{"declaration": "protected theorem StateEqRs.refl (t : Register) (\u03b6 : State) : \u03b6 \u2243[t]/ac \u03b6 := by simp [StateEqRs]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6 : State\n\u22a2 sorry \u2243 [t] / sorry"}, {"line": "simp [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6 : State\n\u22a2 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "protected theorem StateEqRs.symm {t : Register} (\u03b6\u2081 \u03b6\u2082 : State) :\n    \u03b6\u2081 \u2243[t]/ac \u03b6\u2082 \u2192 \u03b6\u2082 \u2243[t]/ac \u03b6\u2081 := by\n  simp_all [StateEqRs]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 : State\n\u22a2 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry"}, {"line": "simp_all [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 : State\n\u22a2 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "protected theorem StateEqRs.trans {t : Register} (\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State) :\n    \u03b6\u2081 \u2243[t]/ac \u03b6\u2082 \u2192 \u03b6\u2082 \u2243[t]/ac \u03b6\u2083 \u2192 \u03b6\u2081 \u2243[t]/ac \u03b6\u2083 := by\n  simp_all [StateEqRs]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State\n\u22a2 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry"}, {"line": "simp_all [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State\n\u22a2 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "theorem card : card (Q n) = 2 ^ n := by simp [Q]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Sensitivity.lean", "context": {"open": ["Bool Finset Fintype Function LinearMap Module Module.DualBases"], "variables": ["(n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nQ : x\u271d\n\u22a2 sorry = 2 ^ n"}, {"line": "simp [Q]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nQ : x\u271d\n\u22a2 sorry () = 2 ^ n"}]}
{"declaration": "example : \u00ac LucasLehmerTest 2 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Examples/MersennePrimes.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acLucasLehmerTest 2"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "example : (mersenne 2).Prime := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Examples/MersennePrimes.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Nat.Prime (mersenne 2)"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem solve_cos2_half {x : \u211d} : cos x ^ 2 = 1 / 2 \u2194 \u2203 k : \u2124, x = (2 * \u2191k + 1) * \u03c0 / 4 := by\n  rw [cos_sq]\n  simp only [add_eq_left]\n  simp only [div_eq_zero_iff]\n  norm_num\n  rw [cos_eq_zero_iff]\n  constructor <;>\n    \u00b7 rintro \u27e8k, h\u27e9\n      use k\n      linarith\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos x ^ 2 = 1 / 2 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "rw [cos_sq]", "tactic_state": "x : \u211d\n\u22a2 1 / 2 + cos (2 * x) / 2 = 1 / 2 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "simp only [add_eq_left]", "tactic_state": "x : \u211d\n\u22a2 cos (2 * x) / 2 = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "simp only [div_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 cos (2 * x) = 0 \u2228 2 = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "norm_num", "tactic_state": "x : \u211d\n\u22a2 cos (2 * x) = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "rw [cos_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 k, 2 * x = (2 * \u2191k + 1) * Real.pi / 2) \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "constructor <;>\n    \u00b7 rintro \u27e8k, h\u27e9\n      use k\n      linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem solve_cos3x_0 {x : \u211d} : cos (3 * x) = 0 \u2194 \u2203 k : \u2124, x = (2 * \u2191k + 1) * \u03c0 / 6 := by\n  rw [cos_eq_zero_iff]\n  refine exists_congr fun k => ?_\n  constructor <;> intro <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (3 * x) = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "rw [cos_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 k, 3 * x = (2 * \u2191k + 1) * Real.pi / 2) \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "refine exists_congr fun k => ?_", "tactic_state": "x : \u211d\nk : \u2124\n\u22a2 3 * x = (2 * \u2191k + 1) * Real.pi / 2 \u2194 x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "constructor <;> intro <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem solve_cos2x_0 {x : \u211d} : cos (2 * x) = 0 \u2194 \u2203 k : \u2124, x = (2 * \u2191k + 1) * \u03c0 / 4 := by\n  rw [cos_eq_zero_iff]\n  refine exists_congr fun k => ?_\n  constructor <;> intro <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real", "Imo1962Q4"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (2 * x) = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "rw [cos_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 k, 2 * x = (2 * \u2191k + 1) * Real.pi / 2) \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "refine exists_congr fun k => ?_", "tactic_state": "x : \u211d\nk : \u2124\n\u22a2 2 * x = (2 * \u2191k + 1) * Real.pi / 2 \u2194 x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "constructor <;> intro <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_sin_pi_div_seven_ne_zero : 2 * sin (\u03c0 / 7) \u2260 0 := by\n  apply mul_ne_zero two_ne_zero (Real.sin_pos_of_pos_of_lt_pi _ _).ne' <;> linarith [pi_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1963Q5.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 * sin (Real.pi / 7) \u2260 0"}, {"line": "apply mul_ne_zero two_ne_zero (Real.sin_pos_of_pos_of_lt_pi _ _).ne' <;> linarith [pi_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_pi_mul_neg_div (a b : \u211d) : sin (\u03c0 * (- a / b)) = - sin (\u03c0 * (a / b)) := by\n  ring_nf\n  exact sin_neg _\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1963Q5.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 sin (Real.pi * (-a / b)) = -sin (Real.pi * (a / b))"}, {"line": "ring_nf", "tactic_state": "a b : \u211d\n\u22a2 sin (-(Real.pi * a * b\u207b\u00b9)) = -sin (Real.pi * a * b\u207b\u00b9)"}, {"line": "exact sin_neg _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo1964_q1b (n : \u2115) : \u00ac7 \u2223 2 ^ n + 1 := by\n  intro h\n  let t := n % 3\n  have : t < 3 := Nat.mod_lt _ (by decide)\n  have H : 2 ^ t + 1 \u2261 0 [MOD 7] := calc\n    2 ^ t + 1 \u2261 2 ^ n + 1 [MOD 7] := by gcongr ?_ + 1; exact (two_pow_mod_seven n).symm\n      _ \u2261 0 [MOD 7] := h.modEq_zero_nat\n  interval_cases t <;> contradiction", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1964Q1.lean", "context": {"open": ["Nat", "Imo1964Q1"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u00ac7 \u2223 2 ^ n + 1"}, {"line": "intro h", "tactic_state": "n : \u2115\nh : 7 \u2223 2 ^ n + 1\n\u22a2 False"}, {"line": "let t := n % 3", "tactic_state": "n : \u2115\nh : 7 \u2223 2 ^ n + 1\nt : \u2115 := n % 3\n\u22a2 False"}, {"line": "have : t < 3 := Nat.mod_lt _ (by decide)", "tactic_state": "n : \u2115\nh : 7 \u2223 2 ^ n + 1\nt : \u2115 := n % 3\nthis : t < 3\n\u22a2 False"}, {"line": "have H : 2 ^ t + 1 \u2261 0 [MOD 7] := calc\n    2 ^ t + 1 \u2261 2 ^ n + 1 [MOD 7] := by gcongr ?_ + 1; exact (two_pow_mod_seven n).symm\n      _ \u2261 0 [MOD 7] := h.modEq_zero_nat", "tactic_state": "n : \u2115\nh : 7 \u2223 2 ^ n + 1\nt : \u2115 := n % 3\nthis : t < 3\nH : 2 ^ t + 1 \u2261 0 [MOD 7]\n\u22a2 False"}, {"line": "interval_cases t <;> contradiction", "tactic_state": "No Goals!"}]}
{"declaration": "theorem left_factor_large {m : \u2124} (n : \u2124) (h : 1 < m) : 1 < (n - m) ^ 2 + m ^ 2 := by nlinarith\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\nh : 1 < m\n\u22a2 1 < (n - m) ^ 2 + m ^ 2"}, {"line": "nlinarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem right_factor_large {m : \u2124} (n : \u2124) (h : 1 < m) : 1 < (n + m) ^ 2 + m ^ 2 := by nlinarith\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\nh : 1 < m\n\u22a2 1 < (n + m) ^ 2 + m ^ 2"}, {"line": "nlinarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_large {m : \u2124} (h : 1 < m) : 1 < m.natAbs := by\n  exact_mod_cast lt_of_lt_of_le h le_natAbs\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\nh : 1 < m\n\u22a2 1 < m.natAbs"}, {"line": "exact_mod_cast lt_of_lt_of_le h le_natAbs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo1972_q5 (f g : \u211d \u2192 \u211d) (hf1 : \u2200 x, \u2200 y, f (x + y) + f (x - y) = 2 * f x * g y)\n    (hf2 : \u2200 y, \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) : \u2016g y\u2016 \u2264 1 := by\n  -- Suppose the conclusion does not hold.\n  by_contra! hneg\n  set S := Set.range fun x => \u2016f x\u2016\n  -- Introduce `k`, the supremum of `f`.\n  let k : \u211d := sSup S\n  -- Show that `\u2016f x\u2016 \u2264 k`.\n  have hk\u2081 : \u2200 x, \u2016f x\u2016 \u2264 k := by\n    have h : BddAbove S := \u27e81, Set.forall_mem_range.mpr hf2\u27e9\n    intro x\n    exact le_csSup h (Set.mem_range_self x)\n  -- Show that `2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k`.\n  have hk\u2082 : \u2200 x, 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k := fun x \u21a6\n    calc\n      2 * (\u2016f x\u2016 * \u2016g y\u2016) = \u20162 * f x * g y\u2016 := by simp [abs_mul, mul_assoc]\n      _ = \u2016f (x + y) + f (x - y)\u2016 := by rw [hf1]\n      _ \u2264 \u2016f (x + y)\u2016 + \u2016f (x - y)\u2016 := norm_add_le _ _\n      _ \u2264 k + k := add_le_add (hk\u2081 _) (hk\u2081 _)\n      _ = 2 * k := (two_mul _).symm\n  set k' := k / \u2016g y\u2016\n  -- Demonstrate that `k' < k` using `hneg`.\n  have H\u2081 : k' < k := by\n    have h\u2081 : 0 < k := by\n      obtain \u27e8x, hx\u27e9 := hf3\n      calc\n        0 < \u2016f x\u2016 := norm_pos_iff.mpr hx\n        _ \u2264 k := hk\u2081 x\n    rw [div_lt_iff\u2080]\n    \u00b7 apply lt_mul_of_one_lt_right h\u2081 hneg\n    \u00b7 exact zero_lt_one.trans hneg\n  -- Demonstrate that `k \u2264 k'` using `hk\u2082`.\n  have H\u2082 : k \u2264 k' := by\n    have h\u2081 : \u2203 x : \u211d, x \u2208 S := by use \u2016f 0\u2016; exact Set.mem_range_self 0\n    have h\u2082 : \u2200 x, \u2016f x\u2016 \u2264 k' := by\n      intro x\n      rw [le_div_iff\u2080]\n      \u00b7 apply (mul_le_mul_left zero_lt_two).mp (hk\u2082 x)\n      \u00b7 exact zero_lt_one.trans hneg\n    apply csSup_le h\u2081\n    rintro y' \u27e8yy, rfl\u27e9\n    exact h\u2082 yy\n  -- Conclude by obtaining a contradiction, `k' < k'`.\n  apply lt_irrefl k'\n  calc\n    k' < k := H\u2081\n    _ \u2264 k' := H\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1972Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\n\u22a2 \u2016g y\u2016 \u2264 1"}, {"line": "by_contra! hneg", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\n\u22a2 False"}, {"line": "set S := Set.range fun x => \u2016f x\u2016", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\n\u22a2 False"}, {"line": "let k : \u211d := sSup S", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\n\u22a2 False"}, {"line": "have hk\u2081 : \u2200 x, \u2016f x\u2016 \u2264 k := sorry", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\n\u22a2 False"}, {"line": "have hk\u2082 : \u2200 x, 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k := fun x \u21a6\n    calc\n      2 * (\u2016f x\u2016 * \u2016g y\u2016) = \u20162 * f x * g y\u2016 := by simp [abs_mul, mul_assoc]\n      _ = \u2016f (x + y) + f (x - y)\u2016 := by rw [hf1]\n      _ \u2264 \u2016f (x + y)\u2016 + \u2016f (x - y)\u2016 := norm_add_le _ _\n      _ \u2264 k + k := add_le_add (hk\u2081 _) (hk\u2081 _)\n      _ = 2 * k := (two_mul _).symm", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\nhk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k\n\u22a2 False"}, {"line": "set k' := k / \u2016g y\u2016", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\nhk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k\nk' : \u211d := k / \u2016g y\u2016\n\u22a2 False"}, {"line": "have H\u2081 : k' < k := sorry", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\nhk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k\nk' : \u211d := k / \u2016g y\u2016\nH\u2081 : k' < k\n\u22a2 False"}, {"line": "have H\u2082 : k \u2264 k' := sorry", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\nhk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k\nk' : \u211d := k / \u2016g y\u2016\nH\u2081 : k' < k\nH\u2082 : k \u2264 k'\n\u22a2 False"}, {"line": "apply lt_irrefl k'", "tactic_state": "f g : \u211d \u2192 \u211d\nhf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y\nhf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1\nhf3 : \u2203 x, f x \u2260 0\ny : \u211d\nhneg : 1 < \u2016g y\u2016\nS : Set \u211d := Set.range fun x => \u2016f x\u2016\nk : \u211d := sSup S\nhk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k\nhk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k\nk' : \u211d := k / \u2016g y\u2016\nH\u2081 : k' < k\nH\u2082 : k \u2264 k'\n\u22a2 k' < k'"}, {"line": "calc\n    k' < k := H\u2081\n    _ \u2264 k' := H\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tedious (m : \u2115) (k : Fin (m + 1)) : m - ((m + 1 - \u2191k) + m) % (m + 1) = \u2191k := by\n  obtain \u27e8k, hk\u27e9 := k\n  rw [Nat.lt_succ_iff] at hk\n  rw [le_iff_exists_add] at hk\n  rcases hk with \u27e8c, rfl\u27e9\n  have : (k + c + 1 - k) + (k + c) = c + (k + c + 1) := by omega\n  rw [Fin.val_mk]\n  rw [this]\n  rw [Nat.add_mod_right]\n  rw [Nat.mod_eq_of_lt]\n  rw [Nat.add_sub_cancel]\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1994Q1.lean", "context": {"open": ["Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nk : Fin (m + 1)\n\u22a2 m - (m + 1 - \u2191k + m) % (m + 1) = \u2191k"}, {"line": "obtain \u27e8k, hk\u27e9 := k", "tactic_state": "case mk\nm k : \u2115\nhk : k < m + 1\n\u22a2 m - (m + 1 - \u2191\u27e8k, hk\u27e9 + m) % (m + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "rw [Nat.lt_succ_iff] at hk", "tactic_state": "case mk\nm k : \u2115\nhk\u271d : k < m + 1\nhk : k \u2264 m\n\u22a2 m - (m + 1 - \u2191\u27e8k, hk\u271d\u27e9 + m) % (m + 1) = \u2191\u27e8k, hk\u271d\u27e9"}, {"line": "rw [le_iff_exists_add] at hk", "tactic_state": "case mk\nm k : \u2115\nhk\u271d : k < m + 1\nhk : \u2203 c, m = k + c\n\u22a2 m - (m + 1 - \u2191\u27e8k, hk\u271d\u27e9 + m) % (m + 1) = \u2191\u27e8k, hk\u271d\u27e9"}, {"line": "rcases hk with \u27e8c, rfl\u27e9", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\n\u22a2 k + c - (k + c + 1 - \u2191\u27e8k, hk\u27e9 + (k + c)) % (k + c + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "have : (k + c + 1 - k) + (k + c) = c + (k + c + 1) := by omega", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - (k + c + 1 - \u2191\u27e8k, hk\u27e9 + (k + c)) % (k + c + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "rw [Fin.val_mk]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - (k + c + 1 - k + (k + c)) % (k + c + 1) = k"}, {"line": "rw [this]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - (c + (k + c + 1)) % (k + c + 1) = k"}, {"line": "rw [Nat.add_mod_right]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - c % (k + c + 1) = k"}, {"line": "rw [Nat.mod_eq_of_lt]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - c = k\n---\ncase mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 c < k + c + 1"}, {"line": "rw [Nat.add_sub_cancel]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 c < k + c + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem A_maps_to_offDiag_judgePair (a : AgreedTriple C J) :\n    a \u2208 A r \u2192 a.judgePair \u2208 Finset.offDiag (@Finset.univ J _) := by simp [A, Finset.mem_offDiag]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1998Q2.lean", "context": {"open": ["scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{C J : Type*} (r : C \u2192 J \u2192 Prop)", "[Fintype J] [Fintype C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u_5\ninst\u271d : Fintype J\nx\u271d\u00b9 : Sort u_1\nAgreedTriple : x\u271d\u00b9\nx\u271d : Sort u_2\nA : x\u271d\na : sorry\n\u22a2 a \u2208 sorry \u2192 sorry \u2208 sorry"}, {"line": "simp [A, Finset.mem_offDiag]", "tactic_state": "J : Type u_5\ninst\u271d : Fintype J\nx\u271d\u00b9 : Sort u_1\nAgreedTriple : x\u271d\u00b9\nx\u271d : Sort u_2\nA : x\u271d\na : sorry\n\u22a2 a \u2208 sorry () \u2192 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem clear_denominators {a b k : \u2115} (ha : 0 < a) (hb : 0 < b) :\n    (b - 1 : \u211a) / (2 * b) \u2264 k / a \u2194 ((b : \u2115) - 1) * a \u2264 k * (2 * b) := by\n  rw [div_le_div_iff\u2080]\n  on_goal 1 => convert Nat.cast_le (\u03b1 := \u211a)\n  all_goals simp [ha, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1998Q2.lean", "context": {"open": ["scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{C J : Type*} (r : C \u2192 J \u2192 Prop)", "[Fintype J] [Fintype C]", "[Fintype J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) / (2 * \u2191b) \u2264 \u2191k / \u2191a \u2194 (b - 1) * a \u2264 k * (2 * b)"}, {"line": "rw [div_le_div_iff\u2080]", "tactic_state": "a b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) * \u2191a \u2264 \u2191k * (2 * \u2191b) \u2194 (b - 1) * a \u2264 k * (2 * b)\n---\ncase hb\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < 2 * \u2191b\n---\ncase hd\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < \u2191a"}, {"line": "on_goal 1 => convert Nat.cast_le (\u03b1 := \u211a)", "tactic_state": "case h.e'_1.h.e'_3\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) * \u2191a = \u2191((b - 1) * a)\n---\ncase h.e'_1.h.e'_4\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 \u2191k * (2 * \u2191b) = \u2191(k * (2 * b))\n---\ncase hb\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < 2 * \u2191b\n---\ncase hd\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < \u2191a"}, {"line": "all_goals simp [ha, hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bound (ha : 0 < a) (hb : 0 < b) (hc : 0 < c) :\n    a ^ 4 / (a ^ 4 + b ^ 4 + c ^ 4) \u2264 a ^ 3 / sqrt ((a ^ 3) ^ 2 + \u21918 * b ^ 3 * c ^ 3) := by\n  rw [div_le_div_iff\u2080 (by positivity) (by positivity)]\n  calc a ^ 4 * sqrt ((a ^ 3) ^ 2 + (8:\u211d) * b ^ 3 * c ^ 3)\n      = a ^ 3 * (a * sqrt ((a ^ 3) ^ 2 + (8:\u211d) * b ^ 3 * c ^ 3)) := by ring\n    _ \u2264 a ^ 3 * (a ^ 4 + b ^ 4 + c ^ 4) := ?_\n  gcongr\n  apply le_of_pow_le_pow_left\u2080 two_ne_zero (by positivity)\n  rw [mul_pow]\n  rw [sq_sqrt (by positivity)]\n  rw [\u2190 sub_nonneg]\n  calc\n    (a ^ 4 + b ^ 4 + c ^ 4) ^ 2 - a ^ 2 * ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)\n      = 2 * (a ^ 2 * (b ^ 2 - c ^ 2)) ^ 2 + (b ^ 4 - c ^ 4) ^ 2 +\n        (2 * (a ^ 2 * b * c - b ^ 2 * c ^ 2)) ^ 2 := by ring\n    _ \u2265 0 := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2001Q2.lean", "context": {"open": ["Real"], "variables": ["{a b c : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a ^ 4 / (a ^ 4 + b ^ 4 + c ^ 4) \u2264 a ^ 3 / \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)"}, {"line": "rw [div_le_div_iff\u2080 (by positivity) (by positivity)]", "tactic_state": "a b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a ^ 4 * \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) \u2264 a ^ 3 * (a ^ 4 + b ^ 4 + c ^ 4)"}, {"line": "calc a ^ 4 * sqrt ((a ^ 3) ^ 2 + (8:\u211d) * b ^ 3 * c ^ 3)\n      = a ^ 3 * (a * sqrt ((a ^ 3) ^ 2 + (8:\u211d) * b ^ 3 * c ^ 3)) := by ring\n    _ \u2264 a ^ 3 * (a ^ 4 + b ^ 4 + c ^ 4) := ?_", "tactic_state": "a b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a ^ 3 * (a * \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)) \u2264 a ^ 3 * (a ^ 4 + b ^ 4 + c ^ 4)"}, {"line": "gcongr", "tactic_state": "case h\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a * \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) \u2264 a ^ 4 + b ^ 4 + c ^ 4"}, {"line": "apply le_of_pow_le_pow_left\u2080 two_ne_zero (by positivity)", "tactic_state": "case h\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 (a * \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)) ^ 2 \u2264 (a ^ 4 + b ^ 4 + c ^ 4) ^ 2"}, {"line": "rw [mul_pow]", "tactic_state": "case h\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a ^ 2 * \u221a((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) ^ 2 \u2264 (a ^ 4 + b ^ 4 + c ^ 4) ^ 2"}, {"line": "rw [sq_sqrt (by positivity)]", "tactic_state": "case h\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 a ^ 2 * ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3) \u2264 (a ^ 4 + b ^ 4 + c ^ 4) ^ 2"}, {"line": "rw [\u2190 sub_nonneg]", "tactic_state": "case h\na b c : \u211d\nha : 0 < a\nhb : 0 < b\nhc : 0 < c\n\u22a2 0 \u2264 (a ^ 4 + b ^ 4 + c ^ 4) ^ 2 - a ^ 2 * ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)"}, {"line": "calc\n    (a ^ 4 + b ^ 4 + c ^ 4) ^ 2 - a ^ 2 * ((a ^ 3) ^ 2 + 8 * b ^ 3 * c ^ 3)\n      = 2 * (a ^ 2 * (b ^ 2 - c ^ 2)) ^ 2 + (b ^ 4 - c ^ 4) ^ 2 +\n        (2 * (a ^ 2 * b * c - b ^ 2 * c ^ 2)) ^ 2 := by ring\n    _ \u2265 0 := by positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem key_insight (x y z : \u211d) (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z \u2265 1) :\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) \u2265 (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) := by\n  have key :\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) -\n        (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) =\n      (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /\n        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) := by\n    field_simp\n    ring\n  have h\u2085 :\n    (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /\n        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) \u2265 0 := by positivity\n  calc\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2)\n      \u2265 (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by linarith only [key, h\u2085]\n    _ \u2265 (x ^ 5 - x ^ 2 * (x * y * z)) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by gcongr\n    _ = (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) := by field_simp; ring\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2005Q3.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : x > 0\nhy : y > 0\nhz : z > 0\nh : x * y * z \u2265 1\n\u22a2 (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) \u2265 (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2)"}, {"line": "have key :\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) -\n        (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) =\n      (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /\n        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) := by\n    field_simp\n    ring", "tactic_state": "x y z : \u211d\nhx : x > 0\nhy : y > 0\nhz : z > 0\nh : x * y * z \u2265 1\nkey :\n  (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) - (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) =\n    (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) / ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)))\n\u22a2 (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) \u2265 (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2)"}, {"line": "have h\u2085 : (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) /\n        ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) \u2265 0 := sorry", "tactic_state": "x y z : \u211d\nhx : x > 0\nhy : y > 0\nhz : z > 0\nh : x * y * z \u2265 1\nkey :\n  (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) - (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) =\n    (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) / ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)))\nh\u2085 : (x ^ 3 - 1) ^ 2 * x ^ 2 * (y ^ 2 + z ^ 2) / ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) \u2265 0\n\u22a2 (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) \u2265 (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2)"}, {"line": "calc\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2)\n      \u2265 (x ^ 5 - x ^ 2 * 1) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by linarith only [key, h\u2085]\n    _ \u2265 (x ^ 5 - x ^ 2 * (x * y * z)) / (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2)) := by gcongr\n    _ = (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) := by field_simp; ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo2005_q3 (x y z : \u211d) (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z \u2265 1) :\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +\n        (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) \u2265\n      0 := by\n  calc\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +\n          (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) \u2265\n        (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) + (y ^ 2 - z * x) / (y ^ 2 + z ^ 2 + x ^ 2) +\n          (z ^ 2 - x * y) / (z ^ 2 + x ^ 2 + y ^ 2) := by\n      gcongr ?_ + ?_ + ?_ <;> apply key_insight <;> linarith\n    _ = 1 / 2 * ((x - y) ^ 2 + (y - z) ^ 2 + (z - x) ^ 2) / (x ^ 2 + y ^ 2 + z ^ 2) := by ring\n    _ \u2265 0 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2005Q3.lean", "context": {"open": ["Imo2005Q3"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : x > 0\nhy : y > 0\nhz : z > 0\nh : x * y * z \u2265 1\n\u22a2 (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +\n      (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) \u2265\n    0"}, {"line": "calc\n    (x ^ 5 - x ^ 2) / (x ^ 5 + y ^ 2 + z ^ 2) + (y ^ 5 - y ^ 2) / (y ^ 5 + z ^ 2 + x ^ 2) +\n          (z ^ 5 - z ^ 2) / (z ^ 5 + x ^ 2 + y ^ 2) \u2265\n        (x ^ 2 - y * z) / (x ^ 2 + y ^ 2 + z ^ 2) + (y ^ 2 - z * x) / (y ^ 2 + z ^ 2 + x ^ 2) +\n          (z ^ 2 - x * y) / (z ^ 2 + x ^ 2 + y ^ 2) := by\n      gcongr ?_ + ?_ + ?_ <;> apply key_insight <;> linarith\n    _ = 1 / 2 * ((x - y) ^ 2 + (y - z) ^ 2 + (z - x) ^ 2) / (x ^ 2 + y ^ 2 + z ^ 2) := by ring\n    _ \u2265 0 := by positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem four_pow_four_pos : (0 : \u211d) < 4 ^ 4 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 4 ^ 4"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_32 : (0 : \u211d) < 32 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 32"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem proof\u2082 (M : \u211d)\n    (h : \u2200 a b c : \u211d,\n      |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264\n        M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2) :\n    9 * sqrt 2 / 32 \u2264 M := by\n  set \u03b1 := sqrt (2:\u211d)\n  have h\u03b1 : \u03b1 ^ 2 = 2 := sq_sqrt (by norm_num)\n  let a := 2 - 3 * \u03b1\n  let c := 2 + 3 * \u03b1\n  calc _ = 18 ^ 2 * 2 * \u03b1 / 48 ^ 2 := by ring\n    _ \u2264 M := ?_\n  rw [div_le_iff\u2080 (by positivity)]\n  calc 18 ^ 2 * 2 * \u03b1\n      = 18 ^ 2 * \u03b1 ^ 2 * \u03b1 := by linear_combination -324 * \u03b1 * h\u03b1\n    _ = abs (-(18 ^ 2 * \u03b1 ^ 2 * \u03b1)) := by rw [abs_neg, abs_of_nonneg]; positivity\n    _ = |a * 2 * (a ^ 2 - 2 ^ 2) + 2 * c * (2 ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| := by ring_nf!\n    _ \u2264 M * (a ^ 2 + 2 ^ 2 + c ^ 2) ^ 2 := by apply h\n    _ = M * 48 ^ 2 := by linear_combination (324 * \u03b1 ^ 2 + 1080) * M * h\u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u22a2 9 * \u221a2 / 32 \u2264 M"}, {"line": "set \u03b1 := sqrt (2:\u211d)", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\n\u22a2 9 * \u03b1 / 32 \u2264 M"}, {"line": "have h\u03b1 : \u03b1 ^ 2 = 2 := sq_sqrt (by norm_num)", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\nh\u03b1 : \u03b1 ^ 2 = 2\n\u22a2 9 * \u03b1 / 32 \u2264 M"}, {"line": "let a := 2 - 3 * \u03b1", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\nh\u03b1 : \u03b1 ^ 2 = 2\na : \u211d := 2 - 3 * \u03b1\n\u22a2 9 * \u03b1 / 32 \u2264 M"}, {"line": "let c := 2 + 3 * \u03b1", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\nh\u03b1 : \u03b1 ^ 2 = 2\na : \u211d := 2 - 3 * \u03b1\nc : \u211d := 2 + 3 * \u03b1\n\u22a2 9 * \u03b1 / 32 \u2264 M"}, {"line": "calc _ = 18 ^ 2 * 2 * \u03b1 / 48 ^ 2 := by ring\n    _ \u2264 M := ?_", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\nh\u03b1 : \u03b1 ^ 2 = 2\na : \u211d := 2 - 3 * \u03b1\nc : \u211d := 2 + 3 * \u03b1\n\u22a2 18 ^ 2 * 2 * \u03b1 / 48 ^ 2 \u2264 M"}, {"line": "rw [div_le_iff\u2080 (by positivity)]", "tactic_state": "M : \u211d\nh :\n  \u2200 (a b c : \u211d),\n    |a * b * (a ^ 2 - b ^ 2) + b * c * (b ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| \u2264 M * (a ^ 2 + b ^ 2 + c ^ 2) ^ 2\n\u03b1 : \u211d := \u221a2\nh\u03b1 : \u03b1 ^ 2 = 2\na : \u211d := 2 - 3 * \u03b1\nc : \u211d := 2 + 3 * \u03b1\n\u22a2 18 ^ 2 * 2 * \u03b1 \u2264 M * 48 ^ 2"}, {"line": "calc 18 ^ 2 * 2 * \u03b1\n      = 18 ^ 2 * \u03b1 ^ 2 * \u03b1 := by linear_combination -324 * \u03b1 * h\u03b1\n    _ = abs (-(18 ^ 2 * \u03b1 ^ 2 * \u03b1)) := by rw [abs_neg, abs_of_nonneg]; positivity\n    _ = |a * 2 * (a ^ 2 - 2 ^ 2) + 2 * c * (2 ^ 2 - c ^ 2) + c * a * (c ^ 2 - a ^ 2)| := by ring_nf!\n    _ \u2264 M * (a ^ 2 + 2 ^ 2 + c ^ 2) ^ 2 := by apply h\n    _ = M * 48 ^ 2 := by linear_combination (324 * \u03b1 ^ 2 + 1080) * M * h\u03b1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subst_abc {x y z : \u211d} (h : x * y * z = 1) :\n    \u2203 a b c : \u211d, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 x = a / b \u2227 y = b / c \u2227 z = c / a := by\n  use x, 1, 1 / y\n  obtain \u27e8\u27e8hx, hy\u27e9, _\u27e9 : (x \u2260 0 \u2227 y \u2260 0) \u2227 z \u2260 0 := by\n    have := h.symm \u25b8 one_ne_zero\n    simpa [not_or] using this\n  have : z * (y * x) = 1 := by rw [\u2190 h]; ac_rfl\n  field_simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2008Q2.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nh : x * y * z = 1\n\u22a2 \u2203 a b c, a \u2260 0 \u2227 b \u2260 0 \u2227 c \u2260 0 \u2227 x = a / b \u2227 y = b / c \u2227 z = c / a"}, {"line": "use x, 1, 1 / y", "tactic_state": "case h\nx y z : \u211d\nh : x * y * z = 1\n\u22a2 x \u2260 0 \u2227 1 \u2260 0 \u2227 1 / y \u2260 0 \u2227 x = x / 1 \u2227 y = 1 / (1 / y) \u2227 z = 1 / y / x"}, {"line": "obtain \u27e8\u27e8hx, hy\u27e9, _\u27e9 : (x \u2260 0 \u2227 y \u2260 0) \u2227 z \u2260 0 := by\n    have := h.symm \u25b8 one_ne_zero\n    simpa [not_or] using this", "tactic_state": "case h.intro.intro\nx y z : \u211d\nh : x * y * z = 1\nright\u271d : z \u2260 0\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 x \u2260 0 \u2227 1 \u2260 0 \u2227 1 / y \u2260 0 \u2227 x = x / 1 \u2227 y = 1 / (1 / y) \u2227 z = 1 / y / x"}, {"line": "have : z * (y * x) = 1 := by rw [\u2190 h]; ac_rfl", "tactic_state": "case h.intro.intro\nx y z : \u211d\nh : x * y * z = 1\nright\u271d : z \u2260 0\nhx : x \u2260 0\nhy : y \u2260 0\nthis : z * (y * x) = 1\n\u22a2 x \u2260 0 \u2227 1 \u2260 0 \u2227 1 / y \u2260 0 \u2227 x = x / 1 \u2227 y = 1 / (1 / y) \u2227 z = 1 / y / x"}, {"line": "field_simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem p_lemma (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) :\n    \u2203 n : \u2115, p \u2223 n ^ 2 + 1 \u2227 (p : \u211d) > 2 * n + sqrt (2 * n) := by\n  haveI := Fact.mk hpp\n  have hp_mod_4_ne_3 : p % 4 \u2260 3 := by linarith [show p % 4 = 1 from hp_mod_4_eq_1]\n  obtain \u27e8y, hy\u27e9 := ZMod.exists_sq_eq_neg_one_iff.mpr hp_mod_4_ne_3\n  let m := ZMod.valMinAbs y\n  let n := Int.natAbs m\n  have hnat\u2081 : p \u2223 n ^ 2 + 1 := by\n    refine Int.natCast_dvd_natCast.mp ?_\n    simp only [n]\n    simp only [Int.natAbs_sq]\n    simp only [Int.natCast_pow]\n    simp only [Int.natCast_succ]\n    simp only [Int.natCast_dvd_natCast.mp]\n    refine (ZMod.intCast_zmod_eq_zero_iff_dvd (m ^ 2 + 1) p).mp ?_\n    simp only [m]\n    simp only [Int.cast_pow]\n    simp only [Int.cast_add]\n    simp only [Int.cast_one]\n    simp only [ZMod.coe_valMinAbs]\n    rw [pow_two]; exact neg_add_cancel 1\n    rw [\u2190 hy]; exact neg_add_cancel 1\n  have hnat\u2082 : n \u2264 p / 2 := ZMod.natAbs_valMinAbs_le y\n  have hnat\u2083 : p \u2265 2 * n := by omega\n  set k : \u2115 := p - 2 * n with hnat\u2084\n  have hnat\u2085 : p \u2223 k ^ 2 + 4 := by\n    obtain \u27e8x, hx\u27e9 := hnat\u2081\n    have : (p : \u2124) \u2223 (k : \u2124) ^ 2 + 4 := by\n      use (p : \u2124) - 4 * n + 4 * x\n      have hcast\u2081 : (k : \u2124) = p - 2 * n := by assumption_mod_cast\n      have hcast\u2082 : (n : \u2124) ^ 2 + 1 = p * x := by assumption_mod_cast\n      linear_combination ((k : \u2124) + p - 2 * n) * hcast\u2081 + 4 * hcast\u2082\n    assumption_mod_cast\n  have hnat\u2086 : k ^ 2 + 4 \u2265 p := Nat.le_of_dvd (k ^ 2 + 3).succ_pos hnat\u2085\n  have hreal\u2081 : (k : \u211d) = p - 2 * n := by assumption_mod_cast\n  have hreal\u2082 : (p : \u211d) > 20 := by assumption_mod_cast\n  have hreal\u2083 : (k : \u211d) ^ 2 + 4 \u2265 p := by assumption_mod_cast\n  have hreal\u2085 : (k : \u211d) > 4 := by\n    refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    linarith only [hreal\u2082, hreal\u2083]\n  have hreal\u2086 : (k : \u211d) > sqrt (2 * n) := by\n    refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    rw [sq_sqrt (mul_nonneg zero_le_two n.cast_nonneg)]\n    linarith only [hreal\u2081, hreal\u2083, hreal\u2085]\n  exact \u27e8n, hnat\u2081, by linarith only [hreal\u2086, hreal\u2081]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2008Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "haveI := Fact.mk hpp", "tactic_state": "p : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hp_mod_4_ne_3 : p % 4 \u2260 3 := sorry", "tactic_state": "p : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "obtain \u27e8y, hy\u27e9 := ZMod.exists_sq_eq_neg_one_iff.mpr hp_mod_4_ne_3", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "let m := ZMod.valMinAbs y", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "let n := Int.natAbs m", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hnat\u2081 : p \u2223 n ^ 2 + 1 := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hnat\u2082 : n \u2264 p / 2 := ZMod.natAbs_valMinAbs_le y", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hnat\u2083 : p \u2265 2 * n := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "set k : \u2115 := p - 2 * n with hnat\u2084", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hnat\u2085 : p \u2223 k ^ 2 + 4 := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hnat\u2086 : k ^ 2 + 4 \u2265 p := Nat.le_of_dvd (k ^ 2 + 3).succ_pos hnat\u2085", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hreal\u2081 : (k : \u211d) = p - 2 * n := by assumption_mod_cast", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\nhreal\u2081 : \u2191k = \u2191p - 2 * \u2191n\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hreal\u2082 : (p : \u211d) > 20 := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\nhreal\u2081 : \u2191k = \u2191p - 2 * \u2191n\nhreal\u2082 : \u2191p > 20\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hreal\u2083 : (k : \u211d) ^ 2 + 4 \u2265 p := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\nhreal\u2081 : \u2191k = \u2191p - 2 * \u2191n\nhreal\u2082 : \u2191p > 20\nhreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hreal\u2085 : (k : \u211d) > 4 := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\nhreal\u2081 : \u2191k = \u2191p - 2 * \u2191n\nhreal\u2082 : \u2191p > 20\nhreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p\nhreal\u2085 : \u2191k > 4\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "have hreal\u2086 : (k : \u211d) > sqrt (2 * n) := sorry", "tactic_state": "case intro\np : \u2115\nhpp : Nat.Prime p\nhp_mod_4_eq_1 : p \u2261 1 [MOD 4]\nhp_gt_20 : p > 20\nthis : Fact (Nat.Prime p)\nhp_mod_4_ne_3 : p % 4 \u2260 3\ny : ZMod p\nhy : -1 = y * y\nm : \u2124 := y.valMinAbs\nn : \u2115 := m.natAbs\nhnat\u2081 : p \u2223 n ^ 2 + 1\nhnat\u2082 : n \u2264 p / 2\nhnat\u2083 : p \u2265 2 * n\nk : \u2115 := p - 2 * n\nhnat\u2084 : k = p - 2 * n\nhnat\u2085 : p \u2223 k ^ 2 + 4\nhnat\u2086 : k ^ 2 + 4 \u2265 p\nhreal\u2081 : \u2191k = \u2191p - 2 * \u2191n\nhreal\u2082 : \u2191p > 20\nhreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p\nhreal\u2085 : \u2191k > 4\nhreal\u2086 : \u2191k > \u221a(2 * \u2191n)\n\u22a2 \u2203 n, p \u2223 n ^ 2 + 1 \u2227 \u2191p > 2 * \u2191n + \u221a(2 * \u2191n)"}, {"line": "exact \u27e8n, hnat\u2081, by linarith only [hreal\u2086, hreal\u2081]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_eq_one_of_pow_eq_one (x : \u211d) (n : \u2115) (hn : n \u2260 0) (h : x ^ n = 1) : |x| = 1 := by\n  rw [\u2190 pow_left_inj\u2080 (abs_nonneg x) zero_le_one hn]\n  rw [one_pow]\n  rw [pow_abs]\n  rw [h]\n  rw [abs_one]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2008Q4.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |x| = 1"}, {"line": "rw [\u2190 pow_left_inj\u2080 (abs_nonneg x) zero_le_one hn]", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |x| ^ n = 1 ^ n"}, {"line": "rw [one_pow]", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |x| ^ n = 1"}, {"line": "rw [pow_abs]", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |x ^ n| = 1"}, {"line": "rw [h]", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |1| = 1"}, {"line": "rw [abs_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo2011_q5 (f : \u2124 \u2192 \u2124) (hpos : \u2200 n : \u2124, 0 < f n) (hdvd : \u2200 m n : \u2124, f (m - n) \u2223 f m - f n) :\n    \u2200 m n : \u2124, f m \u2264 f n \u2192 f m \u2223 f n := by\n  intro m n h_fm_le_fn\n  rcases lt_or_eq_of_le h_fm_le_fn with h_fm_lt_fn | h_fm_eq_fn\n  \u00b7 -- m < n\n    let d := f m - f (m - n)\n    have h_fn_dvd_d : f n \u2223 d := by\n      rw [\u2190 sub_sub_self m n]\n      exact hdvd m (m - n)\n    have h_d_lt_fn : d < f n := calc\n      d < f m := sub_lt_self _ (hpos (m - n))\n      _ < f n := h_fm_lt_fn\n    have h_neg_d_lt_fn : -d < f n := by\n      calc\n        -d = f (m - n) - f m := neg_sub _ _\n        _ < f (m - n) := sub_lt_self _ (hpos m)\n        _ \u2264 f n - f m := le_of_dvd (sub_pos.mpr h_fm_lt_fn) ?_\n        _ < f n := sub_lt_self _ (hpos m)\n      -- \u22a2 f (m - n) \u2223 f n - f m\n      rw [\u2190 Int.dvd_neg]\n      rw [neg_sub]\n      exact hdvd m n\n    have h_d_eq_zero : d = 0 := by\n      obtain hd | hd | hd : d > 0 \u2228 d = 0 \u2228 d < 0 := trichotomous d 0\n      \u00b7 -- d > 0\n        have h\u2081 : f n \u2264 d := le_of_dvd hd h_fn_dvd_d\n        have h\u2082 : \u00acf n \u2264 d := not_le.mpr h_d_lt_fn\n        contradiction\n      \u00b7 -- d = 0\n        exact hd\n      \u00b7 -- d < 0\n        have h\u2081 : f n \u2264 -d := le_of_dvd (neg_pos.mpr hd) h_fn_dvd_d.neg_right\n        have h\u2082 : \u00acf n \u2264 -d := not_le.mpr h_neg_d_lt_fn\n        contradiction\n    have h\u2081 : f m = f (m - n) := sub_eq_zero.mp h_d_eq_zero\n    have h\u2082 : f (m - n) \u2223 f m - f n := hdvd m n\n    rw [\u2190 h\u2081] at h\u2082\n    exact (dvd_iff_dvd_of_dvd_sub h\u2082).mp dvd_rfl\n  \u00b7 -- m = n\n    rw [h_fm_eq_fn]", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2011Q5.lean", "context": {"open": ["Int"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2124\nhpos : \u2200 (n : \u2124), 0 < f n\nhdvd : \u2200 (m n : \u2124), f (m - n) \u2223 f m - f n\n\u22a2 \u2200 (m n : \u2124), f m \u2264 f n \u2192 f m \u2223 f n"}, {"line": "intro m n h_fm_le_fn", "tactic_state": "f : \u2124 \u2192 \u2124\nhpos : \u2200 (n : \u2124), 0 < f n\nhdvd : \u2200 (m n : \u2124), f (m - n) \u2223 f m - f n\nm n : \u2124\nh_fm_le_fn : f m \u2264 f n\n\u22a2 f m \u2223 f n"}, {"line": "rcases lt_or_eq_of_le h_fm_le_fn with h_fm_lt_fn | h_fm_eq_fn", "tactic_state": "case inl\nf : \u2124 \u2192 \u2124\nhpos : \u2200 (n : \u2124), 0 < f n\nhdvd : \u2200 (m n : \u2124), f (m - n) \u2223 f m - f n\nm n : \u2124\nh_fm_le_fn : f m \u2264 f n\nh_fm_lt_fn : f m < f n\n\u22a2 f m \u2223 f n\n---\ncase inr\nf : \u2124 \u2192 \u2124\nhpos : \u2200 (n : \u2124), 0 < f n\nhdvd : \u2200 (m n : \u2124), f (m - n) \u2223 f m - f n\nm n : \u2124\nh_fm_le_fn : f m \u2264 f n\nh_fm_eq_fn : f m = f n\n\u22a2 f m \u2223 f n"}, {"line": "\u00b7 -- m < n\n    let d := f m - f (m - n)\n    have h_fn_dvd_d : f n \u2223 d := by\n      rw [\u2190 sub_sub_self m n]\n      exact hdvd m (m - n)\n    have h_d_lt_fn : d < f n := calc\n      d < f m := sub_lt_self _ (hpos (m - n))\n      _ < f n := h_fm_lt_fn\n    have h_neg_d_lt_fn : -d < f n := by\n      calc\n        -d = f (m - n) - f m := neg_sub _ _\n        _ < f (m - n) := sub_lt_self _ (hpos m)\n        _ \u2264 f n - f m := le_of_dvd (sub_pos.mpr h_fm_lt_fn) ?_\n        _ < f n := sub_lt_self _ (hpos m)\n      rw [\u2190 Int.dvd_neg]\n      rw [neg_sub]\n      exact hdvd m n\n    have h_d_eq_zero : d = 0 := by\n      obtain hd | hd | hd : d > 0 \u2228 d = 0 \u2228 d < 0 := trichotomous d 0\n      \u00b7 -- d > 0\n        have h\u2081 : f n \u2264 d := le_of_dvd hd h_fn_dvd_d\n        have h\u2082 : \u00acf n \u2264 d := not_le.mpr h_d_lt_fn\n        contradiction\n      \u00b7 -- d = 0\n        exact hd\n      \u00b7 -- d < 0\n        have h\u2081 : f n \u2264 -d := le_of_dvd (neg_pos.mpr hd) h_fn_dvd_d.neg_right\n        have h\u2082 : \u00acf n \u2264 -d := not_le.mpr h_neg_d_lt_fn\n        contradiction\n    have h\u2081 : f m = f (m - n) := sub_eq_zero.mp h_d_eq_zero\n    have h\u2082 : f (m - n) \u2223 f m - f n := hdvd m n\n    rw [\u2190 h\u2081] at h\u2082\n    exact (dvd_iff_dvd_of_dvd_sub h\u2082).mp dvd_rfl", "tactic_state": "case inr\nf : \u2124 \u2192 \u2124\nhpos : \u2200 (n : \u2124), 0 < f n\nhdvd : \u2200 (m n : \u2124), f (m - n) \u2223 f m - f n\nm n : \u2124\nh_fm_le_fn : f m \u2264 f n\nh_fm_eq_fn : f m = f n\n\u22a2 f m \u2223 f n"}, {"line": "\u00b7 -- m = n\n    rw [h_fm_eq_fn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo2020_q2 (a b c d : \u211d) (hd0 : 0 < d) (hdc : d \u2264 c) (hcb : c \u2264 b) (hba : b \u2264 a)\n    (h1 : a + b + c + d = 1) : (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d < 1 := by\n  have hp : a ^ a * b ^ b * c ^ c * d ^ d \u2264 a * a + b * b + c * c + d * d := by\n    refine geom_mean_le_arith_mean4_weighted ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ h1 <;> linarith\n  calc\n    (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d =\n        (a + 2 * b + 3 * c + 4 * d) * (a ^ a * b ^ b * c ^ c * d ^ d) := by ac_rfl\n    _ \u2264 (a + 2 * b + 3 * c + 4 * d) * (a * a + b * b + c * c + d * d) := by gcongr; linarith\n    _ = (a + 2 * b + 3 * c + 4 * d) * a ^ 2 + (a + 2 * b + 3 * c + 4 * d) * b ^ 2\n        + (a + 2 * b + 3 * c + 4 * d) * c ^ 2 + (a + 2 * b + 3 * c + 4 * d) * d ^ 2 := by ring\n    _ \u2264 (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2\n        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2 := by\n        gcongr ?_ * _ + ?_ * _ + ?_ * _ + ?_ * _ <;> linarith\n    _ < (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2\n        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2\n        + (6 * a * b * c + 6 * a * b * d + 6 * a * c * d + 6 * b * c * d) :=\n        (lt_add_of_pos_right _ (by apply_rules [add_pos, mul_pos, zero_lt_one] <;> linarith))\n    _ = (a + b + c + d) ^ 3 := by ring\n    _ = 1 := by simp [h1]", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2020Q2.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u211d\nhd0 : 0 < d\nhdc : d \u2264 c\nhcb : c \u2264 b\nhba : b \u2264 a\nh1 : a + b + c + d = 1\n\u22a2 (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d < 1"}, {"line": "have hp : a ^ a * b ^ b * c ^ c * d ^ d \u2264 a * a + b * b + c * c + d * d := sorry", "tactic_state": "a b c d : \u211d\nhd0 : 0 < d\nhdc : d \u2264 c\nhcb : c \u2264 b\nhba : b \u2264 a\nh1 : a + b + c + d = 1\nhp : a ^ a * b ^ b * c ^ c * d ^ d \u2264 a * a + b * b + c * c + d * d\n\u22a2 (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d < 1"}, {"line": "calc\n    (a + 2 * b + 3 * c + 4 * d) * a ^ a * b ^ b * c ^ c * d ^ d =\n        (a + 2 * b + 3 * c + 4 * d) * (a ^ a * b ^ b * c ^ c * d ^ d) := by ac_rfl\n    _ \u2264 (a + 2 * b + 3 * c + 4 * d) * (a * a + b * b + c * c + d * d) := by gcongr; linarith\n    _ = (a + 2 * b + 3 * c + 4 * d) * a ^ 2 + (a + 2 * b + 3 * c + 4 * d) * b ^ 2\n        + (a + 2 * b + 3 * c + 4 * d) * c ^ 2 + (a + 2 * b + 3 * c + 4 * d) * d ^ 2 := by ring\n    _ \u2264 (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2\n        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2 := by\n        gcongr ?_ * _ + ?_ * _ + ?_ * _ + ?_ * _ <;> linarith\n    _ < (a + 3 * b + 3 * c + 3 * d) * a ^ 2 + (3 * a + b + 3 * c + 3 * d) * b ^ 2\n        + (3 * a + 3 * b + c + 3 * d) * c ^ 2 + (3 * a + 3 * b + 3 * c + d) * d ^ 2\n        + (6 * a * b * c + 6 * a * b * d + 6 * a * c * d + 6 * b * c * d) :=\n        (lt_add_of_pos_right _ (by apply_rules [add_pos, mul_pos, zero_lt_one] <;> linarith))\n    _ = (a + b + c + d) ^ 3 := by ring\n    _ = 1 := by simp [h1]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_pow_iff_of_dvd_sub {a b d n : \u2115} {z : \u2124} (ha : a.Coprime d)\n    (hd : (\u03c6 d : \u2124) \u2223 (n : \u2124) - z) :\n    d \u2223 a ^ n + b \u2194 (((ZMod.unitOfCoprime _ ha) ^ z : (ZMod d)\u02e3) : ZMod d) + b = 0 := by\n  rcases hd with \u27e8k, hk\u27e9\n  rw [\u2190 ZMod.natCast_zmod_eq_zero_iff_dvd]\n  convert Iff.rfl\n  push_cast\n  congr\n  suffices (((ZMod.unitOfCoprime _ ha) ^ z : (ZMod d)\u02e3) : ZMod d) =\n      (((ZMod.unitOfCoprime _ ha) ^ (n : \u2124) : (ZMod d)\u02e3) : ZMod d) by\n    convert this\n  rw [sub_eq_iff_eq_add] at hk\n  rw [hk]\n  rw [zpow_add]\n  rw [zpow_mul]\n  norm_cast\n  rw [ZMod.pow_totient]\n  rw [one_zpow]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b d n : \u2115\nz : \u2124\nha : a.Coprime d\nhd : \u2191d.totient \u2223 \u2191n - z\n\u22a2 d \u2223 a ^ n + b \u2194 \u2191(ZMod.unitOfCoprime a ha ^ z) + \u2191b = 0"}, {"line": "rcases hd with \u27e8k, hk\u27e9", "tactic_state": "case intro\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 d \u2223 a ^ n + b \u2194 \u2191(ZMod.unitOfCoprime a ha ^ z) + \u2191b = 0"}, {"line": "rw [\u2190 ZMod.natCast_zmod_eq_zero_iff_dvd]", "tactic_state": "case intro\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 \u2191(a ^ n + b) = 0 \u2194 \u2191(ZMod.unitOfCoprime a ha ^ z) + \u2191b = 0"}, {"line": "convert Iff.rfl", "tactic_state": "case h.e'_2.h.e'_2\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) + \u2191b = \u2191(a ^ n + b)"}, {"line": "push_cast", "tactic_state": "case h.e'_2.h.e'_2\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) + \u2191b = \u2191a ^ n + \u2191b"}, {"line": "congr", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191a ^ n"}, {"line": "suffices (((ZMod.unitOfCoprime _ ha) ^ z : (ZMod d)\u02e3) : ZMod d) =\n      (((ZMod.unitOfCoprime _ ha) ^ (n : \u2124) : (ZMod d)\u02e3) : ZMod d) by\n    convert this", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n - z = \u2191d.totient * k\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191(ZMod.unitOfCoprime a ha ^ \u2191n)"}, {"line": "rw [sub_eq_iff_eq_add] at hk", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191(ZMod.unitOfCoprime a ha ^ \u2191n)"}, {"line": "rw [hk]", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191(ZMod.unitOfCoprime a ha ^ (\u2191d.totient * k + z))"}, {"line": "rw [zpow_add]", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191(ZMod.unitOfCoprime a ha ^ (\u2191d.totient * k) * ZMod.unitOfCoprime a ha ^ z)"}, {"line": "rw [zpow_mul]", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 \u2191(ZMod.unitOfCoprime a ha ^ z) = \u2191((ZMod.unitOfCoprime a ha ^ \u2191d.totient) ^ k * ZMod.unitOfCoprime a ha ^ z)"}, {"line": "norm_cast", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 ZMod.unitOfCoprime a ha ^ z = (ZMod.unitOfCoprime a ha ^ d.totient) ^ k * ZMod.unitOfCoprime a ha ^ z"}, {"line": "rw [ZMod.pow_totient]", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 ZMod.unitOfCoprime a ha ^ z = 1 ^ k * ZMod.unitOfCoprime a ha ^ z"}, {"line": "rw [one_zpow]", "tactic_state": "case h.e'_2.h.e'_2.e_a\na b d n : \u2115\nz : \u2124\nha : a.Coprime d\nk : \u2124\nhk : \u2191n = \u2191d.totient * k + z\n\u22a2 ZMod.unitOfCoprime a ha ^ z = 1 * ZMod.unitOfCoprime a ha ^ z"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma a_coprime_ab_add_one : a.Coprime (a * b + 1) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 a.Coprime (a * b + 1)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_large_n_sub_neg_one : (\u03c6 (a * b + 1) : \u2124) \u2223 (h.large_n : \u2124) - (-1 : \u2124) := by\n  simp [large_n]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry - -1"}, {"line": "simp [large_n]", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry () + 1"}]}
{"declaration": "lemma dvd_large_n_0_sub_zero : (\u03c6 (a * b + 1) : \u2124) \u2223 (h.large_n_0 : \u2124) - (0 : \u2124) := by\n  simp [large_n_0]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry - 0"}, {"line": "simp [large_n_0]", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry ()"}]}
{"declaration": "lemma ab_add_one_dvd_b_add_one : a * b + 1 \u2223 b + 1 := by\n  rw [add_comm b]\n  suffices a * b + 1 \u2223 a ^ h.large_n_0 + b by\n    rw [dvd_pow_iff_of_dvd_sub a_coprime_ab_add_one h.dvd_large_n_0_sub_zero] at this\n    rw [zpow_zero] at this\n    rw [\u2190 ZMod.natCast_zmod_eq_zero_iff_dvd]\n    push_cast\n    norm_cast at this\n  exact h.ab_add_one_dvd_a_pow_large_n_0_add_b\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 a * b + 1 \u2223 b + 1"}, {"line": "rw [add_comm b]", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 a * b + 1 \u2223 1 + b"}, {"line": "suffices a * b + 1 \u2223 a ^ h.large_n_0 + b by\n    rw [dvd_pow_iff_of_dvd_sub a_coprime_ab_add_one h.dvd_large_n_0_sub_zero] at this\n    rw [zpow_zero] at this\n    rw [\u2190 ZMod.natCast_zmod_eq_zero_iff_dvd]\n    push_cast\n    norm_cast at this", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 a * b + 1 \u2223 a ^ sorry + b"}, {"line": "exact h.ab_add_one_dvd_a_pow_large_n_0_add_b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_two_mul_sub_one_le_one : sqrt (2 * x - 1) \u2264 1 \u2194 x \u2264 1 := by\n  simp [sqrt_le_iff, \u2190 two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1959Q2.lean", "context": {"open": ["Set Real"], "variables": ["{x A : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u221a(2 * x - 1) \u2264 1 \u2194 x \u2264 1"}, {"line": "simp [sqrt_le_iff, \u2190 two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGood_sqrt2_iff : IsGood x (sqrt 2) \u2194 x \u2208 Icc (1 / 2) 1 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 (isGood_iff_eq_sqrt_two h).2 rfl\u27e9\n  exact \u27e8h.one_half_le, not_lt.1 fun h\u2081 \u21a6 (h.sqrt_two_lt_of_one_lt h\u2081).false\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1959Q2.lean", "context": {"open": ["Set Real"], "variables": ["{x A : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nIsGood : x\u271d\n\u22a2 sorry \u2194 x \u2208 Icc (1 / 2) 1"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 (isGood_iff_eq_sqrt_two h).2 rfl\u27e9", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nIsGood : x\u271d\nh : sorry\n\u22a2 x \u2208 Icc (1 / 2) 1"}, {"line": "exact \u27e8h.one_half_le, not_lt.1 fun h\u2081 \u21a6 (h.sqrt_two_lt_of_one_lt h\u2081).false\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ge_100 {n : \u2115} (h1 : ProblemPredicate n) : 100 \u2264 n := by\n  have h2 : 10 ^ 3 \u2264 10 * n := by\n    rw [\u2190 h1.left]\n    refine Nat.base_pow_length_digits_le 10 n ?_ (not_zero h1)\n    simp\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1960Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nn : \u2115\nh1 : sorry\n\u22a2 100 \u2264 n"}, {"line": "have h2 : 10 ^ 3 \u2264 10 * n := sorry", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nn : \u2115\nh1 : sorry\nh2 : 10 ^ 3 \u2264 10 * n\n\u22a2 100 \u2264 n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_1000 {n : \u2115} (h1 : ProblemPredicate n) : n < 1000 := by\n  have h2 : n < 10 ^ 3 := by\n    rw [\u2190 h1.left]\n    refine Nat.lt_base_pow_length_digits ?_\n    simp\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1960Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nn : \u2115\nh1 : sorry\n\u22a2 n < 1000"}, {"line": "have h2 : n < 10 ^ 3 := sorry", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nn : \u2115\nh1 : sorry\nh2 : n < 10 ^ 3\n\u22a2 n < 1000"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma helper_5_digits {c : \u2124} (hc : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)) : c = 15384 := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2124\nhc : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)\n\u22a2 c = 15384"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma case_5_digits {c n : \u2115} (hc : (digits 10 c).length = 5) (hpp : ProblemPredicate' c n) :\n    c = 15384 := by\n  have hpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [hc]\n  have hmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6) := by rw [hpow, hpp.right, hpp.left]\n  zify at *\n  exact helper_5_digits hmul\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\n\u22a2 c = 15384"}, {"line": "have hpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [hc]", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\nhpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c\n\u22a2 c = 15384"}, {"line": "have hmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6) := by rw [hpow, hpp.right, hpp.left]", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\nhpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c\nhmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)\n\u22a2 c = 15384"}, {"line": "zify at *", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhpp : sorry\nhc : \u2191(digits 10 c).length = 5\nhpow : 6 * 10 ^ 5 + \u2191c = 6 * 10 ^ (digits 10 c).length + \u2191c\nhmul : 6 * 10 ^ 5 + \u2191c = 4 * (10 * \u2191c + 6)\n\u22a2 \u2191c = 15384"}, {"line": "exact helper_5_digits hmul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem m_le_n {m n : \u2124} (h1 : ProblemPredicate N m n) : m \u2264 n := by\n  by_contra h2\n  have h3 : 1 = (n * (n - m) - m ^ 2) ^ 2 := by linear_combination - h1.eq_one\n  have h4 : n * (n - m) - m ^ 2 < -1 := by nlinarith [h1.n_range.left]\n  have h5 : 1 < (n * (n - m) - m ^ 2) ^ 2 := by nlinarith\n  exact h5.ne h3\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1981Q3.lean", "context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\n\u22a2 m \u2264 n"}, {"line": "by_contra h2", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\n\u22a2 False"}, {"line": "have h3 : 1 = (n * (n - m) - m ^ 2) ^ 2 := by linear_combination - h1.eq_one", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\n\u22a2 False"}, {"line": "have h4 : n * (n - m) - m ^ 2 < -1 := sorry", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\nh4 : n * (n - m) - m ^ 2 < -1\n\u22a2 False"}, {"line": "have h5 : 1 < (n * (n - m) - m ^ 2) ^ 2 := sorry", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\nh4 : n * (n - m) - m ^ 2 < -1\nh5 : 1 < (n * (n - m) - m ^ 2) ^ 2\n\u22a2 False"}, {"line": "exact h5.ne h3", "tactic_state": "No Goals!"}]}
{"declaration": "lemma part_1 : 660 \u2264 f (1980) := by\n  exact hf.le_mul_three_apply 660\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1982Q1.lean", "context": {"open": [], "variables": ["{f : \u2115+ \u2192 \u2115} (hf : IsGood f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsGood : ?m.427\nf\u271d : \u2115+ \u2192 \u2115\nhf : sorry\nf : \u2115+ \u2192 \u2115\n\u22a2 660 \u2264 f 1980"}, {"line": "exact hf.le_mul_three_apply 660", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ineq (h0 : x 0 = 1) (hp : \u2200 k, 0 < x k) :\n    4 * n / (n + 1) \u2264 \u2211 k \u2208 range (n + 1), x k ^ 2 / x (k + 1) := by\n  calc\n    -- We first use AM-GM.\n    _ \u2264 (\u2211 k \u2208 range n, x (k + 1) + 1) ^ 2 / (\u2211 k \u2208 range n, x (k + 1)) * n / (n + 1) := by\n      gcongr\n      rw [le_div_iff\u2080]\n      \u00b7 simpa using four_mul_le_sq_add (\u2211 k \u2208 range n, x (k + 1)) 1\n      \u00b7 exact sum_pos (fun k _ \u21a6 hp _) (nonempty_range_iff.2 hn)\n    -- We move the fraction into the denominator.\n    _ = (\u2211 k \u2208 range n, x (k + 1) + 1) ^ 2 / ((\u2211 k \u2208 range n, x (k + 1)) * (1 + 1 / n)) := by\n      field_simp\n    -- We make use of the `le_avg` lemma.\n    _ \u2264 (\u2211 k \u2208 range (n + 1), x k) ^ 2 / \u2211 k \u2208 range (n + 1), x (k + 1) := by\n      gcongr\n      \u00b7 exact sum_pos (fun k _ \u21a6 hp _) nonempty_range_succ\n      \u00b7 exact add_nonneg (sum_nonneg fun k _ \u21a6 (hp _).le) zero_le_one\n      \u00b7 rw [sum_range_succ', h0]\n      \u00b7 exact le_avg hn (hx.comp_monotone @Nat.succ_le_succ)\n    -- We conclude by Sedrakyan.\n    _ \u2264 _ := sq_sum_div_le_sum_sq_div _ x fun k _ \u21a6 hp (k + 1)\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1982Q3.lean", "context": {"open": ["Finset NNReal"], "variables": ["{x : \u2115 \u2192 \u211d} {n : \u2115} (hn : n \u2260 0) (hx : Antitone x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115 \u2192 \u211d\nn : \u2115\nh0 : x 0 = 1\nhp : \u2200 (k : \u2115), 0 < x k\n\u22a2 4 * \u2191n / (\u2191n + 1) \u2264 \u2211 k \u2208 range (n + 1), x k ^ 2 / x (k + 1)"}, {"line": "calc\n    _ \u2264 (\u2211 k \u2208 range n, x (k + 1) + 1) ^ 2 / (\u2211 k \u2208 range n, x (k + 1)) * n / (n + 1) := by\n      gcongr\n      rw [le_div_iff\u2080]\n      \u00b7 simpa using four_mul_le_sq_add (\u2211 k \u2208 range n, x (k + 1)) 1\n      \u00b7 exact sum_pos (fun k _ \u21a6 hp _) (nonempty_range_iff.2 hn)\n    _ = (\u2211 k \u2208 range n, x (k + 1) + 1) ^ 2 / ((\u2211 k \u2208 range n, x (k + 1)) * (1 + 1 / n)) := by\n      field_simp\n    _ \u2264 (\u2211 k \u2208 range (n + 1), x k) ^ 2 / \u2211 k \u2208 range (n + 1), x (k + 1) := by\n      gcongr\n      \u00b7 exact sum_pos (fun k _ \u21a6 hp _) nonempty_range_succ\n      \u00b7 exact add_nonneg (sum_nonneg fun k _ \u21a6 (hp _).le) zero_le_one\n      \u00b7 rw [sum_range_succ', h0]\n      \u00b7 exact le_avg hn (hx.comp_monotone @Nat.succ_le_succ)\n    _ \u2264 _ := sq_sum_div_le_sum_sq_div _ x fun k _ \u21a6 hp (k + 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_ne_zero_iff : f x \u2260 0 \u2194 x < 2 := by simp [hf.map_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1986Q5.lean", "context": {"open": ["NNReal"], "variables": ["{f : \u211d\u22650 \u2192 \u211d\u22650} (hf : IsGood f) {x y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsGood : ?m.434\nf\u271d : NNReal \u2192 NNReal\nhf : sorry\nx\u271d y : NNReal\nf : NNReal \u2192 NNReal\nx : NNReal\n\u22a2 f x \u2260 0 \u2194 x < 2"}, {"line": "simp [hf.map_eq_zero]", "tactic_state": "IsGood : ?m.434\nf\u271d : NNReal \u2192 NNReal\nhf : sorry\nx\u271d y : NNReal\nf : NNReal \u2192 NNReal\nx : NNReal\n\u22a2 \u00acf x = 0 \u2194 x < 2"}]}
{"declaration": "theorem main\u2080 (n : \u2115) : \u2211 k \u2208 range (n + 1), k * p (Fin n) k = n * (n - 1)! := by\n  simpa using main_fintype (Fin n)\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo1987Q1.lean", "context": {"open": ["scoped Nat", "Equiv Fintype Function", "Finset (range sum_const)", "Set (Iic)"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\np : x\u271d\nn : \u2115\n\u22a2 \u2211 k \u2208 range (n + 1), k * sorry = n * (n - 1).factorial"}, {"line": "simpa using main_fintype (Fin n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.natAbs_eq_of_chain_dvd {l : Cycle \u2124} {x y : \u2124} (hl : l.Chain (\u00b7 \u2223 \u00b7)) (hx : x \u2208 l)\n    (hy : y \u2208 l) : x.natAbs = y.natAbs := by\n  rw [Cycle.chain_iff_pairwise] at hl\n  exact Int.natAbs_eq_of_dvd_dvd (hl x hx y hy) (hl y hy x hx)\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q5.lean", "context": {"open": ["Function Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Cycle \u2124\nx y : \u2124\nhl : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) l\nhx : x \u2208 l\nhy : y \u2208 l\n\u22a2 x.natAbs = y.natAbs"}, {"line": "rw [Cycle.chain_iff_pairwise] at hl", "tactic_state": "l : Cycle \u2124\nx y : \u2124\nhl : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2223 b\nhx : x \u2208 l\nhy : y \u2208 l\n\u22a2 x.natAbs = y.natAbs"}, {"line": "exact Int.natAbs_eq_of_dvd_dvd (hl x hx y hy) (hl y hy x hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.isPeriodicPt_eval_two {P : Polynomial \u2124} {t : \u2124}\n    (ht : t \u2208 periodicPts fun x => P.eval x) : IsPeriodicPt (fun x => P.eval x) 2 t := by\n  -- The cycle [P(t) - t, P(P(t)) - P(t), ...]\n  let C : Cycle \u2124 := (periodicOrbit (fun x => P.eval x) t).map fun x => P.eval x - x\n  have HC : \u2200 {n : \u2115}, (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t \u2208 C := by\n    intro n\n    rw [Cycle.mem_map]\n    rw [Function.iterate_succ_apply']\n    exact \u27e8_, iterate_mem_periodicOrbit ht n, rfl\u27e9\n  -- Elements in C are all divisible by one another.\n  have Hdvd : C.Chain (\u00b7 \u2223 \u00b7) := by\n    rw [Cycle.chain_map]\n    rw [periodicOrbit_chain' _ ht]\n    intro n\n    convert sub_dvd_eval_sub ((fun x => P.eval x)^[n + 1] t) ((fun x => P.eval x)^[n] t) P <;>\n      rw [Function.iterate_succ_apply']\n  -- Any two entries in C have the same absolute value.\n  have Habs :\n    \u2200 m n : \u2115,\n      ((fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t).natAbs =\n        ((fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t).natAbs :=\n    fun m n => Int.natAbs_eq_of_chain_dvd Hdvd HC HC\n  -- We case on whether the elements on C are pairwise equal.\n  by_cases HC' : C.Chain (\u00b7 = \u00b7)\n  \u00b7 -- Any two entries in C are equal.\n    have Heq :\n      \u2200 m n : \u2115,\n        (fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t =\n          (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t :=\n      fun m n => Cycle.chain_iff_pairwise.1 HC' _ HC _ HC\n    -- The sign of P^n(t) - t is the same as P(t) - t for positive n. Proven by induction on n.\n    have IH : \u2200 n : \u2115, ((fun x => P.eval x)^[n + 1] t - t).sign = (P.eval t - t).sign := by\n      intro n\n      induction' n with n IH\n      \u00b7 rfl\n      \u00b7 apply Eq.trans _ (Int.sign_add_eq_of_sign_eq IH)\n        have H := Heq n.succ 0\n        dsimp at H \u22a2\n        rw [\u2190 H]\n        rw [sub_add_sub_cancel']\n    -- This implies that the sign of P(t) - t is the same as the sign of P^k(t) - t, which is 0.\n    -- Hence P(t) = t and P(P(t)) = P(t).\n    rcases ht with \u27e8_ | k, hk, hk'\u27e9\n    \u00b7 exact (irrefl 0 hk).elim\n    \u00b7 have H := IH k\n      rw [hk'.isFixedPt.eq] at H\n      rw [sub_self] at H\n      rw [Int.sign_zero] at H\n      rw [eq_comm] at H\n      rw [Int.sign_eq_zero_iff_zero] at H\n      rw [sub_eq_zero] at H\n      simp [IsPeriodicPt, IsFixedPt, H]\n  \u00b7 -- We take two nonequal consecutive entries.\n    rw [Cycle.chain_map] at HC'\n    rw [periodicOrbit_chain' _ ht] at HC'\n    push_neg at HC'\n    obtain \u27e8n, hn\u27e9 := HC'\n    -- They must have opposite sign, so that P^{k + 1}(t) - P^k(t) = P^{k + 2}(t) - P^{k + 1}(t).\n    rcases Int.natAbs_eq_natAbs_iff.1 (Habs n n.succ) with hn' | hn'\n    \u00b7 apply (hn _).elim\n      convert hn' <;> simp only [Function.iterate_succ_apply']\n    -- We deduce P^{k + 2}(t) = P^k(t) and hence P(P(t)) = t.\n    \u00b7 rw [neg_sub, sub_right_inj] at hn'\n      simp only [Function.iterate_succ_apply'] at hn'\n      exact isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate ht hn'.symm\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q5.lean", "context": {"open": ["Function Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "let C : Cycle \u2124 := (periodicOrbit (fun x => P.eval x) t).map fun x => P.eval x - x", "tactic_state": "P : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "have HC : \u2200 {n : \u2115}, (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t \u2208 C := by\n    intro n\n    rw [Cycle.mem_map]\n    rw [Function.iterate_succ_apply']\n    exact \u27e8_, iterate_mem_periodicOrbit ht n, rfl\u27e9", "tactic_state": "P : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "have Hdvd : C.Chain (\u00b7 \u2223 \u00b7) := sorry", "tactic_state": "P : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\nHdvd : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) C\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "have Habs :\n    \u2200 m n : \u2115,\n      ((fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t).natAbs =\n        ((fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t).natAbs :=\n    fun m n => Int.natAbs_eq_of_chain_dvd Hdvd HC HC", "tactic_state": "P : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\nHdvd : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) C\nHabs :\n  \u2200 (m n : \u2115),\n    ((fun x => eval x P)^[m + 1] t - (fun x => eval x P)^[m] t).natAbs =\n      ((fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t).natAbs\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "by_cases HC' : C.Chain (\u00b7 = \u00b7)", "tactic_state": "case pos\nP : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\nHdvd : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) C\nHabs :\n  \u2200 (m n : \u2115),\n    ((fun x => eval x P)^[m + 1] t - (fun x => eval x P)^[m] t).natAbs =\n      ((fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t).natAbs\nHC' : Cycle.Chain (fun x1 x2 => x1 = x2) C\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t\n---\ncase neg\nP : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\nHdvd : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) C\nHabs :\n  \u2200 (m n : \u2115),\n    ((fun x => eval x P)^[m + 1] t - (fun x => eval x P)^[m] t).natAbs =\n      ((fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t).natAbs\nHC' : \u00acCycle.Chain (fun x1 x2 => x1 = x2) C\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "\u00b7 -- Any two entries in C are equal.\n    have Heq :\n      \u2200 m n : \u2115,\n        (fun x => P.eval x)^[m + 1] t - (fun x => P.eval x)^[m] t =\n          (fun x => P.eval x)^[n + 1] t - (fun x => P.eval x)^[n] t :=\n      fun m n => Cycle.chain_iff_pairwise.1 HC' _ HC _ HC\n    have IH : \u2200 n : \u2115, ((fun x => P.eval x)^[n + 1] t - t).sign = (P.eval t - t).sign := by\n      intro n\n      induction' n with n IH\n      \u00b7 rfl\n      \u00b7 apply Eq.trans _ (Int.sign_add_eq_of_sign_eq IH)\n        have H := Heq n.succ 0\n        dsimp at H \u22a2\n        rw [\u2190 H]\n        rw [sub_add_sub_cancel']\n    rcases ht with \u27e8_ | k, hk, hk'\u27e9\n    \u00b7 exact (irrefl 0 hk).elim\n    \u00b7 have H := IH k\n      rw [hk'.isFixedPt.eq] at H\n      rw [sub_self] at H\n      rw [Int.sign_zero] at H\n      rw [eq_comm] at H\n      rw [Int.sign_eq_zero_iff_zero] at H\n      rw [sub_eq_zero] at H\n      simp [IsPeriodicPt, IsFixedPt, H]", "tactic_state": "case neg\nP : Polynomial \u2124\nt : \u2124\nht : t \u2208 periodicPts fun x => eval x P\nC : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)\nHC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C\nHdvd : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) C\nHabs :\n  \u2200 (m n : \u2115),\n    ((fun x => eval x P)^[m + 1] t - (fun x => eval x P)^[m] t).natAbs =\n      ((fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t).natAbs\nHC' : \u00acCycle.Chain (fun x1 x2 => x1 = x2) C\n\u22a2 IsPeriodicPt (fun x => eval x P) 2 t"}, {"line": "\u00b7 -- We take two nonequal consecutive entries.\n    rw [Cycle.chain_map] at HC'\n    rw [periodicOrbit_chain' _ ht] at HC'\n    push_neg at HC'\n    obtain \u27e8n, hn\u27e9 := HC'\n    rcases Int.natAbs_eq_natAbs_iff.1 (Habs n n.succ) with hn' | hn'\n    \u00b7 apply (hn _).elim\n      convert hn' <;> simp only [Function.iterate_succ_apply']\n    \u00b7 rw [neg_sub, sub_right_inj] at hn'\n      simp only [Function.iterate_succ_apply'] at hn'\n      exact isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate ht hn'.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.iterate_comp_sub_X_ne {P : Polynomial \u2124} (hP : 1 < P.natDegree) {k : \u2115}\n    (hk : 0 < k) : P.comp^[k] X - X \u2260 0 := by\n  rw [sub_ne_zero]\n  apply_fun natDegree\n  simpa using (one_lt_pow\u2080 hP hk.ne').ne'\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q5.lean", "context": {"open": ["Function Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 P.comp^[k] X - X \u2260 0"}, {"line": "rw [sub_ne_zero]", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 P.comp^[k] X \u2260 X"}, {"line": "apply_fun natDegree", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 (P.comp^[k] X).natDegree \u2260 X.natDegree"}, {"line": "simpa using (one_lt_pow\u2080 hP hk.ne').ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arith_lemma (k n : \u2115) : 0 < 2 * n + 2 ^ k.succ := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q1.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k n : \u2115\n\u22a2 0 < 2 * n + 2 ^ k.succ"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_lemma (m : \u2115 \u2192 \u2115+) (k : \u2115) (nm : \u2115+) :\n    \u220f i \u2208 Finset.range k, ((1 : \u211a) + 1 / \u2191(if i < k then m i else nm)) =\n      \u220f i \u2208 Finset.range k, (1 + 1 / (m i : \u211a)) := by\n  suffices \u2200 i, i \u2208 Finset.range k \u2192 (1 : \u211a) + 1 / \u2191(if i < k then m i else nm) = 1 + 1 / m i from\n    Finset.prod_congr rfl this\n  intro i hi\n  simp [Finset.mem_range.mp hi]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q1.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115 \u2192 \u2115+\nk : \u2115\nnm : \u2115+\n\u22a2 \u220f i \u2208 Finset.range k, (1 + 1 / \u2191\u2191(if i < k then m i else nm)) = \u220f i \u2208 Finset.range k, (1 + 1 / \u2191\u2191(m i))"}, {"line": "suffices \u2200 i, i \u2208 Finset.range k \u2192 (1 : \u211a) + 1 / \u2191(if i < k then m i else nm) = 1 + 1 / m i from\n    Finset.prod_congr rfl this", "tactic_state": "m : \u2115 \u2192 \u2115+\nk : \u2115\nnm : \u2115+\n\u22a2 \u2200 i \u2208 Finset.range k, 1 + 1 / \u2191\u2191(if i < k then m i else nm) = 1 + 1 / \u2191\u2191(m i)"}, {"line": "intro i hi", "tactic_state": "m : \u2115 \u2192 \u2115+\nk : \u2115\nnm : \u2115+\ni : \u2115\nhi : i \u2208 Finset.range k\n\u22a2 1 + 1 / \u2191\u2191(if i < k then m i else nm) = 1 + 1 / \u2191\u2191(m i)"}, {"line": "simp [Finset.mem_range.mp hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imo2013_q1 (n : \u2115+) (k : \u2115) :\n    \u2203 m : \u2115 \u2192 \u2115+, (1 : \u211a) + (2 ^ k - 1) / n = \u220f i \u2208 Finset.range k, (1 + 1 / (m i : \u211a)) := by\n  revert n\n  induction' k with pk hpk\n  \u00b7 intro n; use fun (_ : \u2115) => (1 : \u2115+); simp\n  -- For the base case, any m works.\n  intro n\n  obtain \u27e8t, ht : \u2191n = t + t\u27e9 | \u27e8t, ht : \u2191n = 2 * t + 1\u27e9 := (n : \u2115).even_or_odd\n  \u00b7 -- even case\n    rw [\u2190 two_mul] at ht\n    rcases t with - | t\n    -- Eliminate the zero case to simplify later calculations.\n    \u00b7 exfalso; rw [Nat.mul_zero] at ht; exact PNat.ne_zero n ht\n    -- Now we have ht : \u2191n = 2 * (t + 1).\n    let t_succ : \u2115+ := \u27e8t + 1, t.succ_pos\u27e9\n    obtain \u27e8pm, hpm\u27e9 := hpk t_succ\n    let m i := if i < pk then pm i else \u27e82 * t + 2 ^ pk.succ, arith_lemma pk t\u27e9\n    use m\n    have hmpk : (m pk : \u211a) = 2 * t + 2 ^ pk.succ := by\n      have : m pk = \u27e82 * t + 2 ^ pk.succ, _\u27e9 := if_neg (irrefl pk); simp [this]\n    calc\n      ((1 : \u211a) + (2 ^ pk.succ - 1) / (n : \u211a) : \u211a)= 1 + (2 * 2 ^ pk - 1) / (2 * (t + 1) : \u2115) := by\n        rw [ht]\n        rw [pow_succ']\n      _ = (1 + 1 / (2 * t + 2 * 2 ^ pk)) * (1 + (2 ^ pk - 1) / (\u2191t + 1)) := by\n        field_simp\n        ring\n      _ = (1 + 1 / (2 * t + 2 ^ pk.succ)) * (1 + (2 ^ pk - 1) / t_succ) := by\n        simp [pow_succ', PNat.mk_coe, t_succ]\n      _ = (\u220f i \u2208 Finset.range pk, (1 + 1 / (m i : \u211a))) * (1 + 1 / m pk) := by\n        rw [prod_lemma]\n        rw [hpm]\n        rw [\u2190 hmpk]\n        rw [mul_comm]\n      _ = \u220f i \u2208 Finset.range pk.succ, (1 + 1 / (m i : \u211a)) := by rw [\u2190 Finset.prod_range_succ _ pk]\n  \u00b7 -- odd case\n    let t_succ : \u2115+ := \u27e8t + 1, t.succ_pos\u27e9\n    obtain \u27e8pm, hpm\u27e9 := hpk t_succ\n    let m i := if i < pk then pm i else \u27e82 * t + 1, Nat.succ_pos _\u27e9\n    use m\n    have hmpk : (m pk : \u211a) = 2 * t + 1 := by\n      have : m pk = \u27e82 * t + 1, _\u27e9 := if_neg (irrefl pk)\n      simp [this]\n    calc\n      ((1 : \u211a) + (2 ^ pk.succ - 1) / \u2191n : \u211a) = 1 + (2 * 2 ^ pk - 1) / (2 * t + 1 : \u2115) := by\n        rw [ht]\n        rw [pow_succ']\n      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / (t + 1)) := by\n        field_simp\n        ring\n      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / t_succ) := by norm_cast\n      _ = (\u220f i \u2208 Finset.range pk, (1 + 1 / (m i : \u211a))) * (1 + 1 / \u2191(m pk)) := by\n        rw [prod_lemma]\n        rw [hpm]\n        rw [\u2190 hmpk]\n        rw [mul_comm]\n      _ = \u220f i \u2208 Finset.range pk.succ, (1 + 1 / (m i : \u211a)) := by rw [\u2190 Finset.prod_range_succ _ pk]", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q1.lean", "context": {"open": ["Imo2013Q1"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115+\nk : \u2115\n\u22a2 \u2203 m, 1 + (2 ^ k - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range k, (1 + 1 / \u2191\u2191(m i))"}, {"line": "revert n", "tactic_state": "k : \u2115\n\u22a2 \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ k - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range k, (1 + 1 / \u2191\u2191(m i))"}, {"line": "induction' k with pk hpk", "tactic_state": "case zero\n\u22a2 \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ 0 - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range 0, (1 + 1 / \u2191\u2191(m i))\n---\ncase succ\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\n\u22a2 \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))"}, {"line": "\u00b7 intro n; use fun (_ : \u2115) => (1 : \u2115+); simp", "tactic_state": "case succ\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\n\u22a2 \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))"}, {"line": "intro n", "tactic_state": "case succ\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\nn : \u2115+\n\u22a2 \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))"}, {"line": "obtain \u27e8t, ht : \u2191n = t + t\u27e9 | \u27e8t, ht : \u2191n = 2 * t + 1\u27e9 := (n : \u2115).even_or_odd", "tactic_state": "case succ.inl.intro\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\nn : \u2115+\nt : \u2115\nht : \u2191n = t + t\n\u22a2 \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))\n---\ncase succ.inr.intro\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\nn : \u2115+\nt : \u2115\nht : \u2191n = 2 * t + 1\n\u22a2 \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))"}, {"line": "\u00b7 -- even case\n    rw [\u2190 two_mul] at ht\n    rcases t with - | t\n    \u00b7 exfalso; rw [Nat.mul_zero] at ht; exact PNat.ne_zero n ht\n    let t_succ : \u2115+ := \u27e8t + 1, t.succ_pos\u27e9\n    obtain \u27e8pm, hpm\u27e9 := hpk t_succ\n    let m i := if i < pk then pm i else \u27e82 * t + 2 ^ pk.succ, arith_lemma pk t\u27e9\n    use m\n    have hmpk : (m pk : \u211a) = 2 * t + 2 ^ pk.succ := by\n      have : m pk = \u27e82 * t + 2 ^ pk.succ, _\u27e9 := if_neg (irrefl pk); simp [this]\n    calc\n      ((1 : \u211a) + (2 ^ pk.succ - 1) / (n : \u211a) : \u211a)= 1 + (2 * 2 ^ pk - 1) / (2 * (t + 1) : \u2115) := by\n        rw [ht]\n        rw [pow_succ']\n      _ = (1 + 1 / (2 * t + 2 * 2 ^ pk)) * (1 + (2 ^ pk - 1) / (\u2191t + 1)) := by\n        field_simp\n        ring\n      _ = (1 + 1 / (2 * t + 2 ^ pk.succ)) * (1 + (2 ^ pk - 1) / t_succ) := by\n        simp [pow_succ', PNat.mk_coe, t_succ]\n      _ = (\u220f i \u2208 Finset.range pk, (1 + 1 / (m i : \u211a))) * (1 + 1 / m pk) := by\n        rw [prod_lemma]\n        rw [hpm]\n        rw [\u2190 hmpk]\n        rw [mul_comm]\n      _ = \u220f i \u2208 Finset.range pk.succ, (1 + 1 / (m i : \u211a)) := by rw [\u2190 Finset.prod_range_succ _ pk]", "tactic_state": "case succ.inr.intro\npk : \u2115\nhpk : \u2200 (n : \u2115+), \u2203 m, 1 + (2 ^ pk - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range pk, (1 + 1 / \u2191\u2191(m i))\nn : \u2115+\nt : \u2115\nht : \u2191n = 2 * t + 1\n\u22a2 \u2203 m, 1 + (2 ^ (pk + 1) - 1) / \u2191\u2191n = \u220f i \u2208 Finset.range (pk + 1), (1 + 1 / \u2191\u2191(m i))"}, {"line": "\u00b7 -- odd case\n    let t_succ : \u2115+ := \u27e8t + 1, t.succ_pos\u27e9\n    obtain \u27e8pm, hpm\u27e9 := hpk t_succ\n    let m i := if i < pk then pm i else \u27e82 * t + 1, Nat.succ_pos _\u27e9\n    use m\n    have hmpk : (m pk : \u211a) = 2 * t + 1 := by\n      have : m pk = \u27e82 * t + 1, _\u27e9 := if_neg (irrefl pk)\n      simp [this]\n    calc\n      ((1 : \u211a) + (2 ^ pk.succ - 1) / \u2191n : \u211a) = 1 + (2 * 2 ^ pk - 1) / (2 * t + 1 : \u2115) := by\n        rw [ht]\n        rw [pow_succ']\n      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / (t + 1)) := by\n        field_simp\n        ring\n      _ = (1 + 1 / (2 * t + 1)) * (1 + (2 ^ pk - 1) / t_succ) := by norm_cast\n      _ = (\u220f i \u2208 Finset.range pk, (1 + 1 / (m i : \u211a))) * (1 + 1 / \u2191(m pk)) := by\n        rw [prod_lemma]\n        rw [hpm]\n        rw [\u2190 hmpk]\n        rw [mul_comm]\n      _ = \u220f i \u2208 Finset.range pk.succ, (1 + 1 / (m i : \u211a)) := by rw [\u2190 Finset.prod_range_succ _ pk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_of_all_pow_lt_succ {x y : \u211d} (hx : 1 < x) (hy : 1 < y)\n    (h : \u2200 n : \u2115, 0 < n \u2192 x ^ n - 1 < y ^ n) : x \u2264 y := by\n  by_contra! hxy\n  have hxmy : 0 < x - y := sub_pos.mpr hxy\n  have hn : \u2200 n : \u2115, 0 < n \u2192 (x - y) * (n : \u211d) \u2264 x ^ n - y ^ n := by\n    intro n _\n    have hterm : \u2200 i : \u2115, i \u2208 Finset.range n \u2192 1 \u2264 x ^ i * y ^ (n - 1 - i) := by\n      intro i _\n      calc\n        1 \u2264 x ^ i := one_le_pow\u2080 hx.le\n        _ = x ^ i * 1 := by ring\n        _ \u2264 x ^ i * y ^ (n - 1 - i) := by gcongr; apply one_le_pow\u2080 hy.le\n    calc\n      (x - y) * (n : \u211d) = (n : \u211d) * (x - y) := by ring\n      _ = (\u2211 _i \u2208 Finset.range n, (1 : \u211d)) * (x - y) := by\n        simp only [mul_one]\n        simp only [Finset.sum_const]\n        simp only [nsmul_eq_mul]\n        simp only [Finset.card_range]\n      _ \u2264 (\u2211 i \u2208 Finset.range n, x ^ i * y ^ (n - 1 - i)) * (x - y) := by\n        gcongr with i hi; apply hterm i hi\n      _ = x ^ n - y ^ n := geom_sum\u2082_mul x y n\n  -- Choose n larger than 1 / (x - y).\n  obtain \u27e8N, hN\u27e9 := exists_nat_gt (1 / (x - y))\n  have hNp : 0 < N := mod_cast (one_div_pos.mpr hxmy).trans hN\n  have :=\n    calc\n      1 = (x - y) * (1 / (x - y)) := by field_simp\n      _ < (x - y) * N := by gcongr\n      _ \u2264 x ^ N - y ^ N := hn N hNp\n  linarith [h N hNp]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\n\u22a2 x \u2264 y"}, {"line": "by_contra! hxy", "tactic_state": "x y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\n\u22a2 False"}, {"line": "have hxmy : 0 < x - y := sub_pos.mpr hxy", "tactic_state": "x y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\nhxmy : 0 < x - y\n\u22a2 False"}, {"line": "have hn : \u2200 n : \u2115, 0 < n \u2192 (x - y) * (n : \u211d) \u2264 x ^ n - y ^ n := sorry", "tactic_state": "x y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\nhxmy : 0 < x - y\nhn : \u2200 (n : \u2115), 0 < n \u2192 (x - y) * \u2191n \u2264 x ^ n - y ^ n\n\u22a2 False"}, {"line": "obtain \u27e8N, hN\u27e9 := exists_nat_gt (1 / (x - y))", "tactic_state": "case intro\nx y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\nhxmy : 0 < x - y\nhn : \u2200 (n : \u2115), 0 < n \u2192 (x - y) * \u2191n \u2264 x ^ n - y ^ n\nN : \u2115\nhN : 1 / (x - y) < \u2191N\n\u22a2 False"}, {"line": "have hNp : 0 < N := mod_cast (one_div_pos.mpr hxmy).trans hN", "tactic_state": "case intro\nx y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\nhxmy : 0 < x - y\nhn : \u2200 (n : \u2115), 0 < n \u2192 (x - y) * \u2191n \u2264 x ^ n - y ^ n\nN : \u2115\nhN : 1 / (x - y) < \u2191N\nhNp : 0 < N\n\u22a2 False"}, {"line": "have :=\n    calc\n      1 = (x - y) * (1 / (x - y)) := by field_simp\n      _ < (x - y) * N := by gcongr\n      _ \u2264 x ^ N - y ^ N := hn N hNp", "tactic_state": "case intro\nx y : \u211d\nhx : 1 < x\nhy : 1 < y\nh : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n\nhxy : y < x\nhxmy : 0 < x - y\nhn : \u2200 (n : \u2115), 0 < n \u2192 (x - y) * \u2191n \u2264 x ^ n - y ^ n\nN : \u2115\nhN : 1 / (x - y) < \u2191N\nhNp : 0 < N\nthis : 1 < x ^ N - y ^ N\n\u22a2 False"}, {"line": "linarith [h N hNp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem f_pos_of_pos {f : \u211a \u2192 \u211d} {q : \u211a} (hq : 0 < q)\n    (H1 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H4 : \u2200 n : \u2115, 0 < n \u2192 (n : \u211d) \u2264 f n) :\n    0 < f q := by\n  have num_pos : 0 < q.num := Rat.num_pos.mpr hq\n  have hmul_pos :=\n    calc\n      (0 : \u211d) < q.num := Int.cast_pos.mpr num_pos\n      _ = ((q.num.natAbs : \u2124) : \u211d) := congr_arg Int.cast (Int.natAbs_of_nonneg num_pos.le).symm\n      _ \u2264 f q.num.natAbs := (H4 q.num.natAbs ((@Int.natAbs_pos q.num).mpr num_pos.ne.symm))\n      _ = f q.num := by rw [Nat.cast_natAbs, abs_of_nonneg num_pos.le]\n      _ = f (q * q.den) := by rw [\u2190 Rat.mul_den_eq_num]\n      _ \u2264 f q * f q.den := H1 q q.den hq (Nat.cast_pos.mpr q.pos)\n  have h_f_denom_pos :=\n    calc\n      (0 : \u211d) < q.den := Nat.cast_pos.mpr q.pos\n      _ \u2264 f q.den := H4 q.den q.pos\n  exact pos_of_mul_pos_left hmul_pos h_f_denom_pos.le\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211a \u2192 \u211d\nq : \u211a\nhq : 0 < q\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\n\u22a2 0 < f q"}, {"line": "have num_pos : 0 < q.num := Rat.num_pos.mpr hq", "tactic_state": "f : \u211a \u2192 \u211d\nq : \u211a\nhq : 0 < q\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nnum_pos : 0 < q.num\n\u22a2 0 < f q"}, {"line": "have hmul_pos :=\n    calc\n      (0 : \u211d) < q.num := Int.cast_pos.mpr num_pos\n      _ = ((q.num.natAbs : \u2124) : \u211d) := congr_arg Int.cast (Int.natAbs_of_nonneg num_pos.le).symm\n      _ \u2264 f q.num.natAbs := (H4 q.num.natAbs ((@Int.natAbs_pos q.num).mpr num_pos.ne.symm))\n      _ = f q.num := by rw [Nat.cast_natAbs, abs_of_nonneg num_pos.le]\n      _ = f (q * q.den) := by rw [\u2190 Rat.mul_den_eq_num]\n      _ \u2264 f q * f q.den := H1 q q.den hq (Nat.cast_pos.mpr q.pos)", "tactic_state": "f : \u211a \u2192 \u211d\nq : \u211a\nhq : 0 < q\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nnum_pos : 0 < q.num\nhmul_pos : 0 < f q * f \u2191q.den\n\u22a2 0 < f q"}, {"line": "have h_f_denom_pos :=\n    calc\n      (0 : \u211d) < q.den := Nat.cast_pos.mpr q.pos\n      _ \u2264 f q.den := H4 q.den q.pos", "tactic_state": "f : \u211a \u2192 \u211d\nq : \u211a\nhq : 0 < q\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nnum_pos : 0 < q.num\nhmul_pos : 0 < f q * f \u2191q.den\nh_f_denom_pos : 0 < f \u2191q.den\n\u22a2 0 < f q"}, {"line": "exact pos_of_mul_pos_left hmul_pos h_f_denom_pos.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fx_gt_xm1 {f : \u211a \u2192 \u211d} {x : \u211a} (hx : 1 \u2264 x)\n    (H1 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y)\n    (H2 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 n : \u2115, 0 < n \u2192 (n : \u211d) \u2264 f n) :\n    (x - 1 : \u211d) < f x := by\n  have hx0 :=\n    calc\n      (x - 1 : \u211d) < \u230ax\u230b\u208a := mod_cast Nat.sub_one_lt_floor x\n      _ \u2264 f \u230ax\u230b\u208a := H4 _ (Nat.floor_pos.2 hx)\n  obtain h_eq | h_lt := (Nat.floor_le <| zero_le_one.trans hx).eq_or_lt\n  \u00b7 rwa [h_eq] at hx0\n  calc\n    (x - 1 : \u211d) < f \u230ax\u230b\u208a := hx0\n    _ < f (x - \u230ax\u230b\u208a) + f \u230ax\u230b\u208a := (lt_add_of_pos_left _ (f_pos_of_pos (sub_pos.mpr h_lt) H1 H4))\n    _ \u2264 f (x - \u230ax\u230b\u208a + \u230ax\u230b\u208a) := (H2 _ _ (sub_pos.mpr h_lt) (Nat.cast_pos.2 (Nat.floor_pos.2 hx)))\n    _ = f x := by ring_nf\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 \u2264 x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\n\u22a2 \u2191x - 1 < f x"}, {"line": "have hx0 :=\n    calc\n      (x - 1 : \u211d) < \u230ax\u230b\u208a := mod_cast Nat.sub_one_lt_floor x\n      _ \u2264 f \u230ax\u230b\u208a := H4 _ (Nat.floor_pos.2 hx)", "tactic_state": "f : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 \u2264 x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhx0 : \u2191x - 1 < f \u2191\u230ax\u230b\u208a\n\u22a2 \u2191x - 1 < f x"}, {"line": "obtain h_eq | h_lt := (Nat.floor_le <| zero_le_one.trans hx).eq_or_lt", "tactic_state": "case inl\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 \u2264 x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhx0 : \u2191x - 1 < f \u2191\u230ax\u230b\u208a\nh_eq : \u2191\u230ax\u230b\u208a = x\n\u22a2 \u2191x - 1 < f x\n---\ncase inr\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 \u2264 x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhx0 : \u2191x - 1 < f \u2191\u230ax\u230b\u208a\nh_lt : \u2191\u230ax\u230b\u208a < x\n\u22a2 \u2191x - 1 < f x"}, {"line": "\u00b7 rwa [h_eq] at hx0", "tactic_state": "case inr\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 \u2264 x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhx0 : \u2191x - 1 < f \u2191\u230ax\u230b\u208a\nh_lt : \u2191\u230ax\u230b\u208a < x\n\u22a2 \u2191x - 1 < f x"}, {"line": "calc\n    (x - 1 : \u211d) < f \u230ax\u230b\u208a := hx0\n    _ < f (x - \u230ax\u230b\u208a) + f \u230ax\u230b\u208a := (lt_add_of_pos_left _ (f_pos_of_pos (sub_pos.mpr h_lt) H1 H4))\n    _ \u2264 f (x - \u230ax\u230b\u208a + \u230ax\u230b\u208a) := (H2 _ _ (sub_pos.mpr h_lt) (Nat.cast_pos.2 (Nat.floor_pos.2 hx)))\n    _ = f x := by ring_nf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_f_le_f_pow {f : \u211a \u2192 \u211d} {n : \u2115} (hn : 0 < n) {x : \u211a} (hx : 1 < x)\n    (H1 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H4 : \u2200 n : \u2115, 0 < n \u2192 (n : \u211d) \u2264 f n) :\n    f (x ^ n) \u2264 f x ^ n := by\n  induction' n with pn hpn\n  \u00b7 exfalso; exact Nat.lt_asymm hn hn\n  rcases pn with - | pn\n  \u00b7 norm_num\n  have hpn' := hpn pn.succ_pos\n  rw [pow_succ x (pn + 1)]\n  rw [pow_succ (f x) (pn + 1)]\n  have hxp : 0 < x := by positivity\n  calc\n    f (x ^ (pn + 1) * x) \u2264 f (x ^ (pn + 1)) * f x := H1 (x ^ (pn + 1)) x (pow_pos hxp (pn + 1)) hxp\n    _ \u2264 f x ^ (pn + 1) * f x := by gcongr; exact (f_pos_of_pos hxp H1 H4).le\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211a \u2192 \u211d\nn : \u2115\nhn : 0 < n\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\n\u22a2 f (x ^ n) \u2264 f x ^ n"}, {"line": "induction' n with pn hpn", "tactic_state": "case zero\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhn : 0 < 0\n\u22a2 f (x ^ 0) \u2264 f x ^ 0\n---\ncase succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn \u2192 f (x ^ pn) \u2264 f x ^ pn\nhn : 0 < pn + 1\n\u22a2 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)"}, {"line": "\u00b7 exfalso; exact Nat.lt_asymm hn hn", "tactic_state": "case succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn \u2192 f (x ^ pn) \u2264 f x ^ pn\nhn : 0 < pn + 1\n\u22a2 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)"}, {"line": "rcases pn with - | pn", "tactic_state": "case succ.zero\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nhpn : 0 < 0 \u2192 f (x ^ 0) \u2264 f x ^ 0\nhn : 0 < 0 + 1\n\u22a2 f (x ^ (0 + 1)) \u2264 f x ^ (0 + 1)\n---\ncase succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\n\u22a2 f (x ^ (pn + 1 + 1)) \u2264 f x ^ (pn + 1 + 1)"}, {"line": "\u00b7 norm_num", "tactic_state": "case succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\n\u22a2 f (x ^ (pn + 1 + 1)) \u2264 f x ^ (pn + 1 + 1)"}, {"line": "have hpn' := hpn pn.succ_pos", "tactic_state": "case succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\nhpn' : f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\n\u22a2 f (x ^ (pn + 1 + 1)) \u2264 f x ^ (pn + 1 + 1)"}, {"line": "rw [pow_succ x (pn + 1)]", "tactic_state": "case succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\nhpn' : f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\n\u22a2 f (x ^ (pn + 1) * x) \u2264 f x ^ (pn + 1 + 1)"}, {"line": "rw [pow_succ (f x) (pn + 1)]", "tactic_state": "case succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\nhpn' : f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\n\u22a2 f (x ^ (pn + 1) * x) \u2264 f x ^ (pn + 1) * f x"}, {"line": "have hxp : 0 < x := sorry", "tactic_state": "case succ.succ\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\npn : \u2115\nhpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhn : 0 < pn + 1 + 1\nhpn' : f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)\nhxp : 0 < x\n\u22a2 f (x ^ (pn + 1) * x) \u2264 f x ^ (pn + 1) * f x"}, {"line": "calc\n    f (x ^ (pn + 1) * x) \u2264 f (x ^ (pn + 1)) * f x := H1 (x ^ (pn + 1)) x (pow_pos hxp (pn + 1)) hxp\n    _ \u2264 f x ^ (pn + 1) * f x := by gcongr; exact (f_pos_of_pos hxp H1 H4).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fixed_point_of_pos_nat_pow {f : \u211a \u2192 \u211d} {n : \u2115} (hn : 0 < n)\n    (H1 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H4 : \u2200 n : \u2115, 0 < n \u2192 (n : \u211d) \u2264 f n)\n    (H5 : \u2200 x : \u211a, 1 < x \u2192 (x : \u211d) \u2264 f x) {a : \u211a} (ha1 : 1 < a) (hae : f a = a) :\n    f (a ^ n) = a ^ n := by\n  have hh0 : (a : \u211d) ^ n \u2264 f (a ^ n) := mod_cast H5 (a ^ n) (one_lt_pow\u2080 ha1 hn.ne')\n  have hh1 :=\n    calc\n      f (a ^ n) \u2264 f a ^ n := pow_f_le_f_pow hn ha1 H1 H4\n      _ = (a : \u211d) ^ n := by rw [\u2190 hae]\n  exact mod_cast hh1.antisymm hh0\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211a \u2192 \u211d\nn : \u2115\nhn : 0 < n\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\n\u22a2 f (a ^ n) = \u2191a ^ n"}, {"line": "have hh0 : (a : \u211d) ^ n \u2264 f (a ^ n) := mod_cast H5 (a ^ n) (one_lt_pow\u2080 ha1 hn.ne')", "tactic_state": "f : \u211a \u2192 \u211d\nn : \u2115\nhn : 0 < n\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nhh0 : \u2191a ^ n \u2264 f (a ^ n)\n\u22a2 f (a ^ n) = \u2191a ^ n"}, {"line": "have hh1 :=\n    calc\n      f (a ^ n) \u2264 f a ^ n := pow_f_le_f_pow hn ha1 H1 H4\n      _ = (a : \u211d) ^ n := by rw [\u2190 hae]", "tactic_state": "f : \u211a \u2192 \u211d\nn : \u2115\nhn : 0 < n\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nhh0 : \u2191a ^ n \u2264 f (a ^ n)\nhh1 : f (a ^ n) \u2264 \u2191a ^ n\n\u22a2 f (a ^ n) = \u2191a ^ n"}, {"line": "exact mod_cast hh1.antisymm hh0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fixed_point_of_gt_1 {f : \u211a \u2192 \u211d} {x : \u211a} (hx : 1 < x)\n    (H1 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y)\n    (H2 : \u2200 x y, 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 n : \u2115, 0 < n \u2192 (n : \u211d) \u2264 f n)\n    (H5 : \u2200 x : \u211a, 1 < x \u2192 (x : \u211d) \u2264 f x) {a : \u211a} (ha1 : 1 < a) (hae : f a = a) : f x = x := by\n  -- Choose n such that 1 + x < a^n.\n  obtain \u27e8N, hN\u27e9 := pow_unbounded_of_one_lt (1 + x) ha1\n  have h_big_enough : (1 : \u211a) < a ^ N - x := lt_sub_iff_add_lt.mpr hN\n  have h1 :=\n    calc\n      (x : \u211d) + (a ^ N - x : \u211a) \u2264 f x + (a ^ N - x : \u211a) := by gcongr; exact H5 x hx\n      _ \u2264 f x + f (a ^ N - x) := by gcongr; exact H5 _ h_big_enough\n  have hxp : 0 < x := by positivity\n  have hNp : 0 < N := by by_contra! H; rw [Nat.le_zero.mp H] at hN; linarith\n  have h2 :=\n    calc\n      f x + f (a ^ N - x) \u2264 f (x + (a ^ N - x)) := H2 x (a ^ N - x) hxp (by positivity)\n      _ = f (a ^ N) := by ring_nf\n      _ = a ^ N := fixed_point_of_pos_nat_pow hNp H1 H4 H5 ha1 hae\n      _ = x + (a ^ N - x) := by ring\n  have heq := h1.antisymm (mod_cast h2)\n  linarith [H5 x hx, H5 _ h_big_enough]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q5.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\n\u22a2 f x = \u2191x"}, {"line": "obtain \u27e8N, hN\u27e9 := pow_unbounded_of_one_lt (1 + x) ha1", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\n\u22a2 f x = \u2191x"}, {"line": "have h_big_enough : (1 : \u211a) < a ^ N - x := lt_sub_iff_add_lt.mpr hN", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\n\u22a2 f x = \u2191x"}, {"line": "have h1 :=\n    calc\n      (x : \u211d) + (a ^ N - x : \u211a) \u2264 f x + (a ^ N - x : \u211a) := by gcongr; exact H5 x hx\n      _ \u2264 f x + f (a ^ N - x) := by gcongr; exact H5 _ h_big_enough", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\nh1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)\n\u22a2 f x = \u2191x"}, {"line": "have hxp : 0 < x := sorry", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\nh1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)\nhxp : 0 < x\n\u22a2 f x = \u2191x"}, {"line": "have hNp : 0 < N := sorry", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\nh1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)\nhxp : 0 < x\nhNp : 0 < N\n\u22a2 f x = \u2191x"}, {"line": "have h2 :=\n    calc\n      f x + f (a ^ N - x) \u2264 f (x + (a ^ N - x)) := H2 x (a ^ N - x) hxp (by positivity)\n      _ = f (a ^ N) := by ring_nf\n      _ = a ^ N := fixed_point_of_pos_nat_pow hNp H1 H4 H5 ha1 hae\n      _ = x + (a ^ N - x) := by ring", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\nh1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)\nhxp : 0 < x\nhNp : 0 < N\nh2 : f x + f (a ^ N - x) \u2264 \u2191x + (\u2191a ^ N - \u2191x)\n\u22a2 f x = \u2191x"}, {"line": "have heq := h1.antisymm (mod_cast h2)", "tactic_state": "case intro\nf : \u211a \u2192 \u211d\nx : \u211a\nhx : 1 < x\nH1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y\nH2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)\nH4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n\nH5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x\na : \u211a\nha1 : 1 < a\nhae : f a = \u2191a\nN : \u2115\nhN : 1 + x < a ^ N\nh_big_enough : 1 < a ^ N - x\nh1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)\nhxp : 0 < x\nhNp : 0 < N\nh2 : f x + f (a ^ N - x) \u2264 \u2191x + (\u2191a ^ N - \u2191x)\nheq : \u2191x + \u2191(a ^ N - x) = f x + f (a ^ N - x)\n\u22a2 f x = \u2191x"}, {"line": "linarith [H5 x hx, H5 _ h_big_enough]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_sum_pool : \u2211 i \u2208 range b, (i : \u2124) \u2264 \u2211 x \u2208 pool a t, x := by\n  convert sum_range_le_sum fun x mx \u21a6 (mem_Icc.mp ((pool_subset_Icc ha) mx)).1\n  \u00b7 rw [hbN _ ht]\n  \u00b7 rw [zero_add]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2015Q6.lean", "context": {"open": ["Finset"], "variables": ["{a : \u2115 \u2192 \u2124} (ha : Condition a) {t : \u2115}", "{b N : \u2115} (hbN : \u2200 t \u2265 N, #(pool a t) = b) (ht : t \u2265 N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.1311\npool : ?m.1343\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2211 i \u2208 range b, \u2191i \u2264 \u2211 x \u2208 sorry, x"}, {"line": "convert sum_range_le_sum fun x mx \u21a6 (mem_Icc.mp ((pool_subset_Icc ha) mx)).1", "tactic_state": "case h.e'_3.h.h.e'_1\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 b = card ?m.5232\n---\ncase h.e'_3.a\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb x\u271d : \u2115\na\u271d : x\u271d \u2208 range (card ?m.5232)\n\u22a2 \u2191x\u271d = ?convert_2 + \u2191x\u271d\n---\ncase convert_2\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2124\n---\ncase convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}, {"line": "\u00b7 rw [hbN _ ht]", "tactic_state": "case h.e'_3.a\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb x\u271d : \u2115\na\u271d : x\u271d \u2208 range (card ?m.5232)\n\u22a2 \u2191x\u271d = ?convert_2 + \u2191x\u271d\n---\ncase convert_2\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2124\n---\ncase convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}, {"line": "\u00b7 rw [zero_add]", "tactic_state": "case convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}]}
{"declaration": "lemma exists_infinite_setOf_apply_eq : \u2203 m, {i | a i = m}.Infinite := by\n  by_contra hi\n  have hr : (Set.range a).Infinite := by\n    contrapose! hi with hr\n    rw [Set.not_infinite] at hr\n    rw [\u2190 Set.finite_coe_iff] at hr\n    obtain \u27e8n, hn\u27e9 := Finite.exists_infinite_fiber (Set.rangeFactorization a)\n    rw [Set.infinite_coe_iff] at hn\n    rw [Set.preimage] at hn\n    simp only [Set.mem_singleton_iff] at hn\n    simp only [Set.rangeFactorization] at hn\n    simp only [Subtype.ext_iff] at hn\n    exact \u27e8\u2191n, hn\u27e9\n  simp only [not_exists] at hi\n  simp only [Set.not_infinite] at hi\n  have hinj : Set.InjOn (fun i \u21a6 Nat.nth (a \u00b7 = i) 0 + 1) (Set.range a \\ Set.Ico 0 (M a N)) := by\n    rintro _ \u27e8\u27e8_, rfl\u27e9, hi\u27e9 _ \u27e8\u27e8_, rfl\u27e9, hj\u27e9 h\n    simp only [Set.mem_diff] at hi hj\n    simp only [Set.mem_range] at hi hj\n    simp only [Set.mem_Ico] at hi hj\n    simp only [zero_le] at hi hj\n    simp only [true_and] at hi hj\n    simp only [not_lt] at hi hj\n    simp only [add_left_inj] at h\n    convert congr(a $h) using 1 <;> simp [apply_nth_zero]\n  refine Set.not_infinite.2 (hi 1) (Set.infinite_of_injOn_mapsTo hinj (fun i hi \u21a6 ?_)\n    (hr.diff (Set.finite_Ico _ _)))\n  simp only [Set.mem_diff] at hi\n  simp only [Set.mem_range] at hi\n  simp only [Set.mem_Ico] at hi\n  simp only [zero_le] at hi\n  simp only [true_and] at hi\n  simp only [not_lt] at hi\n  rcases hi with \u27e8\u27e8_, rfl\u27e9, hi\u27e9\n  exact hc.apply_nth_add_one_eq toFinset_card_pos\n    (N_lt_of_M_le_apply (a := a) (by simp only [apply_nth_zero, hi])).le\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\n\u22a2 \u2203 m, {i | a i = m}.Infinite"}, {"line": "by_contra hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhi : \u00ac\u2203 m, {i | a i = m}.Infinite\n\u22a2 False"}, {"line": "have hr : (Set.range a).Infinite := sorry", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhi : \u00ac\u2203 m, {i | a i = m}.Infinite\nhr : (Set.range a).Infinite\n\u22a2 False"}, {"line": "simp only [not_exists] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi : \u2200 (x : \u2115), \u00ac{i | a i = x}.Infinite\n\u22a2 False"}, {"line": "simp only [Set.not_infinite] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi : \u2200 (x : \u2115), {i | a i = x}.Finite\n\u22a2 False"}, {"line": "have hinj : Set.InjOn (fun i \u21a6 Nat.nth (a \u00b7 = i) 0 + 1) (Set.range a \\ Set.Ico 0 (M a N)) := by\n    rintro _ \u27e8\u27e8_, rfl\u27e9, hi\u27e9 _ \u27e8\u27e8_, rfl\u27e9, hj\u27e9 h\n    simp only [Set.mem_diff] at hi hj\n    simp only [Set.mem_range] at hi hj\n    simp only [Set.mem_Ico] at hi hj\n    simp only [zero_le] at hi hj\n    simp only [true_and] at hi hj\n    simp only [not_lt] at hi hj\n    simp only [add_left_inj] at h\n    convert congr(a $h) using 1 <;> simp [apply_nth_zero]", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\n\u22a2 False"}, {"line": "refine Set.not_infinite.2 (hi 1) (Set.infinite_of_injOn_mapsTo hinj (fun i hi \u21a6 ?_)\n    (hr.diff (Set.finite_Ico _ _)))", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : i \u2208 Set.range a \\ Set.Ico 0 sorry\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [Set.mem_diff] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : i \u2208 Set.range a \u2227 i \u2209 Set.Ico 0 sorry\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [Set.mem_range] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : (\u2203 y, a y = i) \u2227 i \u2209 Set.Ico 0 sorry\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [Set.mem_Ico] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : (\u2203 y, a y = i) \u2227 \u00ac(0 \u2264 i \u2227 i < sorry)\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [zero_le] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : (\u2203 y, a y = i) \u2227 \u00ac(True \u2227 i < sorry)\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [true_and] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : (\u2203 y, a y = i) \u2227 \u00aci < sorry\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "simp only [not_lt] at hi", "tactic_state": "Condition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\ni : \u2115\nhi : (\u2203 y, a y = i) \u2227 sorry \u2264 i\n\u22a2 Nat.nth (fun x => a x = i) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "rcases hi with \u27e8\u27e8_, rfl\u27e9, hi\u27e9", "tactic_state": "case intro.intro\nCondition : ?m.433\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nhr : (Set.range a).Infinite\nhi\u271d : \u2200 (x : \u2115), {i | a i = x}.Finite\nhinj : Set.InjOn (fun i => Nat.nth (fun x => a x = i) 0 + 1) (Set.range a \\ Set.Ico 0 sorry)\nw\u271d : \u2115\nhi : sorry \u2264 a w\u271d\n\u22a2 Nat.nth (fun x => a x = a w\u271d) 0 + 1 \u2208 {i | a i = 1}"}, {"line": "exact hc.apply_nth_add_one_eq toFinset_card_pos\n    (N_lt_of_M_le_apply (a := a) (by simp only [apply_nth_zero, hi])).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finite_setOf_apply_eq_iff_not_small {j : \u2115} (hj : 0 < j) :\n    {i | a i = j}.Finite \u2194 \u00acSmall a j := by\n  simpa only [Set.not_infinite] using (hc.infinite_setOf_apply_eq_iff_small hj).not\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.1291\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nj : \u2115\nhj : 0 < j\n\u22a2 {i | a i = j}.Finite \u2194 \u00acsorry"}, {"line": "simpa only [Set.not_infinite] using (hc.infinite_setOf_apply_eq_iff_small hj).not", "tactic_state": "No Goals!"}]}
{"declaration": "lemma apply_sub_two_small_of_apply_small_of_N'_lt {i : \u2115} (h : Small a (a i)) (hN' : N' a N < i) :\n    Small a (a (i - 2)) := by\n  convert hc.apply_sub_one_small_of_apply_big_of_N'_le\n    (hc.apply_sub_one_big_of_apply_small_of_N'_lt h hN') (by omega) using 1\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}", "(a)", "{a}", "(a N)", "{a N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.3007\na : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\nx\u271d : Sort u_1\nN' : x\u271d\ni : \u2115\nh : sorry\nhN' : sorry < i\n\u22a2 sorry"}, {"line": "convert hc.apply_sub_one_small_of_apply_big_of_N'_le\n    (hc.apply_sub_one_big_of_apply_small_of_N'_lt h hN') (by omega) using 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma N_lt_of_apply_eq_of_apply_big_of_N'_le {i j : \u2115} (hj : a j = a i) (h : Big a (a i))\n    (hN' : N' a N \u2264 i) : N < j :=\n  have hj' : j \u2208 {t | a t = a i} := by simpa using hj\n  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' \u25b8 hj').1\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}", "(a)", "{a}", "(a N)", "{a N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.3007\na\u271d : \u2115 \u2192 \u2115\nN\u271d : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nN : \u2115\nx\u271d\u00b9 : Sort u_1\nBig : x\u271d\u00b9\nx\u271d : Sort u_2\nN' : x\u271d\ni j : \u2115\nhj : a j = a i\nh : sorry\nhN' : sorry \u2264 i\n\u22a2 j \u2208 {t | a t = a i}"}, {"line": "simpa using hj\n  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' \u25b8 hj').1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma small_apply_sub_one_of_apply_eq_of_apply_big_of_N'_le {i j : \u2115} (hj : a j = a i)\n    (h : Big a (a i)) (hN' : N' a N \u2264 i) : Small a (a (j - 1)) :=\n  have hj' : j \u2208 {t | a t = a i} := by simpa using hj\n  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' \u25b8 hj').2.1\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}", "(a)", "{a}", "(a N)", "{a N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.3007\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nx\u271d\u00b9 : Sort u_1\nBig : x\u271d\u00b9\nx\u271d : Sort u_2\nN' : x\u271d\ni j : \u2115\nhj : a j = a i\nh : sorry\nhN' : sorry \u2264 i\n\u22a2 j \u2208 {t | a t = a i}"}, {"line": "simpa using hj\n  (hc.setOf_apply_eq_of_apply_big_of_N'_le h hN' \u25b8 hj').2.1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MonsterData.not_mem_monsterCells_of_fst_eq_zero (m : MonsterData N)\n    {c : Cell N} (hc : c.1 = 0) : c \u2209 m.monsterCells := by\n  simp [monsterCells, Prod.ext_iff, hc]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nCell : x\u271d\nm : sorry\nc : sorry\nhc : sorry = 0\n\u22a2 c \u2209 sorry"}, {"line": "simp [monsterCells, Prod.ext_iff, hc]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nCell : x\u271d\nm : sorry\nc : sorry\nhc : sorry = 0\n\u22a2 c \u2209 sorry ()"}]}
{"declaration": "lemma find?_eq_eq_find?_le {l : List (Cell N)} {r : Fin (N + 2)} (hne : l \u2260 [])\n    (hf : (l.head hne).1 \u2264 r) (ha : l.Chain' Adjacent) :\n    l.find? (fun c \u21a6 c.1 = r) = l.find? (fun c \u21a6 r \u2264 c.1) := by\n  induction l\n  case nil => simp at hne\n  case cons head tail hi =>\n    by_cases h : head.1 = r\n    \u00b7 simp [h]\n    \u00b7 have h' : \u00ac(r \u2264 head.1) := fun hr' \u21a6 h (le_antisymm hf hr')\n      simp only [h]\n      simp only [decide_false]\n      simp only [Bool.false_eq_true]\n      simp only [not_false_eq_true]\n      simp only [List.find?_cons_of_neg]\n      simp only [h']\n      rcases tail with \u27e8\u27e9 | \u27e8htail, ttail\u27e9\n      \u00b7 simp\n      \u00b7 simp only [List.chain'_cons] at ha\n        rcases ha with \u27e8ha1, ha2\u27e9\n        simp only [List.head_cons] at hf\n        simp only [ne_eq] at hi\n        simp only [reduceCtorEq] at hi\n        simp only [not_false_eq_true] at hi\n        simp only [List.head_cons] at hi\n        simp only [ha2] at hi\n        simp only [true_implies] at hi\n        refine hi ?_\n        simp only [Adjacent] at ha1\n        simp only [Nat.dist] at ha1\n        omega\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nCell : x\u271d\nAdjacent : sorry \u2192 sorry \u2192 Prop\nl : List sorry\nr : Fin (N + 2)\nhne : l \u2260 []\nhf : sorry \u2264 r\nha : List.Chain' Adjacent l\n\u22a2 List.find? (fun c => decide (sorry = r)) l = List.find? (fun c => decide (r \u2264 sorry)) l"}, {"line": "induction l", "tactic_state": "case nil\nN : \u2115\nx\u271d : Sort u_1\nCell : x\u271d\nAdjacent : sorry \u2192 sorry \u2192 Prop\nr : Fin (N + 2)\nhf : sorry \u2264 r\nhne : [] \u2260 []\nha : List.Chain' Adjacent []\n\u22a2 List.find? (fun c => decide (sorry = r)) [] = List.find? (fun c => decide (r \u2264 sorry)) []\n---\ncase cons\nN : \u2115\nx\u271d : Sort u_1\nCell : x\u271d\nAdjacent : sorry \u2192 sorry \u2192 Prop\nr : Fin (N + 2)\nhf : sorry \u2264 r\nhead\u271d : sorry\ntail\u271d : List sorry\ntail_ih\u271d :\n  tail\u271d \u2260 [] \u2192\n    List.Chain' Adjacent tail\u271d \u2192\n      List.find? (fun c => decide (sorry = r)) tail\u271d = List.find? (fun c => decide (r \u2264 sorry)) tail\u271d\nhne : head\u271d :: tail\u271d \u2260 []\nha : List.Chain' Adjacent (head\u271d :: tail\u271d)\n\u22a2 List.find? (fun c => decide (sorry = r)) (head\u271d :: tail\u271d) = List.find? (fun c => decide (r \u2264 sorry)) (head\u271d :: tail\u271d)"}, {"line": "case nil => simp at hne", "tactic_state": "case cons\nN : \u2115\nx\u271d : Sort u_1\nCell : x\u271d\nAdjacent : sorry \u2192 sorry \u2192 Prop\nr : Fin (N + 2)\nhf : sorry \u2264 r\nhead\u271d : sorry\ntail\u271d : List sorry\ntail_ih\u271d :\n  tail\u271d \u2260 [] \u2192\n    List.Chain' Adjacent tail\u271d \u2192\n      List.find? (fun c => decide (sorry = r)) tail\u271d = List.find? (fun c => decide (r \u2264 sorry)) tail\u271d\nhne : head\u271d :: tail\u271d \u2260 []\nha : List.Chain' Adjacent (head\u271d :: tail\u271d)\n\u22a2 List.find? (fun c => decide (sorry = r)) (head\u271d :: tail\u271d) = List.find? (fun c => decide (r \u2264 sorry)) (head\u271d :: tail\u271d)"}, {"line": "case cons head tail hi =>\n    by_cases h : head.1 = r\n    \u00b7 simp [h]\n    \u00b7 have h' : \u00ac(r \u2264 head.1) := fun hr' \u21a6 h (le_antisymm hf hr')\n      simp only [h]\n      simp only [decide_false]\n      simp only [Bool.false_eq_true]\n      simp only [not_false_eq_true]\n      simp only [List.find?_cons_of_neg]\n      simp only [h']\n      rcases tail with \u27e8\u27e9 | \u27e8htail, ttail\u27e9\n      \u00b7 simp\n      \u00b7 simp only [List.chain'_cons] at ha\n        rcases ha with \u27e8ha1, ha2\u27e9\n        simp only [List.head_cons] at hf\n        simp only [ne_eq] at hi\n        simp only [reduceCtorEq] at hi\n        simp only [not_false_eq_true] at hi\n        simp only [List.head_cons] at hi\n        simp only [ha2] at hi\n        simp only [true_implies] at hi\n        refine hi ?_\n        simp only [Adjacent] at ha1\n        simp only [Nat.dist] at ha1\n        omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Path.ofFn_firstMonster_eq_none {m : \u2115} (f : Fin m \u2192 Cell N) (hm hf hl ha)\n    (m : MonsterData N) :\n    ((Path.ofFn f hm hf hl ha).firstMonster m) = none \u2194 \u2200 i, f i \u2209 m.monsterCells := by\n  simp [firstMonster_eq_none, ofFn_cells, List.mem_ofFn]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nCell : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\nm\u271d : \u2115\nf : Fin m\u271d \u2192 sorry\nhm : ?m.4039 f\nhf : ?m.4040 f hm\nhl : ?m.4041 f hm hf\nha : ?m.4042 f hm hf hl\nm : sorry\n\u22a2 sorry = none \u2194 \u2200 (i : Fin m\u271d), f i \u2209 ?m.879"}, {"line": "simp [firstMonster_eq_none, ofFn_cells, List.mem_ofFn]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nCell : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\nm\u271d : \u2115\nf : Fin m\u271d \u2192 sorry\nhm : ?m.4039 f\nhf : ?m.4040 f hm\nhl : ?m.4041 f hm hf\nha : ?m.4042 f hm hf hl\nm : sorry\n\u22a2 sorry () = none \u2194 \u2200 (i : Fin m\u271d), f i \u2209 ?m.879"}]}
{"declaration": "lemma Strategy.play_comp_castLE (s : Strategy N) (m : MonsterData N) {k\u2081 k\u2082 : \u2115} (hk : k\u2081 \u2264 k\u2082) :\n    s.play m k\u2082 \u2218 Fin.castLE hk = s.play m k\u2081 := by\n  induction hk\n  case refl => rfl\n  case step k' hk' hki =>\n    rw [\u2190 hki]\n    rw [\u2190 Fin.castLE_comp_castLE hk' (Nat.le_succ k')]\n    rw [\u2190 Function.comp_assoc]\n    convert rfl\n    exact Fin.snoc_comp_castSucc.symm\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nStrategy : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\ns : sorry\nm : sorry\nk\u2081 k\u2082 : \u2115\nhk : k\u2081 \u2264 k\u2082\n\u22a2 sorry \u2218 Fin.castLE hk = sorry"}, {"line": "induction hk", "tactic_state": "case refl\nx\u271d\u00b9 : Sort u_1\nStrategy : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\ns : sorry\nm : sorry\nk\u2081 k\u2082 : \u2115\n\u22a2 sorry \u2218 Fin.castLE \u22ef = sorry\n---\ncase step\nx\u271d\u00b9 : Sort u_1\nStrategy : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\ns : sorry\nm : sorry\nk\u2081 k\u2082 m\u271d : \u2115\na\u271d : k\u2081.le m\u271d\na_ih\u271d : sorry \u2218 Fin.castLE a\u271d = sorry\n\u22a2 sorry \u2218 Fin.castLE \u22ef = sorry"}, {"line": "case refl => rfl", "tactic_state": "case step\nx\u271d\u00b9 : Sort u_1\nStrategy : x\u271d\u00b9\nx\u271d : Sort u_2\nMonsterData : x\u271d\ns : sorry\nm : sorry\nk\u2081 k\u2082 m\u271d : \u2115\na\u271d : k\u2081.le m\u271d\na_ih\u271d : sorry \u2218 Fin.castLE a\u271d = sorry\n\u22a2 sorry \u2218 Fin.castLE \u22ef = sorry"}, {"line": "case step k' hk' hki =>\n    rw [\u2190 hki]\n    rw [\u2190 Fin.castLE_comp_castLE hk' (Nat.le_succ k')]\n    rw [\u2190 Function.comp_assoc]\n    convert rfl\n    exact Fin.snoc_comp_castSucc.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma row2_mem_monsterCells_monsterData12 (hN : 2 \u2264 N) {c\u2081 c\u2082 : Fin (N + 1)} (h : c\u2081 \u2260 c\u2082) :\n    (\u27e82, by omega\u27e9, c\u2082) \u2208 (monsterData12 hN c\u2081 c\u2082).monsterCells := by\n  convert Set.mem_range_self (row2 hN)\n  exact (monsterData12_apply_row2 hN h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 (sorry, c\u2082) \u2208 sorry"}, {"line": "convert Set.mem_range_self (row2 hN)", "tactic_state": "case a\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 (sorry, c\u2082) \u2208 sorry \u2194 ?convert_3 sorry \u2208 Set.range ?convert_3\n---\ncase convert_1\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Type ?u.1834\n---\ncase convert_2\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Sort ?u.1833\n---\ncase convert_3\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 ?convert_2 \u2192 ?convert_1"}, {"line": "exact (monsterData12_apply_row2 hN h).symm", "tactic_state": "case convert_1\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Type ?u.1834\n---\ncase convert_2\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Sort ?u.1833\n---\ncase convert_3\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 ?convert_2 \u2192 ?convert_1"}]}
{"declaration": "lemma Strategy.ForcesWinIn.three_le {s : Strategy N} {k : \u2115} (hf : s.ForcesWinIn k)\n    (hN : 2 \u2264 N) : 3 \u2264 k := by\n  by_contra hk\n  exact s.not_forcesWinIn_two hN (Strategy.ForcesWinIn.mono s hf (by omega))\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nStrategy : x\u271d\ns : sorry\nk : \u2115\nhf : sorry\nhN : 2 \u2264 N\n\u22a2 3 \u2264 k"}, {"line": "by_contra hk", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nStrategy : x\u271d\ns : sorry\nk : \u2115\nhf : sorry\nhN : 2 \u2264 N\nhk : \u00ac3 \u2264 k\n\u22a2 False"}, {"line": "exact s.not_forcesWinIn_two hN (Strategy.ForcesWinIn.mono s hf (by omega))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma winningStrategy_play_one_eq_none_or_play_two_eq_none (hN : 2 \u2264 N) (m : MonsterData N) :\n    (winningStrategy hN).play m 3 \u27e81, by norm_num\u27e9 = none \u2228\n      (winningStrategy hN).play m 3 \u27e82, by norm_num\u27e9 = none := by\n  by_cases hc\u20810 : m (row1 hN) = 0\n  \u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_edge_zero hN hc\u20810\n  \u00b7 by_cases hc\u2081N : (m (row1 hN) : \u2115) = N\n    \u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_edge_N hN hc\u2081N\n    \u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_not_edge hN hc\u20810 hc\u2081N\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nwinningStrategy : x\u271d\nhN : 2 \u2264 N\nm : sorry\n\u22a2 sorry = none \u2228 sorry = none"}, {"line": "by_cases hc\u20810 : m (row1 hN) = 0", "tactic_state": "case pos\nN : \u2115\nx\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nwinningStrategy : x\u271d\nhN : 2 \u2264 N\nm : sorry\nhc\u20810 : sorry = 0\n\u22a2 sorry = none \u2228 sorry = none\n---\ncase neg\nN : \u2115\nx\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nwinningStrategy : x\u271d\nhN : 2 \u2264 N\nm : sorry\nhc\u20810 : \u00acsorry = 0\n\u22a2 sorry = none \u2228 sorry = none"}, {"line": "\u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_edge_zero hN hc\u20810", "tactic_state": "case neg\nN : \u2115\nx\u271d\u00b9 : Sort u_1\nMonsterData : x\u271d\u00b9\nx\u271d : Sort u_2\nwinningStrategy : x\u271d\nhN : 2 \u2264 N\nm : sorry\nhc\u20810 : \u00acsorry = 0\n\u22a2 sorry = none \u2228 sorry = none"}, {"line": "\u00b7 by_cases hc\u2081N : (m (row1 hN) : \u2115) = N\n    \u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_edge_N hN hc\u2081N\n    \u00b7 exact winningStrategy_play_one_eq_none_or_play_two_eq_none_of_not_edge hN hc\u20810 hc\u2081N", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_apply (x : G) : f (-(f x)) = -x := by\n  rw [\u2190 add_eq_zero_iff_eq_neg]\n  exact h.apply_neg_apply_add x\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx : G\n\u22a2 f (-f x) = -x"}, {"line": "rw [\u2190 add_eq_zero_iff_eq_neg]", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx : G\n\u22a2 f (-f x) + x = 0"}, {"line": "exact h.apply_neg_apply_add x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_of_apply_eq {x\u2081 x\u2082 : G} (hx : f x\u2081 = x\u2082) : f (-x\u2082) = -x\u2081 := by\n  rw [\u2190 hx]\n  exact h.apply_neg_apply _\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhx : f x\u2081 = x\u2082\n\u22a2 f (-x\u2082) = -x\u2081"}, {"line": "rw [\u2190 hx]", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhx : f x\u2081 = x\u2082\n\u22a2 f (-f x\u2081) = -x\u2081"}, {"line": "exact h.apply_neg_apply _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_eq_neg_iff {x\u2081 x\u2082 : G} : f (-x\u2082) = -x\u2081 \u2194 f x\u2081 = x\u2082 := by\n  refine \u27e8fun hn \u21a6 ?_, h.apply_neg_of_apply_eq\u27e9\n  convert h.apply_neg_of_apply_eq hn <;> rw [neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\n\u22a2 f (-x\u2082) = -x\u2081 \u2194 f x\u2081 = x\u2082"}, {"line": "refine \u27e8fun hn \u21a6 ?_, h.apply_neg_of_apply_eq\u27e9", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhn : f (-x\u2082) = -x\u2081\n\u22a2 f x\u2081 = x\u2082"}, {"line": "convert h.apply_neg_of_apply_eq hn <;> rw [neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.pair_lemma {x u v : G} (huv : u \u2260 v) (hx : f x = u \u2228 f u = x)\n    (hy : f x = v \u2228 f v = x) : f x = v \u2228 f x = u := by\n  rcases hx with hx | hx <;> rcases hy with hy | hy\n  \u00b7 exact (huv (hx.symm.trans hy)).elim\n  \u00b7 exact .inr hx\n  \u00b7 exact .inl hy\n  \u00b7 exact ((h.injective.ne huv) (hx.trans hy.symm)).elim\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u \u2228 f u = x\nhy : f x = v \u2228 f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "rcases hx with hx | hx <;> rcases hy with hy | hy", "tactic_state": "case inl.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inl.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact (huv (hx.symm.trans hy)).elim", "tactic_state": "case inl.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact .inr hx", "tactic_state": "case inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact .inl hy", "tactic_state": "case inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact ((h.injective.ne huv) (hx.trans hy.symm)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fract_fExample (x : \u211a) :\n    Int.fract (fExample x) = if Int.fract x = 0 then 0 else 1 - Int.fract x := by\n  by_cases h : Int.fract x = 0\n  \u00b7 simp [fExample, h]\n  \u00b7 simp [fExample, h, sub_eq_add_neg, Int.fract_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "by_cases h : Int.fract x = 0", "tactic_state": "case pos\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : Int.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x\n---\ncase neg\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : \u00acInt.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "\u00b7 simp [fExample, h]", "tactic_state": "case neg\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : \u00acInt.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "\u00b7 simp [fExample, h, sub_eq_add_neg, Int.fract_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"UMI\") : Derivable \"UMIU\" := by\n  change Derivable ([U, M] ++ [I, U])\n  exact Derivable.r1 h -- Rule 1\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([U, M] ++ [I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r1 h -- Rule 1", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"MIIU\") : Derivable \"MIIUIIU\" := by\n  change Derivable (M :: [I, I, U] ++ [I, I, U])\n  exact Derivable.r2 h -- Rule 2\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable (M :: [I, I, U] ++ [I, I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r2 h -- Rule 2", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"UIUMIIIMMM\") : Derivable \"UIUMUMMM\" := by\n  change Derivable ([U, I, U, M] ++ U :: [M, M, M])\n  exact Derivable.r3 h -- Rule 3\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([U, I, U, M] ++ U :: [M, M, M])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r3 h -- Rule 3", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"MIMIMUUIIM\") : Derivable \"MIMIMIIM\" := by\n  change Derivable ([M, I, M, I, M] ++ [I, I, M])\n  exact Derivable.r4 h -- Rule 4\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([M, I, M, I, M] ++ [I, I, M])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r4 h -- Rule 4", "tactic_state": "No Goals!"}]}
{"declaration": "example : Derivable \"MIUIU\" := by\n  change Derivable (M :: [I, U] ++ [I, U])\n  exact Derivable.r2 MIU_der -- `\"MIUIU\"` can be derived as `\"MIU\"` can.\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry"}, {"line": "change Derivable (M :: [I, U] ++ [I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry"}, {"line": "exact Derivable.r2 MIU_der -- `\"MIUIU\"` can be derived as `\"MIU\"` can.", "tactic_state": "No Goals!"}]}
{"declaration": "example : Derivable \"MUI\" := by\n  have h\u2082 : Derivable \"MII\" := by\n    change Derivable (M :: [I] ++ [I])\n    exact Derivable.r2 Derivable.mk\n  have h\u2083 : Derivable \"MIIII\" := by\n    change Derivable (M :: [I, I] ++ [I, I])\n    exact Derivable.r2 h\u2082\n  change Derivable ([M] ++ U :: [I])\n  exact Derivable.r3 h\u2083 -- We prove our main goal using rule 3\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry"}, {"line": "have h\u2082 : Derivable \"MII\" := sorry", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh\u2082 : sorry\n\u22a2 sorry"}, {"line": "have h\u2083 : Derivable \"MIIII\" := sorry", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh\u2082 : sorry\nh\u2083 : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([M] ++ U :: [I])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh\u2082 : sorry\nh\u2083 : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r3 h\u2083 -- We prove our main goal using rule 3", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem der_cons_replicate (n : \u2115) : Derivable (M :: replicate (2 ^ n) I) := by\n  induction' n with k hk\n  \u00b7 -- base case\n    constructor\n  \u00b7 -- inductive step\n    rw [pow_add]\n    rw [pow_one 2]\n    rw [mul_two]\n    rw [replicate_add]\n    exact Derivable.r2 hk\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/DecisionSuf.lean", "context": {"open": ["MiuAtom List Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nn : \u2115\n\u22a2 sorry"}, {"line": "induction' n with k hk", "tactic_state": "case zero\nx\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry\n---\ncase succ\nx\u271d : Sort u_1\nDerivable : x\u271d\nk : \u2115\nhk : sorry\n\u22a2 sorry"}, {"line": "\u00b7 -- base case\n    constructor", "tactic_state": "case succ\nx\u271d : Sort u_1\nDerivable : x\u271d\nk : \u2115\nhk : sorry\n\u22a2 sorry"}, {"line": "\u00b7 -- inductive step\n    rw [pow_add]\n    rw [pow_one 2]\n    rw [mul_two]\n    rw [replicate_add]\n    exact Derivable.r2 hk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem der_cons_replicate_I_replicate_U_append_of_der_cons_replicate_I_append (c k : \u2115)\n    (_ : c % 3 = 1 \u2228 c % 3 = 2) (xs : Miustr)\n    (hder : Derivable (\u2191(M :: replicate (c + 3 * k) I) ++ xs)) :\n    Derivable (\u2191(M :: (replicate c I ++ replicate k U)) ++ xs) := by\n  revert xs\n  induction' k with a ha\n  \u00b7 simp only [replicate, zero_eq, mul_zero, add_zero, append_nil, forall_true_iff, imp_self]\n  \u00b7 intro xs\n    specialize ha (U :: xs)\n    intro h\u2082\n    -- We massage the goal into a form amenable to the application of `ha`.\n    rw [replicate_add]\n    rw [\u2190 append_assoc]\n    rw [\u2190 cons_append]\n    rw [replicate_one]\n    rw [append_assoc]\n    rw [singleton_append]\n    apply ha\n    apply Derivable.r3\n    change Derivable (\u2191(M :: replicate (c + 3 * a) I) ++ \u2191(replicate 3 I) ++ xs)\n    rwa [cons_append, \u2190 replicate_add, add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/MiuLanguage/DecisionSuf.lean", "context": {"open": ["MiuAtom List Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Miustr : Sort u_1\nx\u271d\u00b9 : Sort u_2\nDerivable : x\u271d\u00b9\nc k : \u2115\nx\u271d : c % 3 = 1 \u2228 c % 3 = 2\nxs : Miustr\nhder : sorry\n\u22a2 sorry"}, {"line": "revert xs", "tactic_state": "Miustr : Sort u_1\nx\u271d\u00b9 : Sort u_2\nDerivable : x\u271d\u00b9\nc k : \u2115\nx\u271d : c % 3 = 1 \u2228 c % 3 = 2\nhder : sorry\n\u22a2 Miustr \u2192 sorry"}, {"line": "induction' k with a ha", "tactic_state": "case zero\nMiustr : Sort u_1\nx\u271d\u00b9 : Sort u_2\nDerivable : x\u271d\u00b9\nc : \u2115\nx\u271d : c % 3 = 1 \u2228 c % 3 = 2\nhder : sorry\n\u22a2 Miustr \u2192 sorry\n---\ncase succ\nMiustr : Sort u_1\nx\u271d\u00b9 : Sort u_2\nDerivable : x\u271d\u00b9\nc : \u2115\nx\u271d : c % 3 = 1 \u2228 c % 3 = 2\nhder : sorry\na : \u2115\nha : Miustr \u2192 sorry\n\u22a2 Miustr \u2192 sorry"}, {"line": "\u00b7 simp only [replicate, zero_eq, mul_zero, add_zero, append_nil, forall_true_iff, imp_self]", "tactic_state": "case succ\nMiustr : Sort u_1\nx\u271d\u00b9 : Sort u_2\nDerivable : x\u271d\u00b9\nc : \u2115\nx\u271d : c % 3 = 1 \u2228 c % 3 = 2\nhder : sorry\na : \u2115\nha : Miustr \u2192 sorry\n\u22a2 Miustr \u2192 sorry"}, {"line": "\u00b7 intro xs\n    specialize ha (U :: xs)\n    intro h\u2082\n    rw [replicate_add]\n    rw [\u2190 append_assoc]\n    rw [\u2190 cons_append]\n    rw [replicate_one]\n    rw [append_assoc]\n    rw [singleton_append]\n    apply ha\n    apply Derivable.r3\n    change Derivable (\u2191(M :: replicate (c + 3 * a) I) ++ \u2191(replicate 3 I) ++ xs)\n    rwa [cons_append, \u2190 replicate_add, add_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setOf_odd_degree_eq :\n    {v | Odd (graph.degree v)} = {Verts.V1, Verts.V2, Verts.V3, Verts.V4} := by\n  ext w\n  simp [not_even_degree_iff, \u2190 Nat.not_even_iff_odd]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/Konigsberg.lean", "context": {"open": ["Verts"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 {v | Odd sorry} = sorry"}, {"line": "ext w", "tactic_state": "case h\nw : ?m.4\n\u22a2 w \u2208 {v | Odd sorry} \u2194 w \u2208 sorry"}, {"line": "simp [not_even_degree_iff, \u2190 Nat.not_even_iff_odd]", "tactic_state": "case h\nw : ?m.4\n\u22a2 Odd (sorry ()) \u2194 w \u2208 sorry ()"}]}
{"declaration": "theorem cube_root_of_unity_sum (h\u03c9 : IsPrimitiveRoot \u03c9 3) : 1 + \u03c9 + \u03c9 ^ 2 = 0 := by\n  simpa [cyclotomic_prime, Finset.sum_range_succ] using h\u03c9.isRoot_cyclotomic (by decide)\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/SolutionOfCubicQuartic.lean", "context": {"open": ["Polynomial"], "variables": ["{K : Type*} [Field K] (a b c d e : K) {\u03c9 p q r s t u v w x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\n\u03c9 : K\nh\u03c9 : IsPrimitiveRoot \u03c9 3\n\u22a2 1 + \u03c9 + \u03c9 ^ 2 = 0"}, {"line": "simpa [cyclotomic_prime, Finset.sum_range_succ] using h\u03c9.isRoot_cyclotomic (by decide)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_Phi {S : Type*} [CommRing S] (f : R \u2192+* S) : (\u03a6 R a b).map f = \u03a6 S a b := by simp [\u03a6]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\n\u03a6 : x\u271d\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\n\u22a2 sorry = sorry"}, {"line": "simp [\u03a6]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\n\u03a6 : x\u271d\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem coeff_zero_Phi : (\u03a6 R a b).coeff 0 = (b : R) := by simp [\u03a6, coeff_X_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nb : \u2115\nx\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry = \u2191b"}, {"line": "simp [\u03a6, coeff_X_pow]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nb : \u2115\nx\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry () = \u2191b"}]}
{"declaration": "theorem coeff_five_Phi : (\u03a6 R a b).coeff 5 = 1 := by\n  simp [\u03a6, coeff_X, coeff_C, -map_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [\u03a6, coeff_X, coeff_C, -map_natCast]", "tactic_state": "x\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem not_solvable_by_rad' (x : \u2102) (hx : aeval x (\u03a6 \u211a 4 2) = 0) : \u00acIsSolvableByRad \u211a x := by\n  apply not_solvable_by_rad 4 2 2 x hx <;> decide\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\n\u03a6 : x\u271d\nx : \u2102\nhx : (aeval x) sorry = 0\n\u22a2 \u00acIsSolvableByRad \u211a x"}, {"line": "apply not_solvable_by_rad 4 2 2 x hx <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_not_solvable_by_rad : \u2203 x : \u2102, IsAlgebraic \u211a x \u2227 \u00acIsSolvableByRad \u211a x := by\n  obtain \u27e8x, hx\u27e9 := exists_root_of_splits (algebraMap \u211a \u2102) (IsAlgClosed.splits_codomain (\u03a6 \u211a 4 2))\n    (ne_of_eq_of_ne (degree_Phi 4 2) (mt WithBot.coe_eq_coe.mp (show 5 \u2260 0 by norm_num)))\n  exact \u27e8x, \u27e8\u03a6 \u211a 4 2, (monic_Phi 4 2).ne_zero, hx\u27e9, not_solvable_by_rad' x hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, IsAlgebraic \u211a x \u2227 \u00acIsSolvableByRad \u211a x"}, {"line": "obtain \u27e8x, hx\u27e9 := exists_root_of_splits (algebraMap \u211a \u2102) (IsAlgClosed.splits_codomain (\u03a6 \u211a 4 2))\n    (ne_of_eq_of_ne (degree_Phi 4 2) (mt WithBot.coe_eq_coe.mp (show 5 \u2260 0 by norm_num)))", "tactic_state": "case intro\nx : \u2102\nhx : eval\u2082 (algebraMap \u211a \u2102) x sorry = 0\n\u22a2 \u2203 x, IsAlgebraic \u211a x \u2227 \u00acIsSolvableByRad \u211a x"}, {"line": "exact \u27e8x, \u27e8\u03a6 \u211a 4 2, (monic_Phi 4 2).ne_zero, hx\u27e9, not_solvable_by_rad' x hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem counted_ne_nil_left {p q : \u2115} (hp : p \u2260 0) {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l \u2260 [] := by simp [counted_eq_nil_iff hl, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhp : p \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l \u2260 []"}, {"line": "simp [counted_eq_nil_iff hl, hp]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhp : p \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 \u00acl = []"}]}
{"declaration": "theorem counted_ne_nil_right {p q : \u2115} (hq : q \u2260 0) {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l \u2260 [] := by simp [counted_eq_nil_iff hl, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhq : q \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l \u2260 []"}, {"line": "simp [counted_eq_nil_iff hl, hq]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhq : q \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 \u00acl = []"}]}
{"declaration": "theorem sum_of_mem_countedSequence {p q} {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l.sum = p - q := by simp [(mem_countedSequence_iff_perm.1 hl).sum_eq, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2124\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l.sum = p - q"}, {"line": "simp [(mem_countedSequence_iff_perm.1 hl).sum_eq, sub_eq_add_neg]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2124\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l.sum = p + -q"}]}
{"declaration": "theorem disjoint_bits (p q : \u2115) :\n    Disjoint (List.cons 1 '' countedSequence p (q + 1))\n      (List.cons (-1) '' countedSequence (p + 1) q) := by\n  simp_rw [disjoint_left, mem_image, not_exists, exists_imp]\n  rintro _ _ \u27e8_, rfl\u27e9 _ \u27e8_, _, _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\n\u22a2 Disjoint (List.cons 1 '' sorry) (List.cons (-1) '' sorry)"}, {"line": "simp_rw [disjoint_left, mem_image, not_exists, exists_imp]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\n\u22a2 \u2200 \u2983a : List \u2124\u2984 (x : List \u2124), x \u2208 sorry \u2227 1 :: x = a \u2192 \u2200 (x : List \u2124), \u00ac(x \u2208 sorry \u2227 -1 :: x = a)"}, {"line": "rintro _ _ \u27e8_, rfl\u27e9 _ \u27e8_, _, _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intervalIntegrable_min_const_sin_mul (a b : \u211d) :\n    IntervalIntegrable (fun (\u03b8 : \u211d) => min d (\u03b8.sin * l)) \u2119 a b := by\n  apply Continuous.intervalIntegrable\n  exact Continuous.min continuous_const (Continuous.mul Real.continuous_sin continuous_const)\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BuffonsNeedle.lean", "context": {"open": ["MeasureTheory (MeasureSpace IsProbabilityMeasure Measure pdf.IsUniform)", "ProbabilityTheory Real"], "variables": [""]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d l a b : \u211d\n\u22a2 IntervalIntegrable (fun \u03b8 => min d (sin \u03b8 * l)) MeasureTheory.volume a b"}, {"line": "apply Continuous.intervalIntegrable", "tactic_state": "case hu\nd l a b : \u211d\n\u22a2 Continuous fun \u03b8 => min d (sin \u03b8 * l)"}, {"line": "exact Continuous.min continuous_const (Continuous.mul Real.continuous_sin continuous_const)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_zero_to_arcsin_min :\n    \u222b \u03b8 in (0)..(d / l).arcsin, min d (\u03b8.sin * l) = (1 - \u221a(1 - (d / l) ^ 2)) * l := by\n  have : Set.EqOn (fun \u03b8 => min d (\u03b8.sin * l)) (Real.sin \u00b7 * l) (Set.uIcc 0 (d / l).arcsin) := by\n    intro \u03b8 \u27e8h\u03b8\u2081, h\u03b8\u2082\u27e9\n    have : 0 \u2264 (d / l).arcsin := Real.arcsin_nonneg.mpr (div_nonneg hd.le hl.le)\n    simp only [min_eq_left this] at h\u03b8\u2081 h\u03b8\u2082\n    simp only [max_eq_right this] at h\u03b8\u2081 h\u03b8\u2082\n    have h\u03b8_mem : \u03b8 \u2208 Set.Ioc (-(\u03c0 / 2)) (\u03c0 / 2) := by\n      exact \u27e8lt_of_lt_of_le (neg_lt_zero.mpr (div_pos Real.pi_pos two_pos)) h\u03b8\u2081,\n        le_trans h\u03b8\u2082 (d / l).arcsin_mem_Icc.right\u27e9\n    simp_rw [min_eq_right ((le_div_iff\u2080 hl).mp ((Real.le_arcsin_iff_sin_le' h\u03b8_mem).mp h\u03b8\u2082))]\n  rw [intervalIntegral.integral_congr this]\n  rw [intervalIntegral.integral_mul_const]\n  rw [integral_sin]\n  rw [Real.cos_zero]\n  rw [Real.cos_arcsin]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BuffonsNeedle.lean", "context": {"open": ["MeasureTheory (MeasureSpace IsProbabilityMeasure Measure pdf.IsUniform)", "ProbabilityTheory Real"], "variables": [""]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d l : \u211d\n\u22a2 \u222b (\u03b8 : \u211d) in 0 ..arcsin (d / l), min d (sin \u03b8 * l) = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "have : Set.EqOn (fun \u03b8 => min d (\u03b8.sin * l)) (Real.sin \u00b7 * l) (Set.uIcc 0 (d / l).arcsin) := by\n    intro \u03b8 \u27e8h\u03b8\u2081, h\u03b8\u2082\u27e9\n    have : 0 \u2264 (d / l).arcsin := Real.arcsin_nonneg.mpr (div_nonneg hd.le hl.le)\n    simp only [min_eq_left this] at h\u03b8\u2081 h\u03b8\u2082\n    simp only [max_eq_right this] at h\u03b8\u2081 h\u03b8\u2082\n    have h\u03b8_mem : \u03b8 \u2208 Set.Ioc (-(\u03c0 / 2)) (\u03c0 / 2) := by\n      exact \u27e8lt_of_lt_of_le (neg_lt_zero.mpr (div_pos Real.pi_pos two_pos)) h\u03b8\u2081,\n        le_trans h\u03b8\u2082 (d / l).arcsin_mem_Icc.right\u27e9\n    simp_rw [min_eq_right ((le_div_iff\u2080 hl).mp ((Real.le_arcsin_iff_sin_le' h\u03b8_mem).mp h\u03b8\u2082))]", "tactic_state": "d l : \u211d\nthis : Set.EqOn (fun \u03b8 => min d (sin \u03b8 * l)) (fun x => sin x * l) (Set.uIcc 0 (arcsin (d / l)))\n\u22a2 \u222b (\u03b8 : \u211d) in 0 ..arcsin (d / l), min d (sin \u03b8 * l) = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "rw [intervalIntegral.integral_congr this]", "tactic_state": "d l : \u211d\nthis : Set.EqOn (fun \u03b8 => min d (sin \u03b8 * l)) (fun x => sin x * l) (Set.uIcc 0 (arcsin (d / l)))\n\u22a2 \u222b (x : \u211d) in 0 ..arcsin (d / l), sin x * l = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "rw [intervalIntegral.integral_mul_const]", "tactic_state": "d l : \u211d\nthis : Set.EqOn (fun \u03b8 => min d (sin \u03b8 * l)) (fun x => sin x * l) (Set.uIcc 0 (arcsin (d / l)))\n\u22a2 (\u222b (x : \u211d) in 0 ..arcsin (d / l), sin x) * l = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "rw [integral_sin]", "tactic_state": "d l : \u211d\nthis : Set.EqOn (fun \u03b8 => min d (sin \u03b8 * l)) (fun x => sin x * l) (Set.uIcc 0 (arcsin (d / l)))\n\u22a2 (cos 0 - cos (arcsin (d / l))) * l = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "rw [Real.cos_zero]", "tactic_state": "d l : \u211d\nthis : Set.EqOn (fun \u03b8 => min d (sin \u03b8 * l)) (fun x => sin x * l) (Set.uIcc 0 (arcsin (d / l)))\n\u22a2 (1 - cos (arcsin (d / l))) * l = (1 - \u221a(1 - (d / l) ^ 2)) * l"}, {"line": "rw [Real.cos_arcsin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem b_mem_side (c : Cube n) (j : Fin n) : c.b j \u2208 c.side j := by simp [side, Cube.hw, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nCube : x\u271d\nc : sorry\nj : Fin n\n\u22a2 sorry \u2208 sorry"}, {"line": "simp [side, Cube.hw, le_refl]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nCube : x\u271d\nc : sorry\nj : Fin n\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem side_nonempty (c : Cube n) (i : Fin n) : (side c i).Nonempty := by simp [side, c.hw]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nCube : x\u271d\u00b9\nx\u271d : Sort u_2\nside : x\u271d\nc : sorry\ni : Fin n\n\u22a2 sorry"}, {"line": "simp [side, c.hw]", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nCube : x\u271d\u00b9\nx\u271d : Sort u_2\nside : x\u271d\nc : sorry\ni : Fin n\n\u22a2 sorry ()"}]}
{"declaration": "theorem b_mem_toSet (c : Cube n) : c.b \u2208 c.toSet := by simp [toSet]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry \u2208 sorry"}, {"line": "simp [toSet]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem b_mem_bottom (c : Cube (n + 1)) : c.b \u2208 c.bottom := by\n  simp [bottom, toSet, side, Cube.hw, le_refl, Cube.tail]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry \u2208 sorry"}, {"line": "simp [bottom, toSet, side, Cube.hw, le_refl, Cube.tail]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem b_lt_xm (c : Cube (n + 1)) : c.b 0 < c.xm := by simp [xm, hw]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry < sorry"}, {"line": "simp [xm, hw]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () < sorry ()"}]}
{"declaration": "theorem tail_shiftUp (c : Cube (n + 1)) : c.shiftUp.tail = c.tail := by simp [shiftUp, Cube.tail]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [shiftUp, Cube.tail]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem side_unitCube {j : Fin n} : unitCube.side j = Ico 0 1 := by\n  norm_num [unitCube, side]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry = Ico 0 1"}, {"line": "norm_num [unitCube, side]", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry () = Ico 0 1"}]}
{"declaration": "theorem side_subset {i j} : (cs i).side j \u2286 Ico 0 1 := by\n  simpa only [side_unitCube] using toSet_subset.1 h.toSet_subset_unitCube j\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin", "Cube"], "variables": ["{n : \u2115}", "{\u03b9 : Type} {cs : \u03b9 \u2192 Cube (n + 1)} {i i' : \u03b9}", "(h : Correct cs)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cube : ?m.1284\nCorrect : ?m.1301\nn : \u2115\n\u03b9\u271d : Type\ncs : \u03b9\u271d \u2192 sorry\ni\u271d i' : \u03b9\u271d\nh : sorry\n\u03b9 : Type\ni : \u03b9\nj : ?m.2631\n\u22a2 sorry \u2286 Ico 0 1"}, {"line": "simpa only [side_unitCube] using toSet_subset.1 h.toSet_subset_unitCube j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem existsPolitician_of_degree_le_two (hd : G.IsRegularOfDegree d) (h : d \u2264 2) :\n    ExistsPolitician G := by\n  interval_cases d\n  iterate 2 apply existsPolitician_of_degree_le_one hG hd; norm_num\n  exact existsPolitician_of_degree_eq_two hG hd\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/FriendshipGraphs.lean", "context": {"open": ["Finset SimpleGraph Matrix", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{V : Type u} {R : Type v} [Semiring R]", "(G : SimpleGraph V)", "[Fintype V] {G : SimpleGraph V} {d : \u2115} (hG : Friendship G)", "(R)", "{R}", "[Nonempty V]", "[Nonempty V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : d \u2264 2\n\u22a2 sorry"}, {"line": "interval_cases d", "tactic_state": "case \u00ab0\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 0 \u2264 2\n\u22a2 sorry\n---\ncase \u00ab1\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 1 \u2264 2\n\u22a2 sorry\n---\ncase \u00ab2\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 2 \u2264 2\n\u22a2 sorry"}, {"line": "iterate 2 apply existsPolitician_of_degree_le_one hG hd; norm_num", "tactic_state": "case \u00ab2\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 2 \u2264 2\n\u22a2 sorry ()"}, {"line": "exact existsPolitician_of_degree_eq_two hG hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Theorems100.inverse_triangle_sum :\n    \u2200 n, \u2211 k \u2208 range n, (2 : \u211a) / (k * (k + 1)) = if n = 0 then 0 else 2 - (2 : \u211a) / n := by\n  refine sum_range_induction _ _ rfl ?_\n  rintro (_ | _)\n  \u00b7 norm_num\n  field_simp\n  ring", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/InverseTriangleSum.lean", "context": {"open": ["Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), \u2211 k \u2208 range n, 2 / (\u2191k * (\u2191k + 1)) = if n = 0 then 0 else 2 - 2 / \u2191n"}, {"line": "refine sum_range_induction _ _ rfl ?_", "tactic_state": "\u22a2 \u2200 (n : \u2115), (if n + 1 = 0 then 0 else 2 - 2 / \u2191(n + 1)) = (if n = 0 then 0 else 2 - 2 / \u2191n) + 2 / (\u2191n * (\u2191n + 1))"}, {"line": "rintro (_ | _)", "tactic_state": "case zero\n\u22a2 (if 0 + 1 = 0 then 0 else 2 - 2 / \u2191(0 + 1)) = (if 0 = 0 then 0 else 2 - 2 / \u21910) + 2 / (\u21910 * (\u21910 + 1))\n---\ncase succ\nn\u271d : \u2115\n\u22a2 (if n\u271d + 1 + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1 + 1)) =\n    (if n\u271d + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1)) + 2 / (\u2191(n\u271d + 1) * (\u2191(n\u271d + 1) + 1))"}, {"line": "\u00b7 norm_num", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (if n\u271d + 1 + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1 + 1)) =\n    (if n\u271d + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1)) + 2 / (\u2191(n\u271d + 1) * (\u2191(n\u271d + 1) + 1))"}, {"line": "field_simp", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (2 * (\u2191n\u271d + 1 + 1) - 2) * ((\u2191n\u271d + 1) * ((\u2191n\u271d + 1) * (\u2191n\u271d + 1 + 1))) =\n    ((2 * (\u2191n\u271d + 1) - 2) * ((\u2191n\u271d + 1) * (\u2191n\u271d + 1 + 1)) + 2 * (\u2191n\u271d + 1)) * (\u2191n\u271d + 1 + 1)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_two_pow_eq_mersenne_succ (k : \u2115) : \u03c3 1 (2 ^ k) = mersenne (k + 1) := by\n  simp_rw [sigma_one_apply, mersenne, show 2 = 1 + 1 from rfl, \u2190 geom_sum_mul_add 1 (k + 1)]\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 (sigma 1) (2 ^ k) = mersenne (k + 1)"}, {"line": "simp_rw [sigma_one_apply, mersenne, show 2 = 1 + 1 from rfl, \u2190 geom_sum_mul_add 1 (k + 1)]", "tactic_state": "k : \u2115\n\u22a2 \u2211 x \u2208 ((1 + 1) ^ k).divisors, x = (\u2211 i \u2208 range (k + 1), (1 + 1) ^ i) * 1 + 1 - 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_of_prime_mersenne (k : \u2115) (pr : (mersenne (k + 1)).Prime) : k \u2260 0 := by\n  intro H\n  simp [H, mersenne, Nat.not_prime_one] at pr\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\n\u22a2 k \u2260 0"}, {"line": "intro H", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\nH : k = 0\n\u22a2 False"}, {"line": "simp [H, mersenne, Nat.not_prime_one] at pr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem even_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).Prime) :\n    Even (2 ^ k * mersenne (k + 1)) := by simp [ne_zero_of_prime_mersenne k pr, parity_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\n\u22a2 Even (2 ^ k * mersenne (k + 1))"}, {"line": "simp [ne_zero_of_prime_mersenne k pr, parity_simps]", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\n\u22a2 \u00ack = 0 \u2228 Even (mersenne (k + 1))"}]}
{"declaration": "theorem eq_two_pow_mul_odd {n : \u2115} (hpos : 0 < n) : \u2203 k m : \u2115, n = 2 ^ k * m \u2227 \u00acEven m := by\n  have h := Nat.finiteMultiplicity_iff.2 \u27e8Nat.prime_two.ne_one, hpos\u27e9\n  obtain \u27e8m, hm\u27e9 := pow_multiplicity_dvd 2 n\n  use multiplicity 2 n, m\n  refine \u27e8hm, ?_\u27e9\n  rw [even_iff_two_dvd]\n  have hg := h.not_pow_dvd_of_multiplicity_lt (Nat.lt_succ_self _)\n  contrapose! hg\n  rcases hg with \u27e8k, rfl\u27e9\n  apply Dvd.intro k\n  rw [pow_succ]\n  rw [mul_assoc]\n  rw [\u2190 hm]\n", "file": "/root/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhpos : 0 < n\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "have h := Nat.finiteMultiplicity_iff.2 \u27e8Nat.prime_two.ne_one, hpos\u27e9", "tactic_state": "n : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "obtain \u27e8m, hm\u27e9 := pow_multiplicity_dvd 2 n", "tactic_state": "case intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "use multiplicity 2 n, m", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 n = 2 ^ multiplicity 2 n * m \u2227 \u00acEven m"}, {"line": "refine \u27e8hm, ?_\u27e9", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u00acEven m"}, {"line": "rw [even_iff_two_dvd]", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u00ac2 \u2223 m"}, {"line": "have hg := h.not_pow_dvd_of_multiplicity_lt (Nat.lt_succ_self _)", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\nhg : \u00ac2 ^ (multiplicity 2 n).succ \u2223 n\n\u22a2 \u00ac2 \u2223 m"}, {"line": "contrapose! hg", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\nhg : 2 \u2223 m\n\u22a2 2 ^ (multiplicity 2 n).succ \u2223 n"}, {"line": "rcases hg with \u27e8k, rfl\u27e9", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ (multiplicity 2 n).succ \u2223 n"}, {"line": "apply Dvd.intro k", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ (multiplicity 2 n).succ * k = n"}, {"line": "rw [pow_succ]", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ multiplicity 2 n * 2 * k = n"}, {"line": "rw [mul_assoc]", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ multiplicity 2 n * (2 * k) = n"}, {"line": "rw [\u2190 hm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_zmod_2 (a : ZMod 2) : a = 0 \u2228 a = 1 := by\n  rcases a with \u27e8_ | _, _ | _ | _ | _\u27e9\n  \u00b7 exact Or.inl rfl\n  \u00b7 exact Or.inr rfl\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/CanonicallyOrderedCommSemiringTwoMul.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ZMod 2\n\u22a2 a = 0 \u2228 a = 1"}, {"line": "rcases a with \u27e8_ | _, _ | _ | _ | _\u27e9", "tactic_state": "case mk.zero.step.refl\n\u22a2 \u27e80, \u22ef\u27e9 = 0 \u2228 \u27e80, \u22ef\u27e9 = 1\n---\ncase mk.succ.refl\n\u22a2 \u27e80 + 1, \u22ef\u27e9 = 0 \u2228 \u27e80 + 1, \u22ef\u27e9 = 1"}, {"line": "\u00b7 exact Or.inl rfl", "tactic_state": "case mk.succ.refl\n\u22a2 \u27e80 + 1, \u22ef\u27e9 = 0 \u2228 \u27e80 + 1, \u22ef\u27e9 = 1"}, {"line": "\u00b7 exact Or.inr rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_sq : star * star \u2248 star := by\n  have le : star * star \u2264 star := by\n    rw [le_iff_forall_lf]\n    constructor <;>\n    intro i\n    \u00b7 apply leftMoves_mul_cases i <;>\n      intro _ _\n      case' hl => rw [mul_moveLeft_inl]\n      case' hr => rw [mul_moveLeft_inr]\n      all_goals rw [lf_iff_game_lf]; simpa using zero_lf_star\n    \u00b7 refine lf_zero.2 \u27e8toRightMovesMul (Sum.inl default), ?_\u27e9\n      rintro (j | j) <;> -- Instance can't be inferred otherwise.\n      exact isEmptyElim j\n  constructor\n  case' right =>\n    rw [\u2190 neg_le_neg_iff];\n    apply (neg_mul _ _).symm.equiv.1.trans;\n    rw [neg_star]\n  assumption'\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/GameMultiplication.lean", "context": {"open": ["SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 PGame.star * PGame.star \u2248 PGame.star"}, {"line": "have le : star * star \u2264 star := sorry", "tactic_state": "le : PGame.star * PGame.star \u2264 PGame.star\n\u22a2 PGame.star * PGame.star \u2248 PGame.star"}, {"line": "constructor", "tactic_state": "case left\nle : PGame.star * PGame.star \u2264 PGame.star\n\u22a2 PGame.star * PGame.star \u2264 PGame.star\n---\ncase right\nle : PGame.star * PGame.star \u2264 PGame.star\n\u22a2 PGame.star \u2264 PGame.star * PGame.star"}, {"line": "case' right =>\n    rw [\u2190 neg_le_neg_iff];\n    apply (neg_mul _ _).symm.equiv.1.trans;\n    rw [neg_star]", "tactic_state": "case right\nle : PGame.star * PGame.star \u2264 PGame.star\n\u22a2 PGame.star * PGame.star \u2264 PGame.star\n---\ncase left\nle : PGame.star * PGame.star \u2264 PGame.star\n\u22a2 PGame.star * PGame.star \u2264 PGame.star"}, {"line": "assumption'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star'_mul_star_lf : star' * star \u29cf star := by\n  rw [lf_iff_exists_le]\n  refine Or.inr \u27e8toRightMovesMul (Sum.inr \u27e8\u27e81, Nat.one_lt_two\u27e9, default\u27e9), ?_\u27e9\n  rw [mul_moveRight_inr]\n  rw [le_iff_game_le]\n  simp [star']\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/GameMultiplication.lean", "context": {"open": ["SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "star' : PGame\n\u22a2 (star' * PGame.star).LF PGame.star"}, {"line": "rw [lf_iff_exists_le]", "tactic_state": "star' : PGame\n\u22a2 (\u2203 i, star' * PGame.star \u2264 PGame.star.moveLeft i) \u2228 \u2203 j, (star' * PGame.star).moveRight j \u2264 PGame.star"}, {"line": "refine Or.inr \u27e8toRightMovesMul (Sum.inr \u27e8\u27e81, Nat.one_lt_two\u27e9, default\u27e9), ?_\u27e9", "tactic_state": "star' : PGame\n\u22a2 (star' * PGame.star).moveRight (toRightMovesMul (Sum.inr (sorry, default))) \u2264 PGame.star"}, {"line": "rw [mul_moveRight_inr]", "tactic_state": "star' : PGame\n\u22a2 star'.moveRight sorry * PGame.star + star' * PGame.star.moveLeft default -\n      star'.moveRight sorry * PGame.star.moveLeft default \u2264\n    PGame.star"}, {"line": "rw [le_iff_game_le]", "tactic_state": "star' : PGame\n\u22a2 \u27e6star'.moveRight sorry * PGame.star + star' * PGame.star.moveLeft default -\n        star'.moveRight sorry * PGame.star.moveLeft default\u27e7 \u2264\n    \u27e6PGame.star\u27e7"}, {"line": "simp [star']", "tactic_state": "star' : PGame\n\u22a2 \u27e6star'.moveRight (sorry ()) * PGame.star\u27e7 \u2264 \u27e6PGame.star\u27e7"}]}
{"declaration": "theorem isClopen_Iio (a : \u211d\u2097) : IsClopen (Iio a) := by\n  simpa only [compl_Ici] using (isClopen_Ici a).compl\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\na : \u211d\u2097\n\u22a2 sorry"}, {"line": "simpa only [compl_Ici] using (isClopen_Ici a).compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_prod_antitone_basis_inv_pnat (x y : \u211d\u2097) :\n    (\ud835\udcdd (x, y)).HasAntitoneBasis fun n : \u2115+ => Ico x (x + (n : \u211d\u2097)\u207b\u00b9) \u00d7\u02e2 Ico y (y + (n : \u211d\u2097)\u207b\u00b9) := by\n  rw [nhds_prod_eq]\n  exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine", "Subtype in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\nx y : \u211d\u2097\n\u22a2 (nhds (x, y)).HasAntitoneBasis fun n => sorry \u00d7\u02e2 sorry"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "\u211d\u2097 : Type u_1\nx y : \u211d\u2097\n\u22a2 (nhds x \u00d7\u02e2 nhds y).HasAntitoneBasis fun n => sorry \u00d7\u02e2 sorry\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097"}, {"line": "exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)", "tactic_state": "\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097"}]}
{"declaration": "theorem not_metrizableSpace : \u00acMetrizableSpace \u211d\u2097 := by\n  intro\n  letI := metrizableSpaceMetric \u211d\u2097\n  exact not_normalSpace_prod inferInstance\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine", "Subtype in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\n\u22a2 \u00acsorry"}, {"line": "intro", "tactic_state": "\u211d\u2097 : Type u_1\na\u271d : sorry\n\u22a2 False"}, {"line": "letI := metrizableSpaceMetric \u211d\u2097", "tactic_state": "\u211d\u2097 : Type u_1\na\u271d : sorry\nthis : MetricSpace \u211d\u2097 := sorry\n\u22a2 False"}, {"line": "exact not_normalSpace_prod inferInstance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_divisors_of_periodic {R A} [Nontrivial R] [Ring R] [AddMonoid A] {n : \u2115} (a : A)\n    (n2 : 2 \u2264 n) (na : n \u2022 a = a) (na1 : (n - 1) \u2022 a \u2260 0) :\n    \u2203 f g : R[A], f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0 := by\n  refine \u27e8single a 1, single ((n - 1) \u2022 a) 1 - single 0 1, by simp, ?_, ?_\u27e9\n  \u00b7 exact sub_ne_zero.mpr (by simpa [single, AddMonoidAlgebra, single_eq_single_iff])\n  \u00b7 rw [mul_sub, AddMonoidAlgebra.single_mul_single, AddMonoidAlgebra.single_mul_single,\n      sub_eq_zero, add_zero, \u2190 succ_nsmul', Nat.sub_add_cancel (one_le_two.trans n2), na]\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 \u2203 f g, f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0"}, {"line": "refine \u27e8single a 1, single ((n - 1) \u2022 a) 1 - single 0 1, by simp, ?_, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat R 1\n---\ncase refine_2\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat A 0\n---\ncase refine_3\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat R 1\n---\ncase refine_4\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 single sorry 1 - single 0 1 \u2260 0\n---\ncase refine_5\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 sorry * (single sorry 1 - single 0 1) = 0"}, {"line": "\u00b7 exact sub_ne_zero.mpr (by simpa [single, AddMonoidAlgebra, single_eq_single_iff])", "tactic_state": "case refine_2\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat A 0\n---\ncase refine_3\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat R 1\n---\ncase refine_4\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 single sorry 1 - single 0 1 \u2260 0\n---\ncase refine_5\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 sorry * (single sorry 1 - single 0 1) = 0"}, {"line": "\u00b7 rw [mul_sub, AddMonoidAlgebra.single_mul_single, AddMonoidAlgebra.single_mul_single,\n      sub_eq_zero, add_zero, \u2190 succ_nsmul', Nat.sub_add_cancel (one_le_two.trans n2), na]", "tactic_state": "case refine_3\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 OfNat R 1\n---\ncase refine_4\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 single sorry 1 - single 0 1 \u2260 0\n---\ncase refine_5\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 : Ring R\ninst\u271d : AddMonoid A\nn : \u2115\na : A\nn2 : 2 \u2264 n\nna : n \u2022 a = a\nna1 : (n - 1) \u2022 a \u2260 0\n\u22a2 sorry * (single sorry 1 - single 0 1) = 0"}]}
{"declaration": "example : AddRightMono F := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : LinearOrder F := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 LinearOrder F"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : AddMonoid F := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 AddMonoid F"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00acUniqueProds \u2115 := by\n  rintro \u27e8h\u27e9\n  refine not_not.mpr (h (Finset.singleton_nonempty 0) (Finset.insert_nonempty 0 {1})) ?_\n  simp [UniqueMul, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acUniqueProds \u2115"}, {"line": "rintro \u27e8h\u27e9", "tactic_state": "case mk\nh : \u2200 {A B : Finset \u2115}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0\n\u22a2 False"}, {"line": "refine not_not.mpr (h (Finset.singleton_nonempty 0) (Finset.insert_nonempty 0 {1})) ?_", "tactic_state": "case mk\nh : \u2200 {A B : Finset \u2115}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueMul A B a0 b0\n\u22a2 \u00ac\u2203 a0 \u2208 {0}, \u2203 b0 \u2208 {0, 1}, UniqueMul {0} {0, 1} a0 b0"}, {"line": "simp [UniqueMul, not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) (n2 : 2 \u2264 n) : \u00acUniqueSums (ZMod n) := by\n  haveI : Fintype (ZMod n) := @ZMod.fintype n \u27e8(zero_lt_two.trans_le n2).ne'\u27e9\n  haveI : Nontrivial (ZMod n) := CharP.nontrivial_of_char_ne_one (one_lt_two.trans_le n2).ne'\n  rintro \u27e8h\u27e9\n  refine not_not.mpr (h Finset.univ_nonempty Finset.univ_nonempty) ?_\n  suffices \u2200 x y : ZMod n, \u2203 x' y' : ZMod n, x' + y' = x + y \u2227 (x' = x \u2192 \u00acy' = y) by\n    simpa [UniqueAdd]\n  exact fun x y => \u27e8x - 1, y + 1, sub_add_add_cancel _ _ _, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nn2 : 2 \u2264 n\n\u22a2 \u00acUniqueSums (ZMod n)"}, {"line": "haveI : Fintype (ZMod n) := @ZMod.fintype n \u27e8(zero_lt_two.trans_le n2).ne'\u27e9", "tactic_state": "n : \u2115\nn2 : 2 \u2264 n\nthis : Fintype (ZMod n)\n\u22a2 \u00acUniqueSums (ZMod n)"}, {"line": "haveI : Nontrivial (ZMod n) := CharP.nontrivial_of_char_ne_one (one_lt_two.trans_le n2).ne'", "tactic_state": "n : \u2115\nn2 : 2 \u2264 n\nthis\u271d : Fintype (ZMod n)\nthis : Nontrivial (ZMod n)\n\u22a2 \u00acUniqueSums (ZMod n)"}, {"line": "rintro \u27e8h\u27e9", "tactic_state": "case mk\nn : \u2115\nn2 : 2 \u2264 n\nthis\u271d : Fintype (ZMod n)\nthis : Nontrivial (ZMod n)\nh : \u2200 {A B : Finset (ZMod n)}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueAdd A B a0 b0\n\u22a2 False"}, {"line": "refine not_not.mpr (h Finset.univ_nonempty Finset.univ_nonempty) ?_", "tactic_state": "case mk\nn : \u2115\nn2 : 2 \u2264 n\nthis\u271d : Fintype (ZMod n)\nthis : Nontrivial (ZMod n)\nh : \u2200 {A B : Finset (ZMod n)}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueAdd A B a0 b0\n\u22a2 \u00ac\u2203 a0 \u2208 Finset.univ, \u2203 b0 \u2208 Finset.univ, UniqueAdd Finset.univ Finset.univ a0 b0"}, {"line": "suffices \u2200 x y : ZMod n, \u2203 x' y' : ZMod n, x' + y' = x + y \u2227 (x' = x \u2192 \u00acy' = y) by\n    simpa [UniqueAdd]", "tactic_state": "case mk\nn : \u2115\nn2 : 2 \u2264 n\nthis\u271d : Fintype (ZMod n)\nthis : Nontrivial (ZMod n)\nh : \u2200 {A B : Finset (ZMod n)}, A.Nonempty \u2192 B.Nonempty \u2192 \u2203 a0 \u2208 A, \u2203 b0 \u2208 B, UniqueAdd A B a0 b0\n\u22a2 \u2200 (x y : ZMod n), \u2203 x' y', x' + y' = x + y \u2227 (x' = x \u2192 \u00acy' = y)"}, {"line": "exact fun x y => \u27e8x - 1, y + 1, sub_add_add_cancel _ _ _, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma level_eq (n : \u2115) : level n = {x | (ofHollom x).2.2 = n} := by\n  simp [Set.ext_iff, level, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nlevel : x\u271d\u00b9\nx\u271d : Sort u_2\nofHollom : x\u271d\nn : \u2115\n\u22a2 sorry = {x | sorry = n}"}, {"line": "simp [Set.ext_iff, level, eq_comm]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nlevel : x\u271d\u00b9\nx\u271d : Sort u_2\nofHollom : x\u271d\nn : \u2115\n\u22a2 \u2200 (x : ?m.882 n), n = sorry () \u2194 x \u2208 sorry ()"}]}
{"declaration": "lemma level_eq_range (n : \u2115) : level n = Set.range (embed n) := by\n  simp [level, Set.range, embed]\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nlevel : x\u271d\u00b9\nx\u271d : Sort u_2\nembed : x\u271d\nn : \u2115\n\u22a2 sorry = Set.range sorry"}, {"line": "simp [level, Set.range, embed]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nlevel : x\u271d\u00b9\nx\u271d : Sort u_2\nembed : x\u271d\nn : \u2115\n\u22a2 sorry () = {x | \u2203 y, sorry () y = x}"}]}
{"declaration": "private lemma no_strictly_decreasing {\u03b1 : Type*} [Preorder \u03b1] [WellFoundedLT \u03b1] (f : \u2115 \u2192 \u03b1) {n\u2080 : \u2115}\n    (hf : \u2200 n \u2265 n\u2080, f (n + 1) < f n) : False := by\n  let g (n : \u2115) : \u03b1 := f (n\u2080 + n)\n  have : (\u00b7 > \u00b7) \u21aar (\u00b7 < \u00b7) := RelEmbedding.natGT g (fun n \u21a6 hf _ (by simp))\n  exact this.not_wellFounded_of_decreasing_seq wellFounded_lt\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\n\u22a2 False"}, {"line": "let g (n : \u2115) : \u03b1 := f (n\u2080 + n)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\ng : \u2115 \u2192 \u03b1 := fun n => f (n\u2080 + n)\n\u22a2 False"}, {"line": "have : (\u00b7 > \u00b7) \u21aar (\u00b7 < \u00b7) := RelEmbedding.natGT g (fun n \u21a6 hf _ (by simp))", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\ng : \u2115 \u2192 \u03b1 := fun n => f (n\u2080 + n)\nthis : (fun x1 x2 => x1 > x2) \u21aar fun x1 x2 => x1 < x2\n\u22a2 False"}, {"line": "exact this.not_wellFounded_of_decreasing_seq wellFounded_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem no_infinite_antichain {A : Set Hollom} (hC : IsAntichain (\u00b7 \u2264 \u00b7) A) : A.Finite := by\n  let f (x : Hollom) : \u2115 := (ofHollom x).2.2\n  have (n : \u2115) : A \u2229 f \u207b\u00b9' {n} \u2286 level n := fun x \u21a6 by induction x with | h x => simp [f]\n  -- We show that the antichain can only occupy finitely much of each level\n  -- and it can only exist in finitely many levels.\n  apply Set.Finite.of_finite_fibers f\n  case hfibers =>\n    intro x hx\n    exact no_infinite_antichain_level (this _) (hC.subset Set.inter_subset_left)\n  case himage =>\n    rw [\u2190 Set.not_infinite]\n    intro h\n    obtain \u27e8n, hn\u27e9 := h.nonempty\n    suffices f '' A \u2286 Set.Iio (n + 2) from h ((Set.finite_Iio _).subset this)\n    intro m\n    simp only [Set.mem_image]\n    simp only [\u00abexists\u00bb]\n    simp only [ofHollom_toHollom]\n    simp only [Prod.exists]\n    simp only [exists_eq_right]\n    simp only [Set.mem_Iio]\n    simp only [forall_exists_index]\n    simp only [f]\n    simp only [Set.mem_image] at hn\n    simp only [\u00abexists\u00bb] at hn\n    simp only [ofHollom_toHollom] at hn\n    simp only [Prod.exists] at hn\n    simp only [exists_eq_right] at hn\n    simp only [f] at hn\n    obtain \u27e8a, b, hab\u27e9 := hn\n    intro c d hcd\n    by_contra!\n    exact hC hcd hab (by simp; omega) (HollomOrder.twice this)\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Hollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\n\u22a2 A.Finite"}, {"line": "let f (x : Hollom) : \u2115 := (ofHollom x).2.2", "tactic_state": "Hollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\nf : Hollom \u2192 \u2115 := fun x => sorry\n\u22a2 A.Finite"}, {"line": "have (n : \u2115) : A \u2229 f \u207b\u00b9' {n} \u2286 level n := fun x \u21a6 by induction x with | h x => simp [f]", "tactic_state": "Hollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\nf : Hollom \u2192 \u2115 := fun x => sorry\nthis : \u2200 (n : \u2115), A \u2229 f \u207b\u00b9' {n} \u2286 sorry\n\u22a2 A.Finite"}, {"line": "apply Set.Finite.of_finite_fibers f", "tactic_state": "case himage\nHollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\nf : Hollom \u2192 \u2115 := fun x => sorry\nthis : \u2200 (n : \u2115), A \u2229 f \u207b\u00b9' {n} \u2286 sorry\n\u22a2 (f '' A).Finite\n---\ncase hfibers\nHollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\nf : Hollom \u2192 \u2115 := fun x => sorry\nthis : \u2200 (n : \u2115), A \u2229 f \u207b\u00b9' {n} \u2286 sorry\n\u22a2 \u2200 x \u2208 f '' A, (A \u2229 f \u207b\u00b9' {x}).Finite"}, {"line": "case hfibers =>\n    intro x hx\n    exact no_infinite_antichain_level (this _) (hC.subset Set.inter_subset_left)", "tactic_state": "case himage\nHollom : Type u_1\nA : Set Hollom\nhC : IsAntichain (fun x1 x2 => x1 \u2264 x2) A\nf : Hollom \u2192 \u2115 := fun x => sorry\nthis : \u2200 (n : \u2115), A \u2229 f \u207b\u00b9' {n} \u2286 sorry\n\u22a2 (f '' A).Finite"}, {"line": "case himage =>\n    rw [\u2190 Set.not_infinite]\n    intro h\n    obtain \u27e8n, hn\u27e9 := h.nonempty\n    suffices f '' A \u2286 Set.Iio (n + 2) from h ((Set.finite_Iio _).subset this)\n    intro m\n    simp only [Set.mem_image]\n    simp only [\u00abexists\u00bb]\n    simp only [ofHollom_toHollom]\n    simp only [Prod.exists]\n    simp only [exists_eq_right]\n    simp only [Set.mem_Iio]\n    simp only [forall_exists_index]\n    simp only [f]\n    simp only [Set.mem_image] at hn\n    simp only [\u00abexists\u00bb] at hn\n    simp only [ofHollom_toHollom] at hn\n    simp only [Prod.exists] at hn\n    simp only [exists_eq_right] at hn\n    simp only [f] at hn\n    obtain \u27e8a, b, hab\u27e9 := hn\n    intro c d hcd\n    by_contra!\n    exact hC hcd hab (by simp; omega) (HollomOrder.twice this)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem no_spinalMap (hC : IsChain (\u00b7 \u2264 \u00b7) C) (f : SpinalMap C) : False := by\n  obtain \u27e8n, hn, hn'\u27e9 : \u2203 n, n \u2260 0 \u2227 (C \u2229 Hollom.level n).Finite := by\n    obtain \u27e8n, hn, hn'\u27e9 := Filter.frequently_atTop.1 (Hollom.exists_finite_intersection hC) 1\n    exact \u27e8n, by omega, hn'\u27e9\n  exact Hollom.not_S_mapsTo_previous hC hn' hn (Hollom.S_mapsTo_previous f hC hn)\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom", "Filter", "Finset", "Finset in", "Finset in", "Classical Finset in", "Classical Finset in", "Finset in", "Classical in", "Classical in", "Finset in"], "variables": ["{C : Set Hollom}", "{\u03b1 : Type*} [PartialOrder \u03b1] {C : Set \u03b1}", "(f : SpinalMap C)", "{x y z : \u03b1}", "{f : SpinalMap C}", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SpinalMap : ?m.2232\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\u271d\nC\u271d : Set \u03b1\u271d\nf\u271d\u00b9 : sorry\nx y z : \u03b1\u271d\nf\u271d : sorry\nn : \u2115\n\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nC : Set \u03b1\nhC : IsChain (fun x1 x2 => x1 \u2264 x2) C\nf : sorry\n\u22a2 False"}, {"line": "obtain \u27e8n, hn, hn'\u27e9 : \u2203 n, n \u2260 0 \u2227 (C \u2229 Hollom.level n).Finite := by\n    obtain \u27e8n, hn, hn'\u27e9 := Filter.frequently_atTop.1 (Hollom.exists_finite_intersection hC) 1\n    exact \u27e8n, by omega, hn'\u27e9", "tactic_state": "case intro.intro\nSpinalMap : ?m.2232\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : PartialOrder \u03b1\u271d\nC\u271d : Set \u03b1\u271d\nf\u271d\u00b9 : sorry\nx y z : \u03b1\u271d\nf\u271d : sorry\nn\u271d : \u2115\n\u03b1 : Type u_1\ninst\u271d : PartialOrder \u03b1\nC : Set \u03b1\nhC : IsChain (fun x1 x2 => x1 \u2264 x2) C\nf : sorry\nn : \u2115\nhn : n \u2260 0\nhn' : (C \u2229 sorry).Finite\n\u22a2 False"}, {"line": "exact Hollom.not_S_mapsTo_previous hC hn' hn (Hollom.S_mapsTo_previous f hC hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Q'_apply (a : Fin 3 \u2192 K) : Q' a = a 0 * a 0 + a 1 * a 1 + a 2 * a 2 :=\n  calc\n    Q' a = a 0 * a 0 + (a 1 * a 1 + (a 2 * a 2 + 0)) := rfl\n    _ = _ := by ring\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/CliffordAlgebraNotInjective.lean", "context": {"open": ["LinearMap (BilinForm)", "LinearMap (BilinMap)", "MvPolynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nx\u271d : Sort u_2\nQ' : x\u271d\na : Fin 3 \u2192 K\n\u22a2 Function.const Lean.Name () `7.4.7.52.4.52._sorry._@._hyg.82 =\n    Function.const Lean.Name () `5.35.5.75.35.75._sorry._@._hyg.48"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UnitsInt.one_ne_neg_one : (1 : \u2124\u02e3) \u2260 -1 := by decide\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/DirectSumIsInternal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 \u2260 -1"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "example : CompleteSpace (DiscreteCopy \u211d \u2192\u1d47 \u211d) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Counterexamples/Phillips.lean", "context": {"open": ["Set BoundedContinuousFunction MeasureTheory", "Cardinal (aleph)", "scoped Cardinal BoundedContinuousFunction", "BoundedAdditiveMeasure"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nDiscreteCopy : x\u271d\n\u22a2 CompleteSpace (BoundedContinuousFunction sorry \u211d)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_of_charZero (R A : Type*) [CommRing R] [Ring A] [Algebra R A]\n    [CharZero A] : { x : A | IsAlgebraic R x }.Infinite := by\n  letI := MulActionWithZero.nontrivial R A\n  exact infinite_of_injective_forall_mem Nat.cast_injective isAlgebraic_nat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AlgebraicCard.lean", "context": {"open": ["Cardinal Polynomial Set", "Cardinal Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : CharZero A\n\u22a2 {x | IsAlgebraic R x}.Infinite"}, {"line": "letI := MulActionWithZero.nontrivial R A", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : Ring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : CharZero A\nthis : Nontrivial R := sorry\n\u22a2 {x | IsAlgebraic R x}.Infinite"}, {"line": "exact infinite_of_injective_forall_mem Nat.cast_injective isAlgebraic_nat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimePow_nat_iff (n : \u2115) : IsPrimePow n \u2194 \u2203 p k : \u2115, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n := by\n  simp only [isPrimePow_def]\n  simp only [Nat.prime_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/IsPrimePow.lean", "context": {"open": [], "variables": ["{R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsPrimePow n \u2194 \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "simp only [isPrimePow_def]", "tactic_state": "n : \u2115\n\u22a2 (\u2203 p k, Prime p \u2227 0 < k \u2227 p ^ k = n) \u2194 \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "simp only [Nat.prime_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimePow_nat_iff_bounded (n : \u2115) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p \u2264 n \u2227 \u2203 k : \u2115, k \u2264 n \u2227 p.Prime \u2227 0 < k \u2227 p ^ k = n := by\n  rw [isPrimePow_nat_iff]\n  refine Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, ?_\u27e9\n  rintro \u27e8p, k, hp, hk, rfl\u27e9\n  refine \u27e8p, ?_, k, (Nat.lt_pow_self hp.one_lt).le, hp, hk, rfl\u27e9\n  conv => { lhs; rw [\u2190 (pow_one p)] }\n  exact Nat.pow_le_pow_right hp.one_lt.le hk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/IsPrimePow.lean", "context": {"open": [], "variables": ["{R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsPrimePow n \u2194 \u2203 p \u2264 n, \u2203 k \u2264 n, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "rw [isPrimePow_nat_iff]", "tactic_state": "n : \u2115\n\u22a2 (\u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n) \u2194 \u2203 p \u2264 n, \u2203 k \u2264 n, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "refine Iff.symm \u27e8fun \u27e8p, _, k, _, hp, hk, hn\u27e9 => \u27e8p, k, hp, hk, hn\u27e9, ?_\u27e9", "tactic_state": "n : \u2115\n\u22a2 (\u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n) \u2192 \u2203 p \u2264 n, \u2203 k \u2264 n, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "rintro \u27e8p, k, hp, hk, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 \u2203 p_1 \u2264 p ^ k, \u2203 k_1 \u2264 p ^ k, Nat.Prime p_1 \u2227 0 < k_1 \u2227 p_1 ^ k_1 = p ^ k"}, {"line": "refine \u27e8p, ?_, k, (Nat.lt_pow_self hp.one_lt).le, hp, hk, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 p \u2264 p ^ k"}, {"line": "conv => { lhs; rw [\u2190 (pow_one p)] }", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 p ^ 1 \u2264 p ^ k"}, {"line": "exact Nat.pow_le_pow_right hp.one_lt.le hk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPrimePow.dvd {n m : \u2115} (hn : IsPrimePow n) (hm : m \u2223 n) (hm\u2081 : m \u2260 1) : IsPrimePow m := by\n  rw [isPrimePow_nat_iff] at hn \u22a2\n  rcases hn with \u27e8p, k, hp, _hk, rfl\u27e9\n  obtain \u27e8i, hik, rfl\u27e9 := (Nat.dvd_prime_pow hp).1 hm\n  refine \u27e8p, i, hp, ?_, rfl\u27e9\n  apply Nat.pos_of_ne_zero\n  rintro rfl\n  simp only [pow_zero] at hm\u2081\n  simp only [ne_eq] at hm\u2081\n  simp only [not_true_eq_false] at hm\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/IsPrimePow.lean", "context": {"open": [], "variables": ["{R : Type*} [CommMonoidWithZero R] (n p : R) (k : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nhn : IsPrimePow n\nhm : m \u2223 n\nhm\u2081 : m \u2260 1\n\u22a2 IsPrimePow m"}, {"line": "rw [isPrimePow_nat_iff] at hn \u22a2", "tactic_state": "n m : \u2115\nhn : \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n\nhm : m \u2223 n\nhm\u2081 : m \u2260 1\n\u22a2 \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = m"}, {"line": "rcases hn with \u27e8p, k, hp, _hk, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nm : \u2115\nhm\u2081 : m \u2260 1\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\nhm : m \u2223 p ^ k\n\u22a2 \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = m"}, {"line": "obtain \u27e8i, hik, rfl\u27e9 := (Nat.dvd_prime_pow hp).1 hm", "tactic_state": "case intro.intro.intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\ni : \u2115\nhik : i \u2264 k\nhm\u2081 : p ^ i \u2260 1\nhm : p ^ i \u2223 p ^ k\n\u22a2 \u2203 p_1 k, Nat.Prime p_1 \u2227 0 < k \u2227 p_1 ^ k = p ^ i"}, {"line": "refine \u27e8p, i, hp, ?_, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\ni : \u2115\nhik : i \u2264 k\nhm\u2081 : p ^ i \u2260 1\nhm : p ^ i \u2223 p ^ k\n\u22a2 0 < i"}, {"line": "apply Nat.pos_of_ne_zero", "tactic_state": "case intro.intro.intro.intro.intro.intro.a\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\ni : \u2115\nhik : i \u2264 k\nhm\u2081 : p ^ i \u2260 1\nhm : p ^ i \u2223 p ^ k\n\u22a2 i \u2260 0"}, {"line": "rintro rfl", "tactic_state": "case intro.intro.intro.intro.intro.intro.a\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\nhik : 0 \u2264 k\nhm\u2081 : p ^ 0 \u2260 1\nhm : p ^ 0 \u2223 p ^ k\n\u22a2 False"}, {"line": "simp only [pow_zero] at hm\u2081", "tactic_state": "case intro.intro.intro.intro.intro.intro.a\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\nhik : 0 \u2264 k\nhm : p ^ 0 \u2223 p ^ k\nhm\u2081 : 1 \u2260 1\n\u22a2 False"}, {"line": "simp only [ne_eq] at hm\u2081", "tactic_state": "case intro.intro.intro.intro.intro.intro.a\np k : \u2115\nhp : Nat.Prime p\n_hk : 0 < k\nhik : 0 \u2264 k\nhm : p ^ 0 \u2223 p ^ k\nhm\u2081 : \u00acTrue\n\u22a2 False"}, {"line": "simp only [not_true_eq_false] at hm\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modEq_zero : a \u2261 b [PMOD 0] \u2194 a = b := by simp [ModEq, sub_eq_zero, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a \u2261 b [PMOD 0] \u2194 a = b"}, {"line": "simp [ModEq, sub_eq_zero, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_modEq_zero : a - b \u2261 0 [PMOD p] \u2194 a \u2261 b [PMOD p] := by simp [sub_modEq_iff_modEq_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\np a b : \u03b1\n\u22a2 a - b \u2261 0 [PMOD p] \u2194 a \u2261 b [PMOD p]"}, {"line": "simp [sub_modEq_iff_modEq_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_modEq_left : a + b \u2261 a [PMOD p] \u2194 b \u2261 0 [PMOD p] := by simp [\u2190 modEq_sub_iff_add_modEq']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\np a b : \u03b1\n\u22a2 a + b \u2261 a [PMOD p] \u2194 b \u2261 0 [PMOD p]"}, {"line": "simp [\u2190 modEq_sub_iff_add_modEq']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_modEq_right : a + b \u2261 b [PMOD p] \u2194 a \u2261 0 [PMOD p] := by simp [\u2190 modEq_sub_iff_add_modEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : AddCommGroup \u03b1\np a b : \u03b1\n\u22a2 a + b \u2261 b [PMOD p] \u2194 a \u2261 0 [PMOD p]"}, {"line": "simp [\u2190 modEq_sub_iff_add_modEq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modEq_iff_int_modEq {a b z : \u2124} : a \u2261 b [PMOD z] \u2194 a \u2261 b [ZMOD z] := by\n  simp [ModEq, dvd_iff_exists_eq_mul_left, Int.modEq_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b z : \u2124\n\u22a2 a \u2261 b [PMOD z] \u2194 a \u2261 b [ZMOD z]"}, {"line": "simp [ModEq, dvd_iff_exists_eq_mul_left, Int.modEq_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_modEq_intCast' {a b : \u2124} {n : \u2115} : a \u2261 b [PMOD (n : \u03b1)] \u2194 a \u2261 b [PMOD (n : \u2124)] := by\n  simpa using intCast_modEq_intCast (\u03b1 := \u03b1) (z := n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ModEq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddCommGroup \u03b1] {p a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u03b1} {n : \u2115} {z : \u2124}", "[AddCommGroupWithOne \u03b1] [CharZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : AddCommGroupWithOne \u03b1\ninst\u271d : CharZero \u03b1\na b : \u2124\nn : \u2115\n\u22a2 \u2191a \u2261 \u2191b [PMOD \u2191n] \u2194 a \u2261 b [PMOD \u2191n]"}, {"line": "simpa using intCast_modEq_intCast (\u03b1 := \u03b1) (z := n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_unique (f : R \u2192+* T) {r : R \u2192 R \u2192 Prop} (w : \u2200 \u2983x y\u2984, r x y \u2192 f x = f y)\n    (g : RingQuot r \u2192+* T) (h : g.comp (mkRingHom r) = f) : g = lift \u27e8f, w\u27e9 := by\n  ext\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/RingQuot.lean", "context": {"open": [], "variables": ["{R : Type uR} [Semiring R]", "{S : Type uS} [CommSemiring S]", "{T : Type uT}", "{A : Type uA} [Semiring A] [Algebra S A]", "(r : R \u2192 R \u2192 Prop)", "[Semiring T]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type uR\ninst\u271d\u00b9 : Semiring R\nT : Type uT\ninst\u271d : Semiring T\nx\u271d\u00b9 : Sort u_1\nmkRingHom : x\u271d\u00b9\nx\u271d : Sort u_2\nlift : x\u271d\nf : R \u2192+* T\nr : R \u2192 R \u2192 Prop\nw : \u2200 \u2983x y : R\u2984, r x y \u2192 f x = f y\ng : RingQuot r \u2192+* T\nh : g.comp sorry = f\n\u22a2 g = sorry"}, {"line": "ext", "tactic_state": "case a\nR : Type uR\ninst\u271d\u00b9 : Semiring R\nT : Type uT\ninst\u271d : Semiring T\nx\u271d\u00b2 : Sort u_1\nmkRingHom : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nlift : x\u271d\u00b9\nf : R \u2192+* T\nr : R \u2192 R \u2192 Prop\nw : \u2200 \u2983x y : R\u2984, r x y \u2192 f x = f y\ng : RingQuot r \u2192+* T\nh : g.comp sorry = f\nx\u271d : RingQuot r\n\u22a2 g x\u271d = sorry x\u271d"}, {"line": "simp [h]", "tactic_state": "case a\nR : Type uR\ninst\u271d\u00b9 : Semiring R\nT : Type uT\ninst\u271d : Semiring T\nx\u271d\u00b2 : Sort u_1\nmkRingHom : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nlift : x\u271d\u00b9\nf : R \u2192+* T\nr : R \u2192 R \u2192 Prop\nw : \u2200 \u2983x y : R\u2984, r x y \u2192 f x = f y\ng : RingQuot r \u2192+* T\nh : g.comp sorry = f\nx\u271d : RingQuot r\n\u22a2 g x\u271d = (sorry ()) x\u271d"}]}
{"declaration": "theorem commute_eps_left [Semiring R] (x : DualNumber R) : Commute \u03b5 x := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DualNumber.lean", "context": {"open": ["DualNumber", "TrivSqZeroExt"], "variables": ["{R A B : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : DualNumber R\n\u22a2 Commute eps x"}, {"line": "ext <;> simp", "tactic_state": "case h2\nR : Type u_1\ninst\u271d : Semiring R\nx : DualNumber R\n\u22a2 0 + 1 * fst x = fst x * 1"}]}
{"declaration": "lemma exact_zero_iff_injective {M N : Type*} (P : Type*)\n    [AddCommGroup M] [AddCommGroup N] [AddCommMonoid P] [Module R N] [Module R M]\n    [Module R P] (f : M \u2192\u2097[R] N) :\n    Function.Exact (0 : P \u2192\u2097[R] M) f \u2194 Function.Injective f := by\n  simp [\u2190 ker_eq_bot, exact_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Exact.lean", "context": {"open": ["Function", "AddMonoidHom", "Function"], "variables": ["{R M M' N N' P P' : Type*}", "(f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')", "{f g}", "[AddGroup M] [AddGroup N] [AddGroup P] {f : M \u2192+ N} {g : N \u2192+ P}", "{X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : Type*} [AddCommMonoid X\u2081] [AddCommMonoid X\u2082] [AddCommMonoid X\u2083]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid N]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "{R M N P : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2076 : Ring R\nM : Type u_18\nN : Type u_19\nP : Type u_20\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nf : M \u2192\u2097[R] N\n\u22a2 Exact \u21d10 \u21d1f \u2194 Injective \u21d1f"}, {"line": "simp [\u2190 ker_eq_bot, exact_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exact_zero_iff_surjective {M N : Type*} (P : Type*)\n    [AddCommGroup M] [AddCommGroup N] [AddCommMonoid P] [Module R N] [Module R M]\n    [Module R P] (f : M \u2192\u2097[R] N) :\n    Function.Exact f (0 : N \u2192\u2097[R] P) \u2194 Function.Surjective f := by\n  simp [\u2190 range_eq_top, exact_iff, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Exact.lean", "context": {"open": ["Function", "AddMonoidHom", "Function"], "variables": ["{R M M' N N' P P' : Type*}", "(f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')", "{f g}", "[AddGroup M] [AddGroup N] [AddGroup P] {f : M \u2192+ N} {g : N \u2192+ P}", "{X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : Type*} [AddCommMonoid X\u2081] [AddCommMonoid X\u2082] [AddCommMonoid X\u2083]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid N]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "{R M N P : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\ninst\u271d\u2076 : Ring R\nM : Type u_18\nN : Type u_19\nP : Type u_20\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R P\nf : M \u2192\u2097[R] N\n\u22a2 Exact \u21d1f \u21d10 \u2194 Surjective \u21d1f"}, {"line": "simp [\u2190 range_eq_top, exact_iff, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Exact.split_tfae\n    {R M N P} [Semiring R] [AddCommGroup M] [AddCommGroup N]\n    [AddCommGroup P] [Module R M] [Module R N] [Module R P] {f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}\n    (h : Function.Exact f g) (hf : Function.Injective f) (hg : Function.Surjective g) :\n    List.TFAE [\n      \u2203 l, g \u2218\u2097 l = LinearMap.id,\n      \u2203 l, l \u2218\u2097 f = LinearMap.id,\n      \u2203 e : N \u2243\u2097[R] M \u00d7 P, f = e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 e] := by\n  tfae_have 1 \u2194 3 := by\n    simpa using (h.splitSurjectiveEquiv hf).nonempty_congr\n  tfae_have 2 \u2194 3 := by\n    simpa using (h.splitInjectiveEquiv hg).nonempty_congr\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Exact.lean", "context": {"open": ["Function", "AddMonoidHom", "Function", "LinearMap", "LinearMap"], "variables": ["{R M M' N N' P P' : Type*}", "(f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')", "{f g}", "[AddGroup M] [AddGroup N] [AddGroup P] {f : M \u2192+ N} {g : N \u2192+ P}", "{X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : Type*} [AddCommMonoid X\u2081] [AddCommMonoid X\u2082] [AddCommMonoid X\u2083]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid N]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "{R M N P : Type*} [Ring R]", "(f g) in", "", "[Semiring R]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module R N] [Module R P]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_18\nM : Type u_19\nN : Type u_20\nP : Type u_21\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommGroup P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nf : M \u2192\u2097[R] N\ng : N \u2192\u2097[R] P\nh : Exact \u21d1f \u21d1g\nhf : Injective \u21d1f\nhg : Surjective \u21d1g\n\u22a2 [\u2203 l, g \u2218\u2097 l = LinearMap.id, \u2203 l, l \u2218\u2097 f = LinearMap.id,\n      \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e].TFAE"}, {"line": "tfae_have 1 \u2194 3 := by\n    simpa using (h.splitSurjectiveEquiv hf).nonempty_congr", "tactic_state": "R : Type u_18\nM : Type u_19\nN : Type u_20\nP : Type u_21\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommGroup P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nf : M \u2192\u2097[R] N\ng : N \u2192\u2097[R] P\nh : Exact \u21d1f \u21d1g\nhf : Injective \u21d1f\nhg : Surjective \u21d1g\ntfae_1_iff_3 : (\u2203 l, g \u2218\u2097 l = LinearMap.id) \u2194 \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e\n\u22a2 [\u2203 l, g \u2218\u2097 l = LinearMap.id, \u2203 l, l \u2218\u2097 f = LinearMap.id,\n      \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e].TFAE"}, {"line": "tfae_have 2 \u2194 3 := by\n    simpa using (h.splitInjectiveEquiv hg).nonempty_congr", "tactic_state": "R : Type u_18\nM : Type u_19\nN : Type u_20\nP : Type u_21\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : AddCommGroup P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nf : M \u2192\u2097[R] N\ng : N \u2192\u2097[R] P\nh : Exact \u21d1f \u21d1g\nhf : Injective \u21d1f\nhg : Surjective \u21d1g\ntfae_1_iff_3 : (\u2203 l, g \u2218\u2097 l = LinearMap.id) \u2194 \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e\ntfae_2_iff_3 : (\u2203 l, l \u2218\u2097 f = LinearMap.id) \u2194 \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e\n\u22a2 [\u2203 l, g \u2218\u2097 l = LinearMap.id, \u2203 l, l \u2218\u2097 f = LinearMap.id,\n      \u2203 e, f = \u2191e.symm \u2218\u2097 LinearMap.inl R M P \u2227 g = LinearMap.snd R M P \u2218\u2097 \u2191e].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Exact.inr_fst : Function.Exact (LinearMap.inr R M N) (LinearMap.fst R M N) := by\n  rintro \u27e8x, y\u27e9\n  simp only [LinearMap.fst_apply]\n  simp only [@eq_comm _ x]\n  simp only [LinearMap.coe_inr]\n  simp only [Set.mem_range]\n  simp only [Prod.mk.injEq]\n  simp only [exists_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Exact.lean", "context": {"open": ["Function", "AddMonoidHom", "Function", "LinearMap", "LinearMap"], "variables": ["{R M M' N N' P P' : Type*}", "(f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')", "{f g}", "[AddGroup M] [AddGroup N] [AddGroup P] {f : M \u2192+ N} {g : N \u2192+ P}", "{X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : Type*} [AddCommMonoid X\u2081] [AddCommMonoid X\u2082] [AddCommMonoid X\u2083]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid N]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "{R M N P : Type*} [Ring R]", "(f g) in", "", "[Semiring R]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module R N] [Module R P]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\n\u22a2 Exact \u21d1(LinearMap.inr R M N) \u21d1(LinearMap.fst R M N)"}, {"line": "rintro \u27e8x, y\u27e9", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 (LinearMap.fst R M N) (x, y) = 0 \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inr R M N)"}, {"line": "simp only [LinearMap.fst_apply]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 x = 0 \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inr R M N)"}, {"line": "simp only [@eq_comm _ x]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = x \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inr R M N)"}, {"line": "simp only [LinearMap.coe_inr]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = x \u2194 (x, y) \u2208 Set.range (Prod.mk 0)"}, {"line": "simp only [Set.mem_range]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = x \u2194 \u2203 y_1, (0, y_1) = (x, y)"}, {"line": "simp only [Prod.mk.injEq]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = x \u2194 \u2203 y_1, 0 = x \u2227 y_1 = y"}, {"line": "simp only [exists_eq_right]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = x \u2194 0 = x"}]}
{"declaration": "lemma Exact.inl_snd : Function.Exact (LinearMap.inl R M N) (LinearMap.snd R M N) := by\n  rintro \u27e8x, y\u27e9\n  simp only [LinearMap.snd_apply]\n  simp only [@eq_comm _ y]\n  simp only [LinearMap.coe_inl]\n  simp only [Set.mem_range]\n  simp only [Prod.mk.injEq]\n  simp only [exists_eq_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Exact.lean", "context": {"open": ["Function", "AddMonoidHom", "Function", "LinearMap", "LinearMap"], "variables": ["{R M M' N N' P P' : Type*}", "(f : M \u2192 N) (g : N \u2192 P) (g' : P \u2192 P')", "{f g}", "[AddGroup M] [AddGroup N] [AddGroup P] {f : M \u2192+ N} {g : N \u2192+ P}", "{X\u2081 X\u2082 X\u2083 Y\u2081 Y\u2082 Y\u2083 : Type*} [AddCommMonoid X\u2081] [AddCommMonoid X\u2082] [AddCommMonoid X\u2083]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid N]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "{R M N P : Type*} [Ring R]", "(f g) in", "", "[Semiring R]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P] [Module R M] [Module R N] [Module R P]", "{f : M \u2192\u2097[R] N} {g : N \u2192\u2097[R] P}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\n\u22a2 Exact \u21d1(LinearMap.inl R M N) \u21d1(LinearMap.snd R M N)"}, {"line": "rintro \u27e8x, y\u27e9", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 (LinearMap.snd R M N) (x, y) = 0 \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inl R M N)"}, {"line": "simp only [LinearMap.snd_apply]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 y = 0 \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inl R M N)"}, {"line": "simp only [@eq_comm _ y]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = y \u2194 (x, y) \u2208 Set.range \u21d1(LinearMap.inl R M N)"}, {"line": "simp only [LinearMap.coe_inl]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = y \u2194 (x, y) \u2208 Set.range fun x => (x, 0)"}, {"line": "simp only [Set.mem_range]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = y \u2194 \u2203 y_1, (y_1, 0) = (x, y)"}, {"line": "simp only [Prod.mk.injEq]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = y \u2194 \u2203 y_1, y_1 = x \u2227 0 = y"}, {"line": "simp only [exists_eq_left]", "tactic_state": "case mk\nR : Type u_14\nM : Type u_15\nN : Type u_16\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 : AddCommGroup N\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R N\nx : M\ny : N\n\u22a2 0 = y \u2194 0 = y"}]}
{"declaration": "theorem _root_.Algebra.adjoin_eq_range_freeAlgebra_lift (s : Set A) :\n    Algebra.adjoin R s = (FreeAlgebra.lift R ((\u2191) : s \u2192 A)).range := by\n  rw [\u2190 Algebra.adjoin_range_eq_range_freeAlgebra_lift]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAlgebra.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R]", "(X : Type*)", "(S : Type) [CommSemiring S] in", "(S : Type) [CommRing S] in", "{X}", "{A : Type*} [Semiring A] [Algebra R A]", "{R}", "{A : Type*} [Semiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nA : Type u_4\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\ns : Set A\n\u22a2 Algebra.adjoin R s = ((FreeAlgebra.lift R) Subtype.val).range"}, {"line": "rw [\u2190 Algebra.adjoin_range_eq_range_freeAlgebra_lift]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nA : Type u_4\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\ns : Set A\n\u22a2 Algebra.adjoin R s = Algebra.adjoin R (Set.range Subtype.val)"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_sum_succ {x : R} {n : \u2115} :\n    \u2211 i \u2208 range (n + 1), x ^ i = (x * \u2211 i \u2208 range n, x ^ i) + 1 := by\n  simp only [mul_sum]\n  simp only [\u2190 pow_succ']\n  simp only [sum_range_succ']\n  simp only [pow_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 \u2211 i \u2208 range (n + 1), x ^ i = x * \u2211 i \u2208 range n, x ^ i + 1"}, {"line": "simp only [mul_sum]", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 \u2211 i \u2208 range (n + 1), x ^ i = \u2211 i \u2208 range n, x * x ^ i + 1"}, {"line": "simp only [\u2190 pow_succ']", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 \u2211 i \u2208 range (n + 1), x ^ i = \u2211 x_1 \u2208 range n, x ^ (x_1 + 1) + 1"}, {"line": "simp only [sum_range_succ']", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 \u2211 k \u2208 range n, x ^ (k + 1) + x ^ 0 = \u2211 k \u2208 range n, x ^ (k + 1) + 1"}, {"line": "simp only [pow_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_sum_one (x : R) : \u2211 i \u2208 range 1, x ^ i = 1 := by simp [geom_sum_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\n\u22a2 \u2211 i \u2208 range 1, x ^ i = 1"}, {"line": "simp [geom_sum_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_sum_two {x : R} : \u2211 i \u2208 range 2, x ^ i = x + 1 := by simp [geom_sum_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\n\u22a2 \u2211 i \u2208 range 2, x ^ i = x + 1"}, {"line": "simp [geom_sum_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem op_geom_sum (x : R) (n : \u2115) : op (\u2211 i \u2208 range n, x ^ i) = \u2211 i \u2208 range n, op x ^ i := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Semiring R\nx : R\nn : \u2115\n\u22a2 op (\u2211 i \u2208 range n, x ^ i) = \u2211 i \u2208 range n, op x ^ i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nat_pow_one_sub_dvd_pow_mul_sub_one (x m n : \u2115) : x ^ m - 1 \u2223 x ^ (m * n) - 1 := by\n  nth_rw 2 [\u2190 Nat.one_pow n]\n  rw [Nat.pow_mul x m n]\n  apply nat_sub_dvd_pow_sub_pow (x ^ m) 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x m n : \u2115\n\u22a2 x ^ m - 1 \u2223 x ^ (m * n) - 1"}, {"line": "nth_rw 2 [\u2190 Nat.one_pow n]", "tactic_state": "x m n : \u2115\n\u22a2 x ^ m - 1 \u2223 x ^ (m * n) - 1 ^ n"}, {"line": "rw [Nat.pow_mul x m n]", "tactic_state": "x m n : \u2115\n\u22a2 x ^ m - 1 \u2223 (x ^ m) ^ n - 1 ^ n"}, {"line": "apply nat_sub_dvd_pow_sub_pow (x ^ m) 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_sum_mul_of_one_le [CommSemiring R] [PartialOrder R] [AddLeftReflectLE R]\n    [AddLeftMono R] [ExistsAddOfLE R] [Sub R] [OrderedSub R] {x : R} (hx : 1 \u2264 x) (n : \u2115) :\n    (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1 := by\n  simpa using geom_sum\u2082_mul_of_ge hx n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddLeftReflectLE R\ninst\u271d\u00b3 : AddLeftMono R\ninst\u271d\u00b2 : ExistsAddOfLE R\ninst\u271d\u00b9 : Sub R\ninst\u271d : OrderedSub R\nx : R\nhx : 1 \u2264 x\nn : \u2115\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (x - 1) = x ^ n - 1"}, {"line": "simpa using geom_sum\u2082_mul_of_ge hx n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_sum_mul_of_le_one [CommSemiring R] [PartialOrder R] [AddLeftReflectLE R]\n    [AddLeftMono R] [ExistsAddOfLE R] [Sub R] [OrderedSub R] {x : R} (hx : x \u2264 1) (n : \u2115) :\n    (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n := by\n  simpa using geom_sum\u2082_mul_of_le hx n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddLeftReflectLE R\ninst\u271d\u00b3 : AddLeftMono R\ninst\u271d\u00b2 : ExistsAddOfLE R\ninst\u271d\u00b9 : Sub R\ninst\u271d : OrderedSub R\nx : R\nhx : x \u2264 1\nn : \u2115\n\u22a2 (\u2211 i \u2208 range n, x ^ i) * (1 - x) = 1 - x ^ n"}, {"line": "simpa using geom_sum\u2082_mul_of_le hx n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.geomSum_eq (hm : 2 \u2264 m) (n : \u2115) :\n    \u2211 k \u2208 range n, m ^ k = (m ^ n - 1) / (m - 1) := by\n  refine (Nat.div_eq_of_eq_mul_left (tsub_pos_iff_lt.2 hm) <| tsub_eq_of_eq_add ?_).symm\n  simpa only [tsub_add_cancel_of_le (one_le_two.trans hm), eq_comm] using geom_sum_mul_add (m - 1) n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GeomSum.lean", "context": {"open": ["Finset MulOpposite"], "variables": ["{R K : Type*}", "[Semiring R]", "{S : Type*}", "{n : \u2115} {x : R}", "{m n : \u2115} {s : Finset \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nhm : 2 \u2264 m\nn : \u2115\n\u22a2 \u2211 k \u2208 range n, m ^ k = (m ^ n - 1) / (m - 1)"}, {"line": "refine (Nat.div_eq_of_eq_mul_left (tsub_pos_iff_lt.2 hm) <| tsub_eq_of_eq_add ?_).symm", "tactic_state": "m : \u2115\nhm : 2 \u2264 m\nn : \u2115\n\u22a2 m ^ n = (\u2211 k \u2208 range n, m ^ k) * (m - 1) + 1"}, {"line": "simpa only [tsub_add_cancel_of_le (one_le_two.trans hm), eq_comm] using geom_sum_mul_add (m - 1) n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GradedMonoid.list_prod_map_eq_dProd (l : List \u03b1) (f : \u03b1 \u2192 GradedMonoid A) :\n    (l.map f).prod = GradedMonoid.mk _ (l.dProd (fun i => (f i).1) fun i => (f i).2) := by\n  rw [GradedMonoid.mk_list_dProd]\n  rw [GradedMonoid.mk]\n  simp_rw [Sigma.eta]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GradedMonoid.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "{\u03b1 \u03b2} {A : \u03b9 \u2192 Type*}", "(A : \u03b9 \u2192 Type*)", "{A}", "[AddMonoid \u03b9] [GMul A] [GOne A]", "(A : \u03b9 \u2192 Type*)", "[Zero \u03b9] [GOne A]", "[AddZeroClass \u03b9] [GMul A]", "{A}", "[AddMonoid \u03b9] [GMonoid A]", "{A} in", "[AddCommMonoid \u03b9] [GCommMonoid A]", "[AddMonoid \u03b9] [GMonoid A]", "{\u03b1 : Type*} {A : \u03b9 \u2192 Type*} [AddMonoid \u03b9] [GradedMonoid.GMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_5\nA : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GMonoid A\nl : List \u03b1\nf : \u03b1 \u2192 GradedMonoid A\n\u22a2 (List.map f l).prod = mk (l.dProdIndex fun i => (f i).fst) (l.dProd (fun i => (f i).fst) fun i => (f i).snd)"}, {"line": "rw [GradedMonoid.mk_list_dProd]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_5\nA : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GMonoid A\nl : List \u03b1\nf : \u03b1 \u2192 GradedMonoid A\n\u22a2 (List.map f l).prod = (List.map (fun a => mk (f a).fst (f a).snd) l).prod"}, {"line": "rw [GradedMonoid.mk]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_5\nA : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GMonoid A\nl : List \u03b1\nf : \u03b1 \u2192 GradedMonoid A\n\u22a2 (List.map f l).prod = (List.map (fun a => \u27e8(f a).fst, (f a).snd\u27e9) l).prod"}, {"line": "simp_rw [Sigma.eta]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GradedMonoid.list_prod_ofFn_eq_dProd {n : \u2115} (f : Fin n \u2192 GradedMonoid A) :\n    (List.ofFn f).prod =\n      GradedMonoid.mk _ ((List.finRange n).dProd (fun i => (f i).1) fun i => (f i).2) := by\n  rw [List.ofFn_eq_map]\n  rw [GradedMonoid.list_prod_map_eq_dProd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GradedMonoid.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "{\u03b1 \u03b2} {A : \u03b9 \u2192 Type*}", "(A : \u03b9 \u2192 Type*)", "{A}", "[AddMonoid \u03b9] [GMul A] [GOne A]", "(A : \u03b9 \u2192 Type*)", "[Zero \u03b9] [GOne A]", "[AddZeroClass \u03b9] [GMul A]", "{A}", "[AddMonoid \u03b9] [GMonoid A]", "{A} in", "[AddCommMonoid \u03b9] [GCommMonoid A]", "[AddMonoid \u03b9] [GMonoid A]", "{\u03b1 : Type*} {A : \u03b9 \u2192 Type*} [AddMonoid \u03b9] [GradedMonoid.GMonoid A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GMonoid A\nn : \u2115\nf : Fin n \u2192 GradedMonoid A\n\u22a2 (List.ofFn f).prod =\n    mk ((List.finRange n).dProdIndex fun i => (f i).fst)\n      ((List.finRange n).dProd (fun i => (f i).fst) fun i => (f i).snd)"}, {"line": "rw [List.ofFn_eq_map]", "tactic_state": "\u03b9 : Type u_1\nA : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GMonoid A\nn : \u2115\nf : Fin n \u2192 GradedMonoid A\n\u22a2 (List.map f (List.finRange n)).prod =\n    mk ((List.finRange n).dProdIndex fun i => (f i).fst)\n      ((List.finRange n).dProd (fun i => (f i).fst) fun i => (f i).snd)"}, {"line": "rw [GradedMonoid.list_prod_map_eq_dProd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem list_prod_ofFn_mem_graded {n} (i : Fin n \u2192 \u03b9) (r : Fin n \u2192 R) (h : \u2200 j, r j \u2208 A (i j)) :\n    (List.ofFn r).prod \u2208 A (List.ofFn i).sum := by\n  rw [List.ofFn_eq_map]\n  rw [List.ofFn_eq_map]\n  exact list_prod_map_mem_graded _ _ _ fun _ _ => h _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GradedMonoid.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}", "{\u03b1 \u03b2} {A : \u03b9 \u2192 Type*}", "(A : \u03b9 \u2192 Type*)", "{A}", "[AddMonoid \u03b9] [GMul A] [GOne A]", "(A : \u03b9 \u2192 Type*)", "[Zero \u03b9] [GOne A]", "[AddZeroClass \u03b9] [GMul A]", "{A}", "[AddMonoid \u03b9] [GMonoid A]", "{A} in", "[AddCommMonoid \u03b9] [GCommMonoid A]", "[AddMonoid \u03b9] [GMonoid A]", "{\u03b1 : Type*} {A : \u03b9 \u2192 Type*} [AddMonoid \u03b9] [GradedMonoid.GMonoid A]", "(\u03b9) {R : Type*}", "{R : Type*}", "{S : Type*} [SetLike S R] [Monoid R] [AddMonoid \u03b9]", "{A : \u03b9 \u2192 S} [SetLike.GradedMonoid A]", "(A) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : AddMonoid \u03b9\nR : Type u_8\nS : Type u_9\ninst\u271d\u00b3 : SetLike S R\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b9\nA : \u03b9 \u2192 S\ninst\u271d : SetLike.GradedMonoid A\nn : \u2115\ni : Fin n \u2192 \u03b9\nr : Fin n \u2192 R\nh : \u2200 (j : Fin n), r j \u2208 A (i j)\n\u22a2 (List.ofFn r).prod \u2208 A (List.ofFn i).sum"}, {"line": "rw [List.ofFn_eq_map]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : AddMonoid \u03b9\nR : Type u_8\nS : Type u_9\ninst\u271d\u00b3 : SetLike S R\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b9\nA : \u03b9 \u2192 S\ninst\u271d : SetLike.GradedMonoid A\nn : \u2115\ni : Fin n \u2192 \u03b9\nr : Fin n \u2192 R\nh : \u2200 (j : Fin n), r j \u2208 A (i j)\n\u22a2 (List.ofFn r).prod \u2208 A (List.map i (List.finRange n)).sum"}, {"line": "rw [List.ofFn_eq_map]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : AddMonoid \u03b9\nR : Type u_8\nS : Type u_9\ninst\u271d\u00b3 : SetLike S R\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : AddMonoid \u03b9\nA : \u03b9 \u2192 S\ninst\u271d : SetLike.GradedMonoid A\nn : \u2115\ni : Fin n \u2192 \u03b9\nr : Fin n \u2192 R\nh : \u2200 (j : Fin n), r j \u2208 A (i j)\n\u22a2 (List.map r (List.finRange n)).prod \u2208 A (List.map i (List.finRange n)).sum"}, {"line": "exact list_prod_map_mem_graded _ _ _ fun _ _ => h _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_neZero {n : R} : \u00acNeZero n \u2194 n = 0 := by simp [neZero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/NeZero.lean", "context": {"open": [], "variables": ["{R : Type*} [Zero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : Zero R\nn : R\n\u22a2 \u00acNeZero n \u2194 n = 0"}, {"line": "simp [neZero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem left_cancel (x : R) {y y' : R} : x \u25c3 y = x \u25c3 y' \u2194 y = y' := by\n  constructor\n  \u00b7 apply (act' x).injective\n  rintro rfl\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quandle.lean", "context": {"open": ["MulOpposite", "Quandles", "Shelf"], "variables": ["{S : Type*} [UnitalShelf S]", "{R : Type*} [Rack R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 act x y = act x y' \u2194 y = y'"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 act x y = act x y' \u2192 y = y'\n---\ncase mpr\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 y = y' \u2192 act x y = act x y'"}, {"line": "\u00b7 apply (act' x).injective", "tactic_state": "case mpr\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 y = y' \u2192 act x y = act x y'"}, {"line": "rintro rfl", "tactic_state": "case mpr\nR : Type u_2\ninst\u271d : Rack R\nx y : R\n\u22a2 act x y = act x y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem left_cancel_inv (x : R) {y y' : R} : x \u25c3\u207b\u00b9 y = x \u25c3\u207b\u00b9 y' \u2194 y = y' := by\n  constructor\n  \u00b7 apply (act' x).symm.injective\n  rintro rfl\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quandle.lean", "context": {"open": ["MulOpposite", "Quandles", "Shelf"], "variables": ["{S : Type*} [UnitalShelf S]", "{R : Type*} [Rack R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 Rack.invAct x y = Rack.invAct x y' \u2194 y = y'"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 Rack.invAct x y = Rack.invAct x y' \u2192 y = y'\n---\ncase mpr\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 y = y' \u2192 Rack.invAct x y = Rack.invAct x y'"}, {"line": "\u00b7 apply (act' x).symm.injective", "tactic_state": "case mpr\nR : Type u_2\ninst\u271d : Rack R\nx y y' : R\n\u22a2 y = y' \u2192 Rack.invAct x y = Rack.invAct x y'"}, {"line": "rintro rfl", "tactic_state": "case mpr\nR : Type u_2\ninst\u271d : Rack R\nx y : R\n\u22a2 Rack.invAct x y = Rack.invAct x y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_add : ((x + y : R) : \u210d[R,c\u2081,c\u2082,c\u2083]) = x + y := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2081 c\u2082 c\u2083 x y : R\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddZeroClass R\n\u22a2 \u2191(x + y) = \u2191x + \u2191y"}, {"line": "ext <;> simp", "tactic_state": "case imI\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x y : R\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddZeroClass R\n\u22a2 0 = 0 + 0\n---\ncase imJ\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x y : R\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddZeroClass R\n\u22a2 0 = 0 + 0\n---\ncase imK\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x y : R\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : One R\ninst\u271d\u00b9 : Add R\ninst\u271d : AddZeroClass R\n\u22a2 0 = 0 + 0"}]}
{"declaration": "theorem coe_neg : ((-x : R) : \u210d[R,c\u2081,c\u2082,c\u2083]) = -x := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2075 : Zero R\ninst\u271d\u2074 : One R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : AddZeroClass R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroup R\n\u22a2 \u2191(-x) = -\u2191x"}, {"line": "ext <;> simp", "tactic_state": "case imI\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2075 : Zero R\ninst\u271d\u2074 : One R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : AddZeroClass R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroup R\n\u22a2 0 = -0\n---\ncase imJ\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2075 : Zero R\ninst\u271d\u2074 : One R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : AddZeroClass R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroup R\n\u22a2 0 = -0\n---\ncase imK\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2075 : Zero R\ninst\u271d\u2074 : One R\ninst\u271d\u00b3 : Add R\ninst\u271d\u00b2 : AddZeroClass R\ninst\u271d\u00b9 : Neg R\ninst\u271d : AddGroup R\n\u22a2 0 = -0"}]}
{"declaration": "lemma comm (r : R) (x : \u210d[R, c\u2081, c\u2082, c\u2083]) : r * x = x * r := by\n  ext <;> simp [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\nr : R\nx : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 \u2191r * x = x * \u2191r"}, {"line": "ext <;> simp [mul_comm]", "tactic_state": "case re\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\nr : R\nx : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 r * x.re + c\u2081 * 0 * x.imI + c\u2083 * 0 * x.imJ + c\u2082 * c\u2083 * 0 * x.imK - c\u2081 * c\u2083 * 0 * x.imK =\n    x.re * r + c\u2081 * x.imI * 0 + c\u2083 * x.imJ * 0 + c\u2082 * c\u2083 * x.imJ * 0 - c\u2081 * c\u2083 * x.imK * 0\n---\ncase imI\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\nr : R\nx : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 r * x.imI + 0 * x.re + c\u2082 * 0 * x.imI - c\u2083 * 0 * x.imK + c\u2083 * 0 * x.imJ =\n    x.re * 0 + x.imI * r + c\u2082 * x.imI * 0 - c\u2083 * x.imJ * 0 + c\u2083 * x.imK * 0\n---\ncase imJ\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\nr : R\nx : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 r * x.imJ + c\u2081 * 0 * x.imK + 0 * x.re + c\u2082 * 0 * x.imI - c\u2081 * 0 * x.imI =\n    x.re * 0 + c\u2081 * x.imI * 0 + x.imJ * r + c\u2082 * x.imJ * 0 - c\u2081 * x.imK * 0\n---\ncase imK\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\nr : R\nx : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 r * x.imK + 0 * x.imJ + c\u2082 * 0 * x.imK - 0 * x.imI + 0 * x.re =\n    x.re * 0 + x.imI * 0 + c\u2082 * x.imI * 0 - x.imJ * 0 + x.imK * r"}]}
{"declaration": "theorem star_coe : star (x : \u210d[R,c\u2081,c\u2082,c\u2083]) = x := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\n\u22a2 star \u2191x = \u2191x"}, {"line": "ext <;> simp", "tactic_state": "case re\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\n\u22a2 x + c\u2082 * 0 = x\n---\ncase imI\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\n\u22a2 -0 = 0\n---\ncase imJ\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\n\u22a2 -0 = 0\n---\ncase imK\nR : Type u_3\nc\u2081 c\u2082 c\u2083 x : R\ninst\u271d\u2078 : Zero R\ninst\u271d\u2077 : One R\ninst\u271d\u2076 : Add R\ninst\u271d\u2075 : AddZeroClass R\ninst\u271d\u2074 : Neg R\ninst\u271d\u00b3 : AddGroup R\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroupWithOne R\ninst\u271d : CommRing R\n\u22a2 -0 = 0"}]}
{"declaration": "theorem star_eq_self {c\u2081 c\u2082 : R} {a : \u210d[R,c\u2081,c\u2082,c\u2083]} : star a = a \u2194 a = a.re := by\n  simp_all [QuaternionAlgebra.ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2083 : R\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nc\u2081 c\u2082 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 star a = a \u2194 a = \u2191a.re"}, {"line": "simp_all [QuaternionAlgebra.ext_iff, neg_eq_iff_add_eq_zero, add_self_eq_zero]", "tactic_state": "R : Type u_3\nc\u2083 : R\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nc\u2081 c\u2082 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\n\u22a2 a.re + c\u2082 * a.imI = a.re \u2227 a.imI + a.imI = 0 \u2227 a.imJ + a.imJ = 0 \u2227 a.imK + a.imK = 0 \u2194\n    a.imI = 0 \u2227 a.imJ = 0 \u2227 a.imK = 0"}]}
{"declaration": "theorem star_eq_neg {c\u2081 : R} {a : \u210d[R,c\u2081,0,c\u2083]} : star a = -a \u2194 a.re = 0 := by\n  simp [QuaternionAlgebra.ext_iff, eq_neg_iff_add_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2083 : R\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nc\u2081 : R\na : QuaternionAlgebra R c\u2081 0 c\u2083\n\u22a2 star a = -a \u2194 a.re = 0"}, {"line": "simp [QuaternionAlgebra.ext_iff, eq_neg_iff_add_eq_zero]", "tactic_state": "R : Type u_3\nc\u2083 : R\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nc\u2081 : R\na : QuaternionAlgebra R c\u2081 0 c\u2083\n\u22a2 a.re + 0 * a.imI = -a.re \u2227 -a.imI = -a.imI \u2227 -a.imJ = -a.imJ \u2227 -a.imK = -a.imK \u2194 a.re = 0"}]}
{"declaration": "theorem star_mul_eq_coe : star a * a = (star a * a).re := by ext <;> simp <;> ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\nc\u2081 c\u2082 c\u2083 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 star a * a = \u2191(star a * a).re"}, {"line": "ext <;> simp <;> ring", "tactic_state": "case imI\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (a.re + c\u2082 * a.imI) * a.imI + -a.imI * a.re + c\u2082 * -a.imI * a.imI - c\u2083 * -a.imJ * a.imK + c\u2083 * -a.imK * a.imJ = 0\n---\ncase imJ\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (a.re + c\u2082 * a.imI) * a.imJ + c\u2081 * -a.imI * a.imK + -a.imJ * a.re + c\u2082 * -a.imJ * a.imI - c\u2081 * -a.imK * a.imI = 0\n---\ncase imK\nR : Type u_3\nc\u2081 c\u2082 c\u2083 : R\na : QuaternionAlgebra R c\u2081 c\u2082 c\u2083\ninst\u271d\u00b9\u2070 : Zero R\ninst\u271d\u2079 : One R\ninst\u271d\u2078 : Add R\ninst\u271d\u2077 : AddZeroClass R\ninst\u271d\u2076 : Neg R\ninst\u271d\u2075 : AddGroup R\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : AddCommGroupWithOne R\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (a.re + c\u2082 * a.imI) * a.imK + -a.imI * a.imJ + c\u2082 * -a.imI * a.imK - -a.imJ * a.imI + -a.imK * a.re = 0"}]}
{"declaration": "theorem normSq_coe : normSq (x : \u210d[R]) = x ^ 2 := by\n  rw [normSq_def]\n  rw [star_coe]\n  rw [\u2190 coe_mul]\n  rw [coe_re]\n  rw [sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\nx : R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 normSq \u2191x = x ^ 2"}, {"line": "rw [normSq_def]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\nx : R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (\u2191x * star \u2191x).re = x ^ 2"}, {"line": "rw [star_coe]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\nx : R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (\u2191x * \u2191x).re = x ^ 2"}, {"line": "rw [\u2190 coe_mul]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\nx : R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 (\u2191(x * x)).re = x ^ 2"}, {"line": "rw [coe_re]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\nx : R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 x * x = x ^ 2"}, {"line": "rw [sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_star : normSq (star a) = normSq a := by simp [normSq_def']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\na : Quaternion R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 normSq (star a) = normSq a"}, {"line": "simp [normSq_def']", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\na : Quaternion R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 a.re ^ 2 + (-a.imI) ^ 2 + (-a.imJ) ^ 2 + (-a.imK) ^ 2 = a.re ^ 2 + a.imI ^ 2 + a.imJ ^ 2 + a.imK ^ 2"}]}
{"declaration": "theorem normSq_natCast (n : \u2115) : normSq (n : \u210d[R]) = (n : R) ^ 2 := by\n  rw [\u2190 coe_natCast]\n  rw [normSq_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nn : \u2115\n\u22a2 normSq \u2191n = \u2191n ^ 2"}, {"line": "rw [\u2190 coe_natCast]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nn : \u2115\n\u22a2 normSq \u2191\u2191n = \u2191n ^ 2"}, {"line": "rw [normSq_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_intCast (z : \u2124) : normSq (z : \u210d[R]) = (z : R) ^ 2 := by\n  rw [\u2190 coe_intCast]\n  rw [normSq_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nz : \u2124\n\u22a2 normSq \u2191z = \u2191z ^ 2"}, {"line": "rw [\u2190 coe_intCast]", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\nz : \u2124\n\u22a2 normSq \u2191\u2191z = \u2191z ^ 2"}, {"line": "rw [normSq_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_mul_star : a * star a = normSq a := by rw [mul_star_eq_coe, normSq_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\na : Quaternion R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 a * star a = \u2191(normSq a)"}, {"line": "rw [mul_star_eq_coe, normSq_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mul_self : star a * a = normSq a := by rw [star_comm_self, self_mul_star]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\na : Quaternion R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 star a * a = \u2191(normSq a)"}, {"line": "rw [star_comm_self, self_mul_star]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem im_sq : a.im ^ 2 = -normSq a.im := by\n  simp_rw [sq, \u2190 star_mul_self, im_star, neg_mul, neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Quaternion.lean", "context": {"open": ["Quaternion", "MulOpposite", "Quaternion", "MulOpposite"], "variables": ["{S T R : Type*} {c\u2081 c\u2082 c\u2083 : R} (r x y : R) (a b : \u210d[R,c\u2081,c\u2082,c\u2083])", "[Zero R]", "[One R]", "[Add R]", "[AddZeroClass R]", "[Neg R]", "[AddGroup R]", "[Ring R]", "[SMul S R] [SMul T R] (s : S)", "[AddCommGroupWithOne R]", "[CommRing R]", "(c\u2081 c\u2082 c\u2083)", "[NoZeroDivisors R] [CharZero R]", "{S T R : Type*} [CommRing R] (r x y : R) (a b : \u210d[R])", "[NoZeroDivisors R] [CharZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b2 : CommRing R\na : Quaternion R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : CharZero R\n\u22a2 a.im ^ 2 = -\u2191(normSq a.im)"}, {"line": "simp_rw [sq, \u2190 star_mul_self, im_star, neg_mul, neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_zero : q.lift (0 : \u210d[R,c\u2081,c\u2082,c\u2083]) = 0 := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/QuaternionBasis.lean", "context": {"open": ["Quaternion"], "variables": ["{R : Type*} {A B : Type*} [CommRing R] [Ring A] [Ring B] [Algebra R A] [Algebra R B]", "{c\u2081 c\u2082 c\u2083 : R}", "(R) in", "(q : Basis A c\u2081 c\u2082 c\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 0"}, {"line": "simp [lift]", "tactic_state": "\u22a2 sorry () = 0"}]}
{"declaration": "theorem lift_one : q.lift (1 : \u210d[R,c\u2081,c\u2082,c\u2083]) = 1 := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/QuaternionBasis.lean", "context": {"open": ["Quaternion"], "variables": ["{R : Type*} {A B : Type*} [CommRing R] [Ring A] [Ring B] [Algebra R A] [Algebra R B]", "{c\u2081 c\u2082 c\u2083 : R}", "(R) in", "(q : Basis A c\u2081 c\u2082 c\u2083)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 1"}, {"line": "simp [lift]", "tactic_state": "\u22a2 sorry () = 1"}]}
{"declaration": "theorem snd_map (f : M \u2192\u2097[R'] N) (x : TrivSqZeroExt R' M) : snd (map f x) = f (snd x) := by\n  simp [map, lift_def, Algebra.ofId_apply, algebraMap_eq_inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/TrivSqZeroExt.lean", "context": {"open": ["scoped RightActions", "MulOpposite"], "variables": ["{R : Type u} {M : Type v}", "(M)", "(R)", "{T : Type*} {S : Type*} {R : Type u} {M : Type v}", "(M)", "(R)", "(R M)", "{R : Type u} {M : Type v}", "(M)", "(R)", "(R M)", "{R : Type u} {M : Type v}", "[Neg M] [Inv R] [SMul R\u1d50\u1d52\u1d56 M] [SMul R M]", "{R : Type u} {M : Type v}", "[AddCommGroup M] [Semiring R] [Module R\u1d50\u1d52\u1d56 M] [Module R M]", "[SMulCommClass R R\u1d50\u1d52\u1d56 M]", "{R : Type u} {M : Type v}", "[DivisionSemiring R] [AddCommGroup M] [Module R\u1d50\u1d52\u1d56 M] [Module R M]", "[SMulCommClass R R\u1d50\u1d52\u1d56 M]", "{R : Type u} {M : Type v}", "[DivisionRing R] [AddCommGroup M] [Module R\u1d50\u1d52\u1d56 M] [Module R M]", "(S : Type*) (R R' : Type u) (M : Type v)", "[CommSemiring S] [Semiring R] [CommSemiring R'] [AddCommMonoid M]", "[Algebra S R] [Module S M] [Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M]", "[IsScalarTower S R M] [IsScalarTower S R\u1d50\u1d52\u1d56 M]", "[Module R' M] [Module R'\u1d50\u1d52\u1d56 M] [IsCentralScalar R' M]", "{R R' S M}", "{A : Type*} [Semiring A] [Algebra S A] [Algebra R' A]", "{N P : Type*} [AddCommMonoid N] [Module R' N] [Module R'\u1d50\u1d52\u1d56 N] [IsCentralScalar R' N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R' : Type u\nM : Type v\ninst\u271d\u2078 : CommSemiring R'\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R' M\ninst\u271d\u2075 : Module R'\u1d50\u1d52\u1d56 M\ninst\u271d\u2074 : IsCentralScalar R' M\nN : Type u_5\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R' N\ninst\u271d\u00b9 : Module R'\u1d50\u1d52\u1d56 N\ninst\u271d : IsCentralScalar R' N\nx\u271d : Sort u_7\nsnd : x\u271d\nf : M \u2192\u2097[R'] N\nx : TrivSqZeroExt R' M\n\u22a2 sorry = f sorry"}, {"line": "simp [map, lift_def, Algebra.ofId_apply, algebraMap_eq_inl]", "tactic_state": "R' : Type u\nM : Type v\ninst\u271d\u2078 : CommSemiring R'\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R' M\ninst\u271d\u2075 : Module R'\u1d50\u1d52\u1d56 M\ninst\u271d\u2074 : IsCentralScalar R' M\nN : Type u_5\ninst\u271d\u00b3 : AddCommMonoid N\ninst\u271d\u00b2 : Module R' N\ninst\u271d\u00b9 : Module R'\u1d50\u1d52\u1d56 N\ninst\u271d : IsCentralScalar R' N\nx\u271d : Sort u_7\nsnd : x\u271d\nf : M \u2192\u2097[R'] N\nx : TrivSqZeroExt R' M\n\u22a2 sorry () = f (sorry ())"}]}
{"declaration": "theorem map_add_nsmul [AddMonoid G] [AddMonoid H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) (n : \u2115) : f (x + n \u2022 a) = f x + n \u2022 b := by\n  simpa using (AddConstMapClass.semiconj f).iterate_right n x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddMonoid G\ninst\u271d\u00b9 : AddMonoid H\ninst\u271d : AddConstMapClass F G H a b\nf : F\nx : G\nn : \u2115\n\u22a2 f (x + n \u2022 a) = f x + n \u2022 b"}, {"line": "simpa using (AddConstMapClass.semiconj f).iterate_right n x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_const [AddZeroClass G] [Add H] [AddConstMapClass F G H a b] (f : F) :\n    f a = f 0 + b := by\n  simpa using map_add_const f 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddZeroClass G\ninst\u271d\u00b9 : Add H\ninst\u271d : AddConstMapClass F G H a b\nf : F\n\u22a2 f a = f 0 + b"}, {"line": "simpa using map_add_const f 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nsmul_const [AddMonoid G] [AddMonoid H] [AddConstMapClass F G H a b]\n    (f : F) (n : \u2115) : f (n \u2022 a) = f 0 + n \u2022 b := by\n  simpa using map_add_nsmul f 0 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddMonoid G\ninst\u271d\u00b9 : AddMonoid H\ninst\u271d : AddConstMapClass F G H a b\nf : F\nn : \u2115\n\u22a2 f (n \u2022 a) = f 0 + n \u2022 b"}, {"line": "simpa using map_add_nsmul f 0 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nat' [AddMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : \u2115) : f n = f 0 + n \u2022 b := by\n  simpa using map_add_nat' f 0 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\nb : H\ninst\u271d\u00b2 : AddMonoidWithOne G\ninst\u271d\u00b9 : AddMonoid H\ninst\u271d : AddConstMapClass F G H 1 b\nf : F\nn : \u2115\n\u22a2 f \u2191n = f 0 + n \u2022 b"}, {"line": "simpa using map_add_nat' f 0 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_nat_add' [AddCommMonoidWithOne G] [AddMonoid H] [AddConstMapClass F G H 1 b]\n    (f : F) (n : \u2115) (x : G) : f (\u2191n + x) = f x + n \u2022 b := by\n  simpa using map_nsmul_add f n x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\nb : H\ninst\u271d\u00b2 : AddCommMonoidWithOne G\ninst\u271d\u00b9 : AddMonoid H\ninst\u271d : AddConstMapClass F G H 1 b\nf : F\nn : \u2115\nx : G\n\u22a2 f (\u2191n + x) = f x + n \u2022 b"}, {"line": "simpa using map_nsmul_add f n x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sub_const [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) : f (x - a) = f x - b := by\n  simpa using map_sub_nsmul f x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddGroup G\ninst\u271d\u00b9 : AddGroup H\ninst\u271d : AddConstMapClass F G H a b\nf : F\nx : G\n\u22a2 f (x - a) = f x - b"}, {"line": "simpa using map_sub_nsmul f x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sub_nat' [AddGroupWithOne G] [AddGroup H] [AddConstMapClass F G H 1 b]\n    (f : F) (x : G) (n : \u2115) : f (x - n) = f x - n \u2022 b := by\n  simpa using map_sub_nsmul f x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\nb : H\ninst\u271d\u00b2 : AddGroupWithOne G\ninst\u271d\u00b9 : AddGroup H\ninst\u271d : AddConstMapClass F G H 1 b\nf : F\nx : G\nn : \u2115\n\u22a2 f (x - \u2191n) = f x - n \u2022 b"}, {"line": "simpa using map_sub_nsmul f x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_zsmul_const [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (n : \u2124) : f (n \u2022 a) = f 0 + n \u2022 b := by\n  simpa using map_add_zsmul f 0 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddGroup G\ninst\u271d\u00b9 : AddGroup H\ninst\u271d : AddConstMapClass F G H a b\nf : F\nn : \u2124\n\u22a2 f (n \u2022 a) = f 0 + n \u2022 b"}, {"line": "simpa using map_add_zsmul f 0 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sub_zsmul [AddGroup G] [AddGroup H] [AddConstMapClass F G H a b]\n    (f : F) (x : G) (n : \u2124) : f (x - n \u2022 a) = f x - n \u2022 b := by\n  simpa [sub_eq_add_neg] using map_add_zsmul f x (-n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddConstMap/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{F G H : Type*} [FunLike F G H] {a : G} {b : H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nG : Type u_2\nH : Type u_3\ninst\u271d\u00b3 : FunLike F G H\na : G\nb : H\ninst\u271d\u00b2 : AddGroup G\ninst\u271d\u00b9 : AddGroup H\ninst\u271d : AddConstMapClass F G H a b\nf : F\nx : G\nn : \u2124\n\u22a2 f (x - n \u2022 a) = f x - n \u2022 b"}, {"line": "simpa [sub_eq_add_neg] using map_add_zsmul f x (-n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_vsub_self (p : P) : ({p} : Set P) -\u1d65 {p} = {(0 : G)} := by\n  rw [Set.singleton_vsub_singleton]\n  rw [vsub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np : P\n\u22a2 {p} -\u1d65 {p} = {0}"}, {"line": "rw [Set.singleton_vsub_singleton]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np : P\n\u22a2 {p -\u1d65 p} = {0}"}, {"line": "rw [vsub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vsub_left_cancel {p\u2081 p\u2082 p : P} (h : p\u2081 -\u1d65 p = p\u2082 -\u1d65 p) : p\u2081 = p\u2082 := by\n  rwa [\u2190 sub_eq_zero, vsub_sub_vsub_cancel_right, vsub_eq_zero_iff_eq] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p : P\nh : p\u2081 -\u1d65 p = p\u2082 -\u1d65 p\n\u22a2 p\u2081 = p\u2082"}, {"line": "rwa [\u2190 sub_eq_zero, vsub_sub_vsub_cancel_right, vsub_eq_zero_iff_eq] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vadd_vsub_vadd_cancel_left (v : G) (p\u2081 p\u2082 : P) : (v +\u1d65 p\u2081) -\u1d65 (v +\u1d65 p\u2082) = p\u2081 -\u1d65 p\u2082 := by\n  rw [vsub_vadd_eq_vsub_sub]\n  rw [vadd_vsub_assoc]\n  rw [add_sub_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]", "{G : Type*} {P : Type*} [AddCommGroup G] [AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\nv : G\np\u2081 p\u2082 : P\n\u22a2 (v +\u1d65 p\u2081) -\u1d65 (v +\u1d65 p\u2082) = p\u2081 -\u1d65 p\u2082"}, {"line": "rw [vsub_vadd_eq_vsub_sub]", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\nv : G\np\u2081 p\u2082 : P\n\u22a2 (v +\u1d65 p\u2081) -\u1d65 p\u2082 - v = p\u2081 -\u1d65 p\u2082"}, {"line": "rw [vadd_vsub_assoc]", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\nv : G\np\u2081 p\u2082 : P\n\u22a2 v + (p\u2081 -\u1d65 p\u2082) - v = p\u2081 -\u1d65 p\u2082"}, {"line": "rw [add_sub_cancel_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vsub_sub_vsub_comm (p\u2081 p\u2082 p\u2083 p\u2084 : P) : p\u2081 -\u1d65 p\u2082 - (p\u2083 -\u1d65 p\u2084) = p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2084) := by\n  rw [\u2190 vsub_vadd_eq_vsub_sub]\n  rw [vsub_vadd_comm]\n  rw [vsub_vadd_eq_vsub_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Basic.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]", "{G : Type*} {P : Type*} [AddCommGroup G] [AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 p\u2081 -\u1d65 p\u2082 - (p\u2083 -\u1d65 p\u2084) = p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2084)"}, {"line": "rw [\u2190 vsub_vadd_eq_vsub_sub]", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 p\u2081 -\u1d65 ((p\u2083 -\u1d65 p\u2084) +\u1d65 p\u2082) = p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2084)"}, {"line": "rw [vsub_vadd_comm]", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : AddTorsor G P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 p\u2081 -\u1d65 ((p\u2082 -\u1d65 p\u2084) +\u1d65 p\u2083) = p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2084)"}, {"line": "rw [vsub_vadd_eq_vsub_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vadd_vsub_eq_sub_vsub (g : G) (p q : P) : (g +\u1d65 p) -\u1d65 q = g - (q -\u1d65 p) := by\n  rw [vadd_vsub_assoc]\n  rw [sub_eq_add_neg]\n  rw [neg_vsub_eq_vsub_rev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Defs.lean", "context": {"open": [], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\ng : G\np q : P\n\u22a2 (g +\u1d65 p) -\u1d65 q = g - (q -\u1d65 p)"}, {"line": "rw [vadd_vsub_assoc]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\ng : G\np q : P\n\u22a2 g + (p -\u1d65 q) = g - (q -\u1d65 p)"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\ng : G\np q : P\n\u22a2 g + (p -\u1d65 q) = g + -(q -\u1d65 p)"}, {"line": "rw [neg_vsub_eq_vsub_rev]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vsub_sub_vsub_cancel_right (p\u2081 p\u2082 p\u2083 : P) : p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2083) = p\u2081 -\u1d65 p\u2082 := by\n  rw [\u2190 vsub_vadd_eq_vsub_sub]\n  rw [vsub_vadd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Defs.lean", "context": {"open": [], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p\u2083 : P\n\u22a2 p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2083) = p\u2081 -\u1d65 p\u2082"}, {"line": "rw [\u2190 vsub_vadd_eq_vsub_sub]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\np\u2081 p\u2082 p\u2083 : P\n\u22a2 p\u2081 -\u1d65 ((p\u2082 -\u1d65 p\u2083) +\u1d65 p\u2083) = p\u2081 -\u1d65 p\u2082"}, {"line": "rw [vsub_vadd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vadd_vsub_vadd_cancel_right (v\u2081 v\u2082 : G) (p : P) : (v\u2081 +\u1d65 p) -\u1d65 (v\u2082 +\u1d65 p) = v\u2081 - v\u2082 := by\n  rw [vsub_vadd_eq_vsub_sub]\n  rw [vadd_vsub_assoc]\n  rw [vsub_self]\n  rw [add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Defs.lean", "context": {"open": [], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\nv\u2081 v\u2082 : G\np : P\n\u22a2 (v\u2081 +\u1d65 p) -\u1d65 (v\u2082 +\u1d65 p) = v\u2081 - v\u2082"}, {"line": "rw [vsub_vadd_eq_vsub_sub]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\nv\u2081 v\u2082 : G\np : P\n\u22a2 (v\u2081 +\u1d65 p) -\u1d65 p - v\u2082 = v\u2081 - v\u2082"}, {"line": "rw [vadd_vsub_assoc]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\nv\u2081 v\u2082 : G\np : P\n\u22a2 v\u2081 + (p -\u1d65 p) - v\u2082 = v\u2081 - v\u2082"}, {"line": "rw [vsub_self]", "tactic_state": "G : Type u_1\nP : Type u_2\ninst\u271d : AddGroup G\nT : AddTorsor G P\nv\u2081 v\u2082 : G\np : P\n\u22a2 v\u2081 + 0 - v\u2082 = v\u2081 - v\u2082"}, {"line": "rw [add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pointReflection_vsub_right (x y : P) : pointReflection x y -\u1d65 y = 2 \u2022 (x -\u1d65 y) := by\n  simp [pointReflection, two_nsmul, vadd_vsub_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/AddTorsor/Defs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*} {P : Type*} [AddGroup G] [T : AddTorsor G P]", "{G : Type*} {P : Type*} [AddGroup G] [AddTorsor G P]", "(P)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : AddTorsor G P\nx\u271d : Sort u_5\npointReflection : x\u271d\nx y : P\n\u22a2 sorry -\u1d65 y = 2 \u2022 (x -\u1d65 y)"}, {"line": "simp [pointReflection, two_nsmul, vadd_vsub_assoc]", "tactic_state": "G : Type u_3\nP : Type u_4\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : AddTorsor G P\nx\u271d : Sort u_5\npointReflection : x\u271d\nx y : P\n\u22a2 sorry () -\u1d65 y = x -\u1d65 y + (x -\u1d65 y)"}]}
{"declaration": "theorem _root_.Algebra.lmul_isUnit_iff {x : A} :\n    IsUnit (Algebra.lmul R A x) \u2194 IsUnit x := by\n  rw [Module.End.isUnit_iff]\n  rw [Iff.comm]\n  exact IsUnit.isUnit_iff_mulLeft_bijective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Bilinear.lean", "context": {"open": ["TensorProduct Module"], "variables": ["(R A : Type*)", "[Semiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{A} [SMulCommClass R A A]", "(A) in", "{A} [IsScalarTower R A A]", "(A) in", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SMulCommClass R A A] [IsScalarTower R A A]", "{A}", "{R}", "(R A B : Type*)", "[Semiring R] [NonUnitalSemiring A] [NonUnitalSemiring B] [Module R B] [Module R A]", "[CommSemiring R] [NonUnitalSemiring A] [NonUnitalSemiring B] [Module R B] [Module R A]", "[SMulCommClass R A A] [IsScalarTower R A A]", "[SMulCommClass R B B] [IsScalarTower R B B]", "{R A B}", "(R A : Type*)", "[Semiring R] [Semiring A]", "[Module R A] [SMulCommClass R A A]", "[Module R A] [IsScalarTower R A A]", "[CommSemiring R] [Semiring A] [Algebra R A]", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Module R A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 IsUnit ((Algebra.lmul R A) x) \u2194 IsUnit x"}, {"line": "rw [Module.End.isUnit_iff]", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Module R A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 Function.Bijective \u21d1((Algebra.lmul R A) x) \u2194 IsUnit x"}, {"line": "rw [Iff.comm]", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Module R A\ninst\u271d\u2075 : SMulCommClass R A A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 IsUnit x \u2194 Function.Bijective \u21d1((Algebra.lmul R A) x)"}, {"line": "exact IsUnit.isUnit_iff_mulLeft_bijective", "tactic_state": "No Goals!"}]}
{"declaration": "lemma starMap_inl (\u03c6 : A \u2192\u22c6\u2099\u2090[R] B) (r : R) :\n    starMap \u03c6 (inl r) = algebraMap R (Unitization R B) r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Unitization.lean", "context": {"open": [], "variables": ["{R A : Type*}", "(A)", "(R)", "{T : Type*} {S : Type*} {R : Type*} {A : Type*}", "(R A) in", "(A)", "(R)", "(R A)", "{R A : Type*}", "(A)", "(R)", "(R A)", "{R A : Type*}", "(S R A : Type*) [CommSemiring S] [CommSemiring R] [NonUnitalSemiring A] [Module R A]", "{S R A : Type*} [CommSemiring S] [CommSemiring R] [NonUnitalSemiring A] [Module R A]", "{R A C : Type*} [CommSemiring R] [StarRing R] [NonUnitalSemiring A] [StarRing A]", "[Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[Semiring C] [Algebra R C] [StarRing C]", "[StarModule R C]", "{R A B C : Type*} [CommSemiring R] [StarRing R]", "[NonUnitalSemiring A] [StarRing A] [Module R A] [SMulCommClass R A A] [IsScalarTower R A A]", "[NonUnitalSemiring B] [StarRing B] [Module R B] [SMulCommClass R B B] [IsScalarTower R B B]", "[NonUnitalSemiring C] [StarRing C] [Module R C] [SMulCommClass R C C] [IsScalarTower R C C]", "[StarModule R B] [StarModule R C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_20\nA : Type u_21\nB : Type u_22\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : StarRing R\ninst\u271d\u00b9\u2070 : NonUnitalSemiring A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : SMulCommClass R A A\ninst\u271d\u2076 : IsScalarTower R A A\ninst\u271d\u2075 : NonUnitalSemiring B\ninst\u271d\u2074 : StarRing B\ninst\u271d\u00b3 : Module R B\ninst\u271d\u00b2 : SMulCommClass R B B\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : StarModule R B\nx\u271d : Sort u_24\nstarMap : x\u271d\n\u03c6 : A \u2192\u22c6\u2099\u2090[R] B\nr : R\n\u22a2 sorry = (algebraMap R (Unitization R B)) r"}, {"line": "simp", "tactic_state": "R : Type u_20\nA : Type u_21\nB : Type u_22\ninst\u271d\u00b9\u00b2 : CommSemiring R\ninst\u271d\u00b9\u00b9 : StarRing R\ninst\u271d\u00b9\u2070 : NonUnitalSemiring A\ninst\u271d\u2079 : StarRing A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : SMulCommClass R A A\ninst\u271d\u2076 : IsScalarTower R A A\ninst\u271d\u2075 : NonUnitalSemiring B\ninst\u271d\u2074 : StarRing B\ninst\u271d\u00b3 : Module R B\ninst\u271d\u00b2 : SMulCommClass R B B\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : StarModule R B\nx\u271d : Sort u_24\nstarMap : x\u271d\n\u03c6 : A \u2192\u22c6\u2099\u2090[R] B\nr : R\n\u22a2 sorry () = (algebraMap R (Unitization R B)) r"}]}
{"declaration": "theorem algebra_ext {R : Type*} [CommSemiring R] {A : Type*} [Semiring A] (P Q : Algebra R A)\n    (h : \u2200 r : R, (haveI := P; algebraMap R A r) = haveI := Q; algebraMap R A r) :\n    P = Q := by\n  replace h : P.algebraMap = Q.algebraMap := DFunLike.ext _ _ h\n  have h' : (haveI := P; (\u00b7 \u2022 \u00b7) : R \u2192 A \u2192 A) = (haveI := Q; (\u00b7 \u2022 \u00b7) : R \u2192 A \u2192 A) := by\n    funext r a\n    rw [P.smul_def']\n    rw [Q.smul_def']\n    rw [h]\n  rcases P with @\u27e8\u27e8P\u27e9\u27e9\n  rcases Q with @\u27e8\u27e8Q\u27e9\u27e9\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Defs.lean", "context": {"open": [], "variables": ["{R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A]", "{R A : Type*} [CommRing R] [Ring A] [Algebra R A]", "{R : Type u} {S : Type v} {A : Type w} {B : Type*}", "[CommSemiring R] [CommSemiring S]", "[Semiring A] [Algebra R A] [Semiring B] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_7\ninst\u271d : Semiring A\nP Q : Algebra R A\nh : \u2200 (r : R), (algebraMap R A) r = (algebraMap R A) r\n\u22a2 P = Q"}, {"line": "replace h : P.algebraMap = Q.algebraMap := DFunLike.ext _ _ h", "tactic_state": "R : Type u_6\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_7\ninst\u271d : Semiring A\nP Q : Algebra R A\nh : Algebra.algebraMap = Algebra.algebraMap\n\u22a2 P = Q"}, {"line": "have h' : (haveI := P; (\u00b7 \u2022 \u00b7) : R \u2192 A \u2192 A) = (haveI := Q; (\u00b7 \u2022 \u00b7) : R \u2192 A \u2192 A) := by\n    funext r a\n    rw [P.smul_def']\n    rw [Q.smul_def']\n    rw [h]", "tactic_state": "R : Type u_6\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_7\ninst\u271d : Semiring A\nP Q : Algebra R A\nh : Algebra.algebraMap = Algebra.algebraMap\nh' : (fun x1 x2 => x1 \u2022 x2) = fun x1 x2 => x1 \u2022 x2\n\u22a2 P = Q"}, {"line": "rcases P with @\u27e8\u27e8P\u27e9\u27e9", "tactic_state": "case mk.mk\nR : Type u_6\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_7\ninst\u271d : Semiring A\nQ : Algebra R A\nalgebraMap\u271d : R \u2192+* A\ncommutes'\u271d : \u2200 (r : R) (x : A), algebraMap\u271d r * x = x * algebraMap\u271d r\nP : R \u2192 A \u2192 A\nsmul_def'\u271d : \u2200 (r : R) (x : A), r \u2022 x = algebraMap\u271d r * x\nh : Algebra.algebraMap = Algebra.algebraMap\nh' : (fun x1 x2 => x1 \u2022 x2) = fun x1 x2 => x1 \u2022 x2\n\u22a2 { smul := P, algebraMap := algebraMap\u271d, commutes' := commutes'\u271d, smul_def' := smul_def'\u271d } = Q"}, {"line": "rcases Q with @\u27e8\u27e8Q\u27e9\u27e9", "tactic_state": "case mk.mk.mk.mk\nR : Type u_6\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_7\ninst\u271d : Semiring A\nalgebraMap\u271d\u00b9 : R \u2192+* A\ncommutes'\u271d\u00b9 : \u2200 (r : R) (x : A), algebraMap\u271d\u00b9 r * x = x * algebraMap\u271d\u00b9 r\nP : R \u2192 A \u2192 A\nsmul_def'\u271d\u00b9 : \u2200 (r : R) (x : A), r \u2022 x = algebraMap\u271d\u00b9 r * x\nalgebraMap\u271d : R \u2192+* A\ncommutes'\u271d : \u2200 (r : R) (x : A), algebraMap\u271d r * x = x * algebraMap\u271d r\nQ : R \u2192 A \u2192 A\nsmul_def'\u271d : \u2200 (r : R) (x : A), r \u2022 x = algebraMap\u271d r * x\nh : Algebra.algebraMap = Algebra.algebraMap\nh' : (fun x1 x2 => x1 \u2022 x2) = fun x1 x2 => x1 \u2022 x2\n\u22a2 { smul := P, algebraMap := algebraMap\u271d\u00b9, commutes' := commutes'\u271d\u00b9, smul_def' := smul_def'\u271d\u00b9 } =\n    { smul := Q, algebraMap := algebraMap\u271d, commutes' := commutes'\u271d, smul_def' := smul_def'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma span_eq_toSubmodule (s : NonUnitalSubalgebra R A) :\n    Submodule.span R (s : Set A) = s.toSubmodule := by\n  simp [SetLike.ext'_iff, Submodule.coe_span_eq_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": [], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring A\ninst\u271d : Module R A\ns : NonUnitalSubalgebra R A\n\u22a2 Submodule.span R \u2191s = s.toSubmodule"}, {"line": "simp [SetLike.ext'_iff, Submodule.coe_span_eq_self]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.NonUnitalAlgHom.map_adjoin_singleton [IsScalarTower R B B] [SMulCommClass R B B]\n    (f : F) (x : A) : map f (adjoin R {x}) = adjoin R {f x} := by\n  simp [NonUnitalAlgHom.map_adjoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": ["Submodule in", "NonUnitalSubalgebra in", "NonUnitalSubalgebra in"], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[NonUnitalNonAssocSemiring B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "(R A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : NonUnitalNonAssocSemiring B\ninst\u271d\u2076 : Module R B\ninst\u271d\u2075 : FunLike F A B\ninst\u271d\u2074 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : SMulCommClass R A A\nx\u271d\u00b9 : Sort u_4\nmap : x\u271d\u00b9\nx\u271d : Sort u_5\nadjoin : x\u271d\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : SMulCommClass R B B\nf : F\nx : A\n\u22a2 sorry = sorry"}, {"line": "simp [NonUnitalAlgHom.map_adjoin]", "tactic_state": "F : Type u_3\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u00b9\u2070 : CommSemiring R\ninst\u271d\u2079 : NonUnitalNonAssocSemiring A\ninst\u271d\u2078 : Module R A\ninst\u271d\u2077 : NonUnitalNonAssocSemiring B\ninst\u271d\u2076 : Module R B\ninst\u271d\u2075 : FunLike F A B\ninst\u271d\u2074 : NonUnitalAlgHomClass F R A B\ninst\u271d\u00b3 : IsScalarTower R A A\ninst\u271d\u00b2 : SMulCommClass R A A\nx\u271d\u00b9 : Sort u_4\nmap : x\u271d\u00b9\nx\u271d : Sort u_5\nadjoin : x\u271d\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : SMulCommClass R B B\nf : F\nx : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubalgebra R A} :\n    (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i := by simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": ["Submodule in", "NonUnitalSubalgebra in", "NonUnitalSubalgebra in"], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[NonUnitalNonAssocSemiring B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\n\u03b9 : Sort u_4\nS : \u03b9 \u2192 NonUnitalSubalgebra R A\n\u22a2 \u2191(\u2a05 i, S i) = \u22c2 i, \u2191(S i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 NonUnitalSubalgebra R A} {x : A} :\n    (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i := by simp only [iInf, mem_sInf, Set.forall_mem_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": ["Submodule in", "NonUnitalSubalgebra in", "NonUnitalSubalgebra in"], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[NonUnitalNonAssocSemiring B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\n\u03b9 : Sort u_4\nS : \u03b9 \u2192 NonUnitalSubalgebra R A\nx : A\n\u22a2 x \u2208 \u2a05 i, S i \u2194 \u2200 (i : \u03b9), x \u2208 S i"}, {"line": "simp only [iInf, mem_sInf, Set.forall_mem_range]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\n\u03b9 : Sort u_4\nS : \u03b9 \u2192 NonUnitalSubalgebra R A\nx : A\n\u22a2 x \u2208 sInf (Set.range fun i => S i) \u2194 \u2200 (i : \u03b9), x \u2208 S i"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9]\n    [IsScalarTower R B B] [SMulCommClass R B B] (f : F)\n    (hf : Function.Injective f) (S : \u03b9 \u2192 NonUnitalSubalgebra R A) :\n    ((\u2a05 i, S i).map f : NonUnitalSubalgebra R B) = \u2a05 i, (S i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 S)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": ["Submodule in", "NonUnitalSubalgebra in", "NonUnitalSubalgebra in"], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[NonUnitalNonAssocSemiring B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u2079 : Module R A\ninst\u271d\u2078 : NonUnitalNonAssocSemiring B\ninst\u271d\u2077 : Module R B\ninst\u271d\u2076 : FunLike F A B\ninst\u271d\u2075 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2074 : IsScalarTower R A A\ninst\u271d\u00b3 : SMulCommClass R A A\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : Nonempty \u03b9\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : SMulCommClass R B B\nf : F\nhf : Function.Injective \u21d1f\nS : \u03b9 \u2192 NonUnitalSubalgebra R A\n\u22a2 NonUnitalSubalgebra.map f (\u2a05 i, S i) = \u2a05 i, NonUnitalSubalgebra.map f (S i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nF : Type u_3\nR : Type u\nA : Type v\nB : Type w\ninst\u271d\u00b9\u00b9 : CommSemiring R\ninst\u271d\u00b9\u2070 : NonUnitalNonAssocSemiring A\ninst\u271d\u2079 : Module R A\ninst\u271d\u2078 : NonUnitalNonAssocSemiring B\ninst\u271d\u2077 : Module R B\ninst\u271d\u2076 : FunLike F A B\ninst\u271d\u2075 : NonUnitalAlgHomClass F R A B\ninst\u271d\u2074 : IsScalarTower R A A\ninst\u271d\u00b3 : SMulCommClass R A A\n\u03b9 : Sort u_4\ninst\u271d\u00b2 : Nonempty \u03b9\ninst\u271d\u00b9 : IsScalarTower R B B\ninst\u271d : SMulCommClass R B B\nf : F\nhf : Function.Injective \u21d1f\nS : \u03b9 \u2192 NonUnitalSubalgebra R A\n\u22a2 \u2191(NonUnitalSubalgebra.map f (\u2a05 i, S i)) = \u2191(\u2a05 i, NonUnitalSubalgebra.map f (S i))"}, {"line": "simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe \u2218 S)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_bot : ((\u22a5 : NonUnitalSubalgebra R A) : Set A) = {0} := by\n  simp [Set.ext_iff, NonUnitalAlgebra.mem_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/NonUnitalSubalgebra.lean", "context": {"open": ["Submodule in", "NonUnitalSubalgebra in", "NonUnitalSubalgebra in"], "variables": ["{S R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[SetLike S A] [NonUnitalSubsemiringClass S A] [hSR : SMulMemClass S R A] (s : S)", "{s} in", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "[CommRing R]", "[NonUnitalNonAssocRing A] [NonUnitalNonAssocRing B] [NonUnitalNonAssocRing C]", "[Module R A] [Module R B] [Module R C]", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B] [NonUnitalNonAssocSemiring C]", "[Module R A] [Module R B] [Module R C]", "{S : NonUnitalSubalgebra R A}", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{R A : Type*} [CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "{F : Type v'} {R' : Type u'} {R : Type u} {A : Type v} {B : Type w} {C : Type w'}", "[CommSemiring R]", "[NonUnitalNonAssocSemiring A] [Module R A] [NonUnitalNonAssocSemiring B] [Module R B]", "[NonUnitalNonAssocSemiring C] [Module R C] [FunLike F A B] [NonUnitalAlgHomClass F R A B]", "{F : Type*} (R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [NonUnitalNonAssocSemiring A] [Module R A]", "[NonUnitalNonAssocSemiring B] [Module R B]", "[FunLike F A B] [NonUnitalAlgHomClass F R A B]", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : Module R A\ninst\u271d\u00b9 : IsScalarTower R A A\ninst\u271d : SMulCommClass R A A\n\u22a2 \u2191\u22a5 = {0}"}, {"line": "simp [Set.ext_iff, NonUnitalAlgebra.mem_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le {P : Submodule R A} : (1 : Submodule R A) \u2264 P \u2194 (1 : A) \u2208 P := by\n  simp [one_eq_span]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Module R A\nP : Submodule R A\n\u22a2 1 \u2264 P \u2194 1 \u2208 P"}, {"line": "simp [one_eq_span]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraMap_mem (r : R) : algebraMap R A r \u2208 (1 : Submodule R A) := by\n  simp [one_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]", "{M : Type*} [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]", "{I J : Submodule R A} {N P : Submodule R M}", "(I J N P)", "[IsScalarTower R A A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(M)", "{M}", "(M N P)", "{\u03b9 : Sort u\u03b9}", "{\u03b9 : Sort u\u03b9}", "{R : Type u} [CommSemiring R]", "{A : Type v} [Semiring A] [Algebra R A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nr : R\n\u22a2 (algebraMap R A) r \u2208 1"}, {"line": "simp [one_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_one {x : A} : x \u2208 (1 : Submodule R A) \u2194 \u2203 y, algebraMap R A y = x := by\n  simp [one_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]", "{M : Type*} [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]", "{I J : Submodule R A} {N P : Submodule R M}", "(I J N P)", "[IsScalarTower R A A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(M)", "{M}", "(M N P)", "{\u03b9 : Sort u\u03b9}", "{\u03b9 : Sort u\u03b9}", "{R : Type u} [CommSemiring R]", "{A : Type v} [Semiring A] [Algebra R A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nx : A\n\u22a2 x \u2208 1 \u2194 \u2203 y, (algebraMap R A) y = x"}, {"line": "simp [one_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_def : M * N = span R (M * N : Set A) := by simp [\u2190 span_mul_span]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]", "{M : Type*} [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]", "{I J : Submodule R A} {N P : Submodule R M}", "(I J N P)", "[IsScalarTower R A A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(M)", "{M}", "(M N P)", "{\u03b9 : Sort u\u03b9}", "{\u03b9 : Sort u\u03b9}", "{R : Type u} [CommSemiring R]", "{A : Type v} [Semiring A] [Algebra R A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(R M N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nM N : Submodule R A\nx\u271d : Sort u_2\nspan : x\u271d\n\u22a2 M * N = sorry"}, {"line": "simp [\u2190 span_mul_span]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nM N : Submodule R A\nx\u271d : Sort u_2\nspan : x\u271d\n\u22a2 M * N = sorry ()"}]}
{"declaration": "lemma mem_smul_iff_inv_mul_mem {S} [DivisionSemiring S] [Algebra R S] {x : S} {p : Submodule R S}\n    {y : S} (hx : x \u2260 0) : y \u2208 x \u2022 p \u2194 x\u207b\u00b9 * y \u2208 p := by\n  constructor\n  \u00b7 rintro \u27e8a, ha : a \u2208 p, rfl\u27e9; simpa [inv_mul_cancel_left\u2080 hx]\n  \u00b7 exact fun h \u21a6 \u27e8_, h, by simp [mul_inv_cancel_left\u2080 hx]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]", "{M : Type*} [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]", "{I J : Submodule R A} {N P : Submodule R M}", "(I J N P)", "[IsScalarTower R A A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(M)", "{M}", "(M N P)", "{\u03b9 : Sort u\u03b9}", "{\u03b9 : Sort u\u03b9}", "{R : Type u} [CommSemiring R]", "{A : Type v} [Semiring A] [Algebra R A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(R M N)", "{R} (P Q)", "{\u03b1 : Type*} [Monoid \u03b1] [DistribMulAction \u03b1 A] [SMulCommClass \u03b1 R A]", "{M N P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_3\ninst\u271d\u00b9 : DivisionSemiring S\ninst\u271d : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : x \u2260 0\n\u22a2 y \u2208 x \u2022 p \u2194 x\u207b\u00b9 * y \u2208 p"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_3\ninst\u271d\u00b9 : DivisionSemiring S\ninst\u271d : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : x \u2260 0\n\u22a2 y \u2208 x \u2022 p \u2192 x\u207b\u00b9 * y \u2208 p\n---\ncase mpr\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_3\ninst\u271d\u00b9 : DivisionSemiring S\ninst\u271d : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : x \u2260 0\n\u22a2 x\u207b\u00b9 * y \u2208 p \u2192 y \u2208 x \u2022 p"}, {"line": "\u00b7 rintro \u27e8a, ha : a \u2208 p, rfl\u27e9; simpa [inv_mul_cancel_left\u2080 hx]", "tactic_state": "case mpr\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Type u_3\ninst\u271d\u00b9 : DivisionSemiring S\ninst\u271d : Algebra R S\nx : S\np : Submodule R S\ny : S\nhx : x \u2260 0\n\u22a2 x\u207b\u00b9 * y \u2208 p \u2192 y \u2208 x \u2022 p"}, {"line": "\u00b7 exact fun h \u21a6 \u27e8_, h, by simp [mul_inv_cancel_left\u2080 hx]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_span {\u03b9 : Type*} (s : Finset \u03b9) (M : \u03b9 \u2192 Set A) :\n    (\u220f i \u2208 s, Submodule.span R (M i)) = Submodule.span R (\u220f i \u2208 s, M i) := by\n  letI := Classical.decEq \u03b9\n  refine Finset.induction_on s ?_ ?_\n  \u00b7 simp [one_eq_span, Set.singleton_one]\n  \u00b7 intro _ _ H ih\n    rw [Finset.prod_insert H]\n    rw [Finset.prod_insert H]\n    rw [ih]\n    rw [span_mul_span]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Operations.lean", "context": {"open": ["Algebra Set MulOpposite", "Pointwise", "Pointwise"], "variables": ["{R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]", "{R : Type u} [Semiring R] {A : Type v} [Semiring A] [Module R A]", "{M : Type*} [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M]", "{I J : Submodule R A} {N P : Submodule R M}", "(I J N P)", "[IsScalarTower R A A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(M)", "{M}", "(M N P)", "{\u03b9 : Sort u\u03b9}", "{\u03b9 : Sort u\u03b9}", "{R : Type u} [CommSemiring R]", "{A : Type v} [Semiring A] [Algebra R A]", "(S T : Set A) {M N P Q : Submodule R A} {m n : A}", "(R M N)", "{R} (P Q)", "{\u03b1 : Type*} [Monoid \u03b1] [DistribMulAction \u03b1 A] [SMulCommClass \u03b1 R A]", "{M N P}", "(M N) in", "(M)", "{\u03b1 : Type*} [Monoid \u03b1] [MulSemiringAction \u03b1 A] [SMulCommClass \u03b1 R A]", "{A : Type v} [CommSemiring A] [Algebra R A]", "{M N : Submodule R A} {m n : A}", "(M N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u03b9 : Type u_4\ns : Finset \u03b9\nM : \u03b9 \u2192 Set A\n\u22a2 \u220f i \u2208 s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 s, M i)"}, {"line": "letI := Classical.decEq \u03b9", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u03b9 : Type u_4\ns : Finset \u03b9\nM : \u03b9 \u2192 Set A\nthis : DecidableEq \u03b9 := Classical.decEq \u03b9\n\u22a2 \u220f i \u2208 s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 s, M i)"}, {"line": "refine Finset.induction_on s ?_ ?_", "tactic_state": "case refine_1\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u03b9 : Type u_4\ns : Finset \u03b9\nM : \u03b9 \u2192 Set A\nthis : DecidableEq \u03b9 := Classical.decEq \u03b9\n\u22a2 \u220f i \u2208 \u2205, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 \u2205, M i)\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u03b9 : Type u_4\ns : Finset \u03b9\nM : \u03b9 \u2192 Set A\nthis : DecidableEq \u03b9 := Classical.decEq \u03b9\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    a \u2209 s \u2192\n      \u220f i \u2208 s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 s, M i) \u2192\n        \u220f i \u2208 insert a s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 insert a s, M i)"}, {"line": "\u00b7 simp [one_eq_span, Set.singleton_one]", "tactic_state": "case refine_2\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nA : Type v\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u03b9 : Type u_4\ns : Finset \u03b9\nM : \u03b9 \u2192 Set A\nthis : DecidableEq \u03b9 := Classical.decEq \u03b9\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    a \u2209 s \u2192\n      \u220f i \u2208 s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 s, M i) \u2192\n        \u220f i \u2208 insert a s, Submodule.span R (M i) = Submodule.span R (\u220f i \u2208 insert a s, M i)"}, {"line": "\u00b7 intro _ _ H ih\n    rw [Finset.prod_insert H]\n    rw [Finset.prod_insert H]\n    rw [ih]\n    rw [span_mul_span]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem units_smul_resolvent_self {r : R\u02e3} {a : A} :\n    r \u2022 resolvent a (r : R) = resolvent (r\u207b\u00b9 \u2022 a) (1 : R) := by\n  simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using\n    @units_smul_resolvent _ _ _ _ _ r r a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : R\u02e3\na : A\n\u22a2 r \u2022 resolvent a \u2191r = resolvent (r\u207b\u00b9 \u2022 a) 1"}, {"line": "simpa only [Units.smul_def, Algebra.id.smul_eq_mul, Units.inv_mul] using\n    @units_smul_resolvent _ _ _ _ _ r r a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mem_resolventSet_of_unit (a : A\u02e3) : 0 \u2208 resolventSet R (a : A) := by\n  simpa only [mem_resolventSet_iff, \u2190 not_mem_iff, zero_not_mem_iff] using a.isUnit\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\u02e3\n\u22a2 0 \u2208 resolventSet R \u2191a"}, {"line": "simpa only [mem_resolventSet_iff, \u2190 not_mem_iff, zero_not_mem_iff] using a.isUnit", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star_mem_resolventSet_iff {r : R} {a : A} :\n    star r \u2208 resolventSet R a \u2194 r \u2208 resolventSet R (star a) := by\n  refine \u27e8fun h => ?_, fun h => ?_\u27e9 <;>\n    simpa only [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul,\n      star_star, star_one] using IsUnit.star h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}", "[InvolutiveStar R] [StarRing A] [StarModule R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : InvolutiveStar R\ninst\u271d\u00b9 : StarRing A\ninst\u271d : StarModule R A\nr : R\na : A\n\u22a2 star r \u2208 resolventSet R a \u2194 r \u2208 resolventSet R (star a)"}, {"line": "refine \u27e8fun h => ?_, fun h => ?_\u27e9 <;>\n    simpa only [mem_resolventSet_iff, Algebra.algebraMap_eq_smul_one, star_sub, star_smul,\n      star_star, star_one] using IsUnit.star h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv\u2080_mem_iff {r : R} {a : A\u02e3} :\n    r\u207b\u00b9 \u2208 spectrum R (a : A) \u2194 r \u2208 spectrum R (\u2191a\u207b\u00b9 : A) := by\n  obtain (rfl | hr) := eq_or_ne r 0\n  \u00b7 simp [zero_mem_iff]\n  \u00b7 lift r to R\u02e3 using hr.isUnit\n    simp [inv_mem_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}", "[InvolutiveStar R] [StarRing A] [StarModule R A]", "{R : Type u} {A : Type v}", "[CommRing R] [Ring A] [Algebra R A]", "{R : Type u} {A : Type v} [Semifield R] [Ring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : R\na : A\u02e3\n\u22a2 r\u207b\u00b9 \u2208 spectrum R \u2191a \u2194 r \u2208 spectrum R \u2191a\u207b\u00b9"}, {"line": "obtain (rfl | hr) := eq_or_ne r 0", "tactic_state": "case inl\nR : Type u\nA : Type v\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\u02e3\n\u22a2 sorry\u207b\u00b9 \u2208 spectrum R \u2191a \u2194 sorry \u2208 spectrum R \u2191a\u207b\u00b9\n---\ncase inr\nR : Type u\nA : Type v\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : R\na : A\u02e3\nhr : r \u2260 sorry\n\u22a2 r\u207b\u00b9 \u2208 spectrum R \u2191a \u2194 r \u2208 spectrum R \u2191a\u207b\u00b9"}, {"line": "\u00b7 simp [zero_mem_iff]", "tactic_state": "case inr\nR : Type u\nA : Type v\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : R\na : A\u02e3\nhr : r \u2260 sorry\n\u22a2 r\u207b\u00b9 \u2208 spectrum R \u2191a \u2194 r \u2208 spectrum R \u2191a\u207b\u00b9"}, {"line": "\u00b7 lift r to R\u02e3 using hr.isUnit\n    simp [inv_mem_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv\u2080_mem_inv_iff {r : R} {a : A\u02e3} :\n    r\u207b\u00b9 \u2208 spectrum R (\u2191a\u207b\u00b9 : A) \u2194 r \u2208 spectrum R (a : A) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}", "[InvolutiveStar R] [StarRing A] [StarModule R A]", "{R : Type u} {A : Type v}", "[CommRing R] [Ring A] [Algebra R A]", "{R : Type u} {A : Type v} [Semifield R] [Ring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\nr : R\na : A\u02e3\n\u22a2 r\u207b\u00b9 \u2208 spectrum R \u2191a\u207b\u00b9 \u2194 r \u2208 spectrum R \u2191a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_resolventSet_apply (\u03c6 : F) {a : A} {r : R} (h : r \u2208 resolventSet R a) :\n    r \u2208 resolventSet R ((\u03c6 : A \u2192 B) a) := by\n  simpa only [map_sub, AlgHomClass.commutes] using h.map \u03c6\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}", "[InvolutiveStar R] [StarRing A] [StarModule R A]", "{R : Type u} {A : Type v}", "[CommRing R] [Ring A] [Algebra R A]", "{R : Type u} {A : Type v} [Semifield R] [Ring A] [Algebra R A]", "{\ud835\udd5c : Type u} {A : Type v}", "[Field \ud835\udd5c] [Ring A] [Algebra \ud835\udd5c A]", "{F R A B : Type*} [CommSemiring R] [Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[FunLike F A B] [AlgHomClass F R A B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nR : Type u_2\nA : Type u_3\nB : Type u_4\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : Ring A\ninst\u271d\u2074 : Algebra R A\ninst\u271d\u00b3 : Ring B\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : FunLike F A B\ninst\u271d : AlgHomClass F R A B\n\u03c6 : F\na : A\nr : R\nh : r \u2208 resolventSet R a\n\u22a2 r \u2208 resolventSet R (\u03c6 a)"}, {"line": "simpa only [map_sub, AlgHomClass.commutes] using h.map \u03c6", "tactic_state": "No Goals!"}]}
{"declaration": "lemma spectrum.units_conjugate' {a : A} {u : A\u02e3} :\n    spectrum R (u\u207b\u00b9 * a * u) = spectrum R a := by\n  simpa using spectrum.units_conjugate (u := u\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Basic.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["(R : Type u) {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "{R}", "{R : Type u} {A : Type v}", "[CommSemiring R] [Ring A] [Algebra R A]", "(R)", "{R}", "[InvolutiveStar R] [StarRing A] [StarModule R A]", "{R : Type u} {A : Type v}", "[CommRing R] [Ring A] [Algebra R A]", "{R : Type u} {A : Type v} [Semifield R] [Ring A] [Algebra R A]", "{\ud835\udd5c : Type u} {A : Type v}", "[Field \ud835\udd5c] [Ring A] [Algebra \ud835\udd5c A]", "{F R A B : Type*} [CommSemiring R] [Ring A] [Algebra R A] [Ring B] [Algebra R B]", "[FunLike F A B] [AlgHomClass F R A B]", "{F R A : Type*} [CommRing R] [Ring A] [Algebra R A]", "[FunLike F A R] [AlgHomClass F R A R]", "{R A : Type*} [CommSemiring R] [Ring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\nA : Type u_9\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nu : A\u02e3\n\u22a2 spectrum R (\u2191u\u207b\u00b9 * a * \u2191u) = spectrum R a"}, {"line": "simpa using spectrum.units_conjugate (u := u\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.spectrum_eq [CommSemiring R] [\u2200 i, Ring (\u03ba i)] [\u2200 i, Algebra R (\u03ba i)]\n    (a : \u2200 i, \u03ba i) : spectrum R a = \u22c3 i, spectrum R (a i) := by\n  apply compl_injective\n  simp_rw [spectrum, Set.compl_iUnion, compl_compl, resolventSet, Set.iInter_setOf,\n    Pi.isUnit_iff, sub_apply, algebraMap_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Pi.lean", "context": {"open": [], "variables": ["{\u03b9 A B R : Type*} {\u03ba : \u03b9 \u2192 Type*}", "(\u03ba) in", "(A B) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_4\n\u03ba : \u03b9 \u2192 Type u_5\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Ring (\u03ba i)\ninst\u271d : (i : \u03b9) \u2192 Algebra R (\u03ba i)\na : (i : \u03b9) \u2192 \u03ba i\n\u22a2 spectrum R a = \u22c3 i, spectrum R (a i)"}, {"line": "apply compl_injective", "tactic_state": "case a\n\u03b9 : Type u_1\nR : Type u_4\n\u03ba : \u03b9 \u2192 Type u_5\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Ring (\u03ba i)\ninst\u271d : (i : \u03b9) \u2192 Algebra R (\u03ba i)\na : (i : \u03b9) \u2192 \u03ba i\n\u22a2 (spectrum R a)\u1d9c = (\u22c3 i, spectrum R (a i))\u1d9c"}, {"line": "simp_rw [spectrum, Set.compl_iUnion, compl_compl, resolventSet, Set.iInter_setOf,\n    Pi.isUnit_iff, sub_apply, algebraMap_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Prod.spectrum_eq [CommSemiring R] [Ring A] [Ring B] [Algebra R A] [Algebra R B]\n    (a : A) (b : B) : spectrum R (\u27e8a, b\u27e9 : A \u00d7 B) = spectrum R a \u222a spectrum R b := by\n  apply compl_injective\n  simp_rw [spectrum, Set.compl_union, compl_compl, resolventSet, \u2190 Set.setOf_and,\n    Prod.isUnit_iff, algebraMap_apply, mk_sub_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Pi.lean", "context": {"open": [], "variables": ["{\u03b9 A B R : Type*} {\u03ba : \u03b9 \u2192 Type*}", "(\u03ba) in", "(A B) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\na : A\nb : B\n\u22a2 spectrum R (a, b) = spectrum R a \u222a spectrum R b"}, {"line": "apply compl_injective", "tactic_state": "case a\nA : Type u_2\nB : Type u_3\nR : Type u_4\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra R B\na : A\nb : B\n\u22a2 (spectrum R (a, b))\u1d9c = (spectrum R a \u222a spectrum R b)\u1d9c"}, {"line": "simp_rw [spectrum, Set.compl_union, compl_compl, resolventSet, \u2190 Set.setOf_and,\n    Prod.isUnit_iff, algebraMap_apply, mk_sub_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_add_add_mul_eq_zero (u : (PreQuasiregular R)\u02e3) :\n    u\u207b\u00b9.val.val + u.val.val + u.val.val * u\u207b\u00b9.val.val = 0 := by\n  simpa [-Units.mul_inv] using congr($(u.mul_inv).val)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": [], "variables": ["{R : Type*} [NonUnitalSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalSemiring R\nu : (PreQuasiregular R)\u02e3\n\u22a2 (\u2191u\u207b\u00b9).val + (\u2191u).val + (\u2191u).val * (\u2191u\u207b\u00b9).val = 0"}, {"line": "simpa [-Units.mul_inv] using congr($(u.mul_inv).val)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_inv_add_mul_eq_zero (u : (PreQuasiregular R)\u02e3) :\n    u.val.val + u\u207b\u00b9.val.val + u\u207b\u00b9.val.val * u.val.val = 0 := by\n  simpa [-Units.inv_mul] using congr($(u.inv_mul).val)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": [], "variables": ["{R : Type*} [NonUnitalSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalSemiring R\nu : (PreQuasiregular R)\u02e3\n\u22a2 (\u2191u).val + (\u2191u\u207b\u00b9).val + (\u2191u\u207b\u00b9).val * (\u2191u).val = 0"}, {"line": "simpa [-Units.inv_mul] using congr($(u.inv_mul).val)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsQuasiregular.map {F R S : Type*} [NonUnitalSemiring R] [NonUnitalSemiring S]\n    [FunLike F R S] [NonUnitalRingHomClass F R S] (f : F) {x : R} (hx : IsQuasiregular x) :\n    IsQuasiregular (f x) := by\n  rw [isQuasiregular_iff] at hx \u22a2\n  obtain \u27e8y, hy\u2081, hy\u2082\u27e9 := hx\n  exact \u27e8f y, by simpa using And.intro congr(f $(hy\u2081)) congr(f $(hy\u2082))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : NonUnitalSemiring S\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : NonUnitalRingHomClass F R S\nf : F\nx : R\nhx : IsQuasiregular x\n\u22a2 IsQuasiregular (f x)"}, {"line": "rw [isQuasiregular_iff] at hx \u22a2", "tactic_state": "F : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : NonUnitalSemiring S\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : NonUnitalRingHomClass F R S\nf : F\nx : R\nhx : \u2203 y, y + x + x * y = 0 \u2227 x + y + y * x = 0\n\u22a2 \u2203 y, y + f x + f x * y = 0 \u2227 f x + y + y * f x = 0"}, {"line": "obtain \u27e8y, hy\u2081, hy\u2082\u27e9 := hx", "tactic_state": "case intro.intro\nF : Type u_4\nR : Type u_5\nS : Type u_6\ninst\u271d\u00b3 : NonUnitalSemiring R\ninst\u271d\u00b2 : NonUnitalSemiring S\ninst\u271d\u00b9 : FunLike F R S\ninst\u271d : NonUnitalRingHomClass F R S\nf : F\nx y : R\nhy\u2081 : y + x + x * y = 0\nhy\u2082 : x + y + y * x = 0\n\u22a2 \u2203 y, y + f x + f x * y = 0 \u2227 f x + y + y * f x = 0"}, {"line": "exact \u27e8f y, by simpa using And.intro congr(f $(hy\u2081)) congr(f $(hy\u2082))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quasispectrum_eq_spectrum_union_zero (R : Type*) {A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] (a : A) : quasispectrum R a = spectrum R a \u222a {0} := by\n  convert quasispectrum_eq_spectrum_union R a\n  ext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\n\u22a2 quasispectrum R a = spectrum R a \u222a {0}"}, {"line": "convert quasispectrum_eq_spectrum_union R a", "tactic_state": "case h.e'_3.h.e'_4\nR : Type u_6\nA : Type u_7\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\n\u22a2 {0} = {r | \u00acIsUnit r}"}, {"line": "ext x", "tactic_state": "case h.e'_3.h.e'_4.h\nR : Type u_6\nA : Type u_7\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nx : R\n\u22a2 x \u2208 {0} \u2194 x \u2208 {r | \u00acIsUnit r}"}, {"line": "simp", "tactic_state": "case h.e'_3.h.e'_4.h\nR : Type u_6\nA : Type u_7\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nx : R\n\u22a2 x = 0 \u2194 \u00acIsUnit x"}]}
{"declaration": "lemma mem_quasispectrum_iff {R A : Type*} [Semifield R] [Ring A]\n    [Algebra R A] {a : A} {x : R} :\n    x \u2208 quasispectrum R a \u2194 x = 0 \u2228 x \u2208 spectrum R a := by\n  simp [quasispectrum_eq_spectrum_union_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nA : Type u_7\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nx : R\n\u22a2 x \u2208 quasispectrum R a \u2194 x = 0 \u2228 x \u2208 spectrum R a"}, {"line": "simp [quasispectrum_eq_spectrum_union_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_mem_spectrum_inr (R S : Type*) {A : Type*} [CommSemiring R]\n    [CommRing S] [Nontrivial S] [NonUnitalRing A] [Algebra R S] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [Module R A] [IsScalarTower R S A] (a : A) :\n    0 \u2208 spectrum R (a : Unitization S A) := by\n  rw [spectrum.zero_mem_iff]\n  rintro \u27e8u, hu\u27e9\n  simpa [-Units.mul_inv, hu] using congr($(u.mul_inv).fst)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}", "[IsScalarTower R A A] [SMulCommClass R A A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Nontrivial S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : IsScalarTower S A A\ninst\u271d\u00b2 : SMulCommClass S A A\ninst\u271d\u00b9 : Module R A\ninst\u271d : IsScalarTower R S A\na : A\n\u22a2 0 \u2208 spectrum R \u2191a"}, {"line": "rw [spectrum.zero_mem_iff]", "tactic_state": "R : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Nontrivial S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : IsScalarTower S A A\ninst\u271d\u00b2 : SMulCommClass S A A\ninst\u271d\u00b9 : Module R A\ninst\u271d : IsScalarTower R S A\na : A\n\u22a2 \u00acIsUnit \u2191a"}, {"line": "rintro \u27e8u, hu\u27e9", "tactic_state": "case intro\nR : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : CommRing S\ninst\u271d\u2077 : Nontrivial S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : IsScalarTower S A A\ninst\u271d\u00b2 : SMulCommClass S A A\ninst\u271d\u00b9 : Module R A\ninst\u271d : IsScalarTower R S A\na : A\nu : (Unitization S A)\u02e3\nhu : \u2191u = \u2191a\n\u22a2 False"}, {"line": "simpa [-Units.mul_inv, hu] using congr($(u.mul_inv).fst)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraMap_image (h : QuasispectrumRestricts a f) :\n    algebraMap R S '' quasispectrum R a = quasispectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => \u27e8f s, ?_\u27e9\n  \u00b7 simpa only [quasispectrum.preimage_algebraMap] using\n      (quasispectrum S a).image_preimage_subset (algebraMap R S)\n  exact \u27e8quasispectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm \u25b8 hs), h.rightInvOn hs\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A] [Module R A] [Module S A]", "[Algebra R S] {a : A} {f : S \u2192 R}", "[IsScalarTower S A A] [SMulCommClass S A A]", "[IsScalarTower R S A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module R A\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : Algebra R S\na : A\nf : S \u2192 R\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\nh : QuasispectrumRestricts a f\n\u22a2 \u21d1(algebraMap R S) '' quasispectrum R a = quasispectrum S a"}, {"line": "refine Set.eq_of_subset_of_subset ?_ fun s hs => \u27e8f s, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module R A\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : Algebra R S\na : A\nf : S \u2192 R\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\nh : QuasispectrumRestricts a f\n\u22a2 \u21d1(algebraMap R S) '' quasispectrum R a \u2286 quasispectrum S a\n---\ncase refine_2\nR : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module R A\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : Algebra R S\na : A\nf : S \u2192 R\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\nh : QuasispectrumRestricts a f\ns : S\nhs : s \u2208 quasispectrum S a\n\u22a2 f s \u2208 quasispectrum R a \u2227 (algebraMap R S) (f s) = s"}, {"line": "\u00b7 simpa only [quasispectrum.preimage_algebraMap] using\n      (quasispectrum S a).image_preimage_subset (algebraMap R S)", "tactic_state": "case refine_2\nR : Type u_6\nS : Type u_7\nA : Type u_8\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module R A\ninst\u271d\u2074 : Module S A\ninst\u271d\u00b3 : Algebra R S\na : A\nf : S \u2192 R\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\nh : QuasispectrumRestricts a f\ns : S\nhs : s \u2208 quasispectrum S a\n\u22a2 f s \u2208 quasispectrum R a \u2227 (algebraMap R S) (f s) = s"}, {"line": "exact \u27e8quasispectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm \u25b8 hs), h.rightInvOn hs\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem algebraMap_image (h : SpectrumRestricts a f) :\n    algebraMap R S '' spectrum R a = spectrum S a := by\n  refine Set.eq_of_subset_of_subset ?_ fun s hs => \u27e8f s, ?_\u27e9\n  \u00b7 simpa only [spectrum.preimage_algebraMap] using\n      (spectrum S a).image_preimage_subset (algebraMap R S)\n  exact \u27e8spectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm \u25b8 hs), h.rightInvOn hs\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A] [Module R A] [Module S A]", "[Algebra R S] {a : A} {f : S \u2192 R}", "[IsScalarTower S A A] [SMulCommClass S A A]", "[IsScalarTower R S A]", "{R S A : Type*} [Semifield R] [Semifield S] [Ring A]", "[Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S \u2192 R}", "[IsScalarTower R S A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_9\nS : Type u_10\nA : Type u_11\ninst\u271d\u2076 : Semifield R\ninst\u271d\u2075 : Semifield S\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\na : A\nf : S \u2192 R\ninst\u271d : IsScalarTower R S A\nh : SpectrumRestricts a f\n\u22a2 \u21d1(algebraMap R S) '' spectrum R a = spectrum S a"}, {"line": "refine Set.eq_of_subset_of_subset ?_ fun s hs => \u27e8f s, ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_9\nS : Type u_10\nA : Type u_11\ninst\u271d\u2076 : Semifield R\ninst\u271d\u2075 : Semifield S\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\na : A\nf : S \u2192 R\ninst\u271d : IsScalarTower R S A\nh : SpectrumRestricts a f\n\u22a2 \u21d1(algebraMap R S) '' spectrum R a \u2286 spectrum S a\n---\ncase refine_2\nR : Type u_9\nS : Type u_10\nA : Type u_11\ninst\u271d\u2076 : Semifield R\ninst\u271d\u2075 : Semifield S\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\na : A\nf : S \u2192 R\ninst\u271d : IsScalarTower R S A\nh : SpectrumRestricts a f\ns : S\nhs : s \u2208 spectrum S a\n\u22a2 f s \u2208 spectrum R a \u2227 (algebraMap R S) (f s) = s"}, {"line": "\u00b7 simpa only [spectrum.preimage_algebraMap] using\n      (spectrum S a).image_preimage_subset (algebraMap R S)", "tactic_state": "case refine_2\nR : Type u_9\nS : Type u_10\nA : Type u_11\ninst\u271d\u2076 : Semifield R\ninst\u271d\u2075 : Semifield S\ninst\u271d\u2074 : Ring A\ninst\u271d\u00b3 : Algebra R S\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Algebra S A\na : A\nf : S \u2192 R\ninst\u271d : IsScalarTower R S A\nh : SpectrumRestricts a f\ns : S\nhs : s \u2208 spectrum S a\n\u22a2 f s \u2208 spectrum R a \u2227 (algebraMap R S) (f s) = s"}, {"line": "exact \u27e8spectrum.of_algebraMap_mem S ((h.rightInvOn hs).symm \u25b8 hs), h.rightInvOn hs\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quasispectrumRestricts_iff_spectrumRestricts_inr (S : Type*) {R A : Type*} [Semifield R]\n    [Field S] [NonUnitalRing A] [Algebra R S] [Module R A] [Module S A] [IsScalarTower S A A]\n    [SMulCommClass S A A] [IsScalarTower R S A] {a : A} {f : S \u2192 R} :\n    QuasispectrumRestricts a f \u2194 SpectrumRestricts (a : Unitization S A) f := by\n  rw [quasispectrumRestricts_iff]\n  rw [spectrumRestricts_iff]\n  rw [\u2190 Unitization.quasispectrum_eq_spectrum_inr']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A] [Module R A] [Module S A]", "[Algebra R S] {a : A} {f : S \u2192 R}", "[IsScalarTower S A A] [SMulCommClass S A A]", "[IsScalarTower R S A]", "{R S A : Type*} [Semifield R] [Semifield S] [Ring A]", "[Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S \u2192 R}", "[IsScalarTower R S A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_12\nR : Type u_13\nA : Type u_14\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\na : A\nf : S \u2192 R\n\u22a2 QuasispectrumRestricts a f \u2194 SpectrumRestricts (\u2191a) f"}, {"line": "rw [quasispectrumRestricts_iff]", "tactic_state": "S : Type u_12\nR : Type u_13\nA : Type u_14\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\na : A\nf : S \u2192 R\n\u22a2 Set.RightInvOn f (\u21d1(algebraMap R S)) (quasispectrum S a) \u2227 Function.LeftInverse f \u21d1(algebraMap R S) \u2194\n    SpectrumRestricts (\u2191a) f"}, {"line": "rw [spectrumRestricts_iff]", "tactic_state": "S : Type u_12\nR : Type u_13\nA : Type u_14\ninst\u271d\u2078 : Semifield R\ninst\u271d\u2077 : Field S\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Algebra R S\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : Module S A\ninst\u271d\u00b2 : IsScalarTower S A A\ninst\u271d\u00b9 : SMulCommClass S A A\ninst\u271d : IsScalarTower R S A\na : A\nf : S \u2192 R\n\u22a2 Set.RightInvOn f (\u21d1(algebraMap R S)) (quasispectrum S a) \u2227 Function.LeftInverse f \u21d1(algebraMap R S) \u2194\n    Set.RightInvOn f (\u21d1(algebraMap R S)) (spectrum S \u2191a) \u2227 Function.LeftInverse f \u21d1(algebraMap R S)"}, {"line": "rw [\u2190 Unitization.quasispectrum_eq_spectrum_inr']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quasispectrumRestricts_iff_spectrumRestricts {R S A : Type*} [Semifield R] [Semifield S]\n    [Ring A] [Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S \u2192 R} :\n    QuasispectrumRestricts a f \u2194 SpectrumRestricts a f := by rfl", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Spectrum/Quasispectrum.lean", "context": {"open": ["PreQuasiregular", "PreQuasiregular"], "variables": ["{R : Type*} [NonUnitalSemiring R]", "{R A : Type*} [CommSemiring R] [NonUnitalSemiring A] [Module R A] [IsScalarTower R A A]", "(R A) in", "(R) in", "{R : Type*} [NonUnitalSemiring R]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalRing A]", "{R} in", "{R}", "[IsScalarTower R A A] [SMulCommClass R A A]", "{R S A : Type*} [Semifield R] [Field S] [NonUnitalRing A] [Module R A] [Module S A]", "[Algebra R S] {a : A} {f : S \u2192 R}", "[IsScalarTower S A A] [SMulCommClass S A A]", "[IsScalarTower R S A]", "{R S A : Type*} [Semifield R] [Semifield S] [Ring A]", "[Algebra R S] [Algebra R A] [Algebra S A] {a : A} {f : S \u2192 R}", "[IsScalarTower R S A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\nS : Type u_13\nA : Type u_14\ninst\u271d\u2075 : Semifield R\ninst\u271d\u2074 : Semifield S\ninst\u271d\u00b3 : Ring A\ninst\u271d\u00b2 : Algebra R S\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : Algebra S A\na : A\nf : S \u2192 R\n\u22a2 QuasispectrumRestricts a f \u2194 SpectrumRestricts a f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIdempotentElem_toSubmodule (S : Subalgebra R A) :\n    IsIdempotentElem S.toSubmodule := by\n  apply le_antisymm\n  \u00b7 refine (mul_toSubmodule_le _ _).trans_eq ?_\n    rw [sup_idem]\n  \u00b7 intro x hx1\n    rw [\u2190 mul_one x]\n    exact Submodule.mul_mem_mul hx1 (show (1 : A) \u2208 S from one_mem S)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Subalgebra/Pointwise.lean", "context": {"open": [], "variables": ["{R : Type*} {A : Type*} [CommSemiring R] [Semiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\n\u22a2 IsIdempotentElem (Subalgebra.toSubmodule S)"}, {"line": "apply le_antisymm", "tactic_state": "case a\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\n\u22a2 Subalgebra.toSubmodule S * Subalgebra.toSubmodule S \u2264 Subalgebra.toSubmodule S\n---\ncase a\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\n\u22a2 Subalgebra.toSubmodule S \u2264 Subalgebra.toSubmodule S * Subalgebra.toSubmodule S"}, {"line": "\u00b7 refine (mul_toSubmodule_le _ _).trans_eq ?_\n    rw [sup_idem]", "tactic_state": "case a\nR : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\nS : Subalgebra R A\n\u22a2 Subalgebra.toSubmodule S \u2264 Subalgebra.toSubmodule S * Subalgebra.toSubmodule S"}, {"line": "\u00b7 intro x hx1\n    rw [\u2190 mul_one x]\n    exact Submodule.mul_mem_mul hx1 (show (1 : A) \u2208 S from one_mem S)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self\n    {f : A \u2192\u2090[R] B} {S : Subalgebra R B} (h : S \u2264 f.range) : (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Algebra/Subalgebra/Lattice.lean", "context": {"open": ["Subalgebra in", "Subalgebra in", "Subalgebra in", "Algebra"], "variables": ["(R : Type u) {A : Type v} {B : Type w}", "[CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "{R}", "{R : Type u} {A : Type v} {B : Type w}", "[CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "(S : Subalgebra R A)", "(R A)", "(R)", "{R A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]", "{F : Type*}", "[FunLike F A B] [AlgHomClass F R A B]", "{R A B : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B] [Algebra R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nA : Type u_6\nB : Type u_7\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : Algebra R A\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Algebra R B\nf : A \u2192\u2090[R] B\nS : Subalgebra R B\nh : S \u2264 f.range\n\u22a2 Subalgebra.map f (Subalgebra.comap f S) = S"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f S", "tactic_state": "No Goals!"}]}
{"declaration": "lemma AlgHom.mulLeftRight_apply (a : A) (b : A\u1d50\u1d52\u1d56) (x : A) :\n    AlgHom.mulLeftRight R A (a \u2297\u209c b) x = a * x * b.unop := by\n  simp only [AlgHom.mulLeftRight]\n  simp only [Algebra.lsmul_coe]\n  change TensorProduct.Algebra.moduleAux _ _ = _\n  simp [TensorProduct.Algebra.moduleAux, \u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Azumaya/Defs.lean", "context": {"open": ["TensorProduct MulOpposite"], "variables": ["(R A : Type*) [CommSemiring R] [Semiring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\na : A\nb : A\u1d50\u1d52\u1d56\nx : A\n\u22a2 ((mulLeftRight R A) (a \u2297\u209c[R] b)) x = a * x * MulOpposite.unop b"}, {"line": "simp only [AlgHom.mulLeftRight]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\na : A\nb : A\u1d50\u1d52\u1d56\nx : A\n\u22a2 ((Algebra.lsmul R R A) (a \u2297\u209c[R] b)) x = a * x * MulOpposite.unop b"}, {"line": "simp only [Algebra.lsmul_coe]", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\na : A\nb : A\u1d50\u1d52\u1d56\nx : A\n\u22a2 a \u2297\u209c[R] b \u2022 x = a * x * MulOpposite.unop b"}, {"line": "change TensorProduct.Algebra.moduleAux _ _ = _", "tactic_state": "R : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Algebra R A\na : A\nb : A\u1d50\u1d52\u1d56\nx : A\n\u22a2 (Algebra.moduleAux (a \u2297\u209c[R] b)) x = a * x * MulOpposite.unop b"}, {"line": "simp [TensorProduct.Algebra.moduleAux, \u2190 mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_sum_comm (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03ba \u2192 M) :\n    \ud835\udd3c i \u2208 s, \u2211 j \u2208 t, f i j = \u2211 j \u2208 t, \ud835\udd3c i \u2208 s, f i j := by\n  simpa only [expect, smul_sum] using sum_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 (s.expect fun i => \u2211 j \u2208 t, f i j) = \u2211 j \u2208 t, s.expect fun i => f i j"}, {"line": "simpa only [expect, smul_sum] using sum_comm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_comm (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03ba \u2192 M) :\n    \ud835\udd3c i \u2208 s, \ud835\udd3c j \u2208 t, f i j = \ud835\udd3c j \u2208 t, \ud835\udd3c i \u2208 s, f i j := by\n  rw [expect]\n  rw [expect]\n  rw [\u2190 expect_sum_comm]\n  rw [\u2190 expect_sum_comm]\n  rw [expect]\n  rw [expect]\n  rw [smul_comm]\n  rw [sum_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 (s.expect fun i => t.expect fun j => f i j) = t.expect fun j => s.expect fun i => f i j"}, {"line": "rw [expect]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 ((\u2191s.card)\u207b\u00b9 \u2022 \u2211 i \u2208 s, t.expect fun j => f i j) = t.expect fun j => s.expect fun i => f i j"}, {"line": "rw [expect]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 ((\u2191s.card)\u207b\u00b9 \u2022 \u2211 i \u2208 s, t.expect fun j => f i j) = (\u2191t.card)\u207b\u00b9 \u2022 \u2211 i \u2208 t, s.expect fun i_1 => f i_1 i"}, {"line": "rw [\u2190 expect_sum_comm]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 ((\u2191s.card)\u207b\u00b9 \u2022 t.expect fun i => \u2211 j \u2208 s, f j i) = (\u2191t.card)\u207b\u00b9 \u2022 \u2211 i \u2208 t, s.expect fun i_1 => f i_1 i"}, {"line": "rw [\u2190 expect_sum_comm]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 ((\u2191s.card)\u207b\u00b9 \u2022 t.expect fun i => \u2211 j \u2208 s, f j i) = (\u2191t.card)\u207b\u00b9 \u2022 s.expect fun i => \u2211 j \u2208 t, f i j"}, {"line": "rw [expect]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 (\u2191s.card)\u207b\u00b9 \u2022 (\u2191t.card)\u207b\u00b9 \u2022 \u2211 i \u2208 t, \u2211 j \u2208 s, f j i = (\u2191t.card)\u207b\u00b9 \u2022 s.expect fun i => \u2211 j \u2208 t, f i j"}, {"line": "rw [expect]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 (\u2191s.card)\u207b\u00b9 \u2022 (\u2191t.card)\u207b\u00b9 \u2022 \u2211 i \u2208 t, \u2211 j \u2208 s, f j i = (\u2191t.card)\u207b\u00b9 \u2022 (\u2191s.card)\u207b\u00b9 \u2022 \u2211 i \u2208 s, \u2211 j \u2208 t, f i j"}, {"line": "rw [smul_comm]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03ba \u2192 M\n\u22a2 (\u2191t.card)\u207b\u00b9 \u2022 (\u2191s.card)\u207b\u00b9 \u2022 \u2211 i \u2208 t, \u2211 j \u2208 s, f j i = (\u2191t.card)\u207b\u00b9 \u2022 (\u2191s.card)\u207b\u00b9 \u2022 \u2211 i \u2208 s, \u2211 j \u2208 t, f i j"}, {"line": "rw [sum_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_add_distrib (s : Finset \u03b9) (f g : \u03b9 \u2192 M) :\n    \ud835\udd3c i \u2208 s, (f i + g i) = \ud835\udd3c i \u2208 s, f i + \ud835\udd3c i \u2208 s, g i := by\n  simp [expect, sum_add_distrib]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nf g : \u03b9 \u2192 M\n\u22a2 (s.expect fun i => f i + g i) = (s.expect fun i => f i) + s.expect fun i => g i"}, {"line": "simp [expect, sum_add_distrib]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_add_expect_comm (f\u2081 f\u2082 g\u2081 g\u2082 : \u03b9 \u2192 M) :\n    \ud835\udd3c i \u2208 s, (f\u2081 i + f\u2082 i) + \ud835\udd3c i \u2208 s, (g\u2081 i + g\u2082 i) =\n      \ud835\udd3c i \u2208 s, (f\u2081 i + g\u2081 i) + \ud835\udd3c i \u2208 s, (f\u2082 i + g\u2082 i) := by\n  simp_rw [expect_add_distrib, add_add_add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nf\u2081 f\u2082 g\u2081 g\u2082 : \u03b9 \u2192 M\n\u22a2 ((s.expect fun i => f\u2081 i + f\u2082 i) + s.expect fun i => g\u2081 i + g\u2082 i) =\n    (s.expect fun i => f\u2081 i + g\u2081 i) + s.expect fun i => f\u2082 i + g\u2082 i"}, {"line": "simp_rw [expect_add_distrib, add_add_add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.map_expect {F : Type*} [FunLike F M N] [LinearMapClass F \u211a\u22650 M N]\n    (g : F) (f : \u03b9 \u2192 M) (s : Finset \u03b9) :\n    g (\ud835\udd3c i \u2208 s, f i) = \ud835\udd3c i \u2208 s, g (f i) := by simp only [expect, map_smul, map_natCast, map_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\nN : Type u_4\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : _root_.Module \u211a\u22650 M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : _root_.Module \u211a\u22650 N\ninst\u271d\u00b2 : DecidableEq \u03b9\nF : Type u_5\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : LinearMapClass F \u211a\u22650 M N\ng : F\nf : \u03b9 \u2192 M\ns : Finset \u03b9\n\u22a2 g (s.expect fun i => f i) = s.expect fun i => g (f i)"}, {"line": "simp only [expect, map_smul, map_natCast, map_sum]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\nN : Type u_4\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : _root_.Module \u211a\u22650 M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : _root_.Module \u211a\u22650 N\ninst\u271d\u00b2 : DecidableEq \u03b9\nF : Type u_5\ninst\u271d\u00b9 : FunLike F M N\ninst\u271d : LinearMapClass F \u211a\u22650 M N\ng : F\nf : \u03b9 \u2192 M\ns : Finset \u03b9\n\u22a2 g ((\u2191s.card)\u207b\u00b9 \u2022 \u2211 x \u2208 s, f x) = (\u2191s.card)\u207b\u00b9 \u2022 \u2211 x \u2208 s, g (f x)"}]}
{"declaration": "lemma expect_neg_distrib (s : Finset \u03b9) (f : \u03b9 \u2192 M) : \ud835\udd3c i \u2208 s, -f i = -\ud835\udd3c i \u2208 s, f i := by\n  simp [expect]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (s.expect fun i => -f i) = -s.expect fun i => f i"}, {"line": "simp [expect]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : _root_.Module \u211a\u22650 M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (\u2191s.card)\u207b\u00b9 \u2022 \u2211 x \u2208 s, -f x = -((\u2191s.card)\u207b\u00b9 \u2022 \u2211 x \u2208 s, f x)"}]}
{"declaration": "lemma expect_ite_zero (p : \u03b9 \u2192 Prop) [DecidablePred p] (h : \u2200 i j, p i \u2192 p j \u2192 i = j) (a : M) :\n    \ud835\udd3c i, ite (p i) a 0 = ite (\u2203 i, p i) (a /\u211a Fintype.card \u03b9) 0 := by\n  simp [univ.expect_ite_zero p (by simpa using h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]", "[Semiring M] [Module \u211a\u22650 M]", "[CommSemiring M] [Module \u211a\u22650 M] [IsScalarTower \u211a\u22650 M M] [SMulCommClass \u211a\u22650 M M]", "[Semifield M] [CharZero M]", "[Semifield M] [CharZero M] [Semifield N] [CharZero N] [Algebra M N]", "[Fintype \u03b9] [Fintype \u03ba]", "[AddCommMonoid M] [Module \u211a\u22650 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nh : \u2200 (i j : \u03b9), p i \u2192 p j \u2192 i = j\na : M\n\u22a2 (univ.expect fun i => if p i then a else 0) = if \u2203 i, p i then a / sorry else 0"}, {"line": "simp [univ.expect_ite_zero p (by simpa using h)]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nh : \u2200 (i j : \u03b9), p i \u2192 p j \u2192 i = j\na : M\n\u22a2 (univ.expect fun i => if p i then a else 0) = if \u2203 i, p i then a / sorry () else 0"}]}
{"declaration": "lemma expect_dite_eq (i : \u03b9) (f : \u2200 j, i = j \u2192 M) :\n    \ud835\udd3c j, (if h : i = j then f j h else 0) = f i rfl /\u211a card \u03b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]", "[Semiring M] [Module \u211a\u22650 M]", "[CommSemiring M] [Module \u211a\u22650 M] [IsScalarTower \u211a\u22650 M M] [SMulCommClass \u211a\u22650 M M]", "[Semifield M] [CharZero M]", "[Semifield M] [CharZero M] [Semifield N] [CharZero N] [Algebra M N]", "[Fintype \u03b9] [Fintype \u03ba]", "[AddCommMonoid M] [Module \u211a\u22650 M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : (j : \u03b9) \u2192 i = j \u2192 M\n\u22a2 (univ.expect fun j => if h : i = j then f j h else 0) = f i \u22ef / sorry"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : (j : \u03b9) \u2192 i = j \u2192 M\n\u22a2 (univ.expect fun j => if h : i = j then f j h else 0) = f i \u22ef / sorry ()"}]}
{"declaration": "lemma expect_dite_eq' (i : \u03b9) (f : \u2200 j, j = i \u2192 M) :\n    \ud835\udd3c j, (if h : j = i then f j h else 0) = f i rfl /\u211a card \u03b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]", "[Semiring M] [Module \u211a\u22650 M]", "[CommSemiring M] [Module \u211a\u22650 M] [IsScalarTower \u211a\u22650 M M] [SMulCommClass \u211a\u22650 M M]", "[Semifield M] [CharZero M]", "[Semifield M] [CharZero M] [Semifield N] [CharZero N] [Algebra M N]", "[Fintype \u03b9] [Fintype \u03ba]", "[AddCommMonoid M] [Module \u211a\u22650 M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : (j : \u03b9) \u2192 j = i \u2192 M\n\u22a2 (univ.expect fun j => if h : j = i then f j h else 0) = f i \u22ef / sorry"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : (j : \u03b9) \u2192 j = i \u2192 M\n\u22a2 (univ.expect fun j => if h : j = i then f j h else 0) = f i \u22ef / sorry ()"}]}
{"declaration": "lemma expect_ite_eq (i : \u03b9) (f : \u03b9 \u2192 M) :\n    \ud835\udd3c j, (if i = j then f j else 0) = f i /\u211a card \u03b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]", "[Semiring M] [Module \u211a\u22650 M]", "[CommSemiring M] [Module \u211a\u22650 M] [IsScalarTower \u211a\u22650 M M] [SMulCommClass \u211a\u22650 M M]", "[Semifield M] [CharZero M]", "[Semifield M] [CharZero M] [Semifield N] [CharZero N] [Algebra M N]", "[Fintype \u03b9] [Fintype \u03ba]", "[AddCommMonoid M] [Module \u211a\u22650 M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (univ.expect fun j => if i = j then f j else 0) = f i / sorry"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (univ.expect fun j => if i = j then f j else 0) = f i / sorry ()"}]}
{"declaration": "lemma expect_ite_eq' (i : \u03b9) (f : \u03b9 \u2192 M) :\n    \ud835\udd3c j, (if j = i then f j else 0) = f i /\u211a card \u03b9 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Expect.lean", "context": {"open": ["Finset Function", "Fintype (card)", "scoped Pointwise", "Batteries.ExtendedBinder Lean Meta", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "Batteries.ExtendedBinder", "scoped BigOperators"], "variables": ["{\u03b9 \u03ba M N : Type*}", "[AddCommMonoid M] [Module \u211a\u22650 M] [AddCommMonoid N] [Module \u211a\u22650 N] {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "{t : Finset \u03ba} {g : \u03ba \u2192 M}", "[AddCommGroup M] [Module \u211a\u22650 M]", "[Semiring M] [Module \u211a\u22650 M]", "[CommSemiring M] [Module \u211a\u22650 M] [IsScalarTower \u211a\u22650 M M] [SMulCommClass \u211a\u22650 M M]", "[Semifield M] [CharZero M]", "[Semifield M] [CharZero M] [Semifield N] [CharZero N] [Algebra M N]", "[Fintype \u03b9] [Fintype \u03ba]", "[AddCommMonoid M] [Module \u211a\u22650 M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (univ.expect fun j => if j = i then f j else 0) = f i / sorry"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b9\u2078 : AddCommMonoid M\ninst\u271d\u00b9\u2077 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u2076 : DecidableEq \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup M\ninst\u271d\u00b9\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b3 : Semiring M\ninst\u271d\u00b9\u00b2 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b9\u00b9 : CommSemiring M\ninst\u271d\u00b9\u2070 : _root_.Module \u211a\u22650 M\ninst\u271d\u2079 : IsScalarTower \u211a\u22650 M M\ninst\u271d\u2078 : SMulCommClass \u211a\u22650 M M\ninst\u271d\u2077 : Semifield M\ninst\u271d\u2076 : CharZero M\ninst\u271d\u2075 : Semifield M\ninst\u271d\u2074 : CharZero M\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : _root_.Module \u211a\u22650 M\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 M\n\u22a2 (univ.expect fun j => if j = i then f j else 0) = f i / sorry ()"}]}
{"declaration": "theorem prod_insertNone (f : Option \u03b1 \u2192 M) (s : Finset \u03b1) :\n    \u220f x \u2208 insertNone s, f x = f none * \u220f x \u2208 s, f (some x) := by simp [insertNone]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Option.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M : Type*} [CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : CommMonoid M\nx\u271d : Sort u_3\ninsertNone : x\u271d\nf : Option \u03b1 \u2192 M\ns : Finset \u03b1\n\u22a2 \u220f x \u2208 sorry, f x = f none * \u220f x \u2208 s, f (some x)"}, {"line": "simp [insertNone]", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : CommMonoid M\nx\u271d : Sort u_3\ninsertNone : x\u271d\nf : Option \u03b1 \u2192 M\ns : Finset \u03b1\n\u22a2 \u220f x \u2208 sorry (), f x = f none * \u220f x \u2208 s, f (some x)"}]}
{"declaration": "theorem sum_sym2_filter_not_isDiag {\u03b9 \u03b1} [LinearOrder \u03b9] [AddCommMonoid \u03b1]\n    (s : Finset \u03b9) (p : Sym2 \u03b9 \u2192 \u03b1) :\n    \u2211 i \u2208 s.sym2 with \u00ac i.IsDiag, p i = \u2211 i \u2208 s.offDiag with i.1 < i.2, p s(i.1, i.2) := by\n  rw [Finset.offDiag_filter_lt_eq_filter_le]\n  conv_rhs => rw [\u2190 Finset.sum_subtype_eq_sum_filter]\n  refine (Finset.sum_equiv Sym2.sortEquiv.symm ?_ ?_).symm\n  all_goals aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Sym.lean", "context": {"open": ["Multiset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\np : Sym2 \u03b9 \u2192 \u03b1\n\u22a2 \u2211 i \u2208 {i \u2208 s.sym2 | \u00aci.IsDiag}, p i = \u2211 i \u2208 {i \u2208 s.offDiag | i.1 < i.2}, p s(i.1, i.2)"}, {"line": "rw [Finset.offDiag_filter_lt_eq_filter_le]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\np : Sym2 \u03b9 \u2192 \u03b1\n\u22a2 \u2211 i \u2208 {i \u2208 s.sym2 | \u00aci.IsDiag}, p i = \u2211 i \u2208 {i \u2208 s.offDiag | i.1 \u2264 i.2}, p s(i.1, i.2)"}, {"line": "conv_rhs => rw [\u2190 Finset.sum_subtype_eq_sum_filter]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\np : Sym2 \u03b9 \u2192 \u03b1\n\u22a2 \u2211 i \u2208 {i \u2208 s.sym2 | \u00aci.IsDiag}, p i = \u2211 x \u2208 Finset.subtype (fun i => i.1 \u2264 i.2) s.offDiag, p s((\u2191x).1, (\u2191x).2)"}, {"line": "refine (Finset.sum_equiv Sym2.sortEquiv.symm ?_ ?_).symm", "tactic_state": "case refine_1\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\np : Sym2 \u03b9 \u2192 \u03b1\n\u22a2 \u2200 (i : { p // p.1 \u2264 p.2 }),\n    i \u2208 Finset.subtype (fun i => i.1 \u2264 i.2) s.offDiag \u2194 Sym2.sortEquiv.symm i \u2208 {i \u2208 s.sym2 | \u00aci.IsDiag}\n---\ncase refine_2\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : LinearOrder \u03b9\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\np : Sym2 \u03b9 \u2192 \u03b1\n\u22a2 \u2200 i \u2208 Finset.subtype (fun i => i.1 \u2264 i.2) s.offDiag, p s((\u2191i).1, (\u2191i).2) = p (Sym2.sortEquiv.symm i)"}, {"line": "all_goals aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_ne_top : \u2211 i \u2208 s, f i \u2260 \u22a4 \u2194 \u2200 i \u2208 s, f i \u2260 \u22a4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/WithTop.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03b1 : Type*}", "[AddCommMonoid \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 WithTop \u03b1\n\u22a2 \u2211 i \u2208 s, f i \u2260 \u22a4 \u2194 \u2200 i \u2208 s, f i \u2260 \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_eq_bot_iff : \u2211 i \u2208 s, f i = \u22a5 \u2194 \u2203 i \u2208 s, f i = \u22a5 := by\n  induction s using Finset.cons_induction <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/WithTop.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03b1 : Type*}", "[AddCommMonoid \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop \u03b1}", "[LT \u03b1]", "[CommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] [Nontrivial \u03b1] [DecidableEq \u03b1]", "[AddCommMonoid \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 WithBot \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : LT \u03b1\ninst\u271d\u2074 : CommMonoidWithZero \u03b1\ninst\u271d\u00b3 : NoZeroDivisors \u03b1\ninst\u271d\u00b2 : Nontrivial \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : AddCommMonoid \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 WithBot \u03b1\n\u22a2 \u2211 i \u2208 s, f i = \u22a5 \u2194 \u2203 i \u2208 s, f i = \u22a5"}, {"line": "induction s using Finset.cons_induction <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.not_dvd_finset_prod {S : Finset \u03b1} {p : M} (pp : Prime p) {g : \u03b1 \u2192 M}\n    (hS : \u2200 a \u2208 S, \u00acp \u2223 g a) : \u00acp \u2223 S.prod g := by\n  exact mt (Prime.dvd_finset_prod_iff pp _).1 <| not_exists.2 fun a => not_and.2 (hS a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Associated.lean", "context": {"open": ["Submonoid in", "Finset Finsupp"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[CommMonoidWithZero \u03b1] {p : \u03b1}", "[CommMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "{M : Type*} [CommMonoidWithZero M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CommMonoidWithZero \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\nM : Type u_5\ninst\u271d : CommMonoidWithZero M\nS : Finset \u03b1\np : M\npp : Prime p\ng : \u03b1 \u2192 M\nhS : \u2200 a \u2208 S, \u00acp \u2223 g a\n\u22a2 \u00acp \u2223 S.prod g"}, {"line": "exact mt (Prime.dvd_finset_prod_iff pp _).1 <| not_exists.2 fun a => not_and.2 (hS a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Multiset.sum_map_div (s : Multiset \u03b9) (f : \u03b9 \u2192 K) (a : K) :\n    (s.map (fun x \u21a6 f x / a)).sum = (s.map f).sum / a := by\n  simp only [div_eq_mul_inv]\n  simp only [Multiset.sum_map_mul_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Field.lean", "context": {"open": ["Fintype"], "variables": ["{\u03b9 K : Type*} [DivisionSemiring K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nK : Type u_2\ninst\u271d : DivisionSemiring K\ns : Multiset \u03b9\nf : \u03b9 \u2192 K\na : K\n\u22a2 (map (fun x => f x / a) s).sum = (map f s).sum / a"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "\u03b9 : Type u_1\nK : Type u_2\ninst\u271d : DivisionSemiring K\ns : Multiset \u03b9\nf : \u03b9 \u2192 K\na : K\n\u22a2 (map (fun x => f x * a\u207b\u00b9) s).sum = (map f s).sum * a\u207b\u00b9"}, {"line": "simp only [Multiset.sum_map_mul_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Finset.sum_div (s : Finset \u03b9) (f : \u03b9 \u2192 K) (a : K) :\n    (\u2211 i \u2208 s, f i) / a = \u2211 i \u2208 s, f i / a := by simp only [div_eq_mul_inv, sum_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Field.lean", "context": {"open": ["Fintype"], "variables": ["{\u03b9 K : Type*} [DivisionSemiring K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nK : Type u_2\ninst\u271d : DivisionSemiring K\ns : Finset \u03b9\nf : \u03b9 \u2192 K\na : K\n\u22a2 (\u2211 i \u2208 s, f i) / a = \u2211 i \u2208 s, f i / a"}, {"line": "simp only [div_eq_mul_inv, sum_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dens_disjiUnion (s : Finset \u03b1) (t : \u03b1 \u2192 Finset \u03b2) (h) :\n    (s.disjiUnion t h).dens = \u2211 a \u2208 s, (t a).dens := by simp [dens, sum_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Field.lean", "context": {"open": ["Fintype"], "variables": ["{\u03b9 K : Type*} [DivisionSemiring K]", "{\u03b1 \u03b2 : Type*} [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : Fintype \u03b2\ns : Finset \u03b1\nt : \u03b1 \u2192 Finset \u03b2\nh : (\u2191s).PairwiseDisjoint t\n\u22a2 (s.disjiUnion t h).dens = \u2211 a \u2208 s, (t a).dens"}, {"line": "simp [dens, sum_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ofFn (f : Fin n \u2192 M) : (List.ofFn f).prod = \u220f i, f i := by\n  simp [prod_eq_multiset_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nn : \u2115\nf : Fin n \u2192 M\n\u22a2 (List.ofFn f).prod = \u220f i, f i"}, {"line": "simp [prod_eq_multiset_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_univ_castSucc (f : Fin (n + 1) \u2192 M) :\n    \u220f i, f i = (\u220f i : Fin n, f (Fin.castSucc i)) * f (last n) := by\n  simpa [mul_comm] using prod_univ_succAbove f (last n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nn : \u2115\nx\u271d : Sort u_3\nlast : x\u271d\nf : Fin (n + 1) \u2192 M\n\u22a2 \u220f i, f i = (\u220f i, f i.castSucc) * f sorry"}, {"line": "simpa [mul_comm] using prod_univ_succAbove f (last n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_univ_getElem (l : List M) : \u220f i : Fin l.length, l[i.1] = l.prod := by\n  simp [Finset.prod_eq_multiset_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nl : List M\n\u22a2 \u220f i, l[\u2191i] = l.prod"}, {"line": "simp [Finset.prod_eq_multiset_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_univ_fun_getElem (l : List \u03b1) (f : \u03b1 \u2192 M) :\n    \u220f i : Fin l.length, f l[i.1] = (l.map f).prod := by\n  simp [Finset.prod_eq_multiset_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : CommMonoid M\nl : List \u03b1\nf : \u03b1 \u2192 M\n\u22a2 \u220f i, f l[\u2191i] = (List.map f l).prod"}, {"line": "simp [Finset.prod_eq_multiset_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_snoc (x : M) (f : Fin n \u2192 M) :\n    (\u220f i : Fin n.succ, (snoc f x : Fin n.succ \u2192 M) i) = (\u220f i : Fin n, f i) * x := by\n  simp [prod_univ_castSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nn : \u2115\nx\u271d : Sort u_3\nsnoc : x\u271d\nx : M\nf : Fin n \u2192 M\n\u22a2 \u220f i, sorry i = (\u220f i, f i) * x"}, {"line": "simp [prod_univ_castSucc]", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nn : \u2115\nx\u271d : Sort u_3\nsnoc : x\u271d\nx : M\nf : Fin n \u2192 M\n\u22a2 \u220f x, sorry () x = (\u220f i, f i) * x"}]}
{"declaration": "theorem prod_univ_one (f : Fin 1 \u2192 M) : \u220f i, f i = f 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : Fin 1 \u2192 M\n\u22a2 \u220f i, f i = f 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_univ_two (f : Fin 2 \u2192 M) : \u220f i, f i = f 0 * f 1 := by\n  simp [prod_univ_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : Fin 2 \u2192 M\n\u22a2 \u220f i, f i = f 0 * f 1"}, {"line": "simp [prod_univ_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_const (n : \u2115) (x : M) : \u220f _i : Fin n, x = x ^ n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nn : \u2115\nx : M\n\u22a2 \u220f _i, x = x ^ n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_congr' {a b : \u2115} (f : Fin b \u2192 M) (h : a = b) :\n    (\u220f i : Fin a, f (i.cast h)) = \u220f i : Fin b, f i := by\n  subst h\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\na b : \u2115\nf : Fin b \u2192 M\nh : a = b\n\u22a2 \u220f i, f (Fin.cast h i) = \u220f i, f i"}, {"line": "subst h", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\na : \u2115\nf : Fin a \u2192 M\n\u22a2 \u220f i, f (Fin.cast \u22ef i) = \u220f i, f i"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_pow_mul_eq_add_pow {n : \u2115} {R : Type*} [CommSemiring R] (a b : R) :\n    (\u2211 s : Finset (Fin n), a ^ s.card * b ^ (n - s.card)) = (a + b) ^ n := by\n  simpa using Fintype.sum_pow_mul_eq_add_pow (Fin n) a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_3\ninst\u271d : CommSemiring R\na b : R\n\u22a2 \u2211 s, a ^ s.card * b ^ (n - s.card) = (a + b) ^ n"}, {"line": "simpa using Fintype.sum_pow_mul_eq_add_pow (Fin n) a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem partialProd_zero (f : Fin n \u2192 \u03b1) : partialProd f 0 = 1 := by simp [partialProd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}", "[Monoid \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nn : \u2115\nx\u271d : Sort u_3\npartialProd : x\u271d\nf : Fin n \u2192 \u03b1\n\u22a2 sorry = 1"}, {"line": "simp [partialProd]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nn : \u2115\nx\u271d : Sort u_3\npartialProd : x\u271d\nf : Fin n \u2192 \u03b1\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem partialProd_succ (f : Fin n \u2192 \u03b1) (j : Fin n) :\n    partialProd f j.succ = partialProd f (Fin.castSucc j) * f j := by\n  simp [partialProd, List.take_succ, List.ofFnNthVal, dif_pos j.is_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}", "[Monoid \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nn : \u2115\nx\u271d : Sort u_3\npartialProd : x\u271d\nf : Fin n \u2192 \u03b1\nj : Fin n\n\u22a2 sorry = sorry * f j"}, {"line": "simp [partialProd, List.take_succ, List.ofFnNthVal, dif_pos j.is_lt]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nn : \u2115\nx\u271d : Sort u_3\npartialProd : x\u271d\nf : Fin n \u2192 \u03b1\nj : Fin n\n\u22a2 sorry () = sorry () * f j"}]}
{"declaration": "theorem finFunctionFinEquiv_single {m n : \u2115} [NeZero m] (i : Fin n) (j : Fin m) :\n    (finFunctionFinEquiv (Pi.single i j) : \u2115) = j * m ^ (i : \u2115) := by\n  rw [finFunctionFinEquiv_apply]\n  rw [Fintype.sum_eq_single i]\n  rw [Pi.single_eq_same]\n  rintro x hx\n  rw [Pi.single_eq_of_ne hx]\n  rw [Fin.val_zero]\n  rw [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}", "[Monoid \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\n\u22a2 \u2191(finFunctionFinEquiv (Pi.single i j)) = \u2191j * m ^ \u2191i"}, {"line": "rw [finFunctionFinEquiv_apply]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\n\u22a2 \u2211 i_1, \u2191(Pi.single i j i_1) * m ^ \u2191i_1 = \u2191j * m ^ \u2191i"}, {"line": "rw [Fintype.sum_eq_single i]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\n\u22a2 \u2191(Pi.single i j i) * m ^ \u2191i = \u2191j * m ^ \u2191i\n---\nm n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\n\u22a2 \u2200 (x : Fin n), x \u2260 i \u2192 \u2191(Pi.single i j x) * m ^ \u2191x = 0"}, {"line": "rw [Pi.single_eq_same]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\n\u22a2 \u2200 (x : Fin n), x \u2260 i \u2192 \u2191(Pi.single i j x) * m ^ \u2191x = 0"}, {"line": "rintro x hx", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\nx : Fin n\nhx : x \u2260 i\n\u22a2 \u2191(Pi.single i j x) * m ^ \u2191x = 0"}, {"line": "rw [Pi.single_eq_of_ne hx]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\nx : Fin n\nhx : x \u2260 i\n\u22a2 \u21910 * m ^ \u2191x = 0"}, {"line": "rw [Fin.val_zero]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\ni : Fin n\nj : Fin m\nx : Fin n\nhx : x \u2260 i\n\u22a2 0 * m ^ \u2191x = 0"}, {"line": "rw [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finPiFinEquiv_single {m : \u2115} {n : Fin m \u2192 \u2115} [\u2200 i, NeZero (n i)] (i : Fin m)\n    (j : Fin (n i)) :\n    (finPiFinEquiv (Pi.single i j : \u2200 i : Fin m, Fin (n i)) : \u2115) =\n      j * \u220f j, n (Fin.castLE i.is_lt.le j) := by\n  rw [finPiFinEquiv_apply]\n  rw [Fintype.sum_eq_single i]\n  rw [Pi.single_eq_same]\n  rintro x hx\n  rw [Pi.single_eq_of_ne hx]\n  rw [Fin.val_zero]\n  rw [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}", "[Monoid \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n\u22a2 \u2191(finPiFinEquiv (Pi.single i j)) = \u2191j * \u220f j, n (Fin.castLE \u22ef j)"}, {"line": "rw [finPiFinEquiv_apply]", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n\u22a2 \u2211 i_1, \u2191(Pi.single i j i_1) * \u220f j, n (Fin.castLE \u22ef j) = \u2191j * \u220f j, n (Fin.castLE \u22ef j)"}, {"line": "rw [Fintype.sum_eq_single i]", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n\u22a2 \u2191(Pi.single i j i) * \u220f j, n (Fin.castLE \u22ef j) = \u2191j * \u220f j, n (Fin.castLE \u22ef j)\n---\nm : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n\u22a2 \u2200 (x : Fin m), x \u2260 i \u2192 \u2191(Pi.single i j x) * \u220f j, n (Fin.castLE \u22ef j) = 0"}, {"line": "rw [Pi.single_eq_same]", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\n\u22a2 \u2200 (x : Fin m), x \u2260 i \u2192 \u2191(Pi.single i j x) * \u220f j, n (Fin.castLE \u22ef j) = 0"}, {"line": "rintro x hx", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\nx : Fin m\nhx : x \u2260 i\n\u22a2 \u2191(Pi.single i j x) * \u220f j, n (Fin.castLE \u22ef j) = 0"}, {"line": "rw [Pi.single_eq_of_ne hx]", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\nx : Fin m\nhx : x \u2260 i\n\u22a2 \u21910 * \u220f j, n (Fin.castLE \u22ef j) = 0"}, {"line": "rw [Fin.val_zero]", "tactic_state": "m : \u2115\nn : Fin m \u2192 \u2115\ninst\u271d : \u2200 (i : Fin m), NeZero (n i)\ni : Fin m\nj : Fin (n i)\nx : Fin m\nhx : x \u2260 i\n\u22a2 0 * \u220f j, n (Fin.castLE \u22ef j) = 0"}, {"line": "rw [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSigmaFinEquiv_one {n : Fin 1 \u2192 \u2115} (ij : (i : Fin 1) \u00d7 Fin (n i)) :\n    (finSigmaFinEquiv ij : \u2115) = ij.2 := by\n  rw [finSigmaFinEquiv_apply]\n  rw [add_eq_right]\n  apply @Finset.sum_of_isEmpty _ _ _ _ (by simpa using Fin.isEmpty')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Fin.lean", "context": {"open": ["Finset"], "variables": ["{\u03b1 M : Type*}", "[CommMonoid M] {n : \u2115}", "[Monoid \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin 1 \u2192 \u2115\nij : (i : Fin 1) \u00d7 Fin (n i)\n\u22a2 \u2191(finSigmaFinEquiv ij) = \u2191ij.snd"}, {"line": "rw [finSigmaFinEquiv_apply]", "tactic_state": "n : Fin 1 \u2192 \u2115\nij : (i : Fin 1) \u00d7 Fin (n i)\n\u22a2 \u2211 i, n (Fin.castLE \u22ef i) + \u2191ij.snd = \u2191ij.snd"}, {"line": "rw [add_eq_right]", "tactic_state": "n : Fin 1 \u2192 \u2115\nij : (i : Fin 1) \u00d7 Fin (n i)\n\u22a2 \u2211 i, n (Fin.castLE \u22ef i) = 0"}, {"line": "apply @Finset.sum_of_isEmpty _ _ _ _ (by simpa using Fin.isEmpty')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_eq_dif {p : Prop} [Decidable p] (f : p \u2192 M) :\n    \u220f\u1da0 i, f i = if h : p then f h else 1 := by\n  split_ifs with h\n  \u00b7 haveI : Unique p := \u27e8\u27e8h\u27e9, fun _ => rfl\u27e9\n    exact finprod_unique f\n  \u00b7 haveI : IsEmpty p := \u27e8h\u27e9\n    exact finprod_of_isEmpty f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d\u00b9 : CommMonoid M\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\n\u22a2 \u220f\u1da0 (i : p), f i = if h : p then f h else 1"}, {"line": "split_ifs with h", "tactic_state": "case pos\nM : Type u_2\ninst\u271d\u00b9 : CommMonoid M\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : p\n\u22a2 \u220f\u1da0 (i : p), f i = f h\n---\ncase neg\nM : Type u_2\ninst\u271d\u00b9 : CommMonoid M\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\n\u22a2 \u220f\u1da0 (i : p), f i = 1"}, {"line": "\u00b7 haveI : Unique p := \u27e8\u27e8h\u27e9, fun _ => rfl\u27e9\n    exact finprod_unique f", "tactic_state": "case neg\nM : Type u_2\ninst\u271d\u00b9 : CommMonoid M\np : Prop\ninst\u271d : Decidable p\nf : p \u2192 M\nh : \u00acp\n\u22a2 \u220f\u1da0 (i : p), f i = 1"}, {"line": "\u00b7 haveI : IsEmpty p := \u27e8h\u27e9\n    exact finprod_of_isEmpty f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_congr_Prop {p q : Prop} {f : p \u2192 M} {g : q \u2192 M} (hpq : p = q)\n    (hfg : \u2200 h : q, f (hpq.mpr h) = g h) : finprod f = finprod g := by\n  subst q\n  exact finprod_congr hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\np q : Prop\nf : p \u2192 M\ng : q \u2192 M\nhpq : p = q\nhfg : \u2200 (h : q), f \u22ef = g h\n\u22a2 finprod f = finprod g"}, {"line": "subst q", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\np : Prop\nf g : p \u2192 M\nhfg : \u2200 (h : p), f \u22ef = g h\n\u22a2 finprod f = finprod g"}, {"line": "exact finprod_congr hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_induction {f : \u03b1 \u2192 M} (p : M \u2192 Prop) (hp\u2080 : p 1)\n    (hp\u2081 : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (hp\u2082 : \u2200 i, p (f i)) : p (\u220f\u1da0 i, f i) := by\n  rw [finprod]\n  split_ifs\n  exacts [Finset.prod_induction _ _ hp\u2081 hp\u2080 fun i _ => hp\u2082 _, hp\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\n\u03b1 : Sort u_4\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\np : M \u2192 Prop\nhp\u2080 : p 1\nhp\u2081 : \u2200 (x y : M), p x \u2192 p y \u2192 p (x * y)\nhp\u2082 : \u2200 (i : \u03b1), p (f i)\n\u22a2 p (\u220f\u1da0 (i : \u03b1), f i)"}, {"line": "rw [finprod]", "tactic_state": "M : Type u_2\n\u03b1 : Sort u_4\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\np : M \u2192 Prop\nhp\u2080 : p 1\nhp\u2081 : \u2200 (x y : M), p x \u2192 p y \u2192 p (x * y)\nhp\u2082 : \u2200 (i : \u03b1), p (f i)\n\u22a2 p (if h : (mulSupport ((fun i => f i) \u2218 PLift.down)).Finite then \u220f i \u2208 h.toFinset, f i.down else 1)"}, {"line": "split_ifs", "tactic_state": "case pos\nM : Type u_2\n\u03b1 : Sort u_4\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\np : M \u2192 Prop\nhp\u2080 : p 1\nhp\u2081 : \u2200 (x y : M), p x \u2192 p y \u2192 p (x * y)\nhp\u2082 : \u2200 (i : \u03b1), p (f i)\nh\u271d : (mulSupport ((fun i => f i) \u2218 PLift.down)).Finite\n\u22a2 p (\u220f i \u2208 h\u271d.toFinset, f i.down)\n---\ncase neg\nM : Type u_2\n\u03b1 : Sort u_4\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\np : M \u2192 Prop\nhp\u2080 : p 1\nhp\u2081 : \u2200 (x y : M), p x \u2192 p y \u2192 p (x * y)\nhp\u2082 : \u2200 (i : \u03b1), p (f i)\nh\u271d : \u00ac(mulSupport ((fun i => f i) \u2218 PLift.down)).Finite\n\u22a2 p 1"}, {"line": "exacts [Finset.prod_induction _ _ hp\u2081 hp\u2080 fun i _ => hp\u2082 _, hp\u2080]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finsum_smul {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    (f : \u03b9 \u2192 R) (x : M) : (\u2211\u1da0 i, f i) \u2022 x = \u2211\u1da0 i, f i \u2022 x := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  \u00b7 simp\n  \u00b7 exact ((smulAddHom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : \u03b9 \u2192 R\nx : M\n\u22a2 (\u2211\u1da0 (i : \u03b9), f i) \u2022 x = \u2211\u1da0 (i : \u03b9), f i \u2022 x"}, {"line": "rcases eq_or_ne x 0 with (rfl | hx)", "tactic_state": "case inl\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : \u03b9 \u2192 R\n\u22a2 (\u2211\u1da0 (i : \u03b9), f i) \u2022 sorry = \u2211\u1da0 (i : \u03b9), f i \u2022 sorry\n---\ncase inr\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : \u03b9 \u2192 R\nx : M\nhx : x \u2260 sorry\n\u22a2 (\u2211\u1da0 (i : \u03b9), f i) \u2022 x = \u2211\u1da0 (i : \u03b9), f i \u2022 x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : \u03b9 \u2192 R\nx : M\nhx : x \u2260 sorry\n\u22a2 (\u2211\u1da0 (i : \u03b9), f i) \u2022 x = \u2211\u1da0 (i : \u03b9), f i \u2022 x"}, {"line": "\u00b7 exact ((smulAddHom R M).flip x).map_finsum_of_injective (smul_left_injective R hx) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_finsum {R M : Type*} [Semiring R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] (c : R) (f : \u03b9 \u2192 M) : (c \u2022 \u2211\u1da0 i, f i) = \u2211\u1da0 i, c \u2022 f i := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  \u00b7 simp\n  \u00b7 exact (smulAddHom R M c).map_finsum_of_injective (smul_right_injective M hc) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nf : \u03b9 \u2192 M\n\u22a2 c \u2022 \u2211\u1da0 (i : \u03b9), f i = \u2211\u1da0 (i : \u03b9), c \u2022 f i"}, {"line": "rcases eq_or_ne c 0 with (rfl | hc)", "tactic_state": "case inl\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nf : \u03b9 \u2192 M\n\u22a2 sorry \u2022 \u2211\u1da0 (i : \u03b9), f i = \u2211\u1da0 (i : \u03b9), sorry \u2022 f i\n---\ncase inr\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nf : \u03b9 \u2192 M\nhc : c \u2260 sorry\n\u22a2 c \u2022 \u2211\u1da0 (i : \u03b9), f i = \u2211\u1da0 (i : \u03b9), c \u2022 f i"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b9 : Sort u_6\nR : Type u_7\nM : Type u_8\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nf : \u03b9 \u2192 M\nhc : c \u2260 sorry\n\u22a2 c \u2022 \u2211\u1da0 (i : \u03b9), f i = \u2211\u1da0 (i : \u03b9), c \u2022 f i"}, {"line": "\u00b7 exact (smulAddHom R M c).map_finsum_of_injective (smul_right_injective M hc) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_eq_mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    \u220f\u1da0 _ : a \u2208 s, f a = mulIndicator s f a := by\n  classical convert finprod_eq_if (M := M) (p := a \u2208 s) (x := f a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (_ : a \u2208 s), f a = s.mulIndicator f a"}, {"line": "classical convert finprod_eq_if (M := M) (p := a \u2208 s) (x := f a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_apply_ne_one (f : \u03b1 \u2192 M) (a : \u03b1) : \u220f\u1da0 _ : f a \u2260 1, f a = f a := by\n  rw [\u2190 mem_mulSupport]\n  rw [finprod_eq_mulIndicator_apply]\n  rw [mulIndicator_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (_ : f a \u2260 1), f a = f a"}, {"line": "rw [\u2190 mem_mulSupport]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (_ : a \u2208 mulSupport f), f a = f a"}, {"line": "rw [finprod_eq_mulIndicator_apply]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 (mulSupport f).mulIndicator f a = f a"}, {"line": "rw [mulIndicator_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finprod_mem_mulSupport (f : \u03b1 \u2192 M) : \u220f\u1da0 a \u2208 mulSupport f, f a = \u220f\u1da0 a, f a := by\n  rw [finprod_mem_def]\n  rw [mulIndicator_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 mulSupport f), f a = \u220f\u1da0 (a : \u03b1), f a"}, {"line": "rw [finprod_mem_def]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\n\u22a2 \u220f\u1da0 (a : \u03b1), (mulSupport f).mulIndicator f a = \u220f\u1da0 (a : \u03b1), f a"}, {"line": "rw [mulIndicator_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_of_infinite_mulSupport {f : \u03b1 \u2192 M} (hf : (mulSupport f).Infinite) :\n    \u220f\u1da0 i, f i = 1 := by classical rw [finprod_def, dif_neg hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nhf : (mulSupport f).Infinite\n\u22a2 \u220f\u1da0 (i : \u03b1), f i = 1"}, {"line": "classical rw [finprod_def, dif_neg hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_eq_prod (f : \u03b1 \u2192 M) (hf : (mulSupport f).Finite) :\n    \u220f\u1da0 i : \u03b1, f i = \u220f i \u2208 hf.toFinset, f i := by classical rw [finprod_def, dif_pos hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nhf : (mulSupport f).Finite\n\u22a2 \u220f\u1da0 (i : \u03b1), f i = \u220f i \u2208 hf.toFinset, f i"}, {"line": "classical rw [finprod_def, dif_pos hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_finset_prod {\u03b1 F : Type*} [Fintype \u03b1] [EquivLike F M N] [MulEquivClass F M N] (f : F)\n    (g : \u03b1 \u2192 M) : f (\u220f i : \u03b1, g i) = \u220f i : \u03b1, f (g i) := by\n  simp [\u2190 finprod_eq_prod_of_fintype, MulEquivClass.map_finprod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_11\nN : Type u_12\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommMonoid N\n\u03b1 : Type u_13\nF : Type u_14\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : EquivLike F M N\ninst\u271d : MulEquivClass F M N\nf : F\ng : \u03b1 \u2192 M\n\u22a2 f (\u220f i, g i) = \u220f i, f (g i)"}, {"line": "simp [\u2190 finprod_eq_prod_of_fintype, MulEquivClass.map_finprod]", "tactic_state": "M : Type u_11\nN : Type u_12\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : CommMonoid N\n\u03b1 : Type u_13\nF : Type u_14\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : EquivLike F M N\ninst\u271d : MulEquivClass F M N\nf : F\ng : \u03b1 \u2192 M\n\u22a2 f (\u220f\u1da0 (i : \u03b1), g i) = \u220f\u1da0 (i : \u03b1), f (g i)"}]}
{"declaration": "theorem finprod_mem_eq_one_of_forall_eq_one {f : \u03b1 \u2192 M} {s : Set \u03b1} (h : \u2200 x \u2208 s, f x = 1) :\n    \u220f\u1da0 i \u2208 s, f i = 1 := by simp +contextual [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\nh : \u2200 x \u2208 s, f x = 1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = 1"}, {"line": "simp +contextual [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_inter_mulSupport (f : \u03b1 \u2192 M) (s : Set \u03b1) :\n    \u220f\u1da0 i \u2208 s \u2229 mulSupport f, f i = \u220f\u1da0 i \u2208 s, f i := by\n  rw [finprod_mem_def]\n  rw [finprod_mem_def]\n  rw [mulIndicator_inter_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s \u2229 mulSupport f), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i"}, {"line": "rw [finprod_mem_def]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (a : \u03b1), (s \u2229 mulSupport f).mulIndicator f a = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i"}, {"line": "rw [finprod_mem_def]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (a : \u03b1), (s \u2229 mulSupport f).mulIndicator f a = \u220f\u1da0 (a : \u03b1), s.mulIndicator f a"}, {"line": "rw [mulIndicator_inter_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_inter_mulSupport_eq (f : \u03b1 \u2192 M) (s t : Set \u03b1)\n    (h : s \u2229 mulSupport f = t \u2229 mulSupport f) : \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 i \u2208 t, f i := by\n  rw [\u2190 finprod_mem_inter_mulSupport]\n  rw [h]\n  rw [finprod_mem_inter_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns t : Set \u03b1\nh : s \u2229 mulSupport f = t \u2229 mulSupport f\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i"}, {"line": "rw [\u2190 finprod_mem_inter_mulSupport]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns t : Set \u03b1\nh : s \u2229 mulSupport f = t \u2229 mulSupport f\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s \u2229 mulSupport f), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i"}, {"line": "rw [h]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns t : Set \u03b1\nh : s \u2229 mulSupport f = t \u2229 mulSupport f\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t \u2229 mulSupport f), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 t), f i"}, {"line": "rw [finprod_mem_inter_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_eq_one_of_forall_eq_one {f : \u03b1 \u2192 M} (h : \u2200 x, f x = 1) : \u220f\u1da0 i, f i = 1 := by\n  simp +contextual [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nh : \u2200 (x : \u03b1), f x = 1\n\u22a2 \u220f\u1da0 (i : \u03b1), f i = 1"}, {"line": "simp +contextual [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_one (s : Set \u03b1) : (\u220f\u1da0 i \u2208 s, (1 : M)) = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), 1 = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_of_eqOn_one (hf : s.EqOn f 1) : \u220f\u1da0 i \u2208 s, f i = 1 := by\n  rw [\u2190 finprod_mem_one s]\n  exact finprod_mem_congr rfl hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhf : EqOn f 1 s\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = 1"}, {"line": "rw [\u2190 finprod_mem_one s]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\nhf : EqOn f 1 s\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), 1"}, {"line": "exact finprod_mem_congr rfl hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_ne_one_of_finprod_mem_ne_one (h : \u220f\u1da0 i \u2208 s, f i \u2260 1) : \u2203 x \u2208 s, f x \u2260 1 := by\n  by_contra! h'\n  exact h (finprod_mem_of_eqOn_one h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\nh : \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i \u2260 1\n\u22a2 \u2203 x \u2208 s, f x \u2260 1"}, {"line": "by_contra! h'", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\nh : \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i \u2260 1\nh' : \u2200 x \u2208 s, f x = 1\n\u22a2 False"}, {"line": "exact h (finprod_mem_of_eqOn_one h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_empty : (\u220f\u1da0 i \u2208 (\u2205 : Set \u03b1), f i) = 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2205), f i = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_singleton : (\u220f\u1da0 i \u2208 ({a} : Set \u03b1), f i) = f a := by\n  rw [\u2190 Finset.coe_singleton]\n  rw [finprod_mem_coe_finset]\n  rw [Finset.prod_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 {a}), f i = f a"}, {"line": "rw [\u2190 Finset.coe_singleton]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 \u2191{a}), f i = f a"}, {"line": "rw [finprod_mem_coe_finset]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f i \u2208 {a}, f i = f a"}, {"line": "rw [Finset.prod_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_cond_eq_right : (\u220f\u1da0 (i) (_ : a = i), f i) = f a := by simp [@eq_comm _ a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : a = i), f i = f a"}, {"line": "simp [@eq_comm _ a]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_pair (h : a \u2260 b) : (\u220f\u1da0 i \u2208 ({a, b} : Set \u03b1), f i) = f a * f b := by\n  rw [finprod_mem_insert]\n  rw [finprod_mem_singleton]\n  exacts [h, finite_singleton b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 {a, b}), f i = f a * f b"}, {"line": "rw [finprod_mem_insert]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 f a * \u220f\u1da0 (i : \u03b1) (_ : i \u2208 {b}), f i = f a * f b\n---\ncase h\n\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 a \u2209 {b}\n---\ncase hs\n\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 {b}.Finite"}, {"line": "rw [finprod_mem_singleton]", "tactic_state": "case h\n\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 a \u2209 {b}\n---\ncase hs\n\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\na b : \u03b1\nh : a \u2260 b\n\u22a2 {b}.Finite"}, {"line": "exacts [h, finite_singleton b]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_image' {s : Set \u03b2} {g : \u03b2 \u2192 \u03b1} (hg : (s \u2229 mulSupport (f \u2218 g)).InjOn g) :\n    \u220f\u1da0 i \u2208 g '' s, f i = \u220f\u1da0 j \u2208 s, f (g j) := by\n  classical\n    by_cases hs : (s \u2229 mulSupport (f \u2218 g)).Finite\n    \u00b7 have hg : \u2200 x \u2208 hs.toFinset, \u2200 y \u2208 hs.toFinset, g x = g y \u2192 x = y := by\n        simpa only [hs.mem_toFinset]\n      have := finprod_mem_eq_prod (comp f g) hs\n      unfold Function.comp at this\n      rw [this]\n      rw [\u2190 Finset.prod_image hg]\n      refine finprod_mem_eq_prod_of_inter_mulSupport_eq f ?_\n      rw [Finset.coe_image]\n      rw [hs.coe_toFinset]\n      rw [\u2190 image_inter_mulSupport_eq]\n      rw [inter_assoc]\n      rw [inter_self]\n    \u00b7 unfold Function.comp at hs\n      rw [finprod_mem_eq_one_of_infinite hs]\n      rw [finprod_mem_eq_one_of_infinite]\n      rwa [image_inter_mulSupport_eq, infinite_image_iff hg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b2\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (s \u2229 mulSupport (f \u2218 g))\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 g '' s), f i = \u220f\u1da0 (j : \u03b2) (_ : j \u2208 s), f (g j)"}, {"line": "classical\n    by_cases hs : (s \u2229 mulSupport (f \u2218 g)).Finite\n    \u00b7 have hg : \u2200 x \u2208 hs.toFinset, \u2200 y \u2208 hs.toFinset, g x = g y \u2192 x = y := by\n        simpa only [hs.mem_toFinset]\n      have := finprod_mem_eq_prod (comp f g) hs\n      unfold Function.comp at this\n      rw [this]\n      rw [\u2190 Finset.prod_image hg]\n      refine finprod_mem_eq_prod_of_inter_mulSupport_eq f ?_\n      rw [Finset.coe_image]\n      rw [hs.coe_toFinset]\n      rw [\u2190 image_inter_mulSupport_eq]\n      rw [inter_assoc]\n      rw [inter_self]\n    \u00b7 unfold Function.comp at hs\n      rw [finprod_mem_eq_one_of_infinite hs]\n      rw [finprod_mem_eq_one_of_infinite]\n      rwa [image_inter_mulSupport_eq, infinite_image_iff hg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_range' {g : \u03b2 \u2192 \u03b1} (hg : (mulSupport (f \u2218 g)).InjOn g) :\n    \u220f\u1da0 i \u2208 range g, f i = \u220f\u1da0 j, f (g j) := by\n  rw [\u2190 image_univ]\n  rw [finprod_mem_image']\n  rw [finprod_mem_univ]\n  rwa [univ_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (mulSupport (f \u2218 g))\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 range g), f i = \u220f\u1da0 (j : \u03b2), f (g j)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (mulSupport (f \u2218 g))\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 g '' univ), f i = \u220f\u1da0 (j : \u03b2), f (g j)"}, {"line": "rw [finprod_mem_image']", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (mulSupport (f \u2218 g))\n\u22a2 \u220f\u1da0 (j : \u03b2) (_ : j \u2208 univ), f (g j) = \u220f\u1da0 (j : \u03b2), f (g j)\n---\n\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (mulSupport (f \u2218 g))\n\u22a2 InjOn g (univ \u2229 mulSupport (f \u2218 g))"}, {"line": "rw [finprod_mem_univ]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 \u03b1\nhg : InjOn g (mulSupport (f \u2218 g))\n\u22a2 InjOn g (univ \u2229 mulSupport (f \u2218 g))"}, {"line": "rwa [univ_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_eq_of_bijOn {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2)\n    (he\u2080 : s.BijOn e t) (he\u2081 : \u2200 x \u2208 s, f x = g (e x)) : \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 j \u2208 t, g j := by\n  rw [\u2190 Set.BijOn.image_eq he\u2080]\n  rw [finprod_mem_image he\u2080.2.1]\n  exact finprod_mem_congr rfl he\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\ne : \u03b1 \u2192 \u03b2\nhe\u2080 : BijOn e s t\nhe\u2081 : \u2200 x \u2208 s, f x = g (e x)\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = \u220f\u1da0 (j : \u03b2) (_ : j \u2208 t), g j"}, {"line": "rw [\u2190 Set.BijOn.image_eq he\u2080]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\ne : \u03b1 \u2192 \u03b2\nhe\u2080 : BijOn e s t\nhe\u2081 : \u2200 x \u2208 s, f x = g (e x)\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = \u220f\u1da0 (j : \u03b2) (_ : j \u2208 e '' s), g j"}, {"line": "rw [finprod_mem_image he\u2080.2.1]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\ne : \u03b1 \u2192 \u03b2\nhe\u2080 : BijOn e s t\nhe\u2081 : \u2200 x \u2208 s, f x = g (e x)\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i = \u220f\u1da0 (j : \u03b1) (_ : j \u2208 s), g (e j)"}, {"line": "exact finprod_mem_congr rfl he\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_set_coe_eq_finprod_mem (s : Set \u03b1) : \u220f\u1da0 j : s, f j = \u220f\u1da0 i \u2208 s, f i := by\n  rw [\u2190 finprod_mem_range]\n  rw [Subtype.range_coe]\n  exact Subtype.coe_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (j : \u2191s), f \u2191j = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i"}, {"line": "rw [\u2190 finprod_mem_range]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 \u220f\u1da0 (i : \u03b1) (_ : i \u2208 range Subtype.val), f i = \u220f\u1da0 (i : \u03b1) (_ : i \u2208 s), f i\n---\n\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 Injective Subtype.val"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\ns : Set \u03b1\n\u22a2 Injective Subtype.val"}, {"line": "exact Subtype.coe_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_biUnion {I : Set \u03b9} {t : \u03b9 \u2192 Set \u03b1} (h : I.PairwiseDisjoint t) (hI : I.Finite)\n    (ht : \u2200 i \u2208 I, (t i).Finite) : \u220f\u1da0 a \u2208 \u22c3 x \u2208 I, t x, f a = \u220f\u1da0 i \u2208 I, \u220f\u1da0 j \u2208 t i, f j := by\n  haveI := hI.fintype\n  rw [biUnion_eq_iUnion]\n  rw [finprod_mem_iUnion]\n  rw [\u2190 finprod_set_coe_eq_finprod_mem]\n  exacts [fun x y hxy => h x.2 y.2 (Subtype.coe_injective.ne hxy), fun b => ht b b.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 \u22c3 x \u2208 I, t x), f a = \u220f\u1da0 (i : \u03b9) (_ : i \u2208 I) (j : \u03b1) (_ : j \u2208 t i), f j"}, {"line": "haveI := hI.fintype", "tactic_state": "\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 \u22c3 x \u2208 I, t x), f a = \u220f\u1da0 (i : \u03b9) (_ : i \u2208 I) (j : \u03b1) (_ : j \u2208 t i), f j"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 \u22c3 x, t \u2191x), f a = \u220f\u1da0 (i : \u03b9) (_ : i \u2208 I) (j : \u03b1) (_ : j \u2208 t i), f j"}, {"line": "rw [finprod_mem_iUnion]", "tactic_state": "\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 \u220f\u1da0 (i : \u2191I) (a : \u03b1) (_ : a \u2208 t \u2191i), f a = \u220f\u1da0 (i : \u03b9) (_ : i \u2208 I) (j : \u03b1) (_ : j \u2208 t i), f j\n---\ncase h\n\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 Pairwise (onFun Disjoint fun x => t \u2191x)\n---\ncase ht\n\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 \u2200 (i : \u2191I), (t \u2191i).Finite"}, {"line": "rw [\u2190 finprod_set_coe_eq_finprod_mem]", "tactic_state": "case h\n\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 Pairwise (onFun Disjoint fun x => t \u2191x)\n---\ncase ht\n\u03b1 : Type u_7\n\u03b9 : Type u_9\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nI : Set \u03b9\nt : \u03b9 \u2192 Set \u03b1\nh : I.PairwiseDisjoint t\nhI : I.Finite\nht : \u2200 i \u2208 I, (t i).Finite\nthis : Fintype \u2191I\n\u22a2 \u2200 (i : \u2191I), (t \u2191i).Finite"}, {"line": "exacts [fun x y hxy => h x.2 y.2 (Subtype.coe_injective.ne hxy), fun b => ht b b.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_sUnion {t : Set (Set \u03b1)} (h : t.PairwiseDisjoint id) (ht\u2080 : t.Finite)\n    (ht\u2081 : \u2200 x \u2208 t, Set.Finite x) : \u220f\u1da0 a \u2208 \u22c3\u2080 t, f a = \u220f\u1da0 s \u2208 t, \u220f\u1da0 a \u2208 s, f a := by\n  rw [Set.sUnion_eq_biUnion]\n  exact finprod_mem_biUnion h ht\u2080 ht\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nt : Set (Set \u03b1)\nh : t.PairwiseDisjoint id\nht\u2080 : t.Finite\nht\u2081 : \u2200 x \u2208 t, x.Finite\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 \u22c3\u2080 t), f a = \u220f\u1da0 (s : Set \u03b1) (_ : s \u2208 t) (a : \u03b1) (_ : a \u2208 s), f a"}, {"line": "rw [Set.sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_7\nM : Type u_11\ninst\u271d : CommMonoid M\nf : \u03b1 \u2192 M\nt : Set (Set \u03b1)\nh : t.PairwiseDisjoint id\nht\u2080 : t.Finite\nht\u2081 : \u2200 x \u2208 t, x.Finite\n\u22a2 \u220f\u1da0 (a : \u03b1) (_ : a \u2208 \u22c3 i \u2208 t, i), f a = \u220f\u1da0 (s : Set \u03b1) (_ : s \u2208 t) (a : \u03b1) (_ : a \u2208 s), f a"}, {"line": "exact finprod_mem_biUnion h ht\u2080 ht\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_finset_product (s : Finset (\u03b1 \u00d7 \u03b2)) (f : \u03b1 \u00d7 \u03b2 \u2192 M) :\n    (\u220f\u1da0 (ab) (_ : ab \u2208 s), f ab) = \u220f\u1da0 (a) (b) (_ : (a, b) \u2208 s), f (a, b) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\ns : Finset (\u03b1 \u00d7 \u03b2)\nf : \u03b1 \u00d7 \u03b2 \u2192 M\n\u22a2 \u220f\u1da0 (ab : \u03b1 \u00d7 \u03b2) (_ : ab \u2208 s), f ab = \u220f\u1da0 (a : \u03b1) (b : \u03b2) (_ : (a, b) \u2208 s), f (a, b)"}, {"line": "classical\n    rw [finprod_mem_finset_product']\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finprod_mem_finset_product\u2083 {\u03b3 : Type*} (s : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)) (f : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M) :\n    (\u220f\u1da0 (abc) (_ : abc \u2208 s), f abc) = \u220f\u1da0 (a) (b) (c) (_ : (a, b, c) \u2208 s), f (a, b, c) := by\n  classical\n    rw [finprod_mem_finset_product']\n    simp_rw [finprod_mem_finset_product']\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finprod.lean", "context": {"open": ["Function Set", "Classical in", "Classical in", "Batteries.ExtendedBinder"], "variables": ["{G M N : Type*} {\u03b1 \u03b2 \u03b9 : Sort*} [CommMonoid M] [CommMonoid N]", "{\u03b1 \u03b2 \u03b9 G M N : Type*} [CommMonoid M] [CommMonoid N]", "{f g : \u03b1 \u2192 M} {a b : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\nM : Type u_11\ninst\u271d : CommMonoid M\n\u03b3 : Type u_13\ns : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)\nf : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M\n\u22a2 \u220f\u1da0 (abc : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3) (_ : abc \u2208 s), f abc = \u220f\u1da0 (a : \u03b1) (b : \u03b2) (c : \u03b3) (_ : (a, b, c) \u2208 s), f (a, b, c)"}, {"line": "classical\n    rw [finprod_mem_finset_product']\n    simp_rw [finprod_mem_finset_product']\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_Ico_eq_div {\u03b4 : Type*} [CommGroup \u03b4] (f : \u2115 \u2192 \u03b4) {m n : \u2115} (h : m \u2264 n) :\n    \u220f k \u2208 Ico m n, f k = (\u220f k \u2208 range n, f k) / \u220f k \u2208 range m, f k := by\n  simpa only [div_eq_mul_inv] using prod_Ico_eq_mul_inv f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Intervals.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 M : Type*}", "[PartialOrder \u03b1] [CommMonoid M] {f : \u03b1 \u2192 M} {a b : \u03b1}", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[Fintype \u03b1] [LinearOrder \u03b1] [LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[CommMonoid M] {s\u2082 s\u2081 s : Finset \u03b1} {a : \u03b1} {g f : \u03b1 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_4\nIco : x\u271d\u00b9\nx\u271d : Sort u_5\nrange : x\u271d\n\u03b4 : Type u_3\ninst\u271d : CommGroup \u03b4\nf : \u2115 \u2192 \u03b4\nm n : \u2115\nh : m \u2264 n\n\u22a2 \u220f k \u2208 sorry, f k = (\u220f k \u2208 sorry, f k) / \u220f k \u2208 sorry, f k"}, {"line": "simpa only [div_eq_mul_inv] using prod_Ico_eq_mul_inv f h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_Ico_eq_prod_range (f : \u2115 \u2192 M) (m n : \u2115) :\n    \u220f k \u2208 Ico m n, f k = \u220f k \u2208 range (n - m), f (m + k) := by\n  by_cases h : m \u2264 n\n  \u00b7 rw [\u2190 Nat.Ico_zero_eq_range, prod_Ico_add, zero_add, tsub_add_cancel_of_le h]\n  \u00b7 replace h : n \u2264 m := le_of_not_ge h\n    rw [Ico_eq_empty_of_le h]\n    rw [tsub_eq_zero_iff_le.mpr h]\n    rw [range_zero]\n    rw [prod_empty]\n    rw [prod_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Intervals.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 M : Type*}", "[PartialOrder \u03b1] [CommMonoid M] {f : \u03b1 \u2192 M} {a b : \u03b1}", "[LocallyFiniteOrder \u03b1]", "[LocallyFiniteOrderTop \u03b1]", "[LocallyFiniteOrderBot \u03b1]", "[Fintype \u03b1] [LinearOrder \u03b1] [LocallyFiniteOrderTop \u03b1] [LocallyFiniteOrderBot \u03b1]", "[CommMonoid M] {s\u2082 s\u2081 s : Finset \u03b1} {a : \u03b1} {g f : \u03b1 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d\u00b9 inst\u271d : CommMonoid M\nx\u271d\u00b9 : Sort u_3\nIco : x\u271d\u00b9\nx\u271d : Sort u_4\nrange : x\u271d\nf : \u2115 \u2192 M\nm n : \u2115\n\u22a2 \u220f k \u2208 sorry, f k = \u220f k \u2208 sorry, f (m + k)"}, {"line": "by_cases h : m \u2264 n", "tactic_state": "case pos\nM : Type u_2\ninst\u271d\u00b9 inst\u271d : CommMonoid M\nx\u271d\u00b9 : Sort u_3\nIco : x\u271d\u00b9\nx\u271d : Sort u_4\nrange : x\u271d\nf : \u2115 \u2192 M\nm n : \u2115\nh : m \u2264 n\n\u22a2 \u220f k \u2208 sorry, f k = \u220f k \u2208 sorry, f (m + k)\n---\ncase neg\nM : Type u_2\ninst\u271d\u00b9 inst\u271d : CommMonoid M\nx\u271d\u00b9 : Sort u_3\nIco : x\u271d\u00b9\nx\u271d : Sort u_4\nrange : x\u271d\nf : \u2115 \u2192 M\nm n : \u2115\nh : \u00acm \u2264 n\n\u22a2 \u220f k \u2208 sorry, f k = \u220f k \u2208 sorry, f (m + k)"}, {"line": "\u00b7 rw [\u2190 Nat.Ico_zero_eq_range, prod_Ico_add, zero_add, tsub_add_cancel_of_le h]", "tactic_state": "case neg\nM : Type u_2\ninst\u271d\u00b9 inst\u271d : CommMonoid M\nx\u271d\u00b9 : Sort u_3\nIco : x\u271d\u00b9\nx\u271d : Sort u_4\nrange : x\u271d\nf : \u2115 \u2192 M\nm n : \u2115\nh : \u00acm \u2264 n\n\u22a2 \u220f k \u2208 sorry, f k = \u220f k \u2208 sorry, f (m + k)"}, {"line": "\u00b7 replace h : n \u2264 m := le_of_not_ge h\n    rw [Ico_eq_empty_of_le h]\n    rw [tsub_eq_zero_iff_le.mpr h]\n    rw [range_zero]\n    rw [prod_empty]\n    rw [prod_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_Ioc_by_parts (hmn : m < n) :\n    \u2211 i \u2208 Ioc m n, f i \u2022 g i =\n      f n \u2022 G (n + 1) - f (m + 1) \u2022 G (m + 1)\n        - \u2211 i \u2208 Ioc m (n - 1), (f (i + 1) - f i) \u2022 G (i + 1) := by\n  simpa only [\u2190 Nat.Ico_succ_succ, Nat.succ_eq_add_one, Nat.sub_add_cancel (Nat.one_le_of_lt hmn),\n    add_tsub_cancel_right] using sum_Ico_by_parts f g (Nat.succ_lt_succ hmn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Module.lean", "context": {"open": [], "variables": ["{R M : Type*} [Ring R] [AddCommGroup M] [Module R M] (f : \u2115 \u2192 R) (g : \u2115 \u2192 M) {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nm n : \u2115\nx\u271d\u00b9 : Sort u_3\nIoc : x\u271d\u00b9\nx\u271d : Sort u_4\nG : x\u271d\nhmn : m < n\n\u22a2 \u2211 i \u2208 sorry, f i \u2022 g i = f n \u2022 sorry - f (m + 1) \u2022 sorry - \u2211 i \u2208 sorry, (f (i + 1) - f i) \u2022 sorry"}, {"line": "simpa only [\u2190 Nat.Ico_succ_succ, Nat.succ_eq_add_one, Nat.sub_add_cancel (Nat.one_le_of_lt hmn),\n    add_tsub_cancel_right] using sum_Ico_by_parts f g (Nat.succ_lt_succ hmn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_range_by_parts :\n    \u2211 i \u2208 range n, f i \u2022 g i =\n      f (n - 1) \u2022 G n - \u2211 i \u2208 range (n - 1), (f (i + 1) - f i) \u2022 G (i + 1) := by\n  by_cases hn : n = 0\n  \u00b7 simp [hn]\n  \u00b7 rw [range_eq_Ico, sum_Ico_by_parts f g (Nat.pos_of_ne_zero hn), sum_range_zero, smul_zero,\n      sub_zero, range_eq_Ico]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Module.lean", "context": {"open": [], "variables": ["{R M : Type*} [Ring R] [AddCommGroup M] [Module R M] (f : \u2115 \u2192 R) (g : \u2115 \u2192 M) {m n : \u2115}", "(n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nn : \u2115\nx\u271d\u00b9 : Sort u_3\nrange : x\u271d\u00b9\nx\u271d : Sort u_4\nG : x\u271d\n\u22a2 \u2211 i \u2208 sorry, f i \u2022 g i = f (n - 1) \u2022 sorry - \u2211 i \u2208 sorry, (f (i + 1) - f i) \u2022 sorry"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nn : \u2115\nx\u271d\u00b9 : Sort u_3\nrange : x\u271d\u00b9\nx\u271d : Sort u_4\nG : x\u271d\nhn : n = 0\n\u22a2 \u2211 i \u2208 sorry, f i \u2022 g i = f (n - 1) \u2022 sorry - \u2211 i \u2208 sorry, (f (i + 1) - f i) \u2022 sorry\n---\ncase neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nn : \u2115\nx\u271d\u00b9 : Sort u_3\nrange : x\u271d\u00b9\nx\u271d : Sort u_4\nG : x\u271d\nhn : \u00acn = 0\n\u22a2 \u2211 i \u2208 sorry, f i \u2022 g i = f (n - 1) \u2022 sorry - \u2211 i \u2208 sorry, (f (i + 1) - f i) \u2022 sorry"}, {"line": "\u00b7 simp [hn]", "tactic_state": "case neg\nR : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nf : \u2115 \u2192 R\ng : \u2115 \u2192 M\nn : \u2115\nx\u271d\u00b9 : Sort u_3\nrange : x\u271d\u00b9\nx\u271d : Sort u_4\nG : x\u271d\nhn : \u00acn = 0\n\u22a2 \u2211 i \u2208 sorry, f i \u2022 g i = f (n - 1) \u2022 sorry - \u2211 i \u2208 sorry, (f (i + 1) - f i) \u2022 sorry"}, {"line": "\u00b7 rw [range_eq_Ico, sum_Ico_by_parts f g (Nat.pos_of_ne_zero hn), sum_range_zero, smul_zero,\n      sub_zero, range_eq_Ico]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_eq_sum_univ {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] {R : Type*} [NonAssocSemiring R]\n    (x : \u03b9 \u2192 R) : x = \u2211 i, (x i) \u2022 fun j => if i = j then (1 : R) else 0 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Pi.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\nR : Type u_5\ninst\u271d : NonAssocSemiring R\nx : \u03b9 \u2192 R\n\u22a2 x = \u2211 i, x i \u2022 fun j => if i = j then 1 else 0"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\nR : Type u_5\ninst\u271d : NonAssocSemiring R\nx : \u03b9 \u2192 R\nx\u271d : \u03b9\n\u22a2 x x\u271d = (\u2211 i, x i \u2022 fun j => if i = j then 1 else 0) x\u271d"}, {"line": "simp", "tactic_state": "case h\n\u03b9 : Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\nR : Type u_5\ninst\u271d : NonAssocSemiring R\nx : \u03b9 \u2192 R\nx\u271d : \u03b9\n\u22a2 x x\u271d = x x\u271d * 1"}]}
{"declaration": "lemma prod_indicator_const_apply (s : Finset \u03b9) (f : \u03b9 \u2192 Set \u03ba) (g : \u03ba \u2192 \u03b1) (j : \u03ba) :\n    \u220f i \u2208 s, (f i).indicator g j = (\u22c2 x \u2208 s, f x).indicator (g ^ #s) j := by\n  simp [prod_indicator_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Pi.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\n\u03b1 : Type u_3\ninst\u271d : CommSemiring \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 Set \u03ba\ng : \u03ba \u2192 \u03b1\nj : \u03ba\n\u22a2 \u220f i \u2208 s, (f i).indicator g j = (\u22c2 x \u2208 s, f x).indicator (g ^ s.card) j"}, {"line": "simp [prod_indicator_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_indicator_const (s : Finset \u03b9) (f : \u03b9 \u2192 Set \u03ba) (g : \u03ba \u2192 \u03b1) :\n    \u220f i \u2208 s, (f i).indicator g = (\u22c2 x \u2208 s, f x).indicator (g ^ #s) := by simp [prod_indicator]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Pi.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\n\u03b1 : Type u_3\ninst\u271d : CommSemiring \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 Set \u03ba\ng : \u03ba \u2192 \u03b1\n\u22a2 \u220f i \u2208 s, (f i).indicator g = (\u22c2 x \u2208 s, f x).indicator (g ^ s.card)"}, {"line": "simp [prod_indicator]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.univ_prod_mulSingle [Fintype I] (f : \u2200 i, Z i) :\n    (\u220f i, Pi.mulSingle i (f i)) = f := by\n  ext a\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Pi.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[CommSemiring \u03b1]", "{I : Type*} [DecidableEq I] {Z : I \u2192 Type*}", "[\u2200 i, CommMonoid (Z i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u_4\ninst\u271d\u00b2 : DecidableEq I\nZ : I \u2192 Type u_5\ninst\u271d\u00b9 : (i : I) \u2192 CommMonoid (Z i)\ninst\u271d : Fintype I\nf : (i : I) \u2192 Z i\n\u22a2 \u220f i, Pi.mulSingle i (f i) = f"}, {"line": "ext a", "tactic_state": "case h\nI : Type u_4\ninst\u271d\u00b2 : DecidableEq I\nZ : I \u2192 Type u_5\ninst\u271d\u00b9 : (i : I) \u2192 CommMonoid (Z i)\ninst\u271d : Fintype I\nf : (i : I) \u2192 Z i\na : I\n\u22a2 (\u220f i, Pi.mulSingle i (f i)) a = f a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_single_index {a : \u03b1} {b : M} {h : \u03b1 \u2192 M \u2192 N} (h_zero : h a 0 = 1) :\n    (single a b).prod h = h a b :=\n  calc\n    (single a b).prod h = \u220f x \u2208 {a}, h x (single a b x) :=\n      prod_of_support_subset _ support_single_subset h fun _ hx =>\n        (mem_singleton.1 hx).symm \u25b8 h_zero\n    _ = h a b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_8\nN : Type u_10\ninst\u271d\u00b9 : Zero M\ninst\u271d : CommMonoid N\nx\u271d : Sort u_16\nsingle : x\u271d\na : \u03b1\nb : M\nh : \u03b1 \u2192 M \u2192 N\nh_zero : h a 0 = 1\n\u22a2 \u220f x \u2208 {a}, h x sorry = h a b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nM : Type u_8\nN : Type u_10\ninst\u271d\u00b9 : Zero M\ninst\u271d : CommMonoid N\nx\u271d : Sort u_16\nsingle : x\u271d\na : \u03b1\nb : M\nh : \u03b1 \u2192 M \u2192 N\nh_zero : h a 0 = 1\n\u22a2 h a (sorry ()) = h a b"}]}
{"declaration": "theorem sum_ite_self_eq [DecidableEq \u03b1] {N : Type*} [AddCommMonoid N] (f : \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (f.sum fun x v => ite (a = x) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\nN : Type u_16\ninst\u271d : AddCommMonoid N\nf : \u03b1 \u2192\u2080 N\na : \u03b1\n\u22a2 (f.sum fun x v => if a = x then v else 0) = f a"}, {"line": "classical\n    convert f.sum_ite_eq a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_ite_self_eq' [DecidableEq \u03b1] {N : Type*} [AddCommMonoid N] (f : \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (f.sum fun x v => ite (x = a) v 0) = f a := by\n  classical\n    convert f.sum_ite_eq' a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\nN : Type u_16\ninst\u271d : AddCommMonoid N\nf : \u03b1 \u2192\u2080 N\na : \u03b1\n\u22a2 (f.sum fun x v => if x = a then v else 0) = f a"}, {"line": "classical\n    convert f.sum_ite_eq' a fun _ => id\n    simp [ite_eq_right_iff.2 Eq.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 N}\n    (h_zero : \u2200 a, h a 0 = 1) (h_add : \u2200 a b\u2081 b\u2082, h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082) :\n    (f + g).prod h = f.prod h * g.prod h := by\n  classical exact prod_add_index (fun a _ => h_zero a) fun a _ => h_add a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]", "[Zero \u03b1] [CommMonoidWithZero \u03b2] [Nontrivial \u03b2] [NoZeroDivisors \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_8\nN : Type u_10\ninst\u271d\u2074 : Zero M\ninst\u271d\u00b3 : CommMonoid N\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : AddZeroClass M\ninst\u271d : CommMonoid N\nf g : \u03b1 \u2192\u2080 M\nh : \u03b1 \u2192 M \u2192 N\nh_zero : \u2200 (a : \u03b1), h a 0 = 1\nh_add : \u2200 (a : \u03b1) (b\u2081 b\u2082 : M), h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082\n\u22a2 sorry = f.prod h * g.prod h"}, {"line": "classical exact prod_add_index (fun a _ => h_zero a) fun a _ => h_add a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finsupp.sum_mul (b : S) (s : \u03b1 \u2192\u2080 R) {f : \u03b1 \u2192 R \u2192 S} :\n    s.sum f * b = s.sum fun a c => f a c * b := by simp only [Finsupp.sum, Finset.sum_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]", "[Zero \u03b1] [CommMonoidWithZero \u03b2] [Nontrivial \u03b2] [NoZeroDivisors \u03b2]", "[NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_14\nS : Type u_15\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : NonUnitalNonAssocSemiring S\nb : S\ns : \u03b1 \u2192\u2080 R\nf : \u03b1 \u2192 R \u2192 S\n\u22a2 s.sum f * b = s.sum fun a c => f a c * b"}, {"line": "simp only [Finsupp.sum, Finset.sum_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finsupp.mul_sum (b : S) (s : \u03b1 \u2192\u2080 R) {f : \u03b1 \u2192 R \u2192 S} :\n    b * s.sum f = s.sum fun a c => b * f a c := by simp only [Finsupp.sum, Finset.mul_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Finsupp/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 \u03b3 A B C : Type*} [AddCommMonoid A] [AddCommMonoid B] [AddCommMonoid C]", "{t : \u03b9 \u2192 A \u2192 C}", "{s : Finset \u03b1} {f : \u03b1 \u2192 \u03b9 \u2192\u2080 A} (i : \u03b9)", "(g : \u03b9 \u2192\u2080 A) (k : \u03b9 \u2192 A \u2192 \u03b3 \u2192 B) (x : \u03b3)", "{\u03b2 M M' N P G H R S : Type*}", "[Zero M] [Zero M'] [CommMonoid N]", "[Zero \u03b1] [CommMonoidWithZero \u03b2] [Nontrivial \u03b2] [NoZeroDivisors \u03b2]", "[NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_14\nS : Type u_15\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d : NonUnitalNonAssocSemiring S\nb : S\ns : \u03b1 \u2192\u2080 R\nf : \u03b1 \u2192 R \u2192 S\n\u22a2 b * s.sum f = s.sum fun a c => b * f a c"}, {"line": "simp only [Finsupp.sum, Finset.mul_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_univ_pi [DecidableEq \u03b9] [Fintype \u03b9] {\u03ba : \u03b9 \u2192 Type*} (t : \u2200 i, Finset (\u03ba i))\n    (f : (\u2200 i \u2208 (univ : Finset \u03b9), \u03ba i) \u2192 \u03b2) :\n    \u220f x \u2208 univ.pi t, f x = \u220f x \u2208 Fintype.piFinset t, f fun a _ \u21a6 x a := by\n  apply prod_nbij' (fun x i \u21a6 x i <| mem_univ _) (fun x i _ \u21a6 x i) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Pi.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03b2 : Type*}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b2\nuniv : Finset \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\n\u03ba : \u03b9 \u2192 Type u_3\nt : (i : \u03b9) \u2192 Finset (\u03ba i)\nf : ((i : \u03b9) \u2192 i \u2208 univ \u2192 \u03ba i) \u2192 \u03b2\n\u22a2 \u220f x \u2208 univ.pi t, f x = \u220f x \u2208 Fintype.piFinset t, f fun a x_1 => x a"}, {"line": "apply prod_nbij' (fun x i \u21a6 x i <| mem_univ _) (fun x i _ \u21a6 x i) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_comm' {s : Finset \u03b3} {t : \u03b3 \u2192 Finset \u03b1} {t' : Finset \u03b1} {s' : \u03b1 \u2192 Finset \u03b3}\n    (h : \u2200 x y, x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t') {f : \u03b3 \u2192 \u03b1 \u2192 \u03b2} :\n    (\u220f x \u2208 s, \u220f y \u2208 t x, f x y) = \u220f y \u2208 t', \u220f x \u2208 s' y, f x y := by\n  classical\n    have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).map <| Function.Embedding.sectR x _) \u2194\n      z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n      rintro \u27e8x, y\u27e9\n      simp only [mem_biUnion]\n      simp only [mem_map]\n      simp only [Function.Embedding.sectR_apply]\n      simp only [Prod.mk.injEq]\n      simp only [exists_eq_right]\n      simp only [\u2190 and_assoc]\n    exact\n      (prod_finset_product' _ _ _ this).symm.trans\n        ((prod_finset_product_right' _ _ _) fun \u27e8x, y\u27e9 => (this _).trans ((h x y).trans and_comm))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Sigma.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b3\nt : \u03b3 \u2192 Finset \u03b1\nt' : Finset \u03b1\ns' : \u03b1 \u2192 Finset \u03b3\nh : \u2200 (x : \u03b3) (y : \u03b1), x \u2208 s \u2227 y \u2208 t x \u2194 x \u2208 s' y \u2227 y \u2208 t'\nf : \u03b3 \u2192 \u03b1 \u2192 \u03b2\n\u22a2 \u220f x \u2208 s, \u220f y \u2208 t x, f x y = \u220f y \u2208 t', \u220f x \u2208 s' y, f x y"}, {"line": "classical\n    have : \u2200 z : \u03b3 \u00d7 \u03b1, (z \u2208 s.biUnion fun x => (t x).map <| Function.Embedding.sectR x _) \u2194\n      z.1 \u2208 s \u2227 z.2 \u2208 t z.1 := by\n      rintro \u27e8x, y\u27e9\n      simp only [mem_biUnion]\n      simp only [mem_map]\n      simp only [Function.Embedding.sectR_apply]\n      simp only [Prod.mk.injEq]\n      simp only [exists_eq_right]\n      simp only [\u2190 and_assoc]\n    exact\n      (prod_finset_product' _ _ _ this).symm.trans\n        ((prod_finset_product_right' _ _ _) fun \u27e8x, y\u27e9 => (this _).trans ((h x y).trans and_comm))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_insert_of_eq_one_if_not_mem [DecidableEq \u03b9] (h : a \u2209 s \u2192 f a = 1) :\n    \u220f x \u2208 insert a s, f x = \u220f x \u2208 s, f x := by\n  by_cases hm : a \u2208 s\n  \u00b7 simp_rw [insert_eq_of_mem hm]\n  \u00b7 rw [prod_insert hm, h hm, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ns : Finset \u03b9\na : \u03b9\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nh : a \u2209 s \u2192 f a = 1\n\u22a2 \u220f x \u2208 insert a s, f x = \u220f x \u2208 s, f x"}, {"line": "by_cases hm : a \u2208 s", "tactic_state": "case pos\n\u03b9 : Type u_1\nM : Type u_4\ns : Finset \u03b9\na : \u03b9\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nh : a \u2209 s \u2192 f a = 1\nhm : a \u2208 s\n\u22a2 \u220f x \u2208 insert a s, f x = \u220f x \u2208 s, f x\n---\ncase neg\n\u03b9 : Type u_1\nM : Type u_4\ns : Finset \u03b9\na : \u03b9\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nh : a \u2209 s \u2192 f a = 1\nhm : a \u2209 s\n\u22a2 \u220f x \u2208 insert a s, f x = \u220f x \u2208 s, f x"}, {"line": "\u00b7 simp_rw [insert_eq_of_mem hm]", "tactic_state": "case neg\n\u03b9 : Type u_1\nM : Type u_4\ns : Finset \u03b9\na : \u03b9\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b9 \u2192 M\ninst\u271d : DecidableEq \u03b9\nh : a \u2209 s \u2192 f a = 1\nhm : a \u2209 s\n\u22a2 \u220f x \u2208 insert a s, f x = \u220f x \u2208 s, f x"}, {"line": "\u00b7 rw [prod_insert hm, h hm, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_eq_one_iff [Subsingleton M\u02e3] : \u220f i \u2208 s, f i = 1 \u2194 \u2200 i \u2208 s, f i = 1 := by\n  induction' s using Finset.cons_induction with i s hi ih <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ns : Finset \u03b9\ninst\u271d\u00b9 : CommMonoid M\nf : \u03b9 \u2192 M\ninst\u271d : Subsingleton M\u02e3\n\u22a2 \u220f i \u2208 s, f i = 1 \u2194 \u2200 i \u2208 s, f i = 1"}, {"line": "induction' s using Finset.cons_induction with i s hi ih <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_sum_eq_prod_toLeft_mul_prod_toRight (s : Finset (\u03b9 \u2295 \u03ba)) (f : \u03b9 \u2295 \u03ba \u2192 M) :\n    \u220f x \u2208 s, f x = (\u220f x \u2208 s.toLeft, f (Sum.inl x)) * \u220f x \u2208 s.toRight, f (Sum.inr x) := by\n  rw [\u2190 Finset.toLeft_disjSum_toRight (u := s)]\n  rw [Finset.prod_disj_sum]\n  rw [Finset.toLeft_disjSum]\n  rw [Finset.toRight_disjSum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset (\u03b9 \u2295 \u03ba)\nf : \u03b9 \u2295 \u03ba \u2192 M\n\u22a2 \u220f x \u2208 s, f x = (\u220f x \u2208 s.toLeft, f (Sum.inl x)) * \u220f x \u2208 s.toRight, f (Sum.inr x)"}, {"line": "rw [\u2190 Finset.toLeft_disjSum_toRight (u := s)]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset (\u03b9 \u2295 \u03ba)\nf : \u03b9 \u2295 \u03ba \u2192 M\n\u22a2 \u220f x \u2208 s.toLeft.disjSum s.toRight, f x =\n    (\u220f x \u2208 (s.toLeft.disjSum s.toRight).toLeft, f (Sum.inl x)) *\n      \u220f x \u2208 (s.toLeft.disjSum s.toRight).toRight, f (Sum.inr x)"}, {"line": "rw [Finset.prod_disj_sum]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset (\u03b9 \u2295 \u03ba)\nf : \u03b9 \u2295 \u03ba \u2192 M\n\u22a2 (\u220f x \u2208 s.toLeft, f (Sum.inl x)) * \u220f x \u2208 s.toRight, f (Sum.inr x) =\n    (\u220f x \u2208 (s.toLeft.disjSum s.toRight).toLeft, f (Sum.inl x)) *\n      \u220f x \u2208 (s.toLeft.disjSum s.toRight).toRight, f (Sum.inr x)"}, {"line": "rw [Finset.toLeft_disjSum]", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset (\u03b9 \u2295 \u03ba)\nf : \u03b9 \u2295 \u03ba \u2192 M\n\u22a2 (\u220f x \u2208 s.toLeft, f (Sum.inl x)) * \u220f x \u2208 s.toRight, f (Sum.inr x) =\n    (\u220f x \u2208 s.toLeft, f (Sum.inl x)) * \u220f x \u2208 (s.toLeft.disjSum s.toRight).toRight, f (Sum.inr x)"}, {"line": "rw [Finset.toRight_disjSum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_sumElim (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 M) (g : \u03ba \u2192 M) :\n    \u220f x \u2208 s.disjSum t, Sum.elim f g x = (\u220f x \u2208 s, f x) * \u220f x \u2208 t, g x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 M\ng : \u03ba \u2192 M\n\u22a2 \u220f x \u2208 s.disjSum t, Sum.elim f g x = (\u220f x \u2208 s, f x) * \u220f x \u2208 t, g x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_fiberwise_eq_prod_filter' (s : Finset \u03b9) (t : Finset \u03ba) (g : \u03b9 \u2192 \u03ba) (f : \u03ba \u2192 M) :\n    \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f j = \u220f i \u2208 s with g i \u2208 t, f (g i) := by\n  calc\n    _ = \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f (g i) :=\n        prod_congr rfl fun j _ \u21a6 prod_congr rfl fun i hi \u21a6 by rw [(mem_filter.1 hi).2]\n    _ = _ := prod_fiberwise_eq_prod_filter _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq \u03ba\ns : Finset \u03b9\nt : Finset \u03ba\ng : \u03b9 \u2192 \u03ba\nf : \u03ba \u2192 M\n\u22a2 \u220f j \u2208 t, \u220f i \u2208 {i \u2208 s | g i = j}, f j = \u220f i \u2208 {i \u2208 s | g i \u2208 t}, f (g i)"}, {"line": "calc\n    _ = \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f (g i) :=\n        prod_congr rfl fun j _ \u21a6 prod_congr rfl fun i hi \u21a6 by rw [(mem_filter.1 hi).2]\n    _ = _ := prod_fiberwise_eq_prod_filter _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_fiberwise_of_maps_to' {g : \u03b9 \u2192 \u03ba} (h : \u2200 i \u2208 s, g i \u2208 t) (f : \u03ba \u2192 M) :\n    \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f j = \u220f i \u2208 s, f (g i) := by\n  calc\n    _ = \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f (g i) :=\n        prod_congr rfl fun y _ \u21a6 prod_congr rfl fun x hx \u21a6 by rw [(mem_filter.1 hx).2]\n    _ = _ := prod_fiberwise_of_maps_to h _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\nM : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ns : Finset \u03b9\nt : Finset \u03ba\ninst\u271d : DecidableEq \u03ba\ng : \u03b9 \u2192 \u03ba\nh : \u2200 i \u2208 s, g i \u2208 t\nf : \u03ba \u2192 M\n\u22a2 \u220f j \u2208 t, \u220f i \u2208 {i \u2208 s | g i = j}, f j = \u220f i \u2208 s, f (g i)"}, {"line": "calc\n    _ = \u220f j \u2208 t, \u220f i \u2208 s with g i = j, f (g i) :=\n        prod_congr rfl fun y _ \u21a6 prod_congr rfl fun x hx \u21a6 by rw [(mem_filter.1 hx).2]\n    _ = _ := prod_fiberwise_of_maps_to h _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_diag [DecidableEq \u03b9] (s : Finset \u03b9) (f : \u03b9 \u00d7 \u03b9 \u2192 M) :\n    \u220f i \u2208 s.diag, f i = \u220f i \u2208 s, f (i, i) := by\n  apply prod_nbij' Prod.fst (fun i \u21a6 (i, i)) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u00d7 \u03b9 \u2192 M\n\u22a2 \u220f i \u2208 s.diag, f i = \u220f i \u2208 s, f (i, i)"}, {"line": "apply prod_nbij' Prod.fst (fun i \u21a6 (i, i)) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_subtype_map_embedding {p : \u03b9 \u2192 Prop} {s : Finset { x // p x }} {f : { x // p x } \u2192 M}\n    {g : \u03b9 \u2192 M} (h : \u2200 x : { x // p x }, x \u2208 s \u2192 g x = f x) :\n    (\u220f x \u2208 s.map (Function.Embedding.subtype _), g x) = \u220f x \u2208 s, f x := by\n  rw [Finset.prod_map]\n  exact Finset.prod_congr rfl h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d : CommMonoid M\np : \u03b9 \u2192 Prop\ns : Finset { x // p x }\nf : { x // p x } \u2192 M\ng : \u03b9 \u2192 M\nh : \u2200 x \u2208 s, g \u2191x = f x\n\u22a2 \u220f x \u2208 Finset.map (Embedding.subtype fun x => p x) s, g x = \u220f x \u2208 s, f x"}, {"line": "rw [Finset.prod_map]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d : CommMonoid M\np : \u03b9 \u2192 Prop\ns : Finset { x // p x }\nf : { x // p x } \u2192 M\ng : \u03b9 \u2192 M\nh : \u2200 x \u2208 s, g \u2191x = f x\n\u22a2 \u220f x \u2208 s, g ((Embedding.subtype fun x => p x) x) = \u220f x \u2208 s, f x"}, {"line": "exact Finset.prod_congr rfl h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_list_count [DecidableEq M] (s : List M) :\n    s.prod = \u220f m \u2208 s.toFinset, m ^ s.count m := by simpa using prod_list_map_count s id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\ns : List M\n\u22a2 s.prod = \u220f m \u2208 s.toFinset, m ^ count m s"}, {"line": "simpa using prod_list_map_count s id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_multiset_map_count [DecidableEq \u03b9] (s : Multiset \u03b9) {M : Type*} [CommMonoid M]\n    (f : \u03b9 \u2192 M) : (s.map f).prod = \u220f m \u2208 s.toFinset, f m ^ s.count m := by\n  refine Quot.induction_on s fun l => ?_\n  simp [prod_list_map_count l f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ns : Multiset \u03b9\nM : Type u_5\ninst\u271d : CommMonoid M\nf : \u03b9 \u2192 M\n\u22a2 (Multiset.map f s).prod = \u220f m \u2208 s.toFinset, f m ^ Multiset.count m s"}, {"line": "refine Quot.induction_on s fun l => ?_", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ns : Multiset \u03b9\nM : Type u_5\ninst\u271d : CommMonoid M\nf : \u03b9 \u2192 M\nl : List \u03b9\n\u22a2 (Multiset.map f (Quot.mk (\u21d1(isSetoid \u03b9)) l)).prod =\n    \u220f m \u2208 Multiset.toFinset (Quot.mk (\u21d1(isSetoid \u03b9)) l), f m ^ Multiset.count m (Quot.mk (\u21d1(isSetoid \u03b9)) l)"}, {"line": "simp [prod_list_map_count l f]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ns : Multiset \u03b9\nM : Type u_5\ninst\u271d : CommMonoid M\nf : \u03b9 \u2192 M\nl : List \u03b9\n\u22a2 (List.map f l).prod = \u220f x \u2208 l.toFinset, f x ^ List.count x l"}]}
{"declaration": "theorem prod_multiset_count_of_subset [DecidableEq M] (m : Multiset M) (s : Finset M)\n    (hs : m.toFinset \u2286 s) : m.prod = \u220f i \u2208 s, i ^ m.count i := by\n  revert hs\n  refine Quot.induction_on m fun l => ?_\n  simp only [quot_mk_to_coe'']\n  simp only [prod_coe]\n  simp only [coe_count]\n  apply prod_list_count_of_subset l s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\nhs : m.toFinset \u2286 s\n\u22a2 m.prod = \u220f i \u2208 s, i ^ Multiset.count i m"}, {"line": "revert hs", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\n\u22a2 m.toFinset \u2286 s \u2192 m.prod = \u220f i \u2208 s, i ^ Multiset.count i m"}, {"line": "refine Quot.induction_on m fun l => ?_", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\nl : List M\n\u22a2 Multiset.toFinset (Quot.mk (\u21d1(isSetoid M)) l) \u2286 s \u2192\n    Multiset.prod (Quot.mk (\u21d1(isSetoid M)) l) = \u220f i \u2208 s, i ^ Multiset.count i (Quot.mk (\u21d1(isSetoid M)) l)"}, {"line": "simp only [quot_mk_to_coe'']", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\nl : List M\n\u22a2 (\u2191l).toFinset \u2286 s \u2192 (\u2191l).prod = \u220f x \u2208 s, x ^ Multiset.count x \u2191l"}, {"line": "simp only [prod_coe]", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\nl : List M\n\u22a2 (\u2191l).toFinset \u2286 s \u2192 l.prod = \u220f x \u2208 s, x ^ Multiset.count x \u2191l"}, {"line": "simp only [coe_count]", "tactic_state": "M : Type u_4\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : DecidableEq M\nm : Multiset M\ns : Finset M\nl : List M\n\u22a2 (\u2191l).toFinset \u2286 s \u2192 l.prod = \u220f x \u2208 s, x ^ List.count x l"}, {"line": "apply prod_list_count_of_subset l s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_of_prod_eq_one {s : Finset \u03b9} {f : \u03b9 \u2192 M} {a : \u03b9} (hp : \u220f x \u2208 s, f x = 1)\n    (h1 : \u2200 x \u2208 s, x \u2260 a \u2192 f x = 1) : \u2200 x \u2208 s, f x = 1 := by\n  intro x hx\n  classical\n    by_cases h : x = a\n    \u00b7 rw [h]\n      rw [h] at hx\n      rw [\u2190 prod_subset (singleton_subset_iff.2 hx) fun t ht ha => h1 t ht (not_mem_singleton.1 ha)] at hp\n      rw [prod_singleton] at hp\n      exact hp\n    \u00b7 exact h1 x hx h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\na : \u03b9\nhp : \u220f x \u2208 s, f x = 1\nh1 : \u2200 x \u2208 s, x \u2260 a \u2192 f x = 1\n\u22a2 \u2200 x \u2208 s, f x = 1"}, {"line": "intro x hx", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d : CommMonoid M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\na : \u03b9\nhp : \u220f x \u2208 s, f x = 1\nh1 : \u2200 x \u2208 s, x \u2260 a \u2192 f x = 1\nx : \u03b9\nhx : x \u2208 s\n\u22a2 f x = 1"}, {"line": "classical\n    by_cases h : x = a\n    \u00b7 rw [h]\n      rw [h] at hx\n      rw [\u2190 prod_subset (singleton_subset_iff.2 hx) fun t ht ha => h1 t ht (not_mem_singleton.1 ha)] at hp\n      rw [prod_singleton] at hp\n      exact hp\n    \u00b7 exact h1 x hx h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_insert_div (ha : a \u2209 s) (f : \u03b9 \u2192 G) :\n    (\u220f x \u2208 insert a s, f x) / f a = \u220f x \u2208 s, f x := by simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}", "[DecidableEq \u03b9] [CancelCommMonoid M] {s t : Finset \u03b9} {f : \u03b9 \u2192 M}", "[CommGroup G] [DecidableEq \u03b9] {f : \u03b9 \u2192 G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : Type u_3\na : \u03b9\ninst\u271d\u00b2 : DecidableEq \u03b9\ns : Finset \u03b9\ninst\u271d\u00b9 : CommGroup G\ninst\u271d : DecidableEq \u03b9\nha : a \u2209 s\nf : \u03b9 \u2192 G\n\u22a2 (\u220f x \u2208 insert a s, f x) / f a = \u220f x \u2208 s, f x"}, {"line": "simp [ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_toFinset_count_eq_length [DecidableEq \u03b9] (l : List \u03b9) :\n    \u2211 a \u2208 l.toFinset, l.count a = l.length := by\n  simpa [List.map_const'] using (Finset.sum_list_map_count l fun _ => (1 : \u2115)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset", "Finset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}", "[DecidableEq \u03b9] [CancelCommMonoid M] {s t : Finset \u03b9} {f : \u03b9 \u2192 M}", "[CommGroup G] [DecidableEq \u03b9] {f : \u03b9 \u2192 G}", "[AddCommMonoid M] [PartialOrder M] [Sub M] [OrderedSub M] [AddLeftMono M]", "{\u03b9 \u03ba \u03b9 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nl : List \u03b9\n\u22a2 \u2211 a \u2208 l.toFinset, List.count a l = l.length"}, {"line": "simpa [List.map_const'] using (Finset.sum_list_map_count l fun _ => (1 : \u2115)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_sum_count_eq (s : Multiset \u03b9) : \u2211 a \u2208 s.toFinset, s.count a = card s := by\n  simpa using (Finset.sum_multiset_map_count s (fun _ => (1 : \u2115))).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset", "Finset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}", "[DecidableEq \u03b9] [CancelCommMonoid M] {s t : Finset \u03b9} {f : \u03b9 \u2192 M}", "[CommGroup G] [DecidableEq \u03b9] {f : \u03b9 \u2192 G}", "[AddCommMonoid M] [PartialOrder M] [Sub M] [OrderedSub M] [AddLeftMono M]", "{\u03b9 \u03ba \u03b9 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ns : Multiset \u03b9\n\u22a2 \u2211 a \u2208 s.toFinset, Multiset.count a s = s.card"}, {"line": "simpa using (Finset.sum_multiset_map_count s (fun _ => (1 : \u2115))).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_sum_count_nsmul_eq (s : Multiset \u03b9) :\n    \u2211 a \u2208 s.toFinset, s.count a \u2022 {a} = s := by\n  rw [\u2190 Finset.sum_multiset_map_count]\n  rw [Multiset.sum_map_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset", "Finset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}", "[DecidableEq \u03b9] [CancelCommMonoid M] {s t : Finset \u03b9} {f : \u03b9 \u2192 M}", "[CommGroup G] [DecidableEq \u03b9] {f : \u03b9 \u2192 G}", "[AddCommMonoid M] [PartialOrder M] [Sub M] [OrderedSub M] [AddLeftMono M]", "{\u03b9 \u03ba \u03b9 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ns : Multiset \u03b9\n\u22a2 \u2211 a \u2208 s.toFinset, Multiset.count a s \u2022 {a} = s"}, {"line": "rw [\u2190 Finset.sum_multiset_map_count]", "tactic_state": "\u03b9 : Type u_7\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ns : Multiset \u03b9\n\u22a2 (Multiset.map singleton s).sum = s"}, {"line": "rw [Multiset.sum_map_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsUnit.prod_univ_iff [Fintype \u03b9] [CommMonoid M] {f : \u03b9 \u2192 M} :\n    IsUnit (\u220f a, f a) \u2194 \u2200 a, IsUnit (f a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Basic.lean", "context": {"open": ["Fin Function", "List", "Multiset", "Finset"], "variables": ["{\u03b9 \u03ba G M : Type*} {s s\u2081 s\u2082 : Finset \u03b9} {a : \u03b9}", "[CommMonoid M] {f g : \u03b9 \u2192 M}", "{s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 M} {g : \u03ba \u2192 M}", "[DecidableEq \u03ba]", "[Fintype \u03ba]", "(f s)", "{f s}", "[DecidableEq \u03b9] [CancelCommMonoid M] {s t : Finset \u03b9} {f : \u03b9 \u2192 M}", "[CommGroup G] [DecidableEq \u03b9] {f : \u03b9 \u2192 G}", "[AddCommMonoid M] [PartialOrder M] [Sub M] [OrderedSub M] [AddLeftMono M]", "{\u03b9 \u03ba \u03b9 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid M]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\ninst\u271d\u00b9\u00b9 : CommMonoid M\ninst\u271d\u00b9\u2070 : CancelCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : PartialOrder M\ninst\u271d\u2077 : Sub M\ninst\u271d\u2076 : OrderedSub M\ninst\u271d\u2075 : AddLeftMono M\n\u03b9 : Type u_7\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : CommMonoid M\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommMonoid M\nf : \u03b9 \u2192 M\n\u22a2 IsUnit (\u220f a, f a) \u2194 \u2200 (a : \u03b9), IsUnit (f a)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_val [CommMonoid \u03b1] (s : Finset \u03b1) : s.1.prod = s.prod id := by\n  rw [Finset.prod]\n  rw [Multiset.map_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b1\n\u22a2 s.val.prod = s.prod id"}, {"line": "rw [Finset.prod]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b1\n\u22a2 s.val.prod = (Multiset.map id s.val).prod"}, {"line": "rw [Multiset.map_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_const_one : (\u220f _x \u2208 s, (1 : \u03b2)) = 1 := by\n  simp only [Finset.prod]\n  simp only [Multiset.map_const']\n  simp only [Multiset.prod_replicate]\n  simp only [one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\n\u22a2 \u220f _x \u2208 s, 1 = 1"}, {"line": "simp only [Finset.prod]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\n\u22a2 (Multiset.map (fun _x => 1) s.val).prod = 1"}, {"line": "simp only [Multiset.map_const']", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\n\u22a2 (Multiset.replicate s.val.card 1).prod = 1"}, {"line": "simp only [Multiset.prod_replicate]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\n\u22a2 1 ^ s.val.card = 1"}, {"line": "simp only [one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_map_toList (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) : (s.toList.map f).prod = s.prod f := by\n  rw [Finset.prod]\n  rw [\u2190 Multiset.prod_coe]\n  rw [\u2190 Multiset.map_coe]\n  rw [Finset.coe_toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (List.map f s.toList).prod = s.prod f"}, {"line": "rw [Finset.prod]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (List.map f s.toList).prod = (Multiset.map f s.val).prod"}, {"line": "rw [\u2190 Multiset.prod_coe]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2191(List.map f s.toList)).prod = (Multiset.map f s.val).prod"}, {"line": "rw [\u2190 Multiset.map_coe]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (Multiset.map f \u2191s.toList).prod = (Multiset.map f s.val).prod"}, {"line": "rw [Finset.coe_toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_toList {\u03b1 : Type*} [CommMonoid \u03b1] (s : Finset \u03b1) :\n    s.toList.prod = \u220f x \u2208 s, x := by\n  simpa using s.prod_map_toList id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b1\n\u22a2 s.toList.prod = \u220f x \u2208 s, x"}, {"line": "simpa using s.prod_map_toList id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Equiv.Perm.prod_comp' (\u03c3 : Equiv.Perm \u03b1) (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2)\n    (hs : { a | \u03c3 a \u2260 a } \u2286 s) : (\u220f x \u2208 s, f (\u03c3 x) x) = \u220f x \u2208 s, f x (\u03c3.symm x) := by\n  convert \u03c3.prod_comp s (fun x => f x (\u03c3.symm x)) hs\n  rw [Equiv.symm_apply_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\n\u03c3 : Equiv.Perm \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhs : {a | \u03c3 a \u2260 a} \u2286 \u2191s\n\u22a2 \u220f x \u2208 s, f (\u03c3 x) x = \u220f x \u2208 s, f x ((Equiv.symm \u03c3) x)"}, {"line": "convert \u03c3.prod_comp s (fun x => f x (\u03c3.symm x)) hs", "tactic_state": "case h.e'_2.a.h.e'_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\n\u03c3 : Equiv.Perm \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b1 \u2192 \u03b2\nhs : {a | \u03c3 a \u2260 a} \u2286 \u2191s\nx\u271d : \u03b1\na\u271d : x\u271d \u2208 s\n\u22a2 x\u271d = (Equiv.symm \u03c3) (\u03c3 x\u271d)"}, {"line": "rw [Equiv.symm_apply_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_equiv (e : \u03b9 \u2243 \u03ba) (hst : \u2200 i, i \u2208 s \u2194 e i \u2208 t) (hfg : \u2200 i \u2208 s, f i = g (e i)) :\n    \u220f i \u2208 s, f i = \u220f i \u2208 t, g i := by refine prod_nbij' e e.symm ?_ ?_ ?_ ?_ hfg <;> simp [hst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_6\n\u03ba : Type u_7\n\u03b1 : Type u_8\ninst\u271d : CommMonoid \u03b1\ns : Finset \u03b9\nt : Finset \u03ba\nf : \u03b9 \u2192 \u03b1\ng : \u03ba \u2192 \u03b1\ne : \u03b9 \u2243 \u03ba\nhst : \u2200 (i : \u03b9), i \u2208 s \u2194 e i \u2208 t\nhfg : \u2200 i \u2208 s, f i = g (e i)\n\u22a2 \u220f i \u2208 s, f i = \u220f i \u2208 t, g i"}, {"line": "refine prod_nbij' e e.symm ?_ ?_ ?_ ?_ hfg <;> simp [hst]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ite_irrel (p : Prop) [Decidable p] (s : Finset \u03b1) (f g : \u03b1 \u2192 \u03b2) :\n    \u220f x \u2208 s, (if p then f x else g x) = if p then \u220f x \u2208 s, f x else \u220f x \u2208 s, g x := by\n  split_ifs with h <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b2\n\u03b1 : Type u_8\ninst\u271d\u00b9 : CommMonoid \u03b1\np : Prop\ninst\u271d : Decidable p\ns : Finset \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 (\u220f x \u2208 s, if p then f x else g x) = if p then \u220f x \u2208 s, f x else \u220f x \u2208 s, g x"}, {"line": "split_ifs with h <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_dite_irrel (p : Prop) [Decidable p] (s : Finset \u03b1) (f : p \u2192 \u03b1 \u2192 \u03b2) (g : \u00acp \u2192 \u03b1 \u2192 \u03b2) :\n    \u220f x \u2208 s, (if h : p then f h x else g h x) =\n      if h : p then \u220f x \u2208 s, f h x else \u220f x \u2208 s, g h x := by\n  split_ifs with h <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b2\n\u03b1 : Type u_8\ninst\u271d\u00b9 : CommMonoid \u03b1\np : Prop\ninst\u271d : Decidable p\ns : Finset \u03b1\nf : p \u2192 \u03b1 \u2192 \u03b2\ng : \u00acp \u2192 \u03b1 \u2192 \u03b2\n\u22a2 (\u220f x \u2208 s, if h : p then f h x else g h x) = if h : p then \u220f x \u2208 s, f h x else \u220f x \u2208 s, g h x"}, {"line": "split_ifs with h <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_filter_count_eq_countP [DecidableEq \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] (l : List \u03b1) :\n    \u2211 x \u2208 l.toFinset with p x, l.count x = l.countP p := by\n  simp [Finset.sum, sum_map_count_dedup_filter_eq_countP p l]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\n\u22a2 \u2211 x \u2208 {x \u2208 l.toFinset | p x}, count x l = countP (fun b => decide (p b)) l"}, {"line": "simp [Finset.sum, sum_map_count_dedup_filter_eq_countP p l]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nl : List \u03b1\n\u22a2 (map (fun x => count x l) (filter (fun b => decide (p b)) l.dedup)).sum = countP (fun b => decide (p b)) l"}]}
{"declaration": "theorem prod_mem_multiset [DecidableEq \u03b1] (m : Multiset \u03b1) (f : { x // x \u2208 m } \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2)\n    (hfg : \u2200 x, f x = g x) : \u220f x : { x // x \u2208 m }, f x = \u220f x \u2208 m.toFinset, g x := by\n  refine prod_bij' (fun x _ \u21a6 x) (fun x hx \u21a6 \u27e8x, Multiset.mem_toFinset.1 hx\u27e9) ?_ ?_ ?_ ?_ ?_ <;>\n    simp [hfg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b2\n\u03b1 : Type u_8\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\nf : { x // x \u2208 m } \u2192 \u03b2\ng : \u03b1 \u2192 \u03b2\nhfg : \u2200 (x : { x // x \u2208 m }), f x = g \u2191x\n\u22a2 \u220f x, f x = \u220f x \u2208 m.toFinset, g x"}, {"line": "refine prod_bij' (fun x _ \u21a6 x) (fun x hx \u21a6 \u27e8x, Multiset.mem_toFinset.1 hx\u27e9) ?_ ?_ ?_ ?_ ?_ <;>\n    simp [hfg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_erase_attach [DecidableEq \u03b9] {s : Finset \u03b9} (f : \u03b9 \u2192 \u03b1) (i : \u2191s) :\n    \u220f j \u2208 s.attach.erase i, f \u2191j = \u220f j \u2208 s.erase \u2191i, f j := by\n  rw [\u2190 Function.Embedding.coe_subtype]\n  rw [\u2190 prod_map]\n  simp [attach_map_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset", "MulOpposite", "Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}", "[DivisionCommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid \u03b1]", "[CommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_9\n\u03b1 : Type u_11\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : { x // x \u2208 s }\n\u22a2 \u220f j \u2208 s.attach.erase i, f \u2191j = \u220f j \u2208 s.erase \u2191i, f j"}, {"line": "rw [\u2190 Function.Embedding.coe_subtype]", "tactic_state": "\u03b9 : Type u_9\n\u03b1 : Type u_11\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : { x // x \u2208 s }\n\u22a2 \u220f j \u2208 s.attach.erase i, f ((Embedding.subtype fun x => x \u2208 s) j) =\n    \u220f j \u2208 s.erase ((Embedding.subtype fun x => x \u2208 s) i), f j"}, {"line": "rw [\u2190 prod_map]", "tactic_state": "\u03b9 : Type u_9\n\u03b1 : Type u_11\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : { x // x \u2208 s }\n\u22a2 \u220f x \u2208 Finset.map (Embedding.subtype fun x => x \u2208 s) (s.attach.erase i), f x =\n    \u220f j \u2208 s.erase ((Embedding.subtype fun x => x \u2208 s) i), f j"}, {"line": "simp [attach_map_val]", "tactic_state": "\u03b9 : Type u_9\n\u03b1 : Type u_11\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : { x // x \u2208 s }\n\u22a2 \u220f x \u2208 s.attach.erase i, f \u2191x = \u220f x \u2208 s.erase \u2191i, f x"}]}
{"declaration": "theorem disjoint_list_sum_right {a : Multiset \u03b1} {l : List (Multiset \u03b1)} :\n    Disjoint a l.sum \u2194 \u2200 b \u2208 l, Disjoint a b := by\n  simpa only [disjoint_comm (a := a)] using disjoint_list_sum_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset", "MulOpposite", "Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}", "[DivisionCommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid \u03b1]", "[CommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b1\na : Multiset \u03b1\nl : List (Multiset \u03b1)\n\u22a2 _root_.Disjoint a l.sum \u2194 \u2200 b \u2208 l, _root_.Disjoint a b"}, {"line": "simpa only [disjoint_comm (a := a)] using disjoint_list_sum_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_sum_right {a : Multiset \u03b1} {i : Multiset (Multiset \u03b1)} :\n    Disjoint a i.sum \u2194 \u2200 b \u2208 i, Disjoint a b := by\n  simpa only [disjoint_comm (a := a)] using disjoint_sum_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset", "MulOpposite", "Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}", "[DivisionCommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid \u03b1]", "[CommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b1\na : Multiset \u03b1\ni : Multiset (Multiset \u03b1)\n\u22a2 _root_.Disjoint a i.sum \u2194 \u2200 b \u2208 i, _root_.Disjoint a b"}, {"line": "simpa only [disjoint_comm (a := a)] using disjoint_sum_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_finset_sum_left {\u03b2 : Type*} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} {a : Multiset \u03b1} :\n    Disjoint (i.sum f) a \u2194 \u2200 b \u2208 i, Disjoint (f b) a := by\n  convert @disjoint_sum_left _ a (map f i.val)\n  simp [and_congr_left_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset", "MulOpposite", "Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}", "[DivisionCommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid \u03b1]", "[CommMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b1\n\u03b2 : Type u_12\ni : Finset \u03b2\nf : \u03b2 \u2192 Multiset \u03b1\na : Multiset \u03b1\n\u22a2 _root_.Disjoint (i.sum f) a \u2194 \u2200 b \u2208 i, _root_.Disjoint (f b) a"}, {"line": "convert @disjoint_sum_left _ a (map f i.val)", "tactic_state": "case h.e'_2.a\n\u03b1 : Type u_11\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b1\n\u03b2 : Type u_12\ni : Finset \u03b2\nf : \u03b2 \u2192 Multiset \u03b1\na : Multiset \u03b1\n\u22a2 (\u2200 b \u2208 i, _root_.Disjoint (f b) a) \u2194 \u2200 b \u2208 Multiset.map f i.val, _root_.Disjoint b a"}, {"line": "simp [and_congr_left_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_sum' {s : Finset \u03b2} {a : \u03b1} {f : \u03b2 \u2192 Multiset \u03b1} :\n    count a (\u2211 x \u2208 s, f x) = \u2211 x \u2208 s, count a (f x) := by\n  dsimp only [Finset.sum]\n  rw [count_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Defs.lean", "context": {"open": ["Fin Function", "Batteries.ExtendedBinder Lean Meta", "Elab Term Tactic TryThis", "Lean Meta Parser.Term PrettyPrinter.Delaborator SubExpr", "scoped Batteries.ExtendedBinder", "List", "Multiset", "MulOpposite", "Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Finset \u03b1} {a : \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[CommMonoid \u03b2]", "[CommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [CommMonoid \u03b1] {s : Finset \u03b9} {t : Finset \u03ba} {f : \u03b9 \u2192 \u03b1} {g : \u03ba \u2192 \u03b1}", "(f s)", "{f s}", "[DivisionCommMonoid \u03b2]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba]", "[CommMonoid \u03b1]", "[CommMonoid \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u2075 inst\u271d\u2074 : CommMonoid \u03b2\ninst\u271d\u00b3 : DivisionCommMonoid \u03b2\n\u03b1 : Type u_11\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b2\na : \u03b1\nf : \u03b2 \u2192 Multiset \u03b1\n\u22a2 Multiset.count a (\u2211 x \u2208 s, f x) = \u2211 x \u2208 s, Multiset.count a (f x)"}, {"line": "dsimp only [Finset.sum]", "tactic_state": "\u03b2 : Type u_4\ninst\u271d\u2075 inst\u271d\u2074 : CommMonoid \u03b2\ninst\u271d\u00b3 : DivisionCommMonoid \u03b2\n\u03b1 : Type u_11\ninst\u271d\u00b2 inst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b2\na : \u03b1\nf : \u03b2 \u2192 Multiset \u03b1\n\u22a2 Multiset.count a (Multiset.map (fun x => f x) s.val).sum = (Multiset.map (fun x => Multiset.count a (f x)) s.val).sum"}, {"line": "rw [count_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_mulIndicator_subset_of_eq_one [One \u03b1] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 \u03b2) {s t : Finset \u03b9}\n    (h : s \u2286 t) (hg : \u2200 a, g a 1 = 1) :\n    \u220f i \u2208 t, g i (mulIndicator \u2191s f i) = \u220f i \u2208 s, g i (f i) := by\n  calc\n    _ = \u220f i \u2208 s, g i (mulIndicator \u2191s f i) := by rw [prod_subset h fun i _ hn \u21a6 by simp [hn, hg]]\n    _ = _ := prod_congr rfl fun i hi \u21a6 congr_arg _ <| mulIndicator_of_mem hi f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 : Type*} [CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : One \u03b1\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b1 \u2192 \u03b2\ns t : Finset \u03b9\nh : s \u2286 t\nhg : \u2200 (a : \u03b9), g a 1 = 1\n\u22a2 \u220f i \u2208 t, g i ((\u2191s).mulIndicator f i) = \u220f i \u2208 s, g i (f i)"}, {"line": "calc\n    _ = \u220f i \u2208 s, g i (mulIndicator \u2191s f i) := by rw [prod_subset h fun i _ hn \u21a6 by simp [hn, hg]]\n    _ = _ := prod_congr rfl fun i hi \u21a6 congr_arg _ <| mulIndicator_of_mem hi f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_dite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f : \u2200 x : \u03b1, p x \u2192 \u03b2)\n    (g : \u2200 x : \u03b1, \u00acp x \u2192 \u03b2) :\n    \u220f x \u2208 s, (if hx : p x then f x hx else g x hx) =\n      (\u220f x : {x \u2208 s | p x}, f x.1 (by simpa using (mem_filter.mp x.2).2)) *\n        \u220f x : {x \u2208 s | \u00acp x}, g x.1 (by simpa using (mem_filter.mp x.2).2) := by\n  simp [prod_apply_dite _ _ fun x => x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf : (x : \u03b1) \u2192 p x \u2192 \u03b2\ng : (x : \u03b1) \u2192 \u00acp x \u2192 \u03b2\n\u22a2 (\u220f x \u2208 s, if hx : p x then f x hx else g x hx) = (\u220f x, f \u2191x \u22ef) * \u220f x, g \u2191x \u22ef"}, {"line": "simp [prod_apply_dite _ _ fun x => x]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\ns : Finset \u03b1\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf : (x : \u03b1) \u2192 p x \u2192 \u03b2\ng : (x : \u03b1) \u2192 \u00acp x \u2192 \u03b2\n\u22a2 (\u220f x \u2208 s, if hx : p x then f x hx else g x hx) =\n    (\u220f x \u2208 {x \u2208 s | p x}.attach, f \u2191x \u22ef) * \u220f x \u2208 {x \u2208 s | \u00acp x}.attach, g \u2191x \u22ef"}]}
{"declaration": "lemma prod_dite_of_false {p : \u03b1 \u2192 Prop} {_ : DecidablePred p} (h : \u2200 i \u2208 s, \u00ac p i)\n    (f : \u2200 i, p i \u2192 \u03b2) (g : \u2200 i, \u00ac p i \u2192 \u03b2) :\n    \u220f i \u2208 s, (if hi : p i then f i hi else g i hi) = \u220f i : s, g i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nx\u271d : DecidablePred p\nh : \u2200 i \u2208 s, \u00acp i\nf : (i : \u03b1) \u2192 p i \u2192 \u03b2\ng : (i : \u03b1) \u2192 \u00acp i \u2192 \u03b2\n\u22a2 (\u220f i \u2208 s, if hi : p i then f i hi else g i hi) = \u220f i, g \u2191i \u22ef"}, {"line": "refine prod_bij' (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_dite_of_true {p : \u03b1 \u2192 Prop} {_ : DecidablePred p} (h : \u2200 i \u2208 s, p i) (f : \u2200 i, p i \u2192 \u03b2)\n    (g : \u2200 i, \u00ac p i \u2192 \u03b2) :\n    \u220f i \u2208 s, (if hi : p i then f i hi else g i hi) = \u220f i : s, f i.1 (h _ i.2) := by\n  refine prod_bij' (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nx\u271d : DecidablePred p\nh : \u2200 i \u2208 s, p i\nf : (i : \u03b1) \u2192 p i \u2192 \u03b2\ng : (i : \u03b1) \u2192 \u00acp i \u2192 \u03b2\n\u22a2 (\u220f i \u2208 s, if hi : p i then f i hi else g i hi) = \u220f i, f \u2191i \u22ef"}, {"line": "refine prod_bij' (fun x hx => \u27e8x, hx\u27e9) (fun x _ \u21a6 x) ?_ ?_ ?_ ?_ ?_ <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_apply_ite_of_false {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b3) (k : \u03b3 \u2192 \u03b2)\n    (h : \u2200 x \u2208 s, \u00acp x) : (\u220f x \u2208 s, k (if p x then f x else g x)) = \u220f x \u2208 s, k (g x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_false h _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf g : \u03b1 \u2192 \u03b3\nk : \u03b3 \u2192 \u03b2\nh : \u2200 x \u2208 s, \u00acp x\n\u22a2 \u220f x \u2208 s, k (if p x then f x else g x) = \u220f x \u2208 s, k (g x)"}, {"line": "simp_rw [apply_ite k]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf g : \u03b1 \u2192 \u03b3\nk : \u03b3 \u2192 \u03b2\nh : \u2200 x \u2208 s, \u00acp x\n\u22a2 (\u220f x \u2208 s, if p x then k (f x) else k (g x)) = \u220f x \u2208 s, k (g x)"}, {"line": "exact prod_ite_of_false h _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_apply_ite_of_true {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b3) (k : \u03b3 \u2192 \u03b2)\n    (h : \u2200 x \u2208 s, p x) : (\u220f x \u2208 s, k (if p x then f x else g x)) = \u220f x \u2208 s, k (f x) := by\n  simp_rw [apply_ite k]\n  exact prod_ite_of_true h _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf g : \u03b1 \u2192 \u03b3\nk : \u03b3 \u2192 \u03b2\nh : \u2200 x \u2208 s, p x\n\u22a2 \u220f x \u2208 s, k (if p x then f x else g x) = \u220f x \u2208 s, k (f x)"}, {"line": "simp_rw [apply_ite k]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\n\u03b3 : Type u_5\ns : Finset \u03b1\ninst\u271d : CommMonoid \u03b2\np : \u03b1 \u2192 Prop\nhp : DecidablePred p\nf g : \u03b1 \u2192 \u03b3\nk : \u03b3 \u2192 \u03b2\nh : \u2200 x \u2208 s, p x\n\u22a2 (\u220f x \u2208 s, if p x then k (f x) else k (g x)) = \u220f x \u2208 s, k (f x)"}, {"line": "exact prod_ite_of_true h _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ite_mem [DecidableEq \u03b1] (s t : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    \u220f i \u2208 s, (if i \u2208 t then f i else 1) = \u220f i \u2208 s \u2229 t, f i := by\n  rw [\u2190 Finset.prod_filter]\n  rw [Finset.filter_mem_eq_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u220f i \u2208 s, if i \u2208 t then f i else 1) = \u220f i \u2208 s \u2229 t, f i"}, {"line": "rw [\u2190 Finset.prod_filter]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u220f a \u2208 {a \u2208 s | a \u2208 t}, f a = \u220f i \u2208 s \u2229 t, f i"}, {"line": "rw [Finset.filter_mem_eq_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_attach_eq_prod_dite [Fintype \u03b1] (s : Finset \u03b1) (f : s \u2192 \u03b2) [DecidablePred (\u00b7 \u2208 s)] :\n    \u220f i \u2208 s.attach, f i = \u220f i, if h : i \u2208 s then f \u27e8i, h\u27e9 else 1 := by\n  rw [Finset.prod_dite]\n  rw [Finset.univ_eq_attach]\n  rw [Finset.prod_const_one]\n  rw [mul_one]\n  congr\n  \u00b7 ext; simp\n  \u00b7 ext; simp\n  \u00b7 apply Function.hfunext <;> simp +contextual [Subtype.heq_iff_coe_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 \u220f i \u2208 s.attach, f i = \u220f i, if h : i \u2208 s then f \u27e8i, h\u27e9 else 1"}, {"line": "rw [Finset.prod_dite]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 \u220f i \u2208 s.attach, f i = (\u220f x, f \u27e8\u2191x, \u22ef\u27e9) * \u220f x, 1"}, {"line": "rw [Finset.univ_eq_attach]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 \u220f i \u2208 s.attach, f i = (\u220f x \u2208 {x | x \u2208 s}.attach, f \u27e8\u2191x, \u22ef\u27e9) * \u220f x, 1"}, {"line": "rw [Finset.prod_const_one]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 \u220f i \u2208 s.attach, f i = (\u220f x \u2208 {x | x \u2208 s}.attach, f \u27e8\u2191x, \u22ef\u27e9) * 1"}, {"line": "rw [mul_one]", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 \u220f i \u2208 s.attach, f i = \u220f x \u2208 {x | x \u2208 s}.attach, f \u27e8\u2191x, \u22ef\u27e9"}, {"line": "congr", "tactic_state": "case h.e_1.e_p\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 (fun x => x \u2208 s) = fun x => x \u2208 {x | x \u2208 s}\n---\ncase h.e_4.e_2.h\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 s = {x | x \u2208 s}\n---\ncase h.e_5\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 HEq (fun i => f i) fun x => f \u27e8\u2191x, \u22ef\u27e9"}, {"line": "\u00b7 ext; simp", "tactic_state": "case h.e_4.e_2.h\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 s = {x | x \u2208 s}\n---\ncase h.e_5\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 HEq (fun i => f i) fun x => f \u27e8\u2191x, \u22ef\u27e9"}, {"line": "\u00b7 ext; simp", "tactic_state": "case h.e_5\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b2\ninst\u271d\u00b9 : Fintype \u03b1\ns : Finset \u03b1\nf : { x // x \u2208 s } \u2192 \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 HEq (fun i => f i) fun x => f \u27e8\u2191x, \u22ef\u27e9"}, {"line": "\u00b7 apply Function.hfunext <;> simp +contextual [Subtype.heq_iff_coe_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_inter_mul_prod_diff [DecidableEq \u03b1] (s t : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (\u220f x \u2208 s \u2229 t, f x) * \u220f x \u2208 s \\ t, f x = \u220f x \u2208 s, f x := by\n  convert (s.prod_piecewise t f f).symm\n  simp +unfoldPartialApp [Finset.piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u220f x \u2208 s \u2229 t, f x) * \u220f x \u2208 s \\ t, f x = \u220f x \u2208 s, f x"}, {"line": "convert (s.prod_piecewise t f f).symm", "tactic_state": "case h.e'_3.a.h.e\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns t : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u03b1\na\u271d : x\u271d \u2208 s\n\u22a2 f = t.piecewise f f"}, {"line": "simp +unfoldPartialApp [Finset.piecewise]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_mul_prod_diff_singleton [DecidableEq \u03b1] {s : Finset \u03b1} {i : \u03b1} (h : i \u2208 s)\n    (f : \u03b1 \u2192 \u03b2) : \u220f x \u2208 s, f x = f i * \u220f x \u2208 s \\ {i}, f x := by\n  convert (s.prod_inter_mul_prod_diff {i} f).symm\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\ni : \u03b1\nh : i \u2208 s\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u220f x \u2208 s, f x = f i * \u220f x \u2208 s \\ {i}, f x"}, {"line": "convert (s.prod_inter_mul_prod_diff {i} f).symm", "tactic_state": "case h.e'_3.h.e'_5\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\ni : \u03b1\nh : i \u2208 s\nf : \u03b1 \u2192 \u03b2\n\u22a2 f i = \u220f x \u2208 s \u2229 {i}, f x"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_prod_of_mem (f : \u03b1 \u2192 \u03b2) {a : \u03b1} {s : Finset \u03b1} (ha : a \u2208 s) : f a \u2223 \u220f i \u2208 s, f i := by\n  classical\n    rw [Finset.prod_eq_mul_prod_diff_singleton ha]\n    exact dvd_mul_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d : CommMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Finset \u03b1\nha : a \u2208 s\n\u22a2 f a \u2223 \u220f i \u2208 s, f i"}, {"line": "classical\n    rw [Finset.prod_eq_mul_prod_diff_singleton ha]\n    exact dvd_mul_right _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_pow_boole [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (\u220f x \u2208 s, f x ^ ite (a = x) 1 0) = ite (a \u2208 s) (f a) 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 (\u220f x \u2208 s, f x ^ if a = x then 1 else 0) = if a \u2208 s then f a else 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_ite_mem (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : \u220f i, (if i \u2208 s then f i else 1) = \u220f i \u2208 s, f i := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]", "[CommMonoid \u03b1] [Fintype \u03b9]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u220f i, if i \u2208 s then f i else 1) = \u220f i \u2208 s, f i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_ite_eq (i : \u03b9) (f : \u03b9 \u2192 \u03b1) : \u220f j, (if i = j then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq]\n  rw [if_pos (mem_univ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]", "[CommMonoid \u03b1] [Fintype \u03b9]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u220f j, if i = j then f j else 1) = f i"}, {"line": "rw [Finset.prod_ite_eq]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (if i \u2208 univ then f i else 1) = f i"}, {"line": "rw [if_pos (mem_univ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_ite_eq' (i : \u03b9) (f : \u03b9 \u2192 \u03b1) : \u220f j, (if j = i then f j else 1) = f i := by\n  rw [Finset.prod_ite_eq']\n  rw [if_pos (mem_univ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Finset/Piecewise.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 \u03b3 : Type*} {s : Finset \u03b1}", "[CommMonoid \u03b2]", "[CommMonoid \u03b1] [Fintype \u03b9]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u220f j, if j = i then f j else 1) = f i"}, {"line": "rw [Finset.prod_ite_eq']", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 (if i \u2208 univ then f i else 1) = f i"}, {"line": "rw [if_pos (mem_univ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_hom\u2082_nonempty {l : List \u03b9} (f : M \u2192 N \u2192 P)\n    (hf : \u2200 a b c d, f (a * b) (c * d) = f a c * f b d) (f\u2081 : \u03b9 \u2192 M) (f\u2082 : \u03b9 \u2192 N) (hl : l \u2260 []) :\n    (l.map fun i => f (f\u2081 i) (f\u2082 i)).prod = f (l.map f\u2081).prod (l.map f\u2082).prod := by\n  match l, hl with | x :: xs, hl => induction xs generalizing x <;> aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nN : Type u_4\nP : Type u_2\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : Monoid N\ninst\u271d : Monoid P\n\u03b9 : Type u_1\nl : List \u03b9\nf : M \u2192 N \u2192 P\nhf : \u2200 (a b : M) (c d : N), f (a * b) (c * d) = f a c * f b d\nf\u2081 : \u03b9 \u2192 M\nf\u2082 : \u03b9 \u2192 N\nhl : l \u2260 []\n\u22a2 (List.map (fun i => f (f\u2081 i) (f\u2082 i)) l).prod = f (List.map f\u2081 l).prod (List.map f\u2082 l).prod"}, {"line": "match l, hl with | x :: xs, hl => induction xs generalizing x <;> aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_take_mul_prod_drop (L : List M) (i : \u2115) :\n    (L.take i).prod * (L.drop i).prod = L.prod := by\n  simp [\u2190 prod_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\nL : List M\ni : \u2115\n\u22a2 (List.take i L).prod * (List.drop i L).prod = L.prod"}, {"line": "simp [\u2190 prod_append]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_pos_of_prod_ne_one (L : List M) (h : L.prod \u2260 1) : 0 < L.length := by\n  cases L\n  \u00b7 simp at h\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\nL : List M\nh : L.prod \u2260 1\n\u22a2 0 < L.length"}, {"line": "cases L", "tactic_state": "case nil\nM : Type u_1\ninst\u271d : Monoid M\nh : [].prod \u2260 1\n\u22a2 0 < [].length\n---\ncase cons\nM : Type u_1\ninst\u271d : Monoid M\nhead\u271d : M\ntail\u271d : List M\nh : (head\u271d :: tail\u271d).prod \u2260 1\n\u22a2 0 < (head\u271d :: tail\u271d).length"}, {"line": "\u00b7 simp at h", "tactic_state": "case cons\nM : Type u_1\ninst\u271d : Monoid M\nhead\u271d : M\ntail\u271d : List M\nh : (head\u271d :: tail\u271d).prod \u2260 1\n\u22a2 0 < (head\u271d :: tail\u271d).length"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getElem?_zero_mul_tail_prod (l : List M) : l[0]?.getD 1 * l.tail.prod = l.prod := by\n  cases l <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Monoid M\nl : List M\n\u22a2 l[0]?.getD 1 * l.tail.prod = l.prod"}, {"line": "cases l <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem headI_mul_tail_prod_of_ne_nil [Inhabited M] (l : List M) (h : l \u2260 []) :\n    l.headI * l.tail.prod = l.prod := by cases l <;> [contradiction; simp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\ninst\u271d : Inhabited M\nl : List M\nh : l \u2260 []\n\u22a2 l.headI * l.tail.prod = l.prod"}, {"line": "cases l <;> [contradiction; simp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem headI_add_tail_sum (L : List \u2115) : L.headI + L.tail.sum = L.sum := by\n  cases L <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[CommMonoid M] {a : M} {l l\u2081 l\u2082 : List M}", "[Group G]", "[CommGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : List \u2115\n\u22a2 L.headI + L.tail.sum = L.sum"}, {"line": "cases L <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_int_mod (l : List \u2124) (n : \u2124) : l.sum % n = (l.map (\u00b7 % n)).sum % n := by\n  induction l <;> simp [Int.add_emod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[CommMonoid M] {a : M} {l l\u2081 l\u2082 : List M}", "[Group G]", "[CommGroup G]", "[One \u03b1] [Mul \u03b1] [Inv \u03b1]", "[CommGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : List \u2124\nn : \u2124\n\u22a2 l.sum % n = (List.map (fun x => x % n) l).sum % n"}, {"line": "induction l <;> simp [Int.add_emod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_int_mod (l : List \u2124) (n : \u2124) : l.prod % n = (l.map (\u00b7 % n)).prod % n := by\n  induction l <;> simp [Int.mul_emod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[CommMonoid M] {a : M} {l l\u2081 l\u2082 : List M}", "[Group G]", "[CommGroup G]", "[One \u03b1] [Mul \u03b1] [Inv \u03b1]", "[CommGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : List \u2124\nn : \u2124\n\u22a2 l.prod % n = (List.map (fun x => x % n) l).prod % n"}, {"line": "induction l <;> simp [Int.mul_emod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma take_sum_flatten (L : List (List \u03b1)) (i : \u2115) :\n    L.flatten.take ((L.map length).take i).sum = (L.take i).flatten := by\n  induction L generalizing i\n  \u00b7 simp\n  \u00b7 cases i <;> simp [take_append, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[CommMonoid M] {a : M} {l l\u2081 l\u2082 : List M}", "[Group G]", "[CommGroup G]", "[One \u03b1] [Mul \u03b1] [Inv \u03b1]", "[CommGroup \u03b1]", "[Monoid M] [Monoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nL : List (List \u03b1)\ni : \u2115\n\u22a2 List.take (List.take i (List.map length L)).sum L.flatten = (List.take i L).flatten"}, {"line": "induction L generalizing i", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\ni : \u2115\n\u22a2 List.take (List.take i (List.map length [])).sum [].flatten = (List.take i []).flatten\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\ntail_ih\u271d : \u2200 (i : \u2115), List.take (List.take i (List.map length tail\u271d)).sum tail\u271d.flatten = (List.take i tail\u271d).flatten\ni : \u2115\n\u22a2 List.take (List.take i (List.map length (head\u271d :: tail\u271d))).sum (head\u271d :: tail\u271d).flatten =\n    (List.take i (head\u271d :: tail\u271d)).flatten"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\ntail_ih\u271d : \u2200 (i : \u2115), List.take (List.take i (List.map length tail\u271d)).sum tail\u271d.flatten = (List.take i tail\u271d).flatten\ni : \u2115\n\u22a2 List.take (List.take i (List.map length (head\u271d :: tail\u271d))).sum (head\u271d :: tail\u271d).flatten =\n    (List.take i (head\u271d :: tail\u271d)).flatten"}, {"line": "\u00b7 cases i <;> simp [take_append, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma drop_sum_flatten (L : List (List \u03b1)) (i : \u2115) :\n    L.flatten.drop ((L.map length).take i).sum = (L.drop i).flatten := by\n  induction L generalizing i\n  \u00b7 simp\n  \u00b7 cases i <;> simp [take_append, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Basic.lean", "context": {"open": ["scoped Relator in"], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[CommMonoid M] {a : M} {l l\u2081 l\u2082 : List M}", "[Group G]", "[CommGroup G]", "[One \u03b1] [Mul \u03b1] [Inv \u03b1]", "[CommGroup \u03b1]", "[Monoid M] [Monoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nL : List (List \u03b1)\ni : \u2115\n\u22a2 List.drop (List.take i (List.map length L)).sum L.flatten = (List.drop i L).flatten"}, {"line": "induction L generalizing i", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\ni : \u2115\n\u22a2 List.drop (List.take i (List.map length [])).sum [].flatten = (List.drop i []).flatten\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\ntail_ih\u271d : \u2200 (i : \u2115), List.drop (List.take i (List.map length tail\u271d)).sum tail\u271d.flatten = (List.drop i tail\u271d).flatten\ni : \u2115\n\u22a2 List.drop (List.take i (List.map length (head\u271d :: tail\u271d))).sum (head\u271d :: tail\u271d).flatten =\n    (List.drop i (head\u271d :: tail\u271d)).flatten"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d\u00b3 : One \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Inv \u03b1\ninst\u271d : CommGroup \u03b1\nlength : List \u03b1 \u2192 \u2115\nhead\u271d : List \u03b1\ntail\u271d : List (List \u03b1)\ntail_ih\u271d : \u2200 (i : \u2115), List.drop (List.take i (List.map length tail\u271d)).sum tail\u271d.flatten = (List.drop i tail\u271d).flatten\ni : \u2115\n\u22a2 List.drop (List.take i (List.map length (head\u271d :: tail\u271d))).sum (head\u271d :: tail\u271d).flatten =\n    (List.drop i (head\u271d :: tail\u271d)).flatten"}, {"line": "\u00b7 cases i <;> simp [take_append, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_map_count_dedup_eq_length (l : List \u03b1) :\n    (l.dedup.map fun x => l.count x).sum = l.length := by\n  simpa using sum_map_count_dedup_filter_eq_countP (fun _ => True) l\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[Group G]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\n\u22a2 (List.map (fun x => List.count x l) l.dedup).sum = l.length"}, {"line": "simpa using sum_map_count_dedup_filter_eq_countP (fun _ => True) l", "tactic_state": "No Goals!"}]}
{"declaration": "lemma length_sigma {\u03c3 : \u03b1 \u2192 Type*} (l\u2081 : List \u03b1) (l\u2082 : \u2200 a, List (\u03c3 a)) :\n    length (l\u2081.sigma l\u2082) = (l\u2081.map fun a \u21a6 length (l\u2082 a)).sum := by\n  induction' l\u2081 with x l\u2081 IH\n  \u00b7 rfl\n  \u00b7 simp only [sigma_cons, length_append, length_map, IH, map, sum_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/List/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 M N P G : Type*}", "[Monoid M] [Monoid N] [Monoid P] {l l\u2081 l\u2082 : List M} {a : M}", "[Group G]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_9\nlength : x\u271d\n\u03c3 : \u03b1 \u2192 Type u_8\nl\u2081 : List \u03b1\nl\u2082 : (a : \u03b1) \u2192 List (\u03c3 a)\n\u22a2 sorry = (List.map (fun a => ?m.264) l\u2081).sum"}, {"line": "induction' l\u2081 with x l\u2081 IH", "tactic_state": "case nil\n\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_9\nlength : x\u271d\n\u03c3 : \u03b1 \u2192 Type u_8\nl\u2082 : (a : \u03b1) \u2192 List (\u03c3 a)\n\u22a2 sorry = (List.map (fun a => ?m.8107 [] l\u2082 a) []).sum\n---\ncase cons\n\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_9\nlength : x\u271d\n\u03c3 : \u03b1 \u2192 Type u_8\nl\u2082 : (a : \u03b1) \u2192 List (\u03c3 a)\nx : \u03b1\nl\u2081 : List \u03b1\nIH : sorry = (List.map (fun a => ?m.264) l\u2081).sum\n\u22a2 sorry = (List.map (fun a => ?m.8107 (x :: l\u2081) l\u2082 a) (x :: l\u2081)).sum"}, {"line": "\u00b7 rfl", "tactic_state": "case cons\n\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_9\nlength : x\u271d\n\u03c3 : \u03b1 \u2192 Type u_8\nl\u2082 : (a : \u03b1) \u2192 List (\u03c3 a)\nx : \u03b1\nl\u2081 : List \u03b1\nIH : sorry = (List.map (fun a => ?m.264) l\u2081).sum\n\u22a2 sorry = (List.map (fun a => ?m.8107 (x :: l\u2081) l\u2082 a) (x :: l\u2081)).sum"}, {"line": "\u00b7 simp only [sigma_cons, length_append, length_map, IH, map, sum_cons]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_map_eq_pow_single [DecidableEq \u03b9] (i : \u03b9)\n    (hf : \u2200 i' \u2260 i, i' \u2208 m \u2192 f i' = 1) : (m.map f).prod = f i ^ m.count i := by\n  induction m using Quotient.inductionOn\n  simp [List.prod_map_eq_pow_single i f hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\nm : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 m \u2192 f i' = 1\n\u22a2 (Multiset.map f m).prod = f i ^ Multiset.count i m"}, {"line": "induction m using Quotient.inductionOn", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\nm : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\na\u271d : List \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 \u27e6a\u271d\u27e7 \u2192 f i' = 1\n\u22a2 (Multiset.map f \u27e6a\u271d\u27e7).prod = f i ^ Multiset.count i \u27e6a\u271d\u27e7"}, {"line": "simp [List.prod_map_eq_pow_single i f hf]", "tactic_state": "case h\n\u03b9 : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\nm : Multiset \u03b9\nf : \u03b9 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b9\ni : \u03b9\na\u271d : List \u03b9\nhf : \u2200 (i' : \u03b9), i' \u2260 i \u2192 i' \u2208 \u27e6a\u271d\u27e7 \u2192 f i' = 1\n\u22a2 (List.map f a\u271d).prod = f i ^ List.count i a\u271d"}]}
{"declaration": "theorem prod_hom' (s : Multiset \u03b9) {F : Type*} [FunLike F \u03b1 \u03b2]\n    [MonoidHomClass F \u03b1 \u03b2] (f : F)\n    (g : \u03b9 \u2192 \u03b1) : (s.map fun i => f <| g i).prod = f (s.map g).prod := by\n  convert (s.map g).prod_hom f\n  exact (map_map _ _ _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b2\ns : Multiset \u03b9\nF : Type u_7\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\ng : \u03b9 \u2192 \u03b1\n\u22a2 (Multiset.map (fun i => f (g i)) s).prod = f (Multiset.map g s).prod"}, {"line": "convert (s.map g).prod_hom f", "tactic_state": "case h.e'_2.h.e'_3\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b2\ns : Multiset \u03b9\nF : Type u_7\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\ng : \u03b9 \u2192 \u03b1\n\u22a2 Multiset.map (fun i => f (g i)) s = Multiset.map (\u21d1f) (Multiset.map g s)\n---\ncase convert_5\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b2\ns : Multiset \u03b9\nF : Type u_7\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\ng : \u03b9 \u2192 \u03b1\n\u22a2 MonoidHomClass F \u03b1 \u03b2"}, {"line": "exact (map_map _ _ _).symm", "tactic_state": "case convert_5\n\u03b9 : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b2\ns : Multiset \u03b9\nF : Type u_7\ninst\u271d\u00b9 : FunLike F \u03b1 \u03b2\ninst\u271d : MonoidHomClass F \u03b1 \u03b2\nf : F\ng : \u03b9 \u2192 \u03b1\n\u22a2 MonoidHomClass F \u03b1 \u03b2"}]}
{"declaration": "theorem prod_dvd_prod_of_dvd [CommMonoid \u03b2] {S : Multiset \u03b1} (g1 g2 : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a \u2208 S, g1 a \u2223 g2 a) : (Multiset.map g1 S).prod \u2223 (Multiset.map g2 S).prod := by\n  apply Multiset.induction_on' S\n  \u00b7 simp\n  intro a T haS _ IH\n  simp [mul_dvd_mul (h a haS) IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\n\u22a2 (Multiset.map g1 S).prod \u2223 (Multiset.map g2 S).prod"}, {"line": "apply Multiset.induction_on' S", "tactic_state": "case h\u2081\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\n\u22a2 (Multiset.map g1 0).prod \u2223 (Multiset.map g2 0).prod\n---\ncase h\u2082\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\n\u22a2 \u2200 {a : \u03b1} {s : Multiset \u03b1},\n    a \u2208 S \u2192\n      s \u2286 S \u2192\n        (Multiset.map g1 s).prod \u2223 (Multiset.map g2 s).prod \u2192\n          (Multiset.map g1 (insert a s)).prod \u2223 (Multiset.map g2 (insert a s)).prod"}, {"line": "\u00b7 simp", "tactic_state": "case h\u2082\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\n\u22a2 \u2200 {a : \u03b1} {s : Multiset \u03b1},\n    a \u2208 S \u2192\n      s \u2286 S \u2192\n        (Multiset.map g1 s).prod \u2223 (Multiset.map g2 s).prod \u2192\n          (Multiset.map g1 (insert a s)).prod \u2223 (Multiset.map g2 (insert a s)).prod"}, {"line": "intro a T haS _ IH", "tactic_state": "case h\u2082\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\na : \u03b1\nT : Multiset \u03b1\nhaS : a \u2208 S\na\u271d : T \u2286 S\nIH : (Multiset.map g1 T).prod \u2223 (Multiset.map g2 T).prod\n\u22a2 (Multiset.map g1 (insert a T)).prod \u2223 (Multiset.map g2 (insert a T)).prod"}, {"line": "simp [mul_dvd_mul (h a haS) IH]", "tactic_state": "case h\u2082\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : CommMonoid \u03b2\nS : Multiset \u03b1\ng1 g2 : \u03b1 \u2192 \u03b2\nh : \u2200 a \u2208 S, g1 a \u2223 g2 a\na : \u03b1\nT : Multiset \u03b1\nhaS : a \u2208 S\na\u271d : T \u2286 S\nIH : (Multiset.map g1 T).prod \u2223 (Multiset.map g2 T).prod\n\u22a2 g1 a * (Multiset.map g1 T).prod \u2223 g2 a * (Multiset.map g2 T).prod"}]}
{"declaration": "theorem sum_nat_mod (s : Multiset \u2115) (n : \u2115) : s.sum % n = (s.map (\u00b7 % n)).sum % n := by\n  induction s using Multiset.induction <;> simp [Nat.add_mod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoid \u03b1]", "[DivisionCommMonoid \u03b1] {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Multiset \u2115\nn : \u2115\n\u22a2 s.sum % n = (Multiset.map (fun x => x % n) s).sum % n"}, {"line": "induction s using Multiset.induction <;> simp [Nat.add_mod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_nat_mod (s : Multiset \u2115) (n : \u2115) : s.prod % n = (s.map (\u00b7 % n)).prod % n := by\n  induction s using Multiset.induction <;> simp [Nat.mul_mod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoid \u03b1]", "[DivisionCommMonoid \u03b1] {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Multiset \u2115\nn : \u2115\n\u22a2 s.prod % n = (Multiset.map (fun x => x % n) s).prod % n"}, {"line": "induction s using Multiset.induction <;> simp [Nat.mul_mod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_int_mod (s : Multiset \u2124) (n : \u2124) : s.sum % n = (s.map (\u00b7 % n)).sum % n := by\n  induction s using Multiset.induction <;> simp [Int.add_emod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoid \u03b1]", "[DivisionCommMonoid \u03b1] {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Multiset \u2124\nn : \u2124\n\u22a2 s.sum % n = (Multiset.map (fun x => x % n) s).sum % n"}, {"line": "induction s using Multiset.induction <;> simp [Int.add_emod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_int_mod (s : Multiset \u2124) (n : \u2124) : s.prod % n = (s.map (\u00b7 % n)).prod % n := by\n  induction s using Multiset.induction <;> simp [Int.mul_emod, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Basic.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoid \u03b1]", "[DivisionCommMonoid \u03b1] {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Multiset \u2124\nn : \u2124\n\u22a2 s.prod % n = (Multiset.map (fun x => x % n) s).prod % n"}, {"line": "induction s using Multiset.induction <;> simp [Int.mul_emod, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_replicate (n : \u2115) (a : \u03b1) : (replicate n a).prod = a ^ n := by\n  simp [replicate, List.prod_replicate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Group/Multiset/Defs.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 \u03b2' \u03b3 : Type*}", "[CommMonoid \u03b1] [CommMonoid \u03b2] {s t : Multiset \u03b1} {a : \u03b1} {m : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : CommMonoid \u03b1\nx\u271d : Sort u_7\nreplicate : x\u271d\nn : \u2115\na : \u03b1\n\u22a2 sorry = a ^ n"}, {"line": "simp [replicate, List.prod_replicate]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : CommMonoid \u03b1\nx\u271d : Sort u_7\nreplicate : x\u271d\nn : \u2115\na : \u03b1\n\u22a2 sorry () = a ^ n"}]}
{"declaration": "lemma prod_eq_zero_iff : \u220f x \u2208 s, f x = 0 \u2194 \u2203 a \u2208 s, f a = 0 := by\n  classical\n    induction s using Finset.induction_on with\n    | empty => exact \u27e8Not.elim one_ne_zero, fun \u27e8_, H, _\u27e9 => by simp at H\u27e9\n    | insert _ _ ha ih => rw [prod_insert ha, mul_eq_zero, exists_mem_insert, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 : Type*}", "[CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080} {s : Finset \u03b9}", "[Nontrivial M\u2080] [NoZeroDivisors M\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u00b2 : CommMonoidWithZero M\u2080\nf : \u03b9 \u2192 M\u2080\ns : Finset \u03b9\ninst\u271d\u00b9 : Nontrivial M\u2080\ninst\u271d : NoZeroDivisors M\u2080\n\u22a2 \u220f x \u2208 s, f x = 0 \u2194 \u2203 a \u2208 s, f a = 0"}, {"line": "classical\n    induction s using Finset.induction_on with\n    | empty => exact \u27e8Not.elim one_ne_zero, fun \u27e8_, H, _\u27e9 => by simp at H\u27e9\n    | insert _ _ ha ih => rw [prod_insert ha, mul_eq_zero, exists_mem_insert, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_ite_zero : (\u220f i, if p i then f i else 0) = if \u2200 i, p i then \u220f i, f i else 0 := by\n  simp [Finset.prod_ite_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 : Type*}", "[CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080} {s : Finset \u03b9}", "[Nontrivial M\u2080] [NoZeroDivisors M\u2080]", "[Fintype \u03b9] [CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : CommMonoidWithZero M\u2080\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b9 \u2192 M\u2080\n\u22a2 (\u220f i, if p i then f i else 0) = if \u2200 (i : \u03b9), p i then \u220f i, f i else 0"}, {"line": "simp [Finset.prod_ite_zero]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : CommMonoidWithZero M\u2080\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b9 \u2192 M\u2080\n\u22a2 (if \u2200 i \u2208 Finset.univ, p i then \u220f i, f i else 0) = if \u2200 (i : \u03b9), p i then \u220f i, f i else 0"}]}
{"declaration": "lemma prod_boole : \u220f i, (ite (p i) 1 0 : M\u2080) = ite (\u2200 i, p i) 1 0 := by simp [Finset.prod_boole]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 : Type*}", "[CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080} {s : Finset \u03b9}", "[Nontrivial M\u2080] [NoZeroDivisors M\u2080]", "[Fintype \u03b9] [CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : CommMonoidWithZero M\u2080\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 (\u220f i, if p i then 1 else 0) = if \u2200 (i : \u03b9), p i then 1 else 0"}, {"line": "simp [Finset.prod_boole]", "tactic_state": "\u03b9 : Type u_1\nM\u2080 : Type u_4\ninst\u271d\u2075 : CommMonoidWithZero M\u2080\ninst\u271d\u2074 : Nontrivial M\u2080\ninst\u271d\u00b3 : NoZeroDivisors M\u2080\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : CommMonoidWithZero M\u2080\np : \u03b9 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 (if \u2200 i \u2208 Finset.univ, p i then 1 else 0) = if \u2200 (i : \u03b9), p i then 1 else 0"}]}
{"declaration": "lemma Units.mk0_prod [CommGroupWithZero G\u2080] (s : Finset \u03b9) (f : \u03b9 \u2192 G\u2080) (h) :\n    Units.mk0 (\u220f i \u2208 s, f i) h =\n      \u220f i \u2208 s.attach, Units.mk0 (f i) fun hh \u21a6 h (Finset.prod_eq_zero i.2 hh) := by\n  classical induction s using Finset.induction_on <;> simp [*]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/GroupWithZero/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03ba G\u2080 M\u2080 : Type*}", "[CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080} {s : Finset \u03b9}", "[Nontrivial M\u2080] [NoZeroDivisors M\u2080]", "[Fintype \u03b9] [CommMonoidWithZero M\u2080] {p : \u03b9 \u2192 Prop} [DecidablePred p] {f : \u03b9 \u2192 M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommGroupWithZero G\u2080\ns : Finset \u03b9\nf : \u03b9 \u2192 G\u2080\nh : \u220f i \u2208 s, f i \u2260 0\n\u22a2 mk0 (\u220f i \u2208 s, f i) h = \u220f i \u2208 s.attach, mk0 (f \u2191i) \u22ef"}, {"line": "classical induction s using Finset.induction_on <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_map_neg (l : List M) :\n    (l.map Neg.neg).prod = (-1) ^ l.length * l.prod := by\n  induction l <;> simp [*, pow_succ, ((Commute.neg_one_left _).pow_left _).left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/List.lean", "context": {"open": ["MulOpposite List"], "variables": ["{\u03b9 \u03ba M M\u2080 R : Type*}", "[NonUnitalNonAssocSemiring R]", "[Monoid M] [HasDistribNeg M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b9 : Monoid M\ninst\u271d : HasDistribNeg M\nl : List M\n\u22a2 (map Neg.neg l).prod = (-1) ^ l.length * l.prod"}, {"line": "induction l <;> simp [*, pow_succ, ((Commute.neg_one_left _).pow_left _).left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiset_sum_right (a : \u03b1) (h : \u2200 b \u2208 s, Commute a b) : Commute a s.sum := by\n  induction s using Quotient.inductionOn\n  rw [quot_mk_to_coe]\n  rw [sum_coe]\n  exact Commute.list_sum_right _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/Multiset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[CommMonoid \u03b1] [HasDistribNeg \u03b1]", "[CommMonoidWithZero \u03b1] {s : Multiset \u03b1}", "[NoZeroDivisors \u03b1] [Nontrivial \u03b1] {s : Multiset \u03b1}", "[NonUnitalNonAssocSemiring \u03b1] {a : \u03b1} {s : Multiset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[NonUnitalSemiring \u03b1] {s : Multiset \u03b1} {a : \u03b1}", "[CommSemiring \u03b1]", "[NonUnitalNonAssocSemiring \u03b1] (s : Multiset \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2078 : CommMonoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\ninst\u271d\u2076 : CommMonoidWithZero \u03b1\ninst\u271d\u2075 : NoZeroDivisors \u03b1\ninst\u271d\u2074 : Nontrivial \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\ns : Multiset \u03b1\na : \u03b1\nh : \u2200 b \u2208 s, Commute a b\n\u22a2 Commute a s.sum"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u2078 : CommMonoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\ninst\u271d\u2076 : CommMonoidWithZero \u03b1\ninst\u271d\u2075 : NoZeroDivisors \u03b1\ninst\u271d\u2074 : Nontrivial \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\ns : Multiset \u03b1\na : \u03b1\na\u271d : List \u03b1\nh : \u2200 b \u2208 \u27e6a\u271d\u27e7, Commute a b\n\u22a2 Commute a (sum \u27e6a\u271d\u27e7)"}, {"line": "rw [quot_mk_to_coe]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u2078 : CommMonoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\ninst\u271d\u2076 : CommMonoidWithZero \u03b1\ninst\u271d\u2075 : NoZeroDivisors \u03b1\ninst\u271d\u2074 : Nontrivial \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\ns : Multiset \u03b1\na : \u03b1\na\u271d : List \u03b1\nh : \u2200 b \u2208 \u27e6a\u271d\u27e7, Commute a b\n\u22a2 Commute a (\u2191a\u271d).sum"}, {"line": "rw [sum_coe]", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u2078 : CommMonoid \u03b1\ninst\u271d\u2077 : HasDistribNeg \u03b1\ninst\u271d\u2076 : CommMonoidWithZero \u03b1\ninst\u271d\u2075 : NoZeroDivisors \u03b1\ninst\u271d\u2074 : Nontrivial \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : NonUnitalNonAssocSemiring \u03b1\ns : Multiset \u03b1\na : \u03b1\na\u271d : List \u03b1\nh : \u2200 b \u2208 \u27e6a\u271d\u27e7, Commute a b\n\u22a2 Commute a a\u271d.sum"}, {"line": "exact Commute.list_sum_right _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_mul_boole (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (i : \u03b9) :\n    \u2211 j \u2208 s, f j * ite (i = j) 1 0 = ite (i \u2208 s) (f i) 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/Finset.lean", "context": {"open": ["Fintype"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Finset \u03b9} {i : \u03b9} {a : \u03b1} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoidWithOne \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1] [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2074 : AddCommMonoidWithOne \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 (\u2211 j \u2208 s, f j * if i = j then 1 else 0) = if i \u2208 s then f i else 0"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2074 : AddCommMonoidWithOne \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 (if i \u2208 s then f i * 1 else 0) = if i \u2208 s then f i else 0"}]}
{"declaration": "lemma sum_boole_mul (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (i : \u03b9) :\n    \u2211 j \u2208 s, ite (i = j) 1 0 * f j = ite (i \u2208 s) (f i) 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/Finset.lean", "context": {"open": ["Fintype"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Finset \u03b9} {i : \u03b9} {a : \u03b1} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoidWithOne \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1] [DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2074 : AddCommMonoidWithOne \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 \u2211 j \u2208 s, (if i = j then 1 else 0) * f j = if i \u2208 s then f i else 0"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2074 : AddCommMonoidWithOne \u03b1\ninst\u271d\u00b3 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b2 : NonUnitalSemiring \u03b1\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 (if i \u2208 s then 1 * f i else 0) = if i \u2208 s then f i else 0"}]}
{"declaration": "lemma sum_pow (f : \u03b9 \u2192 \u03b1) (n : \u2115) : (\u2211 a, f a) ^ n = \u2211 p : Fin n \u2192 \u03b9, \u220f i, f (p i) := by\n  simp [sum_pow']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/Finset.lean", "context": {"open": ["Fintype", "Finset"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Finset \u03b9} {i : \u03b9} {a : \u03b1} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoidWithOne \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1] [DecidableEq \u03b9]", "[CommSemiring \u03b1]", "[DecidableEq \u03b9]", "[CommRing \u03b1]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba] [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : Type u_9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : CommSemiring \u03b1\nf : \u03b9 \u2192 \u03b1\nn : \u2115\n\u22a2 (\u2211 a, f a) ^ n = \u2211 p, \u220f i, f (p i)"}, {"line": "simp [sum_pow']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_add (f g : \u03b9 \u2192 \u03b1) : \u220f a, (f a + g a) = \u2211 t, (\u220f a \u2208 t, f a) * \u220f a \u2208 t\u1d9c, g a := by\n  simpa [compl_eq_univ_sdiff] using Finset.prod_add f g univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/BigOperators/Ring/Finset.lean", "context": {"open": ["Fintype", "Finset"], "variables": ["{\u03b9 \u03b9' \u03b1 \u03b2 \u03b3 : Type*} {\u03ba : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Finset \u03b9} {i : \u03b9} {a : \u03b1} {f g : \u03b9 \u2192 \u03b1}", "[AddCommMonoidWithOne \u03b1]", "[NonUnitalNonAssocSemiring \u03b1]", "[NonUnitalSemiring \u03b1]", "[NonAssocSemiring \u03b1] [DecidableEq \u03b9]", "[CommSemiring \u03b1]", "[DecidableEq \u03b9]", "[CommRing \u03b1]", "{\u03b9 \u03ba \u03b1 : Type*} [Fintype \u03b9] [Fintype \u03ba] [CommSemiring \u03b1]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : CommSemiring \u03b1\ninst\u271d : DecidableEq \u03b9\nf g : \u03b9 \u2192 \u03b1\n\u22a2 \u220f a, (f a + g a) = \u2211 t, (\u220f a \u2208 t, f a) * \u220f a \u2208 t\u1d9c, g a"}, {"line": "simpa [compl_eq_univ_sdiff] using Finset.prod_add f g univ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (A : AlgebraCat.{v} R) (a : A) :\n    (\ud835\udfd9 A : A \u27f6 A) a = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["(R : Type u) [CommRing R]", "{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nA : AlgebraCat R\na : \u2191A\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id A)) a = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {A B C : AlgebraCat.{v} R} (f : A \u27f6 B) (g : B \u27f6 C) (a : A) :\n    (f \u226b g) a = g (f a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/AlgebraCat/Basic.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["(R : Type u) [CommRing R]", "{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nA B C : AlgebraCat R\nf : A \u27f6 B\ng : B \u27f6 C\na : \u2191A\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) a = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) a)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem coevaluation_evaluation :\n    letI V' : FGModuleCat K := FGModuleCatDual K V\n    V' \u25c1 FGModuleCatCoevaluation K V \u226b (\u03b1_ V' V V').inv \u226b FGModuleCatEvaluation K V \u25b7 V' =\n      (\u03c1_ V').hom \u226b (\u03bb_ V').inv := by\n  ext : 1\n  apply contractLeft_assoc_coevaluation K V\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/FGModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "MonoidalCategory", "CategoryTheory.MonoidalCategory"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}", "(R : Type u) [Ring R]", "{R} in", "{R} in", "{R}", "(R : Type u) [CommRing R]", "(K : Type u) [Field K]", "(V W : FGModuleCat K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nV : FGModuleCat K\nx\u271d\u00b2 : Sort u_1\nFGModuleCatDual : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nFGModuleCatCoevaluation : x\u271d\u00b9\nx\u271d : Sort u_3\nFGModuleCatEvaluation : x\u271d\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft sorry sorry)\n      (CategoryStruct.comp (associator sorry V sorry).inv (MonoidalCategoryStruct.whiskerRight sorry sorry)) =\n    CategoryStruct.comp (rightUnitor sorry).hom (leftUnitor sorry).inv"}, {"line": "ext : 1", "tactic_state": "case h\nK : Type u\ninst\u271d : Field K\nV : FGModuleCat K\nx\u271d\u00b2 : Sort u_1\nFGModuleCatDual : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nFGModuleCatCoevaluation : x\u271d\u00b9\nx\u271d : Sort u_3\nFGModuleCatEvaluation : x\u271d\n\u22a2 ConcreteCategory.hom\n      (CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft sorry sorry)\n        (CategoryStruct.comp (associator sorry V sorry).inv (MonoidalCategoryStruct.whiskerRight sorry sorry))) =\n    ConcreteCategory.hom (CategoryStruct.comp (rightUnitor sorry).hom (leftUnitor sorry).inv)"}, {"line": "apply contractLeft_assoc_coevaluation K V", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem evaluation_coevaluation :\n    FGModuleCatCoevaluation K V \u25b7 V \u226b\n        (\u03b1_ V (FGModuleCatDual K V) V).hom \u226b V \u25c1 FGModuleCatEvaluation K V =\n      (\u03bb_ V).hom \u226b (\u03c1_ V).inv := by\n  ext : 1\n  apply contractLeft_assoc_coevaluation' K V\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/FGModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "MonoidalCategory", "CategoryTheory.MonoidalCategory"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}", "(R : Type u) [Ring R]", "{R} in", "{R} in", "{R}", "(R : Type u) [CommRing R]", "(K : Type u) [Field K]", "(V W : FGModuleCat K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nV : FGModuleCat K\nx\u271d\u00b2 : Sort u_1\nFGModuleCatCoevaluation : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nFGModuleCatDual : x\u271d\u00b9\nx\u271d : Sort u_3\nFGModuleCatEvaluation : x\u271d\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight sorry V)\n      (CategoryStruct.comp (associator V sorry V).hom (MonoidalCategoryStruct.whiskerLeft V sorry)) =\n    CategoryStruct.comp (leftUnitor V).hom (rightUnitor V).inv"}, {"line": "ext : 1", "tactic_state": "case h\nK : Type u\ninst\u271d : Field K\nV : FGModuleCat K\nx\u271d\u00b2 : Sort u_1\nFGModuleCatCoevaluation : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\nFGModuleCatDual : x\u271d\u00b9\nx\u271d : Sort u_3\nFGModuleCatEvaluation : x\u271d\n\u22a2 ConcreteCategory.hom\n      (CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight sorry V)\n        (CategoryStruct.comp (associator V sorry V).hom (MonoidalCategoryStruct.whiskerLeft V sorry))) =\n    ConcreteCategory.hom (CategoryStruct.comp (leftUnitor V).hom (rightUnitor V).inv)"}, {"line": "apply contractLeft_assoc_coevaluation' K V", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : Grp) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Grp\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y T : Grp} (f : X \u27f6 Y) (g : Y \u27f6 T) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y T : Grp\nf : X \u27f6 Y\ng : Y \u27f6 T\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : Grp} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Grp\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : Grp} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Grp\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example {R S : Grp} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : ?m.5\nR S : Grp\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (ConcreteCategory.hom i) r = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : CommGrp) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : CommGrp\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y T : CommGrp} (f : X \u27f6 Y) (g : Y \u27f6 T) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y T : CommGrp\nf : X \u27f6 Y\ng : Y \u27f6 T\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : CommGrp} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : CommGrp\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example {R S : CommGrp} (i : R \u27f6 S) (r : R) (h : r = 1) : i r = 1 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : ?m.5\nR S : CommGrp\ni : R \u27f6 S\nr : \u2191R\nh : r = 1\n\u22a2 (ConcreteCategory.hom i) r = 1"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.comp_id_grp {G : Grp.{u}} {H : Type u} [Monoid H] (f : G \u2192* H) :\n    f.comp (Grp.Hom.hom (\ud835\udfd9 G)) = f := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Grp\nH : Type u\ninst\u271d : Monoid H\nf : \u2191G \u2192* H\n\u22a2 f.comp (Grp.Hom.hom (CategoryStruct.id G)) = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.id_grp_comp {G : Type u} [Monoid G] {H : Grp.{u}} (f : G \u2192* H) :\n    MonoidHom.comp (Grp.Hom.hom (\ud835\udfd9 H)) f = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Monoid G\nH : Grp\nf : G \u2192* \u2191H\n\u22a2 (Grp.Hom.hom (CategoryStruct.id H)).comp f = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.comp_id_commGrp {G : CommGrp.{u}} {H : Type u} [Monoid H] (f : G \u2192* H) :\n    f.comp (CommGrp.Hom.hom (\ud835\udfd9 G)) = f := by\n  simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : CommGrp\nH : Type u\ninst\u271d : Monoid H\nf : \u2191G \u2192* H\n\u22a2 f.comp (CommGrp.Hom.hom (CategoryStruct.id G)) = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.id_commGrp_comp {G : Type u} [Monoid G] {H : CommGrp.{u}} (f : G \u2192* H) :\n    MonoidHom.comp (CommGrp.Hom.hom (\ud835\udfd9 H)) f = f := by\n  simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Monoid G\nH : CommGrp\nf : G \u2192* \u2191H\n\u22a2 (CommGrp.Hom.hom (CategoryStruct.id H)).comp f = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasLimit_iff_small_sections :\n    HasLimit F \u2194 Small.{u} (F \u22d9 forget Grp).sections := by\n  constructor\n  \u00b7 apply Concrete.small_sections_of_hasLimit\n  \u00b7 intro\n    infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "(F : J \u2964 Grp.{u})", "[Small.{u} (Functor.sections (F \u22d9 forget Grp))]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget Grp)).sections\n\u22a2 HasLimit F \u2194 Small.{u, max u v} \u2191(F.comp (forget Grp)).sections"}, {"line": "constructor", "tactic_state": "case mp\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget Grp)).sections\n\u22a2 HasLimit F \u2192 Small.{u, max u v} \u2191(F.comp (forget Grp)).sections\n---\ncase mpr\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget Grp)).sections\n\u22a2 Small.{u, max u v} \u2191(F.comp (forget Grp)).sections \u2192 HasLimit F"}, {"line": "\u00b7 apply Concrete.small_sections_of_hasLimit", "tactic_state": "case mpr\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget Grp)).sections\n\u22a2 Small.{u, max u v} \u2191(F.comp (forget Grp)).sections \u2192 HasLimit F"}, {"line": "\u00b7 intro\n    infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasLimit_iff_small_sections :\n    HasLimit F \u2194 Small.{u} (F \u22d9 forget CommGrp).sections := by\n  constructor\n  \u00b7 apply Concrete.small_sections_of_hasLimit\n  \u00b7 intro\n    infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "(F : J \u2964 Grp.{u})", "[Small.{u} (Functor.sections (F \u22d9 forget Grp))]", "(F : J \u2964 CommGrp.{u})", "[Small.{u} (Functor.sections (F \u22d9 forget CommGrp))]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\n\u22a2 HasLimit F \u2194 Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections"}, {"line": "constructor", "tactic_state": "case mp\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\n\u22a2 HasLimit F \u2192 Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\n---\ncase mpr\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\n\u22a2 Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections \u2192 HasLimit F"}, {"line": "\u00b7 apply Concrete.small_sections_of_hasLimit", "tactic_state": "case mpr\nJ : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\n\u22a2 Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections \u2192 HasLimit F"}, {"line": "\u00b7 intro\n    infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u2115 \u2192 AddCommGrp) : HasProduct f := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/Limits.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "(F : J \u2964 Grp.{u})", "[Small.{u} (Functor.sections (F \u22d9 forget Grp))]", "(F : J \u2964 CommGrp.{u})", "[Small.{u} (Functor.sections (F \u22d9 forget CommGrp))]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type v\ninst\u271d\u00b2 : Category.{w, v} J\nF\u271d : CategoryTheory.Functor J Grp\ninst\u271d\u00b9 : Small.{u, max u v} \u2191(F\u271d.comp (forget Grp)).sections\nF : CategoryTheory.Functor J CommGrp\ninst\u271d : Small.{u, max u v} \u2191(F.comp (forget CommGrp)).sections\nf : \u2115 \u2192 AddCommGrp\n\u22a2 HasProduct f"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem \u03bc_forget_apply {G H : Grp.{u}} (p : G) (q : H) :\n    Functor.LaxMonoidal.\u03bc (forget Grp.{u}) G H (p, q) = (p, q) := by\n  apply Prod.ext\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget Grp.{u}) G H) (p, q)\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget Grp.{u}) G H) (p, q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/ChosenFiniteProducts.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G H : Grp\np : \u2191G\nq : \u2191H\n\u22a2 Functor.LaxMonoidal.\u03bc (forget Grp) G H (p, q) = (p, q)"}, {"line": "apply Prod.ext", "tactic_state": "case fst\nG H : Grp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget Grp) G H (p, q)).1 = (p, q).1\n---\ncase snd\nG H : Grp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget Grp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget Grp.{u}) G H) (p, q)", "tactic_state": "case snd\nG H : Grp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget Grp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget Grp.{u}) G H) (p, q)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem \u03bc_forget_apply {G H : AddGrp.{u}} (p : G) (q : H) :\n    Functor.LaxMonoidal.\u03bc (forget AddGrp.{u}) G H (p, q) = (p, q) := by\n  apply Prod.ext\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget AddGrp.{u}) G H) (p, q)\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget AddGrp.{u}) G H) (p, q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/ChosenFiniteProducts.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G H : AddGrp\np : \u2191G\nq : \u2191H\n\u22a2 Functor.LaxMonoidal.\u03bc (forget AddGrp) G H (p, q) = (p, q)"}, {"line": "apply Prod.ext", "tactic_state": "case fst\nG H : AddGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget AddGrp) G H (p, q)).1 = (p, q).1\n---\ncase snd\nG H : AddGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget AddGrp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget AddGrp.{u}) G H) (p, q)", "tactic_state": "case snd\nG H : AddGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget AddGrp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget AddGrp.{u}) G H) (p, q)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem \u03bc_forget_apply {G H : CommGrp.{u}} (p : G) (q : H) :\n    Functor.LaxMonoidal.\u03bc (forget CommGrp.{u}) G H (p, q) = (p, q) := by\n  apply Prod.ext\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget CommGrp.{u}) G H) (p, q)\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget CommGrp.{u}) G H) (p, q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/ChosenFiniteProducts.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G H : CommGrp\np : \u2191G\nq : \u2191H\n\u22a2 Functor.LaxMonoidal.\u03bc (forget CommGrp) G H (p, q) = (p, q)"}, {"line": "apply Prod.ext", "tactic_state": "case fst\nG H : CommGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget CommGrp) G H (p, q)).1 = (p, q).1\n---\ncase snd\nG H : CommGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget CommGrp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget CommGrp.{u}) G H) (p, q)", "tactic_state": "case snd\nG H : CommGrp\np : \u2191G\nq : \u2191H\n\u22a2 (Functor.LaxMonoidal.\u03bc (forget CommGrp) G H (p, q)).2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget CommGrp.{u}) G H) (p, q)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem \u03bc_forget_apply {G H : AddCommGrp.{u}} (p : G) (q : H) :\n    Functor.LaxMonoidal.\u03bc (forget AddCommGrp.{u}) G H (p, q) = (p, q) := by\n  apply Prod.ext\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget AddCommGrp.{u}) G H) (p, q)\n  \u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget AddCommGrp.{u}) G H) (p, q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/ChosenFiniteProducts.lean", "context": {"open": ["CategoryTheory Limits MonoidalCategory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G H : AddCommGrp\np : \u2191G\nq : \u2191H\n\u22a2 sorry = (p, q)"}, {"line": "apply Prod.ext", "tactic_state": "case fst\nG H : AddCommGrp\np : \u2191G\nq : \u2191H\n\u22a2 sorry.1 = (p, q).1\n---\ncase snd\nG H : AddCommGrp\np : \u2191G\nq : \u2191H\n\u22a2 sorry.2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_fst (forget AddCommGrp.{u}) G H) (p, q)", "tactic_state": "case snd\nG H : AddCommGrp\np : \u2191G\nq : \u2191H\n\u22a2 sorry.2 = (p, q).2"}, {"line": "\u00b7 exact congrFun (Functor.Monoidal.\u03bc_snd (forget AddCommGrp.{u}) G H) (p, q)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjective_of_epi [Epi f] : Function.Surjective f := by\n  by_contra r\n  dsimp [Function.Surjective] at r\n  push_neg at r\n  rcases r with \u27e8b, hb\u27e9\n  exact\n    SurjectiveOfEpiAuxs.g_ne_h f b (fun \u27e8c, hc\u27e9 => hb _ hc)\n      (congr_arg Grp.Hom.hom ((cancel_epi f).1 (SurjectiveOfEpiAuxs.comp_eq f)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/EpiMono.lean", "context": {"open": ["scoped Pointwise", "QuotientGroup", "CategoryTheory", "XWithInfinity Equiv.Perm"], "variables": ["{A : Type u} {B : Type v}", "[Group A] [Group B]", "[CommGroup A] [CommGroup B]", "{A B : Grp.{u}} (f : A \u27f6 B)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : Grp\nf : A \u27f6 B\ninst\u271d : Epi f\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "by_contra r", "tactic_state": "A B : Grp\nf : A \u27f6 B\ninst\u271d : Epi f\nr : \u00acFunction.Surjective \u21d1(ConcreteCategory.hom f)\n\u22a2 False"}, {"line": "dsimp [Function.Surjective] at r", "tactic_state": "A B : Grp\nf : A \u27f6 B\ninst\u271d : Epi f\nr : \u00ac\u2200 (b : \u2191B), \u2203 a, (ConcreteCategory.hom f) a = b\n\u22a2 False"}, {"line": "push_neg at r", "tactic_state": "A B : Grp\nf : A \u27f6 B\ninst\u271d : Epi f\nr : \u2203 b, \u2200 (a : \u2191A), (ConcreteCategory.hom f) a \u2260 b\n\u22a2 False"}, {"line": "rcases r with \u27e8b, hb\u27e9", "tactic_state": "case intro\nA B : Grp\nf : A \u27f6 B\ninst\u271d : Epi f\nb : \u2191B\nhb : \u2200 (a : \u2191A), (ConcreteCategory.hom f) a \u2260 b\n\u22a2 False"}, {"line": "exact\n    SurjectiveOfEpiAuxs.g_ne_h f b (fun \u27e8c, hc\u27e9 => hb _ hc)\n      (congr_arg Grp.Hom.hom ((cancel_epi f).1 (SurjectiveOfEpiAuxs.comp_eq f)))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem epi_iff_surjective : Epi f \u2194 Function.Surjective f := by\n  have i1 : Epi f \u2194 Epi (groupAddGroupEquivalence.inverse.map f) := by\n    refine \u27e8?_, groupAddGroupEquivalence.inverse.epi_of_epi_map\u27e9\n    intro e'\n    apply groupAddGroupEquivalence.inverse.map_epi\n  rwa [Grp.epi_iff_surjective] at i1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Grp/EpiMono.lean", "context": {"open": ["scoped Pointwise", "QuotientGroup", "CategoryTheory", "XWithInfinity Equiv.Perm"], "variables": ["{A : Type u} {B : Type v}", "[Group A] [Group B]", "[CommGroup A] [CommGroup B]", "{A B : Grp.{u}} (f : A \u27f6 B)", "{A B : AddGrp.{u}} (f : A \u27f6 B)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : AddGrp\nf : A \u27f6 B\n\u22a2 Epi f \u2194 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "have i1 : Epi f \u2194 Epi (groupAddGroupEquivalence.inverse.map f) := sorry", "tactic_state": "A B : AddGrp\nf : A \u27f6 B\ni1 : Epi f \u2194 Epi (groupAddGroupEquivalence.inverse.map f)\n\u22a2 Epi f \u2194 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "rwa [Grp.epi_iff_surjective] at i1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma free_\u03b7_freeMk (x : PUnit) : \u03b7 (free R) (freeMk x) = 1 := by\n  apply FreeMonoidal.\u03b5Iso_inv_freeMk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Adjunctions.lean", "context": {"open": ["CategoryTheory", "MonoidalCategory", "FreeMonoidal in", "Functor.LaxMonoidal Functor.OplaxMonoidal"], "variables": ["(R : Type u)", "[Ring R]", "{R}", "(R)", "[CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\n\u03b7 : x\u271d\nx : PUnit.{u_2}\n\u22a2 sorry = 1"}, {"line": "apply FreeMonoidal.\u03b5Iso_inv_freeMk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_map_single (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) (r : R) :\n    (lift R F).map (single f r) = r \u2022 F.map f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Adjunctions.lean", "context": {"open": ["CategoryTheory", "MonoidalCategory", "FreeMonoidal in", "Functor.LaxMonoidal Functor.OplaxMonoidal", "Finsupp", "Preadditive Linear"], "variables": ["(R : Type u)", "[Ring R]", "{R}", "(R)", "[CommRing R]", "(R : Type*) [CommRing R] (C : Type u) [Category.{v} C]", "{C} {D : Type u} [Category.{v} D] [Preadditive D] [Linear R D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u\ninst\u271d\u00b2 : Category.{v, u} D\ninst\u271d\u00b9 : Preadditive D\ninst\u271d : Linear R D\nF : CategoryTheory.Functor C D\nX Y : C\nf : X \u27f6 Y\nr : R\n\u22a2 sorry = r \u2022 F.map f"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommRing R\nC : Type u\ninst\u271d\u00b3 : Category.{v, u} C\nD : Type u\ninst\u271d\u00b2 : Category.{v, u} D\ninst\u271d\u00b9 : Preadditive D\ninst\u271d : Linear R D\nF : CategoryTheory.Functor C D\nX Y : C\nf : X \u27f6 Y\nr : R\n\u22a2 sorry () = r \u2022 F.map f"}]}
{"declaration": "example (R : Type u) [Ring R] : HasCoequalizers (ModuleCat.{u} R) := by\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Colimits.lean", "context": {"open": ["CategoryTheory Category Limits"], "variables": ["{R : Type w} [Ring R]", "{J : Type u} [Category.{v} J] (F : J \u2964 ModuleCat.{w'} R)", "[HasColimit (F \u22d9 forget\u2082 _ AddCommGrp)]", "(J R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type w\ninst\u271d\u00b3 : Ring R\u271d\nJ : Type u\ninst\u271d\u00b2 : Category.{v, u} J\nF : CategoryTheory.Functor J (ModuleCat R\u271d)\ninst\u271d\u00b9 : HasColimit (F.comp (forget\u2082 (ModuleCat R\u271d) AddCommGrp))\nR : Type u\ninst\u271d : Ring R\n\u22a2 HasCoequalizers (ModuleCat R)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_ext {M : ModuleCat.{v} R} {N : ModuleCat.{max u v} R} {n : \u2115}\n    {f g : M.exteriorPower n \u27f6 N}\n    (h : mk.postcomp f = mk.postcomp g) : f = g := by\n  ext : 1\n  exact exteriorPower.linearMap_ext h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/ExteriorPower.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R : Type u} [CommRing R]", "{M : ModuleCat.{v} R} {N : ModuleCat.{max u v} R} {n : \u2115}", "(\u03c6 : M.AlternatingMap N n) {N' : ModuleCat.{max u v} R} (g : N \u27f6 N')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM : ModuleCat R\nN : ModuleCat R\nn : \u2115\nf g : M.exteriorPower n \u27f6 N\nh : sorry = sorry\n\u22a2 f = g"}, {"line": "ext : 1", "tactic_state": "case h\nR : Type u\ninst\u271d : CommRing R\nM : ModuleCat R\nN : ModuleCat R\nn : \u2115\nf g : M.exteriorPower n \u27f6 N\nh : sorry = sorry\n\u22a2 ConcreteCategory.hom f = ConcreteCategory.hom g"}, {"line": "exact exteriorPower.linearMap_ext h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cokernel_\u03c0_ext {M N : ModuleCat.{u} R} (f : M \u27f6 N) {x y : N} (m : M) (w : x = y + f m) :\n    cokernel.\u03c0 f x = cokernel.\u03c0 f y := by\n  subst w\n  simpa only [map_add, add_eq_left] using cokernel.condition_apply f m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits", "ModuleCat"], "variables": ["{R : Type u} [Ring R]", "{M N : ModuleCat.{v} R} (f : M \u27f6 N)", "{G H : ModuleCat.{v} R} (f : G \u27f6 H)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\nf : M \u27f6 N\nx y : \u2191N\nm : \u2191M\nw : x = y + (ConcreteCategory.hom f) m\n\u22a2 (ConcreteCategory.hom (cokernel.\u03c0 f)) x = (ConcreteCategory.hom (cokernel.\u03c0 f)) y"}, {"line": "subst w", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\nf : M \u27f6 N\ny : \u2191N\nm : \u2191M\n\u22a2 (ConcreteCategory.hom (cokernel.\u03c0 f)) (y + (ConcreteCategory.hom f) m) = (ConcreteCategory.hom (cokernel.\u03c0 f)) y"}, {"line": "simpa only [map_add, add_eq_left] using cokernel.condition_apply f m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cokernel_\u03c0_imageSubobject_ext {L M N : ModuleCat.{v} R} (f : L \u27f6 M) [HasImage f]\n    (g : (imageSubobject f : ModuleCat.{v} R) \u27f6 N) [HasCokernel g] {x y : N} (l : L)\n    (w : x = y + g (factorThruImageSubobject f l)) : cokernel.\u03c0 g x = cokernel.\u03c0 g y := by\n  subst w\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Subobject.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Subobject", "CategoryTheory.Limits", "ModuleCat"], "variables": ["{R : Type u} [Ring R] (M : ModuleCat.{v} R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\nL M N : ModuleCat R\nf : L \u27f6 M\ninst\u271d\u00b9 : HasImage f\ng : underlying.obj (imageSubobject f) \u27f6 N\ninst\u271d : HasCokernel g\nx y : \u2191N\nl : \u2191L\nw : x = y + (ConcreteCategory.hom g) ((ConcreteCategory.hom (factorThruImageSubobject f)) l)\n\u22a2 (ConcreteCategory.hom (cokernel.\u03c0 g)) x = (ConcreteCategory.hom (cokernel.\u03c0 g)) y"}, {"line": "subst w", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\nL M N : ModuleCat R\nf : L \u27f6 M\ninst\u271d\u00b9 : HasImage f\ng : underlying.obj (imageSubobject f) \u27f6 N\ninst\u271d : HasCokernel g\ny : \u2191N\nl : \u2191L\n\u22a2 (ConcreteCategory.hom (cokernel.\u03c0 g))\n      (y + (ConcreteCategory.hom g) ((ConcreteCategory.hom (factorThruImageSubobject f)) l)) =\n    (ConcreteCategory.hom (cokernel.\u03c0 g)) y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (M : ModuleCat.{v} R) (x : M) :\n    (\ud835\udfd9 M : M \u27f6 M) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM : ModuleCat R\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id M)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N O : ModuleCat.{v} R} (f : M \u27f6 N) (g : N \u27f6 O) (x : M) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N O : ModuleCat R\nf : M \u27f6 N\ng : N \u27f6 O\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {M N : ModuleCat.{v} R} (e : M \u2245 N) (x : M) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\ne : M \u2245 N\nx : \u2191M\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {M N : ModuleCat.{v} R} (e : M \u2245 N) (x : N) : e.hom (e.inv x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Limits.WalkingParallelPair"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\ne : M \u2245 N\nx : \u2191N\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_naturality {M N : ModuleCat.{v} R} (f : M \u27f6 N) (r : R) :\n    (forget\u2082 (ModuleCat R) AddCommGrp).map f \u226b N.smul r =\n      M.smul r \u226b (forget\u2082 (ModuleCat R) AddCommGrp).map f := by\n  ext x\n  exact (f.hom.map_smul r x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Basic.lean", "context": {"open": ["CategoryTheory", "CategoryTheory.Limits", "CategoryTheory.Limits.WalkingParallelPair", "ModuleCat"], "variables": ["(R : Type u) [Ring R]", "{R} in", "{R}", "{R}", "{R}", "{X\u2081 X\u2082 : Type v}", "{M N : ModuleCat.{v} R}", "{M N : ModuleCat.{v} R} {S : Type*} [Monoid S] [DistribMulAction S N] [SMulCommClass R S N]", "{M N : ModuleCat.{v} R} {S : Type*} [Semiring S] [Module S N] [SMulCommClass R S N]", "{S\u2080 : Type u\u2080} [CommSemiring S\u2080] {S : Type u} [Ring S] [Algebra S\u2080 S]", "{M N : ModuleCat.{v} S}", "{S : Type u} [CommRing S]", "{X Y X' Y' : ModuleCat.{v} S}", "(M N : ModuleCat.{v} R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\nf : M \u27f6 N\nr : R\n\u22a2 CategoryStruct.comp ((forget\u2082 (ModuleCat R) AddCommGrp).map f) (N.smul r) =\n    CategoryStruct.comp (M.smul r) ((forget\u2082 (ModuleCat R) AddCommGrp).map f)"}, {"line": "ext x", "tactic_state": "case hf.h\nR : Type u\ninst\u271d : Ring R\nM N : ModuleCat R\nf : M \u27f6 N\nr : R\nx : \u2191((forget\u2082 (ModuleCat R) AddCommGrp).obj M)\n\u22a2 (AddCommGrp.Hom.hom (CategoryStruct.comp ((forget\u2082 (ModuleCat R) AddCommGrp).map f) (N.smul r))) x =\n    (AddCommGrp.Hom.hom (CategoryStruct.comp (M.smul r) ((forget\u2082 (ModuleCat R) AddCommGrp).map f))) x"}, {"line": "exact (f.hom.map_smul r x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_app {M\u2081 M\u2082 M\u2083 : PresheafOfModules R} (f : M\u2081 \u27f6 M\u2082) (g : M\u2082 \u27f6 M\u2083) (X : C\u1d52\u1d56) :\n    (f \u226b g).app X = f.app X \u226b g.app X := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Presheaf.lean", "context": {"open": ["CategoryTheory LinearMap Opposite"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] {R : C\u1d52\u1d56 \u2964 RingCat.{u}}", "(R) in", "(M M\u2081 M\u2082 : PresheafOfModules.{v} R)", "{M\u2081 M\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\u2081\ninst\u271d : Category.{v\u2081, u\u2081} C\nR : CategoryTheory.Functor C\u1d52\u1d56 RingCat\nM\u2081 M\u2082 M\u2083 : PresheafOfModules R\nf : M\u2081 \u27f6 M\u2082\ng : M\u2082 \u27f6 M\u2083\nX : C\u1d52\u1d56\n\u22a2 (CategoryStruct.comp f g).app X = CategoryStruct.comp (f.app X) (g.app X)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma d_add (b b' : B) : D.d (b + b') = D.d b + D.d b' := by simp [d]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Differentials/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{A B : CommRingCat.{u}} (M : ModuleCat.{v} B) (f : A \u27f6 B)", "{M f}", "(D : M.Derivation f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : CommRingCat\nM : ModuleCat \u2191B\nf : A \u27f6 B\nD : M.Derivation f\nb b' : \u2191B\n\u22a2 D.d (b + b') = D.d b + D.d b'"}, {"line": "simp [d]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma d_mul (b b' : B) : D.d (b * b') = b \u2022 D.d b' + b' \u2022 D.d b := by simp [d]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Differentials/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{A B : CommRingCat.{u}} (M : ModuleCat.{v} B) (f : A \u27f6 B)", "{M f}", "(D : M.Derivation f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : CommRingCat\nM : ModuleCat \u2191B\nf : A \u27f6 B\nD : M.Derivation f\nb b' : \u2191B\n\u22a2 D.d (b * b') = b \u2022 D.d b' + b' \u2022 D.d b"}, {"line": "simp [d]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tensor_ext\u2083 {f g : M\u2081 \u2297 (M\u2082 \u2297 M\u2083) \u27f6 M\u2084}\n    (h : \u2200 m\u2081 m\u2082 m\u2083, f (m\u2081 \u2297\u209c (m\u2082 \u2297\u209c m\u2083)) = g (m\u2081 \u2297\u209c (m\u2082 \u2297\u209c m\u2083))) :\n    f = g := by\n  rw [\u2190 cancel_epi (\u03b1_ _ _ _).hom]\n  exact tensor_ext\u2083' h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Monoidal/Basic.lean", "context": {"open": ["CategoryTheory", "TensorProduct", "MonoidalCategory"], "variables": ["{R : Type u} [CommRing R]", "{M\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat.{u} R}", "(f : M\u2081 \u2192 M\u2082 \u2192 M\u2083) (h\u2081 : \u2200 m\u2081 m\u2082 n, f (m\u2081 + m\u2082) n = f m\u2081 n + f m\u2082 n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 f = g"}, {"line": "rw [\u2190 cancel_epi (\u03b1_ _ _ _).hom]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 CategoryStruct.comp sorry f = CategoryStruct.comp sorry g\n---\nR : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 ModuleCat R\n---\nR : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 Epi sorry"}, {"line": "exact tensor_ext\u2083' h", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 ModuleCat R\n---\nR : Type u\ninst\u271d : CommRing R\nM\u2081 M\u2082 M\u2083 M\u2084 : ModuleCat R\nf g : tensorObj M\u2081 (tensorObj M\u2082 M\u2083) \u27f6 M\u2084\nh :\n  \u2200 (m\u2081 : \u2191M\u2081) (m\u2082 : \u2191M\u2082) (m\u2083 : \u2191M\u2083),\n    (ConcreteCategory.hom f) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083) = (ConcreteCategory.hom g) (m\u2081 \u2297\u209c[R] m\u2082 \u2297\u209c[R] m\u2083)\n\u22a2 Epi sorry"}]}
{"declaration": "theorem braiding_naturality_left {X Y : ModuleCat R} (f : X \u27f6 Y) (Z : ModuleCat R) :\n    f \u25b7 Z \u226b (braiding Y Z).hom = (braiding X Z).hom \u226b Z \u25c1 f := by\n  simp_rw [\u2190 id_tensorHom]\n  apply braiding_naturality\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Monoidal/Symmetric.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx\u271d : Sort u_1\nbraiding : x\u271d\nX Y : ModuleCat R\nf : X \u27f6 Y\nZ : ModuleCat R\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight f Z) sorry =\n    CategoryStruct.comp sorry (MonoidalCategoryStruct.whiskerLeft Z f)"}, {"line": "simp_rw [\u2190 id_tensorHom]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx\u271d : Sort u_1\nbraiding : x\u271d\nX Y : ModuleCat R\nf : X \u27f6 Y\nZ : ModuleCat R\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerRight f Z) sorry =\n    CategoryStruct.comp sorry (tensorHom (CategoryStruct.id Z) f)"}, {"line": "apply braiding_naturality", "tactic_state": "No Goals!"}]}
{"declaration": "theorem braiding_naturality_right (X : ModuleCat R) {Y Z : ModuleCat R} (f : Y \u27f6 Z) :\n    X \u25c1 f \u226b (braiding X Z).hom = (braiding X Y).hom \u226b f \u25b7 X := by\n  simp_rw [\u2190 id_tensorHom]\n  apply braiding_naturality\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Monoidal/Symmetric.lean", "context": {"open": ["CategoryTheory MonoidalCategory"], "variables": ["{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx\u271d : Sort u_1\nbraiding : x\u271d\nX Y Z : ModuleCat R\nf : Y \u27f6 Z\n\u22a2 CategoryStruct.comp (MonoidalCategoryStruct.whiskerLeft X f) sorry =\n    CategoryStruct.comp sorry (MonoidalCategoryStruct.whiskerRight f X)"}, {"line": "simp_rw [\u2190 id_tensorHom]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nx\u271d : Sort u_1\nbraiding : x\u271d\nX Y Z : ModuleCat R\nf : Y \u27f6 Z\n\u22a2 CategoryStruct.comp (tensorHom (CategoryStruct.id X) f) sorry =\n    CategoryStruct.comp sorry (MonoidalCategoryStruct.whiskerRight f X)"}, {"line": "apply braiding_naturality", "tactic_state": "No Goals!"}]}
{"declaration": "lemma freeAdjunction_homEquiv : (freeAdjunction R).homEquiv F G = freeHomEquiv := by\n  simp [freeAdjunction, Adjunction.mkOfHomEquiv_homEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Presheaf/Free.lean", "context": {"open": ["CategoryTheory"], "variables": ["{C : Type u\u2081} [Category.{v\u2081} C] (R : C\u1d52\u1d56 \u2964 RingCat.{u})", "{R} in", "{R}", "{F : C\u1d52\u1d56 \u2964 Type u} {G : PresheafOfModules.{u} R}", "(F R) in", "(R) in", "(F G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfreeAdjunction : x\u271d\n\u03b1\u271d : Sort u_2\nfreeHomEquiv : \u03b1\u271d\n\u22a2 sorry = freeHomEquiv"}, {"line": "simp [freeAdjunction, Adjunction.mkOfHomEquiv_homEquiv]", "tactic_state": "x\u271d : Sort u_1\nfreeAdjunction : x\u271d\n\u03b1\u271d : Sort u_2\nfreeHomEquiv : \u03b1\u271d\n\u22a2 sorry () = freeHomEquiv"}]}
{"declaration": "lemma fromFreeYoneda_app_apply (m : M.Elements) :\n    m.fromFreeYoneda.app m.1 (ModuleCat.freeMk (\ud835\udfd9 _)) = m.2 := by\n  apply freeYonedaEquiv_symm_app\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Presheaf/Generator.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}}", "(R) in", "(R)", "{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}} {M : PresheafOfModules.{v} R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : Category.{v, u} C\nR : CategoryTheory.Functor C\u1d52\u1d56 RingCat\nM : PresheafOfModules R\nm : M.Elements\n\u22a2 (ConcreteCategory.hom (m.fromFreeYoneda.app m.fst)) (ModuleCat.freeMk (CategoryStruct.id (Opposite.unop m.fst))) =\n    m.snd"}, {"line": "apply freeYonedaEquiv_symm_app", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u03b9_fromFreeYonedaCoproduct (m : M.Elements) :\n    M.\u03b9FreeYonedaCoproduct m \u226b M.fromFreeYonedaCoproduct = m.fromFreeYoneda := by\n  apply Sigma.\u03b9_desc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Presheaf/Generator.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}}", "(R) in", "(R)", "{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}} {M : PresheafOfModules.{v} R}", "{C : Type u} [SmallCategory.{u} C] {R : C\u1d52\u1d56 \u2964 RingCat.{u}} (M : PresheafOfModules.{u} R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : SmallCategory C\nR : CategoryTheory.Functor C\u1d52\u1d56 RingCat\nM : PresheafOfModules R\nm : M.Elements\n\u22a2 CategoryStruct.comp (M.\u03b9FreeYonedaCoproduct m) M.fromFreeYonedaCoproduct = m.fromFreeYoneda"}, {"line": "apply Sigma.\u03b9_desc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toFreeYonedaCoproduct_fromFreeYonedaCoproduct :\n    M.toFreeYonedaCoproduct \u226b M.fromFreeYonedaCoproduct = 0 := by\n  simp [toFreeYonedaCoproduct]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/ModuleCat/Presheaf/Generator.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}}", "(R) in", "(R)", "{C : Type u} [Category.{v} C] {R : C\u1d52\u1d56 \u2964 RingCat.{v}} {M : PresheafOfModules.{v} R}", "{C : Type u} [SmallCategory.{u} C] {R : C\u1d52\u1d56 \u2964 RingCat.{u}} (M : PresheafOfModules.{u} R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C : Type u\ninst\u271d : SmallCategory C\nR : CategoryTheory.Functor C\u1d52\u1d56 RingCat\nM : PresheafOfModules R\n\u22a2 CategoryStruct.comp M.toFreeYonedaCoproduct M.fromFreeYonedaCoproduct = 0"}, {"line": "simp [toFreeYonedaCoproduct]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (M : MonCat) (x : M) :\n    (\ud835\udfd9 M : M \u27f6 M) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : MonCat\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id M)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N T : MonCat} (f : M \u27f6 N) (g : N \u27f6 T) (x : M) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N T : MonCat\nf : M \u27f6 N\ng : N \u27f6 T\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {M N : MonCat} (e : M \u2245 N) (x : M) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MonCat\ne : M \u2245 N\nx : \u2191M\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {M N : MonCat} (e : M \u2245 N) (s : N) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MonCat\ne : M \u2245 N\ns : \u2191N\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (M : CommMonCat) (x : M) :\n    (\ud835\udfd9 M : M \u27f6 M) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : CommMonCat\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id M)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N T : CommMonCat} (f : M \u27f6 N) (g : N \u27f6 T) (x : M) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N T : CommMonCat\nf : M \u27f6 N\ng : N \u27f6 T\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {M N : CommMonCat} (e : M \u2245 N) (x : M) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : CommMonCat\ne : M \u2245 N\nx : \u2191M\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {M N : CommMonCat} (e : M \u2245 N) (s : N) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : CommMonCat\ne : M \u2245 N\ns : \u2191N\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.comp_id_monCat {G : MonCat.{u}} {H : Type u} [Monoid H] (f : G \u2192* H) :\n    f.comp (MonCat.Hom.hom (\ud835\udfd9 G)) = f := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{X Y : Type u}", "[Monoid X] [Monoid Y]", "[CommMonoid X] [CommMonoid Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : MonCat\nH : Type u\ninst\u271d : Monoid H\nf : \u2191G \u2192* H\n\u22a2 f.comp (MonCat.Hom.hom (CategoryStruct.id G)) = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.id_monCat_comp {G : Type u} [Monoid G] {H : MonCat.{u}} (f : G \u2192* H) :\n    MonoidHom.comp (MonCat.Hom.hom (\ud835\udfd9 H)) f = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{X Y : Type u}", "[Monoid X] [Monoid Y]", "[CommMonoid X] [CommMonoid Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Monoid G\nH : MonCat\nf : G \u2192* \u2191H\n\u22a2 (MonCat.Hom.hom (CategoryStruct.id H)).comp f = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonoidHom.comp_id_commMonCat {G : CommMonCat.{u}} {H : Type u} [CommMonoid H] (f : G \u2192* H) :\n    f.comp (CommMonCat.Hom.hom (\ud835\udfd9 G)) = f := by\n  simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/MonCat/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{X Y : Type u}", "[Monoid X] [Monoid Y]", "[CommMonoid X] [CommMonoid Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : CommMonCat\nH : Type u\ninst\u271d : CommMonoid H\nf : \u2191G \u2192* H\n\u22a2 f.comp (CommMonCat.Hom.hom (CategoryStruct.id G)) = f"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (R : SemiRingCat) (r : R) :\n    (\ud835\udfd9 R : R \u27f6 R) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : SemiRingCat\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id R)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {R S T : SemiRingCat} (f : R \u27f6 S) (g : S \u27f6 T) (r : R) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S T : SemiRingCat\nf : R \u27f6 S\ng : S \u27f6 T\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) r = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {R S : SemiRingCat} (e : R \u2245 S) (r : R) : e.inv (e.hom r) = r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : SemiRingCat\ne : R \u2245 S\nr : \u2191R\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) r) = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {R S : SemiRingCat} (e : R \u2245 S) (s : S) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : SemiRingCat\ne : R \u2245 S\ns : \u2191S\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (R : RingCat) (r : R) :\n    (\ud835\udfd9 R : R \u27f6 R) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : RingCat\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id R)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {R S T : RingCat} (f : R \u27f6 S) (g : S \u27f6 T) (r : R) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S T : RingCat\nf : R \u27f6 S\ng : S \u27f6 T\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) r = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {R S : RingCat} (e : R \u2245 S) (r : R) : e.inv (e.hom r) = r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : RingCat\ne : R \u2245 S\nr : \u2191R\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) r) = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {R S : RingCat} (e : R \u2245 S) (s : S) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : RingCat\ne : R \u2245 S\ns : \u2191S\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (R : CommSemiRingCat) (r : R) :\n    (\ud835\udfd9 R : R \u27f6 R) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : CommSemiRingCat\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id R)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {R S T : CommSemiRingCat} (f : R \u27f6 S) (g : S \u27f6 T) (r : R) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S T : CommSemiRingCat\nf : R \u27f6 S\ng : S \u27f6 T\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) r = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {R S : CommSemiRingCat} (e : R \u2245 S) (r : R) : e.inv (e.hom r) = r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommSemiRingCat\ne : R \u2245 S\nr : \u2191R\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) r) = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {R S : CommSemiRingCat} (e : R \u2245 S) (s : S) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommSemiRingCat\ne : R \u2245 S\ns : \u2191S\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (R : CommRingCat) (r : R) :\n    (\ud835\udfd9 R : R \u27f6 R) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : CommRingCat\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id R)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {R S T : CommRingCat} (f : R \u27f6 S) (g : S \u27f6 T) (r : R) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S T : CommRingCat\nf : R \u27f6 S\ng : S \u27f6 T\nr : \u2191R\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) r = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {R S : CommRingCat} (e : R \u2245 S) (r : R) : e.inv (e.hom r) = r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommRingCat\ne : R \u2245 S\nr : \u2191R\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) r) = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {R S : CommRingCat} (e : R \u2245 S) (s : S) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommRingCat\ne : R \u2245 S\ns : \u2191S\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma RingHom.surjective_of_epi_of_finite {R S : CommRingCat} (f : R \u27f6 S) [Epi f]\n    (h\u2082 : RingHom.Finite f.hom) : Function.Surjective f := by\n  algebraize [f.hom]\n  apply RingHom.surjective_of_tmul_eq_tmul_of_finite\n  rwa [\u2190 CommRingCat.epi_iff_tmul_eq_tmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Epi.lean", "context": {"open": ["CategoryTheory TensorProduct"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R S : CommRingCat\nf : R \u27f6 S\ninst\u271d : Epi f\nh\u2082 : (CommRingCat.Hom.hom f).Finite\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "algebraize [f.hom]", "tactic_state": "R S : CommRingCat\nf : R \u27f6 S\ninst\u271d : Epi f\nh\u2082 : (CommRingCat.Hom.hom f).Finite\nalgInst\u271d : Algebra \u2191R \u2191S := (CommRingCat.Hom.hom f).toAlgebra\nalgebraizeInst\u271d : Module.Finite \u2191R \u2191S\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "apply RingHom.surjective_of_tmul_eq_tmul_of_finite", "tactic_state": "case h\u2081\nR S : CommRingCat\nf : R \u27f6 S\ninst\u271d : Epi f\nh\u2082 : (CommRingCat.Hom.hom f).Finite\nalgInst\u271d : Algebra \u2191R \u2191S := (CommRingCat.Hom.hom f).toAlgebra\nalgebraizeInst\u271d : Module.Finite \u2191R \u2191S\n\u22a2 \u2200 (s : \u2191S), s \u2297\u209c[\u2191R] 1 = 1 \u2297\u209c[\u2191R] s"}, {"line": "rwa [\u2190 CommRingCat.epi_iff_tmul_eq_tmul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isFinitelyPresentable (S : Under R) (hS : S.hom.hom.FinitePresentation) :\n    IsFinitelyPresentable.{u} S := by\n  rw [isFinitelyPresentable_iff_preservesFilteredColimits]\n  exact preservesFilteredColimits_coyoneda R S hS", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/FinitePresentation.lean", "context": {"open": ["CategoryTheory Limits"], "variables": ["{J : Type uJ} [Category.{vJ} J] [IsFiltered J]", "(R : CommRingCat.{u}) (F : J \u2964 CommRingCat.{u}) (\u03b1 : (Functor.const _).obj R \u27f6 F)", "{S : CommRingCat.{u}} (f : R \u27f6 S) (c : Cocone F) (hc : IsColimit c)", "[PreservesColimit F (forget CommRingCat)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : CommRingCat\nS : Under R\nhS : (CommRingCat.Hom.hom S.hom).FinitePresentation\n\u22a2 IsFinitelyPresentable S"}, {"line": "rw [isFinitelyPresentable_iff_preservesFilteredColimits]", "tactic_state": "R : CommRingCat\nS : Under R\nhS : (CommRingCat.Hom.hom S.hom).FinitePresentation\n\u22a2 PreservesFilteredColimits (coyoneda.obj (Opposite.op S))"}, {"line": "exact preservesFilteredColimits_coyoneda R S hS", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pushout_inl_tensorProdObjIsoPushoutObj_inv_right (A : Under R) :\n    pushout.inl A.hom (ofHom <| algebraMap R S) \u226b (tensorProdObjIsoPushoutObj S A).inv.right =\n      (ofHom <| Algebra.TensorProduct.includeRight.toRingHom) := by\n  simp [tensorProdObjIsoPushoutObj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Ring/Under/Basic.lean", "context": {"open": ["TensorProduct CategoryTheory Limits"], "variables": ["{R S : CommRingCat.{u}}", "(R) in", "[Algebra R S]", "(R S) in", "(S) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : CommRingCat\nx\u271d\u00b9 : Sort u_1\nofHom : x\u271d\u00b9\nx\u271d : Sort u_2\ntensorProdObjIsoPushoutObj : x\u271d\nA : Under R\n\u22a2 CategoryStruct.comp (pushout.inl A.hom sorry) sorry = sorry"}, {"line": "simp [tensorProdObjIsoPushoutObj]", "tactic_state": "R : CommRingCat\nx\u271d\u00b9 : Sort u_1\nofHom : x\u271d\u00b9\nx\u271d : Sort u_2\ntensorProdObjIsoPushoutObj : x\u271d\nA : Under R\n\u22a2 CategoryStruct.comp (pushout.inl A.hom (sorry ())) (sorry ()) = sorry ()"}]}
{"declaration": "lemma id_apply (M : MagmaCat) (x : M) :\n    (\ud835\udfd9 M : M \u27f6 M) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : MagmaCat\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id M)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N T : MagmaCat} (f : M \u27f6 N) (g : N \u27f6 T) (x : M) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N T : MagmaCat\nf : M \u27f6 N\ng : N \u27f6 T\nx : \u2191M\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {M N : MagmaCat} (e : M \u2245 N) (x : M) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MagmaCat\ne : M \u2245 N\nx : \u2191M\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {M N : MagmaCat} (e : M \u2245 N) (s : N) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : MagmaCat\ne : M \u2245 N\ns : \u2191N\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (X : Semigrp) (x : X) :\n    (\ud835\udfd9 X : X \u27f6 X) x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Semigrp\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id X)) x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {X Y T : Semigrp} (f : X \u27f6 Y) (g : Y \u27f6 T) (x : X) :\n    (f \u226b g) x = g (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y T : Semigrp\nf : X \u27f6 Y\ng : Y \u27f6 T\nx : \u2191X\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) x = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {X Y : Semigrp} (e : X \u2245 Y) (x : X) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Semigrp\ne : X \u2245 Y\nx : \u2191X\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {X Y : Semigrp} (e : X \u2245 Y) (s : Y) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Category/Semigrp/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : Semigrp\ne : X \u2245 Y\ns : \u2191Y\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_not_mixedCharZero (h : \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) :\n    \u2200 p > 0, \u00acMixedCharZero R p := by\n  intro p p_pos\n  by_contra hp_mixedChar\n  rcases hp_mixedChar.charP_quotient with \u27e8I, hI_ne_top, hI_p\u27e9\n  replace hI_zero : CharP (R \u29f8 I) 0 := @CharP.ofCharZero _ _ (h I hI_ne_top)\n  exact absurd (CharP.eq (R \u29f8 I) hI_p hI_zero) (ne_of_gt p_pos)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/MixedCharZero.lean", "context": {"open": [], "variables": ["(R : Type*) [CommRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\n\u22a2 \u2200 p > 0, \u00acMixedCharZero R p"}, {"line": "intro p p_pos", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\np : \u2115\np_pos : p > 0\n\u22a2 \u00acMixedCharZero R p"}, {"line": "by_contra hp_mixedChar", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\np : \u2115\np_pos : p > 0\nhp_mixedChar : MixedCharZero R p\n\u22a2 False"}, {"line": "rcases hp_mixedChar.charP_quotient with \u27e8I, hI_ne_top, hI_p\u27e9", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\np : \u2115\np_pos : p > 0\nhp_mixedChar : MixedCharZero R p\nI : Ideal R\nhI_ne_top : I \u2260 \u22a4\nhI_p : CharP (R \u29f8 I) p\n\u22a2 False"}, {"line": "replace hI_zero : CharP (R \u29f8 I) 0 := @CharP.ofCharZero _ _ (h I hI_ne_top)", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d : CommRing R\nh : \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\np : \u2115\np_pos : p > 0\nhp_mixedChar : MixedCharZero R p\nI : Ideal R\nhI_ne_top : I \u2260 \u22a4\nhI_p : CharP (R \u29f8 I) p\nhI_zero : CharP (R \u29f8 I) 0\n\u22a2 False"}, {"line": "exact absurd (CharP.eq (R \u29f8 I) hI_p hI_zero) (ne_of_gt p_pos)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_algebraRat_iff :\n    Nonempty (Algebra \u211a R) \u2194 \u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I) := by\n  constructor\n  \u00b7 intro h_alg\n    haveI h_alg' : Algebra \u211a R := h_alg.some\n    apply of_algebraRat\n  \u00b7 intro h\n    apply Nonempty.intro\n    exact algebraRat h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/MixedCharZero.lean", "context": {"open": [], "variables": ["(R : Type*) [CommRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u22a2 Nonempty (Algebra \u211a R) \u2194 \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 Nonempty (Algebra \u211a R) \u2192 \u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)\n---\ncase mpr\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 (\u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) \u2192 Nonempty (Algebra \u211a R)"}, {"line": "\u00b7 intro h_alg\n    haveI h_alg' : Algebra \u211a R := h_alg.some\n    apply of_algebraRat", "tactic_state": "case mpr\nR : Type u_1\ninst\u271d : CommRing R\n\u22a2 (\u2200 (I : Ideal R), I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I)) \u2192 Nonempty (Algebra \u211a R)"}, {"line": "\u00b7 intro h\n    apply Nonempty.intro\n    exact algebraRat h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_intAlgebraMap_eq_span\n    {R : Type*} [Ring R] (p : \u2115) [CharP R p] :\n    RingHom.ker (algebraMap \u2124 R) = Ideal.span {(p : \u2124)} := by\n  ext a\n  simp [CharP.intCast_eq_zero_iff R p, Ideal.mem_span_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Quotient.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\n\u22a2 RingHom.ker (algebraMap \u2124 R) = Ideal.span {\u2191p}"}, {"line": "ext a", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\na : \u2124\n\u22a2 a \u2208 RingHom.ker (algebraMap \u2124 R) \u2194 a \u2208 Ideal.span {\u2191p}"}, {"line": "simp [CharP.intCast_eq_zero_iff R p, Ideal.mem_span_singleton]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\na : \u2124\n\u22a2 \u2191a = 0 \u2194 \u2191p \u2223 a"}]}
{"declaration": "lemma intCast_injOn_Ico [IsRightCancelAdd R] : InjOn (Int.cast : \u2124 \u2192 R) (Ico 0 p) := by\n  rintro a \u27e8ha\u2080, ha\u27e9 b \u27e8hb\u2080, hb\u27e9 hab\n  lift a to \u2115 using ha\u2080\n  lift b to \u2115 using hb\u2080\n  norm_cast at *\n  exact natCast_injOn_Iio _ _ ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Basic.lean", "context": {"open": ["Set"], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "[IsRightCancelAdd R]", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne R\ninst\u271d\u00b3 : IsRightCancelAdd R\ninst\u271d\u00b2 : AddGroupWithOne R\np : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : IsRightCancelAdd R\n\u22a2 InjOn Int.cast (Ico 0 \u2191p)"}, {"line": "rintro a \u27e8ha\u2080, ha\u27e9 b \u27e8hb\u2080, hb\u27e9 hab", "tactic_state": "case intro.intro\nR : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne R\ninst\u271d\u00b3 : IsRightCancelAdd R\ninst\u271d\u00b2 : AddGroupWithOne R\np : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : IsRightCancelAdd R\na : \u2124\nha\u2080 : 0 \u2264 a\nha : a < \u2191p\nb : \u2124\nhb\u2080 : 0 \u2264 b\nhb : b < \u2191p\nhab : \u2191a = \u2191b\n\u22a2 a = b"}, {"line": "lift a to \u2115 using ha\u2080", "tactic_state": "case intro.intro.intro\nR : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne R\ninst\u271d\u00b3 : IsRightCancelAdd R\ninst\u271d\u00b2 : AddGroupWithOne R\np : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : IsRightCancelAdd R\nb : \u2124\nhb\u2080 : 0 \u2264 b\nhb : b < \u2191p\na : \u2115\nha : \u2191a < \u2191p\nhab : \u2191\u2191a = \u2191b\n\u22a2 \u2191a = b"}, {"line": "lift b to \u2115 using hb\u2080", "tactic_state": "case intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne R\ninst\u271d\u00b3 : IsRightCancelAdd R\ninst\u271d\u00b2 : AddGroupWithOne R\np : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : IsRightCancelAdd R\na : \u2115\nha : \u2191a < \u2191p\nb : \u2115\nhb : \u2191b < \u2191p\nhab : \u2191\u2191a = \u2191\u2191b\n\u22a2 \u2191a = \u2191b"}, {"line": "norm_cast at *", "tactic_state": "case intro.intro.intro.intro\nR : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne R\ninst\u271d\u00b3 : IsRightCancelAdd R\ninst\u271d\u00b2 : AddGroupWithOne R\np : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : IsRightCancelAdd R\na b : \u2115\nha : a < p\nhb : b < p\nhab : \u2191a = \u2191b\n\u22a2 a = b"}, {"line": "exact natCast_injOn_Iio _ _ ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma spec : \u2200 x : \u2115, (x : R) = 0 \u2194 ringChar R \u2223 x := by\n  letI : CharP R (ringChar R) := (Classical.choose_spec (CharP.existsUnique R)).1\n  exact CharP.cast_eq_zero_iff R (ringChar R)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 inst\u271d : NonAssocSemiring R\n\u22a2 \u2200 (x : \u2115), \u2191x = 0 \u2194 ringChar R \u2223 x"}, {"line": "letI : CharP R (ringChar R) := (Classical.choose_spec (CharP.existsUnique R)).1", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 inst\u271d : NonAssocSemiring R\nthis : sorry := sorry\n\u22a2 \u2200 (x : \u2115), \u2191x = 0 \u2194 ringChar R \u2223 x"}, {"line": "exact CharP.cast_eq_zero_iff R (ringChar R)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma char_ne_one [Nontrivial R] (p : \u2115) [hc : CharP R p] : p \u2260 1 := fun hp : p = 1 =>\n  have : (1 : R) = 0 := by simpa using (cast_eq_zero_iff R p 1).mpr (hp \u25b8 dvd_refl p)\n  absurd this one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : AddMonoidWithOne R\ninst\u271d\u2074 inst\u271d\u00b3 : NonAssocSemiring R\ninst\u271d\u00b2 : NonAssocRing R\ninst\u271d\u00b9 : NonAssocSemiring R\ninst\u271d : Nontrivial R\np : \u2115\nhc : CharP R p\nhp : p = 1\n\u22a2 1 = 0"}, {"line": "simpa using (cast_eq_zero_iff R p 1).mpr (hp \u25b8 dvd_refl p)\n  absurd this one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma false_of_nontrivial_of_char_one [Nontrivial R] [CharP R 1] : False := by\n  have : Subsingleton R := CharOne.subsingleton\n  exact false_of_nontrivial_of_subsingleton R\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 inst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R 1\n\u22a2 False"}, {"line": "have : Subsingleton R := CharOne.subsingleton", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 inst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharP R 1\nthis : Subsingleton R\n\u22a2 False"}, {"line": "exact false_of_nontrivial_of_subsingleton R", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expChar_ne_zero (p : \u2115) [hR : ExpChar R p] : p \u2260 0 := by\n  cases hR\n  \u00b7 exact one_ne_zero\n  \u00b7 exact \u2039p.Prime\u203a.ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]", "[AddMonoidWithOne R] {r : R} {n p : \u2115}", "[AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\np : \u2115\nhR : ExpChar R p\n\u22a2 p \u2260 0"}, {"line": "cases hR", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : CharZero R\n\u22a2 1 \u2260 0\n---\ncase prime\nR : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\np : \u2115\nhprime\u271d : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 p \u2260 0"}, {"line": "\u00b7 exact one_ne_zero", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\np : \u2115\nhprime\u271d : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 p \u2260 0"}, {"line": "\u00b7 exact \u2039p.Prime\u203a.ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expChar_one_of_char_zero (q : \u2115) [hp : CharP R 0] [hq : ExpChar R q] : q = 1 := by\n  rcases hq with q | hq_prime\n  \u00b7 rfl\n  \u00b7 exact False.elim <| hq_prime.ne_zero <| \u2039CharP R q\u203a.eq R hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]", "[AddMonoidWithOne R] {r : R} {n p : \u2115}", "[AddMonoidWithOne R]", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\nq : \u2115\nhp : CharP R 0\nhq : ExpChar R q\n\u22a2 q = 1"}, {"line": "rcases hq with q | hq_prime", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\nhp : CharP R 0\ninst\u271d : CharZero R\n\u22a2 1 = 1\n---\ncase prime\nR : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\nq : \u2115\nhp : CharP R 0\nhq_prime : Nat.Prime q\nhchar\u271d : CharP R q\n\u22a2 q = 1"}, {"line": "\u00b7 rfl", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u2078 : AddMonoidWithOne R\ninst\u271d\u2077 inst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NonAssocRing R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : NoZeroDivisors R\ninst\u271d\u00b2 : Nontrivial R\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\nq : \u2115\nhp : CharP R 0\nhq_prime : Nat.Prime q\nhchar\u271d : CharP R q\n\u22a2 q = 1"}, {"line": "\u00b7 exact False.elim <| hq_prime.ne_zero <| \u2039CharP R q\u203a.eq R hp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma char_zero_of_expChar_one (p : \u2115) [hp : CharP R p] [hq : ExpChar R 1] : p = 0 := by\n  cases hq\n  \u00b7 exact CharP.eq R hp inferInstance\n  \u00b7 exact False.elim (CharP.char_ne_one R 1 rfl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]", "[AddMonoidWithOne R] {r : R} {n p : \u2115}", "[AddMonoidWithOne R]", "{R} in", "[NonAssocSemiring R]", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhq : ExpChar R 1\n\u22a2 p = 0"}, {"line": "cases hq", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b9\u2070 : AddMonoidWithOne R\ninst\u271d\u2079 inst\u271d\u2078 : NonAssocSemiring R\ninst\u271d\u2077 : NonAssocRing R\ninst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 inst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 : Nontrivial R\np : \u2115\nhp : CharP R p\ninst\u271d : CharZero R\n\u22a2 p = 0\n---\ncase prime\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 p = 0"}, {"line": "\u00b7 exact CharP.eq R hp inferInstance", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\np : \u2115\nhp : CharP R p\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 p = 0"}, {"line": "\u00b7 exact False.elim (CharP.char_ne_one R 1 rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charZero_of_expChar_one' [hq : ExpChar R 1] : CharZero R := by\n  cases hq\n  \u00b7 assumption\n  \u00b7 exact False.elim (CharP.char_ne_one R 1 rfl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]", "[AddMonoidWithOne R] {r : R} {n p : \u2115}", "[AddMonoidWithOne R]", "{R} in", "[NonAssocSemiring R]", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\nhq : ExpChar R 1\n\u22a2 CharZero R"}, {"line": "cases hq", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b9\u2070 : AddMonoidWithOne R\ninst\u271d\u2079 inst\u271d\u2078 : NonAssocSemiring R\ninst\u271d\u2077 : NonAssocRing R\ninst\u271d\u2076 : NonAssocSemiring R\ninst\u271d\u2075 : NoZeroDivisors R\ninst\u271d\u2074 : Nontrivial R\ninst\u271d\u00b3 inst\u271d\u00b2 : AddMonoidWithOne R\ninst\u271d\u00b9 : Nontrivial R\ninst\u271d : CharZero R\n\u22a2 CharZero R\n---\ncase prime\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 CharZero R"}, {"line": "\u00b7 assumption", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u2079 : AddMonoidWithOne R\ninst\u271d\u2078 inst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NonAssocRing R\ninst\u271d\u2075 : NonAssocSemiring R\ninst\u271d\u2074 : NoZeroDivisors R\ninst\u271d\u00b3 : Nontrivial R\ninst\u271d\u00b2 inst\u271d\u00b9 : AddMonoidWithOne R\ninst\u271d : Nontrivial R\nhprime\u271d : Nat.Prime 1\nhchar\u271d : CharP R 1\n\u22a2 CharZero R"}, {"line": "\u00b7 exact False.elim (CharP.char_ne_one R 1 rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expChar_one_iff_char_zero (p q : \u2115) [CharP R p] [ExpChar R q] : q = 1 \u2194 p = 0 := by\n  constructor\n  \u00b7 rintro rfl\n    exact char_zero_of_expChar_one R p\n  \u00b7 rintro rfl\n    exact expChar_one_of_char_zero R q\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Defs.lean", "context": {"open": [], "variables": ["(R : Type*)", "[AddMonoidWithOne R] (p : \u2115)", "[CharP R p] {a b : \u2115}", "{R} in", "[AddGroupWithOne R] (p : \u2115) [CharP R p] {a b : \u2124}", "[NonAssocSemiring R]", "[NonAssocSemiring R]", "{R}", "[NonAssocRing R]", "[NonAssocSemiring R]", "[NoZeroDivisors R]", "[Nontrivial R]", "{R} [NonAssocSemiring R]", "[AddMonoidWithOne R] {r : R} {n p : \u2115}", "[AddMonoidWithOne R]", "{R} in", "[NonAssocSemiring R]", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9\u00b9 : AddMonoidWithOne R\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : NonAssocSemiring R\ninst\u271d\u2078 : NonAssocRing R\ninst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NoZeroDivisors R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 inst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : Nontrivial R\np q : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : ExpChar R q\n\u22a2 q = 1 \u2194 p = 0"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_1\ninst\u271d\u00b9\u00b9 : AddMonoidWithOne R\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : NonAssocSemiring R\ninst\u271d\u2078 : NonAssocRing R\ninst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NoZeroDivisors R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 inst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : Nontrivial R\np q : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : ExpChar R q\n\u22a2 q = 1 \u2192 p = 0\n---\ncase mpr\nR : Type u_1\ninst\u271d\u00b9\u00b9 : AddMonoidWithOne R\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : NonAssocSemiring R\ninst\u271d\u2078 : NonAssocRing R\ninst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NoZeroDivisors R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 inst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : Nontrivial R\np q : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : ExpChar R q\n\u22a2 p = 0 \u2192 q = 1"}, {"line": "\u00b7 rintro rfl\n    exact char_zero_of_expChar_one R p", "tactic_state": "case mpr\nR : Type u_1\ninst\u271d\u00b9\u00b9 : AddMonoidWithOne R\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : NonAssocSemiring R\ninst\u271d\u2078 : NonAssocRing R\ninst\u271d\u2077 : NonAssocSemiring R\ninst\u271d\u2076 : NoZeroDivisors R\ninst\u271d\u2075 : Nontrivial R\ninst\u271d\u2074 inst\u271d\u00b3 : AddMonoidWithOne R\ninst\u271d\u00b2 : Nontrivial R\np q : \u2115\ninst\u271d\u00b9 : CharP R p\ninst\u271d : ExpChar R q\n\u22a2 p = 0 \u2192 q = 1"}, {"line": "\u00b7 rintro rfl\n    exact expChar_one_of_char_zero R q", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iterateFrobenius_one_apply : iterateFrobenius R p 1 x = x ^ p := by\n  rw [iterateFrobenius_def]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Frobenius.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] {S : Type*} [CommSemiring S]", "(f : R \u2192* S) (g : R \u2192+* S) (p m n : \u2115) [ExpChar R p] [ExpChar S p] (x y : R)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p 1) x = x ^ p"}, {"line": "rw [iterateFrobenius_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 x ^ p ^ 1 = x ^ p"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iterateFrobenius_zero_apply : iterateFrobenius R p 0 x = x := by\n  rw [iterateFrobenius_def]\n  rw [pow_zero]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Frobenius.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] {S : Type*} [CommSemiring S]", "(f : R \u2192* S) (g : R \u2192+* S) (p m n : \u2115) [ExpChar R p] [ExpChar S p] (x y : R)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p 0) x = x"}, {"line": "rw [iterateFrobenius_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 x ^ p ^ 0 = x"}, {"line": "rw [pow_zero]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 x ^ 1 = x"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iterateFrobenius_add_apply :\n    iterateFrobenius R p (m + n) x = iterateFrobenius R p m (iterateFrobenius R p n x) := by\n  simp_rw [iterateFrobenius_def, add_comm m n, pow_add, pow_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Frobenius.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] {S : Type*} [CommSemiring S]", "(f : R \u2192* S) (g : R \u2192+* S) (p m n : \u2115) [ExpChar R p] [ExpChar S p] (x y : R)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np m n : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p (m + n)) x = (iterateFrobenius R p m) ((iterateFrobenius R p n) x)"}, {"line": "simp_rw [iterateFrobenius_def, add_comm m n, pow_add, pow_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iterateFrobenius_mul_apply :\n    iterateFrobenius R p (m * n) x = (iterateFrobenius R p m)^[n] x := by\n  simp_rw [coe_iterateFrobenius, Function.iterate_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Frobenius.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] {S : Type*} [CommSemiring S]", "(f : R \u2192* S) (g : R \u2192+* S) (p m n : \u2115) [ExpChar R p] [ExpChar S p] (x y : R)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np m n : \u2115\ninst\u271d : ExpChar R p\nx : R\n\u22a2 (iterateFrobenius R p (m * n)) x = (\u21d1(iterateFrobenius R p m))^[n] x"}, {"line": "simp_rw [coe_iterateFrobenius, Function.iterate_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MonoidHom.map_iterateFrobenius (n : \u2115) :\n    f (iterateFrobenius R p n x) = iterateFrobenius S p n (f x) := by\n  simp [iterateFrobenius_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Frobenius.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] {S : Type*} [CommSemiring S]", "(f : R \u2192* S) (g : R \u2192+* S) (p m n : \u2115) [ExpChar R p] [ExpChar S p] (x y : R)", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\nf : R \u2192* S\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : ExpChar S p\nx : R\nn : \u2115\n\u22a2 f ((iterateFrobenius R p n) x) = (iterateFrobenius S p n) (f x)"}, {"line": "simp [iterateFrobenius_def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : CommSemiring R\nS : Type u_2\ninst\u271d\u00b2 : CommSemiring S\nf : R \u2192* S\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : ExpChar S p\nx : R\nn : \u2115\n\u22a2 f (x ^ p ^ n) = f x ^ p ^ n"}]}
{"declaration": "theorem CharP.intCast_mul_natCast_gcdA_eq_gcd (n : \u2115) :\n    (n * n.gcdA p : R) = n.gcd p := by\n  suffices \u2191(n * n.gcdA p + p * n.gcdB p : \u2124) = ((n.gcd p : \u2124) : R) by simpa using this\n  rw [\u2190 Nat.gcd_eq_gcd_ab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Invertible.lean", "context": {"open": [], "variables": ["{R K : Type*}", "[Ring R] {p : \u2115} [CharP R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nn : \u2115\n\u22a2 \u2191n * \u2191(n.gcdA p) = \u2191(n.gcd p)"}, {"line": "suffices \u2191(n * n.gcdA p + p * n.gcdB p : \u2124) = ((n.gcd p : \u2124) : R) by simpa using this", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nn : \u2115\n\u22a2 \u2191n * n.gcdA p + \u2191p * n.gcdB p = sorry"}, {"line": "rw [\u2190 Nat.gcd_eq_gcd_ab]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nn : \u2115\n\u22a2 \u2191(n.gcd p) = sorry"}]}
{"declaration": "theorem CharP.isUnit_intCast_iff {z : \u2124} (hp : p.Prime) : IsUnit (z : R) \u2194 \u00ac\u2191p \u2223 z := by\n  obtain \u27e8n, rfl | rfl\u27e9 := z.eq_nat_or_neg\n  \u00b7 simp [CharP.isUnit_natCast_iff hp, Int.ofNat_dvd]\n  \u00b7 simp [CharP.isUnit_natCast_iff hp, Int.dvd_neg, Int.ofNat_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Invertible.lean", "context": {"open": [], "variables": ["{R K : Type*}", "[Ring R] {p : \u2115} [CharP R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nz : \u2124\nhp : Nat.Prime p\n\u22a2 IsUnit \u2191z \u2194 \u00ac\u2191p \u2223 z"}, {"line": "obtain \u27e8n, rfl | rfl\u27e9 := z.eq_nat_or_neg", "tactic_state": "case intro.inl\nR : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nhp : Nat.Prime p\nn : \u2115\n\u22a2 IsUnit \u2191\u2191n \u2194 \u00ac\u2191p \u2223 \u2191n\n---\ncase intro.inr\nR : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nhp : Nat.Prime p\nn : \u2115\n\u22a2 IsUnit \u2191(-\u2191n) \u2194 \u00ac\u2191p \u2223 -\u2191n"}, {"line": "\u00b7 simp [CharP.isUnit_natCast_iff hp, Int.ofNat_dvd]", "tactic_state": "case intro.inr\nR : Type u_1\ninst\u271d\u00b9 : Ring R\np : \u2115\ninst\u271d : CharP R p\nhp : Nat.Prime p\nn : \u2115\n\u22a2 IsUnit \u2191(-\u2191n) \u2194 \u00ac\u2191p \u2223 -\u2191n"}, {"line": "\u00b7 simp [CharP.isUnit_natCast_iff hp, Int.dvd_neg, Int.ofNat_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_ringChar_dvd_of_invertible {t : \u2115} [Invertible (t : K)] : \u00acringChar K \u2223 t := by\n  rw [\u2190 ringChar.spec]\n  rw [\u2190 Ne]\n  exact Invertible.ne_zero (t : K)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Invertible.lean", "context": {"open": [], "variables": ["{R K : Type*}", "[Ring R] {p : \u2115} [CharP R p]", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\ninst\u271d\u00b9 : Field K\nt : \u2115\ninst\u271d : Invertible \u2191t\n\u22a2 \u00acringChar K \u2223 t"}, {"line": "rw [\u2190 ringChar.spec]", "tactic_state": "K : Type u_2\ninst\u271d\u00b9 : Field K\nt : \u2115\ninst\u271d : Invertible \u2191t\n\u22a2 \u00ac\u2191t = 0"}, {"line": "rw [\u2190 Ne]", "tactic_state": "K : Type u_2\ninst\u271d\u00b9 : Field K\nt : \u2115\ninst\u271d : Invertible \u2191t\n\u22a2 \u2191t \u2260 0"}, {"line": "exact Invertible.ne_zero (t : K)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_pow_expChar_of_commute (h : Commute x y) : (x + y) ^ p = x ^ p + y ^ p := by\n  obtain _ | hprime := hR\n  \u00b7 simp only [pow_one]\n  \u00b7 let \u27e8r, hr\u27e9 := h.exists_add_pow_prime_eq hprime\n    simp [hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Lemmas.lean", "context": {"open": ["Finset"], "variables": ["{R S : Type*}", "[Semiring R] {p : \u2115} (hp : p.Prime) {x y : R}", "[CommSemiring R] {p : \u2115} (hp : p.Prime) (x y : R) (n : \u2115)", "[Semiring R] {x y : R} (p n : \u2115)", "[hR : ExpChar R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np : \u2115\nhR : ExpChar R p\nh : Commute x y\n\u22a2 (x + y) ^ p = x ^ p + y ^ p"}, {"line": "obtain _ | hprime := hR", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring R\nx y : R\nh : Commute x y\ninst\u271d : CharZero R\n\u22a2 (x + y) ^ 1 = x ^ 1 + y ^ 1\n---\ncase prime\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np : \u2115\nh : Commute x y\nhprime : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 (x + y) ^ p = x ^ p + y ^ p"}, {"line": "\u00b7 simp only [pow_one]", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np : \u2115\nh : Commute x y\nhprime : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 (x + y) ^ p = x ^ p + y ^ p"}, {"line": "\u00b7 let \u27e8r, hr\u27e9 := h.exists_add_pow_prime_eq hprime\n    simp [hr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_pow_expChar_pow_of_commute (h : Commute x y) :\n    (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n := by\n  obtain _ | hprime := hR\n  \u00b7 simp only [one_pow, pow_one]\n  \u00b7 let \u27e8r, hr\u27e9 := h.exists_add_pow_prime_pow_eq hprime n\n    simp [hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Lemmas.lean", "context": {"open": ["Finset"], "variables": ["{R S : Type*}", "[Semiring R] {p : \u2115} (hp : p.Prime) {x y : R}", "[CommSemiring R] {p : \u2115} (hp : p.Prime) (x y : R) (n : \u2115)", "[Semiring R] {x y : R} (p n : \u2115)", "[hR : ExpChar R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np n : \u2115\nhR : ExpChar R p\nh : Commute x y\n\u22a2 (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n"}, {"line": "obtain _ | hprime := hR", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : Semiring R\nx y : R\nn : \u2115\nh : Commute x y\ninst\u271d : CharZero R\n\u22a2 (x + y) ^ 1 ^ n = x ^ 1 ^ n + y ^ 1 ^ n\n---\ncase prime\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np n : \u2115\nh : Commute x y\nhprime : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n"}, {"line": "\u00b7 simp only [one_pow, pow_one]", "tactic_state": "case prime\nR : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Semiring R\nx y : R\np n : \u2115\nh : Commute x y\nhprime : Nat.Prime p\nhchar\u271d : CharP R p\n\u22a2 (x + y) ^ p ^ n = x ^ p ^ n + y ^ p ^ n"}, {"line": "\u00b7 let \u27e8r, hr\u27e9 := h.exists_add_pow_prime_pow_eq hprime n\n    simp [hr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_pow_expChar_pow_of_commute (h : Commute x y) :\n    (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n := by\n  simp [eq_sub_iff_add_eq, \u2190 add_pow_expChar_pow_of_commute _ _ (h.sub_left rfl)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/CharP/Lemmas.lean", "context": {"open": ["Finset"], "variables": ["{R S : Type*}", "[Semiring R] {p : \u2115} (hp : p.Prime) {x y : R}", "[CommSemiring R] {p : \u2115} (hp : p.Prime) (x y : R) (n : \u2115)", "[Semiring R] {x y : R} (p n : \u2115)", "[hR : ExpChar R p]", "[hp : Fact p.Prime] [CharP R p]", "[CommSemiring R] (x y : R) (p n : \u2115)", "[hR : ExpChar R p]", "[hp : Fact p.Prime] [CharP R p]", "[Ring R] {x y : R} (p n : \u2115)", "[hR : ExpChar R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nx y : R\np n : \u2115\nhR : ExpChar R p\nh : Commute x y\n\u22a2 (x - y) ^ p ^ n = x ^ p ^ n - y ^ p ^ n"}, {"line": "simp [eq_sub_iff_add_eq, \u2190 add_pow_expChar_pow_of_commute _ _ (h.sub_left rfl)]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Ring R\nx y : R\np n : \u2115\nhR : ExpChar R p\nh : Commute x y\n\u22a2 (x - y) ^ p ^ n + y ^ p ^ n = x ^ p ^ n"}]}
{"declaration": "theorem squashSeq_nth_of_not_terminated {gp_n gp_succ_n : Pair K} (s_nth_eq : s.get? n = some gp_n)\n    (s_succ_nth_eq : s.get? (n + 1) = some gp_succ_n) :\n    (squashSeq s n).get? n = some \u27e8gp_n.a, gp_n.b + gp_succ_n.a / gp_succ_n.b\u27e9 := by\n  simp [*, squashSeq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/ConvergentsEquiv.lean", "context": {"open": [], "variables": ["{K : Type*} {n : \u2115}", "{g : GenContFract K} {s : Stream'.Seq <| Pair K}", "[DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Pair : ?m.881\nK : Type u_1\nn\u271d : \u2115\ng : GenContFract K\ns\u271d : Stream'.Seq sorry\ninst\u271d : DivisionRing K\nn : \u2115\ns : Stream'.Seq sorry\nx\u271d : Sort u_2\nsquashSeq : x\u271d\ngp_n : sorry\ngp_succ_n : sorry\ns_nth_eq : s.get? n = some gp_n\ns_succ_nth_eq : s.get? (n + 1) = some gp_succ_n\n\u22a2 sorry = some sorry"}, {"line": "simp [*, squashSeq]", "tactic_state": "Pair : ?m.881\nK : Type u_1\nn\u271d : \u2115\ng : GenContFract K\ns\u271d : Stream'.Seq sorry\ninst\u271d : DivisionRing K\nn : \u2115\ns : Stream'.Seq sorry\nx\u271d : Sort u_2\nsquashSeq : x\u271d\ngp_n : sorry\ngp_succ_n : sorry\ns_nth_eq : s.get? n = some gp_n\ns_succ_nth_eq : s.get? (n + 1) = some gp_succ_n\n\u22a2 sorry () = some (sorry ())"}]}
{"declaration": "theorem terminatedAt_iff_s_terminatedAt : g.TerminatedAt n \u2194 g.s.TerminatedAt n := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\n\u22a2 g.TerminatedAt n \u2194 g.s.TerminatedAt n"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem terminatedAt_iff_s_none : g.TerminatedAt n \u2194 g.s.get? n = none := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\n\u22a2 g.TerminatedAt n \u2194 g.s.get? n = none"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem partNum_none_iff_s_none : g.partNums.get? n = none \u2194 g.s.get? n = none := by\n  cases s_nth_eq : g.s.get? n <;> simp [partNums, s_nth_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\n\u22a2 g.partNums.get? n = none \u2194 g.s.get? n = none"}, {"line": "cases s_nth_eq : g.s.get? n <;> simp [partNums, s_nth_eq]", "tactic_state": "case none\n\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\ns_nth_eq : g.s.get? n = none\n\u22a2 g.partNums.get? n = none\n---\ncase some\n\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\nval\u271d : GenContFract.Pair \u03b1\ns_nth_eq : g.s.get? n = some val\u271d\n\u22a2 \u00acg.partNums.get? n = none"}]}
{"declaration": "theorem partDen_none_iff_s_none : g.partDens.get? n = none \u2194 g.s.get? n = none := by\n  cases s_nth_eq : g.s.get? n <;> simp [partDens, s_nth_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\n\u22a2 g.partDens.get? n = none \u2194 g.s.get? n = none"}, {"line": "cases s_nth_eq : g.s.get? n <;> simp [partDens, s_nth_eq]", "tactic_state": "case none\n\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\ns_nth_eq : g.s.get? n = none\n\u22a2 g.partDens.get? n = none\n---\ncase some\n\u03b1 : Type u_1\ng : GenContFract \u03b1\nn : \u2115\nval\u271d : GenContFract.Pair \u03b1\ns_nth_eq : g.s.get? n = some val\u271d\n\u22a2 \u00acg.partDens.get? n = none"}]}
{"declaration": "theorem exists_conts_a_of_num {A : K} (nth_num_eq : g.nums n = A) :\n    \u2203 conts, g.conts n = conts \u2227 conts.a = A := by simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\ng : GenContFract K\nn : \u2115\ninst\u271d : DivisionRing K\nA : K\nnth_num_eq : g.nums n = A\n\u22a2 \u2203 conts, g.conts n = conts \u2227 conts.a = A"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_conts_b_of_den {B : K} (nth_denom_eq : g.dens n = B) :\n    \u2203 conts, g.conts n = conts \u2227 conts.b = B := by simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\ng : GenContFract K\nn : \u2115\ninst\u271d : DivisionRing K\nB : K\nnth_denom_eq : g.dens n = B\n\u22a2 \u2203 conts, g.conts n = conts \u2227 conts.b = B"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zeroth_conv_eq_h : g.convs 0 = g.h := by\n  simp [conv_eq_num_div_den, num_eq_conts_a, den_eq_conts_b, div_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\ng : GenContFract K\ninst\u271d : DivisionRing K\n\u22a2 g.convs 0 = g.h"}, {"line": "simp [conv_eq_num_div_den, num_eq_conts_a, den_eq_conts_b, div_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zeroth_conv'_eq_h : g.convs' 0 = g.h := by simp [convs']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\ng : GenContFract K\ninst\u271d : DivisionRing K\n\u22a2 g.convs' 0 = g.h"}, {"line": "simp [convs']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convs'Aux_succ_none {s : Stream'.Seq (Pair K)} (h : s.head = none) (n : \u2115) :\n    convs'Aux s (n + 1) = 0 := by simp [convs'Aux, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nPair : x\u271d\u00b9\nx\u271d : Sort u_4\nconvs'Aux : x\u271d\ns : Stream'.Seq sorry\nh : s.head = none\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp [convs'Aux, h]", "tactic_state": "x\u271d\u00b9 : Sort u_3\nPair : x\u271d\u00b9\nx\u271d : Sort u_4\nconvs'Aux : x\u271d\ns : Stream'.Seq sorry\nh : s.head = none\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem convs'Aux_succ_some {s : Stream'.Seq (Pair K)} {p : Pair K} (h : s.head = some p)\n    (n : \u2115) : convs'Aux s (n + 1) = p.a / (p.b + convs'Aux s.tail n) := by\n  simp [convs'Aux, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Translations.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {g : GenContFract \u03b1} {n : \u2115}", "{K : Type*} {g : GenContFract K} {n : \u2115} [DivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_3\nPair : x\u271d\u00b9\nx\u271d : Sort u_4\nconvs'Aux : x\u271d\ns : Stream'.Seq sorry\np : sorry\nh : s.head = some p\nn : \u2115\n\u22a2 sorry = sorry / (sorry + sorry)"}, {"line": "simp [convs'Aux, h]", "tactic_state": "x\u271d\u00b9 : Sort u_3\nPair : x\u271d\u00b9\nx\u271d : Sort u_4\nconvs'Aux : x\u271d\ns : Stream'.Seq sorry\np : sorry\nh : s.head = some p\nn : \u2115\n\u22a2 sorry () = sorry () / (sorry () + sorry ())"}]}
{"declaration": "theorem of_convergence [TopologicalSpace K] [OrderTopology K] :\n    Filter.Tendsto (of v).convs Filter.atTop <| \ud835\udcdd v := by\n  simpa [LinearOrderedAddCommGroup.tendsto_nhds, abs_sub_comm] using of_convergence_epsilon v\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/ApproximationCorollaries.lean", "context": {"open": ["GenContFract (of)", "scoped Topology", "Nat"], "variables": ["{K : Type*} (v : K) [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]", "[Archimedean K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nv : K\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : LinearOrder K\ninst\u271d\u2074 : IsStrictOrderedRing K\ninst\u271d\u00b3 : FloorRing K\ninst\u271d\u00b2 : Archimedean K\ninst\u271d\u00b9 : TopologicalSpace K\ninst\u271d : OrderTopology K\n\u22a2 Filter.Tendsto (of v).convs Filter.atTop (nhds v)"}, {"line": "simpa [LinearOrderedAddCommGroup.tendsto_nhds, abs_sub_comm] using of_convergence_epsilon v", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_nth_stream_b_le_nth_stream_fr_inv {ifp_n ifp_succ_n : IntFractPair K}\n    (nth_stream_eq : IntFractPair.stream v n = some ifp_n)\n    (succ_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :\n    (ifp_succ_n.b : K) \u2264 ifp_n.fr\u207b\u00b9 := by\n  suffices (\u230aifp_n.fr\u207b\u00b9\u230b : K) \u2264 ifp_n.fr\u207b\u00b9 by\n    obtain \u27e8_, ifp_n_fr\u27e9 := ifp_n\n    have : ifp_n_fr \u2260 0 := by\n      intro h\n      simp [h, IntFractPair.stream, nth_stream_eq] at succ_nth_stream_eq\n    have : IntFractPair.of ifp_n_fr\u207b\u00b9 = ifp_succ_n := by\n      simpa [this, IntFractPair.stream, nth_stream_eq, Option.coe_def] using succ_nth_stream_eq\n    rwa [\u2190 this]\n  exact floor_le ifp_n.fr\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean", "context": {"open": ["GenContFract", "GenContFract (of)", "Int"], "variables": ["{K : Type*} {v : K} {n : \u2115} [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nifp_n ifp_succ_n : IntFractPair K\nnth_stream_eq : IntFractPair.stream v n = some ifp_n\nsucc_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n\n\u22a2 \u2191ifp_succ_n.b \u2264 ifp_n.fr\u207b\u00b9"}, {"line": "suffices (\u230aifp_n.fr\u207b\u00b9\u230b : K) \u2264 ifp_n.fr\u207b\u00b9 by\n    obtain \u27e8_, ifp_n_fr\u27e9 := ifp_n\n    have : ifp_n_fr \u2260 0 := by\n      intro h\n      simp [h, IntFractPair.stream, nth_stream_eq] at succ_nth_stream_eq\n    have : IntFractPair.of ifp_n_fr\u207b\u00b9 = ifp_succ_n := by\n      simpa [this, IntFractPair.stream, nth_stream_eq, Option.coe_def] using succ_nth_stream_eq\n    rwa [\u2190 this]", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nifp_n ifp_succ_n : IntFractPair K\nnth_stream_eq : IntFractPair.stream v n = some ifp_n\nsucc_nth_stream_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n\n\u22a2 sorry"}, {"line": "exact floor_le ifp_n.fr\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_partNum_eq_one_and_exists_int_partDen_eq {gp : GenContFract.Pair K}\n    (nth_s_eq : (of v).s.get? n = some gp) : gp.a = 1 \u2227 \u2203 z : \u2124, gp.b = (z : K) := by\n  obtain \u27e8ifp, stream_succ_nth_eq, -\u27e9 : \u2203 ifp, IntFractPair.stream v (n + 1) = some ifp \u2227 _ :=\n    IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some nth_s_eq\n  have : gp = \u27e81, ifp.b\u27e9 := by\n    have : (of v).s.get? n = some \u27e81, ifp.b\u27e9 :=\n      get?_of_eq_some_of_succ_get?_intFractPair_stream stream_succ_nth_eq\n    have : some gp = some \u27e81, ifp.b\u27e9 := by rwa [nth_s_eq] at this\n    injection this\n  simp [this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean", "context": {"open": ["GenContFract", "GenContFract (of)", "Int"], "variables": ["{K : Type*} {v : K} {n : \u2115} [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\ngp : Pair K\nnth_s_eq : (of v).s.get? n = some gp\n\u22a2 gp.a = 1 \u2227 \u2203 z, gp.b = \u2191z"}, {"line": "obtain \u27e8ifp, stream_succ_nth_eq, -\u27e9 : \u2203 ifp, IntFractPair.stream v (n + 1) = some ifp \u2227 _ :=\n    IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some nth_s_eq", "tactic_state": "case intro.intro\nK : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\ngp : Pair K\nnth_s_eq : (of v).s.get? n = some gp\nifp : ?m.1154\nstream_succ_nth_eq : sorry = some ifp\n\u22a2 gp.a = 1 \u2227 \u2203 z, gp.b = \u2191z"}, {"line": "have : gp = \u27e81, ifp.b\u27e9 := by\n    have : (of v).s.get? n = some \u27e81, ifp.b\u27e9 :=\n      get?_of_eq_some_of_succ_get?_intFractPair_stream stream_succ_nth_eq\n    have : some gp = some \u27e81, ifp.b\u27e9 := by rwa [nth_s_eq] at this\n    injection this", "tactic_state": "case intro.intro\nK : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\ngp : Pair K\nnth_s_eq : (of v).s.get? n = some gp\nifp : ?m.1154\nstream_succ_nth_eq : sorry = some ifp\nthis : gp = { a := sorry, b := sorry }\n\u22a2 gp.a = 1 \u2227 \u2203 z, gp.b = \u2191z"}, {"line": "simp [this]", "tactic_state": "case intro.intro\nK : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\ngp : Pair K\nnth_s_eq : (of v).s.get? n = some gp\nifp : ?m.1154\nstream_succ_nth_eq : sorry = some ifp\nthis : gp = { a := sorry, b := sorry }\n\u22a2 sorry () = 1 \u2227 \u2203 z, sorry () = \u2191z"}]}
{"declaration": "theorem le_of_succ_get?_den {b : K}\n    (nth_partDenom_eq : (of v).partDens.get? n = some b) :\n    b * (of v).dens n \u2264 (of v).dens (n + 1) := by\n  rw [den_eq_conts_b]\n  rw [nth_cont_eq_succ_nth_contAux]\n  exact le_of_succ_succ_get?_contsAux_b nth_partDenom_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/Approximations.lean", "context": {"open": ["GenContFract", "GenContFract (of)", "Int", "Nat"], "variables": ["{K : Type*} {v : K} {n : \u2115} [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]", "(v)", "{v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nb : K\nnth_partDenom_eq : (of v).partDens.get? n = some b\n\u22a2 b * (of v).dens n \u2264 (of v).dens (n + 1)"}, {"line": "rw [den_eq_conts_b]", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nb : K\nnth_partDenom_eq : (of v).partDens.get? n = some b\n\u22a2 b * ((of v).conts n).b \u2264 (of v).dens (n + 1)"}, {"line": "rw [nth_cont_eq_succ_nth_contAux]", "tactic_state": "K : Type u_1\nv : K\nn : \u2115\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nb : K\nnth_partDenom_eq : (of v).partDens.get? n = some b\n\u22a2 b * ((of v).contsAux (n + 1)).b \u2264 (of v).dens (n + 1)"}, {"line": "exact le_of_succ_succ_get?_contsAux_b nth_partDenom_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_rat_eq_of_terminates (terminates : (of v).Terminates) : \u2203 q : \u211a, v = \u2191q := by\n  obtain \u27e8n, v_eq_conv\u27e9 : \u2203 n, v = (of v).convs n := of_correctness_of_terminates terminates\n  obtain \u27e8q, conv_eq_q\u27e9 : \u2203 q : \u211a, (of v).convs n = (\u2191q : K) := exists_rat_eq_nth_conv v n\n  have : v = (\u2191q : K) := Eq.trans v_eq_conv conv_eq_q\n  use q, this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean", "context": {"open": ["GenContFract (of)"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]", "(v : K) (n : \u2115)", "{v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nv : K\nterminates : (of v).Terminates\n\u22a2 \u2203 q, v = \u2191q"}, {"line": "obtain \u27e8n, v_eq_conv\u27e9 : \u2203 n, v = (of v).convs n := of_correctness_of_terminates terminates", "tactic_state": "case intro\nK : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nv : K\nterminates : (of v).Terminates\nn : ?m.1748\nv_eq_conv : v = sorry\n\u22a2 \u2203 q, v = \u2191q"}, {"line": "obtain \u27e8q, conv_eq_q\u27e9 : \u2203 q : \u211a, (of v).convs n = (\u2191q : K) := exists_rat_eq_nth_conv v n", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nv : K\nterminates : (of v).Terminates\nn : ?m.1748\nv_eq_conv : v = sorry\nq : \u211a\nconv_eq_q : sorry = sorry\n\u22a2 \u2203 q, v = \u2191q"}, {"line": "have : v = (\u2191q : K) := Eq.trans v_eq_conv conv_eq_q", "tactic_state": "case intro.intro\nK : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nv : K\nterminates : (of v).Terminates\nn : ?m.1748\nv_eq_conv : v = sorry\nq : \u211a\nconv_eq_q : sorry = sorry\nthis : v = sorry\n\u22a2 \u2203 q, v = \u2191q"}, {"line": "use q, this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_of_rat_eq (v_eq_q : v = (\u2191q : K)) :\n    ((IntFractPair.of q).mapFr (\u2191) : IntFractPair K) = IntFractPair.of v := by\n  simp [IntFractPair.of, v_eq_q]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/TerminatesIffRat.lean", "context": {"open": ["GenContFract (of)"], "variables": ["{K : Type*} [Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorRing K]", "(v : K) (n : \u2115)", "{v}", "{v : K} {q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorRing K\nv : K\nq : \u211a\nx\u271d : Sort u_2\nIntFractPair : x\u271d\nv_eq_q : v = \u2191q\n\u22a2 sorry = sorry"}, {"line": "simp [IntFractPair.of, v_eq_q]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_h_eq_floor : (of v).h = \u230av\u230b := by\n  simp [of_h_eq_intFractPair_seq1_fst_b, IntFractPair.of]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/ContinuedFractions/Computation/Translations.lean", "context": {"open": ["GenContFract (of)"], "variables": ["{K : Type*} [DivisionRing K] [LinearOrder K] [FloorRing K] {v : K}", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : LinearOrder K\ninst\u271d : FloorRing K\nv : K\n\u22a2 (of v).h = \u2191\u230av\u230b"}, {"line": "simp [of_h_eq_intFractPair_seq1_fst_b, IntFractPair.of]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem decompose_coe {i : \u03b9} (x : \u2133 i) : decompose \u2133 (x : M) = DirectSum.of _ i x := by\n  rw [\u2190 decompose_symm_of _]\n  rw [Equiv.apply_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Decomposition.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 R M \u03c3 : Type*}", "[DecidableEq \u03b9] [AddCommMonoid M]", "[SetLike \u03c3 M] [AddSubmonoidClass \u03c3 M] (\u2133 : \u03b9 \u2192 \u03c3)", "[Decomposition \u2133]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 (decompose \u2133) \u2191x = (of (fun i => \u21a5(\u2133 i)) i) x"}, {"line": "rw [\u2190 decompose_symm_of _]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 (decompose \u2133) ((decompose \u2133).symm ((of (fun i => \u21a5(\u2133 i)) i) x)) = (of (fun i => \u21a5(\u2133 i)) i) x\n---\n\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 DecidableEq \u03b9\n---\n\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 AddCommMonoid M\n---\n\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 AddSubmonoidClass \u03c3 M\n---\n\u03b9 : Type u_1\nM : Type u_3\n\u03c3 : Type u_4\ninst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : SetLike \u03c3 M\ninst\u271d\u00b9 : AddSubmonoidClass \u03c3 M\n\u2133 : \u03b9 \u2192 \u03c3\ninst\u271d : Decomposition \u2133\ni : \u03b9\nx : \u21a5(\u2133 i)\n\u22a2 Decomposition \u2133"}, {"line": "rw [Equiv.apply_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInternal.addSubmonoid_iSup_eq_top {M : Type*} [DecidableEq \u03b9] [AddCommMonoid M]\n    (A : \u03b9 \u2192 AddSubmonoid M) (h : IsInternal A) : iSup A = \u22a4 := by\n  rw [AddSubmonoid.iSup_eq_mrange_dfinsuppSumAddHom]\n  rw [AddMonoidHom.mrange_eq_top]\n  exact Function.Bijective.surjective h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Basic.lean", "context": {"open": ["Function"], "variables": ["(\u03b9 : Type v) (\u03b2 : \u03b9 \u2192 Type w)", "{\u03b9}", "[\u2200 i, AddCommGroup (\u03b2 i)]", "{\u03b2}", "[\u2200 i, AddCommMonoid (\u03b2 i)]", "{\u03b2}", "[DecidableEq \u03b9]", "(\u03b2)", "{\u03b2}", "{\u03b3 : Type u\u2081} [AddCommMonoid \u03b3]", "(\u03c6 : \u2200 i, \u03b2 i \u2192+ \u03b3) (\u03c8 : (\u2a01 i, \u03b2 i) \u2192+ \u03b3)", "(\u03b2)", "{\u03ba : Type*}", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)]", "[DecidableEq \u03b9] {\u03b1 : \u03b9 \u2192 Type u} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w} [\u2200 i j, AddCommMonoid (\u03b4 i j)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "i : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 iSup A = \u22a4"}, {"line": "rw [AddSubmonoid.iSup_eq_mrange_dfinsuppSumAddHom]", "tactic_state": "i : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 AddMonoidHom.mrange (DFinsupp.sumAddHom fun i => (A i).subtype) = \u22a4\n---\ni : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 DecidableEq \u03b9"}, {"line": "rw [AddMonoidHom.mrange_eq_top]", "tactic_state": "i : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 Surjective \u21d1(DFinsupp.sumAddHom fun i => (A i).subtype)\n---\ni : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 DecidableEq \u03b9\n---\ni : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 DecidableEq \u03b9"}, {"line": "exact Function.Bijective.surjective h", "tactic_state": "i : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 DecidableEq \u03b9\n---\ni : ?m.97753 \u2192 ?m.97754\n\u03b9\u271d : Type v\n\u03b2 : \u03b9\u271d \u2192 Type w\ninst\u271d\u00b9\u2070 : (i : \u03b9\u271d) \u2192 AddCommGroup (\u03b2 i)\ninst\u271d\u2079 : (i : \u03b9\u271d) \u2192 AddCommMonoid (\u03b2 i)\ninst\u271d\u2078 : DecidableEq \u03b9\u271d\n\u03b3 : Type u\u2081\ninst\u271d\u2077 : AddCommMonoid \u03b3\n\u03c6 : (i : \u03b9\u271d) \u2192 \u03b2 i \u2192+ \u03b3\n\u03c8 : sorry\n\u03ba : Type u_1\n\u03b1\u271d : Option \u03b9\u271d \u2192 Type w\ninst\u271d\u2076 : (i : Option \u03b9\u271d) \u2192 AddCommMonoid (\u03b1\u271d i)\ninst\u271d\u2075 : DecidableEq \u03b9\u271d\n\u03b1 : \u03b9\u271d \u2192 Type u\n\u03b4 : (i : \u03b9\u271d) \u2192 \u03b1 i \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9\u271d) \u2192 (j : \u03b1 i) \u2192 AddCommMonoid (\u03b4 i j)\n\u03b9 : Type v\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\nx\u271d : Sort u_3\nIsInternal : x\u271d\nM : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : AddCommMonoid M\nA : \u03b9 \u2192 AddSubmonoid M\nh : sorry\n\u22a2 DecidableEq \u03b9"}]}
{"declaration": "theorem coe_mul_of_apply (r : \u2a01 i, A i) {i : \u03b9} (r' : A i) (n : \u03b9) [Decidable (i \u2264 n)] :\n    ((r * of (fun i => A i) i r') n : R) = if i \u2264 n then (r (n - i) : R) * r' else 0 := by\n  split_ifs with h\n  exacts [coe_mul_of_apply_of_le _ _ _ n h, coe_mul_of_apply_of_not_le _ _ _ n h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Internal.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 : Type*} {\u03c3 S R : Type*}", "[DecidableEq \u03b9]", "[Semiring R] [SetLike \u03c3 R] [AddSubmonoidClass \u03c3 R] (A : \u03b9 \u2192 \u03c3)", "[Semiring R] [SetLike \u03c3 R] [AddSubmonoidClass \u03c3 R] (A : \u03b9 \u2192 \u03c3)", "[AddCommMonoid \u03b9] [PartialOrder \u03b9] [CanonicallyOrderedAdd \u03b9] [SetLike.GradedMonoid A]", "[Sub \u03b9] [OrderedSub \u03b9] [AddLeftReflectLE \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\nr : DirectSum \u03b9 fun i => \u21a5(A i)\ni : \u03b9\nr' : \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\n\u22a2 \u2191((r * (of (fun i => \u21a5(A i)) i) r') n) = if i \u2264 n then \u2191(r (n - i)) * \u2191r' else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\nr : DirectSum \u03b9 fun i => \u21a5(A i)\ni : \u03b9\nr' : \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\nh : i \u2264 n\n\u22a2 \u2191((r * (of (fun i => \u21a5(A i)) i) r') n) = \u2191(r (n - i)) * \u2191r'\n---\ncase neg\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\nr : DirectSum \u03b9 fun i => \u21a5(A i)\ni : \u03b9\nr' : \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\nh : \u00aci \u2264 n\n\u22a2 \u2191((r * (of (fun i => \u21a5(A i)) i) r') n) = 0"}, {"line": "exacts [coe_mul_of_apply_of_le _ _ _ n h, coe_mul_of_apply_of_not_le _ _ _ n h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_of_mul_apply {i : \u03b9} (r : A i) (r' : \u2a01 i, A i) (n : \u03b9) [Decidable (i \u2264 n)] :\n    ((of (fun i => A i) i r * r') n : R) = if i \u2264 n then (r * r' (n - i) : R) else 0 := by\n  split_ifs with h\n  exacts [coe_of_mul_apply_of_le _ _ _ n h, coe_of_mul_apply_of_not_le _ _ _ n h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Internal.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 : Type*} {\u03c3 S R : Type*}", "[DecidableEq \u03b9]", "[Semiring R] [SetLike \u03c3 R] [AddSubmonoidClass \u03c3 R] (A : \u03b9 \u2192 \u03c3)", "[Semiring R] [SetLike \u03c3 R] [AddSubmonoidClass \u03c3 R] (A : \u03b9 \u2192 \u03c3)", "[AddCommMonoid \u03b9] [PartialOrder \u03b9] [CanonicallyOrderedAdd \u03b9] [SetLike.GradedMonoid A]", "[Sub \u03b9] [OrderedSub \u03b9] [AddLeftReflectLE \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\ni : \u03b9\nr : \u21a5(A i)\nr' : DirectSum \u03b9 fun i => \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\n\u22a2 \u2191(((of (fun i => \u21a5(A i)) i) r * r') n) = if i \u2264 n then \u2191r * \u2191(r' (n - i)) else 0"}, {"line": "split_ifs with h", "tactic_state": "case pos\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\ni : \u03b9\nr : \u21a5(A i)\nr' : DirectSum \u03b9 fun i => \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\nh : i \u2264 n\n\u22a2 \u2191(((of (fun i => \u21a5(A i)) i) r * r') n) = \u2191r * \u2191(r' (n - i))\n---\ncase neg\n\u03b9 : Type u_1\n\u03c3 : Type u_2\nR : Type u_4\ninst\u271d\u00b9\u2074 : DecidableEq \u03b9\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : SetLike \u03c3 R\ninst\u271d\u00b9\u00b9 : AddSubmonoidClass \u03c3 R\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : SetLike \u03c3 R\ninst\u271d\u2078 : AddSubmonoidClass \u03c3 R\nA : \u03b9 \u2192 \u03c3\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : PartialOrder \u03b9\ninst\u271d\u2075 : CanonicallyOrderedAdd \u03b9\ninst\u271d\u2074 : SetLike.GradedMonoid A\ninst\u271d\u00b3 : Sub \u03b9\ninst\u271d\u00b2 : OrderedSub \u03b9\ninst\u271d\u00b9 : AddLeftReflectLE \u03b9\ni : \u03b9\nr : \u21a5(A i)\nr' : DirectSum \u03b9 fun i => \u21a5(A i)\nn : \u03b9\ninst\u271d : Decidable (i \u2264 n)\nh : \u00aci \u2264 n\n\u22a2 \u2191(((of (fun i => \u21a5(A i)) i) r * r') n) = 0"}, {"line": "exacts [coe_of_mul_apply_of_le _ _ _ n h, coe_of_mul_apply_of_not_le _ _ _ n h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearEquivFunOnFintype_symm_coe [Fintype \u03b9] (f : \u2a01 i, M i) :\n    (linearEquivFunOnFintype R \u03b9 M).symm f = f := by\n  simp [linearEquivFunOnFintype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : Semiring R\n\u03b9 : Type v\nM : \u03b9 \u2192 Type w\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nf : DirectSum \u03b9 fun i => M i\n\u22a2 (linearEquivFunOnFintype R \u03b9 M).symm \u21d1f = f"}, {"line": "simp [linearEquivFunOnFintype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lmap_injective : Function.Injective (lmap f) \u2194 \u2200 i, Function.Injective (f i) := by\n  classical exact DFinsupp.mapRange_injective (hf := fun _ \u21a6 map_zero _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\n\u03b9 : Type v\nM : \u03b9 \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b2 : DecidableEq \u03b9\nN : \u03b9 \u2192 Type u_1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (N i)\ninst\u271d : (i : \u03b9) \u2192 Module R (N i)\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N i\n\u22a2 Function.Injective \u21d1(lmap f) \u2194 \u2200 (i : \u03b9), Function.Injective \u21d1(f i)"}, {"line": "classical exact DFinsupp.mapRange_injective (hf := fun _ \u21a6 map_zero _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lmap_surjective : Function.Surjective (lmap f) \u2194 (\u2200 i, Function.Surjective (f i)) := by\n  classical exact DFinsupp.mapRange_surjective (hf := fun _ \u21a6 map_zero _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2075 : Semiring R\n\u03b9 : Type v\nM : \u03b9 \u2192 Type w\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u00b2 : DecidableEq \u03b9\nN : \u03b9 \u2192 Type u_1\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (N i)\ninst\u271d : (i : \u03b9) \u2192 Module R (N i)\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N i\n\u22a2 Function.Surjective \u21d1(lmap f) \u2194 \u2200 (i : \u03b9), Function.Surjective \u21d1(f i)"}, {"line": "classical exact DFinsupp.mapRange_surjective (hf := fun _ \u21a6 map_zero _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeLinearMap_eq_dfinsuppSum [DecidableEq M] (x : DirectSum \u03b9 fun i => A i) :\n    coeLinearMap A x = DFinsupp.sum x fun i => (fun x : A i => \u2191x) := by\n  simp only [coeLinearMap]\n  simp only [toModule]\n  simp only [DFinsupp.lsum]\n  simp only [LinearEquiv.coe_mk]\n  simp only [LinearMap.coe_mk]\n  simp only [AddHom.coe_mk]\n  rw [DFinsupp.sumAddHom_apply]\n  simp only [LinearMap.toAddMonoidHom_coe]\n  simp only [Submodule.coe_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (coeLinearMap A) x = DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [coeLinearMap]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (toModule R \u03b9 M fun i => (A i).subtype) x = DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [toModule]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 ((DFinsupp.lsum \u2115) fun i => (A i).subtype) x = DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [DFinsupp.lsum]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 ({ toFun := fun F => { toFun := \u21d1(DFinsupp.sumAddHom fun i => (F i).toAddMonoidHom), map_add' := \u22ef, map_smul' := \u22ef },\n          map_add' := \u22ef, map_smul' := \u22ef, invFun := fun F i => F \u2218\u2097 DFinsupp.lsingle i, left_inv := \u22ef, right_inv := \u22ef }\n        fun i => (A i).subtype)\n      x =\n    DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [LinearEquiv.coe_mk]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 { toFun := \u21d1(DFinsupp.sumAddHom fun i => (A i).subtype.toAddMonoidHom), map_add' := \u22ef, map_smul' := \u22ef } x =\n    DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [LinearMap.coe_mk]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 { toFun := \u21d1(DFinsupp.sumAddHom fun i => (A i).subtype.toAddMonoidHom), map_add' := \u22ef } x =\n    DFinsupp.sum x fun i x => \u2191x"}, {"line": "simp only [AddHom.coe_mk]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (DFinsupp.sumAddHom fun i => (A i).subtype.toAddMonoidHom) x = DFinsupp.sum x fun i x => \u2191x"}, {"line": "rw [DFinsupp.sumAddHom_apply]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (DFinsupp.sum x fun x => \u21d1(A x).subtype.toAddMonoidHom) = DFinsupp.sum x fun i x => \u2191x\n---\nR : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (i : \u03b9) \u2192 (x : \u21a5(A i)) \u2192 Decidable (x \u2260 0)"}, {"line": "simp only [LinearMap.toAddMonoidHom_coe]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (DFinsupp.sum x fun x => \u21d1(A x).subtype) = DFinsupp.sum x fun i x => \u2191x\n---\nR : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (i : \u03b9) \u2192 (x : \u21a5(A i)) \u2192 Decidable (x \u2260 0)"}, {"line": "simp only [Submodule.coe_subtype]", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (DFinsupp.sum x fun x => Subtype.val) = DFinsupp.sum x fun i x => \u2191x\n---\nR : Type u\ninst\u271d\u00b3 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\nA : \u03b9 \u2192 Submodule R M\ninst\u271d : DecidableEq M\nx : DirectSum \u03b9 fun i => \u21a5(A i)\n\u22a2 (i : \u03b9) \u2192 (x : \u21a5(A i)) \u2192 Decidable (x \u2260 0)"}]}
{"declaration": "theorem IsInternal.ofBijective_coeLinearMap_same (h : IsInternal A)\n    {i : \u03b9} (x : A i) :\n    (LinearEquiv.ofBijective (coeLinearMap A) h).symm x i = x := by\n  rw [\u2190 coeLinearMap_of]\n  rw [LinearEquiv.ofBijective_symm_apply_apply]\n  rw [of_eq_same]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)", "{A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\ni : \u03b9\nx : \u21a5(A i)\n\u22a2 ((LinearEquiv.ofBijective (coeLinearMap A) h).symm \u2191x) i = x"}, {"line": "rw [\u2190 coeLinearMap_of]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\ni : \u03b9\nx : \u21a5(A i)\n\u22a2 ((LinearEquiv.ofBijective (coeLinearMap A) h).symm ((coeLinearMap A) ((of (fun i => \u21a5(A i)) i) x))) i = x\n---\nR : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\ni : \u03b9\nx : \u21a5(A i)\n\u22a2 DecidableEq \u03b9"}, {"line": "rw [LinearEquiv.ofBijective_symm_apply_apply]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\ni : \u03b9\nx : \u21a5(A i)\n\u22a2 ((of (fun i => \u21a5(A i)) i) x) i = x"}, {"line": "rw [of_eq_same]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInternal.submodule_iSup_eq_top (h : IsInternal A) : iSup A = \u22a4 := by\n  rw [Submodule.iSup_eq_range_dfinsupp_lsum]\n  rw [LinearMap.range_eq_top]\n  exact Function.Bijective.surjective h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)", "{A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 iSup A = \u22a4"}, {"line": "rw [Submodule.iSup_eq_range_dfinsupp_lsum]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 LinearMap.range ((DFinsupp.lsum \u2115) fun i => (A i).subtype) = \u22a4\n---\nR : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 DecidableEq \u03b9"}, {"line": "rw [LinearMap.range_eq_top]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 Function.Surjective \u21d1((DFinsupp.lsum \u2115) fun i => (A i).subtype)\n---\nR : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 DecidableEq \u03b9\n---\nR : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u22a2 DecidableEq \u03b9"}, {"line": "exact Function.Bijective.surjective h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsInternal.collectedBasis_mem (h : IsInternal A) {\u03b1 : \u03b9 \u2192 Type*}\n    (v : \u2200 i, Basis (\u03b1 i) R (A i)) (a : \u03a3 i, \u03b1 i) : h.collectedBasis v a \u2208 A a.1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)", "{A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Semiring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_5\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\nh : IsInternal A\n\u03b1 : \u03b9 \u2192 Type u_6\nv : (i : \u03b9) \u2192 Basis (\u03b1 i) R \u21a5(A i)\na : (i : \u03b9) \u00d7 \u03b1 i\n\u22a2 (h.collectedBasis v) a \u2208 A a.fst"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInternal_submodule_iff_isCompl (A : \u03b9 \u2192 Submodule R M) {i j : \u03b9} (hij : i \u2260 j)\n    (h : (Set.univ : Set \u03b9) = {i, j}) : IsInternal A \u2194 IsCompl (A i) (A j) := by\n  have : \u2200 k, k = i \u2228 k = j := fun k \u21a6 by simpa using Set.ext_iff.mp h k\n  rw [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]\n  rw [iSup]\n  rw [\u2190 Set.image_univ]\n  rw [h]\n  rw [Set.image_insert_eq]\n  rw [Set.image_singleton]\n  rw [sSup_pair]\n  rw [iSupIndep_pair hij this]\n  exact \u27e8fun \u27e8hd, ht\u27e9 \u21a6 \u27e8hd, codisjoint_iff.mpr ht\u27e9, fun \u27e8hd, ht\u27e9 \u21a6 \u27e8hd, ht.eq_top\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)", "{A}", "{R : Type u} [Ring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\n\u22a2 IsInternal A \u2194 IsCompl (A i) (A j)"}, {"line": "have : \u2200 k, k = i \u2228 k = j := fun k \u21a6 by simpa using Set.ext_iff.mp h k", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 IsInternal A \u2194 IsCompl (A i) (A j)"}, {"line": "rw [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 iSup A = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [iSup]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 sSup (Set.range A) = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [\u2190 Set.image_univ]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 sSup (A '' Set.univ) = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [h]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 sSup (A '' {i, j}) = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [Set.image_insert_eq]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 sSup (insert (A i) (A '' {j})) = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [Set.image_singleton]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 sSup {A i, A j} = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [sSup_pair]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 iSupIndep A \u2227 A i \u2294 A j = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "rw [iSupIndep_pair hij this]", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\ni j : \u03b9\nhij : i \u2260 j\nh : Set.univ = {i, j}\nthis : \u2200 (k : \u03b9), k = i \u2228 k = j\n\u22a2 Disjoint (A i) (A j) \u2227 A i \u2294 A j = \u22a4 \u2194 IsCompl (A i) (A j)"}, {"line": "exact \u27e8fun \u27e8hd, ht\u27e9 \u21a6 \u27e8hd, codisjoint_iff.mpr ht\u27e9, fun \u27e8hd, ht\u27e9 \u21a6 \u27e8hd, ht.eq_top\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInternal_ne_bot_iff {A : \u03b9 \u2192 Submodule R M} :\n    IsInternal (fun i : {i // A i \u2260 \u22a5} \u21a6 A i) \u2194 IsInternal A := by\n  simp [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Module.lean", "context": {"open": ["DirectSum Finsupp"], "variables": ["{R : Type u} [Semiring R]", "{\u03b9 : Type v}", "{M : \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "(R) in", "(R \u03b9 M)", "[DecidableEq \u03b9]", "{\u03b9 M}", "{R}", "{N : Type u\u2081} [AddCommMonoid N] [Module R N]", "(\u03c6 : \u2200 i, M i \u2192\u2097[R] N)", "(R \u03b9 N)", "{\u03b9 N \u03c6}", "(\u03c8 : (\u2a01 i, M i) \u2192\u2097[R] N)", "{\u03c8} {\u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N}", "(\u03b9 M)", "{\u03b9 M}", "{\u03b9 M}", "{R} {N : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (N i)] [\u2200 i, Module R (N i)]", "(f : \u2200 i, M i \u2192+ N i)", "(f : \u03a0 i, M i \u2192\u2097[R] N i)", "{R : Type u} {\u03b9 : Type v} {M : \u03b9 \u2192 Type w} {N : \u03b9 \u2192 Type*}", "{\u03ba : Type*}", "{\u03b1 : \u03b9 \u2192 Type*} {\u03b4 : \u2200 i, \u03b1 i \u2192 Type w}", "[DecidableEq \u03b9] [\u2200 i j, AddCommMonoid (\u03b4 i j)] [\u2200 i j, Module R (\u03b4 i j)]", "{\u03b1 : Option \u03b9 \u2192 Type w} [\u2200 i, AddCommMonoid (\u03b1 i)] [\u2200 i, Module R (\u03b1 i)]", "{R : Type u} [Semiring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommMonoid M] [Module R M]", "(A : \u03b9 \u2192 Submodule R M)", "{A}", "{R : Type u} [Ring R]", "{\u03b9 : Type v} [dec_\u03b9 : DecidableEq \u03b9]", "{M : Type*} [AddCommGroup M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : Ring R\n\u03b9 : Type v\ndec_\u03b9 : DecidableEq \u03b9\nM : Type u_6\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nA : \u03b9 \u2192 Submodule R M\n\u22a2 (IsInternal fun i => A \u2191i) \u2194 IsInternal A"}, {"line": "simp [isInternal_submodule_iff_iSupIndep_and_iSup_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem list_prod_ofFn_of_eq_dProd (n : \u2115) (f\u03b9 : Fin n \u2192 \u03b9) (fA : \u2200 a, A (f\u03b9 a)) :\n    (List.ofFn fun a => of A (f\u03b9 a) (fA a)).prod = of A _ ((List.finRange n).dProd f\u03b9 fA) := by\n  rw [List.ofFn_eq_map]\n  rw [ofList_dProd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Ring.lean", "context": {"open": ["DirectSum", "AddMonoidHom (flip_apply coe_comp compHom)", "AddMonoidHom (flipHom coe_comp compHom flip_apply)"], "variables": ["{\u03b9 : Type*} [DecidableEq \u03b9]", "(A : \u03b9 \u2192 Type*)", "(A : \u03b9 \u2192 Type*)", "(A : \u03b9 \u2192 Type*)", "[Zero \u03b9] [GradedMonoid.GOne A] [\u2200 i, AddCommMonoid (A i)]", "[Add \u03b9] [\u2200 i, AddCommMonoid (A i)] [GNonUnitalNonAssocSemiring A]", "{A}", "[\u2200 i, AddCommMonoid (A i)] [AddMonoid \u03b9] [GSemiring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2079 : DecidableEq \u03b9\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : Zero \u03b9\ninst\u271d\u2077 : GradedMonoid.GOne A\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2075 : Add \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GSemiring A\nn : \u2115\nf\u03b9 : Fin n \u2192 \u03b9\nfA : (a : Fin n) \u2192 A (f\u03b9 a)\n\u22a2 (List.ofFn fun a => (of A (f\u03b9 a)) (fA a)).prod =\n    (of A ((List.finRange n).dProdIndex f\u03b9)) ((List.finRange n).dProd f\u03b9 fA)"}, {"line": "rw [List.ofFn_eq_map]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2079 : DecidableEq \u03b9\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : Zero \u03b9\ninst\u271d\u2077 : GradedMonoid.GOne A\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2075 : Add \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GSemiring A\nn : \u2115\nf\u03b9 : Fin n \u2192 \u03b9\nfA : (a : Fin n) \u2192 A (f\u03b9 a)\n\u22a2 (List.map (fun a => (of A (f\u03b9 a)) (fA a)) (List.finRange n)).prod =\n    (of A ((List.finRange n).dProdIndex f\u03b9)) ((List.finRange n).dProd f\u03b9 fA)"}, {"line": "rw [ofList_dProd]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2079 : DecidableEq \u03b9\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : Zero \u03b9\ninst\u271d\u2077 : GradedMonoid.GOne A\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2075 : Add \u03b9\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : GSemiring A\nn : \u2115\nf\u03b9 : Fin n \u2192 \u03b9\nfA : (a : Fin n) \u2192 A (f\u03b9 a)\n\u22a2 (List.map (fun a => (of A (f\u03b9 a)) (fA a)) (List.finRange n)).prod =\n    (List.map (fun a => (of A (f\u03b9 a)) (fA a)) (List.finRange n)).prod"}]}
{"declaration": "example {R : Type*} [AddMonoid \u03b9] [Semiring R] (i j : \u03b9) (a b : R) :\n    (DirectSum.of _ i a * DirectSum.of _ j b : \u2a01 _, R) = DirectSum.of _ (i + j) (a * b) := by\n  rw [DirectSum.of_mul_of]\n  rw [Mul.gMul_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/DirectSum/Ring.lean", "context": {"open": ["DirectSum", "AddMonoidHom (flip_apply coe_comp compHom)", "AddMonoidHom (flipHom coe_comp compHom flip_apply)", "DirectSum"], "variables": ["{\u03b9 : Type*} [DecidableEq \u03b9]", "(A : \u03b9 \u2192 Type*)", "(A : \u03b9 \u2192 Type*)", "(A : \u03b9 \u2192 Type*)", "[Zero \u03b9] [GradedMonoid.GOne A] [\u2200 i, AddCommMonoid (A i)]", "[Add \u03b9] [\u2200 i, AddCommMonoid (A i)] [GNonUnitalNonAssocSemiring A]", "{A}", "[\u2200 i, AddCommMonoid (A i)] [AddMonoid \u03b9] [GSemiring A]", "[\u2200 i, AddCommMonoid (A i)] [AddCommMonoid \u03b9] [GCommSemiring A]", "[\u2200 i, AddCommGroup (A i)] [Add \u03b9] [GNonUnitalNonAssocSemiring A]", "[\u2200 i, AddCommGroup (A i)] [AddMonoid \u03b9] [GRing A]", "[\u2200 i, AddCommGroup (A i)] [AddCommMonoid \u03b9] [GCommRing A]", "[Zero \u03b9] [GradedMonoid.GOne A] [\u2200 i, AddCommMonoid (A i)]", "[AddZeroClass \u03b9] [\u2200 i, AddCommMonoid (A i)] [GNonUnitalNonAssocSemiring A]", "[\u2200 i, AddCommMonoid (A i)] [AddMonoid \u03b9] [GSemiring A]", "[\u2200 i, AddCommMonoid (A i)] [AddCommMonoid \u03b9] [GCommSemiring A]", "[\u2200 i, AddCommGroup (A i)] [AddZeroClass \u03b9] [GNonUnitalNonAssocSemiring A]", "[\u2200 i, AddCommGroup (A i)] [AddMonoid \u03b9] [GRing A]", "[\u2200 i, AddCommGroup (A i)] [AddCommMonoid \u03b9] [GCommRing A]", "{R : Type*} [\u2200 i, AddCommMonoid (A i)] [AddMonoid \u03b9] [GSemiring A] [Semiring R]", "{A}", "(\u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074\u2078 : DecidableEq \u03b9\nA\u271d\u00b9 : \u03b9 \u2192 Type u_2\nA\u271d : \u03b9 \u2192 Type u_3\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2074\u2077 : Zero \u03b9\ninst\u271d\u2074\u2076 : GradedMonoid.GOne A\ninst\u271d\u2074\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2074 : Add \u03b9\ninst\u271d\u2074\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u2074\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2070 : AddMonoid \u03b9\ninst\u271d\u00b3\u2079 : GSemiring A\ninst\u271d\u00b3\u2078 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3\u2077 : AddCommMonoid \u03b9\ninst\u271d\u00b3\u2076 : GCommSemiring A\ninst\u271d\u00b3\u2075 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u2074 : Add \u03b9\ninst\u271d\u00b3\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b3\u00b2 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b3\u2070 : GRing A\ninst\u271d\u00b2\u2079 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b2\u2078 : AddCommMonoid \u03b9\ninst\u271d\u00b2\u2077 : GCommRing A\ninst\u271d\u00b2\u2076 : Zero \u03b9\ninst\u271d\u00b2\u2075 : GradedMonoid.GOne A\ninst\u271d\u00b2\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b2\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b9 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u2070 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2079 : AddMonoid \u03b9\ninst\u271d\u00b9\u2078 : GSemiring A\ninst\u271d\u00b9\u2077 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2076 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2075 : GCommSemiring A\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b9\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u2070 : AddMonoid \u03b9\ninst\u271d\u2079 : GRing A\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : GCommRing A\nR\u271d : Type u_5\ninst\u271d\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : GSemiring A\ninst\u271d\u00b2 : Semiring R\u271d\nR : Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : Semiring R\ni j : \u03b9\na b : R\n\u22a2 (of (fun x => R) i) a * (of (fun x => R) j) b = (of (fun i => R) (i + j)) (a * b)"}, {"line": "rw [DirectSum.of_mul_of]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074\u2078 : DecidableEq \u03b9\nA\u271d\u00b9 : \u03b9 \u2192 Type u_2\nA\u271d : \u03b9 \u2192 Type u_3\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2074\u2077 : Zero \u03b9\ninst\u271d\u2074\u2076 : GradedMonoid.GOne A\ninst\u271d\u2074\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2074 : Add \u03b9\ninst\u271d\u2074\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u2074\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2070 : AddMonoid \u03b9\ninst\u271d\u00b3\u2079 : GSemiring A\ninst\u271d\u00b3\u2078 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3\u2077 : AddCommMonoid \u03b9\ninst\u271d\u00b3\u2076 : GCommSemiring A\ninst\u271d\u00b3\u2075 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u2074 : Add \u03b9\ninst\u271d\u00b3\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b3\u00b2 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b3\u2070 : GRing A\ninst\u271d\u00b2\u2079 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b2\u2078 : AddCommMonoid \u03b9\ninst\u271d\u00b2\u2077 : GCommRing A\ninst\u271d\u00b2\u2076 : Zero \u03b9\ninst\u271d\u00b2\u2075 : GradedMonoid.GOne A\ninst\u271d\u00b2\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b2\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b9 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u2070 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2079 : AddMonoid \u03b9\ninst\u271d\u00b9\u2078 : GSemiring A\ninst\u271d\u00b9\u2077 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2076 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2075 : GCommSemiring A\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b9\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u2070 : AddMonoid \u03b9\ninst\u271d\u2079 : GRing A\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : GCommRing A\nR\u271d : Type u_5\ninst\u271d\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : GSemiring A\ninst\u271d\u00b2 : Semiring R\u271d\nR : Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : Semiring R\ni j : \u03b9\na b : R\n\u22a2 (of (fun x => R) (i + j)) (GradedMonoid.GMul.mul a b) = (of (fun i => R) (i + j)) (a * b)"}, {"line": "rw [Mul.gMul_mul]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074\u2078 : DecidableEq \u03b9\nA\u271d\u00b9 : \u03b9 \u2192 Type u_2\nA\u271d : \u03b9 \u2192 Type u_3\nA : \u03b9 \u2192 Type u_4\ninst\u271d\u2074\u2077 : Zero \u03b9\ninst\u271d\u2074\u2076 : GradedMonoid.GOne A\ninst\u271d\u2074\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2074 : Add \u03b9\ninst\u271d\u2074\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u2074\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074\u2070 : AddMonoid \u03b9\ninst\u271d\u00b3\u2079 : GSemiring A\ninst\u271d\u00b3\u2078 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b3\u2077 : AddCommMonoid \u03b9\ninst\u271d\u00b3\u2076 : GCommSemiring A\ninst\u271d\u00b3\u2075 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u2074 : Add \u03b9\ninst\u271d\u00b3\u00b3 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b3\u00b2 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b3\u00b9 : AddMonoid \u03b9\ninst\u271d\u00b3\u2070 : GRing A\ninst\u271d\u00b2\u2079 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b2\u2078 : AddCommMonoid \u03b9\ninst\u271d\u00b2\u2077 : GCommRing A\ninst\u271d\u00b2\u2076 : Zero \u03b9\ninst\u271d\u00b2\u2075 : GradedMonoid.GOne A\ninst\u271d\u00b2\u2074 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b2\u00b2 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b2\u00b9 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b2\u2070 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2079 : AddMonoid \u03b9\ninst\u271d\u00b9\u2078 : GSemiring A\ninst\u271d\u00b9\u2077 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u00b9\u2076 : AddCommMonoid \u03b9\ninst\u271d\u00b9\u2075 : GCommSemiring A\ninst\u271d\u00b9\u2074 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u00b3 : AddZeroClass \u03b9\ninst\u271d\u00b9\u00b2 : GNonUnitalNonAssocSemiring A\ninst\u271d\u00b9\u00b9 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u00b9\u2070 : AddMonoid \u03b9\ninst\u271d\u2079 : GRing A\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommGroup (A i)\ninst\u271d\u2077 : AddCommMonoid \u03b9\ninst\u271d\u2076 : GCommRing A\nR\u271d : Type u_5\ninst\u271d\u2075 : (i : \u03b9) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074 : AddMonoid \u03b9\ninst\u271d\u00b3 : GSemiring A\ninst\u271d\u00b2 : Semiring R\u271d\nR : Type u_6\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : Semiring R\ni j : \u03b9\na b : R\n\u22a2 (of (fun x => R) (i + j)) (a * b) = (of (fun i => R) (i + j)) (a * b)"}]}
{"declaration": "theorem dvd_of_eq (h : a = b) : a \u2223 b := by rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Divisibility/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Semigroup \u03b1] {a b c : \u03b1}", "(\u03b1) in", "[Monoid \u03b1] {a b c : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\na b : \u03b1\nh : a = b\n\u22a2 a \u2223 b"}, {"line": "rw [h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\na b : \u03b1\nh : a = b\n\u22a2 b \u2223 b"}]}
{"declaration": "theorem mul_dvd_mul_left (a : \u03b1) (h : b \u2223 c) : a * b \u2223 a * c := by\n  obtain \u27e8d, rfl\u27e9 := h\n  use d\n  rw [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Divisibility/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Semigroup \u03b1] {a b c : \u03b1}", "(\u03b1) in", "[Monoid \u03b1] {a b c : \u03b1} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nb c a : \u03b1\nh : b \u2223 c\n\u22a2 a * b \u2223 a * c"}, {"line": "obtain \u27e8d, rfl\u27e9 := h", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nb a d : \u03b1\n\u22a2 a * b \u2223 a * (b * d)"}, {"line": "use d", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : Semigroup \u03b1\nb a d : \u03b1\n\u22a2 a * (b * d) = a * b * d"}, {"line": "rw [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mod_zero (a : R) : a % 0 = a := by simpa only [zero_mul, zero_add] using div_add_mod a 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/EuclideanDomain/Defs.lean", "context": {"open": [], "variables": ["{R : Type u} [EuclideanDomain R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : EuclideanDomain R\na : R\n\u22a2 a % 0 = a"}, {"line": "simpa only [zero_mul, zero_add] using div_add_mod a 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_mul_add_mul_one_div_eq_one_div_add_one_div (ha : a \u2260 0) (hb : b \u2260 0) :\n    1 / a * (a + b) * (1 / b) = 1 / a + 1 / b := by\n  simpa only [one_div] using (inv_add_inv' ha hb).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : DivisionSemiring K\na b : K\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 1 / a * (a + b) * (1 / b) = 1 / a + 1 / b"}, {"line": "simpa only [one_div] using (inv_add_inv' ha hb).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem same_sub_div {a b : K} (h : b \u2260 0) : (b - a) / b = 1 - a / b := by\n  simpa only [\u2190 @div_self _ _ b h] using (div_sub_div_same b a b).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}", "[NeZero (2 : K)]", "[DivisionRing K] {a b c d : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : DivisionSemiring K\ninst\u271d\u00b9 : NeZero 2\ninst\u271d : DivisionRing K\na b : K\nh : b \u2260 0\n\u22a2 (b - a) / b = 1 - a / b"}, {"line": "simpa only [\u2190 @div_self _ _ b h] using (div_sub_div_same b a b).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_mul_sub_mul_one_div_eq_one_div_add_one_div (ha : a \u2260 0) (hb : b \u2260 0) :\n    1 / a * (b - a) * (1 / b) = 1 / a - 1 / b := by\n  simpa only [one_div] using (inv_sub_inv' ha hb).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}", "[NeZero (2 : K)]", "[DivisionRing K] {a b c d : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : DivisionSemiring K\ninst\u271d\u00b9 : NeZero 2\ninst\u271d : DivisionRing K\na b : K\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 1 / a * (b - a) * (1 / b) = 1 / a - 1 / b"}, {"line": "simpa only [one_div] using (inv_sub_inv' ha hb).symm", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Commute.div_sub_div (hbc : Commute b c) (hbd : Commute b d) (hb : b \u2260 0)\n    (hd : d \u2260 0) : a / b - c / d = (a * d - b * c) / (b * d) := by\n  simpa only [mul_neg, neg_div, \u2190 sub_eq_add_neg] using hbc.neg_right.div_add_div hbd hb hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}", "[NeZero (2 : K)]", "[DivisionRing K] {a b c d : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b2 : DivisionSemiring K\ninst\u271d\u00b9 : NeZero 2\ninst\u271d : DivisionRing K\na b c d : K\nhbc : Commute b c\nhbd : Commute b d\nhb : b \u2260 0\nhd : d \u2260 0\n\u22a2 a / b - c / d = (a * d - b * c) / (b * d)"}, {"line": "simpa only [mul_neg, neg_div, \u2190 sub_eq_add_neg] using hbc.neg_right.div_add_div hbd hb hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_div' {a b c : K} (hc : c \u2260 0) : b - a / c = (b * c - a) / c := by\n  simpa using div_sub_div b a one_ne_zero hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}", "[NeZero (2 : K)]", "[DivisionRing K] {a b c d : K}", "[NeZero (2 : K)]", "[Semifield K] {a b d : K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u2075 : DivisionSemiring K\ninst\u271d\u2074 : NeZero 2\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : NeZero 2\ninst\u271d\u00b9 : Semifield K\ninst\u271d : Field K\na b c : K\nhc : c \u2260 0\n\u22a2 b - a / c = (b * c - a) / c"}, {"line": "simpa using div_sub_div b a one_ne_zero hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_sub' {a b c : K} (hc : c \u2260 0) : a / c - b = (a - c * b) / c := by\n  simpa using div_sub_div a b hc one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Basic.lean", "context": {"open": ["Function OrderDual Set"], "variables": ["{K L : Type*}", "[DivisionSemiring K] {a b c d : K}", "[NeZero (2 : K)]", "[DivisionRing K] {a b c d : K}", "[NeZero (2 : K)]", "[Semifield K] {a b d : K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u2075 : DivisionSemiring K\ninst\u271d\u2074 : NeZero 2\ninst\u271d\u00b3 : DivisionRing K\ninst\u271d\u00b2 : NeZero 2\ninst\u271d\u00b9 : Semifield K\ninst\u271d : Field K\na b c : K\nhc : c \u2260 0\n\u22a2 a / c - b = (a - c * b) / c"}, {"line": "simpa using div_sub_div a b hc one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.const_inv_smul\u2080 [AddCommMonoid \u03b1] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Periodic f c) (a : \u03b3) : Periodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c) := by\n  simpa only [inv_inv] using h.const_smul\u2080 a\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : DivisionSemiring \u03b3\ninst\u271d : Module \u03b3 \u03b1\nh : sorry\na : \u03b3\n\u22a2 sorry"}, {"line": "simpa only [inv_inv] using h.const_smul\u2080 a\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.mul_const' [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x * a)) (c / a) := by simpa only [div_eq_mul_inv] using h.mul_const a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : DivisionSemiring \u03b1\nh : sorry\na : \u03b1\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using h.mul_const a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Periodic.div_const [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x / a)) (c * a) := by simpa only [div_eq_mul_inv] using h.mul_const_inv a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_4\nPeriodic : x\u271d\ninst\u271d : DivisionSemiring \u03b1\nh : sorry\na : \u03b1\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using h.mul_const_inv a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.add_nat_mul_eq [NonAssocSemiring \u03b1] [Ring \u03b2] (h : Antiperiodic f c) (n : \u2115) :\n    f (x + n * c) = (-1) ^ n * f x := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.add_nsmul_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : NonAssocSemiring \u03b1\ninst\u271d : Ring \u03b2\nh : sorry\nn : \u2115\n\u22a2 f (x + \u2191n * c) = (-1) ^ n * f x"}, {"line": "simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.add_nsmul_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.sub_nat_mul_eq [NonAssocRing \u03b1] [Ring \u03b2] (h : Antiperiodic f c) (n : \u2115) :\n    f (x - n * c) = (-1) ^ n * f x := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.sub_nsmul_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : NonAssocRing \u03b1\ninst\u271d : Ring \u03b2\nh : sorry\nn : \u2115\n\u22a2 f (x - \u2191n * c) = (-1) ^ n * f x"}, {"line": "simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.sub_nsmul_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.nat_mul_sub_eq [NonAssocRing \u03b1] [Ring \u03b2] (h : Antiperiodic f c) (n : \u2115) :\n    f (n * c - x) = (-1) ^ n * f (-x) := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.nsmul_sub_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nc x : \u03b1\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : NonAssocRing \u03b1\ninst\u271d : Ring \u03b2\nh : sorry\nn : \u2115\n\u22a2 f (\u2191n * c - x) = (-1) ^ n * f (-x)"}, {"line": "simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.nsmul_sub_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.const_inv_smul\u2080 [AddMonoid \u03b1] [Neg \u03b2] [GroupWithZero \u03b3] [DistribMulAction \u03b3 \u03b1]\n    (h : Antiperiodic f c) {a : \u03b3} (ha : a \u2260 0) : Antiperiodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c) := by\n  simpa only [inv_inv] using h.const_smul\u2080 (inv_ne_zero ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b3 : AddMonoid \u03b1\ninst\u271d\u00b2 : Neg \u03b2\ninst\u271d\u00b9 : GroupWithZero \u03b3\ninst\u271d : DistribMulAction \u03b3 \u03b1\nh : sorry\na : \u03b3\nha : a \u2260 0\n\u22a2 sorry"}, {"line": "simpa only [inv_inv] using h.const_smul\u2080 (inv_ne_zero ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.mul_const' [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x * a)) (c / a) := by\n  simpa only [div_eq_mul_inv] using h.mul_const ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : DivisionSemiring \u03b1\ninst\u271d : Neg \u03b2\nh : sorry\na : \u03b1\nha : a \u2260 0\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using h.mul_const ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Antiperiodic.div_inv [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x / a)) (c * a) := by\n  simpa only [div_eq_mul_inv] using h.mul_const_inv ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Periodic.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {f g : \u03b1 \u2192 \u03b2} {c c\u2081 c\u2082 x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_4\nAntiperiodic : x\u271d\ninst\u271d\u00b9 : DivisionSemiring \u03b1\ninst\u271d : Neg \u03b2\nh : sorry\na : \u03b1\nha : a \u2260 0\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using h.mul_const_inv ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnratCast_mem (s : S) (q : \u211a\u22650) : (q : K) \u2208 s := by\n  simpa only [NNRat.cast_def] using div_mem (natCast_mem s q.num) (natCast_mem s q.den)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Defs.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(S : Type*) [SetLike S K] [h : SubfieldClass S K]", "{S} {x : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : DivisionRing K\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\nq : \u211a\u22650\n\u22a2 \u2191q \u2208 s"}, {"line": "simpa only [NNRat.cast_def] using div_mem (natCast_mem s q.num) (natCast_mem s q.den)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ratCast_mem (s : S) (q : \u211a) : (q : K) \u2208 s := by\n  simpa only [Rat.cast_def] using div_mem (intCast_mem s q.num) (natCast_mem s q.den)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Defs.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(S : Type*) [SetLike S K] [h : SubfieldClass S K]", "{S} {x : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : DivisionRing K\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\ns : S\nq : \u211a\n\u22a2 \u2191q \u2208 s"}, {"line": "simpa only [Rat.cast_def] using div_mem (intCast_mem s q.num) (natCast_mem s q.den)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnqsmul_mem (s : S) (q : \u211a\u22650) (hx : x \u2208 s) : q \u2022 x \u2208 s := by\n  simpa only [NNRat.smul_def] using mul_mem (nnratCast_mem _ _) hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Defs.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(S : Type*) [SetLike S K] [h : SubfieldClass S K]", "{S} {x : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : DivisionRing K\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\nx : K\ns : S\nq : \u211a\u22650\nhx : x \u2208 s\n\u22a2 q \u2022 x \u2208 s"}, {"line": "simpa only [NNRat.smul_def] using mul_mem (nnratCast_mem _ _) hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma qsmul_mem (s : S) (q : \u211a) (hx : x \u2208 s) : q \u2022 x \u2208 s := by\n  simpa only [Rat.smul_def] using mul_mem (ratCast_mem _ _) hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Defs.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(S : Type*) [SetLike S K] [h : SubfieldClass S K]", "{S} {x : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : DivisionRing K\nS : Type u_1\ninst\u271d : SetLike S K\nh : SubfieldClass S K\nx : K\ns : S\nq : \u211a\nhx : x \u2208 s\n\u22a2 q \u2022 x \u2208 s"}, {"line": "simpa only [Rat.smul_def] using mul_mem (ratCast_mem _ _) hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_mem {x : K} (hx : x \u2208 s) (n : \u2124) : x ^ n \u2208 s := by\n  cases n\n  \u00b7 simpa using s.pow_mem hx _\n  \u00b7 simpa [pow_succ'] using s.inv_mem (s.mul_mem hx (s.pow_mem hx _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Defs.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(S : Type*) [SetLike S K] [h : SubfieldClass S K]", "{S} {x : K}", "(S)", "(s t : Subfield K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : DivisionRing K\ns : Subfield K\nx : K\nhx : x \u2208 s\nn : \u2124\n\u22a2 x ^ n \u2208 s"}, {"line": "cases n", "tactic_state": "case ofNat\nK : Type u\ninst\u271d : DivisionRing K\ns : Subfield K\nx : K\nhx : x \u2208 s\na\u271d : \u2115\n\u22a2 x ^ Int.ofNat a\u271d \u2208 s\n---\ncase negSucc\nK : Type u\ninst\u271d : DivisionRing K\ns : Subfield K\nx : K\nhx : x \u2208 s\na\u271d : \u2115\n\u22a2 x ^ Int.negSucc a\u271d \u2208 s"}, {"line": "\u00b7 simpa using s.pow_mem hx _", "tactic_state": "case negSucc\nK : Type u\ninst\u271d : DivisionRing K\ns : Subfield K\nx : K\nhx : x \u2208 s\na\u271d : \u2115\n\u22a2 x ^ Int.negSucc a\u271d \u2208 s"}, {"line": "\u00b7 simpa [pow_succ'] using s.inv_mem (s.mul_mem hx (s.pow_mem hx _))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_fieldRange : f.fieldRange.map g = (g.comp f).fieldRange := by\n  simpa only [fieldRange_eq_map] using (\u22a4 : Subfield K).map_map g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Field/Subfield/Basic.lean", "context": {"open": [], "variables": ["{K : Type u} {L : Type v} {M : Type w}", "[DivisionRing K] [DivisionRing L] [DivisionRing M]", "(s t : Subfield K)", "(f : K \u2192+* L)", "(g : L \u2192+* M) (f : K \u2192+* L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b2 : DivisionRing K\ninst\u271d\u00b9 : DivisionRing L\ninst\u271d : DivisionRing M\ng : L \u2192+* M\nf : K \u2192+* L\n\u22a2 Subfield.map g f.fieldRange = (g.comp f).fieldRange"}, {"line": "simpa only [fieldRange_eq_map] using (\u22a4 : Subfield K).map_map g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finsupp.toFreeAbelianGroup_comp_toFinsupp :\n    toFreeAbelianGroup.comp toFinsupp = AddMonoidHom.id (FreeAbelianGroup X) := by\n  ext\n  rw [toFreeAbelianGroup]\n  rw [toFinsupp]\n  rw [AddMonoidHom.comp_apply]\n  rw [lift.of]\n  rw [liftAddHom_apply_single]\n  rw [AddMonoidHom.flip_apply]\n  rw [smulAddHom_apply]\n  rw [one_smul]\n  rw [AddMonoidHom.id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAbelianGroup/Finsupp.lean", "context": {"open": ["Finsupp FreeAbelianGroup"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u22a2 toFreeAbelianGroup.comp toFinsupp = AddMonoidHom.id (FreeAbelianGroup X)"}, {"line": "ext", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 (toFreeAbelianGroup.comp toFinsupp) (of x\u271d) = (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [toFreeAbelianGroup]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 ((liftAddHom fun x => (smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x)).comp toFinsupp) (of x\u271d) =\n    (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [toFinsupp]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 ((liftAddHom fun x => (smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x)).comp\n        (FreeAbelianGroup.lift fun x => fun\u2080 | x => 1))\n      (of x\u271d) =\n    (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [AddMonoidHom.comp_apply]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 (liftAddHom fun x => (smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x))\n      ((FreeAbelianGroup.lift fun x => fun\u2080 | x => 1) (of x\u271d)) =\n    (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [lift.of]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 ((liftAddHom fun x => (smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x)) fun\u2080 | x\u271d => 1) =\n    (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [liftAddHom_apply_single]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 ((smulAddHom \u2124 (FreeAbelianGroup X)).flip (of x\u271d)) 1 = (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [AddMonoidHom.flip_apply]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 ((smulAddHom \u2124 (FreeAbelianGroup X)) 1) (of x\u271d) = (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [smulAddHom_apply]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 1 \u2022 of x\u271d = (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [one_smul]", "tactic_state": "case H\nX : Type u_1\nx\u271d : X\n\u22a2 of x\u271d = (AddMonoidHom.id (FreeAbelianGroup X)) (of x\u271d)"}, {"line": "rw [AddMonoidHom.id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finsupp.toFreeAbelianGroup_toFinsupp {X} (x : FreeAbelianGroup X) :\n    Finsupp.toFreeAbelianGroup (FreeAbelianGroup.toFinsupp x) = x := by\n  rw [\u2190 AddMonoidHom.comp_apply]\n  rw [Finsupp.toFreeAbelianGroup_comp_toFinsupp]\n  rw [AddMonoidHom.id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAbelianGroup/Finsupp.lean", "context": {"open": ["Finsupp FreeAbelianGroup"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nx : FreeAbelianGroup X\n\u22a2 toFreeAbelianGroup (toFinsupp x) = x"}, {"line": "rw [\u2190 AddMonoidHom.comp_apply]", "tactic_state": "X : Type u_2\nx : FreeAbelianGroup X\n\u22a2 (toFreeAbelianGroup.comp toFinsupp) x = x"}, {"line": "rw [Finsupp.toFreeAbelianGroup_comp_toFinsupp]", "tactic_state": "X : Type u_2\nx : FreeAbelianGroup X\n\u22a2 (AddMonoidHom.id (FreeAbelianGroup X)) x = x"}, {"line": "rw [AddMonoidHom.id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinsupp_of (x : X) : toFinsupp (of x) = Finsupp.single x 1 := by\n  simp only [toFinsupp]\n  simp only [lift.of]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAbelianGroup/Finsupp.lean", "context": {"open": ["Finsupp FreeAbelianGroup", "Finsupp"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx : X\n\u22a2 toFinsupp (of x) = fun\u2080 | x => 1"}, {"line": "simp only [toFinsupp]", "tactic_state": "X : Type u_1\nx : X\n\u22a2 (FreeAbelianGroup.lift fun x => fun\u2080 | x => 1) (of x) = fun\u2080 | x => 1"}, {"line": "simp only [lift.of]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinsupp_toFreeAbelianGroup (f : X \u2192\u2080 \u2124) :\n    FreeAbelianGroup.toFinsupp (Finsupp.toFreeAbelianGroup f) = f := by\n  rw [\u2190 AddMonoidHom.comp_apply]\n  rw [toFinsupp_comp_toFreeAbelianGroup]\n  rw [AddMonoidHom.id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAbelianGroup/Finsupp.lean", "context": {"open": ["Finsupp FreeAbelianGroup", "Finsupp"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nf : X \u2192\u2080 \u2124\n\u22a2 toFinsupp (toFreeAbelianGroup f) = f"}, {"line": "rw [\u2190 AddMonoidHom.comp_apply]", "tactic_state": "X : Type u_1\nf : X \u2192\u2080 \u2124\n\u22a2 (toFinsupp.comp toFreeAbelianGroup) f = f"}, {"line": "rw [toFinsupp_comp_toFreeAbelianGroup]", "tactic_state": "X : Type u_1\nf : X \u2192\u2080 \u2124\n\u22a2 (AddMonoidHom.id (X \u2192\u2080 \u2124)) f = f"}, {"line": "rw [AddMonoidHom.id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_nsmul (k : \u2115) (h : k \u2260 0) (a : FreeAbelianGroup X) :\n    support (k \u2022 a) = support a := by\n  apply support_zsmul k _ a\n  exact mod_cast h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAbelianGroup/Finsupp.lean", "context": {"open": ["Finsupp FreeAbelianGroup", "Finsupp"], "variables": ["{X : Type*}", "(X)", "{X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nk : \u2115\nh : k \u2260 0\na : FreeAbelianGroup X\n\u22a2 (k \u2022 a).support = a.support"}, {"line": "apply support_zsmul k _ a", "tactic_state": "X : Type u_1\nk : \u2115\nh : k \u2260 0\na : FreeAbelianGroup X\n\u22a2 \u2191k \u2260 0"}, {"line": "exact mod_cast h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_max_lift :\n    #(FreeAlgebra R X) \u2264 Cardinal.lift.{v} #R \u2294 Cardinal.lift.{u} #X \u2294 \u2135\u2080 := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 exact (cardinalMk_eq_one R X).trans_le (le_max_of_le_right one_le_aleph0)\n  cases isEmpty_or_nonempty X\n  \u00b7 exact (cardinalMk_eq_lift R X).trans_le (le_max_of_le_left <| le_max_left _ _)\n  \u00b7 exact (cardinalMk_eq_max_lift R X).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAlgebra/Cardinality.lean", "context": {"open": ["Cardinal"], "variables": ["(R : Type u) [CommSemiring R]", "(X : Type v)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nX : Type v\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d : Subsingleton R\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0\n---\ncase inr\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d : Nontrivial R\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0"}, {"line": "\u00b7 exact (cardinalMk_eq_one R X).trans_le (le_max_of_le_right one_le_aleph0)", "tactic_state": "case inr\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d : Nontrivial R\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0"}, {"line": "cases isEmpty_or_nonempty X", "tactic_state": "case inr.inl\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d\u00b9 : Nontrivial R\nh\u271d : IsEmpty X\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0\n---\ncase inr.inr\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d\u00b9 : Nontrivial R\nh\u271d : Nonempty X\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0"}, {"line": "\u00b7 exact (cardinalMk_eq_lift R X).trans_le (le_max_of_le_left <| le_max_left _ _)", "tactic_state": "case inr.inr\nR : Type u\ninst\u271d : CommSemiring R\nX : Type v\nh\u271d\u00b9 : Nontrivial R\nh\u271d : Nonempty X\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (lift.{v, u} (mk R)) (lift.{u, v} (mk X))) aleph0"}, {"line": "\u00b7 exact (cardinalMk_eq_max_lift R X).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_max : #(FreeAlgebra R X) \u2264 #R \u2294 #X \u2294 \u2135\u2080 := by\n  simpa using cardinalMk_le_max_lift R X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeAlgebra/Cardinality.lean", "context": {"open": ["Cardinal"], "variables": ["(R : Type u) [CommSemiring R]", "(X : Type v)", "(X : Type u)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nX : Type u\n\u22a2 mk (FreeAlgebra R X) \u2264 max (max (mk R) (mk X)) aleph0"}, {"line": "simpa using cardinalMk_le_max_lift R X", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_prod (xs : List (FreeMonoid \u03b1)) : toList xs.prod = (xs.map toList).flatten := by\n  induction xs <;> simp [*, List.flatten]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {M : Type*} [Monoid M] {N : Type*} [Monoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b1\u271d : Type u_6\ntoList : FreeMonoid \u03b1 \u2192 List \u03b1\u271d\nxs : List (FreeMonoid \u03b1)\n\u22a2 toList xs.prod = (List.map toList xs).flatten"}, {"line": "induction xs <;> simp [*, List.flatten]", "tactic_state": "case nil\n\u03b1 : Type u_1\n\u03b1\u271d : Type u_6\ntoList : FreeMonoid \u03b1 \u2192 List \u03b1\u271d\n\u22a2 toList 1 = []\n---\ncase cons\n\u03b1 : Type u_1\n\u03b1\u271d : Type u_6\ntoList : FreeMonoid \u03b1 \u2192 List \u03b1\u271d\nhead\u271d : FreeMonoid \u03b1\ntail\u271d : List (FreeMonoid \u03b1)\ntail_ih\u271d : toList tail\u271d.prod = (List.map toList tail\u271d).flatten\n\u22a2 toList (head\u271d * tail\u271d.prod) = toList head\u271d ++ (List.map toList tail\u271d).flatten"}]}
{"declaration": "theorem map_symm_apply_map_eq {x : FreeMonoid \u03b1} (e : \u03b1 \u2243 \u03b2) :\n    (map \u21d1e.symm) ((map \u21d1e) x) = x := by simp [map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {M : Type*} [Monoid M] {N : Type*} [Monoid N]", "{a : FreeMonoid \u03b1}", "{m : \u03b1}", "{f : \u03b1 \u2192 \u03b2} {a b : FreeMonoid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_6\nmap : x\u271d\nx : FreeMonoid \u03b1\ne : \u03b1 \u2243 \u03b2\n\u22a2 sorry = x"}, {"line": "simp [map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_6\nmap : x\u271d\nx : FreeMonoid \u03b1\ne : \u03b1 \u2243 \u03b2\n\u22a2 sorry () = x"}]}
{"declaration": "theorem map_apply_map_symm_eq {x : FreeMonoid \u03b2} (e : \u03b1 \u2243 \u03b2) :\n    (map \u21d1e) ((map \u21d1e.symm) x) = x := by simp [map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {M : Type*} [Monoid M] {N : Type*} [Monoid N]", "{a : FreeMonoid \u03b1}", "{m : \u03b1}", "{f : \u03b1 \u2192 \u03b2} {a b : FreeMonoid \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_6\nmap : x\u271d\nx : FreeMonoid \u03b2\ne : \u03b1 \u2243 \u03b2\n\u22a2 sorry = x"}, {"line": "simp [map_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_6\nmap : x\u271d\nx : FreeMonoid \u03b2\ne : \u03b1 \u2243 \u03b2\n\u22a2 sorry () = x"}]}
{"declaration": "theorem count_of [DecidableEq \u03b1] (x y : \u03b1) :\n    count x (of y) = Pi.mulSingle (f := fun _ => Multiplicative \u2115) x (Multiplicative.ofAdd 1) y :=\n  by simp only [count, eq_comm, countP_of, ofAdd_zero, Pi.mulSingle_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/FreeMonoid/Count.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 sorry = Pi.mulSingle x (Multiplicative.ofAdd 1) y"}, {"line": "simp only [count, eq_comm, countP_of, ofAdd_zero, Pi.mulSingle_apply]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 (if y = x then Multiplicative.ofAdd 1 else 1) = sorry"}]}
{"declaration": "theorem lcm_insert [DecidableEq \u03b2] {b : \u03b2} :\n    (insert b s : Finset \u03b2).lcm f = GCDMonoid.lcm (f b) (s.lcm f) := by\n  by_cases h : b \u2208 s\n  \u00b7 rw [insert_eq_of_mem h,\n      (lcm_eq_right_iff (f b) (s.lcm f) (Multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)]\n  apply fold_insert h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)"}, {"line": "by_cases h : b \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2208 s\n\u22a2 (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)\n---\ncase neg\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2209 s\n\u22a2 (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)"}, {"line": "\u00b7 rw [insert_eq_of_mem h,\n      (lcm_eq_right_iff (f b) (s.lcm f) (Multiset.normalize_lcm (s.1.map f))).2 (dvd_lcm h)]", "tactic_state": "case neg\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2209 s\n\u22a2 (insert b s).lcm f = GCDMonoid.lcm (f b) (s.lcm f)"}, {"line": "apply fold_insert h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lcm_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.lcm f = s\u2082.lcm g := by\n  subst hs\n  exact Finset.fold_congr hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhs : s\u2081 = s\u2082\nhfg : \u2200 a \u2208 s\u2082, f a = g a\n\u22a2 s\u2081.lcm f = s\u2082.lcm g"}, {"line": "subst hs", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns\u2081 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhfg : \u2200 a \u2208 s\u2081, f a = g a\n\u22a2 s\u2081.lcm f = s\u2081.lcm g"}, {"line": "exact Finset.fold_congr hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_insert [DecidableEq \u03b2] {b : \u03b2} :\n    (insert b s : Finset \u03b2).gcd f = GCDMonoid.gcd (f b) (s.gcd f) := by\n  by_cases h : b \u2208 s\n  \u00b7 rw [insert_eq_of_mem h,\n      (gcd_eq_right_iff (f b) (s.gcd f) (Multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)]\n  apply fold_insert h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 (insert b s).gcd f = GCDMonoid.gcd (f b) (s.gcd f)"}, {"line": "by_cases h : b \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2208 s\n\u22a2 (insert b s).gcd f = GCDMonoid.gcd (f b) (s.gcd f)\n---\ncase neg\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2209 s\n\u22a2 (insert b s).gcd f = GCDMonoid.gcd (f b) (s.gcd f)"}, {"line": "\u00b7 rw [insert_eq_of_mem h,\n      (gcd_eq_right_iff (f b) (s.gcd f) (Multiset.normalize_gcd (s.1.map f))).2 (gcd_dvd h)]", "tactic_state": "case neg\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\nh : b \u2209 s\n\u22a2 (insert b s).gcd f = GCDMonoid.gcd (f b) (s.gcd f)"}, {"line": "apply fold_insert h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_congr {f g : \u03b2 \u2192 \u03b1} (hs : s\u2081 = s\u2082) (hfg : \u2200 a \u2208 s\u2082, f a = g a) :\n    s\u2081.gcd f = s\u2082.gcd g := by\n  subst hs\n  exact Finset.fold_congr hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns\u2081 s\u2082 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhs : s\u2081 = s\u2082\nhfg : \u2200 a \u2208 s\u2082, f a = g a\n\u22a2 s\u2081.gcd f = s\u2082.gcd g"}, {"line": "subst hs", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns\u2081 : Finset \u03b2\nf g : \u03b2 \u2192 \u03b1\nhfg : \u2200 a \u2208 s\u2081, f a = g a\n\u22a2 s\u2081.gcd f = s\u2081.gcd g"}, {"line": "exact Finset.fold_congr hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_image [DecidableEq \u03b2] {g : \u03b3 \u2192 \u03b2} (s : Finset \u03b3) :\n    (s.image g).gcd f = s.gcd (f \u2218 g) := by\n  classical induction s using Finset.induction <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b3 : Type u_4\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : DecidableEq \u03b2\ng : \u03b3 \u2192 \u03b2\ns : Finset \u03b3\n\u22a2 (Finset.image g s).gcd f = s.gcd (f \u2218 g)"}, {"line": "classical induction s using Finset.induction <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extract_gcd (f : \u03b2 \u2192 \u03b1) (hs : s.Nonempty) :\n    \u2203 g : \u03b2 \u2192 \u03b1, (\u2200 b \u2208 s, f b = s.gcd f * g b) \u2227 s.gcd g = 1 := by\n  classical\n    by_cases h : \u2200 x \u2208 s, f x = (0 : \u03b1)\n    \u00b7 refine \u27e8fun _ \u21a6 1, fun b hb \u21a6 by rw [h b hb, gcd_eq_zero_iff.2 h, mul_one], ?_\u27e9\n      rw [gcd_eq_gcd_image]\n      rw [image_const hs]\n      rw [gcd_singleton]\n      rw [id]\n      rw [normalize_one]\n    \u00b7 choose g' hg using @gcd_dvd _ _ _ _ s f\n      push_neg at h\n      refine \u27e8fun b \u21a6 if hb : b \u2208 s then g' hb else 0, fun b hb \u21a6 ?_,\n          extract_gcd' f _ h fun b hb \u21a6 ?_\u27e9\n      \u00b7 simp only [hb, hg, dite_true]\n      rw [dif_pos hb]\n      rw [hg hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Finset.lean", "context": {"open": ["Multiset"], "variables": ["{\u03b9 \u03b1 \u03b2 \u03b3 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}", "{s s\u2081 s\u2082 : Finset \u03b2} {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\nhs : s.Nonempty\n\u22a2 \u2203 g, (\u2200 b \u2208 s, f b = s.gcd f * g b) \u2227 s.gcd g = 1"}, {"line": "classical\n    by_cases h : \u2200 x \u2208 s, f x = (0 : \u03b1)\n    \u00b7 refine \u27e8fun _ \u21a6 1, fun b hb \u21a6 by rw [h b hb, gcd_eq_zero_iff.2 h, mul_one], ?_\u27e9\n      rw [gcd_eq_gcd_image]\n      rw [image_const hs]\n      rw [gcd_singleton]\n      rw [id]\n      rw [normalize_one]\n    \u00b7 choose g' hg using @gcd_dvd _ _ _ _ s f\n      push_neg at h\n      refine \u27e8fun b \u21a6 if hb : b \u2208 s then g' hb else 0, fun b hb \u21a6 ?_,\n          extract_gcd' f _ h fun b hb \u21a6 ?_\u27e9\n      \u00b7 simp only [hb, hg, dite_true]\n      rw [dif_pos hb]\n      rw [hg hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalize_coe_units (u : \u03b1\u02e3) : normalize (u : \u03b1) = 1 := by simp [normalize_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\nu : \u03b1\u02e3\n\u22a2 normalize \u2191u = 1"}, {"line": "simp [normalize_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normUnit_mul_normUnit (a : \u03b1) : normUnit (a * normUnit a) = 1 := by\n  nontriviality \u03b1 using Subsingleton.elim a 0\n  obtain rfl | h := eq_or_ne a 0\n  \u00b7 rw [normUnit_zero, zero_mul, normUnit_zero]\n  \u00b7 rw [normUnit_mul h (Units.ne_zero _), normUnit_coe_units, mul_inv_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na : \u03b1\n\u22a2 normUnit (a * \u2191(normUnit a)) = 1"}, {"line": "nontriviality \u03b1 using Subsingleton.elim a 0", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na : \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 normUnit (a * \u2191(normUnit a)) = 1"}, {"line": "obtain rfl | h := eq_or_ne a 0", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na\u271d : Nontrivial \u03b1\n\u22a2 normUnit (sorry * \u2191(normUnit sorry)) = 1\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na : \u03b1\na\u271d : Nontrivial \u03b1\nh : a \u2260 sorry\n\u22a2 normUnit (a * \u2191(normUnit a)) = 1"}, {"line": "\u00b7 rw [normUnit_zero, zero_mul, normUnit_zero]", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\na : \u03b1\na\u271d : Nontrivial \u03b1\nh : a \u2260 sorry\n\u22a2 normUnit (a * \u2191(normUnit a)) = 1"}, {"line": "\u00b7 rw [normUnit_mul h (Units.ne_zero _), normUnit_coe_units, mul_inv_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalize_idem (x : \u03b1) : normalize (normalize x) = normalize x := by simp [normalize_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizationMonoid \u03b1\nx : \u03b1\n\u22a2 normalize (normalize x) = normalize x"}, {"line": "simp [normalize_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_ne_zero_of_left [GCDMonoid \u03b1] {a b : \u03b1} (ha : a \u2260 0) : gcd a b \u2260 0 := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2074 : NormalizationMonoid \u03b1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizationMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\na b : \u03b1\nha : a \u2260 0\n\u22a2 gcd a b \u2260 0"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_ne_zero_of_right [GCDMonoid \u03b1] {a b : \u03b1} (hb : b \u2260 0) : gcd a b \u2260 0 := by\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2074 : NormalizationMonoid \u03b1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizationMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\na b : \u03b1\nhb : b \u2260 0\n\u22a2 gcd a b \u2260 0"}, {"line": "simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_one_left' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd 1 a) 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2074 : NormalizationMonoid \u03b1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizationMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\na : \u03b1\n\u22a2 Associated (gcd 1 a) 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_one_right' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd a 1) 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2074 : NormalizationMonoid \u03b1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizationMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : GCDMonoid \u03b1\na : \u03b1\n\u22a2 Associated (gcd a 1) 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_eq_right_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize b = b) :\n    gcd a b = b \u2194 b \u2223 a := by simpa only [gcd_comm a b] using gcd_eq_left_iff b a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2074 : NormalizationMonoid \u03b1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizationMonoid \u03b1\ninst\u271d\u00b9 : CancelCommMonoidWithZero \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\na b : \u03b1\nh : normalize b = b\n\u22a2 gcd a b = b \u2194 b \u2223 a"}, {"line": "simpa only [gcd_comm a b] using gcd_eq_left_iff b a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lcm_eq_right_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize b = b) :\n    lcm a b = b \u2194 a \u2223 b := by simpa only [lcm_comm b a] using lcm_eq_left_iff b a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "[HasDistribNeg \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u2075 : NormalizationMonoid \u03b1\ninst\u271d\u2074 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b3 : NormalizationMonoid \u03b1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : HasDistribNeg \u03b1\ninst\u271d : NormalizedGCDMonoid \u03b1\na b : \u03b1\nh : normalize b = b\n\u22a2 lcm a b = b \u2194 a \u2223 b"}, {"line": "simpa only [lcm_comm b a] using lcm_eq_left_iff b a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_normUnit {a : G\u2080} (h0 : a \u2260 0) : (\u2191(normUnit a) : G\u2080) = a\u207b\u00b9 := by simp [normUnit, h0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": ["Associates"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "[HasDistribNeg \u03b1]", "[CancelCommMonoidWithZero \u03b1] [Subsingleton \u03b1\u02e3]", "[CommRing \u03b1] [IsDomain \u03b1] [NormalizedGCDMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "(G\u2080 : Type*) [CommGroupWithZero G\u2080] [DecidableEq G\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 : CommGroupWithZero G\u2080\ninst\u271d : DecidableEq G\u2080\na : G\u2080\nh0 : a \u2260 0\n\u22a2 \u2191(normUnit a) = a\u207b\u00b9"}, {"line": "simp [normUnit, h0]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 : CommGroupWithZero G\u2080\ninst\u271d : DecidableEq G\u2080\na : G\u2080\nh0 : a \u2260 0\n\u22a2 \u2191(Units.mk0 a \u22ef)\u207b\u00b9 = a\u207b\u00b9"}]}
{"declaration": "theorem normalize_eq_one {a : G\u2080} (h0 : a \u2260 0) : normalize a = 1 := by simp [normalize_apply, h0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Basic.lean", "context": {"open": ["Associates"], "variables": ["{\u03b1 : Type*}", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1] [NormalizationMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "[HasDistribNeg \u03b1]", "[CancelCommMonoidWithZero \u03b1] [Subsingleton \u03b1\u02e3]", "[CommRing \u03b1] [IsDomain \u03b1] [NormalizedGCDMonoid \u03b1]", "[CancelCommMonoidWithZero \u03b1]", "(G\u2080 : Type*) [CommGroupWithZero G\u2080] [DecidableEq G\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 : CommGroupWithZero G\u2080\ninst\u271d : DecidableEq G\u2080\na : G\u2080\nh0 : a \u2260 0\n\u22a2 normalize a = 1"}, {"line": "simp [normalize_apply, h0]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b9 : CommGroupWithZero G\u2080\ninst\u271d : DecidableEq G\u2080\na : G\u2080\nh0 : a \u2260 0\n\u22a2 a * a\u207b\u00b9 = 1"}]}
{"declaration": "theorem gcd_eq_zero_iff (s : Multiset \u03b1) : s.gcd = 0 \u2194 \u2200 x : \u03b1, x \u2208 s \u2192 x = 0 := by\n  constructor\n  \u00b7 intro h x hx\n    apply eq_zero_of_zero_dvd\n    rw [\u2190 h]\n    apply gcd_dvd hx\n  \u00b7 refine s.induction_on ?_ ?_\n    \u00b7 simp\n    intro a s sgcd h\n    simp [h a (mem_cons_self a s), sgcd fun x hx \u21a6 h x (mem_cons_of_mem hx)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Multiset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 s.gcd = 0 \u2194 \u2200 x \u2208 s, x = 0"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 s.gcd = 0 \u2192 \u2200 x \u2208 s, x = 0\n---\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 (\u2200 x \u2208 s, x = 0) \u2192 s.gcd = 0"}, {"line": "\u00b7 intro h x hx\n    apply eq_zero_of_zero_dvd\n    rw [\u2190 h]\n    apply gcd_dvd hx", "tactic_state": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b9 : NormalizedGCDMonoid \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 (\u2200 x \u2208 s, x = 0) \u2192 s.gcd = 0"}, {"line": "\u00b7 refine s.induction_on ?_ ?_\n    \u00b7 simp\n    intro a s sgcd h\n    simp [h a (mem_cons_self a s), sgcd fun x hx \u21a6 h x (mem_cons_of_mem hx)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extract_gcd (s : Multiset \u03b1) (hs : s \u2260 0) :\n    \u2203 t : Multiset \u03b1, s = t.map (s.gcd * \u00b7) \u2227 t.gcd = 1 := by\n  classical\n    by_cases h : \u2200 x \u2208 s, x = (0 : \u03b1)\n    \u00b7 use replicate (card s) 1\n      rw [map_replicate]\n      rw [eq_replicate]\n      rw [mul_one]\n      rw [s.gcd_eq_zero_iff.2 h]\n      rw [\u2190 nsmul_singleton]\n      rw [\u2190 gcd_dedup]\n      rw [dedup_nsmul (card_pos.2 hs).ne']\n      rw [dedup_singleton]\n      rw [gcd_singleton]\n      exact \u27e8\u27e8rfl, h\u27e9, normalize_one\u27e9\n    \u00b7 choose f hf using @gcd_dvd _ _ _ s\n      push_neg at h\n      refine \u27e8s.pmap @f fun _ \u21a6 id, ?_, extract_gcd' s _ h ?_\u27e9 <;>\n      \u00b7 rw [map_pmap]\n        conv_lhs => rw [\u2190 s.map_id, \u2190 s.pmap_eq_map _ _ fun _ \u21a6 id]\n        congr with (x hx)\n        rw [id]\n        rw [\u2190 hf hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Multiset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : CancelCommMonoidWithZero \u03b1\ninst\u271d\u00b2 : NormalizedGCDMonoid \u03b1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\nhs : s \u2260 0\n\u22a2 \u2203 t, s = Multiset.map (fun x => s.gcd * x) t \u2227 t.gcd = 1"}, {"line": "classical\n    by_cases h : \u2200 x \u2208 s, x = (0 : \u03b1)\n    \u00b7 use replicate (card s) 1\n      rw [map_replicate]\n      rw [eq_replicate]\n      rw [mul_one]\n      rw [s.gcd_eq_zero_iff.2 h]\n      rw [\u2190 nsmul_singleton]\n      rw [\u2190 gcd_dedup]\n      rw [dedup_nsmul (card_pos.2 hs).ne']\n      rw [dedup_singleton]\n      rw [gcd_singleton]\n      exact \u27e8\u27e8rfl, h\u27e9, normalize_one\u27e9\n    \u00b7 choose f hf using @gcd_dvd _ _ _ s\n      push_neg at h\n      refine \u27e8s.pmap @f fun _ \u21a6 id, ?_, extract_gcd' s _ h ?_\u27e9 <;>\n      \u00b7 rw [map_pmap]\n        conv_lhs => rw [\u2190 s.map_id, \u2190 s.pmap_eq_map _ _ fun _ \u21a6 id]\n        congr with (x hx)\n        rw [id]\n        rw [\u2190 hf hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalize_of_nonpos {z : \u2124} (h : z \u2264 0) : normalize z = -z := by\n  obtain rfl | h := h.eq_or_lt\n  \u00b7 simp\n  \u00b7 rw [normalize_apply, normUnit_eq, if_neg (not_le_of_gt h), Units.val_neg, Units.val_one,\n      mul_neg_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/GCDMonoid/Nat.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\nh : z \u2264 0\n\u22a2 normalize z = -z"}, {"line": "obtain rfl | h := h.eq_or_lt", "tactic_state": "case inl\nh : 0 \u2264 0\n\u22a2 normalize 0 = -0\n---\ncase inr\nz : \u2124\nh\u271d : z \u2264 0\nh : z < 0\n\u22a2 normalize z = -z"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nz : \u2124\nh\u271d : z \u2264 0\nh : z < 0\n\u22a2 normalize z = -z"}, {"line": "\u00b7 rw [normalize_apply, normUnit_eq, if_neg (not_le_of_gt h), Units.val_neg, Units.val_one,\n      mul_neg_one]", "tactic_state": "No Goals!"}]}
