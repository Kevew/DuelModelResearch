{"declaration": "lemma iteratedFDerivWithin_comp_add_left (n : \u2115) (a : E) (x : E) :\n    iteratedFDerivWithin \ud835\udd5c n (fun z \u21a6 f (a + z)) s x =\n      iteratedFDerivWithin \ud835\udd5c n f (a +\u1d65 s) (a + x) := by\n  simp [iteratedFDerivWithin_comp_add_left']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\ns : Set E\nn : \u2115\na x : E\n\u22a2 sorry = sorry"}, {"line": "simp [iteratedFDerivWithin_comp_add_left']", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\ns : Set E\nn : \u2115\na x : E\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma iteratedFDerivWithin_comp_add_right' (n : \u2115) (a : E) :\n    iteratedFDerivWithin \ud835\udd5c n (fun z \u21a6 f (z + a)) s =\n      fun x \u21a6 iteratedFDerivWithin \ud835\udd5c n f (a +\u1d65 s) (x + a) := by\n  simpa [add_comm a] using iteratedFDerivWithin_comp_add_left' n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d : NormedAddCommGroup E\nM\u2082\u271d : Type u_1\nf : E \u2192 M\u2082\u271d\ns : Set E\nn : \u2115\na : E\n\u22a2 iteratedFDerivWithin \ud835\udd5c n (fun z => f (z + a)) s = fun x => sorry"}, {"line": "simpa [add_comm a] using iteratedFDerivWithin_comp_add_left' n a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedFDerivWithin_comp_add_right (n : \u2115) (a : E) (x : E) :\n    iteratedFDerivWithin \ud835\udd5c n (fun z \u21a6 f (z + a)) s x =\n      iteratedFDerivWithin \ud835\udd5c n f (a +\u1d65 s) (x + a) := by\n  simp [iteratedFDerivWithin_comp_add_right']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\ns : Set E\nn : \u2115\na x : E\n\u22a2 sorry = sorry"}, {"line": "simp [iteratedFDerivWithin_comp_add_right']", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\ns : Set E\nn : \u2115\na x : E\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma iteratedFDerivWithin_comp_sub (n : \u2115) (a : E) :\n    iteratedFDerivWithin \ud835\udd5c n (fun z \u21a6 f (z - a)) s x =\n      iteratedFDerivWithin \ud835\udd5c n f (-a +\u1d65 s) (x - a) := by\n  simp [iteratedFDerivWithin_comp_sub']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d : NormedAddCommGroup E\nM\u2082\u271d : Type u_1\nf : E \u2192 M\u2082\u271d\ns : Set E\nx : E\nn : \u2115\na : E\n\u22a2 iteratedFDerivWithin \ud835\udd5c n (fun z => f (z - a)) s x = sorry"}, {"line": "simp [iteratedFDerivWithin_comp_sub']", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d : NormedAddCommGroup E\nM\u2082\u271d : Type u_1\nf : E \u2192 M\u2082\u271d\ns : Set E\nx : E\nn : \u2115\na : E\n\u22a2 iteratedFDerivWithin \ud835\udd5c n (fun z => f (z - a)) s x = sorry ()"}]}
{"declaration": "lemma iteratedFDeriv_comp_add_left' (n : \u2115) (a : E) :\n    iteratedFDeriv \ud835\udd5c n (fun z \u21a6 f (a + z)) = fun x \u21a6 iteratedFDeriv \ud835\udd5c n f (a + x) := by\n  simpa [\u2190 iteratedFDerivWithin_univ] using iteratedFDerivWithin_comp_add_left' n a (s := univ)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d : NormedAddCommGroup E\nM\u2082\u271d : Type u_1\nf : E \u2192 M\u2082\u271d\nn : \u2115\na : E\n\u22a2 (iteratedFDeriv \ud835\udd5c n fun z => f (a + z)) = fun x => sorry"}, {"line": "simpa [\u2190 iteratedFDerivWithin_univ] using iteratedFDerivWithin_comp_add_left' n a (s := univ)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedFDeriv_comp_add_left (n : \u2115) (a : E) (x : E) :\n    iteratedFDeriv \ud835\udd5c n (fun z \u21a6 f (a + z)) x = iteratedFDeriv \ud835\udd5c n f (a + x) := by\n  simp [iteratedFDeriv_comp_add_left']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry = sorry"}, {"line": "simp [iteratedFDeriv_comp_add_left']", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma iteratedFDeriv_comp_add_right' (n : \u2115) (a : E) :\n    iteratedFDeriv \ud835\udd5c n (fun z \u21a6 f (z + a)) = fun x \u21a6 iteratedFDeriv \ud835\udd5c n f (x + a) := by\n  simpa [add_comm a] using iteratedFDeriv_comp_add_left' n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type uE\ninst\u271d : NormedAddCommGroup E\nM\u2082\u271d : Type u_1\nf : E \u2192 M\u2082\u271d\nn : \u2115\na : E\n\u22a2 (iteratedFDeriv \ud835\udd5c n fun z => f (z + a)) = fun x => sorry"}, {"line": "simpa [add_comm a] using iteratedFDeriv_comp_add_left' n a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedFDeriv_comp_add_right (n : \u2115) (a : E) (x : E) :\n    iteratedFDeriv \ud835\udd5c n (fun z \u21a6 f (z + a)) x = iteratedFDeriv \ud835\udd5c n f (x + a) := by\n  simp [iteratedFDeriv_comp_add_right']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry = sorry"}, {"line": "simp [iteratedFDeriv_comp_add_right']", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma iteratedFDeriv_comp_sub (n : \u2115) (a : E) (x : E) :\n    iteratedFDeriv \ud835\udd5c n (fun z \u21a6 f (z - a)) x = iteratedFDeriv \ud835\udd5c n f (x - a) := by\n  simp [iteratedFDeriv_comp_sub']", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FTaylorSeries.lean", "context": {"open": ["ENat NNReal Topology Filter Set Fin Filter Function", "scoped ContDiff Pointwise"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type uE} [NormedAddCommGroup E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry = sorry"}, {"line": "simp [iteratedFDeriv_comp_sub']", "tactic_state": "E : Type uE\ninst\u271d : NormedAddCommGroup E\nx\u271d : Type u_1\nf : E \u2192 x\u271d\nn : \u2115\na x : E\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma length_le : c.length \u2264 n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ c.parts_strictMono.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\n\u22a2 c.length \u2264 n"}, {"line": "simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ c.parts_strictMono.injective", "tactic_state": "No Goals!"}]}
{"declaration": "lemma partSize_le (m : Fin c.length) : c.partSize m \u2264 n := by\n  simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ (c.emb_strictMono m).injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\nm : Fin c.length\n\u22a2 c.partSize m \u2264 n"}, {"line": "simpa only [Fintype.card_fin] using Fintype.card_le_of_injective _ (c.emb_strictMono m).injective", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_inverse {n : \u2115} (c : OrderedFinpartition n) (j : Fin n) :\n    \u2203 p : \u03a3 m, Fin (c.partSize m), c.emb p.1 p.2 = j := by\n  rcases c.cover j with \u27e8m, r, hmr\u27e9\n  exact \u27e8\u27e8m, r\u27e9, hmr\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\nj : Fin n\n\u22a2 \u2203 p, c.emb p.fst p.snd = j"}, {"line": "rcases c.cover j with \u27e8m, r, hmr\u27e9", "tactic_state": "case intro.intro\nn : \u2115\nc : OrderedFinpartition n\nj : Fin n\nm : Fin c.length\nr : Fin (c.partSize m)\nhmr : c.emb m r = j\n\u22a2 \u2203 p, c.emb p.fst p.snd = j"}, {"line": "exact \u27e8\u27e8m, r\u27e9, hmr\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma emb_injective : Injective (fun (p : \u03a3 m, Fin (c.partSize m)) \u21a6 c.emb p.1 p.2) := by\n  rintro \u27e8m, r\u27e9 \u27e8m', r'\u27e9 (h : c.emb m r = c.emb m' r')\n  have : m = m' := by\n    contrapose! h\n    have A : Disjoint (range (c.emb m)) (range (c.emb m')) :=\n      c.disjoint (mem_univ m) (mem_univ m') h\n    apply disjoint_iff_forall_ne.1 A (mem_range_self r) (mem_range_self r')\n  subst this\n  simpa using (c.emb_strictMono m).injective h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\n\u22a2 Injective fun p => c.emb p.fst p.snd"}, {"line": "rintro \u27e8m, r\u27e9 \u27e8m', r'\u27e9 (h : c.emb m r = c.emb m' r')", "tactic_state": "case mk.mk\nn : \u2115\nc : OrderedFinpartition n\nm : Fin c.length\nr : Fin (c.partSize m)\nm' : Fin c.length\nr' : Fin (c.partSize m')\nh : c.emb m r = c.emb m' r'\n\u22a2 \u27e8m, r\u27e9 = \u27e8m', r'\u27e9"}, {"line": "have : m = m' := by\n    contrapose! h\n    have A : Disjoint (range (c.emb m)) (range (c.emb m')) :=\n      c.disjoint (mem_univ m) (mem_univ m') h\n    apply disjoint_iff_forall_ne.1 A (mem_range_self r) (mem_range_self r')", "tactic_state": "case mk.mk\nn : \u2115\nc : OrderedFinpartition n\nm : Fin c.length\nr : Fin (c.partSize m)\nm' : Fin c.length\nr' : Fin (c.partSize m')\nh : c.emb m r = c.emb m' r'\nthis : m = m'\n\u22a2 \u27e8m, r\u27e9 = \u27e8m', r'\u27e9"}, {"line": "subst this", "tactic_state": "case mk.mk\nn : \u2115\nc : OrderedFinpartition n\nm : Fin c.length\nr r' : Fin (c.partSize m)\nh : c.emb m r = c.emb m r'\n\u22a2 \u27e8m, r\u27e9 = \u27e8m, r'\u27e9"}, {"line": "simpa using (c.emb_strictMono m).injective h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma partSize_eq_one_of_range_emb_eq_singleton\n    (c : OrderedFinpartition n) {i : Fin c.length} {j : Fin n}\n    (hc : range (c.emb i) = {j}) :\n    c.partSize i = 1 := by\n  have : Fintype.card (range (c.emb i)) = Fintype.card (Fin (c.partSize i)) :=\n    card_range_of_injective (c.emb_strictMono i).injective\n  simpa [hc] using this.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\nj : Fin n\nhc : range (c.emb i) = {j}\n\u22a2 c.partSize i = 1"}, {"line": "have : Fintype.card (range (c.emb i)) = Fintype.card (Fin (c.partSize i)) :=\n    card_range_of_injective (c.emb_strictMono i).injective", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\nj : Fin n\nhc : range (c.emb i) = {j}\nthis : Fintype.card \u2191(range (c.emb i)) = Fintype.card (Fin (c.partSize i))\n\u22a2 c.partSize i = 1"}, {"line": "simpa [hc] using this.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma index_extendMiddle_zero (c : OrderedFinpartition n) (i : Fin c.length) :\n    (c.extendMiddle i).index 0 = i := by\n  have : (c.extendMiddle i).emb i 0 = 0 := by simp [extendMiddle]\n  conv_rhs at this => rw [\u2190 (c.extendMiddle i).emb_invEmbedding 0]\n  contrapose! this\n  exact (c.extendMiddle i).emb_ne_emb_of_ne (Ne.symm this)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/FaaDiBruno.lean", "context": {"open": ["Set Fin Filter Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{n : \u2115} (c : OrderedFinpartition n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\n\u22a2 (c.extendMiddle i).index 0 = i"}, {"line": "have : (c.extendMiddle i).emb i 0 = 0 := by simp [extendMiddle]", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\nthis : (c.extendMiddle i).emb i sorry = 0\n\u22a2 (c.extendMiddle i).index 0 = i"}, {"line": "conv_rhs at this => rw [\u2190 (c.extendMiddle i).emb_invEmbedding 0]", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\nthis :\n  (c.extendMiddle i).emb i sorry =\n    (c.extendMiddle i).emb ((c.extendMiddle i).index 0) ((c.extendMiddle i).invEmbedding 0)\n\u22a2 (c.extendMiddle i).index 0 = i"}, {"line": "contrapose! this", "tactic_state": "n : \u2115\nc : OrderedFinpartition n\ni : Fin c.length\nthis : \u00ac(c.extendMiddle i).index 0 = i\n\u22a2 \u00ac(c.extendMiddle i).emb i sorry =\n      (c.extendMiddle i).emb ((c.extendMiddle i).index 0) ((c.extendMiddle i).invEmbedding 0)"}, {"line": "exact (c.extendMiddle i).emb_ne_emb_of_ne (Ne.symm this)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.sub {s : Set E} {f g : E \u2192 F} (hf : ContDiffWithinAt \ud835\udd5c n f s x)\n    (hg : ContDiffWithinAt \ud835\udd5c n g s x) : ContDiffWithinAt \ud835\udd5c n (fun x => f x - g x) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\nF : Type u_6\nn : WithTop \u2115\u221e\nx : E\ns : Set E\nf g : E \u2192 F\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffAt.sub {f g : E \u2192 F} (hf : ContDiffAt \ud835\udd5c n f x) (hg : ContDiffAt \ud835\udd5c n g x) :\n    ContDiffAt \ud835\udd5c n (fun x => f x - g x) x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\nF : Type u_6\nn : WithTop \u2115\u221e\nx : E\nf g : E \u2192 F\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffOn.sub {s : Set E} {f g : E \u2192 F} (hf : ContDiffOn \ud835\udd5c n f s)\n    (hg : ContDiffOn \ud835\udd5c n g s) : ContDiffOn \ud835\udd5c n (fun x => f x - g x) s := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\nF : Type u_6\nn : WithTop \u2115\u221e\ns : Set E\nf g : E \u2192 F\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiff.sub {f g : E \u2192 F} (hf : ContDiff \ud835\udd5c n f) (hg : ContDiff \ud835\udd5c n g) :\n    ContDiff \ud835\udd5c n fun x => f x - g x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\nF : Type u_6\nn : WithTop \u2115\u221e\nf g : E \u2192 F\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.sum {\u03b9 : Type*} {f : \u03b9 \u2192 E \u2192 F} {s : Finset \u03b9} {t : Set E} {x : E}\n    (h : \u2200 i \u2208 s, ContDiffWithinAt \ud835\udd5c n (fun x => f i x) t x) :\n    ContDiffWithinAt \ud835\udd5c n (fun x => \u2211 i \u2208 s, f i x) t x := by\n  classical\n    induction' s using Finset.induction_on with i s is IH\n    \u00b7 simp [contDiffWithinAt_const]\n    \u00b7 simp only [is, Finset.sum_insert, not_false_iff]\n      exact (h _ (Finset.mem_insert_self i s)).add\n        (IH fun j hj => h _ (Finset.mem_insert_of_mem hj))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_6\nF : Type u_7\nn : WithTop \u2115\u221e\n\u03b9 : Type u_5\nf : \u03b9 \u2192 E \u2192 F\ns : Finset \u03b9\nt : Set E\nx : E\nh : \u2200 i \u2208 s, sorry\n\u22a2 sorry"}, {"line": "classical\n    induction' s using Finset.induction_on with i s is IH\n    \u00b7 simp [contDiffWithinAt_const]\n    \u00b7 simp only [is, Finset.sum_insert, not_false_iff]\n      exact (h _ (Finset.mem_insert_self i s)).add\n        (IH fun j hj => h _ (Finset.mem_insert_of_mem hj))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.div_const {f : E \u2192 \ud835\udd5c'} {n} (hf : ContDiffWithinAt \ud835\udd5c n f s x) (c : \ud835\udd5c') :\n    ContDiffWithinAt \ud835\udd5c n (fun x => f x / c) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul contDiffWithinAt_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}", "{\ud835\udd38 \ud835\udd38' \u03b9 \ud835\udd5c' : Type*} [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedCommRing \ud835\udd38']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c' : Type u_8\nE : Type u_9\ns : Set E\nx : E\nf : E \u2192 \ud835\udd5c'\nn : WithTop \u2115\u221e\nhf : sorry\nc : \ud835\udd5c'\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul contDiffWithinAt_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiff.div_const {f : E \u2192 \ud835\udd5c'} {n} (hf : ContDiff \ud835\udd5c n f) (c : \ud835\udd5c') :\n    ContDiff \ud835\udd5c n fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul contDiff_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}", "{\ud835\udd38 \ud835\udd38' \u03b9 \ud835\udd5c' : Type*} [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedCommRing \ud835\udd38']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c' : Type u_8\nE : Type u_9\nf : E \u2192 \ud835\udd5c'\nn : WithTop \u2115\u221e\nhf : sorry\nc : \ud835\udd5c'\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul contDiff_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffAt.prodMap {f : E \u2192 F} {g : E' \u2192 F'} {x : E} {y : E'} (hf : ContDiffAt \ud835\udd5c n f x)\n    (hg : ContDiffAt \ud835\udd5c n g y) : ContDiffAt \ud835\udd5c n (Prod.map f g) (x, y) := by\n  rw [ContDiffAt] at *\n  simpa only [univ_prod_univ] using hf.prodMap hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}", "{\ud835\udd38 \ud835\udd38' \u03b9 \ud835\udd5c' : Type*} [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedCommRing \ud835\udd38']", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F]", "[ContinuousConstSMul R F]", "{i : \u2115} {a : R}", "{E' : Type*} [NormedAddCommGroup E'] [NormedSpace \ud835\udd5c E']", "{F' : Type*} [NormedAddCommGroup F'] [NormedSpace \ud835\udd5c F']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE' : Type u_9\ninst\u271d\u00b3 : NormedAddCommGroup E'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E'\nF' : Type u_10\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : NormedSpace \ud835\udd5c F'\nE : Type u_11\nF : Type u_12\nn : WithTop \u2115\u221e\nf : E \u2192 F\ng : E' \u2192 F'\nx : E\ny : E'\nhf : sorry\nhg : ContDiffAt \ud835\udd5c n g y\n\u22a2 sorry"}, {"line": "rw [ContDiffAt] at *", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE' : Type u_9\ninst\u271d\u00b3 : NormedAddCommGroup E'\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E'\nF' : Type u_10\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : NormedSpace \ud835\udd5c F'\nE : Type u_11\nF : Type u_12\nn : WithTop \u2115\u221e\nf : E \u2192 F\ng : E' \u2192 F'\nx : E\ny : E'\nhf : sorry\nhg : ContDiffWithinAt \ud835\udd5c n g univ y\n\u22a2 sorry"}, {"line": "simpa only [univ_prod_univ] using hf.prodMap hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contDiffAt_ringInverse [HasSummableGeomSeries R] (x : R\u02e3) :\n    ContDiffAt \ud835\udd5c n Ring.inverse (x : R) := by\n  have := AnalyticOnNhd.contDiffOn (analyticOnNhd_inverse (\ud835\udd5c := \ud835\udd5c) (A := R)) (n := n)\n    Units.isOpen.uniqueDiffOn x x.isUnit\n  exact this.contDiffAt (Units.isOpen.mem_nhds x.isUnit)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology", "NormedRing ContinuousLinearMap Ring"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}", "{\ud835\udd38 \ud835\udd38' \u03b9 \ud835\udd5c' : Type*} [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedCommRing \ud835\udd38']", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F]", "[ContinuousConstSMul R F]", "{i : \u2115} {a : R}", "{E' : Type*} [NormedAddCommGroup E'] [NormedSpace \ud835\udd5c E']", "{F' : Type*} [NormedAddCommGroup F'] [NormedSpace \ud835\udd5c F']", "(\ud835\udd5c)", "{R : Type*} [NormedRing R] [NormedAlgebra \ud835\udd5c R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_11\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c R\nn : WithTop \u2115\u221e\ninst\u271d : HasSummableGeomSeries R\nx : R\u02e3\n\u22a2 ContDiffAt \ud835\udd5c n Ring.inverse \u2191x"}, {"line": "have := AnalyticOnNhd.contDiffOn (analyticOnNhd_inverse (\ud835\udd5c := \ud835\udd5c) (A := R)) (n := n)\n    Units.isOpen.uniqueDiffOn x x.isUnit", "tactic_state": "case refine_3\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_11\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c R\nn : WithTop \u2115\u221e\ninst\u271d : HasSummableGeomSeries R\nx : R\u02e3\nthis : ContDiffWithinAt \ud835\udd5c n Ring.inverse {x | IsUnit x} \u2191x\n\u22a2 ContDiffAt \ud835\udd5c n Ring.inverse \u2191x\n---\ncase refine_1\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_11\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c R\nn : WithTop \u2115\u221e\ninst\u271d : HasSummableGeomSeries R\nx : R\u02e3\n\u22a2 NormedAlgebra \ud835\udd5c R\n---\ncase refine_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_11\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c R\nn : WithTop \u2115\u221e\ninst\u271d : HasSummableGeomSeries R\nx : R\u02e3\n\u22a2 NontriviallyNormedField \ud835\udd5c"}, {"line": "exact this.contDiffAt (Units.isOpen.mem_nhds x.isUnit)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.div {f g : E \u2192 \ud835\udd5c} {n} (hf : ContDiffWithinAt \ud835\udd5c n f s x)\n    (hg : ContDiffWithinAt \ud835\udd5c n g s x) (hx : g x \u2260 0) :\n    ContDiffWithinAt \ud835\udd5c n (fun x => f x / g x) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/ContDiff/Operations.lean", "context": {"open": ["scoped NNReal Nat ContDiff", "Set Fin Filter Function", "scoped Topology", "NormedRing ContinuousLinearMap Ring"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{\u03b9 \u03b9' : Type*} [Fintype \u03b9] [Fintype \u03b9'] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "(F') in", "(\ud835\udd5c E)", "{i : \u2115}", "{i : \u2115}", "{\ud835\udd38 \ud835\udd38' \u03b9 \ud835\udd5c' : Type*} [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedCommRing \ud835\udd38']", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F]", "[ContinuousConstSMul R F]", "{i : \u2115} {a : R}", "{E' : Type*} [NormedAddCommGroup E'] [NormedSpace \ud835\udd5c E']", "{F' : Type*} [NormedAddCommGroup F'] [NormedSpace \ud835\udd5c F']", "(\ud835\udd5c)", "{R : Type*} [NormedRing R] [NormedAlgebra \ud835\udd5c R]", "{\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_13\ns : Set E\nx : E\nf g : E \u2192 \ud835\udd5c\nn : WithTop \u2115\u221e\nhf : sorry\nhg : sorry\nhx : g x \u2260 0\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_inv : deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9 := by\n  rcases eq_or_ne x 0 with (rfl | hne)\n  \u00b7 simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv_iff.1 (not_not.2 rfl))]\n  \u00b7 exact (hasDerivAt_inv hne).deriv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9"}, {"line": "rcases eq_or_ne x 0 with (rfl | hne)", "tactic_state": "case inl\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u22a2 deriv (fun x => x\u207b\u00b9) sorry = -(sorry ^ 2)\u207b\u00b9\n---\ncase inr\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nhne : x \u2260 sorry\n\u22a2 deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9"}, {"line": "\u00b7 simp [deriv_zero_of_not_differentiableAt (mt differentiableAt_inv_iff.1 (not_not.2 rfl))]", "tactic_state": "case inr\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nhne : x \u2260 sorry\n\u22a2 deriv (fun x => x\u207b\u00b9) x = -(x ^ 2)\u207b\u00b9"}, {"line": "\u00b7 exact (hasDerivAt_inv hne).deriv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_inv : fderiv \ud835\udd5c (fun x => x\u207b\u00b9) x = smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) := by\n  rw [\u2190 deriv_fderiv]\n  rw [deriv_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 fderiv \ud835\udd5c (fun x => x\u207b\u00b9) x = smulRight 1 (-(x ^ 2)\u207b\u00b9)"}, {"line": "rw [\u2190 deriv_fderiv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 smulRight 1 (deriv (fun x => x\u207b\u00b9) x) = smulRight 1 (-(x ^ 2)\u207b\u00b9)"}, {"line": "rw [deriv_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.inv (hc : HasDerivWithinAt c c' s x) (hx : c x \u2260 0) :\n    HasDerivWithinAt (fun y => (c y)\u207b\u00b9) (-c' / c x ^ 2) s x := by\n  convert (hasDerivAt_inv hx).comp_hasDerivWithinAt x hc using 1\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nhc : HasDerivWithinAt c c' s x\nhx : c x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => (c y)\u207b\u00b9) (-c' / c x ^ 2) s x"}, {"line": "convert (hasDerivAt_inv hx).comp_hasDerivWithinAt x hc using 1", "tactic_state": "case h.e'_9\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nhc : HasDerivWithinAt c c' s x\nhx : c x \u2260 0\n\u22a2 -c' / c x ^ 2 = -(c x ^ 2)\u207b\u00b9 * c'"}, {"line": "field_simp", "tactic_state": "case h.e'_9\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nhc : HasDerivWithinAt c c' s x\nhx : c x \u2260 0\n\u22a2 -c' / c x ^ 2 = -(1 / c x ^ 2) * c'"}]}
{"declaration": "theorem HasDerivAt.inv (hc : HasDerivAt c c' x) (hx : c x \u2260 0) :\n    HasDerivAt (fun y => (c y)\u207b\u00b9) (-c' / c x ^ 2) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hc.inv hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nhc : HasDerivAt c c' x\nhx : c x \u2260 0\n\u22a2 HasDerivAt (fun y => (c y)\u207b\u00b9) (-c' / c x ^ 2) x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nhc : HasDerivWithinAt c c' univ x\nhx : c x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => (c y)\u207b\u00b9) (-c' / c x ^ 2) univ x"}, {"line": "exact hc.inv hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_inv' (hc : DifferentiableWithinAt \ud835\udd5c c s x) (hx : c x \u2260 0) :\n    derivWithin (fun x => (c x)\u207b\u00b9) s x = -derivWithin c s x / c x ^ 2 := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hc.hasDerivWithinAt.inv hx).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhx : c x \u2260 0\n\u22a2 derivWithin (fun x => (c x)\u207b\u00b9) s x = -derivWithin c s x / c x ^ 2"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhx : c x \u2260 0\nhsx : sorry\n\u22a2 derivWithin (fun x => (c x)\u207b\u00b9) s x = -derivWithin c s x / c x ^ 2\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhx : c x \u2260 0\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => (c x)\u207b\u00b9) s x = -derivWithin c s x / c x ^ 2"}, {"line": "\u00b7 exact (hc.hasDerivWithinAt.inv hx).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhx : c x \u2260 0\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => (c x)\u207b\u00b9) s x = -derivWithin c s x / c x ^ 2"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.div (hc : HasDerivAt c c' x) (hd : HasDerivAt d d' x) (hx : d x \u2260 0) :\n    HasDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hc.div hd hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c d : \ud835\udd5c \u2192 \ud835\udd5c'} {c' d' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nc' d' : \ud835\udd5c'\nhc : HasDerivAt c c' x\nhd : HasDerivAt d d' x\nhx : d x \u2260 0\n\u22a2 HasDerivAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nc' d' : \ud835\udd5c'\nhc : HasDerivWithinAt c c' univ x\nhd : HasDerivWithinAt d d' univ x\nhx : d x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => c y / d y) ((c' * d x - c x * d') / d x ^ 2) univ x"}, {"line": "exact hc.div hd hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_div (hc : DifferentiableWithinAt \ud835\udd5c c s x) (hd : DifferentiableWithinAt \ud835\udd5c d s x)\n    (hx : d x \u2260 0) :\n    derivWithin (fun x => c x / d x) s x =\n      (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2 := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inv.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c d : \ud835\udd5c \u2192 \ud835\udd5c'} {c' d' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhx : d x \u2260 0\n\u22a2 derivWithin (fun x => c x / d x) s x = (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhx : d x \u2260 0\nhsx : sorry\n\u22a2 derivWithin (fun x => c x / d x) s x = (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhx : d x \u2260 0\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => c x / d x) s x = (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2"}, {"line": "\u00b7 exact (hc.hasDerivWithinAt.div hd.hasDerivWithinAt hx).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd5c' : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc d : \ud835\udd5c \u2192 \ud835\udd5c'\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhx : d x \u2260 0\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => c x / d x) s x = (derivWithin c s x * d x - c x * derivWithin d s x) / d x ^ 2"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_zero_of_frequently_const {c} (h : \u2203\u1da0 y in \ud835\udcdd[\u2260] x, f y = c) : deriv f x = 0 := by\n  rw [\u2190 derivWithin_univ]\n  rw [derivWithin_zero_of_frequently_const]\n  rwa [\u2190 compl_eq_univ_diff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Inverse.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{s : Set \ud835\udd5c} {x : \ud835\udd5c} {c : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\nh : \u2203\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, f y = c\n\u22a2 deriv f x = 0"}, {"line": "rw [\u2190 derivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\nh : \u2203\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, f y = c\n\u22a2 derivWithin f univ x = 0"}, {"line": "rw [derivWithin_zero_of_frequently_const]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\nh : \u2203\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, f y = c\n\u22a2 \u2203\u1da0 (y : \ud835\udd5c) in nhdsWithin x (univ \\ {x}), f y = ?m.2929\n---\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\nh : \u2203\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, f y = c\n\u22a2 F"}, {"line": "rwa [\u2190 compl_eq_univ_diff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.pow (hc : HasDerivAt c c' x) :\n    HasDerivAt (fun y => c y ^ n) ((n : \ud835\udd5c) * c x ^ (n - 1) * c') x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hc.pow n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Pow.lean", "context": {"open": [], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}", "(n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nn : \u2115\nhc : HasDerivAt c c' x\n\u22a2 HasDerivAt (fun y => c y ^ n) (\u2191n * c x ^ (n - 1) * c') x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nc' : \ud835\udd5c\nn : \u2115\nhc : HasDerivWithinAt c c' Set.univ x\n\u22a2 HasDerivWithinAt (fun y => c y ^ n) (\u2191n * c x ^ (n - 1) * c') Set.univ x"}, {"line": "exact hc.pow n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_pow' (hc : DifferentiableWithinAt \ud835\udd5c c s x) :\n    derivWithin (fun x => c x ^ n) s x = (n : \ud835\udd5c) * c x ^ (n - 1) * derivWithin c s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hc.hasDerivWithinAt.pow n).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Pow.lean", "context": {"open": [], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{c : \ud835\udd5c \u2192 \ud835\udd5c} {c' : \ud835\udd5c}", "(n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nn : \u2115\nhc : DifferentiableWithinAt \ud835\udd5c c s x\n\u22a2 derivWithin (fun x => c x ^ n) s x = \u2191n * c x ^ (n - 1) * derivWithin c s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nn : \u2115\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhsx : sorry\n\u22a2 derivWithin (fun x => c x ^ n) s x = \u2191n * c x ^ (n - 1) * derivWithin c s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nn : \u2115\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => c x ^ n) s x = \u2191n * c x ^ (n - 1) * derivWithin c s x"}, {"line": "\u00b7 exact (hc.hasDerivWithinAt.pow n).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : \ud835\udd5c \u2192 \ud835\udd5c\nn : \u2115\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun x => c x ^ n) s x = \u2191n * c x ^ (n - 1) * derivWithin c s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictDerivAt_abs {x : \u211d} (hx : x \u2260 0) :\n    HasStrictDerivAt (|\u00b7|) (SignType.sign x : \u211d) x := by\n  obtain hx | hx := hx.lt_or_lt\n  \u00b7 simpa [hx] using hasStrictDerivAt_abs_neg hx\n  \u00b7 simpa [hx] using hasStrictDerivAt_abs_pos hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Abs.lean", "context": {"open": ["Filter Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : \u2115\u221e} {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\n\u22a2 HasStrictDerivAt (fun x => |x|) (\u2191(SignType.sign x)) x"}, {"line": "obtain hx | hx := hx.lt_or_lt", "tactic_state": "case inl\nx : \u211d\nhx\u271d : x \u2260 0\nhx : x < 0\n\u22a2 HasStrictDerivAt (fun x => |x|) (\u2191(SignType.sign x)) x\n---\ncase inr\nx : \u211d\nhx\u271d : x \u2260 0\nhx : 0 < x\n\u22a2 HasStrictDerivAt (fun x => |x|) (\u2191(SignType.sign x)) x"}, {"line": "\u00b7 simpa [hx] using hasStrictDerivAt_abs_neg hx", "tactic_state": "case inr\nx : \u211d\nhx\u271d : x \u2260 0\nhx : 0 < x\n\u22a2 HasStrictDerivAt (fun x => |x|) (\u2191(SignType.sign x)) x"}, {"line": "\u00b7 simpa [hx] using hasStrictDerivAt_abs_pos hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.abs_of_neg (hf : HasFDerivWithinAt f f' s x)\n    (h\u2080 : f x < 0) : HasFDerivWithinAt (fun x \u21a6 |f x|) (-f') s x := by\n  convert (hasDerivAt_abs_neg h\u2080).comp_hasFDerivWithinAt x hf using 1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Abs.lean", "context": {"open": ["Filter Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : \u2115\u221e} {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nh\u2080 : f x < 0\n\u22a2 HasFDerivWithinAt (fun x => |f x|) (-f') s x"}, {"line": "convert (hasDerivAt_abs_neg h\u2080).comp_hasFDerivWithinAt x hf using 1", "tactic_state": "case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nh\u2080 : f x < 0\n\u22a2 -f' = -1 \u2022 f'"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.abs_of_pos (hf : HasFDerivWithinAt f f' s x)\n    (h\u2080 : 0 < f x) : HasFDerivWithinAt (fun x \u21a6 |f x|) f' s x := by\n  convert (hasDerivAt_abs_pos h\u2080).comp_hasFDerivWithinAt x hf using 1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Abs.lean", "context": {"open": ["Filter Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : \u2115\u221e} {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nh\u2080 : 0 < f x\n\u22a2 HasFDerivWithinAt (fun x => |f x|) f' s x"}, {"line": "convert (hasDerivAt_abs_pos h\u2080).comp_hasFDerivWithinAt x hf using 1", "tactic_state": "case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192 \u211d\nf' : E \u2192L[\u211d] \u211d\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nh\u2080 : 0 < f x\n\u22a2 f' = 1 \u2022 f'"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_differentiableAt_abs_zero : \u00ac DifferentiableAt \u211d (abs : \u211d \u2192 \u211d) 0 := by\n  intro h\n  have h\u2081 : deriv abs (0 : \u211d) = 1 :=\n    (uniqueDiffOn_Ici _ _ Set.left_mem_Ici).eq_deriv _ h.hasDerivAt.hasDerivWithinAt <|\n      (hasDerivWithinAt_id _ _).congr_of_mem (fun _ h \u21a6 abs_of_nonneg h) Set.left_mem_Ici\n  have h\u2082 : deriv abs (0 : \u211d) = -1 :=\n    (uniqueDiffOn_Iic _ _ Set.right_mem_Iic).eq_deriv _ h.hasDerivAt.hasDerivWithinAt <|\n      (hasDerivWithinAt_neg _ _).congr_of_mem (fun _ h \u21a6 abs_of_nonpos h) Set.right_mem_Iic\n  linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Abs.lean", "context": {"open": ["Filter Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : \u2115\u221e} {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acDifferentiableAt \u211d abs 0"}, {"line": "intro h", "tactic_state": "h : DifferentiableAt \u211d abs 0\n\u22a2 False"}, {"line": "have h\u2081 : deriv abs (0 : \u211d) = 1 :=\n    (uniqueDiffOn_Ici _ _ Set.left_mem_Ici).eq_deriv _ h.hasDerivAt.hasDerivWithinAt <|\n      (hasDerivWithinAt_id _ _).congr_of_mem (fun _ h \u21a6 abs_of_nonneg h) Set.left_mem_Ici", "tactic_state": "h : DifferentiableAt \u211d abs 0\nh\u2081 : deriv abs 0 = 1\n\u22a2 False"}, {"line": "have h\u2082 : deriv abs (0 : \u211d) = -1 :=\n    (uniqueDiffOn_Iic _ _ Set.right_mem_Iic).eq_deriv _ h.hasDerivAt.hasDerivWithinAt <|\n      (hasDerivWithinAt_neg _ _).congr_of_mem (fun _ h \u21a6 abs_of_nonpos h) Set.right_mem_Iic", "tactic_state": "h : DifferentiableAt \u211d abs 0\nh\u2081 : deriv abs 0 = 1\nh\u2082 : deriv abs 0 = -1\n\u22a2 False"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_abs (x : \u211d) : deriv (|\u00b7|) x = SignType.sign x := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simpa using deriv_abs_zero\n  \u00b7 simpa [hx] using (hasDerivAt_abs hx).deriv", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Abs.lean", "context": {"open": ["Filter Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : \u2115\u221e} {f : E \u2192 \u211d} {f' : E \u2192L[\u211d] \u211d} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 deriv (fun x => |x|) x = \u2191(SignType.sign x)"}, {"line": "obtain rfl | hx := eq_or_ne x 0", "tactic_state": "case inl\n\u22a2 deriv (fun x => |x|) 0 = \u2191(SignType.sign 0)\n---\ncase inr\nx : \u211d\nhx : x \u2260 0\n\u22a2 deriv (fun x => |x|) x = \u2191(SignType.sign x)"}, {"line": "\u00b7 simpa using deriv_abs_zero", "tactic_state": "case inr\nx : \u211d\nhx : x \u2260 0\n\u22a2 deriv (fun x => |x|) x = \u2191(SignType.sign x)"}, {"line": "\u00b7 simpa [hx] using (hasDerivAt_abs hx).deriv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_add (hf : DifferentiableWithinAt \ud835\udd5c f s x)\n    (hg : DifferentiableWithinAt \ud835\udd5c g s x) :\n    derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hf.hasDerivWithinAt.add hg.hasDerivWithinAt).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhg : DifferentiableWithinAt \ud835\udd5c g s x\n\u22a2 derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhg : DifferentiableWithinAt \ud835\udd5c g s x\nhsx : sorry\n\u22a2 derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhg : DifferentiableWithinAt \ud835\udd5c g s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x"}, {"line": "\u00b7 exact (hf.hasDerivWithinAt.add hg.hasDerivWithinAt).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhg : DifferentiableWithinAt \ud835\udd5c g s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_add_const (c : F) :\n    derivWithin (fun y => f y + c) s x = derivWithin f s x := by\n  simp only [derivWithin]\n  simp only [fderivWithin_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 derivWithin (fun y => f y + c) s x = derivWithin f s x"}, {"line": "simp only [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 (fderivWithin \ud835\udd5c (fun y => f y + c) s x) 1 = (fderivWithin \ud835\udd5c f s x) 1"}, {"line": "simp only [fderivWithin_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_add_const (c : F) : deriv (fun y => f y + c) x = deriv f x := by\n  simp only [deriv]\n  simp only [fderiv_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 deriv (fun y => f y + c) x = deriv f x"}, {"line": "simp only [deriv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 (fderiv \ud835\udd5c (fun y => f y + c) x) 1 = (fderiv \ud835\udd5c f x) 1"}, {"line": "simp only [fderiv_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_const_add (c : F) :\n    derivWithin (c + f \u00b7) s x = derivWithin f s x := by\n  simp only [derivWithin]\n  simp only [fderivWithin_const_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 derivWithin (fun x => c + f x) s x = derivWithin f s x"}, {"line": "simp only [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 (fderivWithin \ud835\udd5c (fun x => c + f x) s x) 1 = (fderivWithin \ud835\udd5c f s x) 1"}, {"line": "simp only [fderivWithin_const_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_const_add (c : F) : deriv (c + f \u00b7) x = deriv f x := by\n  simp only [deriv]\n  simp only [fderiv_const_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 deriv (fun x => c + f x) x = deriv f x"}, {"line": "simp only [deriv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 (fderiv \ud835\udd5c (fun x => c + f x) x) 1 = (fderiv \ud835\udd5c f x) 1"}, {"line": "simp only [fderiv_const_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_comp_const_add {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (b + x)) a \u2194 DifferentiableAt \ud835\udd5c f (b + a) := by\n  refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H.comp _ (differentiable_id.const_add _).differentiableAt\u27e9\n  convert DifferentiableAt.comp (b + a) (by simpa)\n    (differentiable_id.const_add (-b)).differentiableAt\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a \u2194 DifferentiableAt \ud835\udd5c f (b + a)"}, {"line": "refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H.comp _ (differentiable_id.const_add _).differentiableAt\u27e9", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\n\u22a2 DifferentiableAt \ud835\udd5c f (b + a)"}, {"line": "convert DifferentiableAt.comp (b + a) (by simpa)\n    (differentiable_id.const_add (-b)).differentiableAt", "tactic_state": "case h.e\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\n\u22a2 DifferentiableAt \ud835\udd5c f = DifferentiableAt sorry (sorry \u2218 fun y => -b + id y)\n---\ncase h.e'_1.h.e'_4\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\n\u22a2 instHAdd = sorry"}, {"line": "ext", "tactic_state": "case h.e.h.a\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\nx\u271d : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f x\u271d \u2194 DifferentiableAt sorry (sorry \u2218 fun y => -b + id y) x\u271d\n---\ncase h.e'_1.h.e'_4\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\n\u22a2 instHAdd = sorry"}, {"line": "simp", "tactic_state": "case h.e.h.a\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\nx\u271d : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f x\u271d \u2194 DifferentiableAt sorry (sorry \u2218 fun y => -b + y) x\u271d\n---\ncase h.e'_1.h.e'_4\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b + x)) a\n\u22a2 instHAdd = sorry"}]}
{"declaration": "lemma differentiableAt_comp_add_const {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x + b)) a \u2194 DifferentiableAt \ud835\udd5c f (a + b) := by\n  simpa [add_comm b] using differentiableAt_comp_const_add (f := f) (b := b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (x + b)) a \u2194 DifferentiableAt \ud835\udd5c f (a + b)"}, {"line": "simpa [add_comm b] using differentiableAt_comp_const_add (f := f) (b := b)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_iff_comp_const_add {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x \u21a6 f (b + x)) (-b + a) := by\n  simp [differentiableAt_comp_const_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x => f (b + x)) (-b + a)"}, {"line": "simp [differentiableAt_comp_const_add]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_iff_comp_add_const {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x + b)) (a - b) := by\n  simp [differentiableAt_comp_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x => f (x + b)) (a - b)"}, {"line": "simp [differentiableAt_comp_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_sum (h : \u2200 i \u2208 u, DifferentiableWithinAt \ud835\udd5c (A i) s x) :\n    derivWithin (fun y => \u2211 i \u2208 u, A i y) s x = \u2211 i \u2208 u, derivWithin (A i) s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (HasDerivWithinAt.sum fun i hi => (h i hi).hasDerivWithinAt).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u03b9 : Type u_1\nu : Finset \u03b9\nA : \u03b9 \u2192 \ud835\udd5c \u2192 F\nh : \u2200 i \u2208 u, DifferentiableWithinAt \ud835\udd5c (A i) s x\n\u22a2 derivWithin (fun y => \u2211 i \u2208 u, A i y) s x = \u2211 i \u2208 u, derivWithin (A i) s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u03b9 : Type u_1\nu : Finset \u03b9\nA : \u03b9 \u2192 \ud835\udd5c \u2192 F\nh : \u2200 i \u2208 u, DifferentiableWithinAt \ud835\udd5c (A i) s x\nhsx : sorry\n\u22a2 derivWithin (fun y => \u2211 i \u2208 u, A i y) s x = \u2211 i \u2208 u, derivWithin (A i) s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u03b9 : Type u_1\nu : Finset \u03b9\nA : \u03b9 \u2192 \ud835\udd5c \u2192 F\nh : \u2200 i \u2208 u, DifferentiableWithinAt \ud835\udd5c (A i) s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => \u2211 i \u2208 u, A i y) s x = \u2211 i \u2208 u, derivWithin (A i) s x"}, {"line": "\u00b7 exact (HasDerivWithinAt.sum fun i hi => (h i hi).hasDerivWithinAt).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u03b9 : Type u_1\nu : Finset \u03b9\nA : \u03b9 \u2192 \ud835\udd5c \u2192 F\nh : \u2200 i \u2208 u, DifferentiableWithinAt \ud835\udd5c (A i) s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => \u2211 i \u2208 u, A i y) s x = \u2211 i \u2208 u, derivWithin (A i) s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin.neg : derivWithin (fun y => -f y) s x = -derivWithin f s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 simp only [derivWithin, fderivWithin_neg hsx, ContinuousLinearMap.neg_apply]\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u22a2 derivWithin (fun y => -f y) s x = -derivWithin f s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhsx : sorry\n\u22a2 derivWithin (fun y => -f y) s x = -derivWithin f s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => -f y) s x = -derivWithin f s x"}, {"line": "\u00b7 simp only [derivWithin, fderivWithin_neg hsx, ContinuousLinearMap.neg_apply]", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => -f y) s x = -derivWithin f s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv.neg : deriv (fun y => -f y) x = -deriv f x := by\n  simp only [deriv]\n  simp only [fderiv_neg]\n  simp only [ContinuousLinearMap.neg_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 deriv (fun y => -f y) x = -deriv f x"}, {"line": "simp only [deriv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 (fderiv \ud835\udd5c (fun y => -f y) x) 1 = -(fderiv \ud835\udd5c f x) 1"}, {"line": "simp only [fderiv_neg]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 (-fderiv \ud835\udd5c f x) 1 = -(fderiv \ud835\udd5c f x) 1"}, {"line": "simp only [ContinuousLinearMap.neg_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAtFilter.sub (hf : HasDerivAtFilter f f' x L) (hg : HasDerivAtFilter g g' x L) :\n    HasDerivAtFilter (fun x => f x - g x) (f' - g') x L := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nf' g' : F\nx : \ud835\udd5c\nL : Filter \ud835\udd5c\nhf : HasDerivAtFilter f f' x L\nhg : HasDerivAtFilter g g' x L\n\u22a2 HasDerivAtFilter (fun x => f x - g x) (f' - g') x L"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.sub (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\n    HasStrictDerivAt (fun x => f x - g x) (f' - g') x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : \ud835\udd5c \u2192 F\nf' g' : F\nx : \ud835\udd5c\nhf : HasStrictDerivAt f f' x\nhg : HasStrictDerivAt g g' x\n\u22a2 HasStrictDerivAt (fun x => f x - g x) (f' - g') x"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_sub_const (c : F) :\n    derivWithin (fun y => f y - c) s x = derivWithin f s x := by\n  simp only [derivWithin]\n  simp only [fderivWithin_sub_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 derivWithin (fun y => f y - c) s x = derivWithin f s x"}, {"line": "simp only [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 (fderivWithin \ud835\udd5c (fun y => f y - c) s x) 1 = (fderivWithin \ud835\udd5c f s x) 1"}, {"line": "simp only [fderivWithin_sub_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_sub_const (c : F) : deriv (fun y => f y - c) x = deriv f x := by\n  simp only [deriv]\n  simp only [fderiv_sub_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 deriv (fun y => f y - c) x = deriv f x"}, {"line": "simp only [deriv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 (fderiv \ud835\udd5c (fun y => f y - c) x) 1 = (fderiv \ud835\udd5c f x) 1"}, {"line": "simp only [fderiv_sub_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAtFilter.const_sub (c : F) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun x => c - f x) (-f') x L := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\nL : Filter \ud835\udd5c\nc : F\nhf : HasDerivAtFilter f f' x L\n\u22a2 HasDerivAtFilter (fun x => c - f x) (-f') x L"}, {"line": "simpa only [sub_eq_add_neg] using hf.neg.const_add c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.const_sub (c : F) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun x => c - f x) (-f') x := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\nc : F\nhf : HasStrictDerivAt f f' x\n\u22a2 HasStrictDerivAt (fun x => c - f x) (-f') x"}, {"line": "simpa only [sub_eq_add_neg] using hf.neg.const_add c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_const_sub (c : F) :\n    derivWithin (fun y => c - f y) s x = -derivWithin f s x := by\n  simp [sub_eq_add_neg, derivWithin.neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nc : F\n\u22a2 derivWithin (fun y => c - f y) s x = -derivWithin f s x"}, {"line": "simp [sub_eq_add_neg, derivWithin.neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_const_sub (c : F) : deriv (fun y => c - f y) x = -deriv f x := by\n  simp only [\u2190 derivWithin_univ]\n  simp only [derivWithin_const_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 deriv (fun y => c - f y) x = -deriv f x"}, {"line": "simp only [\u2190 derivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nc : F\n\u22a2 derivWithin (fun y => c - f y) univ x = -derivWithin f univ x"}, {"line": "simp only [derivWithin_const_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_comp_sub_const {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x - b)) a \u2194 DifferentiableAt \ud835\udd5c f (a - b) := by\n  simp [sub_eq_add_neg, differentiableAt_comp_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (x - b)) a \u2194 DifferentiableAt \ud835\udd5c f (a - b)"}, {"line": "simp [sub_eq_add_neg, differentiableAt_comp_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_comp_const_sub {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (b - x)) a \u2194 DifferentiableAt \ud835\udd5c f (b - a) := by\n  refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H.comp a (differentiable_id.const_sub _).differentiableAt\u27e9\n  convert ((sub_sub_cancel _ a).symm \u25b8 H).comp (b - a)\n    (differentiable_id.const_sub _).differentiableAt\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (b - x)) a \u2194 DifferentiableAt \ud835\udd5c f (b - a)"}, {"line": "refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H.comp a (differentiable_id.const_sub _).differentiableAt\u27e9", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b - x)) a\n\u22a2 DifferentiableAt \ud835\udd5c f (b - a)"}, {"line": "convert ((sub_sub_cancel _ a).symm \u25b8 H).comp (b - a)\n    (differentiable_id.const_sub _).differentiableAt", "tactic_state": "case h.e'_11\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b - x)) a\n\u22a2 f = (fun x => f (b - x)) \u2218 HSub.hSub b"}, {"line": "ext", "tactic_state": "case h.e'_11.h\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\nH : DifferentiableAt \ud835\udd5c (fun x => f (b - x)) a\nx\u271d : \ud835\udd5c\n\u22a2 f x\u271d = ((fun x => f (b - x)) \u2218 HSub.hSub b) x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_iff_comp_sub_const {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x - b)) (a + b) := by\n  simp [sub_eq_add_neg, differentiableAt_comp_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x => f (x - b)) (a + b)"}, {"line": "simp [sub_eq_add_neg, differentiableAt_comp_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableAt_iff_comp_const_sub {a b : \ud835\udd5c} :\n    DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x \u21a6 f (b - x)) (b - a) := by\n  simp [differentiableAt_comp_const_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Add.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Asymptotics Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : \ud835\udd5c \u2192 F}", "{f' g' : F}", "{x : \ud835\udd5c} {s : Set \ud835\udd5c} {L : Filter \ud835\udd5c}", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 \ud835\udd5c \u2192 F} {A' : \u03b9 \u2192 F}", "(s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\na b : \ud835\udd5c\n\u22a2 DifferentiableAt \ud835\udd5c f a \u2194 DifferentiableAt \ud835\udd5c (fun x => f (b - x)) (b - a)"}, {"line": "simp [differentiableAt_comp_const_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAtFilter_iff_hasDerivAtFilter {f' : \ud835\udd5c \u2192L[\ud835\udd5c] F} :\n    HasFDerivAtFilter f f' x L \u2194 HasDerivAtFilter f (f' 1) x L := by simp [HasDerivAtFilter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2074 : AddCommGroup F\ninst\u271d\u00b3 : Module \ud835\udd5c F\ninst\u271d\u00b2 : TopologicalSpace F\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nL : Filter \ud835\udd5c\ninst\u271d : ContinuousSMul \ud835\udd5c F\nf' : \ud835\udd5c \u2192L[\ud835\udd5c] F\n\u22a2 HasFDerivAtFilter f f' x L \u2194 HasDerivAtFilter f (f' 1) x L"}, {"line": "simp [HasDerivAtFilter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictFDerivAt_iff_hasStrictDerivAt {f' : \ud835\udd5c \u2192L[\ud835\udd5c] F} :\n    HasStrictFDerivAt f f' x \u2194 HasStrictDerivAt f (f' 1) x := by\n  simp [HasStrictDerivAt, HasStrictFDerivAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2074 : AddCommGroup F\ninst\u271d\u00b3 : Module \ud835\udd5c F\ninst\u271d\u00b2 : TopologicalSpace F\ninst\u271d\u00b9 : ContinuousSMul \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ninst\u271d : ContinuousSMul \ud835\udd5c F\nf' : \ud835\udd5c \u2192L[\ud835\udd5c] F\n\u22a2 HasStrictFDerivAt f f' x \u2194 HasStrictDerivAt f (f' 1) x"}, {"line": "simp [HasStrictDerivAt, HasStrictFDerivAt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_zero_of_not_accPt (h : \u00acAccPt x (\ud835\udcdf s)) : derivWithin f s x = 0 := by\n  rw [derivWithin]\n  rw [fderivWithin_zero_of_not_accPt h]\n  rw [ContinuousLinearMap.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : \u00acAccPt x (principal s)\n\u22a2 derivWithin f s x = 0"}, {"line": "rw [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : \u00acAccPt x (principal s)\n\u22a2 (fderivWithin \ud835\udd5c f s x) 1 = 0"}, {"line": "rw [fderivWithin_zero_of_not_accPt h]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : \u00acAccPt x (principal s)\n\u22a2 0 1 = 0"}, {"line": "rw [ContinuousLinearMap.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_zero_of_isolated (h : \ud835\udcdd[s \\ {x}] x = \u22a5) : derivWithin f s x = 0 := by\n  rw [derivWithin]\n  rw [fderivWithin_zero_of_isolated h]\n  rw [ContinuousLinearMap.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : nhdsWithin x (s \\ {x}) = \u22a5\n\u22a2 derivWithin f s x = 0"}, {"line": "rw [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : nhdsWithin x (s \\ {x}) = \u22a5\n\u22a2 (fderivWithin \ud835\udd5c f s x) 1 = 0"}, {"line": "rw [fderivWithin_zero_of_isolated h]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : nhdsWithin x (s \\ {x}) = \u22a5\n\u22a2 0 1 = 0"}, {"line": "rw [ContinuousLinearMap.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_zero_of_nmem_closure (h : x \u2209 closure s) : derivWithin f s x = 0 := by\n  rw [derivWithin]\n  rw [fderivWithin_zero_of_nmem_closure h]\n  rw [ContinuousLinearMap.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : x \u2209 closure s\n\u22a2 derivWithin f s x = 0"}, {"line": "rw [derivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : x \u2209 closure s\n\u22a2 (fderivWithin \ud835\udd5c f s x) 1 = 0"}, {"line": "rw [fderivWithin_zero_of_nmem_closure h]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nh : x \u2209 closure s\n\u22a2 0 1 = 0"}, {"line": "rw [ContinuousLinearMap.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_Ioi_iff_Ici [PartialOrder \ud835\udd5c] :\n    HasDerivWithinAt f f' (Ioi x) x \u2194 HasDerivWithinAt f f' (Ici x) x := by\n  rw [\u2190 Ici_diff_left]\n  rw [hasDerivWithinAt_diff_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ninst\u271d : PartialOrder \ud835\udd5c\n\u22a2 HasDerivWithinAt f f' (Ioi x) x \u2194 HasDerivWithinAt f f' (Ici x) x"}, {"line": "rw [\u2190 Ici_diff_left]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ninst\u271d : PartialOrder \ud835\udd5c\n\u22a2 HasDerivWithinAt f f' (Ici x \\ {x}) x \u2194 HasDerivWithinAt f f' (Ici x) x"}, {"line": "rw [hasDerivWithinAt_diff_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_Iio_iff_Iic [PartialOrder \ud835\udd5c] :\n    HasDerivWithinAt f f' (Iio x) x \u2194 HasDerivWithinAt f f' (Iic x) x := by\n  rw [\u2190 Iic_diff_right]\n  rw [hasDerivWithinAt_diff_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ninst\u271d : PartialOrder \ud835\udd5c\n\u22a2 HasDerivWithinAt f f' (Iio x) x \u2194 HasDerivWithinAt f f' (Iic x) x"}, {"line": "rw [\u2190 Iic_diff_right]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ninst\u271d : PartialOrder \ud835\udd5c\n\u22a2 HasDerivWithinAt f f' (Iic x \\ {x}) x \u2194 HasDerivWithinAt f f' (Iic x) x"}, {"line": "rw [hasDerivWithinAt_diff_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_fderivWithin :\n    smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (derivWithin f s x) = fderivWithin \ud835\udd5c f s x := by simp [derivWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u22a2 smulRight 1 (derivWithin f s x) = fderivWithin \ud835\udd5c f s x"}, {"line": "simp [derivWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_derivWithin_eq_norm_fderivWithin : \u2016derivWithin f s x\u2016 = \u2016fderivWithin \ud835\udd5c f s x\u2016 := by\n  simp [\u2190 derivWithin_fderivWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u22a2 \u2016derivWithin f s x\u2016 = \u2016fderivWithin \ud835\udd5c f s x\u2016"}, {"line": "simp [\u2190 derivWithin_fderivWithin]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\u22a2 \u2016derivWithin f s x\u2016 = \u2016smulRight 1 (derivWithin f s x)\u2016"}]}
{"declaration": "theorem deriv_fderiv : smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (deriv f x) = fderiv \ud835\udd5c f x := by\n  simp only [deriv]\n  simp only [ContinuousLinearMap.smulRight_one_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 smulRight 1 (deriv f x) = fderiv \ud835\udd5c f x"}, {"line": "simp only [deriv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 smulRight 1 ((fderiv \ud835\udd5c f x) 1) = fderiv \ud835\udd5c f x"}, {"line": "simp only [ContinuousLinearMap.smulRight_one_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fderiv_eq_deriv_mul {f : \ud835\udd5c \u2192 \ud835\udd5c} {x y : \ud835\udd5c} : (fderiv \ud835\udd5c f x : \ud835\udd5c \u2192 \ud835\udd5c) y = (deriv f x) * y := by\n  simp [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nx y : \ud835\udd5c\n\u22a2 (fderiv \ud835\udd5c f x) y = deriv f x * y"}, {"line": "simp [mul_comm]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nx y : \ud835\udd5c\n\u22a2 y * deriv f x = deriv f x * y"}]}
{"declaration": "theorem norm_deriv_eq_norm_fderiv : \u2016deriv f x\u2016 = \u2016fderiv \ud835\udd5c f x\u2016 := by\n  simp [\u2190 deriv_fderiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 \u2016deriv f x\u2016 = \u2016fderiv \ud835\udd5c f x\u2016"}, {"line": "simp [\u2190 deriv_fderiv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 \u2016deriv f x\u2016 = \u2016smulRight 1 (deriv f x)\u2016"}]}
{"declaration": "theorem derivWithin_congr_set' (y : \ud835\udd5c) (h : s =\u1da0[\ud835\udcdd[{y}\u1d9c] x] t) :\n    derivWithin f s x = derivWithin f t x := by simp only [derivWithin, fderivWithin_congr_set' y h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\ny : \ud835\udd5c\nh : s =\u1da0[nhdsWithin x {y}\u1d9c] t\n\u22a2 derivWithin f s x = derivWithin f t x"}, {"line": "simp only [derivWithin, fderivWithin_congr_set' y h]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\ny : \ud835\udd5c\nh : s =\u1da0[nhdsWithin x {y}\u1d9c] t\n\u22a2 (fderivWithin \ud835\udd5c f s x) 1 = (fderivWithin \ud835\udd5c f t x) 1"}]}
{"declaration": "theorem derivWithin_univ : derivWithin f univ = deriv f := by\n  ext\n  unfold derivWithin deriv\n  rw [fderivWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\n\u22a2 derivWithin f univ = deriv f"}, {"line": "ext", "tactic_state": "case h\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx\u271d : \ud835\udd5c\n\u22a2 derivWithin f univ x\u271d = deriv f x\u271d"}, {"line": "unfold derivWithin deriv", "tactic_state": "case h\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx\u271d : \ud835\udd5c\n\u22a2 (fderivWithin \ud835\udd5c f univ x\u271d) 1 = (fderiv \ud835\udd5c f x\u271d) 1"}, {"line": "rw [fderivWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_inter (ht : t \u2208 \ud835\udcdd x) : derivWithin f (s \u2229 t) x = derivWithin f s x := by\n  unfold derivWithin\n  rw [fderivWithin_inter ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nht : t \u2208 nhds x\n\u22a2 derivWithin f (s \u2229 t) x = derivWithin f s x"}, {"line": "unfold derivWithin", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns t : Set \ud835\udd5c\nht : t \u2208 nhds x\n\u22a2 (fderivWithin \ud835\udd5c f (s \u2229 t) x) 1 = (fderivWithin \ud835\udd5c f s x) 1"}, {"line": "rw [fderivWithin_inter ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.deriv_eq (hL : f\u2081 =\u1da0[\ud835\udcdd x] f) : deriv f\u2081 x = deriv f x := by\n  unfold deriv\n  rwa [Filter.EventuallyEq.fderiv_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf f\u2081 : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nhL : f\u2081 =\u1da0[nhds x] f\n\u22a2 deriv f\u2081 x = deriv f x"}, {"line": "unfold deriv", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf f\u2081 : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nhL : f\u2081 =\u1da0[nhds x] f\n\u22a2 (fderiv \ud835\udd5c f\u2081 x) 1 = (fderiv \ud835\udd5c f x) 1"}, {"line": "rwa [Filter.EventuallyEq.fderiv_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_deriv_le_of_lip' {f : \ud835\udd5c \u2192 F} {x\u2080 : \ud835\udd5c}\n    {C : \u211d} (hC\u2080 : 0 \u2264 C) (hlip : \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016) :\n    \u2016deriv f x\u2080\u2016 \u2264 C := by\n  simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lip' \ud835\udd5c hC\u2080 hlip\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Basic.lean", "context": {"open": ["scoped Topology ENNReal NNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "[ContinuousSMul \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "[ContinuousSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 : \ud835\udd5c \u2192 F}", "{f' f\u2080' f\u2081' g' : F}", "{x : \ud835\udd5c}", "{s t : Set \ud835\udd5c}", "{L L\u2081 L\u2082 : Filter \ud835\udd5c}", "(s x L)", "(c : F) (s x L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx\u2080 : \ud835\udd5c\nC : \u211d\nhC\u2080 : 0 \u2264 C\nhlip : \u2200\u1da0 (x : \ud835\udd5c) in nhds x\u2080, \u2016f x - f x\u2080\u2016 \u2264 C * \u2016x - x\u2080\u2016\n\u22a2 \u2016deriv f x\u2080\u2016 \u2264 C"}, {"line": "simpa [norm_deriv_eq_norm_fderiv] using norm_fderiv_le_of_lip' \ud835\udd5c hC\u2080 hlip", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.comp_hasDerivWithinAt {t : Set F} (hl : HasFDerivWithinAt l l' t (f x))\n    (hf : HasDerivWithinAt f f' s x) (hst : MapsTo f s t) :\n    HasDerivWithinAt (l \u2218 f) (l' f') s x := by\n  simpa only [one_apply,one_smul,smulRight_apply,coe_comp',(\u00b7 \u2218 \u00b7)] using\n    (hl.comp x hf.hasFDerivWithinAt hst).hasDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Comp.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{l : F \u2192 E} {l' : F \u2192L[\ud835\udd5c] E} {y : F}", "(x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nl : F \u2192 E\nl' : F \u2192L[\ud835\udd5c] E\nt : Set F\nhl : HasFDerivWithinAt l l' t (f x)\nhf : HasDerivWithinAt f f' s x\nhst : MapsTo f s t\n\u22a2 HasDerivWithinAt (l \u2218 f) (l' f') s x"}, {"line": "simpa only [one_apply,one_smul,smulRight_apply,coe_comp',(\u00b7 \u2218 \u00b7)] using\n    (hl.comp x hf.hasFDerivWithinAt hst).hasDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictFDerivAt.comp_hasStrictDerivAt (hl : HasStrictFDerivAt l l' (f x))\n    (hf : HasStrictDerivAt f f' x) : HasStrictDerivAt (l \u2218 f) (l' f') x := by\n  simpa only [one_apply,one_smul,smulRight_apply,coe_comp',(\u00b7 \u2218 \u00b7)] using\n    (hl.comp x hf.hasStrictFDerivAt).hasStrictDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Comp.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{l : F \u2192 E} {l' : F \u2192L[\ud835\udd5c] E} {y : F}", "(x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\nl : F \u2192 E\nl' : F \u2192L[\ud835\udd5c] E\nhl : HasStrictFDerivAt l l' (f x)\nhf : HasStrictDerivAt f f' x\n\u22a2 HasStrictDerivAt (l \u2218 f) (l' f') x"}, {"line": "simpa only [one_apply,one_smul,smulRight_apply,coe_comp',(\u00b7 \u2218 \u00b7)] using\n    (hl.comp x hf.hasStrictFDerivAt).hasStrictDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_comp_derivWithin {t : Set F} (hl : DifferentiableWithinAt \ud835\udd5c l t (f x))\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) (hs : MapsTo f s t) :\n    derivWithin (l \u2218 f) s x = (fderivWithin \ud835\udd5c l t (f x) : F \u2192 E) (derivWithin f s x) := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hl.hasFDerivWithinAt.comp_hasDerivWithinAt x hf.hasDerivWithinAt hs).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Comp.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{l : F \u2192 E} {l' : F \u2192L[\ud835\udd5c] E} {y : F}", "(x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nl : F \u2192 E\nt : Set F\nhl : DifferentiableWithinAt \ud835\udd5c l t (f x)\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhs : MapsTo f s t\n\u22a2 derivWithin (l \u2218 f) s x = (fderivWithin \ud835\udd5c l t (f x)) (derivWithin f s x)"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nl : F \u2192 E\nt : Set F\nhl : DifferentiableWithinAt \ud835\udd5c l t (f x)\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhs : MapsTo f s t\nhsx : sorry\n\u22a2 derivWithin (l \u2218 f) s x = (fderivWithin \ud835\udd5c l t (f x)) (derivWithin f s x)\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nl : F \u2192 E\nt : Set F\nhl : DifferentiableWithinAt \ud835\udd5c l t (f x)\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhs : MapsTo f s t\nhsx : \u00acsorry\n\u22a2 derivWithin (l \u2218 f) s x = (fderivWithin \ud835\udd5c l t (f x)) (derivWithin f s x)"}, {"line": "\u00b7 exact (hl.hasFDerivWithinAt.comp_hasDerivWithinAt x hf.hasDerivWithinAt hs).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nl : F \u2192 E\nt : Set F\nhl : DifferentiableWithinAt \ud835\udd5c l t (f x)\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhs : MapsTo f s t\nhsx : \u00acsorry\n\u22a2 derivWithin (l \u2218 f) s x = (fderivWithin \ud835\udd5c l t (f x)) (derivWithin f s x)"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_ratio_hasDerivAt_eq_ratio_slope :\n    \u2203 c \u2208 Ioo a b, (g b - g a) * f' c = (f b - f a) * g' c := by\n  let h x := (g b - g a) * f x - (f b - f a) * g x\n  have hI : h a = h b := by simp only [h]; ring\n  let h' x := (g b - g a) * f' x - (f b - f a) * g' x\n  have hhh' : \u2200 x \u2208 Ioo a b, HasDerivAt h (h' x) x := fun x hx =>\n    ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))\n  have hhc : ContinuousOn h (Icc a b) :=\n    (continuousOn_const.mul hfc).sub (continuousOn_const.mul hgc)\n  rcases exists_hasDerivAt_eq_zero hab hhc hI hhh' with \u27e8c, cmem, hc\u27e9\n  exact \u27e8c, cmem, sub_eq_zero.1 hc\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/MeanValue.lean", "context": {"open": ["Set Function Filter", "scoped Topology"], "variables": ["(f f' : \u211d \u2192 \u211d) {a b : \u211d} (hab : a < b) (hfc : ContinuousOn f (Icc a b))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "let h x := (g b - g a) * f x - (f b - f a) * g x", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "have hI : h a = h b := by simp only [h]; ring", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\nhI : h a = h b\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "let h' x := (g b - g a) * f' x - (f b - f a) * g' x", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\nhI : h a = h b\nh' : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f' x - (f b - f a) * sorry\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "have hhh' : \u2200 x \u2208 Ioo a b, HasDerivAt h (h' x) x := fun x hx =>\n    ((hff' x hx).const_mul (g b - g a)).sub ((hgg' x hx).const_mul (f b - f a))", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\nhI : h a = h b\nh' : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f' x - (f b - f a) * sorry\nhhh' : \u2200 x \u2208 Ioo a b, HasDerivAt h (h' x) x\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "have hhc : ContinuousOn h (Icc a b) :=\n    (continuousOn_const.mul hfc).sub (continuousOn_const.mul hgc)", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\nhI : h a = h b\nh' : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f' x - (f b - f a) * sorry\nhhh' : \u2200 x \u2208 Ioo a b, HasDerivAt h (h' x) x\nhhc : ContinuousOn h (Icc a b)\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "rcases exists_hasDerivAt_eq_zero hab hhc hI hhh' with \u27e8c, cmem, hc\u27e9", "tactic_state": "case intro.intro\nf f' : \u211d \u2192 \u211d\na b : \u211d\nx\u271d\u00b9 : Sort u_1\ng : x\u271d\u00b9\nx\u271d : Sort u_2\ng' : x\u271d\nh : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f x - (f b - f a) * sorry\nhI : h a = h b\nh' : \u211d \u2192 \u211d := fun x => (sorry - sorry) * f' x - (f b - f a) * sorry\nhhh' : \u2200 x \u2208 Ioo a b, HasDerivAt h (h' x) x\nhhc : ContinuousOn h (Icc a b)\nc : \u211d\ncmem : c \u2208 Ioo a b\nhc : h' c = 0\n\u22a2 \u2203 c \u2208 Ioo a b, (sorry - sorry) * f' c = (f b - f a) * sorry"}, {"line": "exact \u27e8c, cmem, sub_eq_zero.1 hc\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_hasDerivAt_eq_slope : \u2203 c \u2208 Ioo a b, f' c = (f b - f a) / (b - a) := by\n  obtain \u27e8c, cmem, hc\u27e9 : \u2203 c \u2208 Ioo a b, (b - a) * f' c = (f b - f a) * 1 :=\n    exists_ratio_hasDerivAt_eq_ratio_slope f f' hab hfc hff' id 1 continuousOn_id\n      fun x _ => hasDerivAt_id x\n  use c, cmem\n  rwa [mul_one, mul_comm, \u2190 eq_div_iff (sub_ne_zero.2 hab.ne')] at hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/MeanValue.lean", "context": {"open": ["Set Function Filter", "scoped Topology"], "variables": ["(f f' : \u211d \u2192 \u211d) {a b : \u211d} (hab : a < b) (hfc : ContinuousOn f (Icc a b))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f f' : \u211d \u2192 \u211d\na b : \u211d\n\u22a2 \u2203 c \u2208 Ioo a b, f' c = (f b - f a) / (b - a)"}, {"line": "obtain \u27e8c, cmem, hc\u27e9 : \u2203 c \u2208 Ioo a b, (b - a) * f' c = (f b - f a) * 1 :=\n    exists_ratio_hasDerivAt_eq_ratio_slope f f' hab hfc hff' id 1 continuousOn_id\n      fun x _ => hasDerivAt_id x", "tactic_state": "case intro.intro\nf f' : \u211d \u2192 \u211d\na b c : \u211d\ncmem : c \u2208 Ioo a b\nhc : (b - a) * f' c = (f b - f a) * 1\n\u22a2 \u2203 c \u2208 Ioo a b, f' c = (f b - f a) / (b - a)"}, {"line": "use c, cmem", "tactic_state": "case right\nf f' : \u211d \u2192 \u211d\na b c : \u211d\ncmem : c \u2208 Ioo a b\nhc : (b - a) * f' c = (f b - f a) * 1\n\u22a2 f' c = (f b - f a) / (b - a)"}, {"line": "rwa [mul_one, mul_comm, \u2190 eq_div_iff (sub_ne_zero.2 hab.ne')] at hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Convex.mul_sub_lt_image_sub_of_lt_deriv {D : Set \u211d} (hD : Convex \u211d D) {f : \u211d \u2192 \u211d}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn \u211d f (interior D)) {C}\n    (hf'_gt : \u2200 x \u2208 interior D, C < deriv f x) :\n    \u2200\u1d49 (x \u2208 D) (y \u2208 D), x < y \u2192 C * (y - x) < f y - f x := by\n  intro x hx y hy hxy\n  have hxyD : Icc x y \u2286 D := hD.ordConnected.out hx hy\n  have hxyD' : Ioo x y \u2286 interior D :=\n    subset_sUnion_of_mem \u27e8isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD\u27e9\n  obtain \u27e8a, a_mem, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy (hf.mono hxyD) (hf'.mono hxyD')\n  have : C < (f y - f x) / (y - x) := ha \u25b8 hf'_gt _ (hxyD' a_mem)\n  exact (lt_div_iff\u2080 (sub_pos.2 hxy)).1 this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/MeanValue.lean", "context": {"open": ["Set Function Filter", "scoped Topology"], "variables": ["(f f' : \u211d \u2192 \u211d) {a b : \u211d} (hab : a < b) (hfc : ContinuousOn f (Icc a b))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\n\u22a2 \u2200 x \u2208 D, \u2200 y \u2208 D, x < y \u2192 C * (y - x) < f y - f x"}, {"line": "intro x hx y hy hxy", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x < y\n\u22a2 C * (y - x) < f y - f x"}, {"line": "have hxyD : Icc x y \u2286 D := hD.ordConnected.out hx hy", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x < y\nhxyD : Icc x y \u2286 D\n\u22a2 C * (y - x) < f y - f x"}, {"line": "have hxyD' : Ioo x y \u2286 interior D :=\n    subset_sUnion_of_mem \u27e8isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD\u27e9", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\n\u22a2 C * (y - x) < f y - f x"}, {"line": "obtain \u27e8a, a_mem, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy (hf.mono hxyD) (hf'.mono hxyD')", "tactic_state": "case intro.intro\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\na : \u211d\na_mem : a \u2208 Ioo x y\nha : deriv f a = (f y - f x) / (y - x)\n\u22a2 C * (y - x) < f y - f x"}, {"line": "have : C < (f y - f x) / (y - x) := ha \u25b8 hf'_gt _ (hxyD' a_mem)", "tactic_state": "case intro.intro\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_gt : \u2200 x \u2208 interior D, C < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\na : \u211d\na_mem : a \u2208 Ioo x y\nha : deriv f a = (f y - f x) / (y - x)\nthis : C < (f y - f x) / (y - x)\n\u22a2 C * (y - x) < f y - f x"}, {"line": "exact (lt_div_iff\u2080 (sub_pos.2 hxy)).1 this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Convex.mul_sub_le_image_sub_of_le_deriv {D : Set \u211d} (hD : Convex \u211d D) {f : \u211d \u2192 \u211d}\n    (hf : ContinuousOn f D) (hf' : DifferentiableOn \u211d f (interior D)) {C}\n    (hf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x) :\n    \u2200\u1d49 (x \u2208 D) (y \u2208 D), x \u2264 y \u2192 C * (y - x) \u2264 f y - f x := by\n  intro x hx y hy hxy\n  rcases eq_or_lt_of_le hxy with hxy' | hxy'\n  \u00b7 rw [hxy', sub_self, sub_self, mul_zero]\n  have hxyD : Icc x y \u2286 D := hD.ordConnected.out hx hy\n  have hxyD' : Ioo x y \u2286 interior D :=\n    subset_sUnion_of_mem \u27e8isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD\u27e9\n  obtain \u27e8a, a_mem, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy' (hf.mono hxyD) (hf'.mono hxyD')\n  have : C \u2264 (f y - f x) / (y - x) := ha \u25b8 hf'_ge _ (hxyD' a_mem)\n  exact (le_div_iff\u2080 (sub_pos.2 hxy')).1 this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/MeanValue.lean", "context": {"open": ["Set Function Filter", "scoped Topology"], "variables": ["(f f' : \u211d \u2192 \u211d) {a b : \u211d} (hab : a < b) (hfc : ContinuousOn f (Icc a b))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\n\u22a2 \u2200 x \u2208 D, \u2200 y \u2208 D, x \u2264 y \u2192 C * (y - x) \u2264 f y - f x"}, {"line": "intro x hx y hy hxy", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "rcases eq_or_lt_of_le hxy with hxy' | hxy'", "tactic_state": "case inl\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x = y\n\u22a2 C * (y - x) \u2264 f y - f x\n---\ncase inr\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "\u00b7 rw [hxy', sub_self, sub_self, mul_zero]", "tactic_state": "case inr\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "have hxyD : Icc x y \u2286 D := hD.ordConnected.out hx hy", "tactic_state": "case inr\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\nhxyD : Icc x y \u2286 D\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "have hxyD' : Ioo x y \u2286 interior D :=\n    subset_sUnion_of_mem \u27e8isOpen_Ioo, Ioo_subset_Icc_self.trans hxyD\u27e9", "tactic_state": "case inr\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "obtain \u27e8a, a_mem, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy' (hf.mono hxyD) (hf'.mono hxyD')", "tactic_state": "case inr.intro.intro\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\na : \u211d\na_mem : a \u2208 Ioo x y\nha : deriv f a = (f y - f x) / (y - x)\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "have : C \u2264 (f y - f x) / (y - x) := ha \u25b8 hf'_ge _ (hxyD' a_mem)", "tactic_state": "case inr.intro.intro\nD : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : DifferentiableOn \u211d f (interior D)\nC : \u211d\nhf'_ge : \u2200 x \u2208 interior D, C \u2264 deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nhxy : x \u2264 y\nhxy' : x < y\nhxyD : Icc x y \u2286 D\nhxyD' : Ioo x y \u2286 interior D\na : \u211d\na_mem : a \u2208 Ioo x y\nha : deriv f a = (f y - f x) / (y - x)\nthis : C \u2264 (f y - f x) / (y - x)\n\u22a2 C * (y - x) \u2264 f y - f x"}, {"line": "exact (le_div_iff\u2080 (sub_pos.2 hxy')).1 this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMonoOn_of_deriv_pos {D : Set \u211d} (hD : Convex \u211d D) {f : \u211d \u2192 \u211d}\n    (hf : ContinuousOn f D) (hf' : \u2200 x \u2208 interior D, 0 < deriv f x) : StrictMonoOn f D := by\n  intro x hx y hy\n  have : DifferentiableOn \u211d f (interior D) := fun z hz =>\n    (differentiableAt_of_deriv_ne_zero (hf' z hz).ne').differentiableWithinAt\n  simpa only [zero_mul,sub_pos] using\n    hD.mul_sub_lt_image_sub_of_lt_deriv hf this hf' x hx y hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/MeanValue.lean", "context": {"open": ["Set Function Filter", "scoped Topology"], "variables": ["(f f' : \u211d \u2192 \u211d) {a b : \u211d} (hab : a < b) (hfc : ContinuousOn f (Icc a b))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : \u2200 x \u2208 interior D, 0 < deriv f x\n\u22a2 StrictMonoOn f D"}, {"line": "intro x hx y hy", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : \u2200 x \u2208 interior D, 0 < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\n\u22a2 x < y \u2192 f x < f y"}, {"line": "have : DifferentiableOn \u211d f (interior D) := fun z hz =>\n    (differentiableAt_of_deriv_ne_zero (hf' z hz).ne').differentiableWithinAt", "tactic_state": "D : Set \u211d\nhD : Convex \u211d D\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f D\nhf' : \u2200 x \u2208 interior D, 0 < deriv f x\nx : \u211d\nhx : x \u2208 D\ny : \u211d\nhy : y \u2208 D\nthis : DifferentiableOn \u211d f (interior D)\n\u22a2 x < y \u2192 f x < f y"}, {"line": "simpa only [zero_mul,sub_pos] using\n    hD.mul_sub_lt_image_sub_of_lt_deriv hf this hf' x hx y hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_of_bilinear\n    (hu : HasDerivWithinAt u u' s x) (hv : HasDerivWithinAt v v' s x) :\n    HasDerivWithinAt (fun x \u21a6 B (u x) (v x)) (B (u x) v' + B u' (v x)) s x := by\n  simpa using (B.hasFDerivWithinAt_of_bilinear\n    hu.hasFDerivWithinAt hv.hasFDerivWithinAt).hasDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nu' : E\nv' : F\nhu : HasDerivWithinAt u u' s x\nhv : HasDerivWithinAt v v' s x\n\u22a2 HasDerivWithinAt (fun x => (B (u x)) (v x)) ((B (u x)) v' + (B u') (v x)) s x"}, {"line": "simpa using (B.hasFDerivWithinAt_of_bilinear\n    hu.hasFDerivWithinAt hv.hasFDerivWithinAt).hasDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_of_bilinear (hu : HasDerivAt u u' x) (hv : HasDerivAt v v' x) :\n    HasDerivAt (fun x \u21a6 B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using (B.hasFDerivAt_of_bilinear hu.hasFDerivAt hv.hasFDerivAt).hasDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nu' : E\nv' : F\nhu : HasDerivAt u u' x\nhv : HasDerivAt v v' x\n\u22a2 HasDerivAt (fun x => (B (u x)) (v x)) ((B (u x)) v' + (B u') (v x)) x"}, {"line": "simpa using (B.hasFDerivAt_of_bilinear hu.hasFDerivAt hv.hasFDerivAt).hasDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictDerivAt_of_bilinear (hu : HasStrictDerivAt u u' x) (hv : HasStrictDerivAt v v' x) :\n    HasStrictDerivAt (fun x \u21a6 B (u x) (v x)) (B (u x) v' + B u' (v x)) x := by\n  simpa using\n    (B.hasStrictFDerivAt_of_bilinear hu.hasStrictFDerivAt hv.hasStrictFDerivAt).hasStrictDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nu' : E\nv' : F\nhu : HasStrictDerivAt u u' x\nhv : HasStrictDerivAt v v' x\n\u22a2 HasStrictDerivAt (fun x => (B (u x)) (v x)) ((B (u x)) v' + (B u') (v x)) x"}, {"line": "simpa using\n    (B.hasStrictFDerivAt_of_bilinear hu.hasStrictFDerivAt hv.hasStrictFDerivAt).hasStrictDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_of_bilinear\n    (hu : DifferentiableWithinAt \ud835\udd5c u s x) (hv : DifferentiableWithinAt \ud835\udd5c v s x) :\n    derivWithin (fun y => B (u y) (v y)) s x =\n      B (u x) (derivWithin v s x) + B (derivWithin u s x) (v x) := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (B.hasDerivWithinAt_of_bilinear hu.hasDerivWithinAt hv.hasDerivWithinAt).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nhu : DifferentiableWithinAt \ud835\udd5c u s x\nhv : DifferentiableWithinAt \ud835\udd5c v s x\n\u22a2 derivWithin (fun y => (B (u y)) (v y)) s x = (B (u x)) (derivWithin v s x) + (B (derivWithin u s x)) (v x)"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nhu : DifferentiableWithinAt \ud835\udd5c u s x\nhv : DifferentiableWithinAt \ud835\udd5c v s x\nhsx : sorry\n\u22a2 derivWithin (fun y => (B (u y)) (v y)) s x = (B (u x)) (derivWithin v s x) + (B (derivWithin u s x)) (v x)\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nhu : DifferentiableWithinAt \ud835\udd5c u s x\nhv : DifferentiableWithinAt \ud835\udd5c v s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => (B (u y)) (v y)) s x = (B (u x)) (derivWithin v s x) + (B (derivWithin u s x)) (v x)"}, {"line": "\u00b7 exact (B.hasDerivWithinAt_of_bilinear hu.hasDerivWithinAt hv.hasDerivWithinAt).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nE : Type w\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nG : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nu : \ud835\udd5c \u2192 E\nv : \ud835\udd5c \u2192 F\nhu : DifferentiableWithinAt \ud835\udd5c u s x\nhv : DifferentiableWithinAt \ud835\udd5c v s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => (B (u y)) (v y)) s x = (B (u x)) (derivWithin v s x) + (B (derivWithin u s x)) (v x)"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_const_smul (c : R) (hf : DifferentiableWithinAt \ud835\udd5c f s x) :\n    derivWithin (fun y => c \u2022 f y) s x = c \u2022 derivWithin f s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hf.hasDerivWithinAt.const_smul c).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nR : Type u_3\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Module R F\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c R F\ninst\u271d : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt \ud835\udd5c f s x\n\u22a2 derivWithin (fun y => c \u2022 f y) s x = c \u2022 derivWithin f s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nR : Type u_3\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Module R F\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c R F\ninst\u271d : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhsx : sorry\n\u22a2 derivWithin (fun y => c \u2022 f y) s x = c \u2022 derivWithin f s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nR : Type u_3\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Module R F\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c R F\ninst\u271d : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c \u2022 f y) s x = c \u2022 derivWithin f s x"}, {"line": "\u00b7 exact (hf.hasDerivWithinAt.const_smul c).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nR : Type u_3\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : Module R F\ninst\u271d\u00b9 : SMulCommClass \ud835\udd5c R F\ninst\u271d : ContinuousConstSMul R F\nc : R\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c \u2022 f y) s x = c \u2022 derivWithin f s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.mul_const (hc : HasDerivAt c c' x) (d : \ud835\udd38) :\n    HasDerivAt (fun y => c y * d) (c' * d) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hc.mul_const d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nc' : \ud835\udd38\nhc : HasDerivAt c c' x\nd : \ud835\udd38\n\u22a2 HasDerivAt (fun y => c y * d) (c' * d) x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nc' : \ud835\udd38\nhc : HasDerivWithinAt c c' univ x\nd : \ud835\udd38\n\u22a2 HasDerivWithinAt (fun y => c y * d) (c' * d) univ x"}, {"line": "exact hc.mul_const d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_mul_const (c : \ud835\udd5c) : HasDerivAt (fun x => x * c) c x := by\n  simpa only [one_mul] using (hasDerivAt_id' x).mul_const c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nx c : \ud835\udd5c\n\u22a2 HasDerivAt (fun x => x * c) c x"}, {"line": "simpa only [one_mul] using (hasDerivAt_id' x).mul_const c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_mul_const (hc : DifferentiableWithinAt \ud835\udd5c c s x) (d : \ud835\udd38) :\n    derivWithin (fun y => c y * d) s x = derivWithin c s x * d := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hc.hasDerivWithinAt.mul_const d).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nd : \ud835\udd38\n\u22a2 derivWithin (fun y => c y * d) s x = derivWithin c s x * d"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nd : \ud835\udd38\nhsx : sorry\n\u22a2 derivWithin (fun y => c y * d) s x = derivWithin c s x * d\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nd : \ud835\udd38\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c y * d) s x = derivWithin c s x * d"}, {"line": "\u00b7 exact (hc.hasDerivWithinAt.mul_const d).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nc : \ud835\udd5c \u2192 \ud835\udd38\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nd : \ud835\udd38\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c y * d) s x = derivWithin c s x * d"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.const_mul (c : \ud835\udd38) (hd : HasDerivAt d d' x) :\n    HasDerivAt (fun y => c * d y) (c * d') x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hd.const_mul c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nd' c : \ud835\udd38\nhd : HasDerivAt d d' x\n\u22a2 HasDerivAt (fun y => c * d y) (c * d') x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nd' c : \ud835\udd38\nhd : HasDerivWithinAt d d' univ x\n\u22a2 HasDerivWithinAt (fun y => c * d y) (c * d') univ x"}, {"line": "exact hd.const_mul c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derivWithin_const_mul (c : \ud835\udd38) (hd : DifferentiableWithinAt \ud835\udd5c d s x) :\n    derivWithin (fun y => c * d y) s x = c * derivWithin d s x := by\n  by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact (hd.hasDerivWithinAt.const_mul c).derivWithin hsx\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nc : \ud835\udd38\nhd : DifferentiableWithinAt \ud835\udd5c d s x\n\u22a2 derivWithin (fun y => c * d y) s x = c * derivWithin d s x"}, {"line": "by_cases hsx : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nc : \ud835\udd38\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhsx : sorry\n\u22a2 derivWithin (fun y => c * d y) s x = c * derivWithin d s x\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nc : \ud835\udd38\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c * d y) s x = c * derivWithin d s x"}, {"line": "\u00b7 exact (hd.hasDerivWithinAt.const_mul c).derivWithin hsx", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd38 : Type u_5\ninst\u271d\u00b9 : NormedRing \ud835\udd38\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd38\nd : \ud835\udd5c \u2192 \ud835\udd38\nc : \ud835\udd38\nhd : DifferentiableWithinAt \ud835\udd5c d s x\nhsx : \u00acsorry\n\u22a2 derivWithin (fun y => c * d y) s x = c * derivWithin d s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.div_const (hc : HasDerivAt c c' x) (d : \ud835\udd5c') :\n    HasDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]", "{\u03b9 : Type*} [DecidableEq \u03b9] {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\u03b9 : Type*} {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'} {c' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_10\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc : \ud835\udd5c \u2192 \ud835\udd5c'\nc' : \ud835\udd5c'\nhc : HasDerivAt c c' x\nd : \ud835\udd5c'\n\u22a2 HasDerivAt (fun x => c x / d) (c' / d) x"}, {"line": "simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.div_const (hc : HasDerivWithinAt c c' s x) (d : \ud835\udd5c') :\n    HasDerivWithinAt (fun x => c x / d) (c' / d) s x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]", "{\u03b9 : Type*} [DecidableEq \u03b9] {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\u03b9 : Type*} {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'} {c' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\ns : Set \ud835\udd5c\n\ud835\udd5c' : Type u_10\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc : \ud835\udd5c \u2192 \ud835\udd5c'\nc' : \ud835\udd5c'\nhc : HasDerivWithinAt c c' s x\nd : \ud835\udd5c'\n\u22a2 HasDerivWithinAt (fun x => c x / d) (c' / d) s x"}, {"line": "simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.div_const (hc : HasStrictDerivAt c c' x) (d : \ud835\udd5c') :\n    HasStrictDerivAt (fun x => c x / d) (c' / d) x := by\n  simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]", "{\u03b9 : Type*} [DecidableEq \u03b9] {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\u03b9 : Type*} {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'} {c' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_10\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc : \ud835\udd5c \u2192 \ud835\udd5c'\nc' : \ud835\udd5c'\nhc : HasStrictDerivAt c c' x\nd : \ud835\udd5c'\n\u22a2 HasStrictDerivAt (fun x => c x / d) (c' / d) x"}, {"line": "simpa only [div_eq_mul_inv] using hc.mul_const d\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_div_const (d : \ud835\udd5c') : deriv (fun x => c x / d) x = deriv c x / d := by\n  simp only [div_eq_mul_inv]\n  simp only [deriv_mul_const_field]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Mul.lean", "context": {"open": ["scoped Topology Filter ENNReal", "Filter Asymptotics Set", "ContinuousLinearMap (smulRight smulRight_one_eq_iff)"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{E : Type w} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{L : Filter \ud835\udd5c}", "{B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G} {u : \ud835\udd5c \u2192 E} {v : \ud835\udd5c \u2192 F} {u' : E} {v' : F}", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\ud835\udd5c' \ud835\udd38 : Type*} [NormedField \ud835\udd5c'] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd38]", "{\u03b9 : Type*} [DecidableEq \u03b9] {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\u03b9 : Type*} {\ud835\udd38' : Type*} [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] {c : \ud835\udd5c \u2192 \ud835\udd5c'} {c' : \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_10\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc : \ud835\udd5c \u2192 \ud835\udd5c'\nd : \ud835\udd5c'\n\u22a2 deriv (fun x => c x / d) x = deriv c x / d"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nx : \ud835\udd5c\n\ud835\udd5c' : Type u_10\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nc : \ud835\udd5c \u2192 \ud835\udd5c'\nd : \ud835\udd5c'\n\u22a2 deriv (fun x => c x * d\u207b\u00b9) x = deriv c x * d\u207b\u00b9"}, {"line": "simp only [deriv_mul_const_field]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivWithinAt_iff_tendsto_slope' (hs : x \u2209 s) :\n    HasDerivWithinAt f f' s x \u2194 Tendsto (slope f x) (\ud835\udcdd[s] x) (\ud835\udcdd f') := by\n  rw [hasDerivWithinAt_iff_tendsto_slope]\n  rw [diff_singleton_eq_self hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Slope.lean", "context": {"open": ["scoped Topology", "Filter TopologicalSpace Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhs : x \u2209 s\n\u22a2 HasDerivWithinAt f f' s x \u2194 Tendsto (slope f x) (nhdsWithin x s) (nhds f')"}, {"line": "rw [hasDerivWithinAt_iff_tendsto_slope]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nf' : F\nx : \ud835\udd5c\ns : Set \ud835\udd5c\nhs : x \u2209 s\n\u22a2 Tendsto (slope f x) (nhdsWithin x (s \\ {x})) (nhds f') \u2194 Tendsto (slope f x) (nhdsWithin x s) (nhds f')"}, {"line": "rw [diff_singleton_eq_self hs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparable_range_deriv [SeparableSpace \ud835\udd5c] (f : \ud835\udd5c \u2192 F) :\n    IsSeparable (range (deriv f)) := by\n  rw [\u2190 derivWithin_univ]\n  exact isSeparable_range_derivWithin _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Slope.lean", "context": {"open": ["scoped Topology", "Filter TopologicalSpace Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SeparableSpace \ud835\udd5c\nf : \ud835\udd5c \u2192 F\n\u22a2 TopologicalSpace.IsSeparable (range (deriv f))"}, {"line": "rw [\u2190 derivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\ninst\u271d : SeparableSpace \ud835\udd5c\nf : \ud835\udd5c \u2192 F\n\u22a2 TopologicalSpace.IsSeparable (range (derivWithin f univ))"}, {"line": "exact isSeparable_range_derivWithin _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasDerivAt.continuousAt_div [DecidableEq \ud835\udd5c] {f : \ud835\udd5c \u2192 \ud835\udd5c} {c a : \ud835\udd5c} (hf : HasDerivAt f a c) :\n    ContinuousAt (Function.update (fun x \u21a6 (f x - f c) / (x - c)) c a) c := by\n  rw [\u2190 slope_fun_def_field]\n  exact continuousAt_update_same.mpr <| hasDerivAt_iff_tendsto_slope.mp hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Slope.lean", "context": {"open": ["scoped Topology", "Filter TopologicalSpace Set"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : \ud835\udd5c \u2192 F}", "{f' : F}", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d : DecidableEq \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nc a : \ud835\udd5c\nhf : HasDerivAt f a c\n\u22a2 ContinuousAt (Function.update (fun x => (f x - f c) / (x - c)) c a) c"}, {"line": "rw [\u2190 slope_fun_def_field]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\ninst\u271d : DecidableEq \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nc a : \ud835\udd5c\nhf : HasDerivAt f a c\n\u22a2 ContinuousAt (Function.update (slope f c) c a) c"}, {"line": "exact continuousAt_update_same.mpr <| hasDerivAt_iff_tendsto_slope.mp hf", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem derivWithin.star :\n    derivWithin (fun y => star (f y)) s x = star (derivWithin f s x) := by\n  by_cases hxs : UniqueDiffWithinAt \ud835\udd5c s x\n  \u00b7 exact DFunLike.congr_fun (fderivWithin_star hxs) _\n  \u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hxs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Star.lean", "context": {"open": [], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : \ud835\udd5c \u2192 F}", "[StarRing \ud835\udd5c] [TrivialStar \ud835\udd5c] [StarAddMonoid F] [ContinuousStar F]", "[StarModule \ud835\udd5c F] {f' : F} {s : Set \ud835\udd5c} {x : \ud835\udd5c} {L : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : TrivialStar \ud835\udd5c\ninst\u271d\u00b2 : StarAddMonoid F\ninst\u271d\u00b9 : ContinuousStar F\ninst\u271d : StarModule \ud835\udd5c F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 derivWithin (fun y => star (f y)) s x = star (derivWithin f s x)"}, {"line": "by_cases hxs : UniqueDiffWithinAt \ud835\udd5c s x", "tactic_state": "case pos\n\ud835\udd5c : Type u\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : TrivialStar \ud835\udd5c\ninst\u271d\u00b2 : StarAddMonoid F\ninst\u271d\u00b9 : ContinuousStar F\ninst\u271d : StarModule \ud835\udd5c F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhxs : sorry\n\u22a2 derivWithin (fun y => star (f y)) s x = star (derivWithin f s x)\n---\ncase neg\n\ud835\udd5c : Type u\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : TrivialStar \ud835\udd5c\ninst\u271d\u00b2 : StarAddMonoid F\ninst\u271d\u00b9 : ContinuousStar F\ninst\u271d : StarModule \ud835\udd5c F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhxs : \u00acsorry\n\u22a2 derivWithin (fun y => star (f y)) s x = star (derivWithin f s x)"}, {"line": "\u00b7 exact DFunLike.congr_fun (fderivWithin_star hxs) _", "tactic_state": "case neg\n\ud835\udd5c : Type u\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nF : Type v\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ninst\u271d\u2074 : StarRing \ud835\udd5c\ninst\u271d\u00b3 : TrivialStar \ud835\udd5c\ninst\u271d\u00b2 : StarAddMonoid F\ninst\u271d\u00b9 : ContinuousStar F\ninst\u271d : StarModule \ud835\udd5c F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhxs : \u00acsorry\n\u22a2 derivWithin (fun y => star (f y)) s x = star (derivWithin f s x)"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_uniqueDiffWithinAt hxs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_deriv_subset : support (deriv f) \u2286 tsupport f := by\n  intro x\n  rw [\u2190 not_imp_not]\n  intro h2x\n  rw [not_mem_tsupport_iff_eventuallyEq] at h2x\n  exact nmem_support.mpr (h2x.deriv_eq.trans (deriv_const x 0))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/Support.lean", "context": {"open": ["Function"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{E : Type v} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{f : \ud835\udd5c \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\n\u22a2 support (deriv f) \u2286 tsupport f"}, {"line": "intro x", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\n\u22a2 x \u2208 support (deriv f) \u2192 x \u2208 tsupport f"}, {"line": "rw [\u2190 not_imp_not]", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\n\u22a2 x \u2209 tsupport f \u2192 x \u2209 support (deriv f)"}, {"line": "intro h2x", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh2x : x \u2209 tsupport f\n\u22a2 x \u2209 support (deriv f)"}, {"line": "rw [not_mem_tsupport_iff_eventuallyEq] at h2x", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type v\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh2x : f =\u1da0[nhds x] 0\n\u22a2 x \u2209 support (deriv f)"}, {"line": "exact nmem_support.mpr (h2x.deriv_eq.trans (deriv_const x 0))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iter_deriv_zpow' (m : \u2124) (k : \u2115) :\n    (deriv^[k] fun x : \ud835\udd5c => x ^ m) =\n      fun x => (\u220f i \u2208 Finset.range k, ((m : \ud835\udd5c) - i)) * x ^ (m - k) := by\n  induction' k with k ihk\n  \u00b7 simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero,\n      Function.iterate_zero]\n  \u00b7 simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow',\n      Finset.prod_range_succ, Int.natCast_succ, \u2190 sub_sub, Int.cast_sub, Int.cast_natCast,\n      mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Deriv/ZPow.lean", "context": {"open": ["Topology Filter Asymptotics Set", "scoped Nat"], "variables": ["{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c]", "{E : Type v} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{x : \ud835\udd5c}", "{s : Set \ud835\udd5c}", "{m : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm : \u2124\nk : \u2115\n\u22a2 (deriv^[k] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range k, (\u2191m - \u2191i)) * x ^ (m - \u2191k)"}, {"line": "induction' k with k ihk", "tactic_state": "case zero\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm : \u2124\n\u22a2 (deriv^[0] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range 0, (\u2191m - \u2191i)) * x ^ (m - \u21910)\n---\ncase succ\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm : \u2124\nk : \u2115\nihk : (deriv^[k] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range k, (\u2191m - \u2191i)) * x ^ (m - \u2191k)\n\u22a2 (deriv^[k + 1] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range (k + 1), (\u2191m - \u2191i)) * x ^ (m - \u2191(k + 1))"}, {"line": "\u00b7 simp only [one_mul, Int.ofNat_zero, id, sub_zero, Finset.prod_range_zero,\n      Function.iterate_zero]", "tactic_state": "case succ\n\ud835\udd5c : Type u\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm : \u2124\nk : \u2115\nihk : (deriv^[k] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range k, (\u2191m - \u2191i)) * x ^ (m - \u2191k)\n\u22a2 (deriv^[k + 1] fun x => x ^ m) = fun x => (\u220f i \u2208 Finset.range (k + 1), (\u2191m - \u2191i)) * x ^ (m - \u2191(k + 1))"}, {"line": "\u00b7 simp only [Function.iterate_succ_apply', ihk, deriv_const_mul_field', deriv_zpow',\n      Finset.prod_range_succ, Int.natCast_succ, \u2190 sub_sub, Int.cast_sub, Int.cast_natCast,\n      mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousLinearMap.hasFDerivWithinAt_of_bilinear {f : G' \u2192 E} {g : G' \u2192 F}\n    {f' : G' \u2192L[\ud835\udd5c] E} {g' : G' \u2192L[\ud835\udd5c] F} {x : G'} {s : Set G'} (hf : HasFDerivWithinAt f f' s x)\n    (hg : HasFDerivWithinAt g g' s x) :\n    HasFDerivWithinAt (fun y => B (f y) (g y))\n      (B.precompR G' (f x) g' + B.precompL G' f' (g x)) s x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp_hasFDerivWithinAt x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean", "context": {"open": ["Asymptotics Topology", "NormedField"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{b : E \u00d7 F \u2192 G} {u : Set (E \u00d7 F)}", "(B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nf : G' \u2192 E\ng : G' \u2192 F\nf' : G' \u2192L[\ud835\udd5c] E\ng' : G' \u2192L[\ud835\udd5c] F\nx : G'\ns : Set G'\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\n\u22a2 HasFDerivWithinAt (fun y => (B (f y)) (g y)) (((precompR G' B) (f x)) g' + ((precompL G' B) f') (g x)) s x"}, {"line": "exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp_hasFDerivWithinAt x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousLinearMap.hasFDerivAt_of_bilinear {f : G' \u2192 E} {g : G' \u2192 F} {f' : G' \u2192L[\ud835\udd5c] E}\n    {g' : G' \u2192L[\ud835\udd5c] F} {x : G'} (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) :\n    HasFDerivAt (fun y => B (f y) (g y)) (B.precompR G' (f x) g' + B.precompL G' f' (g x)) x := by\n  exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Bilinear.lean", "context": {"open": ["Asymptotics Topology", "NormedField"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{b : E \u00d7 F \u2192 G} {u : Set (E \u00d7 F)}", "(B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nB : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nf : G' \u2192 E\ng : G' \u2192 F\nf' : G' \u2192L[\ud835\udd5c] E\ng' : G' \u2192L[\ud835\udd5c] F\nx : G'\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\n\u22a2 HasFDerivAt (fun y => (B (f y)) (g y)) (((precompR G' B) (f x)) g' + ((precompL G' B) f') (g x)) x"}, {"line": "exact (B.isBoundedBilinearMap.hasFDerivAt (f x, g x)).comp x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contDiffAt_norm_smul_iff (ht : t \u2260 0) :\n    ContDiffAt \u211d n (\u2016\u00b7\u2016) x \u2194 ContDiffAt \u211d n (\u2016\u00b7\u2016) (t \u2022 x) where\n  mp h := h.contDiffAt_norm_smul ht\n  mpr hd := by\n    convert hd.contDiffAt_norm_smul (inv_ne_zero ht)\n    rw [smul_smul]\n    rw [inv_mul_cancel\u2080 ht]\n    rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nn : WithTop \u2115\u221e\nx : E\nt : \u211d\nht : t \u2260 0\nhd : ContDiffAt \u211d n (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 ContDiffAt \u211d n (fun x => \u2016x\u2016) x"}, {"line": "convert hd.contDiffAt_norm_smul (inv_ne_zero ht)", "tactic_state": "case h.e'_11\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nn : WithTop \u2115\u221e\nx : E\nt : \u211d\nht : t \u2260 0\nhd : ContDiffAt \u211d n (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = t\u207b\u00b9 \u2022 t \u2022 x"}, {"line": "rw [smul_smul]", "tactic_state": "case h.e'_11\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nn : WithTop \u2115\u221e\nx : E\nt : \u211d\nht : t \u2260 0\nhd : ContDiffAt \u211d n (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = (t\u207b\u00b9 * t) \u2022 x"}, {"line": "rw [inv_mul_cancel\u2080 ht]", "tactic_state": "case h.e'_11\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nn : WithTop \u2115\u221e\nx : E\nt : \u211d\nht : t \u2260 0\nhd : ContDiffAt \u211d n (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = 1 \u2022 x"}, {"line": "rw [one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictFDerivAt.hasStrictDerivAt_norm_smul_neg\n    (ht : t < 0) (h : HasStrictFDerivAt (\u2016\u00b7\u2016) f x) :\n    HasStrictFDerivAt (\u2016\u00b7\u2016) (-f) (t \u2022 x) := by\n  simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192L[\u211d] \u211d\nx : E\nt : \u211d\nht : t < 0\nh : HasStrictFDerivAt (fun x => \u2016x\u2016) f x\n\u22a2 HasStrictFDerivAt (fun x => \u2016x\u2016) (-f) (t \u2022 x)"}, {"line": "simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictFDerivAt.hasStrictDerivAt_norm_smul_pos\n    (ht : 0 < t) (h : HasStrictFDerivAt (\u2016\u00b7\u2016) f x) :\n    HasStrictFDerivAt (\u2016\u00b7\u2016) f (t \u2022 x) := by\n  simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192L[\u211d] \u211d\nx : E\nt : \u211d\nht : 0 < t\nh : HasStrictFDerivAt (fun x => \u2016x\u2016) f x\n\u22a2 HasStrictFDerivAt (fun x => \u2016x\u2016) f (t \u2022 x)"}, {"line": "simpa [ht] using h.hasStrictFDerivAt_norm_smul ht.ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.hasFDerivAt_norm_smul_neg\n    (ht : t < 0) (h : HasFDerivAt (\u2016\u00b7\u2016) f x) :\n    HasFDerivAt (\u2016\u00b7\u2016) (-f) (t \u2022 x) := by\n  simpa [ht] using h.hasFDerivAt_norm_smul ht.ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192L[\u211d] \u211d\nx : E\nt : \u211d\nht : t < 0\nh : HasFDerivAt (fun x => \u2016x\u2016) f x\n\u22a2 HasFDerivAt (fun x => \u2016x\u2016) (-f) (t \u2022 x)"}, {"line": "simpa [ht] using h.hasFDerivAt_norm_smul ht.ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.hasFDerivAt_norm_smul_pos\n    (ht : 0 < t) (h : HasFDerivAt (\u2016\u00b7\u2016) f x) :\n    HasFDerivAt (\u2016\u00b7\u2016) f (t \u2022 x) := by\n  simpa [ht] using h.hasFDerivAt_norm_smul ht.ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : E \u2192L[\u211d] \u211d\nx : E\nt : \u211d\nht : 0 < t\nh : HasFDerivAt (fun x => \u2016x\u2016) f x\n\u22a2 HasFDerivAt (fun x => \u2016x\u2016) f (t \u2022 x)"}, {"line": "simpa [ht] using h.hasFDerivAt_norm_smul ht.ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_norm_smul (ht : t \u2260 0) :\n    DifferentiableAt \u211d (\u2016\u00b7\u2016) x \u2194 DifferentiableAt \u211d (\u2016\u00b7\u2016) (t \u2022 x) where\n  mp hd := (hd.hasFDerivAt.hasFDerivAt_norm_smul ht).differentiableAt\n  mpr hd := by\n    convert (hd.hasFDerivAt.hasFDerivAt_norm_smul (inv_ne_zero ht)).differentiableAt\n    rw [smul_smul]\n    rw [inv_mul_cancel\u2080 ht]\n    rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : t \u2260 0\nhd : DifferentiableAt \u211d (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 DifferentiableAt \u211d (fun x => \u2016x\u2016) x"}, {"line": "convert (hd.hasFDerivAt.hasFDerivAt_norm_smul (inv_ne_zero ht)).differentiableAt", "tactic_state": "case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : t \u2260 0\nhd : DifferentiableAt \u211d (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = t\u207b\u00b9 \u2022 t \u2022 x"}, {"line": "rw [smul_smul]", "tactic_state": "case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : t \u2260 0\nhd : DifferentiableAt \u211d (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = (t\u207b\u00b9 * t) \u2022 x"}, {"line": "rw [inv_mul_cancel\u2080 ht]", "tactic_state": "case h.e'_12\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : t \u2260 0\nhd : DifferentiableAt \u211d (fun x => \u2016x\u2016) (t \u2022 x)\n\u22a2 x = 1 \u2022 x"}, {"line": "rw [one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_norm_smul_pos (ht : 0 < t) :\n    fderiv \u211d (\u2016\u00b7\u2016) (t \u2022 x) = fderiv \u211d (\u2016\u00b7\u2016) x := by\n  simp [fderiv_norm_smul, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in", "(x t) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : 0 < t\n\u22a2 fderiv \u211d (fun x => \u2016x\u2016) (t \u2022 x) = fderiv \u211d (fun x => \u2016x\u2016) x"}, {"line": "simp [fderiv_norm_smul, ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_norm_smul_neg (ht : t < 0) :\n    fderiv \u211d (\u2016\u00b7\u2016) (t \u2022 x) = -fderiv \u211d (\u2016\u00b7\u2016) x := by\n  simp [fderiv_norm_smul, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Norm.lean", "context": {"open": ["ContinuousLinearMap Filter NNReal Real Set"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{n : WithTop \u2115\u221e} {f : E \u2192L[\u211d] \u211d} {x : E} {t : \u211d}", "(E) in", "(x t) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nt : \u211d\nht : t < 0\n\u22a2 fderiv \u211d (fun x => \u2016x\u2016) (t \u2022 x) = -fderiv \u211d (fun x => \u2016x\u2016) x"}, {"line": "simp [fderiv_norm_smul, ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.of_restrictScalars {g' : E \u2192L[\ud835\udd5c] F} (h : HasFDerivWithinAt f g' s x)\n    (H : f'.restrictScalars \ud835\udd5c = g') : HasFDerivWithinAt f f' s x := by\n  rw [\u2190 H] at h\n  exact .of_isLittleO h.isLittleO\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/RestrictScalars.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c' E]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] [NormedSpace \ud835\udd5c' F]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c'] F} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c'] F\ns : Set E\nx : E\ng' : E \u2192L[\ud835\udd5c] F\nh : HasFDerivWithinAt f g' s x\nH : ContinuousLinearMap.restrictScalars \ud835\udd5c f' = g'\n\u22a2 HasFDerivWithinAt f f' s x"}, {"line": "rw [\u2190 H] at h", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c'] F\ns : Set E\nx : E\ng' : E \u2192L[\ud835\udd5c] F\nh : HasFDerivWithinAt f (ContinuousLinearMap.restrictScalars \ud835\udd5c f') s x\nH : ContinuousLinearMap.restrictScalars \ud835\udd5c f' = g'\n\u22a2 HasFDerivWithinAt f f' s x"}, {"line": "exact .of_isLittleO h.isLittleO", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_of_restrictScalars {g' : E \u2192L[\ud835\udd5c] F} (h : HasFDerivAt f g' x)\n    (H : f'.restrictScalars \ud835\udd5c = g') : HasFDerivAt f f' x := by\n  rw [\u2190 H] at h\n  exact .of_isLittleO h.isLittleO\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/RestrictScalars.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c' E]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] [NormedSpace \ud835\udd5c' F]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c'] F} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c'] F\nx : E\ng' : E \u2192L[\ud835\udd5c] F\nh : HasFDerivAt f g' x\nH : restrictScalars \ud835\udd5c f' = g'\n\u22a2 HasFDerivAt f f' x"}, {"line": "rw [\u2190 H] at h", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c'] F\nx : E\ng' : E \u2192L[\ud835\udd5c] F\nh : HasFDerivAt f (restrictScalars \ud835\udd5c f') x\nH : restrictScalars \ud835\udd5c f' = g'\n\u22a2 HasFDerivAt f f' x"}, {"line": "exact .of_isLittleO h.isLittleO", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_iff_restrictScalars (hf : DifferentiableAt \ud835\udd5c f x) :\n    DifferentiableAt \ud835\udd5c' f x \u2194 \u2203 g' : E \u2192L[\ud835\udd5c'] F, g'.restrictScalars \ud835\udd5c = fderiv \ud835\udd5c f x := by\n  rw [\u2190 differentiableWithinAt_univ]\n  rw [\u2190 fderivWithin_univ]\n  exact\n    differentiableWithinAt_iff_restrictScalars \ud835\udd5c hf.differentiableWithinAt uniqueDiffWithinAt_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/RestrictScalars.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c' E]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] [NormedSpace \ud835\udd5c' F]", "[IsScalarTower \ud835\udd5c \ud835\udd5c' F]", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c'] F} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nx : E\nhf : DifferentiableAt \ud835\udd5c f x\n\u22a2 DifferentiableAt \ud835\udd5c' f x \u2194 \u2203 g', restrictScalars \ud835\udd5c g' = fderiv \ud835\udd5c f x"}, {"line": "rw [\u2190 differentiableWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nx : E\nhf : DifferentiableAt \ud835\udd5c f x\n\u22a2 DifferentiableWithinAt \ud835\udd5c' f univ x \u2194 \u2203 g', restrictScalars \ud835\udd5c g' = fderiv \ud835\udd5c f x"}, {"line": "rw [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\n\ud835\udd5c' : Type u_2\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u2078 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\nE : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c' E\ninst\u271d\u2074 : IsScalarTower \ud835\udd5c \ud835\udd5c' E\nF : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c' F\ninst\u271d : IsScalarTower \ud835\udd5c \ud835\udd5c' F\nf : E \u2192 F\nx : E\nhf : DifferentiableAt \ud835\udd5c f x\n\u22a2 DifferentiableWithinAt \ud835\udd5c' f univ x \u2194 \u2203 g', restrictScalars \ud835\udd5c g' = fderivWithin \ud835\udd5c f univ x"}, {"line": "exact\n    differentiableWithinAt_iff_restrictScalars \ud835\udd5c hf.differentiableWithinAt uniqueDiffWithinAt_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAtFilter_add_const_iff (c : F) :\n    HasFDerivAtFilter (f \u00b7 + c) f' x L \u2194 HasFDerivAtFilter f f' x L := by\n  simp [hasFDerivAtFilter_iff_isLittleOTVS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nc : F\n\u22a2 HasFDerivAtFilter (fun x => f x + c) f' x L \u2194 HasFDerivAtFilter f f' x L"}, {"line": "simp [hasFDerivAtFilter_iff_isLittleOTVS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictFDerivAt_add_const_iff (c : F) :\n    HasStrictFDerivAt (f \u00b7 + c) f' x \u2194 HasStrictFDerivAt f f' x := by\n  simp [hasStrictFDerivAt_iff_isLittleO]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nc : F\n\u22a2 HasStrictFDerivAt (fun x => f x + c) f' x \u2194 HasStrictFDerivAt f f' x"}, {"line": "simp [hasStrictFDerivAt_iff_isLittleO]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_add_const (c : F) :\n    fderivWithin \ud835\udd5c (fun y => f y + c) s x = fderivWithin \ud835\udd5c f s x := by\n  classical simp [fderivWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => f y + c) s x = fderivWithin \ud835\udd5c f s x"}, {"line": "classical simp [fderivWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_add_const (c : F) : fderiv \ud835\udd5c (fun y => f y + c) x = fderiv \ud835\udd5c f x := by\n  simp only [\u2190 fderivWithin_univ]\n  simp only [fderivWithin_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderiv \ud835\udd5c (fun y => f y + c) x = fderiv \ud835\udd5c f x"}, {"line": "simp only [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => f y + c) Set.univ x = fderivWithin \ud835\udd5c f Set.univ x"}, {"line": "simp only [fderivWithin_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAtFilter_const_add_iff (c : F) :\n    HasFDerivAtFilter (c + f \u00b7) f' x L \u2194 HasFDerivAtFilter f f' x L := by\n  simpa only [add_comm] using hasFDerivAtFilter_add_const_iff c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nc : F\n\u22a2 HasFDerivAtFilter (fun x => c + f x) f' x L \u2194 HasFDerivAtFilter f f' x L"}, {"line": "simpa only [add_comm] using hasFDerivAtFilter_add_const_iff c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictFDerivAt_const_add_iff (c : F) :\n    HasStrictFDerivAt (c + f \u00b7) f' x \u2194 HasStrictFDerivAt f f' x := by\n  simpa only [add_comm] using hasStrictFDerivAt_add_const_iff c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nc : F\n\u22a2 HasStrictFDerivAt (fun x => c + f x) f' x \u2194 HasStrictFDerivAt f f' x"}, {"line": "simpa only [add_comm] using hasStrictFDerivAt_add_const_iff c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_const_add (c : F) :\n    fderivWithin \ud835\udd5c (fun y => c + f y) s x = fderivWithin \ud835\udd5c f s x := by\n  simpa only [add_comm] using fderivWithin_add_const c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => c + f y) s x = fderivWithin \ud835\udd5c f s x"}, {"line": "simpa only [add_comm] using fderivWithin_add_const c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_neg : fderiv \ud835\udd5c (fun y => -f y) x = -fderiv \ud835\udd5c f x := by\n  simp only [\u2190 fderivWithin_univ]\n  simp only [fderivWithin_neg uniqueDiffWithinAt_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 fderiv \ud835\udd5c (fun y => -f y) x = -fderiv \ud835\udd5c f x"}, {"line": "simp only [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 fderivWithin \ud835\udd5c (fun y => -f y) Set.univ x = -fderivWithin \ud835\udd5c f Set.univ x"}, {"line": "simp only [fderivWithin_neg uniqueDiffWithinAt_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictFDerivAt.sub (hf : HasStrictFDerivAt f f' x) (hg : HasStrictFDerivAt g g' x) :\n    HasStrictFDerivAt (fun x => f x - g x) (f' - g') x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nf' g' : E \u2192L[\ud835\udd5c] F\nx : E\nhf : HasStrictFDerivAt f f' x\nhg : HasStrictFDerivAt g g' x\n\u22a2 HasStrictFDerivAt (fun x => f x - g x) (f' - g') x"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAtFilter.sub (hf : HasFDerivAtFilter f f' x L) (hg : HasFDerivAtFilter g g' x L) :\n    HasFDerivAtFilter (fun x => f x - g x) (f' - g') x L := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nf' g' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nhf : HasFDerivAtFilter f f' x L\nhg : HasFDerivAtFilter g g' x L\n\u22a2 HasFDerivAtFilter (fun x => f x - g x) (f' - g') x L"}, {"line": "simpa only [sub_eq_add_neg] using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma DifferentiableAt.add_iff_left (hg : DifferentiableAt \ud835\udd5c g x) :\n    DifferentiableAt \ud835\udd5c (fun y => f y + g y) x \u2194 DifferentiableAt \ud835\udd5c f x := by\n  refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9\n  simpa only [add_sub_cancel_right] using h.sub hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nx : E\nhg : DifferentiableAt \ud835\udd5c g x\n\u22a2 DifferentiableAt \ud835\udd5c (fun y => f y + g y) x \u2194 DifferentiableAt \ud835\udd5c f x"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nx : E\nhg : DifferentiableAt \ud835\udd5c g x\nh : DifferentiableAt \ud835\udd5c (fun y => f y + g y) x\n\u22a2 DifferentiableAt \ud835\udd5c f x"}, {"line": "simpa only [add_sub_cancel_right] using h.sub hg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma DifferentiableOn.add_iff_left (hg : DifferentiableOn \ud835\udd5c g s) :\n    DifferentiableOn \ud835\udd5c (fun y => f y + g y) s \u2194 DifferentiableOn \ud835\udd5c f s := by\n  refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9\n  simpa only [add_sub_cancel_right] using h.sub hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\ns : Set E\nhg : DifferentiableOn \ud835\udd5c g s\n\u22a2 DifferentiableOn \ud835\udd5c (fun y => f y + g y) s \u2194 DifferentiableOn \ud835\udd5c f s"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\ns : Set E\nhg : DifferentiableOn \ud835\udd5c g s\nh : DifferentiableOn \ud835\udd5c (fun y => f y + g y) s\n\u22a2 DifferentiableOn \ud835\udd5c f s"}, {"line": "simpa only [add_sub_cancel_right] using h.sub hg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Differentiable.add_iff_left (hg : Differentiable \ud835\udd5c g) :\n    Differentiable \ud835\udd5c (fun y => f y + g y) \u2194 Differentiable \ud835\udd5c f := by\n  refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9\n  simpa only [add_sub_cancel_right] using h.sub hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nhg : Differentiable \ud835\udd5c g\n\u22a2 (Differentiable \ud835\udd5c fun y => f y + g y) \u2194 Differentiable \ud835\udd5c f"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun hf \u21a6 hf.add hg\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf g : E \u2192 F\nhg : Differentiable \ud835\udd5c g\nh : Differentiable \ud835\udd5c fun y => f y + g y\n\u22a2 Differentiable \ud835\udd5c f"}, {"line": "simpa only [add_sub_cancel_right] using h.sub hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAtFilter_sub_const_iff (c : F) :\n    HasFDerivAtFilter (f \u00b7 - c) f' x L \u2194 HasFDerivAtFilter f f' x L := by\n  simp only [sub_eq_add_neg]\n  simp only [hasFDerivAtFilter_add_const_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nc : F\n\u22a2 HasFDerivAtFilter (fun x => f x - c) f' x L \u2194 HasFDerivAtFilter f f' x L"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nc : F\n\u22a2 HasFDerivAtFilter (fun x => f x + -c) f' x L \u2194 HasFDerivAtFilter f f' x L"}, {"line": "simp only [hasFDerivAtFilter_add_const_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictFDerivAt_sub_const_iff (c : F) :\n    HasStrictFDerivAt (f \u00b7 - c) f' x \u2194 HasStrictFDerivAt f f' x := by\n  simp only [sub_eq_add_neg]\n  simp only [hasStrictFDerivAt_add_const_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nc : F\n\u22a2 HasStrictFDerivAt (fun x => f x - c) f' x \u2194 HasStrictFDerivAt f f' x"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nc : F\n\u22a2 HasStrictFDerivAt (fun x => f x + -c) f' x \u2194 HasStrictFDerivAt f f' x"}, {"line": "simp only [hasStrictFDerivAt_add_const_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_sub_const_iff (c : F) :\n    DifferentiableWithinAt \ud835\udd5c (fun y => f y - c) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x := by\n  simp only [sub_eq_add_neg]\n  simp only [differentiableWithinAt_add_const_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun y => f y - c) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun y => f y + -c) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "simp only [differentiableWithinAt_add_const_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_sub_const (c : F) :\n    fderivWithin \ud835\udd5c (fun y => f y - c) s x = fderivWithin \ud835\udd5c f s x := by\n  simp only [sub_eq_add_neg]\n  simp only [fderivWithin_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => f y - c) s x = fderivWithin \ud835\udd5c f s x"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => f y + -c) s x = fderivWithin \ud835\udd5c f s x"}, {"line": "simp only [fderivWithin_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_sub_const (c : F) : fderiv \ud835\udd5c (fun y => f y - c) x = fderiv \ud835\udd5c f x := by\n  simp only [sub_eq_add_neg]\n  simp only [fderiv_add_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderiv \ud835\udd5c (fun y => f y - c) x = fderiv \ud835\udd5c f x"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderiv \ud835\udd5c (fun y => f y + -c) x = fderiv \ud835\udd5c f x"}, {"line": "simp only [fderiv_add_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAtFilter.const_sub (hf : HasFDerivAtFilter f f' x L) (c : F) :\n    HasFDerivAtFilter (fun x => c - f x) (-f') x L := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nhf : HasFDerivAtFilter f f' x L\nc : F\n\u22a2 HasFDerivAtFilter (fun x => c - f x) (-f') x L"}, {"line": "simpa only [sub_eq_add_neg] using hf.neg.const_add c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_const_sub_iff (c : F) :\n    DifferentiableWithinAt \ud835\udd5c (fun y => c - f y) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nc : F\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun y => c - f y) s x \u2194 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_const_sub (c : F) : fderiv \ud835\udd5c (fun y => c - f y) x = -fderiv \ud835\udd5c f x := by\n  simp only [\u2190 fderivWithin_univ]\n  simp only [fderivWithin_const_sub uniqueDiffWithinAt_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderiv \ud835\udd5c (fun y => c - f y) x = -fderiv \ud835\udd5c f x"}, {"line": "simp only [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun y => c - f y) Set.univ x = -fderivWithin \ud835\udd5c f Set.univ x"}, {"line": "simp only [fderivWithin_const_sub uniqueDiffWithinAt_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_comp_add_left (a : E) :\n    DifferentiableWithinAt \ud835\udd5c (fun x \u21a6 f (a + x)) s x \u2194\n      DifferentiableWithinAt \ud835\udd5c f (a +\u1d65 s) (a + x) := by\n  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\na : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun x => f (a + x)) s x \u2194 DifferentiableWithinAt \ud835\udd5c f (a +\u1d65 s) (a + x)"}, {"line": "simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivWithinAt_comp_add_right (a : E) :\n    HasFDerivWithinAt (fun x \u21a6 f (x + a)) f' s x \u2194 HasFDerivWithinAt f f' (a +\u1d65 s) (x + a) := by\n  simpa only [add_comm a] using hasFDerivWithinAt_comp_add_left a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\na : E\n\u22a2 HasFDerivWithinAt (fun x => f (x + a)) f' s x \u2194 HasFDerivWithinAt f f' (a +\u1d65 s) (x + a)"}, {"line": "simpa only [add_comm a] using hasFDerivWithinAt_comp_add_left a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_comp_add_right (a : E) :\n    DifferentiableWithinAt \ud835\udd5c (fun x \u21a6 f (x + a)) s x \u2194\n      DifferentiableWithinAt \ud835\udd5c f (a +\u1d65 s) (x + a) := by\n  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\na : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun x => f (x + a)) s x \u2194 DifferentiableWithinAt \ud835\udd5c f (a +\u1d65 s) (x + a)"}, {"line": "simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_comp_add_right (a : E) :\n    HasFDerivAt (fun x \u21a6 f (x + a)) f' x \u2194 HasFDerivAt f f' (x + a) := by\n  simp [\u2190 hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx a : E\n\u22a2 HasFDerivAt (fun x => f (x + a)) f' x \u2194 HasFDerivAt f f' (x + a)"}, {"line": "simp [\u2190 hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_comp_add_right (a : E) :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x + a)) x \u2194 DifferentiableAt \ud835\udd5c f (x + a) := by\n  simp [DifferentiableAt, hasFDerivAt_comp_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (x + a)) x \u2194 DifferentiableAt \ud835\udd5c f (x + a)"}, {"line": "simp [DifferentiableAt, hasFDerivAt_comp_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_comp_add_right (a : E) :\n    fderiv \ud835\udd5c (fun x \u21a6 f (x + a)) x = fderiv \ud835\udd5c f (x + a) := by\n  simp [\u2190 fderivWithin_univ, fderivWithin_comp_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 fderiv \ud835\udd5c (fun x => f (x + a)) x = fderiv \ud835\udd5c f (x + a)"}, {"line": "simp [\u2190 fderivWithin_univ, fderivWithin_comp_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_comp_add_left (a : E) :\n    HasFDerivAt (fun x \u21a6 f (a + x)) f' x \u2194 HasFDerivAt f f' (a + x) := by\n  simpa [add_comm a] using hasFDerivAt_comp_add_right a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx a : E\n\u22a2 HasFDerivAt (fun x => f (a + x)) f' x \u2194 HasFDerivAt f f' (a + x)"}, {"line": "simpa [add_comm a] using hasFDerivAt_comp_add_right a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_comp_add_left (a : E) :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (a + x)) x \u2194 DifferentiableAt \ud835\udd5c f (a + x) := by\n  simp [DifferentiableAt, hasFDerivAt_comp_add_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (a + x)) x \u2194 DifferentiableAt \ud835\udd5c f (a + x)"}, {"line": "simp [DifferentiableAt, hasFDerivAt_comp_add_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_comp_add_left (a : E) :\n    fderiv \ud835\udd5c (fun x \u21a6 f (a + x)) x = fderiv \ud835\udd5c f (a + x) := by\n  simpa [add_comm a] using fderiv_comp_add_right a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 fderiv \ud835\udd5c (fun x => f (a + x)) x = fderiv \ud835\udd5c f (a + x)"}, {"line": "simpa [add_comm a] using fderiv_comp_add_right a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_comp_sub (a : E) :\n    DifferentiableWithinAt \ud835\udd5c (fun x \u21a6 f (x - a)) s x \u2194\n      DifferentiableWithinAt \ud835\udd5c f (-a +\u1d65 s) (x - a) := by\n  simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\na : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun x => f (x - a)) s x \u2194 DifferentiableWithinAt \ud835\udd5c f (-a +\u1d65 s) (x - a)"}, {"line": "simp [DifferentiableWithinAt, hasFDerivWithinAt_comp_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_comp_sub (a : E) :\n    HasFDerivAt (fun x \u21a6 f (x - a)) f' x \u2194 HasFDerivAt f f' (x - a) := by\n  simp [\u2190 hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx a : E\n\u22a2 HasFDerivAt (fun x => f (x - a)) f' x \u2194 HasFDerivAt f f' (x - a)"}, {"line": "simp [\u2190 hasFDerivWithinAt_univ, hasFDerivWithinAt_comp_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_comp_sub (a : E) :\n    DifferentiableAt \ud835\udd5c (fun x \u21a6 f (x - a)) x \u2194 DifferentiableAt \ud835\udd5c f (x - a) := by\n  simp [DifferentiableAt, hasFDerivAt_comp_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => f (x - a)) x \u2194 DifferentiableAt \ud835\udd5c f (x - a)"}, {"line": "simp [DifferentiableAt, hasFDerivAt_comp_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_comp_sub (a : E) :\n    fderiv \ud835\udd5c (fun x \u21a6 f (x - a)) x = fderiv \ud835\udd5c f (x - a) := by\n  simp [\u2190 fderivWithin_univ, fderivWithin_comp_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Add.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap", "scoped Pointwise Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f g : E \u2192 F}", "{f' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{L : Filter E}", "{R : Type*} [Semiring R] [Module R F] [SMulCommClass \ud835\udd5c R F] [ContinuousConstSMul R F]", "{\u03b9 : Type*} {u : Finset \u03b9} {A : \u03b9 \u2192 E \u2192 F} {A' : \u03b9 \u2192 E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx a : E\n\u22a2 fderiv \ud835\udd5c (fun x => f (x - a)) x = fderiv \ud835\udd5c f (x - a)"}, {"line": "simp [\u2190 fderivWithin_univ, fderivWithin_comp_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFPowerSeriesAt.hasStrictFDerivAt (h : HasFPowerSeriesAt f p x) :\n    HasStrictFDerivAt f (continuousMultilinearCurryFin1 \ud835\udd5c E F (p 1)) x := by\n  simpa only [hasStrictFDerivAt_iff_isLittleO,Set.insert_eq_of_mem,Set.mem_univ,Set.univ_prod_univ,nhdsWithin_univ]\n    using (h.hasFPowerSeriesWithinAt (s := Set.univ)).hasStrictFDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nf : E \u2192 F\nx : E\nh : HasFPowerSeriesAt f p x\n\u22a2 HasStrictFDerivAt f ((continuousMultilinearCurryFin1 \ud835\udd5c E F) (p 1)) x"}, {"line": "simpa only [hasStrictFDerivAt_iff_isLittleO,Set.insert_eq_of_mem,Set.mem_univ,Set.univ_prod_univ,nhdsWithin_univ]\n    using (h.hasFPowerSeriesWithinAt (s := Set.univ)).hasStrictFDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticWithinAt.differentiableWithinAt (h : AnalyticWithinAt \ud835\udd5c f s x) :\n    DifferentiableWithinAt \ud835\udd5c f (insert x s) x := by\n  obtain \u27e8p, hp\u27e9 := h\n  exact hp.differentiableWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : AnalyticWithinAt \ud835\udd5c f s x\n\u22a2 DifferentiableWithinAt \ud835\udd5c f (insert x s) x"}, {"line": "obtain \u27e8p, hp\u27e9 := h", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\np : FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFPowerSeriesWithinAt f p s x\n\u22a2 DifferentiableWithinAt \ud835\udd5c f (insert x s) x"}, {"line": "exact hp.differentiableWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasFPowerSeriesWithinOnBall.fderivWithin_of_mem [CompleteSpace F]\n    (h : HasFPowerSeriesWithinOnBall f p s x r) (hu : UniqueDiffOn \ud835\udd5c s) (hx : x \u2208 s) :\n    HasFPowerSeriesWithinOnBall (fderivWithin \ud835\udd5c f s) p.derivSeries s x r := by\n  have : insert x s = s := insert_eq_of_mem hx\n  rw [\u2190 this] at hu\n  convert h.fderivWithin hu\n  exact this.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\n\u22a2 HasFPowerSeriesWithinOnBall (fderivWithin \ud835\udd5c f s) p.derivSeries s x r"}, {"line": "have : insert x s = s := insert_eq_of_mem hx", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c s\nhx : x \u2208 s\nthis : insert x s = s\n\u22a2 HasFPowerSeriesWithinOnBall (fderivWithin \ud835\udd5c f s) p.derivSeries s x r"}, {"line": "rw [\u2190 this] at hu", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c (insert x s)\nhx : x \u2208 s\nthis : insert x s = s\n\u22a2 HasFPowerSeriesWithinOnBall (fderivWithin \ud835\udd5c f s) p.derivSeries s x r"}, {"line": "convert h.fderivWithin hu", "tactic_state": "case h.e'_9.h.e'_12\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c (insert x s)\nhx : x \u2208 s\nthis : insert x s = s\n\u22a2 s = insert x s\n---\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c (insert x s)\nhx : x \u2208 s\nthis : insert x s = s\n\u22a2 CompleteSpace F"}, {"line": "exact this.symm", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nf : E \u2192 F\nx : E\ns : Set E\ninst\u271d : CompleteSpace F\nh : HasFPowerSeriesWithinOnBall f p s x r\nhu : UniqueDiffOn \ud835\udd5c (insert x s)\nhx : x \u2208 s\nthis : insert x s = s\n\u22a2 CompleteSpace F"}]}
{"declaration": "protected theorem AnalyticAt.fderiv [CompleteSpace F] (h : AnalyticAt \ud835\udd5c f x) :\n    AnalyticAt \ud835\udd5c (fderiv \ud835\udd5c f) x := by\n  rcases h with \u27e8p, r, hp\u27e9\n  exact hp.fderiv.analyticAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ninst\u271d : CompleteSpace F\nh : AnalyticAt \ud835\udd5c f x\n\u22a2 AnalyticAt \ud835\udd5c (fderiv \ud835\udd5c f) x"}, {"line": "rcases h with \u27e8p, r, hp\u27e9", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ninst\u271d : CompleteSpace F\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nhp : HasFPowerSeriesOnBall f p x r\n\u22a2 AnalyticAt \ud835\udd5c (fderiv \ud835\udd5c f) x"}, {"line": "exact hp.fderiv.analyticAt", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem AnalyticOn.fderivWithin (h : AnalyticOn \ud835\udd5c f s) (hu : UniqueDiffOn \ud835\udd5c s) :\n    AnalyticOn \ud835\udd5c (fderivWithin \ud835\udd5c f s) s := by\n  intro x hx\n  rcases h x hx with \u27e8p, r, hr\u27e9\n  refine \u27e8p.derivSeries, r, hr.fderivWithin_of_mem_of_analyticOn h hu hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : AnalyticOn \ud835\udd5c f s\nhu : UniqueDiffOn \ud835\udd5c s\n\u22a2 AnalyticOn \ud835\udd5c (fderivWithin \ud835\udd5c f s) s"}, {"line": "intro x hx", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : AnalyticOn \ud835\udd5c f s\nhu : UniqueDiffOn \ud835\udd5c s\nx : E\nhx : x \u2208 s\n\u22a2 AnalyticWithinAt \ud835\udd5c (fderivWithin \ud835\udd5c f s) s x"}, {"line": "rcases h x hx with \u27e8p, r, hr\u27e9", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : AnalyticOn \ud835\udd5c f s\nhu : UniqueDiffOn \ud835\udd5c s\nx : E\nhx : x \u2208 s\np : FormalMultilinearSeries \ud835\udd5c E F\nr : ENNReal\nhr : HasFPowerSeriesWithinOnBall f p s x r\n\u22a2 AnalyticWithinAt \ud835\udd5c (fderivWithin \ud835\udd5c f s) s x"}, {"line": "refine \u27e8p.derivSeries, r, hr.fderivWithin_of_mem_of_analyticOn h hu hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PartialHomeomorph.analyticAt_symm' (f : PartialHomeomorph E F) {a : E}\n    {i : E \u2243L[\ud835\udd5c] F} (h0 : a \u2208 f.source) (h : AnalyticAt \ud835\udd5c f a) (h' : fderiv \ud835\udd5c f a = i) :\n    AnalyticAt \ud835\udd5c f.symm (f a) := by\n  rcases h with \u27e8p, hp\u27e9\n  have : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i := by simp [\u2190 h', hp.fderiv_eq]\n  exact (f.hasFPowerSeriesAt_symm h0 hp this).analyticAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : E\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.source\nh : AnalyticAt \ud835\udd5c (\u2191f) a\nh' : fderiv \ud835\udd5c (\u2191f) a = \u2191i\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) (\u2191f a)"}, {"line": "rcases h with \u27e8p, hp\u27e9", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : E\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.source\nh' : fderiv \ud835\udd5c (\u2191f) a = \u2191i\np : FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFPowerSeriesAt (\u2191f) p a\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) (\u2191f a)"}, {"line": "have : p 1 = (continuousMultilinearCurryFin1 \ud835\udd5c E F).symm i := by simp [\u2190 h', hp.fderiv_eq]", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : E\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.source\nh' : fderiv \ud835\udd5c (\u2191f) a = \u2191i\np : FormalMultilinearSeries \ud835\udd5c E F\nhp : HasFPowerSeriesAt (\u2191f) p a\nthis : p 1 = sorry\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) (\u2191f a)"}, {"line": "exact (f.hasFPowerSeriesAt_symm h0 hp this).analyticAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PartialHomeomorph.analyticAt_symm (f : PartialHomeomorph E F) {a : F}\n    {i : E \u2243L[\ud835\udd5c] F} (h0 : a \u2208 f.target) (h : AnalyticAt \ud835\udd5c f (f.symm a))\n    (h' : fderiv \ud835\udd5c f (f.symm a) = i) :\n    AnalyticAt \ud835\udd5c f.symm a := by\n  have : a = f (f.symm a) := by simp [h0]\n  rw [this]\n  exact f.analyticAt_symm' (by simp [h0]) h h'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : F\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.target\nh : AnalyticAt \ud835\udd5c (\u2191f) (\u2191f.symm a)\nh' : fderiv \ud835\udd5c (\u2191f) (\u2191f.symm a) = \u2191i\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) a"}, {"line": "have : a = f (f.symm a) := by simp [h0]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : F\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.target\nh : AnalyticAt \ud835\udd5c (\u2191f) (\u2191f.symm a)\nh' : fderiv \ud835\udd5c (\u2191f) (\u2191f.symm a) = \u2191i\nthis : a = \u2191f sorry\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) a"}, {"line": "rw [this]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type v\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : PartialHomeomorph E F\na : F\ni : E \u2243L[\ud835\udd5c] F\nh0 : a \u2208 f.target\nh : AnalyticAt \ud835\udd5c (\u2191f) (\u2191f.symm a)\nh' : fderiv \ud835\udd5c (\u2191f) (\u2191f.symm a) = \u2191i\nthis : a = \u2191f sorry\n\u22a2 AnalyticAt \ud835\udd5c (\u2191f.symm) (\u2191f sorry)"}, {"line": "exact f.analyticAt_symm' (by simp [h0]) h h'", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma _root_.Equiv.succ_embeddingFinSucc_fst_symm_apply {\u03b9 : Type*} [DecidableEq \u03b9]\n    {n : \u2115} (e : Fin (n+1) \u21aa \u03b9) {k : \u03b9}\n    (h'k : k \u2208 Set.range (Equiv.embeddingFinSucc n \u03b9 e).1) (hk : k \u2208 Set.range e) :\n    Fin.succ ((Equiv.embeddingFinSucc n \u03b9 e).1.toEquivRange.symm \u27e8k, h'k\u27e9)\n      = e.toEquivRange.symm \u27e8k, hk\u27e9 := by\n  rcases hk with \u27e8j, rfl\u27e9\n  have hj : j \u2260 0 := by\n    rintro rfl\n    simp at h'k\n  simp only [Function.Embedding.toEquivRange_symm_apply_self]\n  have : e j = (Equiv.embeddingFinSucc n \u03b9 e).1 (Fin.pred j hj) := by simp\n  simp_rw [this]\n  simp [-Equiv.embeddingFinSucc_fst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Analytic.lean", "context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology", "FormalMultilinearSeries", "Finset in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e} {n : \u2115}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)]", "{n : WithTop \u2115\u221e} (x : \u2200 i, E i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nk : \u03b9\nh'k : k \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\nhk : k \u2208 range \u21d1e\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8k, h'k\u27e9).succ = e.toEquivRange.symm \u27e8k, hk\u27e9"}, {"line": "rcases hk with \u27e8j, rfl\u27e9", "tactic_state": "case intro\n\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nj : Fin (n + 1)\nh'k : e j \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8e j, h'k\u27e9).succ = e.toEquivRange.symm \u27e8e j, \u22ef\u27e9"}, {"line": "have hj : j \u2260 0 := sorry", "tactic_state": "case intro\n\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nj : Fin (n + 1)\nh'k : e j \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\nhj : j \u2260 0\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8e j, h'k\u27e9).succ = e.toEquivRange.symm \u27e8e j, \u22ef\u27e9"}, {"line": "simp only [Function.Embedding.toEquivRange_symm_apply_self]", "tactic_state": "case intro\n\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nj : Fin (n + 1)\nh'k : e j \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\nhj : j \u2260 0\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8e j, h'k\u27e9).succ = j"}, {"line": "have : e j = (Equiv.embeddingFinSucc n \u03b9 e).1 (Fin.pred j hj) := by simp", "tactic_state": "case intro\n\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nj : Fin (n + 1)\nh'k : e j \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\nhj : j \u2260 0\nthis : e j = ((Equiv.embeddingFinSucc n \u03b9) e).fst (j.pred hj)\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8e j, h'k\u27e9).succ = j"}, {"line": "simp_rw [this]", "tactic_state": "case intro\n\u03b9 : Type u_1\ninst\u271d : DecidableEq \u03b9\nn : \u2115\ne : Fin (n + 1) \u21aa \u03b9\nj : Fin (n + 1)\nh'k : e j \u2208 range \u21d1((Equiv.embeddingFinSucc n \u03b9) e).fst\nhj : j \u2260 0\nthis : e j = ((Equiv.embeddingFinSucc n \u03b9) e).fst (j.pred hj)\n\u22a2 (((Equiv.embeddingFinSucc n \u03b9) e).fst.toEquivRange.symm \u27e8((Equiv.embeddingFinSucc n \u03b9) e).fst (j.pred hj), \u22ef\u27e9).succ =\n    j"}, {"line": "simp [-Equiv.embeddingFinSucc_fst]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_zero_of_not_differentiableWithinAt (h : \u00acDifferentiableWithinAt \ud835\udd5c f s x) :\n    fderivWithin \ud835\udd5c f s x = 0 := by\n  simp [fderivWithin, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "simp [fderivWithin, h]", "tactic_state": "h : \u00acsorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem hasFDerivWithinAt_univ : HasFDerivWithinAt f f' univ x \u2194 HasFDerivAt f f' x := by\n  simp only [HasFDerivWithinAt]\n  simp only [nhdsWithin_univ]\n  simp only [HasFDerivAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\n\u22a2 HasFDerivWithinAt f f' univ x \u2194 HasFDerivAt f f' x"}, {"line": "simp only [HasFDerivWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x univ) \u2194 HasFDerivAt f f' x"}, {"line": "simp only [nhdsWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\n\u22a2 HasFDerivAtFilter f f' x (nhds x) \u2194 HasFDerivAt f f' x"}, {"line": "simp only [HasFDerivAt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_univ :\n    DifferentiableWithinAt \ud835\udd5c f univ x \u2194 DifferentiableAt \ud835\udd5c f x := by\n  simp only [DifferentiableWithinAt]\n  simp only [hasFDerivWithinAt_univ]\n  simp only [DifferentiableAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c f univ x \u2194 DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [DifferentiableWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 (\u2203 f', HasFDerivWithinAt f f' univ x) \u2194 DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [hasFDerivWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 (\u2203 f', HasFDerivAt f f' x) \u2194 DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [DifferentiableAt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_zero_of_not_differentiableAt (h : \u00acDifferentiableAt \ud835\udd5c f x) : fderiv \ud835\udd5c f x = 0 := by\n  rw [fderiv]\n  rw [fderivWithin_zero_of_not_differentiableWithinAt]\n  rwa [differentiableWithinAt_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : \u00acDifferentiableAt \ud835\udd5c f x\n\u22a2 fderiv \ud835\udd5c f x = 0"}, {"line": "rw [fderiv]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : \u00acDifferentiableAt \ud835\udd5c f x\n\u22a2 fderivWithin \ud835\udd5c f univ x = 0"}, {"line": "rw [fderivWithin_zero_of_not_differentiableWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : \u00acDifferentiableAt \ud835\udd5c f x\n\u22a2 \u00acDifferentiableWithinAt \ud835\udd5c f univ x"}, {"line": "rwa [differentiableWithinAt_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivWithinAt_of_mem_nhds (h : s \u2208 \ud835\udcdd x) :\n    HasFDerivWithinAt f f' s x \u2194 HasFDerivAt f f' x := by\n  rw [HasFDerivAt]\n  rw [HasFDerivWithinAt]\n  rw [nhdsWithin_eq_nhds.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\nh : s \u2208 nhds x\n\u22a2 HasFDerivWithinAt f f' s x \u2194 HasFDerivAt f f' x"}, {"line": "rw [HasFDerivAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\nh : s \u2208 nhds x\n\u22a2 HasFDerivWithinAt f f' s x \u2194 HasFDerivAtFilter f f' x (nhds x)"}, {"line": "rw [HasFDerivWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\nh : s \u2208 nhds x\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x s) \u2194 HasFDerivAtFilter f f' x (nhds x)"}, {"line": "rw [nhdsWithin_eq_nhds.mpr h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivWithinAt_diff_singleton (y : E) :\n    HasFDerivWithinAt f f' (s \\ {y}) x \u2194 HasFDerivWithinAt f f' s x := by\n  rw [\u2190 hasFDerivWithinAt_insert]\n  rw [insert_diff_singleton]\n  rw [hasFDerivWithinAt_insert]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\ny : E\n\u22a2 HasFDerivWithinAt f f' (s \\ {y}) x \u2194 HasFDerivWithinAt f f' s x"}, {"line": "rw [\u2190 hasFDerivWithinAt_insert]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\ny : E\n\u22a2 HasFDerivWithinAt f f' (insert ?m.69096 (s \\ {y})) x \u2194 HasFDerivWithinAt f f' s x\n---\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\ny : E\n\u22a2 E"}, {"line": "rw [insert_diff_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns : Set E\ny : E\n\u22a2 HasFDerivWithinAt f f' (insert y s) x \u2194 HasFDerivWithinAt f f' s x"}, {"line": "rw [hasFDerivWithinAt_insert]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem HasFDerivWithinAt.empty : HasFDerivWithinAt f f' \u2205 x := by\n  simp [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\n\u22a2 HasFDerivWithinAt f f' \u2205 x"}, {"line": "simp [HasFDerivWithinAt, hasFDerivAtFilter_iff_isLittleOTVS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.unique (h\u2080 : HasFDerivAt f f\u2080' x) (h\u2081 : HasFDerivAt f f\u2081' x) : f\u2080' = f\u2081' := by\n  rw [\u2190 hasFDerivWithinAt_univ] at h\u2080 h\u2081\n  exact uniqueDiffWithinAt_univ.eq h\u2080 h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf\u2080' f\u2081' : E \u2192L[\ud835\udd5c] F\nx : E\nh\u2080 : HasFDerivAt f f\u2080' x\nh\u2081 : HasFDerivAt f f\u2081' x\n\u22a2 f\u2080' = f\u2081'"}, {"line": "rw [\u2190 hasFDerivWithinAt_univ] at h\u2080 h\u2081", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf\u2080' f\u2081' : E \u2192L[\ud835\udd5c] F\nx : E\nh\u2080 : HasFDerivWithinAt f f\u2080' univ x\nh\u2081 : HasFDerivWithinAt f f\u2081' univ x\n\u22a2 f\u2080' = f\u2081'"}, {"line": "exact uniqueDiffWithinAt_univ.eq h\u2080 h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivWithinAt_inter' (h : t \u2208 \ud835\udcdd[s] x) :\n    HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict'' s h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nh : t \u2208 nhdsWithin x s\n\u22a2 HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x"}, {"line": "simp [HasFDerivWithinAt, nhdsWithin_restrict'' s h]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nh : t \u2208 nhdsWithin x s\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x (s \u2229 t)) \u2194 HasFDerivAtFilter f f' x (nhdsWithin x s)"}]}
{"declaration": "theorem hasFDerivWithinAt_inter (h : t \u2208 \ud835\udcdd x) :\n    HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x := by\n  simp [HasFDerivWithinAt, nhdsWithin_restrict' s h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nh : t \u2208 nhds x\n\u22a2 HasFDerivWithinAt f f' (s \u2229 t) x \u2194 HasFDerivWithinAt f f' s x"}, {"line": "simp [HasFDerivWithinAt, nhdsWithin_restrict' s h]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nh : t \u2208 nhds x\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x (s \u2229 t)) \u2194 HasFDerivAtFilter f f' x (nhdsWithin x s)"}]}
{"declaration": "theorem HasFDerivWithinAt.union (hs : HasFDerivWithinAt f f' s x)\n    (ht : HasFDerivWithinAt f f' t x) : HasFDerivWithinAt f f' (s \u222a t) x := by\n  simp only [HasFDerivWithinAt]\n  simp only [nhdsWithin_union]\n  exact .of_isLittleOTVS <| hs.isLittleOTVS.sup ht.isLittleOTVS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nhs : HasFDerivWithinAt f f' s x\nht : HasFDerivWithinAt f f' t x\n\u22a2 HasFDerivWithinAt f f' (s \u222a t) x"}, {"line": "simp only [HasFDerivWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nhs : HasFDerivWithinAt f f' s x\nht : HasFDerivWithinAt f f' t x\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x (s \u222a t))"}, {"line": "simp only [nhdsWithin_union]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\ns t : Set E\nhs : HasFDerivWithinAt f f' s x\nht : HasFDerivWithinAt f f' t x\n\u22a2 HasFDerivAtFilter f f' x (nhdsWithin x s \u2294 nhdsWithin x t)"}, {"line": "exact .of_isLittleOTVS <| hs.isLittleOTVS.sup ht.isLittleOTVS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_zero_of_not_accPt (h : \u00acAccPt x (\ud835\udcdf s)) : fderivWithin \ud835\udd5c f s x = 0 := by\n  rw [fderivWithin]\n  rw [if_pos (.of_not_accPt h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : \u00acAccPt x (principal s)\n\u22a2 fderivWithin \ud835\udd5c f s x = 0"}, {"line": "rw [fderivWithin]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : \u00acAccPt x (principal s)\n\u22a2 (if HasFDerivWithinAt f 0 s x then 0 else if h : DifferentiableWithinAt \ud835\udd5c f s x then Classical.choose h else 0) = 0"}, {"line": "rw [if_pos (.of_not_accPt h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_zero_of_isolated (h : \ud835\udcdd[s \\ {x}] x = \u22a5) : fderivWithin \ud835\udd5c f s x = 0 := by\n  rw [fderivWithin]\n  rw [if_pos (.of_nhdsWithin_eq_bot h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : nhdsWithin x (s \\ {x}) = \u22a5\n\u22a2 fderivWithin \ud835\udd5c f s x = 0"}, {"line": "rw [fderivWithin]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : nhdsWithin x (s \\ {x}) = \u22a5\n\u22a2 (if HasFDerivWithinAt f 0 s x then 0 else if h : DifferentiableWithinAt \ud835\udd5c f s x then Classical.choose h else 0) = 0"}, {"line": "rw [if_pos (.of_nhdsWithin_eq_bot h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DifferentiableWithinAt.hasFDerivWithinAt (h : DifferentiableWithinAt \ud835\udd5c f s x) :\n    HasFDerivWithinAt f (fderivWithin \ud835\udd5c f s x) s x := by\n  simp only [fderivWithin]\n  simp only [dif_pos h]\n  split_ifs with h\u2080\n  exacts [h\u2080, Classical.choose_spec h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : DifferentiableWithinAt \ud835\udd5c f s x\n\u22a2 HasFDerivWithinAt f (fderivWithin \ud835\udd5c f s x) s x"}, {"line": "simp only [fderivWithin]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : DifferentiableWithinAt \ud835\udd5c f s x\n\u22a2 HasFDerivWithinAt f\n    (if HasFDerivWithinAt f 0 s x then 0 else if h : DifferentiableWithinAt \ud835\udd5c f s x then Classical.choose h else 0) s x"}, {"line": "simp only [dif_pos h]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : DifferentiableWithinAt \ud835\udd5c f s x\n\u22a2 HasFDerivWithinAt f (if HasFDerivWithinAt f 0 s x then 0 else Classical.choose h) s x"}, {"line": "split_ifs with h\u2080", "tactic_state": "case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : DifferentiableWithinAt \ud835\udd5c f s x\nh\u2080 : HasFDerivWithinAt f 0 s x\n\u22a2 HasFDerivWithinAt f 0 s x\n---\ncase neg\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nh : DifferentiableWithinAt \ud835\udd5c f s x\nh\u2080 : \u00acHasFDerivWithinAt f 0 s x\n\u22a2 HasFDerivWithinAt f (Classical.choose h) s x"}, {"line": "exacts [h\u2080, Classical.choose_spec h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DifferentiableAt.hasFDerivAt (h : DifferentiableAt \ud835\udd5c f x) :\n    HasFDerivAt f (fderiv \ud835\udd5c f x) x := by\n  rw [fderiv]\n  rw [\u2190 hasFDerivWithinAt_univ]\n  rw [\u2190 differentiableWithinAt_univ] at h\n  exact h.hasFDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : DifferentiableAt \ud835\udd5c f x\n\u22a2 HasFDerivAt f (fderiv \ud835\udd5c f x) x"}, {"line": "rw [fderiv]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : DifferentiableAt \ud835\udd5c f x\n\u22a2 HasFDerivAt f (fderivWithin \ud835\udd5c f univ x) x"}, {"line": "rw [\u2190 hasFDerivWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : DifferentiableAt \ud835\udd5c f x\n\u22a2 HasFDerivWithinAt f (fderivWithin \ud835\udd5c f univ x) univ x"}, {"line": "rw [\u2190 differentiableWithinAt_univ] at h", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nh : DifferentiableWithinAt \ud835\udd5c f univ x\n\u22a2 HasFDerivWithinAt f (fderivWithin \ud835\udd5c f univ x) univ x"}, {"line": "exact h.hasFDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DifferentiableWithinAt.mono (h : DifferentiableWithinAt \ud835\udd5c f t x) (st : s \u2286 t) :\n    DifferentiableWithinAt \ud835\udd5c f s x := by\n  rcases h with \u27e8f', hf'\u27e9\n  exact \u27e8f', hf'.mono st\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns t : Set E\nh : DifferentiableWithinAt \ud835\udd5c f t x\nst : s \u2286 t\n\u22a2 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "rcases h with \u27e8f', hf'\u27e9", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns t : Set E\nst : s \u2286 t\nf' : E \u2192L[\ud835\udd5c] F\nhf' : HasFDerivWithinAt f f' t x\n\u22a2 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "exact \u27e8f', hf'.mono st\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableOn_univ : DifferentiableOn \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f := by\n  simp only [DifferentiableOn]\n  simp only [Differentiable]\n  simp only [differentiableWithinAt_univ]\n  simp only [mem_univ]\n  simp only [forall_true_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u22a2 DifferentiableOn \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f"}, {"line": "simp only [DifferentiableOn]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u22a2 (\u2200 x \u2208 univ, DifferentiableWithinAt \ud835\udd5c f univ x) \u2194 Differentiable \ud835\udd5c f"}, {"line": "simp only [Differentiable]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u22a2 (\u2200 x \u2208 univ, DifferentiableWithinAt \ud835\udd5c f univ x) \u2194 \u2200 (x : E), DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [differentiableWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u22a2 (\u2200 x \u2208 univ, DifferentiableAt \ud835\udd5c f x) \u2194 \u2200 (x : E), DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [mem_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\n\u22a2 (\u2200 (x : E), True \u2192 DifferentiableAt \ud835\udd5c f x) \u2194 \u2200 (x : E), DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [forall_true_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableOn_of_locally_differentiableOn\n    (h : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 DifferentiableOn \ud835\udd5c f (s \u2229 u)) :\n    DifferentiableOn \ud835\udd5c f s := by\n  intro x xs\n  rcases h x xs with \u27e8t, t_open, xt, ht\u27e9\n  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 (ht x \u27e8xs, xt\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 DifferentiableOn \ud835\udd5c f (s \u2229 u)\n\u22a2 DifferentiableOn \ud835\udd5c f s"}, {"line": "intro x xs", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 DifferentiableOn \ud835\udd5c f (s \u2229 u)\nx : E\nxs : x \u2208 s\n\u22a2 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "rcases h x xs with \u27e8t, t_open, xt, ht\u27e9", "tactic_state": "case intro.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ns : Set E\nh : \u2200 x \u2208 s, \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 DifferentiableOn \ud835\udd5c f (s \u2229 u)\nx : E\nxs : x \u2208 s\nt : Set E\nt_open : IsOpen t\nxt : x \u2208 t\nht : DifferentiableOn \ud835\udd5c f (s \u2229 t)\n\u22a2 DifferentiableWithinAt \ud835\udd5c f s x"}, {"line": "exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 (ht x \u27e8xs, xt\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_eq_fderiv (hs : UniqueDiffWithinAt \ud835\udd5c s x) (h : DifferentiableAt \ud835\udd5c f x) :\n    fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x := by\n  rw [\u2190 fderivWithin_univ]\n  exact fderivWithin_subset (subset_univ _) hs h.differentiableWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nh : DifferentiableAt \ud835\udd5c f x\n\u22a2 fderivWithin \ud835\udd5c f s x = fderiv \ud835\udd5c f x"}, {"line": "rw [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\ns : Set E\nhs : UniqueDiffWithinAt \ud835\udd5c s x\nh : DifferentiableAt \ud835\udd5c f x\n\u22a2 fderivWithin \ud835\udd5c f s x = fderivWithin \ud835\udd5c f univ x"}, {"line": "exact fderivWithin_subset (subset_univ _) hs h.differentiableWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Asymptotics.IsBigO.hasFDerivAt {x\u2080 : E} {n : \u2115} (h : f =O[\ud835\udcdd x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n)\n    (hn : 1 < n) : HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x\u2080 := by\n  rw [\u2190 nhdsWithin_univ] at h\n  exact (h.hasFDerivWithinAt (mem_univ _) hn).hasFDerivAt_of_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx\u2080 : E\nn : \u2115\nh : f =O[nhds x\u2080] fun x => \u2016x - x\u2080\u2016 ^ n\nhn : 1 < n\n\u22a2 HasFDerivAt f 0 x\u2080"}, {"line": "rw [\u2190 nhdsWithin_univ] at h", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx\u2080 : E\nn : \u2115\nh : f =O[nhdsWithin x\u2080 univ] fun x => \u2016x - x\u2080\u2016 ^ n\nhn : 1 < n\n\u22a2 HasFDerivAt f 0 x\u2080"}, {"line": "exact (h.hasFDerivWithinAt (mem_univ _) hn).hasFDerivAt_of_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.hasFDerivAtFilter_iff (h\u2080 : f\u2080 =\u1da0[L] f\u2081) (hx : f\u2080 x = f\u2081 x)\n    (h\u2081 : \u2200 x, f\u2080' x = f\u2081' x) : HasFDerivAtFilter f\u2080 f\u2080' x L \u2194 HasFDerivAtFilter f\u2081 f\u2081' x L := by\n  simp only [hasFDerivAtFilter_iff_isLittleOTVS]\n  exact isLittleOTVS_congr (h\u2080.mono fun y hy => by simp only [hy, h\u2081, hx]) .rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf\u2080 f\u2081 : E \u2192 F\nf\u2080' f\u2081' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nh\u2080 : f\u2080 =\u1da0[L] f\u2081\nhx : f\u2080 x = f\u2081 x\nh\u2081 : \u2200 (x : E), f\u2080' x = f\u2081' x\n\u22a2 HasFDerivAtFilter f\u2080 f\u2080' x L \u2194 HasFDerivAtFilter f\u2081 f\u2081' x L"}, {"line": "simp only [hasFDerivAtFilter_iff_isLittleOTVS]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf\u2080 f\u2081 : E \u2192 F\nf\u2080' f\u2081' : E \u2192L[\ud835\udd5c] F\nx : E\nL : Filter E\nh\u2080 : f\u2080 =\u1da0[L] f\u2081\nhx : f\u2080 x = f\u2081 x\nh\u2081 : \u2200 (x : E), f\u2080' x = f\u2081' x\n\u22a2 ((fun x' => f\u2080 x' - f\u2080 x - f\u2080' (x' - x)) =o[\ud835\udd5c; L] fun x' => x' - x) \u2194\n    (fun x' => f\u2081 x' - f\u2081 x - f\u2081' (x' - x)) =o[\ud835\udd5c; L] fun x' => x' - x"}, {"line": "exact isLittleOTVS_congr (h\u2080.mono fun y hy => by simp only [hy, h\u2081, hx]) .rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_const (c : F) : fderivWithin \ud835\udd5c (fun _ \u21a6 c) s = 0 := by\n  ext\n  rw [fderivWithin_const_apply]\n  rw [Pi.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun x => c) s = 0"}, {"line": "ext", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nc : F\nx\u271d : E\n\u22a2 fderivWithin \ud835\udd5c (fun x => c) s x\u271d = 0 x\u271d"}, {"line": "rw [fderivWithin_const_apply]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\ns : Set E\nc : F\nx\u271d : E\n\u22a2 0 = 0 x\u271d"}, {"line": "rw [Pi.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderiv_const (c : F) : (fderiv \ud835\udd5c fun _ : E => c) = 0 := by\n  rw [\u2190 fderivWithin_univ]\n  rw [fderivWithin_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nc : F\n\u22a2 (fderiv \ud835\udd5c fun x => c) = 0"}, {"line": "rw [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nc : F\n\u22a2 fderivWithin \ud835\udd5c (fun x => c) univ = 0"}, {"line": "rw [fderivWithin_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivWithinAt_singleton (f : E \u2192 F) (x : E) :\n    HasFDerivWithinAt f (0 : E \u2192L[\ud835\udd5c] F) {x} x := by\n  simp only [HasFDerivWithinAt]\n  simp only [nhdsWithin_singleton]\n  simp only [hasFDerivAtFilter_iff_isLittleO]\n  simp only [isLittleO_pure]\n  simp only [ContinuousLinearMap.zero_apply]\n  simp only [sub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivWithinAt f 0 {x} x"}, {"line": "simp only [HasFDerivWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivAtFilter f 0 x (nhdsWithin x {x})"}, {"line": "simp only [nhdsWithin_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivAtFilter f 0 x (pure x)"}, {"line": "simp only [hasFDerivAtFilter_iff_isLittleO]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 (fun x' => f x' - f x - 0 (x' - x)) =o[pure x] fun x' => x' - x"}, {"line": "simp only [isLittleO_pure]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 f x - f x - 0 (x - x) = 0"}, {"line": "simp only [ContinuousLinearMap.zero_apply]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\n\u22a2 f x - f x - 0 = 0"}, {"line": "simp only [sub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_of_subsingleton [h : Subsingleton E] (f : E \u2192 F) (x : E) :\n    HasFDerivAt f (0 : E \u2192L[\ud835\udd5c] F) x := by\n  rw [\u2190 hasFDerivWithinAt_univ]\n  rw [subsingleton_univ.eq_singleton_of_mem (mem_univ x)]\n  exact hasFDerivWithinAt_singleton f x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nh : Subsingleton E\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivAt f 0 x"}, {"line": "rw [\u2190 hasFDerivWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nh : Subsingleton E\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivWithinAt f 0 univ x"}, {"line": "rw [subsingleton_univ.eq_singleton_of_mem (mem_univ x)]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nh : Subsingleton E\nf : E \u2192 F\nx : E\n\u22a2 HasFDerivWithinAt f 0 {x} x\n---\n\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nh : Subsingleton E\nf : E \u2192 F\nx : E\n\u22a2 Subsingleton E"}, {"line": "exact hasFDerivWithinAt_singleton f x", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nh : Subsingleton E\nf : E \u2192 F\nx : E\n\u22a2 Subsingleton E"}]}
{"declaration": "theorem differentiableAt_of_isInvertible_fderiv\n    (hf : (fderiv \ud835\udd5c f x).IsInvertible) : DifferentiableAt \ud835\udd5c f x := by\n  simp only [\u2190 differentiableWithinAt_univ] at hf \u22a2\n  simp only [\u2190 fderivWithin_univ] at hf \u22a2\n  exact differentiableWithinAt_of_isInvertible_fderivWithin hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Basic.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] [TopologicalSpace E]", "{F : Type*} [AddCommGroup F] [Module \ud835\udd5c F] [TopologicalSpace F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nhf : (fderiv \ud835\udd5c f x).IsInvertible\n\u22a2 DifferentiableAt \ud835\udd5c f x"}, {"line": "simp only [\u2190 differentiableWithinAt_univ] at hf \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nhf : (fderiv \ud835\udd5c f x).IsInvertible\n\u22a2 DifferentiableWithinAt \ud835\udd5c f univ x"}, {"line": "simp only [\u2190 fderivWithin_univ] at hf \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nx : E\nhf : (fderivWithin \ud835\udd5c f univ x).IsInvertible\n\u22a2 DifferentiableWithinAt \ud835\udd5c f univ x"}, {"line": "exact differentiableWithinAt_of_isInvertible_fderivWithin hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_comp\u2083 {g' : G \u2192 G'} {g : F \u2192 G} {t : Set F} {u : Set G} {y : F} {y' : G}\n    (hg' : DifferentiableWithinAt \ud835\udd5c g' u y') (hg : DifferentiableWithinAt \ud835\udd5c g t y)\n    (hf : DifferentiableWithinAt \ud835\udd5c f s x) (h2g : MapsTo g t u) (h2f : MapsTo f s t) (h3g : g y = y')\n    (h3f : f x = y) (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (g' \u2218 g \u2218 f) s x =\n      (fderivWithin \ud835\udd5c g' u y').comp ((fderivWithin \ud835\udd5c g t y).comp (fderivWithin \ud835\udd5c f s x)) := by\n  substs h3g h3f\n  exact (hg'.hasFDerivWithinAt.comp x (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h2f) <|\n    h2g.comp h2f).fderivWithin hxs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Comp.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f g : E \u2192 F} {f' g' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {L : Filter E}", "(x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : E \u2192 F\nx : E\ns : Set E\ng' : G \u2192 G'\ng : F \u2192 G\nt : Set F\nu : Set G\ny : F\ny' : G\nhg' : DifferentiableWithinAt \ud835\udd5c g' u y'\nhg : DifferentiableWithinAt \ud835\udd5c g t y\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nh2g : MapsTo g t u\nh2f : MapsTo f s t\nh3g : g y = y'\nh3f : f x = y\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 fderivWithin \ud835\udd5c (g' \u2218 g \u2218 f) s x = (fderivWithin \ud835\udd5c g' u y').comp ((fderivWithin \ud835\udd5c g t y).comp (fderivWithin \ud835\udd5c f s x))"}, {"line": "substs h3g h3f", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nf : E \u2192 F\nx : E\ns : Set E\ng' : G \u2192 G'\ng : F \u2192 G\nt : Set F\nu : Set G\nhf : DifferentiableWithinAt \ud835\udd5c f s x\nh2g : MapsTo g t u\nh2f : MapsTo f s t\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nhg : DifferentiableWithinAt \ud835\udd5c g t (f x)\nhg' : DifferentiableWithinAt \ud835\udd5c g' u (g (f x))\n\u22a2 fderivWithin \ud835\udd5c (g' \u2218 g \u2218 f) s x =\n    (fderivWithin \ud835\udd5c g' u (g (f x))).comp ((fderivWithin \ud835\udd5c g t (f x)).comp (fderivWithin \ud835\udd5c f s x))"}, {"line": "exact (hg'.hasFDerivWithinAt.comp x (hg.hasFDerivWithinAt.comp x hf.hasFDerivWithinAt h2f) <|\n    h2g.comp h2f).fderivWithin hxs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_differentiable_iff {f : G \u2192 E} : Differentiable \ud835\udd5c (iso \u2218 f) \u2194 Differentiable \ud835\udd5c f := by\n  rw [\u2190 differentiableOn_univ]\n  rw [\u2190 differentiableOn_univ]\n  exact iso.comp_differentiableOn_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\n\u22a2 Differentiable \ud835\udd5c (\u21d1iso \u2218 f) \u2194 Differentiable \ud835\udd5c f"}, {"line": "rw [\u2190 differentiableOn_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\n\u22a2 DifferentiableOn \ud835\udd5c (\u21d1iso \u2218 f) univ \u2194 Differentiable \ud835\udd5c f"}, {"line": "rw [\u2190 differentiableOn_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\n\u22a2 DifferentiableOn \ud835\udd5c (\u21d1iso \u2218 f) univ \u2194 DifferentiableOn \ud835\udd5c f univ"}, {"line": "exact iso.comp_differentiableOn_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_hasFDerivWithinAt_iff {f : G \u2192 E} {s : Set G} {x : G} {f' : G \u2192L[\ud835\udd5c] E} :\n    HasFDerivWithinAt (iso \u2218 f) ((iso : E \u2192L[\ud835\udd5c] F).comp f') s x \u2194 HasFDerivWithinAt f f' s x := by\n  refine \u27e8fun H => ?_, fun H => iso.hasFDerivAt.comp_hasFDerivWithinAt x H\u27e9\n  have A : f = iso.symm \u2218 iso \u2218 f := by\n    rw [\u2190 Function.comp_assoc]\n    rw [iso.symm_comp_self]\n    rfl\n  have B : f' = (iso.symm : F \u2192L[\ud835\udd5c] E).comp ((iso : E \u2192L[\ud835\udd5c] F).comp f') := by\n    rw [\u2190 ContinuousLinearMap.comp_assoc]\n    rw [iso.coe_symm_comp_coe]\n    rw [ContinuousLinearMap.id_comp]\n  rw [A]\n  rw [B]\n  exact iso.symm.hasFDerivAt.comp_hasFDerivWithinAt x H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\n\u22a2 HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x \u2194 HasFDerivWithinAt f f' s x"}, {"line": "refine \u27e8fun H => ?_, fun H => iso.hasFDerivAt.comp_hasFDerivWithinAt x H\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\nH : HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x\n\u22a2 HasFDerivWithinAt f f' s x"}, {"line": "have A : f = iso.symm \u2218 iso \u2218 f := by\n    rw [\u2190 Function.comp_assoc]\n    rw [iso.symm_comp_self]\n    rfl", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\nH : HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x\nA : f = sorry \u2218 \u21d1iso \u2218 f\n\u22a2 HasFDerivWithinAt f f' s x"}, {"line": "have B : f' = (iso.symm : F \u2192L[\ud835\udd5c] E).comp ((iso : E \u2192L[\ud835\udd5c] F).comp f') := by\n    rw [\u2190 ContinuousLinearMap.comp_assoc]\n    rw [iso.coe_symm_comp_coe]\n    rw [ContinuousLinearMap.id_comp]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\nH : HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x\nA : f = sorry \u2218 \u21d1iso \u2218 f\nB : f' = sorry\n\u22a2 HasFDerivWithinAt f f' s x"}, {"line": "rw [A]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\nH : HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x\nA : f = sorry \u2218 \u21d1iso \u2218 f\nB : f' = sorry\n\u22a2 HasFDerivWithinAt (sorry \u2218 \u21d1iso \u2218 f) f' s x"}, {"line": "rw [B]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nf' : G \u2192L[\ud835\udd5c] E\nH : HasFDerivWithinAt (\u21d1iso \u2218 f) ((\u2191iso).comp f') s x\nA : f = sorry \u2218 \u21d1iso \u2218 f\nB : f' = sorry\n\u22a2 HasFDerivWithinAt (sorry \u2218 \u21d1iso \u2218 f) sorry s x"}, {"line": "exact iso.symm.hasFDerivAt.comp_hasFDerivWithinAt x H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_fderivWithin {f : G \u2192 E} {s : Set G} {x : G} (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\n    fderivWithin \ud835\udd5c (iso \u2218 f) s x = (iso : E \u2192L[\ud835\udd5c] F).comp (fderivWithin \ud835\udd5c f s x) := by\n  by_cases h : DifferentiableWithinAt \ud835\udd5c f s x\n  \u00b7 rw [fderiv_comp_fderivWithin x iso.differentiableAt h hxs, iso.fderiv]\n  \u00b7 have : \u00acDifferentiableWithinAt \ud835\udd5c (iso \u2218 f) s x := mt iso.comp_differentiableWithinAt_iff.1 h\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h]\n    rw [fderivWithin_zero_of_not_differentiableWithinAt this]\n    rw [ContinuousLinearMap.comp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) s x = (\u2191iso).comp (fderivWithin \ud835\udd5c f s x)"}, {"line": "by_cases h : DifferentiableWithinAt \ud835\udd5c f s x", "tactic_state": "case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nh : sorry\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) s x = (\u2191iso).comp (fderivWithin \ud835\udd5c f s x)\n---\ncase neg\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nh : \u00acsorry\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) s x = (\u2191iso).comp (fderivWithin \ud835\udd5c f s x)"}, {"line": "\u00b7 rw [fderiv_comp_fderivWithin x iso.differentiableAt h hxs, iso.fderiv]", "tactic_state": "case neg\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nh : \u00acsorry\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) s x = (\u2191iso).comp (fderivWithin \ud835\udd5c f s x)"}, {"line": "\u00b7 have : \u00acDifferentiableWithinAt \ud835\udd5c (iso \u2218 f) s x := mt iso.comp_differentiableWithinAt_iff.1 h\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h]\n    rw [fderivWithin_zero_of_not_differentiableWithinAt this]\n    rw [ContinuousLinearMap.comp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_fderiv {f : G \u2192 E} {x : G} :\n    fderiv \ud835\udd5c (iso \u2218 f) x = (iso : E \u2192L[\ud835\udd5c] F).comp (fderiv \ud835\udd5c f x) := by\n  rw [\u2190 fderivWithin_univ]\n  rw [\u2190 fderivWithin_univ]\n  exact iso.comp_fderivWithin uniqueDiffWithinAt_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\nx : G\n\u22a2 fderiv \ud835\udd5c (\u21d1iso \u2218 f) x = (\u2191iso).comp (fderiv \ud835\udd5c f x)"}, {"line": "rw [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\nx : G\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) univ x = (\u2191iso).comp (fderiv \ud835\udd5c f x)"}, {"line": "rw [\u2190 fderivWithin_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243L[\ud835\udd5c] F\nf : G \u2192 E\nx : G\n\u22a2 fderivWithin \ud835\udd5c (\u21d1iso \u2218 f) univ x = (\u2191iso).comp (fderivWithin \ud835\udd5c f univ x)"}, {"line": "exact iso.comp_fderivWithin uniqueDiffWithinAt_univ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.fderiv_continuousLinearEquiv_comp' (L : G \u2243L[\ud835\udd5c] G') (f : E \u2192 (F \u2192L[\ud835\udd5c] G)) :\n    fderiv \ud835\udd5c (fun x \u21a6 (L : G \u2192L[\ud835\udd5c] G').comp (f x)) =\n      fun x \u21a6 (((ContinuousLinearEquiv.refl \ud835\udd5c F).arrowCongr L)) \u2218L (fderiv \ud835\udd5c f x) := by\n  ext x : 1\n  exact fderiv_continuousLinearEquiv_comp L f x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nL : G \u2243L[\ud835\udd5c] G'\nf : E \u2192 F \u2192L[\ud835\udd5c] G\n\u22a2 (fderiv \ud835\udd5c fun x => (\u2191L).comp (f x)) = fun x => (\u2191((ContinuousLinearEquiv.refl \ud835\udd5c F).arrowCongr L)).comp (fderiv \ud835\udd5c f x)"}, {"line": "ext x : 1", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nG' : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup G'\ninst\u271d : NormedSpace \ud835\udd5c G'\nL : G \u2243L[\ud835\udd5c] G'\nf : E \u2192 F \u2192L[\ud835\udd5c] G\nx : E\n\u22a2 fderiv \ud835\udd5c (fun x => (\u2191L).comp (f x)) x = (\u2191((ContinuousLinearEquiv.refl \ud835\udd5c F).arrowCongr L)).comp (fderiv \ud835\udd5c f x)"}, {"line": "exact fderiv_continuousLinearEquiv_comp L f x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_fderiv' {f : G \u2192 E} :\n    fderiv \ud835\udd5c (iso \u2218 f) = fun x \u21a6 (iso : E \u2192L[\ud835\udd5c] F).comp (fderiv \ud835\udd5c f x) := by\n  ext x : 1\n  exact LinearIsometryEquiv.comp_fderiv iso\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)", "(iso : E \u2243\u2097\u1d62[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243\u2097\u1d62[\ud835\udd5c] F\nf : G \u2192 E\n\u22a2 fderiv \ud835\udd5c (\u21d1iso \u2218 f) = fun x =>\n    (\u2191{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }).comp (fderiv \ud835\udd5c f x)"}, {"line": "ext x : 1", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b9 : NormedAddCommGroup G\ninst\u271d : NormedSpace \ud835\udd5c G\niso : E \u2243\u2097\u1d62[\ud835\udd5c] F\nf : G \u2192 E\nx : G\n\u22a2 fderiv \ud835\udd5c (\u21d1iso \u2218 f) x =\n    (\u2191{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }).comp (fderiv \ud835\udd5c f x)"}, {"line": "exact LinearIsometryEquiv.comp_fderiv iso", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.of_local_left_inverse {f : E \u2192 F} {f' : E \u2243L[\ud835\udd5c] F} {g : F \u2192 E} {a : F}\n    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) (g a))\n    (hfg : \u2200\u1da0 y in \ud835\udcdd a, f (g y) = y) : HasFDerivAt g (f'.symm : F \u2192L[\ud835\udd5c] E) a := by\n  simp only [\u2190 hasFDerivWithinAt_univ] at hf hfg \u22a2\n  simp only [\u2190 nhdsWithin_univ] at hf hfg \u22a2\n  exact hf.of_local_left_inverse (.inf hg (by simp)) (mem_univ _) hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)", "(iso : E \u2243\u2097\u1d62[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2243L[\ud835\udd5c] F\ng : F \u2192 E\na : F\nhg : ContinuousAt g a\nhf : HasFDerivAt f (\u2191f') (g a)\nhfg : \u2200\u1da0 (y : F) in nhds a, f (g y) = y\n\u22a2 HasFDerivAt g (\u2191f'.symm) a"}, {"line": "simp only [\u2190 hasFDerivWithinAt_univ] at hf hfg \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2243L[\ud835\udd5c] F\ng : F \u2192 E\na : F\nhg : ContinuousAt g a\nhfg : \u2200\u1da0 (y : F) in nhds a, f (g y) = y\nhf : HasFDerivWithinAt f (\u2191f') univ (g a)\n\u22a2 HasFDerivWithinAt g (\u2191f'.symm) univ a"}, {"line": "simp only [\u2190 nhdsWithin_univ] at hf hfg \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2243L[\ud835\udd5c] F\ng : F \u2192 E\na : F\nhg : ContinuousAt g a\nhf : HasFDerivWithinAt f (\u2191f') univ (g a)\nhfg : \u2200\u1da0 (y : F) in nhdsWithin a univ, f (g y) = y\n\u22a2 HasFDerivWithinAt g (\u2191f'.symm) univ a"}, {"line": "exact hf.of_local_left_inverse (.inf hg (by simp)) (mem_univ _) hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.eventually_ne (h : HasFDerivAt f f' x) (hf' : \u2203 C, \u2200 z, \u2016z\u2016 \u2264 C * \u2016f' z\u2016) :\n    \u2200\u1da0 z in \ud835\udcdd[\u2260] x, f z \u2260 c := by\n  simpa only [compl_eq_univ_diff] using (hasFDerivWithinAt_univ.2 h).eventually_ne hf'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Equiv.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {x : E} {s : Set E} {c : F}", "(iso : E \u2243L[\ud835\udd5c] F)", "(iso : E \u2243\u2097\u1d62[\ud835\udd5c] F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nx : E\nc : F\nh : HasFDerivAt f f' x\nhf' : \u2203 C, \u2200 (z : E), \u2016z\u2016 \u2264 C * \u2016f' z\u2016\n\u22a2 \u2200\u1da0 (z : E) in nhdsWithin x {x}\u1d9c, f z \u2260 c"}, {"line": "simpa only [compl_eq_univ_diff] using (hasFDerivWithinAt_univ.2 h).eventually_ne hf'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne {f g : \u211d \u2192 E} {x : \u211d}\n    (f_diff : \u2200 y \u2260 x, HasDerivAt f (g y) y) (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : HasDerivAt f (g x) x := by\n  have A : HasDerivWithinAt f (g x) (Ici x) x := by\n    have diff : DifferentiableOn \u211d f (Ioi x) := fun y hy =>\n      (f_diff y (ne_of_gt hy)).differentiableAt.differentiableWithinAt\n    -- next line is the nontrivial bit of this proof, appealing to differentiability\n    -- extension results.\n    apply\n      hasDerivWithinAt_Ici_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[>] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_gt hy)).deriv.symm\n  have B : HasDerivWithinAt f (g x) (Iic x) x := by\n    have diff : DifferentiableOn \u211d f (Iio x) := fun y hy =>\n      (f_diff y (ne_of_lt hy)).differentiableAt.differentiableWithinAt\n    -- next line is the nontrivial bit of this proof, appealing to differentiability\n    -- extension results.\n    apply\n      hasDerivWithinAt_Iic_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_lt hy)).deriv.symm\n  simpa using B.union A\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Extend.lean", "context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n\u22a2 HasDerivAt f (g x) x"}, {"line": "have A : HasDerivWithinAt f (g x) (Ici x) x := sorry", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nA : sorry\n\u22a2 HasDerivAt f (g x) x"}, {"line": "have B : HasDerivWithinAt f (g x) (Iic x) x := sorry", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nA : sorry\nB : sorry\n\u22a2 HasDerivAt f (g x) x"}, {"line": "simpa using B.union A", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne' {f g : \u211d \u2192 E} {x : \u211d}\n    (f_diff : \u2200 y \u2260 x, HasDerivAt f (g y) y) (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) (y : \u211d) : HasDerivAt f (g y) y := by\n  rcases eq_or_ne y x with (rfl | hne)\n  \u00b7 exact hasDerivAt_of_hasDerivAt_of_ne f_diff hf hg\n  \u00b7 exact f_diff y hne", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Extend.lean", "context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\ny : \u211d\n\u22a2 HasDerivAt f (g y) y"}, {"line": "rcases eq_or_ne y x with (rfl | hne)", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\ny : \u211d\nf_diff : \u2200 (y_1 : \u211d), y_1 \u2260 y \u2192 HasDerivAt f (g y_1) y_1\nhf : ContinuousAt f y\nhg : ContinuousAt g y\n\u22a2 HasDerivAt f (g y) y\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\ny : \u211d\nhne : y \u2260 x\n\u22a2 HasDerivAt f (g y) y"}, {"line": "\u00b7 exact hasDerivAt_of_hasDerivAt_of_ne f_diff hf hg", "tactic_state": "case inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\nx : \u211d\nf_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y\nhf : ContinuousAt f x\nhg : ContinuousAt g x\ny : \u211d\nhne : y \u2260 x\n\u22a2 HasDerivAt f (g y) y"}, {"line": "\u00b7 exact f_diff y hne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurable_deriv [MeasurableSpace \ud835\udd5c] [OpensMeasurableSpace \ud835\udd5c] [MeasurableSpace F]\n    [BorelSpace F] (f : \ud835\udd5c \u2192 F) : Measurable (deriv f) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const \ud835\udd5c f 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : NormedSpace \ud835\udd5c F\ninst\u271d\u2074 : CompleteSpace F\ninst\u271d\u00b3 : MeasurableSpace \ud835\udd5c\ninst\u271d\u00b2 : OpensMeasurableSpace \ud835\udd5c\ninst\u271d\u00b9 : MeasurableSpace F\ninst\u271d : BorelSpace F\nf : \ud835\udd5c \u2192 F\n\u22a2 Measurable (deriv f)"}, {"line": "simpa only [fderiv_deriv] using measurable_fderiv_apply_const \ud835\udd5c f 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stronglyMeasurable_deriv [MeasurableSpace \ud835\udd5c] [OpensMeasurableSpace \ud835\udd5c]\n    [h : SecondCountableTopologyEither \ud835\udd5c F] (f : \ud835\udd5c \u2192 F) : StronglyMeasurable (deriv f) := by\n  borelize F\n  rcases h.out with h\ud835\udd5c|hF\n  \u00b7 exact stronglyMeasurable_iff_measurable_separable.2\n      \u27e8measurable_deriv f, isSeparable_range_deriv _\u27e9\n  \u00b7 exact (measurable_deriv f).stronglyMeasurable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace \ud835\udd5c\ninst\u271d : OpensMeasurableSpace \ud835\udd5c\nh : SecondCountableTopologyEither \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\n\u22a2 StronglyMeasurable (deriv f)"}, {"line": "borelize F", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace \ud835\udd5c\ninst\u271d : OpensMeasurableSpace \ud835\udd5c\nh : SecondCountableTopologyEither \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nthis\u271d\u00b9 : MeasurableSpace F := sorry\nthis\u271d : sorry\n\u22a2 StronglyMeasurable (deriv f)"}, {"line": "rcases h.out with h\ud835\udd5c|hF", "tactic_state": "case inl\n\ud835\udd5c : Type u_4\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace \ud835\udd5c\ninst\u271d : OpensMeasurableSpace \ud835\udd5c\nh : SecondCountableTopologyEither \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nthis\u271d\u00b9 : MeasurableSpace F := sorry\nthis\u271d : sorry\nh\ud835\udd5c : SecondCountableTopology \ud835\udd5c\n\u22a2 StronglyMeasurable (deriv f)\n---\ncase inr\n\ud835\udd5c : Type u_4\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace \ud835\udd5c\ninst\u271d : OpensMeasurableSpace \ud835\udd5c\nh : SecondCountableTopologyEither \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nthis\u271d\u00b9 : MeasurableSpace F := sorry\nthis\u271d : sorry\nhF : SecondCountableTopology F\n\u22a2 StronglyMeasurable (deriv f)"}, {"line": "\u00b7 exact stronglyMeasurable_iff_measurable_separable.2\n      \u27e8measurable_deriv f, isSeparable_range_deriv _\u27e9", "tactic_state": "case inr\n\ud835\udd5c : Type u_4\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nF : Type u_6\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace \ud835\udd5c\ninst\u271d : OpensMeasurableSpace \ud835\udd5c\nh : SecondCountableTopologyEither \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nthis\u271d\u00b9 : MeasurableSpace F := sorry\nthis\u271d : sorry\nhF : SecondCountableTopology F\n\u22a2 StronglyMeasurable (deriv f)"}, {"line": "\u00b7 exact (measurable_deriv f).stronglyMeasurable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurableSet_of_differentiableWithinAt_Ioi :\n    MeasurableSet { x | DifferentiableWithinAt \u211d f (Ioi x) x } := by\n  simpa [differentiableWithinAt_Ioi_iff_Ici] using measurableSet_of_differentiableWithinAt_Ici f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux", "RightDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]", "{f : \u211d \u2192 F} (K : Set F)", "(f)", "[CompleteSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nf : \u211d \u2192 F\ninst\u271d : CompleteSpace F\n\u22a2 MeasurableSet {x | DifferentiableWithinAt \u211d f (Ioi x) x}"}, {"line": "simpa [differentiableWithinAt_Ioi_iff_Ici] using measurableSet_of_differentiableWithinAt_Ici f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurable_derivWithin_Ioi [MeasurableSpace F] [BorelSpace F] :\n    Measurable fun x => derivWithin f (Ioi x) x := by\n  simpa [derivWithin_Ioi_eq_Ici] using measurable_derivWithin_Ici f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux", "RightDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]", "{f : \u211d \u2192 F} (K : Set F)", "(f)", "[CompleteSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \u211d F\nf : \u211d \u2192 F\ninst\u271d\u00b2 : CompleteSpace F\ninst\u271d\u00b9 : MeasurableSpace F\ninst\u271d : BorelSpace F\n\u22a2 Measurable fun x => derivWithin f (Ioi x) x"}, {"line": "simpa [derivWithin_Ioi_eq_Ici] using measurable_derivWithin_Ici f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stronglyMeasurable_derivWithin_Ioi :\n    StronglyMeasurable (fun x \u21a6 derivWithin f (Ioi x) x) := by\n  simpa [derivWithin_Ioi_eq_Ici] using stronglyMeasurable_derivWithin_Ici f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux", "RightDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]", "{f : \u211d \u2192 F} (K : Set F)", "(f)", "[CompleteSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\nf : \u211d \u2192 F\ninst\u271d : CompleteSpace F\n\u22a2 StronglyMeasurable fun x => derivWithin f (Ioi x) x"}, {"line": "simpa [derivWithin_Ioi_eq_Ici] using stronglyMeasurable_derivWithin_Ici f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurable_deriv_with_param [LocallyCompactSpace \ud835\udd5c] [MeasurableSpace \ud835\udd5c]\n    [OpensMeasurableSpace \ud835\udd5c] [MeasurableSpace F]\n    [BorelSpace F] {f : \u03b1 \u2192 \ud835\udd5c \u2192 F} (hf : Continuous f.uncurry) :\n    Measurable (fun (p : \u03b1 \u00d7 \ud835\udd5c) \u21a6 deriv (f p.1) p.2) := by\n  simpa only [fderiv_deriv] using measurable_fderiv_apply_const_with_param \ud835\udd5c hf 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Measurable.lean", "context": {"open": ["Set Metric Asymptotics Filter ContinuousLinearMap MeasureTheory TopologicalSpace", "scoped Topology", "FDerivMeasurableAux", "RightDerivMeasurableAux", "Uniformity", "FDerivMeasurableAux"], "variables": ["{\ud835\udd5c E F : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{f : E \u2192 F} (K : Set (E \u2192L[\ud835\udd5c] F))", "[MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c f)", "[CompleteSpace F]", "{\ud835\udd5c}", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]", "{f : \u211d \u2192 F} (K : Set F)", "(f)", "[CompleteSpace F]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "[MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1] [MeasurableSpace E] [OpensMeasurableSpace E]", "(\ud835\udd5c)", "[CompleteSpace F]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u2079 : NormedAddCommGroup F\ninst\u271d\u2078 : NormedSpace \u211d F\ninst\u271d\u2077 : CompleteSpace F\n\ud835\udd5c : Type u_8\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : CompleteSpace F\n\u03b1 : Type u_9\ninst\u271d\u2074 : LocallyCompactSpace \ud835\udd5c\ninst\u271d\u00b3 : MeasurableSpace \ud835\udd5c\ninst\u271d\u00b2 : OpensMeasurableSpace \ud835\udd5c\ninst\u271d\u00b9 : MeasurableSpace F\ninst\u271d : BorelSpace F\nf : \u03b1 \u2192 \ud835\udd5c \u2192 F\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa only [fderiv_deriv] using measurable_fderiv_apply_const_with_param \ud835\udd5c hf 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.clm_comp (hc : HasFDerivWithinAt c c' s x)\n    (hd : HasFDerivWithinAt d d' s x) :\n    HasFDerivWithinAt (fun y => (c y).comp (d y))\n      ((compL \ud835\udd5c F G H (c x)).comp d' + ((compL \ud835\udd5c F G H).flip (d x)).comp c') s x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp_hasFDerivWithinAt x (hc.prodMk hd)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\ns : Set E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nc' : E \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] H\nd : E \u2192 F \u2192L[\ud835\udd5c] G\nd' : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nhc : HasFDerivWithinAt c c' s x\nhd : HasFDerivWithinAt d d' s x\n\u22a2 HasFDerivWithinAt (fun y => (c y).comp (d y)) (((compL \ud835\udd5c F G H) (c x)).comp d' + ((compL \ud835\udd5c F G H).flip (d x)).comp c')\n    s x"}, {"line": "exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp_hasFDerivWithinAt x (hc.prodMk hd)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.clm_comp (hc : HasFDerivAt c c' x) (hd : HasFDerivAt d d' x) :\n    HasFDerivAt (fun y => (c y).comp (d y))\n      ((compL \ud835\udd5c F G H (c x)).comp d' + ((compL \ud835\udd5c F G H).flip (d x)).comp c') x := by\n  exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp x <| hc.prodMk hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup F\ninst\u271d\u2074 : NormedSpace \ud835\udd5c F\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nc' : E \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] H\nd : E \u2192 F \u2192L[\ud835\udd5c] G\nd' : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G\nhc : HasFDerivAt c c' x\nhd : HasFDerivAt d d' x\n\u22a2 HasFDerivAt (fun y => (c y).comp (d y)) (((compL \ud835\udd5c F G H) (c x)).comp d' + ((compL \ud835\udd5c F G H).flip (d x)).comp c') x"}, {"line": "exact (isBoundedBilinearMap_comp.hasFDerivAt (c x, d x) :).comp x <| hc.prodMk hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.clm_apply (hc : HasFDerivWithinAt c c' s x)\n    (hu : HasFDerivWithinAt u u' s x) :\n    HasFDerivWithinAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) s x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp_hasFDerivWithinAt x\n    (hc.prodMk hu)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\ns : Set E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nc' : E \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] H\nu : E \u2192 G\nu' : E \u2192L[\ud835\udd5c] G\nhc : HasFDerivWithinAt c c' s x\nhu : HasFDerivWithinAt u u' s x\n\u22a2 HasFDerivWithinAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) s x"}, {"line": "exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp_hasFDerivWithinAt x\n    (hc.prodMk hu)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.clm_apply (hc : HasFDerivAt c c' x) (hu : HasFDerivAt u u' x) :\n    HasFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x := by\n  exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp x (hc.prodMk hu)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nc' : E \u2192L[\ud835\udd5c] G \u2192L[\ud835\udd5c] H\nu : E \u2192 G\nu' : E \u2192L[\ud835\udd5c] G\nhc : HasFDerivAt c c' x\nhu : HasFDerivAt u u' x\n\u22a2 HasFDerivAt (fun y => (c y) (u y)) ((c x).comp u' + c'.flip (u x)) x"}, {"line": "exact (isBoundedBilinearMap_apply.hasFDerivAt (c x, u x) :).comp x (hc.prodMk hu)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fderivWithin_continuousMultilinear_apply_const_apply (hxs : UniqueDiffWithinAt \ud835\udd5c s x)\n    (hc : DifferentiableWithinAt \ud835\udd5c c s x) (u : \u2200 i, M i) (m : E) :\n    (fderivWithin \ud835\udd5c (fun y \u21a6 (c y) u) s x) m = (fderivWithin \ud835\udd5c c s x) m u := by\n  simp [fderivWithin_continuousMultilinear_apply_const hxs hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\ns : Set E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nx\u271d : Sort u_7\nM : x\u271d\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nu : ?m.24946 hxs hc \u2192 sorry\nm : E\n\u22a2 (fderivWithin \ud835\udd5c (fun y => (c y) sorry) s x) m = ((fderivWithin \ud835\udd5c c s x) m) sorry"}, {"line": "simp [fderivWithin_continuousMultilinear_apply_const hxs hc]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\ns : Set E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nx\u271d : Sort u_7\nM : x\u271d\nhxs : UniqueDiffWithinAt \ud835\udd5c s x\nhc : DifferentiableWithinAt \ud835\udd5c c s x\nu : ?m.24946 hxs hc \u2192 sorry\nm : E\n\u22a2 (fderivWithin \ud835\udd5c (fun y => (c y) (sorry ())) s x) m = ((fderivWithin \ud835\udd5c c s x) m) (sorry ())"}]}
{"declaration": "theorem fderiv_continuousMultilinear_apply_const_apply (hc : DifferentiableAt \ud835\udd5c c x)\n    (u : \u2200 i, M i) (m : E) :\n    (fderiv \ud835\udd5c (fun y \u21a6 (c y) u) x) m = (fderiv \ud835\udd5c c x) m u := by\n  simp [fderiv_continuousMultilinear_apply_const hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nx\u271d : Sort u_7\nM : x\u271d\nhc : DifferentiableAt \ud835\udd5c c x\nu : ?m.24693 hc \u2192 sorry\nm : E\n\u22a2 (fderiv \ud835\udd5c (fun y => (c y) sorry) x) m = ((fderiv \ud835\udd5c c x) m) sorry"}, {"line": "simp [fderiv_continuousMultilinear_apply_const hc]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\nG : Type u_4\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c G\nx : E\nH : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : NormedSpace \ud835\udd5c H\nc : E \u2192 G \u2192L[\ud835\udd5c] H\nx\u271d : Sort u_7\nM : x\u271d\nhc : DifferentiableAt \ud835\udd5c c x\nu : ?m.24693 hc \u2192 sorry\nm : E\n\u22a2 (fderiv \ud835\udd5c (fun y => (c y) (sorry ())) x) m = ((fderiv \ud835\udd5c c x) m) (sorry ())"}]}
{"declaration": "theorem HasStrictFDerivAt.smul_const (hc : HasStrictFDerivAt c c' x) (f : F) :\n    HasStrictFDerivAt (fun y => c y \u2022 f) (c'.smulRight f) x := by\n  simpa only [smul_zero,zero_add] using hc.smul (hasStrictFDerivAt_const f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{c : E \u2192 \ud835\udd5c'} {c' : E \u2192L[\ud835\udd5c] \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\nx : E\n\ud835\udd5c' : Type u_7\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormedSpace \ud835\udd5c' F\nc : E \u2192 \ud835\udd5c'\nc' : E \u2192L[\ud835\udd5c] \ud835\udd5c'\nhc : HasStrictFDerivAt c c' x\nf : F\n\u22a2 HasStrictFDerivAt (fun y => c y \u2022 f) sorry x"}, {"line": "simpa only [smul_zero,zero_add] using hc.smul (hasStrictFDerivAt_const f x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.smul_const (hc : HasFDerivWithinAt c c' s x) (f : F) :\n    HasFDerivWithinAt (fun y => c y \u2022 f) (c'.smulRight f) s x := by\n  simpa only [smul_zero,zero_add] using hc.smul (hasFDerivWithinAt_const f x s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{c : E \u2192 \ud835\udd5c'} {c' : E \u2192L[\ud835\udd5c] \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\nx : E\ns : Set E\n\ud835\udd5c' : Type u_7\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormedSpace \ud835\udd5c' F\nc : E \u2192 \ud835\udd5c'\nc' : E \u2192L[\ud835\udd5c] \ud835\udd5c'\nhc : HasFDerivWithinAt c c' s x\nf : F\n\u22a2 HasFDerivWithinAt (fun y => c y \u2022 f) sorry s x"}, {"line": "simpa only [smul_zero,zero_add] using hc.smul (hasFDerivWithinAt_const f x s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.smul_const (hc : HasFDerivAt c c' x) (f : F) :\n    HasFDerivAt (fun y => c y \u2022 f) (c'.smulRight f) x := by\n  simpa only [smul_zero,zero_add] using hc.smul (hasFDerivAt_const f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{c : E \u2192 \ud835\udd5c'} {c' : E \u2192L[\ud835\udd5c] \ud835\udd5c'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c F\nx : E\n\ud835\udd5c' : Type u_7\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormedSpace \ud835\udd5c' F\nc : E \u2192 \ud835\udd5c'\nc' : E \u2192L[\ud835\udd5c] \ud835\udd5c'\nhc : HasFDerivAt c c' x\nf : F\n\u22a2 HasFDerivAt (fun y => c y \u2022 f) sorry x"}, {"line": "simpa only [smul_zero,zero_add] using hc.smul (hasFDerivAt_const f x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictFDerivAt_ringInverse (x : R\u02e3) :\n    HasStrictFDerivAt Ring.inverse (-mulLeftRight \ud835\udd5c R \u2191x\u207b\u00b9 \u2191x\u207b\u00b9) x := by\n  convert (analyticAt_inverse (\ud835\udd5c := \ud835\udd5c) x).hasStrictFDerivAt\n  exact (fderiv_inverse x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Mul.lean", "context": {"open": ["Asymptotics ContinuousLinearMap Topology", "NormedRing ContinuousLinearMap Ring"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F}", "{x : E}", "{s : Set E}", "{H : Type*} [NormedAddCommGroup H] [NormedSpace \ud835\udd5c H] {c : E \u2192 G \u2192L[\ud835\udd5c] H}", "{\u03b9 : Type*} [Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "{c : E \u2192 \ud835\udd5c'} {c' : E \u2192L[\ud835\udd5c] \ud835\udd5c'}", "{\ud835\udd38 \ud835\udd38' : Type*} [NormedRing \ud835\udd38] [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38] [NormedAlgebra \ud835\udd5c \ud835\udd38']", "{\u03b9 : Type*} {\ud835\udd38 \ud835\udd38' : Type*} [NormedRing \ud835\udd38] [NormedCommRing \ud835\udd38'] [NormedAlgebra \ud835\udd5c \ud835\udd38]", "{R : Type*} [NormedRing R] [HasSummableGeomSeries R] [NormedAlgebra \ud835\udd5c R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_13\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : HasSummableGeomSeries R\ninst\u271d : NormedAlgebra \ud835\udd5c R\nx : R\u02e3\n\u22a2 HasStrictFDerivAt Ring.inverse (-((mulLeftRight \ud835\udd5c R) \u2191x\u207b\u00b9) \u2191x\u207b\u00b9) \u2191x"}, {"line": "convert (analyticAt_inverse (\ud835\udd5c := \ud835\udd5c) x).hasStrictFDerivAt", "tactic_state": "case h.e'_12.h.h.h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_13\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : HasSummableGeomSeries R\ninst\u271d : NormedAlgebra \ud835\udd5c R\nx : R\u02e3\ne_4\u271d : SeminormedAddCommGroup.toAddCommGroup = NormedAddCommGroup.toAddCommGroup\nhe\u271d : NormedSpace.toModule = NormedSpace.toModule\n\u22a2 -((mulLeftRight \ud835\udd5c R) \u2191x\u207b\u00b9) \u2191x\u207b\u00b9 = fderiv \ud835\udd5c Ring.inverse \u2191x\n---\ncase convert_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_13\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : HasSummableGeomSeries R\ninst\u271d : NormedAlgebra \ud835\udd5c R\nx : R\u02e3\n\u22a2 HasSummableGeomSeries R"}, {"line": "exact (fderiv_inverse x).symm", "tactic_state": "case convert_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nR : Type u_13\ninst\u271d\u00b2 : NormedRing R\ninst\u271d\u00b9 : HasSummableGeomSeries R\ninst\u271d : NormedAlgebra \ud835\udd5c R\nx : R\u02e3\n\u22a2 HasSummableGeomSeries R"}]}
{"declaration": "theorem hasStrictFDerivAt_finCons {\u03c6' : E \u2192L[\ud835\udd5c] \u03a0 i, F' i} :\n    HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u03c6' x \u2194\n      HasStrictFDerivAt \u03c6 (.proj 0 \u2218L \u03c6') x \u2227\n      HasStrictFDerivAt \u03c6s (Pi.compRightL \ud835\udd5c F' Fin.succ \u2218L \u03c6') x := by\n  rw [hasStrictFDerivAt_pi']\n  rw [Fin.forall_fin_succ]\n  rw [hasStrictFDerivAt_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u03c6' x \u2194\n    HasStrictFDerivAt \u03c6 ((proj 0).comp \u03c6') x \u2227 HasStrictFDerivAt \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x"}, {"line": "rw [hasStrictFDerivAt_pi']", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 (\u2200 (i : Fin (n + 1)), HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) ((proj i).comp \u03c6') x) \u2194\n    HasStrictFDerivAt \u03c6 ((proj 0).comp \u03c6') x \u2227 HasStrictFDerivAt \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 (HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) ((proj 0).comp \u03c6') x \u2227\n      \u2200 (i : Fin n), HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) ((proj i.succ).comp \u03c6') x) \u2194\n    HasStrictFDerivAt \u03c6 ((proj 0).comp \u03c6') x \u2227 HasStrictFDerivAt \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x"}, {"line": "rw [hasStrictFDerivAt_pi']", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 (HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) ((proj 0).comp \u03c6') x \u2227\n      \u2200 (i : Fin n), HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) ((proj i.succ).comp \u03c6') x) \u2194\n    HasStrictFDerivAt \u03c6 ((proj 0).comp \u03c6') x \u2227\n      \u2200 (i : Fin n), HasStrictFDerivAt (fun x => \u03c6s x i) ((proj i).comp ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6')) x"}, {"line": "dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 (HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0)\n        { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x \u2227\n      \u2200 (i : Fin n),\n        HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ)\n          { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x) \u2194\n    HasStrictFDerivAt \u03c6 { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x \u2227\n      \u2200 (i : Fin n),\n        HasStrictFDerivAt (fun x => \u03c6s x i) { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef }\n          x"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\n\u22a2 (HasStrictFDerivAt (fun x => \u03c6 x) { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x \u2227\n      \u2200 (i : Fin n),\n        HasStrictFDerivAt (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ)\n          { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x) \u2194\n    HasStrictFDerivAt \u03c6 { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x \u2227\n      \u2200 (i : Fin n),\n        HasStrictFDerivAt (fun x => \u03c6s x i) { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef }\n          x"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAtFilter_finCons\n    {\u03c6' : E \u2192L[\ud835\udd5c] \u03a0 i, F' i} {l : Filter E} :\n    HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u03c6' x l \u2194\n      HasFDerivAtFilter \u03c6 (.proj 0 \u2218L \u03c6') x l \u2227\n      HasFDerivAtFilter \u03c6s (Pi.compRightL \ud835\udd5c F' Fin.succ \u2218L \u03c6') x l := by\n  rw [hasFDerivAtFilter_pi']\n  rw [Fin.forall_fin_succ]\n  rw [hasFDerivAtFilter_pi']\n  dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u03c6' x l \u2194\n    HasFDerivAtFilter \u03c6 ((proj 0).comp \u03c6') x l \u2227 HasFDerivAtFilter \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x l"}, {"line": "rw [hasFDerivAtFilter_pi']", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 (\u2200 (i : Fin (n + 1)), HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) ((proj i).comp \u03c6') x l) \u2194\n    HasFDerivAtFilter \u03c6 ((proj 0).comp \u03c6') x l \u2227 HasFDerivAtFilter \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x l"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 (HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) ((proj 0).comp \u03c6') x l \u2227\n      \u2200 (i : Fin n), HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) ((proj i.succ).comp \u03c6') x l) \u2194\n    HasFDerivAtFilter \u03c6 ((proj 0).comp \u03c6') x l \u2227 HasFDerivAtFilter \u03c6s ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6') x l"}, {"line": "rw [hasFDerivAtFilter_pi']", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 (HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) ((proj 0).comp \u03c6') x l \u2227\n      \u2200 (i : Fin n), HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) ((proj i.succ).comp \u03c6') x l) \u2194\n    HasFDerivAtFilter \u03c6 ((proj 0).comp \u03c6') x l \u2227\n      \u2200 (i : Fin n), HasFDerivAtFilter (fun x => \u03c6s x i) ((proj i).comp ((Pi.compRightL \ud835\udd5c F' Fin.succ).comp \u03c6')) x l"}, {"line": "dsimp [ContinuousLinearMap.comp, LinearMap.comp, Function.comp_def]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 (HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0)\n        { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l \u2227\n      \u2200 (i : Fin n),\n        HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ)\n          { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l) \u2194\n    HasFDerivAtFilter \u03c6 { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l \u2227\n      \u2200 (i : Fin n),\n        HasFDerivAtFilter (fun x => \u03c6s x i) { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef }\n          x l"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u03c6' : E \u2192L[\ud835\udd5c] (i : Fin n.succ) \u2192 F' i\nl : Filter E\n\u22a2 (HasFDerivAtFilter (fun x => \u03c6 x) { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l \u2227\n      \u2200 (i : Fin n),\n        HasFDerivAtFilter (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ)\n          { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l) \u2194\n    HasFDerivAtFilter \u03c6 { toFun := fun x => \u03c6' x 0, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef } x l \u2227\n      \u2200 (i : Fin n),\n        HasFDerivAtFilter (fun x => \u03c6s x i) { toFun := fun x => \u03c6' x i.succ, map_add' := \u22ef, map_smul' := \u22ef, cont := \u22ef }\n          x l"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableWithinAt_finCons :\n    DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) s x \u2194\n      DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 DifferentiableWithinAt \ud835\udd5c \u03c6s s x := by\n  rw [differentiableWithinAt_pi]\n  rw [Fin.forall_fin_succ]\n  rw [differentiableWithinAt_pi]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) s x \u2194\n    DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 DifferentiableWithinAt \ud835\udd5c \u03c6s s x"}, {"line": "rw [differentiableWithinAt_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (\u2200 (i : Fin (n + 1)), DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) s x) \u2194\n    DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 DifferentiableWithinAt \ud835\udd5c \u03c6s s x"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) s x \u2227\n      \u2200 (i : Fin n), DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s x) \u2194\n    DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 DifferentiableWithinAt \ud835\udd5c \u03c6s s x"}, {"line": "rw [differentiableWithinAt_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) s x \u2227\n      \u2200 (i : Fin n), DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s x) \u2194\n    DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 \u2200 (i : Fin n), DifferentiableWithinAt \ud835\udd5c (fun x => \u03c6s x i) s x"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableWithinAt \ud835\udd5c (fun x => \u03c6 x) s x \u2227\n      \u2200 (i : Fin n), DifferentiableWithinAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s x) \u2194\n    DifferentiableWithinAt \ud835\udd5c \u03c6 s x \u2227 \u2200 (i : Fin n), DifferentiableWithinAt \ud835\udd5c (fun x => \u03c6s x i) s x"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableAt_finCons :\n    DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) x \u2194\n      DifferentiableAt \ud835\udd5c \u03c6 x \u2227 DifferentiableAt \ud835\udd5c \u03c6s x := by\n  rw [differentiableAt_pi]\n  rw [Fin.forall_fin_succ]\n  rw [differentiableAt_pi]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) x \u2194 DifferentiableAt \ud835\udd5c \u03c6 x \u2227 DifferentiableAt \ud835\udd5c \u03c6s x"}, {"line": "rw [differentiableAt_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (\u2200 (i : Fin (n + 1)), DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) x) \u2194\n    DifferentiableAt \ud835\udd5c \u03c6 x \u2227 DifferentiableAt \ud835\udd5c \u03c6s x"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) x \u2227\n      \u2200 (i : Fin n), DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) x) \u2194\n    DifferentiableAt \ud835\udd5c \u03c6 x \u2227 DifferentiableAt \ud835\udd5c \u03c6s x"}, {"line": "rw [differentiableAt_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) x \u2227\n      \u2200 (i : Fin n), DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) x) \u2194\n    DifferentiableAt \ud835\udd5c \u03c6 x \u2227 \u2200 (i : Fin n), DifferentiableAt \ud835\udd5c (fun x => \u03c6s x i) x"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nx : E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableAt \ud835\udd5c (fun x => \u03c6 x) x \u2227 \u2200 (i : Fin n), DifferentiableAt \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) x) \u2194\n    DifferentiableAt \ud835\udd5c \u03c6 x \u2227 \u2200 (i : Fin n), DifferentiableAt \ud835\udd5c (fun x => \u03c6s x i) x"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableOn_finCons :\n    DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) s \u2194\n      DifferentiableOn \ud835\udd5c \u03c6 s \u2227 DifferentiableOn \ud835\udd5c \u03c6s s := by\n  rw [differentiableOn_pi]\n  rw [Fin.forall_fin_succ]\n  rw [differentiableOn_pi]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) s \u2194 DifferentiableOn \ud835\udd5c \u03c6 s \u2227 DifferentiableOn \ud835\udd5c \u03c6s s"}, {"line": "rw [differentiableOn_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (\u2200 (i : Fin (n + 1)), DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) s) \u2194\n    DifferentiableOn \ud835\udd5c \u03c6 s \u2227 DifferentiableOn \ud835\udd5c \u03c6s s"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) s \u2227\n      \u2200 (i : Fin n), DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s) \u2194\n    DifferentiableOn \ud835\udd5c \u03c6 s \u2227 DifferentiableOn \ud835\udd5c \u03c6s s"}, {"line": "rw [differentiableOn_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) s \u2227\n      \u2200 (i : Fin n), DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s) \u2194\n    DifferentiableOn \ud835\udd5c \u03c6 s \u2227 \u2200 (i : Fin n), DifferentiableOn \ud835\udd5c (fun x => \u03c6s x i) s"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ns : Set E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (DifferentiableOn \ud835\udd5c (fun x => \u03c6 x) s \u2227 \u2200 (i : Fin n), DifferentiableOn \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) s) \u2194\n    DifferentiableOn \ud835\udd5c \u03c6 s \u2227 \u2200 (i : Fin n), DifferentiableOn \ud835\udd5c (fun x => \u03c6s x i) s"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiable_finCons :\n    Differentiable \ud835\udd5c (fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u2194\n      Differentiable \ud835\udd5c \u03c6 \u2227 Differentiable \ud835\udd5c \u03c6s := by\n  rw [differentiable_pi]\n  rw [Fin.forall_fin_succ]\n  rw [differentiable_pi]\n  simp only [Fin.cons_zero]\n  simp only [Fin.cons_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Prod.lean", "context": {"open": ["Filter Asymptotics ContinuousLinearMap Set Metric Topology NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \ud835\udd5c G]", "{G' : Type*} [NormedAddCommGroup G'] [NormedSpace \ud835\udd5c G']", "{f f\u2080 f\u2081 g : E \u2192 F}", "{f' f\u2080' f\u2081' g' : E \u2192L[\ud835\udd5c] F}", "(e : E \u2192L[\ud835\udd5c] F)", "{x : E}", "{s t : Set E}", "{L L\u2081 L\u2082 : Filter E}", "{f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : E \u2192 F \u00d7 G} {f\u2082' : E \u2192L[\ud835\udd5c] F \u00d7 G} {p : E \u00d7 F}", "{f\u2082 : G \u2192 G'} {f\u2082' : G \u2192L[\ud835\udd5c] G'} {y : G} (p : E \u00d7 G)", "{\u03b9 : Type*} [Fintype \u03b9] {F' : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (F' i)]", "{n : Nat} {F' : Fin n.succ \u2192 Type*}", "[\u2200 i, NormedAddCommGroup (F' i)] [\u2200 i, NormedSpace \ud835\udd5c (F' i)]", "{\u03c6 : E \u2192 F' 0} {\u03c6s : E \u2192 \u2200 i, F' (Fin.succ i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x)) \u2194 Differentiable \ud835\udd5c \u03c6 \u2227 Differentiable \ud835\udd5c \u03c6s"}, {"line": "rw [differentiable_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 (\u2200 (i : Fin (n + 1)), Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) i) \u2194 Differentiable \ud835\udd5c \u03c6 \u2227 Differentiable \ud835\udd5c \u03c6s"}, {"line": "rw [Fin.forall_fin_succ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 ((Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) \u2227\n      \u2200 (i : Fin n), Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) \u2194\n    Differentiable \ud835\udd5c \u03c6 \u2227 Differentiable \ud835\udd5c \u03c6s"}, {"line": "rw [differentiable_pi]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 ((Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) 0) \u2227\n      \u2200 (i : Fin n), Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) \u2194\n    Differentiable \ud835\udd5c \u03c6 \u2227 \u2200 (i : Fin n), Differentiable \ud835\udd5c fun x => \u03c6s x i"}, {"line": "simp only [Fin.cons_zero]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nn : \u2115\nF' : Fin n.succ \u2192 Type u_8\ninst\u271d\u00b9 : (i : Fin n.succ) \u2192 NormedAddCommGroup (F' i)\ninst\u271d : (i : Fin n.succ) \u2192 NormedSpace \ud835\udd5c (F' i)\n\u03c6 : E \u2192 F' 0\n\u03c6s : E \u2192 (i : Fin n) \u2192 F' i.succ\n\u22a2 ((Differentiable \ud835\udd5c fun x => \u03c6 x) \u2227 \u2200 (i : Fin n), Differentiable \ud835\udd5c fun x => Fin.cons (\u03c6 x) (\u03c6s x) i.succ) \u2194\n    Differentiable \ud835\udd5c \u03c6 \u2227 \u2200 (i : Fin n), Differentiable \ud835\udd5c fun x => \u03c6s x i"}, {"line": "simp only [Fin.cons_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_minSmoothness {n : WithTop \u2115\u221e} : n \u2264 minSmoothness \ud835\udd5c n := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean", "context": {"open": ["Asymptotics Set Filter", "scoped Topology ContDiff", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\n\u22a2 n \u2264 minSmoothness \ud835\udd5c n"}, {"line": "simp only [minSmoothness]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn : WithTop \u2115\u221e\n\u22a2 n \u2264 if IsRCLikeNormedField \ud835\udd5c then n else \u22a4"}, {"line": "split_ifs <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma minSmoothness_add {n m : WithTop \u2115\u221e} : minSmoothness \ud835\udd5c (n + m) = minSmoothness \ud835\udd5c n + m := by\n  simp only [minSmoothness]\n  split_ifs <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean", "context": {"open": ["Asymptotics Set Filter", "scoped Topology ContDiff", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn m : WithTop \u2115\u221e\n\u22a2 minSmoothness \ud835\udd5c (n + m) = minSmoothness \ud835\udd5c n + m"}, {"line": "simp only [minSmoothness]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn m : WithTop \u2115\u221e\n\u22a2 (if IsRCLikeNormedField \ud835\udd5c then n + m else \u22a4) = (if IsRCLikeNormedField \ud835\udd5c then n else \u22a4) + m"}, {"line": "split_ifs <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma minSmoothness_monotone : Monotone (minSmoothness \ud835\udd5c) := by\n  intro m n hmn\n  simp only [minSmoothness]\n  split_ifs <;> simp [hmn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/FDeriv/Symmetric.lean", "context": {"open": ["Asymptotics Set Filter", "scoped Topology ContDiff", "scoped Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u22a2 Monotone (minSmoothness \ud835\udd5c)"}, {"line": "intro m n hmn", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm n : WithTop \u2115\u221e\nhmn : m \u2264 n\n\u22a2 minSmoothness \ud835\udd5c m \u2264 minSmoothness \ud835\udd5c n"}, {"line": "simp only [minSmoothness]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nm n : WithTop \u2115\u221e\nhmn : m \u2264 n\n\u22a2 (if IsRCLikeNormedField \ud835\udd5c then m else \u22a4) \u2264 if IsRCLikeNormedField \ud835\udd5c then n else \u22a4"}, {"line": "split_ifs <;> simp [hmn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gradient_eq_deriv : \u2207 g u = starRingEnd \ud835\udd5c (deriv g u) := by\n  by_cases h : DifferentiableAt \ud835\udd5c g u\n  \u00b7 rw [h.hasGradientAt.hasDerivAt.deriv, RCLike.conj_conj]\n  \u00b7 rw [gradient_eq_zero_of_not_differentiableAt h, deriv_zero_of_not_differentiableAt h, map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/Gradient/Basic.lean", "context": {"open": ["Topology InnerProductSpace Set", "scoped Gradient"], "variables": ["{\ud835\udd5c F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup F] [InnerProductSpace \ud835\udd5c F] [CompleteSpace F]", "{f : F \u2192 \ud835\udd5c} {f' x : F}", "{s : Set F} {L : Filter F}", "{g : \ud835\udd5c \u2192 \ud835\udd5c} {g' u : \ud835\udd5c} {L' : Filter \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\ng : \ud835\udd5c \u2192 \ud835\udd5c\nu : \ud835\udd5c\n\u22a2 gradient g u = (starRingEnd \ud835\udd5c) (deriv g u)"}, {"line": "by_cases h : DifferentiableAt \ud835\udd5c g u", "tactic_state": "case pos\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\ng : \ud835\udd5c \u2192 \ud835\udd5c\nu : \ud835\udd5c\nh : sorry\n\u22a2 gradient g u = (starRingEnd \ud835\udd5c) (deriv g u)\n---\ncase neg\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\ng : \ud835\udd5c \u2192 \ud835\udd5c\nu : \ud835\udd5c\nh : \u00acsorry\n\u22a2 gradient g u = (starRingEnd \ud835\udd5c) (deriv g u)"}, {"line": "\u00b7 rw [h.hasGradientAt.hasDerivAt.deriv, RCLike.conj_conj]", "tactic_state": "case neg\n\ud835\udd5c : Type u_1\ninst\u271d : RCLike \ud835\udd5c\ng : \ud835\udd5c \u2192 \ud835\udd5c\nu : \ud835\udd5c\nh : \u00acsorry\n\u22a2 gradient g u = (starRingEnd \ud835\udd5c) (deriv g u)"}, {"line": "\u00b7 rw [gradient_eq_zero_of_not_differentiableAt h, deriv_zero_of_not_differentiableAt h, map_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_homeomorph_extension {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] [FiniteDimensional \u211d F] {s : Set E}\n    {f : E \u2192 F} {f' : E \u2243L[\u211d] F} {c : \u211d\u22650} (hf : ApproximatesLinearOn f (f' : E \u2192L[\u211d] F) s c)\n    (hc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016(f'.symm : F \u2192L[\u211d] E)\u2016\u208a\u207b\u00b9) :\n    \u2203 g : E \u2243\u209c F, EqOn f g s := by\n  -- the difference `f - f'` is Lipschitz on `s`. It can be extended to a Lipschitz function `u`\n  -- on the whole space, with a slightly worse Lipschitz constant. Then `f' + u` will be the\n  -- desired homeomorphism.\n  obtain \u27e8u, hu, uf\u27e9 :\n    \u2203 u : E \u2192 F, LipschitzWith (lipschitzExtensionConstant F * c) u \u2227 EqOn (f - \u21d1f') u s :=\n    hf.lipschitzOnWith.extend_finite_dimension\n  let g : E \u2192 F := fun x => f' x + u x\n  have fg : EqOn f g s := fun x hx => by simp_rw [g, \u2190 uf hx, Pi.sub_apply, add_sub_cancel]\n  have hg : ApproximatesLinearOn g (f' : E \u2192L[\u211d] F) univ (lipschitzExtensionConstant F * c) := by\n    apply LipschitzOnWith.approximatesLinearOn\n    rw [lipschitzOnWith_univ]\n    convert hu\n    ext x\n    simp only [g]\n    simp only [add_sub_cancel_left]\n    simp only [ContinuousLinearEquiv.coe_coe]\n    simp only [Pi.sub_apply]\n  haveI : FiniteDimensional \u211d E := f'.symm.finiteDimensional\n  exact \u27e8hg.toHomeomorph g hc, fg\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/InverseFunctionTheorem/FiniteDimensional.lean", "context": {"open": ["Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "obtain \u27e8u, hu, uf\u27e9 :\n    \u2203 u : E \u2192 F, LipschitzWith (lipschitzExtensionConstant F * c) u \u2227 EqOn (f - \u21d1f') u s :=\n    hf.lipschitzOnWith.extend_finite_dimension", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nu : E \u2192 F\nhu : sorry\nuf : EqOn sorry u s\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "let g : E \u2192 F := fun x => f' x + u x", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nu : E \u2192 F\nhu : sorry\nuf : EqOn sorry u s\ng : E \u2192 F := fun x => sorry\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "have fg : EqOn f g s := fun x hx => by simp_rw [g, \u2190 uf hx, Pi.sub_apply, add_sub_cancel]", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nu : E \u2192 F\nhu : sorry\nuf : EqOn sorry u s\ng : E \u2192 F := fun x => sorry\nfg : EqOn f g s\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "have hg : ApproximatesLinearOn g (f' : E \u2192L[\u211d] F) univ (lipschitzExtensionConstant F * c) := sorry", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nu : E \u2192 F\nhu : sorry\nuf : EqOn sorry u s\ng : E \u2192 F := fun x => sorry\nfg : EqOn f g s\nhg : sorry\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "haveI : FiniteDimensional \u211d E := f'.symm.finiteDimensional", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\nF : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\ns : Set E\nf : E \u2192 F\nf' : E \u2243L[\u211d] F\nc : NNReal\nhf : ApproximatesLinearOn f (\u2191f') s c\nhc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9\nu : E \u2192 F\nhu : sorry\nuf : EqOn sorry u s\ng : E \u2192 F := fun x => sorry\nfg : EqOn f g s\nhg : sorry\nthis : sorry\n\u22a2 \u2203 g, EqOn f (\u21d1g) s"}, {"line": "exact \u27e8hg.toHomeomorph g hc, fg\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem approximatesLinearOn_empty (f : E \u2192 F) (f' : E \u2192L[\ud835\udd5c] F) (c : \u211d\u22650) :\n    ApproximatesLinearOn f f' \u2205 c := by simp [ApproximatesLinearOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology NNReal", "Filter Metric Set", "ContinuousLinearMap (id)"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{\u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : E \u2192 F\nf' : E \u2192L[\ud835\udd5c] F\nc : NNReal\n\u22a2 ApproximatesLinearOn f f' \u2205 c"}, {"line": "simp [ApproximatesLinearOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem open_image (hf : ApproximatesLinearOn f f' s c) (f'symm : f'.NonlinearRightInverse)\n    (hs : IsOpen s) (hc : Subsingleton F \u2228 c < f'symm.nnnorm\u207b\u00b9) : IsOpen (f '' s) := by\n  rcases hc with hE | hc\n  \u00b7 exact isOpen_discrete _\n  simp only [isOpen_iff_mem_nhds] at hs \u22a2\n  simp only [nhds_basis_closedBall.mem_iff] at hs \u22a2\n  simp only [forall_mem_image] at hs \u22a2\n  intro x hx\n  rcases hs x hx with \u27e8\u03b5, \u03b50, h\u03b5\u27e9\n  refine \u27e8(f'symm.nnnorm\u207b\u00b9 - c) * \u03b5, mul_pos (sub_pos.2 hc) \u03b50, ?_\u27e9\n  exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt \u03b50) h\u03b5).mono h\u03b5 Subset.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/InverseFunctionTheorem/ApproximatesLinearOn.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology NNReal", "Filter Metric Set", "ContinuousLinearMap (id)"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{\u03b5 : \u211d}", "{f : E \u2192 F}", "{f' : E \u2192L[\ud835\udd5c] F} {s t : Set E} {c c' : \u211d\u22650}", "[CompleteSpace E] {s : Set E} {c : \u211d\u22650} {f' : E \u2192L[\ud835\udd5c] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhc : Subsingleton F \u2228 c < f'symm.nnnorm\u207b\u00b9\n\u22a2 IsOpen (f '' s)"}, {"line": "rcases hc with hE | hc", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhE : Subsingleton F\n\u22a2 IsOpen (f '' s)\n---\ncase inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhc : c < f'symm.nnnorm\u207b\u00b9\n\u22a2 IsOpen (f '' s)"}, {"line": "\u00b7 exact isOpen_discrete _", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhs : IsOpen s\nhc : c < f'symm.nnnorm\u207b\u00b9\n\u22a2 IsOpen (f '' s)"}, {"line": "simp only [isOpen_iff_mem_nhds] at hs \u22a2", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, s \u2208 nhds x\n\u22a2 \u2200 x \u2208 f '' s, f '' s \u2208 nhds x"}, {"line": "simp only [nhds_basis_closedBall.mem_iff] at hs \u22a2", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 s\n\u22a2 \u2200 x \u2208 f '' s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 f '' s"}, {"line": "simp only [forall_mem_image] at hs \u22a2", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 s\n\u22a2 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 \u2203 i, 0 < i \u2227 closedBall (f x) i \u2286 f '' s"}, {"line": "intro x hx", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 s\nx : E\nhx : x \u2208 s\n\u22a2 \u2203 i, 0 < i \u2227 closedBall (f x) i \u2286 f '' s"}, {"line": "rcases hs x hx with \u27e8\u03b5, \u03b50, h\u03b5\u27e9", "tactic_state": "case inr.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 s\nx : E\nhx : x \u2208 s\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\nh\u03b5 : closedBall x \u03b5 \u2286 s\n\u22a2 \u2203 i, 0 < i \u2227 closedBall (f x) i \u2286 f '' s"}, {"line": "refine \u27e8(f'symm.nnnorm\u207b\u00b9 - c) * \u03b5, mul_pos (sub_pos.2 hc) \u03b50, ?_\u27e9", "tactic_state": "case inr.intro.intro\n\ud835\udd5c : Type u_1\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c F\nf : E \u2192 F\ninst\u271d : CompleteSpace E\ns : Set E\nc : NNReal\nf' : E \u2192L[\ud835\udd5c] F\nhf : ApproximatesLinearOn f f' s c\nf'symm : f'.NonlinearRightInverse\nhc : c < f'symm.nnnorm\u207b\u00b9\nhs : \u2200 x \u2208 s, \u2203 i, 0 < i \u2227 closedBall x i \u2286 s\nx : E\nhx : x \u2208 s\n\u03b5 : \u211d\n\u03b50 : 0 < \u03b5\nh\u03b5 : closedBall x \u03b5 \u2286 s\n\u22a2 closedBall (f x) ((\u2191sorry\u207b\u00b9 - \u2191c) * \u03b5) \u2286 f '' s"}, {"line": "exact (hf.surjOn_closedBall_of_nonlinearRightInverse f'symm (le_of_lt \u03b50) h\u03b5).mono h\u03b5 Subset.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDerivWithin_const_mul (c : \ud835\udd5c) {f : \ud835\udd5c \u2192 \ud835\udd5c} (hf : ContDiffWithinAt \ud835\udd5c n f s x) :\n    iteratedDerivWithin n (fun z => c * f z) s x = c * iteratedDerivWithin n f s x := by\n  simpa using iteratedDerivWithin_const_smul (F := \ud835\udd5c) hx h c hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean", "context": {"open": [], "variables": [""]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nn : WithTop \u2115\u221e\ns : Set \ud835\udd5c\nx c : \ud835\udd5c\nf : \ud835\udd5c \u2192 \ud835\udd5c\nhf : sorry\n\u22a2 sorry = c * sorry"}, {"line": "simpa using iteratedDerivWithin_const_smul (F := \ud835\udd5c) hx h c hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedDeriv_neg (n : \u2115) (f : \ud835\udd5c \u2192 F) (a : \ud835\udd5c) :\n    iteratedDeriv n (fun x \u21a6 -(f x)) a = -(iteratedDeriv n f a) := by\n  simpa only [\u2190 iteratedDerivWithin_univ] using iteratedDerivWithin_neg f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean", "context": {"open": [], "variables": ["", "(f) in", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nF : Type u_2\nn : \u2115\nf : \ud835\udd5c \u2192 F\na : \ud835\udd5c\n\u22a2 sorry = -sorry"}, {"line": "simpa only [\u2190 iteratedDerivWithin_univ] using iteratedDerivWithin_neg f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iteratedDeriv_comp_neg (n : \u2115) (f : \ud835\udd5c \u2192 F) (a : \ud835\udd5c) :\n    iteratedDeriv n (fun x \u21a6 f (-x)) a = (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f (-a) := by\n  induction' n with n ih generalizing a\n  \u00b7 simp only [iteratedDeriv_zero, pow_zero, one_smul]\n  \u00b7 have ih' : iteratedDeriv n (fun x \u21a6 f (-x)) = fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f (-x) :=\n      funext ih\n    rw [iteratedDeriv_succ]\n    rw [iteratedDeriv_succ]\n    rw [ih']\n    rw [pow_succ']\n    rw [neg_mul]\n    rw [one_mul]\n    rw [deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x)]\n    rw [deriv_const_smul']\n    rw [neg_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Lemmas.lean", "context": {"open": [], "variables": ["", "(f) in", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nF : Type u_2\nn : \u2115\nf : \ud835\udd5c \u2192 F\na : \ud835\udd5c\n\u22a2 sorry = sorry \u2022 sorry"}, {"line": "induction' n with n ih generalizing a", "tactic_state": "case zero\n\ud835\udd5c : Type u_1\nF : Type u_2\nf : \ud835\udd5c \u2192 F\na : \ud835\udd5c\n\u22a2 sorry = sorry \u2022 sorry\n---\ncase succ\n\ud835\udd5c : Type u_1\nF : Type u_2\nf : \ud835\udd5c \u2192 F\nn : \u2115\nih : \u2200 (a : \ud835\udd5c), sorry = sorry \u2022 sorry\na : \ud835\udd5c\n\u22a2 sorry = sorry \u2022 sorry"}, {"line": "\u00b7 simp only [iteratedDeriv_zero, pow_zero, one_smul]", "tactic_state": "case succ\n\ud835\udd5c : Type u_1\nF : Type u_2\nf : \ud835\udd5c \u2192 F\nn : \u2115\nih : \u2200 (a : \ud835\udd5c), sorry = sorry \u2022 sorry\na : \ud835\udd5c\n\u22a2 sorry = sorry \u2022 sorry"}, {"line": "\u00b7 have ih' : iteratedDeriv n (fun x \u21a6 f (-x)) = fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f (-x) :=\n      funext ih\n    rw [iteratedDeriv_succ]\n    rw [iteratedDeriv_succ]\n    rw [ih']\n    rw [pow_succ']\n    rw [neg_mul]\n    rw [one_mul]\n    rw [deriv_comp_neg (f := fun x \u21a6 (-1 : \ud835\udd5c) ^ n \u2022 iteratedDeriv n f x)]\n    rw [deriv_const_smul']\n    rw [neg_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDerivWithin_univ : iteratedDerivWithin n f univ = iteratedDeriv n f := by\n  ext x\n  rw [iteratedDerivWithin]\n  rw [iteratedDeriv]\n  rw [iteratedFDerivWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedDerivWithin n f univ = iteratedDeriv n f"}, {"line": "ext x", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin n f univ x = iteratedDeriv n f x"}, {"line": "rw [iteratedDerivWithin]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 ((iteratedFDerivWithin \ud835\udd5c n f univ x) fun x => 1) = iteratedDeriv n f x"}, {"line": "rw [iteratedDeriv]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 ((iteratedFDerivWithin \ud835\udd5c n f univ x) fun x => 1) = (iteratedFDeriv \ud835\udd5c n f x) fun x => 1"}, {"line": "rw [iteratedFDerivWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedFDerivWithin_eq_equiv_comp :\n    iteratedFDerivWithin \ud835\udd5c n f s =\n      ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F \u2218 iteratedDerivWithin n f s := by\n  rw [iteratedDerivWithin_eq_equiv_comp]\n  rw [\u2190 Function.comp_assoc]\n  rw [LinearIsometryEquiv.self_comp_symm]\n  rw [Function.id_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\n\u22a2 iteratedFDerivWithin \ud835\udd5c n f s = \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218 iteratedDerivWithin n f s"}, {"line": "rw [iteratedDerivWithin_eq_equiv_comp]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\n\u22a2 iteratedFDerivWithin \ud835\udd5c n f s =\n    \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218\n      \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm \u2218 iteratedFDerivWithin \ud835\udd5c n f s"}, {"line": "rw [\u2190 Function.comp_assoc]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\n\u22a2 iteratedFDerivWithin \ud835\udd5c n f s =\n    (\u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218 \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm) \u2218\n      iteratedFDerivWithin \ud835\udd5c n f s"}, {"line": "rw [LinearIsometryEquiv.self_comp_symm]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\n\u22a2 iteratedFDerivWithin \ud835\udd5c n f s = id \u2218 iteratedFDerivWithin \ud835\udd5c n f s"}, {"line": "rw [Function.id_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_iteratedFDerivWithin_eq_norm_iteratedDerivWithin :\n    \u2016iteratedFDerivWithin \ud835\udd5c n f s x\u2016 = \u2016iteratedDerivWithin n f s x\u2016 := by\n  rw [iteratedDerivWithin_eq_equiv_comp]\n  rw [Function.comp_apply]\n  rw [LinearIsometryEquiv.norm_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDerivWithin \ud835\udd5c n f s x\u2016 = \u2016iteratedDerivWithin n f s x\u2016"}, {"line": "rw [iteratedDerivWithin_eq_equiv_comp]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDerivWithin \ud835\udd5c n f s x\u2016 =\n    \u2016(\u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm \u2218 iteratedFDerivWithin \ud835\udd5c n f s) x\u2016"}, {"line": "rw [Function.comp_apply]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDerivWithin \ud835\udd5c n f s x\u2016 =\n    \u2016(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm (iteratedFDerivWithin \ud835\udd5c n f s x)\u2016"}, {"line": "rw [LinearIsometryEquiv.norm_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDerivWithin_zero : iteratedDerivWithin 0 f s = f := by\n  ext x\n  simp [iteratedDerivWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\n\u22a2 iteratedDerivWithin 0 f s = f"}, {"line": "ext x", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin 0 f s x = f x"}, {"line": "simp [iteratedDerivWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDerivWithin_one {x : \ud835\udd5c} :\n    iteratedDerivWithin 1 f s x = derivWithin f s x := by\n  by_cases hsx : AccPt x (\ud835\udcdf s)\n  \u00b7 simp only [iteratedDerivWithin, iteratedFDerivWithin_one_apply hsx.uniqueDiffWithinAt,\n      derivWithin]\n  \u00b7 simp [derivWithin_zero_of_not_accPt hsx, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_not_accPt hsx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin 1 f s x = derivWithin f s x"}, {"line": "by_cases hsx : AccPt x (\ud835\udcdf s)", "tactic_state": "case pos\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhsx : sorry\n\u22a2 iteratedDerivWithin 1 f s x = derivWithin f s x\n---\ncase neg\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhsx : \u00acsorry\n\u22a2 iteratedDerivWithin 1 f s x = derivWithin f s x"}, {"line": "\u00b7 simp only [iteratedDerivWithin, iteratedFDerivWithin_one_apply hsx.uniqueDiffWithinAt,\n      derivWithin]", "tactic_state": "case neg\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nhsx : \u00acsorry\n\u22a2 iteratedDerivWithin 1 f s x = derivWithin f s x"}, {"line": "\u00b7 simp [derivWithin_zero_of_not_accPt hsx, iteratedDerivWithin, iteratedFDerivWithin,\n      fderivWithin_zero_of_not_accPt hsx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffOn.continuousOn_iteratedDerivWithin\n    {n : WithTop \u2115\u221e} {m : \u2115} (h : ContDiffOn \ud835\udd5c n f s)\n    (hmn : m \u2264 n) (hs : UniqueDiffOn \ud835\udd5c s) : ContinuousOn (iteratedDerivWithin m f s) s := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp,LinearIsometryEquiv.comp_continuousOn_iff] using\n    h.continuousOn_iteratedFDerivWithin hmn hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nn : WithTop \u2115\u221e\nm : \u2115\nh : ContDiffOn \ud835\udd5c n f s\nhmn : \u2191m \u2264 n\nhs : UniqueDiffOn \ud835\udd5c s\n\u22a2 ContinuousOn (iteratedDerivWithin m f s) s"}, {"line": "simpa only [iteratedDerivWithin_eq_equiv_comp,LinearIsometryEquiv.comp_continuousOn_iff] using\n    h.continuousOn_iteratedFDerivWithin hmn hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.differentiableWithinAt_iteratedDerivWithin {n : WithTop \u2115\u221e} {m : \u2115}\n    (h : ContDiffWithinAt \ud835\udd5c n f s x) (hmn : m < n) (hs : UniqueDiffOn \ud835\udd5c (insert x s)) :\n    DifferentiableWithinAt \ud835\udd5c (iteratedDerivWithin m f s) s x := by\n  simpa only [iteratedDerivWithin_eq_equiv_comp,LinearIsometryEquiv.comp_differentiableWithinAt_iff] using\n    h.differentiableWithinAt_iteratedFDerivWithin hmn hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\ns : Set \ud835\udd5c\nx : \ud835\udd5c\nn : WithTop \u2115\u221e\nm : \u2115\nh : ContDiffWithinAt \ud835\udd5c n f s x\nhmn : \u2191m < n\nhs : UniqueDiffOn \ud835\udd5c (insert x s)\n\u22a2 DifferentiableWithinAt \ud835\udd5c (iteratedDerivWithin m f s) s x"}, {"line": "simpa only [iteratedDerivWithin_eq_equiv_comp,LinearIsometryEquiv.comp_differentiableWithinAt_iff] using\n    h.differentiableWithinAt_iteratedFDerivWithin hmn hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedFDeriv_eq_equiv_comp : iteratedFDeriv \ud835\udd5c n f =\n    ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F \u2218 iteratedDeriv n f := by\n  rw [iteratedDeriv_eq_equiv_comp]\n  rw [\u2190 Function.comp_assoc]\n  rw [LinearIsometryEquiv.self_comp_symm]\n  rw [Function.id_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedFDeriv \ud835\udd5c n f = \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218 iteratedDeriv n f"}, {"line": "rw [iteratedDeriv_eq_equiv_comp]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedFDeriv \ud835\udd5c n f =\n    \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218\n      \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm \u2218 iteratedFDeriv \ud835\udd5c n f"}, {"line": "rw [\u2190 Function.comp_assoc]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedFDeriv \ud835\udd5c n f =\n    (\u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F) \u2218 \u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm) \u2218\n      iteratedFDeriv \ud835\udd5c n f"}, {"line": "rw [LinearIsometryEquiv.self_comp_symm]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedFDeriv \ud835\udd5c n f = id \u2218 iteratedFDeriv \ud835\udd5c n f"}, {"line": "rw [Function.id_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_iteratedFDeriv_eq_norm_iteratedDeriv :\n    \u2016iteratedFDeriv \ud835\udd5c n f x\u2016 = \u2016iteratedDeriv n f x\u2016 := by\n  rw [iteratedDeriv_eq_equiv_comp]\n  rw [Function.comp_apply]\n  rw [LinearIsometryEquiv.norm_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c n f x\u2016 = \u2016iteratedDeriv n f x\u2016"}, {"line": "rw [iteratedDeriv_eq_equiv_comp]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c n f x\u2016 = \u2016(\u21d1(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm \u2218 iteratedFDeriv \ud835\udd5c n f) x\u2016"}, {"line": "rw [Function.comp_apply]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 \u2016iteratedFDeriv \ud835\udd5c n f x\u2016 = \u2016(ContinuousMultilinearMap.piFieldEquiv \ud835\udd5c (Fin n) F).symm (iteratedFDeriv \ud835\udd5c n f x)\u2016"}, {"line": "rw [LinearIsometryEquiv.norm_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contDiff_nat_iff_iteratedDeriv {n : \u2115} : ContDiff \ud835\udd5c n f \u2194\n    (\u2200 m : \u2115, m \u2264 n \u2192 Continuous (iteratedDeriv m f)) \u2227\n      \u2200 m : \u2115, m < n \u2192 Differentiable \ud835\udd5c (iteratedDeriv m f) := by\n  rw [show n = ((n : \u2115\u221e) : WithTop \u2115\u221e) from rfl]\n  rw [contDiff_iff_iteratedDeriv]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nn : \u2115\n\u22a2 ContDiff \ud835\udd5c (\u2191n) f \u2194 (\u2200 m \u2264 n, Continuous (iteratedDeriv m f)) \u2227 \u2200 m < n, Differentiable \ud835\udd5c (iteratedDeriv m f)"}, {"line": "rw [show n = ((n : \u2115\u221e) : WithTop \u2115\u221e) from rfl]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nn : \u2115\n\u22a2 ContDiff \ud835\udd5c (\u2191\u2191n) f \u2194 (\u2200 m \u2264 n, Continuous (iteratedDeriv m f)) \u2227 \u2200 m < n, Differentiable \ud835\udd5c (iteratedDeriv m f)"}, {"line": "rw [contDiff_iff_iteratedDeriv]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nf : \ud835\udd5c \u2192 F\nn : \u2115\n\u22a2 ((\u2200 (m : \u2115), \u2191m \u2264 \u2191n \u2192 Continuous (iteratedDeriv m f)) \u2227 \u2200 (m : \u2115), \u2191m < \u2191n \u2192 Differentiable \ud835\udd5c (iteratedDeriv m f)) \u2194\n    (\u2200 m \u2264 n, Continuous (iteratedDeriv m f)) \u2227 \u2200 m < n, Differentiable \ud835\udd5c (iteratedDeriv m f)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDeriv_succ : iteratedDeriv (n + 1) f = deriv (iteratedDeriv n f) := by\n  ext x\n  rw [\u2190 iteratedDerivWithin_univ]\n  rw [\u2190 iteratedDerivWithin_univ]\n  rw [\u2190 derivWithin_univ]\n  exact iteratedDerivWithin_succ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedDeriv (n + 1) f = deriv (iteratedDeriv n f)"}, {"line": "ext x", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDeriv (n + 1) f x = deriv (iteratedDeriv n f) x"}, {"line": "rw [\u2190 iteratedDerivWithin_univ]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin (n + 1) f univ x = deriv (iteratedDeriv n f) x"}, {"line": "rw [\u2190 iteratedDerivWithin_univ]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin (n + 1) f univ x = deriv (iteratedDerivWithin n f univ) x"}, {"line": "rw [\u2190 derivWithin_univ]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin (n + 1) f univ x = derivWithin (iteratedDerivWithin n f univ) univ x"}, {"line": "exact iteratedDerivWithin_succ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDeriv_eq_iterate : iteratedDeriv n f = deriv^[n] f := by\n  ext x\n  rw [\u2190 iteratedDerivWithin_univ]\n  convert iteratedDerivWithin_eq_iterate (F := F)\n  simp [derivWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/IteratedDeriv/Defs.lean", "context": {"open": ["scoped Topology", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{n : \u2115} {f : \ud835\udd5c \u2192 F} {s : Set \ud835\udd5c} {x : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\n\u22a2 iteratedDeriv n f = deriv^[n] f"}, {"line": "ext x", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDeriv n f x = deriv^[n] f x"}, {"line": "rw [\u2190 iteratedDerivWithin_univ]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\n\u22a2 iteratedDerivWithin n f univ x = deriv^[n] f x"}, {"line": "convert iteratedDerivWithin_eq_iterate (F := F)", "tactic_state": "case h.e'_3.h.e'_1.h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \ud835\udd5c F\nn : \u2115\nf : \ud835\udd5c \u2192 F\nx : \ud835\udd5c\nx\u271d : \ud835\udd5c \u2192 F\n\u22a2 deriv x\u271d = derivWithin x\u271d univ"}, {"line": "simp [derivWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lineDifferentiableWithinAt_univ :\n    LineDifferentiableWithinAt \ud835\udd5c f univ x v \u2194 LineDifferentiableAt \ud835\udd5c f x v := by\n  simp only [LineDifferentiableWithinAt]\n  simp only [LineDifferentiableAt]\n  simp only [preimage_univ]\n  simp only [differentiableWithinAt_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\n\u22a2 LineDifferentiableWithinAt \ud835\udd5c f univ x v \u2194 LineDifferentiableAt \ud835\udd5c f x v"}, {"line": "simp only [LineDifferentiableWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun t => f (x + t \u2022 v)) ((fun t => x + t \u2022 v) \u207b\u00b9' univ) 0 \u2194 LineDifferentiableAt \ud835\udd5c f x v"}, {"line": "simp only [LineDifferentiableAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun t => f (x + t \u2022 v)) ((fun t => x + t \u2022 v) \u207b\u00b9' univ) 0 \u2194\n    DifferentiableAt \ud835\udd5c (fun t => f (x + t \u2022 v)) 0"}, {"line": "simp only [preimage_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\n\u22a2 DifferentiableWithinAt \ud835\udd5c (fun t => f (x + t \u2022 v)) univ 0 \u2194 DifferentiableAt \ud835\udd5c (fun t => f (x + t \u2022 v)) 0"}, {"line": "simp only [differentiableWithinAt_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lineDerivWithin_univ : lineDerivWithin \ud835\udd5c f univ x v = lineDeriv \ud835\udd5c f x v := by\n  simp [lineDerivWithin, lineDeriv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\n\u22a2 lineDerivWithin \ud835\udd5c f univ x v = lineDeriv \ud835\udd5c f x v"}, {"line": "simp [lineDerivWithin, lineDeriv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasFDerivAt.hasLineDerivAt (hf : HasFDerivAt f L x) (v : E) :\n    HasLineDerivAt \ud835\udd5c f (L v) x v := by\n  rw [\u2190 hasLineDerivWithinAt_univ]\n  exact hf.hasFDerivWithinAt.hasLineDerivWithinAt v\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \ud835\udd5c F\nE\u271d : Type u_3\ninst\u271d\u2076 : AddCommGroup E\u271d\ninst\u271d\u2075 : Module \ud835\udd5c E\u271d\nf : E\u271d \u2192 F\nx : E\u271d\nE : Type u_4\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\ninst\u271d\u00b2 : TopologicalSpace E\u271d\ninst\u271d\u00b9 : Module \u03b1\u271d E\u271d\ninst\u271d : Module \u03b1\u271d F\nL : E\u271d \u2192L[\u03b1\u271d] F\nhf : sorry\nv : E\n\u22a2 HasLineDerivAt \ud835\udd5c f (L sorry) x sorry"}, {"line": "rw [\u2190 hasLineDerivWithinAt_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2079 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup F\ninst\u271d\u2077 : NormedSpace \ud835\udd5c F\nE\u271d : Type u_3\ninst\u271d\u2076 : AddCommGroup E\u271d\ninst\u271d\u2075 : Module \ud835\udd5c E\u271d\nf : E\u271d \u2192 F\nx : E\u271d\nE : Type u_4\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\ninst\u271d\u00b2 : TopologicalSpace E\u271d\ninst\u271d\u00b9 : Module \u03b1\u271d E\u271d\ninst\u271d : Module \u03b1\u271d F\nL : E\u271d \u2192L[\u03b1\u271d] F\nhf : sorry\nv : E\n\u22a2 HasLineDerivWithinAt \ud835\udd5c f (L sorry) univ x sorry"}, {"line": "exact hf.hasFDerivWithinAt.hasLineDerivWithinAt v", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.lineDerivWithin_eq (hs : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) :\n    lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v := by\n  apply derivWithin_eq ?_ (by simpa using hx)\n  have A : Continuous (fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v) := by fun_prop\n  exact A.continuousWithinAt.preimage_mem_nhdsWithin'' hs (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf f\u2081 : E \u2192 F\ns : Set E\nx v : E\nhs : f\u2081 =\u1da0[sorry] f\nhx : f\u2081 x = f x\n\u22a2 lineDerivWithin \ud835\udd5c f\u2081 s x v = lineDerivWithin \ud835\udd5c f s x v"}, {"line": "apply derivWithin_eq ?_ (by simpa using hx)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf f\u2081 : E \u2192 F\ns : Set E\nx v : E\nhs : f\u2081 =\u1da0[sorry] f\nhx : f\u2081 x = f x\n\u22a2 (fun t => f\u2081 (x + t \u2022 v)) =\u1da0[nhdsWithin 0 ((fun t => x + t \u2022 v) \u207b\u00b9' s)] fun t => f (x + t \u2022 v)"}, {"line": "have A : Continuous (fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v) := sorry", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_3\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf f\u2081 : E \u2192 F\ns : Set E\nx v : E\nhs : f\u2081 =\u1da0[sorry] f\nhx : f\u2081 x = f x\nA : sorry\n\u22a2 (fun t => f\u2081 (x + t \u2022 v)) =\u1da0[nhdsWithin 0 ((fun t => x + t \u2022 v) \u207b\u00b9' s)] fun t => f (x + t \u2022 v)"}, {"line": "exact A.continuousWithinAt.preimage_mem_nhdsWithin'' hs (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasLineDerivWithinAt_zero : HasLineDerivWithinAt \ud835\udd5c f 0 s x 0 := by\n  simp [HasLineDerivWithinAt, hasDerivWithinAt_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] {f : E \u2192 F} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_5\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\ns : Set E\nx : E\n\u22a2 HasLineDerivWithinAt \ud835\udd5c f 0 s x 0"}, {"line": "simp [HasLineDerivWithinAt, hasDerivWithinAt_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasLineDerivAt_zero : HasLineDerivAt \ud835\udd5c f 0 x 0 := by\n  simp [HasLineDerivAt, hasDerivAt_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] {f : E \u2192 F} {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_5\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx : E\n\u22a2 HasLineDerivAt \ud835\udd5c f 0 x 0"}, {"line": "simp [HasLineDerivAt, hasDerivAt_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasLineDerivAt.smul (h : HasLineDerivAt \ud835\udd5c f f' x v) (c : \ud835\udd5c) :\n    HasLineDerivAt \ud835\udd5c f (c \u2022 f') x (c \u2022 v) := by\n  simp only [\u2190 hasLineDerivWithinAt_univ] at h \u22a2\n  exact HasLineDerivWithinAt.smul h c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LineDeriv/Basic.lean", "context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] {f : E \u2192 F} {s : Set E} {x : E}", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E] {f : E \u2192 F} {s : Set E} {x v : E} {f' : F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\nf' : F\nh : HasLineDerivAt \ud835\udd5c f f' x v\nc : \ud835\udd5c\n\u22a2 HasLineDerivAt \ud835\udd5c f (c \u2022 f') x (c \u2022 v)"}, {"line": "simp only [\u2190 hasLineDerivWithinAt_univ] at h \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2074 : NontriviallyNormedField \ud835\udd5c\nF : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c F\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nf : E \u2192 F\nx v : E\nf' : F\nc : \ud835\udd5c\nh : HasLineDerivWithinAt \ud835\udd5c f f' univ x v\n\u22a2 HasLineDerivWithinAt \ud835\udd5c f (c \u2022 f') univ x (c \u2022 v)"}, {"line": "exact HasLineDerivWithinAt.smul h c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLocalMinOn.hasFDerivWithinAt_nonneg (h : IsLocalMinOn f s a)\n    (hf : HasFDerivWithinAt f f' s a) (hy : y \u2208 posTangentConeAt s a) : 0 \u2264 f' y := by\n  simpa using h.neg.hasFDerivWithinAt_nonpos hf.neg hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "context": {"open": ["Filter Set", "scoped Topology Convex"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d\u00b9 : Type u_1\nf : \u03b1\u271d\u00b9 \u2192 \u2115\ns : Set \u03b1\u271d\u00b9\na : \u03b1\u271d\u00b9\n\u03b1\u271d : Type u_2\nself\u271d\u00b2 : NontriviallyNormedField \u03b1\u271d\ninst\u271d\u00b2 : TopologicalSpace \u03b1\u271d\u00b9\nself\u271d\u00b9 : AddCommGroup \u03b1\u271d\u00b9\nself\u271d : AddCommGroup \u2115\ninst\u271d\u00b9 : Module \u03b1\u271d \u03b1\u271d\u00b9\ninst\u271d : Module \u03b1\u271d \u2115\nf' : \u03b1\u271d\u00b9 \u2192L[\u03b1\u271d] \u2115\ny : \u03b1\u271d\u00b9\nh : IsLocalMinOn f s a\nhf : HasFDerivWithinAt f f' s a\nhy : y \u2208 posTangentConeAt s a\n\u22a2 0 \u2264 f' y"}, {"line": "simpa using h.neg.hasFDerivWithinAt_nonpos hf.neg hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLocalMinOn.hasFDerivWithinAt_eq_zero (h : IsLocalMinOn f s a)\n    (hf : HasFDerivWithinAt f f' s a) (hy : y \u2208 posTangentConeAt s a)\n    (hy' : -y \u2208 posTangentConeAt s a) : f' y = 0 := by\n  simpa using h.neg.hasFDerivWithinAt_eq_zero hf.neg hy hy'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "context": {"open": ["Filter Set", "scoped Topology Convex"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2124 \u2192 \u2115\ns : Set \u2124\na : \u2124\n\u03b1\u271d : Type u_1\nself\u271d\u00b9 : NontriviallyNormedField \u03b1\u271d\nself\u271d : AddCommGroup \u2115\ninst\u271d\u00b9 : Module \u03b1\u271d \u2124\ninst\u271d : Module \u03b1\u271d \u2115\nf' : \u2124 \u2192L[\u03b1\u271d] \u2115\ny : \u2124\nh : IsLocalMinOn f s a\nhf : HasFDerivWithinAt f f' s a\nhy : y \u2208 posTangentConeAt s a\nhy' : -y \u2208 posTangentConeAt s a\n\u22a2 f' y = 0"}, {"line": "simpa using h.neg.hasFDerivWithinAt_eq_zero hf.neg hy hy'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_mem_posTangentConeAt_iff_frequently :\n    1 \u2208 posTangentConeAt s a \u2194 \u2203\u1da0 x in \ud835\udcdd[>] a, x \u2208 s := by\n  rw [one_mem_posTangentConeAt_iff_mem_closure]\n  rw [mem_closure_iff_frequently]\n  rw [frequently_nhdsWithin_iff]\n  rw [inter_comm]\n  simp_rw [mem_inter_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "context": {"open": ["Filter Set", "scoped Topology Convex"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 \u211d} {f' : \u211d} {s : Set \u211d} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\na : \u211d\n\u22a2 1 \u2208 posTangentConeAt s a \u2194 \u2203\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), x \u2208 s"}, {"line": "rw [one_mem_posTangentConeAt_iff_mem_closure]", "tactic_state": "s : Set \u211d\na : \u211d\n\u22a2 a \u2208 closure (Ioi a \u2229 s) \u2194 \u2203\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), x \u2208 s"}, {"line": "rw [mem_closure_iff_frequently]", "tactic_state": "s : Set \u211d\na : \u211d\n\u22a2 (\u2203\u1da0 (x : \u211d) in nhds a, x \u2208 Ioi a \u2229 s) \u2194 \u2203\u1da0 (x : \u211d) in nhdsWithin a (Ioi a), x \u2208 s"}, {"line": "rw [frequently_nhdsWithin_iff]", "tactic_state": "s : Set \u211d\na : \u211d\n\u22a2 (\u2203\u1da0 (x : \u211d) in nhds a, x \u2208 Ioi a \u2229 s) \u2194 \u2203\u1da0 (x : \u211d) in nhds a, x \u2208 s \u2227 x \u2208 Ioi a"}, {"line": "rw [inter_comm]", "tactic_state": "s : Set \u211d\na : \u211d\n\u22a2 (\u2203\u1da0 (x : \u211d) in nhds a, x \u2208 s \u2229 Ioi a) \u2194 \u2203\u1da0 (x : \u211d) in nhds a, x \u2208 s \u2227 x \u2208 Ioi a"}, {"line": "simp_rw [mem_inter_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLocalMin.hasDerivAt_eq_zero (h : IsLocalMin f a) (hf : HasDerivAt f f' a) : f' = 0 := by\n  simpa using DFunLike.congr_fun (h.hasFDerivAt_eq_zero (hasDerivAt_iff_hasFDerivAt.1 hf)) 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LocalExtr/Basic.lean", "context": {"open": ["Filter Set", "scoped Topology Convex"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 \u211d} {f' : \u211d} {s : Set \u211d} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nf' a : \u211d\nh : IsLocalMin f a\nhf : HasDerivAt f f' a\n\u22a2 f' = 0"}, {"line": "simpa using DFunLike.congr_fun (h.hasFDerivAt_eq_zero (hasDerivAt_iff_hasFDerivAt.1 hf)) 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_rootSet_le_derivative {F : Type*} [CommRing F] [Algebra F \u211d] (p : F[X]) :\n    Fintype.card (p.rootSet \u211d) \u2264 Fintype.card (p.derivative.rootSet \u211d) + 1 := by\n  simpa only [rootSet_def,Finset.coe_sort_coe,Fintype.card_coe,derivative_map] using\n    card_roots_toFinset_le_derivative (p.map (algebraMap F \u211d))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Calculus/LocalExtr/Polynomial.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "idx\u271d : Type u_2\nX : idx\u271d\nF : Type u_1\ninst\u271d\u00b9 : CommRing F\ninst\u271d : Algebra F \u211d\np : F[X]\n\u22a2 sorry \u2264 sorry + 1"}, {"line": "simpa only [rootSet_def,Finset.coe_sort_coe,Fintype.card_coe,derivative_map] using\n    card_roots_toFinset_le_derivative (p.map (algebraMap F \u211d))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eventually_eq_of_isLocalMax {f : E \u2192 F} {c : E}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, \u2016f y\u2016 = \u2016f c\u2016 := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with \u27e8r, hr\u2080, hr\u27e9\n  exact nhds_basis_closedBall.eventually_iff.2\n    \u27e8r, hr\u2080, norm_eqOn_closedBall_of_isMaxOn (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/AbsMax.lean", "context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nc : E\nhd : \u2200\u1da0 (z : E) in nhds c, sorry\nhc : IsLocalMax (norm \u2218 f) c\n\u22a2 \u2200\u1da0 (y : E) in nhds c, \u2016f y\u2016 = \u2016f c\u2016"}, {"line": "rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with \u27e8r, hr\u2080, hr\u27e9", "tactic_state": "case intro.intro\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nc : E\nhd : \u2200\u1da0 (z : E) in nhds c, sorry\nhc : IsLocalMax (norm \u2218 f) c\nr : \u211d\nhr\u2080 : 0 < r\nhr : \u2200 \u2983x : E\u2984, x \u2208 closedBall c r \u2192 sorry \u2227 (norm \u2218 f) x \u2264 (norm \u2218 f) c\n\u22a2 \u2200\u1da0 (y : E) in nhds c, \u2016f y\u2016 = \u2016f c\u2016"}, {"line": "exact nhds_basis_closedBall.eventually_iff.2\n    \u27e8r, hr\u2080, norm_eqOn_closedBall_of_isMaxOn (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_setOf_mem_nhds_and_isMaxOn_norm {f : E \u2192 F} {s : Set E}\n    (hd : DifferentiableOn \u2102 f s) : IsOpen {z | s \u2208 \ud835\udcdd z \u2227 IsMaxOn (norm \u2218 f) s z} := by\n  refine isOpen_iff_mem_nhds.2 fun z hz => (eventually_eventually_nhds.2 hz.1).and ?_\n  replace hd : \u2200\u1da0 w in \ud835\udcdd z, DifferentiableAt \u2102 f w := hd.eventually_differentiableAt hz.1\n  exact (norm_eventually_eq_of_isLocalMax hd <| hz.2.isLocalMax hz.1).mono fun x hx y hy =>\n    le_trans (hz.2 hy).out hx.ge\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/AbsMax.lean", "context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\ns : Set E\nhd : sorry\n\u22a2 IsOpen {z | s \u2208 nhds z \u2227 IsMaxOn (norm \u2218 f) s z}"}, {"line": "refine isOpen_iff_mem_nhds.2 fun z hz => (eventually_eventually_nhds.2 hz.1).and ?_", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\ns : Set E\nhd : sorry\nz : E\nhz : z \u2208 {z | s \u2208 nhds z \u2227 IsMaxOn (norm \u2218 f) s z}\n\u22a2 Filter.Eventually (IsMaxOn (norm \u2218 f) s) (nhds z)"}, {"line": "replace hd : \u2200\u1da0 w in \ud835\udcdd z, DifferentiableAt \u2102 f w := hd.eventually_differentiableAt hz.1", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\ns : Set E\nz : E\nhz : z \u2208 {z | s \u2208 nhds z \u2227 IsMaxOn (norm \u2218 f) s z}\nhd : \u2200\u1da0 (w : E) in sorry, sorry\n\u22a2 Filter.Eventually (IsMaxOn (norm \u2218 f) s) (nhds z)"}, {"line": "exact (norm_eventually_eq_of_isLocalMax hd <| hz.2.isLocalMax hz.1).mono fun x hx y hy =>\n    le_trans (hz.2 hy).out hx.ge", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_eq_of_isLocalMax_norm {f : E \u2192 F} {c : E}\n    (hd : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMax (norm \u2218 f) c) :\n    \u2200\u1da0 y in \ud835\udcdd c, f y = f c := by\n  rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with \u27e8r, hr\u2080, hr\u27e9\n  exact nhds_basis_closedBall.eventually_iff.2\n    \u27e8r, hr\u2080, eqOn_closedBall_of_isMaxOn_norm (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/AbsMax.lean", "context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nc : E\nhd : \u2200\u1da0 (z : E) in nhds c, sorry\nhc : IsLocalMax (norm \u2218 f) c\n\u22a2 \u2200\u1da0 (y : E) in nhds c, f y = f c"}, {"line": "rcases nhds_basis_closedBall.eventually_iff.1 (hd.and hc) with \u27e8r, hr\u2080, hr\u27e9", "tactic_state": "case intro.intro\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nF : Type v\ninst\u271d : NormedAddCommGroup F\nf : E \u2192 F\nc : E\nhd : \u2200\u1da0 (z : E) in nhds c, sorry\nhc : IsLocalMax (norm \u2218 f) c\nr : \u211d\nhr\u2080 : 0 < r\nhr : \u2200 \u2983x : E\u2984, x \u2208 closedBall c r \u2192 sorry \u2227 (norm \u2218 f) x \u2264 (norm \u2218 f) c\n\u22a2 \u2200\u1da0 (y : E) in nhds c, f y = f c"}, {"line": "exact nhds_basis_closedBall.eventually_iff.2\n    \u27e8r, hr\u2080, eqOn_closedBall_of_isMaxOn_norm (DifferentiableOn.diffContOnCl fun x hx =>\n        (hr <| closure_ball_subset_closedBall hx).1.differentiableWithinAt) fun x hx =>\n      (hr <| ball_subset_closedBall hx).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm {f : E \u2192 \u2102} {c : E}\n    (hf : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) :\n    (\u2200\u1da0 z in \ud835\udcdd c, f z = f c) \u2228 f c = 0 := by\n  refine or_iff_not_imp_right.mpr fun h => ?_\n  have h1 : \u2200\u1da0 z in \ud835\udcdd c, f z \u2260 0 := hf.self_of_nhds.continuousAt.eventually_ne h\n  have h2 : IsLocalMax (norm \u2218 f)\u207b\u00b9 c := hc.inv (h1.mono fun z => norm_pos_iff.mpr)\n  have h3 : IsLocalMax (norm \u2218 f\u207b\u00b9) c := by refine h2.congr (Eventually.of_forall ?_); simp\n  have h4 : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f\u207b\u00b9 z := by filter_upwards [hf, h1] with z h using h.inv\n  filter_upwards [eventually_eq_of_isLocalMax_norm h4 h3] with z using inv_inj.mp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/AbsMax.lean", "context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\n\u22a2 (\u2200\u1da0 (z : E) in nhds c, f z = f c) \u2228 f c = 0"}, {"line": "refine or_iff_not_imp_right.mpr fun h => ?_", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\nh : \u00acf c = 0\n\u22a2 \u2200\u1da0 (z : E) in nhds c, f z = f c"}, {"line": "have h1 : \u2200\u1da0 z in \ud835\udcdd c, f z \u2260 0 := hf.self_of_nhds.continuousAt.eventually_ne h", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\nh : \u00acf c = 0\nh1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0\n\u22a2 \u2200\u1da0 (z : E) in nhds c, f z = f c"}, {"line": "have h2 : IsLocalMax (norm \u2218 f)\u207b\u00b9 c := hc.inv (h1.mono fun z => norm_pos_iff.mpr)", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\nh : \u00acf c = 0\nh1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0\nh2 : sorry\n\u22a2 \u2200\u1da0 (z : E) in nhds c, f z = f c"}, {"line": "have h3 : IsLocalMax (norm \u2218 f\u207b\u00b9) c := sorry", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\nh : \u00acf c = 0\nh1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0\nh2 : sorry\nh3 : sorry\n\u22a2 \u2200\u1da0 (z : E) in nhds c, f z = f c"}, {"line": "have h4 : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f\u207b\u00b9 z := sorry", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : E \u2192 \u2102\nc : E\nhf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z\nhc : IsLocalMin (norm \u2218 f) c\nh : \u00acf c = 0\nh1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0\nh2 : sorry\nh3 : sorry\nh4 : \u2200\u1da0 (z : E) in sorry, sorry\n\u22a2 \u2200\u1da0 (z : E) in nhds c, f z = f c"}, {"line": "filter_upwards [eventually_eq_of_isLocalMax_norm h4 h3] with z using inv_inj.mp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_pi_ne_one : Circle.exp Real.pi \u2260 1 := by\n  intro h\n  have heq : (Circle.exp Real.pi : \u2102) = 1 := by simp [h]\n  rw [Circle.coe_exp] at heq\n  rw [exp_pi_mul_I] at heq\n  norm_num at heq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Circle.lean", "context": {"open": ["Complex Function Metric", "ComplexConjugate"], "variables": ["{x y : Circle}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Circle.exp Real.pi \u2260 1"}, {"line": "intro h", "tactic_state": "h : Circle.exp Real.pi = 1\n\u22a2 False"}, {"line": "have heq : (Circle.exp Real.pi : \u2102) = 1 := by simp [h]", "tactic_state": "h : Circle.exp Real.pi = 1\nheq : \u2191(Circle.exp Real.pi) = 1\n\u22a2 False"}, {"line": "rw [Circle.coe_exp] at heq", "tactic_state": "h : Circle.exp Real.pi = 1\nheq : exp (\u2191Real.pi * I) = 1\n\u22a2 False"}, {"line": "rw [exp_pi_mul_I] at heq", "tactic_state": "h : Circle.exp Real.pi = 1\nheq : -1 = 1\n\u22a2 False"}, {"line": "norm_num at heq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotation_trans (a b : Circle) : (rotation a).trans (rotation b) = rotation (b * a) := by\n  ext1\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Circle\n\u22a2 (rotation a).trans (rotation b) = rotation (b * a)"}, {"line": "ext1", "tactic_state": "case h\na b : Circle\nx\u271d : \u2102\n\u22a2 ((rotation a).trans (rotation b)) x\u271d = (rotation (b * a)) x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIsometry.re_apply_eq_re_of_add_conj_eq (f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102)\n    (h\u2083 : \u2200 z, z + conj z = f z + conj (f z)) (z : \u2102) : (f z).re = z.re := by\n  simpa [Complex.ext_iff, add_re, add_im, conj_re, conj_im, \u2190 two_mul,\n    show (2 : \u211d) \u2260 0 by simp [two_ne_zero]] using (h\u2083 z).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh\u2083 : \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)\nz : \u2102\n\u22a2 (f z).re = z.re"}, {"line": "simpa [Complex.ext_iff, add_re, add_im, conj_re, conj_im, \u2190 two_mul,\n    show (2 : \u211d) \u2260 0 by simp [two_ne_zero]] using (h\u2083 z).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re {f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102}\n    (h\u2082 : \u2200 z, (f z).re = z.re) (z : \u2102) : (f z).im = z.im \u2228 (f z).im = -z.im := by\n  have h\u2081 := f.norm_map z\n  simp only [norm_def] at h\u2081\n  rwa [Real.sqrt_inj (normSq_nonneg _) (normSq_nonneg _), normSq_apply (f z), normSq_apply z,\n    h\u2082, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh\u2082 : \u2200 (z : \u2102), (f z).re = z.re\nz : \u2102\n\u22a2 (f z).im = z.im \u2228 (f z).im = -z.im"}, {"line": "have h\u2081 := f.norm_map z", "tactic_state": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh\u2082 : \u2200 (z : \u2102), (f z).re = z.re\nz : \u2102\nh\u2081 : \u2016f z\u2016 = \u2016z\u2016\n\u22a2 (f z).im = z.im \u2228 (f z).im = -z.im"}, {"line": "simp only [norm_def] at h\u2081", "tactic_state": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh\u2082 : \u2200 (z : \u2102), (f z).re = z.re\nz : \u2102\nh\u2081 : \u221a(normSq (f z)) = \u221a(normSq z)\n\u22a2 (f z).im = z.im \u2228 (f z).im = -z.im"}, {"line": "rwa [Real.sqrt_inj (normSq_nonneg _) (normSq_nonneg _), normSq_apply (f z), normSq_apply z,\n    h\u2082, add_left_cancel_iff, mul_self_eq_mul_self_iff] at h\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIsometry.re_apply_eq_re {f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102} (h : f 1 = 1) (z : \u2102) : (f z).re = z.re := by\n  apply LinearIsometry.re_apply_eq_re_of_add_conj_eq\n  intro z\n  apply LinearIsometry.im_apply_eq_im h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 (f z).re = z.re"}, {"line": "apply LinearIsometry.re_apply_eq_re_of_add_conj_eq", "tactic_state": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz : \u2102\n\u22a2 \u2200 (z : \u2102), z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"}, {"line": "intro z", "tactic_state": "case h\u2083\nf : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nz\u271d z : \u2102\n\u22a2 z + (starRingEnd \u2102) z = f z + (starRingEnd \u2102) (f z)"}, {"line": "apply LinearIsometry.im_apply_eq_im h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linear_isometry_complex_aux {f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102} (h : f 1 = 1) :\n    f = LinearIsometryEquiv.refl \u211d \u2102 \u2228 f = conjLIE := by\n  have h0 : f I = I \u2228 f I = -I := by\n    simp only [Complex.ext_iff]\n    simp only [\u2190 and_or_left]\n    simp only [neg_re]\n    simp only [I_re]\n    simp only [neg_im]\n    simp only [neg_zero]\n    constructor\n    \u00b7 rw [\u2190 I_re]\n      exact @LinearIsometry.re_apply_eq_re f.toLinearIsometry h I\n    \u00b7 apply @LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re f.toLinearIsometry\n      intro z\n      rw [@LinearIsometry.re_apply_eq_re f.toLinearIsometry h]\n  refine h0.imp (fun h' : f I = I => ?_) fun h' : f I = -I => ?_ <;>\n    \u00b7 apply LinearIsometryEquiv.toLinearEquiv_injective\n      apply Complex.basisOneI.ext'\n      intro i\n      fin_cases i <;> simp [h, h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\n\u22a2 f = LinearIsometryEquiv.refl \u211d \u2102 \u2228 f = conjLIE"}, {"line": "have h0 : f I = I \u2228 f I = -I := by\n    simp only [Complex.ext_iff]\n    simp only [\u2190 and_or_left]\n    simp only [neg_re]\n    simp only [I_re]\n    simp only [neg_im]\n    simp only [neg_zero]\n    constructor\n    \u00b7 rw [\u2190 I_re]\n      exact @LinearIsometry.re_apply_eq_re f.toLinearIsometry h I\n    \u00b7 apply @LinearIsometry.im_apply_eq_im_or_neg_of_re_apply_eq_re f.toLinearIsometry\n      intro z\n      rw [@LinearIsometry.re_apply_eq_re f.toLinearIsometry h]", "tactic_state": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\nh : f 1 = 1\nh0 : f I = I \u2228 f I = -I\n\u22a2 f = LinearIsometryEquiv.refl \u211d \u2102 \u2228 f = conjLIE"}, {"line": "refine h0.imp (fun h' : f I = I => ?_) fun h' : f I = -I => ?_ <;>\n    \u00b7 apply LinearIsometryEquiv.toLinearEquiv_injective\n      apply Complex.basisOneI.ext'\n      intro i\n      fin_cases i <;> simp [h, h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linear_isometry_complex (f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102) :\n    \u2203 a : Circle, f = rotation a \u2228 f = conjLIE.trans (rotation a) := by\n  let a : Circle := \u27e8f 1, by simp [Submonoid.unitSphere, f.norm_map]\u27e9\n  use a\n  have : (f.trans (rotation a).symm) 1 = 1 := by simpa [a] using rotation_apply a\u207b\u00b9 (f 1)\n  refine (linear_isometry_complex_aux this).imp (fun h\u2081 => ?_) fun h\u2082 => ?_\n  \u00b7 simpa using eq_mul_of_inv_mul_eq h\u2081\n  \u00b7 exact eq_mul_of_inv_mul_eq h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\n\u22a2 \u2203 a, f = rotation a \u2228 f = conjLIE.trans (rotation a)"}, {"line": "let a : Circle := \u27e8f 1, by simp [Submonoid.unitSphere, f.norm_map]\u27e9", "tactic_state": "f : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\n\u22a2 \u2203 a, f = rotation a \u2228 f = conjLIE.trans (rotation a)"}, {"line": "use a", "tactic_state": "case h\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\n\u22a2 f = rotation a \u2228 f = conjLIE.trans (rotation a)"}, {"line": "have : (f.trans (rotation a).symm) 1 = 1 := by simpa [a] using rotation_apply a\u207b\u00b9 (f 1)", "tactic_state": "case h\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\nthis : (f.trans (rotation a).symm) 1 = 1\n\u22a2 f = rotation a \u2228 f = conjLIE.trans (rotation a)"}, {"line": "refine (linear_isometry_complex_aux this).imp (fun h\u2081 => ?_) fun h\u2082 => ?_", "tactic_state": "case h.refine_1\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\nthis : (f.trans (rotation a).symm) 1 = 1\nh\u2081 : f.trans (rotation a).symm = LinearIsometryEquiv.refl \u211d \u2102\n\u22a2 f = rotation a\n---\ncase h.refine_2\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\nthis : (f.trans (rotation a).symm) 1 = 1\nh\u2082 : f.trans (rotation a).symm = conjLIE\n\u22a2 f = conjLIE.trans (rotation a)"}, {"line": "\u00b7 simpa using eq_mul_of_inv_mul_eq h\u2081", "tactic_state": "case h.refine_2\nf : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\na : Circle := \u27e8f 1, \u22ef\u27e9\nthis : (f.trans (rotation a).symm) 1 = 1\nh\u2082 : f.trans (rotation a).symm = conjLIE\n\u22a2 f = conjLIE.trans (rotation a)"}, {"line": "\u00b7 exact eq_mul_of_inv_mul_eq h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toMatrix_rotation (a : Circle) :\n    LinearMap.toMatrix basisOneI basisOneI (rotation a).toLinearEquiv =\n      Matrix.planeConformalMatrix (re a) (im a) (by simp [pow_two, \u2190 normSq_apply]) := by\n  ext i j\n  simp only [LinearMap.toMatrix_apply]\n  simp only [coe_basisOneI]\n  simp only [LinearEquiv.coe_coe]\n  simp only [LinearIsometryEquiv.coe_toLinearEquiv]\n  simp only [rotation_apply]\n  simp only [coe_basisOneI_repr]\n  simp only [mul_re]\n  simp only [mul_im]\n  simp only [Matrix.val_planeConformalMatrix]\n  simp only [Matrix.of_apply]\n  simp only [Matrix.cons_val']\n  simp only [Matrix.empty_val']\n  simp only [Matrix.cons_val_fin_one]\n  fin_cases i <;> fin_cases j <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Circle\n\u22a2 (LinearMap.toMatrix basisOneI basisOneI) \u2191(rotation a).toLinearEquiv =\n    \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef)"}, {"line": "ext i j", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (LinearMap.toMatrix basisOneI basisOneI) (\u2191(rotation a).toLinearEquiv) i j =\n    \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [LinearMap.toMatrix_apply]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (basisOneI.repr (\u2191(rotation a).toLinearEquiv (basisOneI j))) i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [coe_basisOneI]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (basisOneI.repr (\u2191(rotation a).toLinearEquiv (![1, I] j))) i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [LinearEquiv.coe_coe]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (basisOneI.repr ((rotation a).toLinearEquiv (![1, I] j))) i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [LinearIsometryEquiv.coe_toLinearEquiv]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (basisOneI.repr ((rotation a) (![1, I] j))) i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [rotation_apply]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 (basisOneI.repr (\u2191a * ![1, I] j)) i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [coe_basisOneI_repr]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a * ![1, I] j).re, (\u2191a * ![1, I] j).im] i = \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [mul_re]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a * ![1, I] j).im] i =\n    \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [mul_im]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) i j"}, {"line": "simp only [Matrix.val_planeConformalMatrix]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    !![(\u2191a).re, -(\u2191a).im; (\u2191a).im, (\u2191a).re] i j"}, {"line": "simp only [Matrix.of_apply]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    ![![(\u2191a).re, -(\u2191a).im], ![(\u2191a).im, (\u2191a).re]] i j"}, {"line": "simp only [Matrix.cons_val']", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    Matrix.vecCons (![(\u2191a).re, -(\u2191a).im] j) (fun i => Matrix.vecCons (![(\u2191a).im, (\u2191a).re] j) (fun i => ![] i j) i) i"}, {"line": "simp only [Matrix.empty_val']", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    Matrix.vecCons (![(\u2191a).re, -(\u2191a).im] j) (fun i => ![![(\u2191a).im, (\u2191a).re] j] i) i"}, {"line": "simp only [Matrix.cons_val_fin_one]", "tactic_state": "case a\na : Circle\ni j : Fin 2\n\u22a2 ![(\u2191a).re * (![1, I] j).re - (\u2191a).im * (![1, I] j).im, (\u2191a).re * (![1, I] j).im + (\u2191a).im * (![1, I] j).re] i =\n    Matrix.vecCons (![(\u2191a).re, -(\u2191a).im] j) (fun i => ![(\u2191a).im, (\u2191a).re] j) i"}, {"line": "fin_cases i <;> fin_cases j <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_rotation (a : Circle) : LinearMap.det ((rotation a).toLinearEquiv : \u2102 \u2192\u2097[\u211d] \u2102) = 1 := by\n  rw [\u2190 LinearMap.det_toMatrix basisOneI]\n  rw [toMatrix_rotation]\n  rw [Matrix.det_fin_two]\n  simp [\u2190 normSq_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Circle\n\u22a2 LinearMap.det \u2191(rotation a).toLinearEquiv = 1"}, {"line": "rw [\u2190 LinearMap.det_toMatrix basisOneI]", "tactic_state": "a : Circle\n\u22a2 ((LinearMap.toMatrix basisOneI basisOneI) \u2191(rotation a).toLinearEquiv).det = 1"}, {"line": "rw [toMatrix_rotation]", "tactic_state": "a : Circle\n\u22a2 (\u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef)).det = 1"}, {"line": "rw [Matrix.det_fin_two]", "tactic_state": "a : Circle\n\u22a2 \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) 0 0 * \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) 1 1 -\n      \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) 0 1 * \u2191(Matrix.planeConformalMatrix (\u2191a).re (\u2191a).im \u22ef) 1 0 =\n    1"}, {"line": "simp [\u2190 normSq_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem linearEquiv_det_rotation (a : Circle) : LinearEquiv.det (rotation a).toLinearEquiv = 1 := by\n  rw [\u2190 Units.eq_iff]\n  rw [LinearEquiv.coe_det]\n  rw [det_rotation]\n  rw [Units.val_one]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Isometry.lean", "context": {"open": ["Complex", "CharZero", "ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : Circle\n\u22a2 LinearEquiv.det (rotation a).toLinearEquiv = 1"}, {"line": "rw [\u2190 Units.eq_iff]", "tactic_state": "a : Circle\n\u22a2 \u2191(LinearEquiv.det (rotation a).toLinearEquiv) = \u21911"}, {"line": "rw [LinearEquiv.coe_det]", "tactic_state": "a : Circle\n\u22a2 LinearMap.det \u2191(rotation a).toLinearEquiv = \u21911"}, {"line": "rw [det_rotation]", "tactic_state": "a : Circle\n\u22a2 1 = \u21911"}, {"line": "rw [Units.val_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_cuspFunction (hh : h \u2260 0) (hf : Periodic f h) (z : \u2102) :\n    (cuspFunction h f) (\ud835\udd62 h z) = f z := by\n  have : (cuspFunction h f) (\ud835\udd62 h z) = f (invQParam h (\ud835\udd62 h z)) := by\n    rw [cuspFunction]\n    rw [update_of_ne]\n    rw [comp_apply]\n    exact exp_ne_zero _\n  obtain \u27e8m, hm\u27e9 := qParam_left_inv_mod_period hh z\n  simpa only [this,hm] using hf.int_mul m z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Periodic.lean", "context": {"open": ["Complex Filter Asymptotics", "scoped Real Topology"], "variables": ["(h : \u211d)", "{h} -- next few theorems all assume h \u2260 0 or 0 < h", "(h : \u211d) (f : \u2102 \u2192 \u2102)", "{f h}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : \u211d\nf : \u2102 \u2192 \u2102\nx\u271d\u00b9 : Sort u_1\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhh : h \u2260 0\nhf : sorry\nz : \u2102\n\u22a2 sorry = f z"}, {"line": "have : (cuspFunction h f) (\ud835\udd62 h z) = f (invQParam h (\ud835\udd62 h z)) := by\n    rw [cuspFunction]\n    rw [update_of_ne]\n    rw [comp_apply]\n    exact exp_ne_zero _", "tactic_state": "h : \u211d\nf : \u2102 \u2192 \u2102\nx\u271d\u00b9 : Sort u_1\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhh : h \u2260 0\nhf : sorry\nz : \u2102\nthis : sorry = f sorry\n\u22a2 sorry = f z"}, {"line": "obtain \u27e8m, hm\u27e9 := qParam_left_inv_mod_period hh z", "tactic_state": "case mk\nh : \u211d\nf : \u2102 \u2192 \u2102\nx\u271d\u00b9 : Sort u_1\nPeriodic : x\u271d\u00b9\nx\u271d : Sort u_2\ncuspFunction : x\u271d\nhh : h \u2260 0\nhf : sorry\nz : \u2102\nthis : sorry = f sorry\nm hm : \u211d\n\u22a2 { re := m, im := hm } = f z"}, {"line": "simpa only [this,hm] using hf.int_mul m z", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonneg_of_iteratedDeriv_nonneg {f : \u2102 \u2192 \u2102} (hf : Differentiable \u2102 f) {c : \u2102}\n    (h : \u2200 n, 0 \u2264 iteratedDeriv n f c) \u2983z : \u2102\u2984 (hz : c \u2264 z) :\n    0 \u2264 f z := by\n  refine hf.differentiableOn.nonneg_of_iteratedDeriv_nonneg (r := (z - c).re + 1) h hz ?_\n  rw [\u2190 sub_nonneg] at hz\n  rw [Metric.mem_ball]\n  rw [dist_eq]\n  rw [eq_re_of_ofReal_le hz]\n  simpa only [Complex.norm_of_nonneg (nonneg_iff.mp hz).1] using lt_add_one _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Positivity.lean", "context": {"open": ["Complex", "scoped ComplexOrder"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 0 \u2264 f z"}, {"line": "refine hf.differentiableOn.nonneg_of_iteratedDeriv_nonneg (r := (z - c).re + 1) h hz ?_", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 z \u2208 Metric.ball c ((z - c).re + 1)"}, {"line": "rw [\u2190 sub_nonneg] at hz", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : 0 \u2264 z - c\n\u22a2 z \u2208 Metric.ball c ((z - c).re + 1)\n---\nf : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 AddRightMono \u2102"}, {"line": "rw [Metric.mem_ball]", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : 0 \u2264 z - c\n\u22a2 dist z c < (z - c).re + 1\n---\nf : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 AddRightMono \u2102"}, {"line": "rw [dist_eq]", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : 0 \u2264 z - c\n\u22a2 \u2016z - c\u2016 < (z - c).re + 1\n---\nf : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 AddRightMono \u2102"}, {"line": "rw [eq_re_of_ofReal_le hz]", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : 0 \u2264 z - c\n\u22a2 \u2016\u2191(z - c).re\u2016 < (\u2191(z - c).re).re + 1\n---\nf : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 AddRightMono \u2102"}, {"line": "simpa only [Complex.norm_of_nonneg (nonneg_iff.mp hz).1] using lt_add_one _", "tactic_state": "f : \u2102 \u2192 \u2102\nhf : Differentiable \u2102 f\nc : \u2102\nh : \u2200 (n : \u2115), 0 \u2264 iteratedDeriv n f c\nz : \u2102\nhz : c \u2264 z\n\u22a2 AddRightMono \u2102"}]}
{"declaration": "theorem interior_setOf_re_le (a : \u211d) : interior { z : \u2102 | z.re \u2264 a } = { z | z.re < a } := by\n  simpa only [interior_Iic] using interior_preimage_re (Iic a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 interior {z | z.re \u2264 a} = {z | z.re < a}"}, {"line": "simpa only [interior_Iic] using interior_preimage_re (Iic a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_setOf_im_le (a : \u211d) : interior { z : \u2102 | z.im \u2264 a } = { z | z.im < a } := by\n  simpa only [interior_Iic] using interior_preimage_im (Iic a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 interior {z | z.im \u2264 a} = {z | z.im < a}"}, {"line": "simpa only [interior_Iic] using interior_preimage_im (Iic a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_setOf_le_re (a : \u211d) : interior { z : \u2102 | a \u2264 z.re } = { z | a < z.re } := by\n  simpa only [interior_Ici] using interior_preimage_re (Ici a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 interior {z | a \u2264 z.re} = {z | a < z.re}"}, {"line": "simpa only [interior_Ici] using interior_preimage_re (Ici a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_setOf_le_im (a : \u211d) : interior { z : \u2102 | a \u2264 z.im } = { z | a < z.im } := by\n  simpa only [interior_Ici] using interior_preimage_im (Ici a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 interior {z | a \u2264 z.im} = {z | a < z.im}"}, {"line": "simpa only [interior_Ici] using interior_preimage_im (Ici a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_setOf_re_lt (a : \u211d) : closure { z : \u2102 | z.re < a } = { z | z.re \u2264 a } := by\n  simpa only [closure_Iio] using closure_preimage_re (Iio a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 closure {z | z.re < a} = {z | z.re \u2264 a}"}, {"line": "simpa only [closure_Iio] using closure_preimage_re (Iio a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_setOf_im_lt (a : \u211d) : closure { z : \u2102 | z.im < a } = { z | z.im \u2264 a } := by\n  simpa only [closure_Iio] using closure_preimage_im (Iio a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 closure {z | z.im < a} = {z | z.im \u2264 a}"}, {"line": "simpa only [closure_Iio] using closure_preimage_im (Iio a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_setOf_lt_re (a : \u211d) : closure { z : \u2102 | a < z.re } = { z | a \u2264 z.re } := by\n  simpa only [closure_Ioi] using closure_preimage_re (Ioi a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 closure {z | a < z.re} = {z | a \u2264 z.re}"}, {"line": "simpa only [closure_Ioi] using closure_preimage_re (Ioi a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_setOf_lt_im (a : \u211d) : closure { z : \u2102 | a < z.im } = { z | a \u2264 z.im } := by\n  simpa only [closure_Ioi] using closure_preimage_im (Ioi a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 closure {z | a < z.im} = {z | a \u2264 z.im}"}, {"line": "simpa only [closure_Ioi] using closure_preimage_im (Ioi a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_re_le (a : \u211d) : frontier { z : \u2102 | z.re \u2264 a } = { z | z.re = a } := by\n  simpa only [frontier_Iic] using frontier_preimage_re (Iic a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | z.re \u2264 a} = {z | z.re = a}"}, {"line": "simpa only [frontier_Iic] using frontier_preimage_re (Iic a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_im_le (a : \u211d) : frontier { z : \u2102 | z.im \u2264 a } = { z | z.im = a } := by\n  simpa only [frontier_Iic] using frontier_preimage_im (Iic a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | z.im \u2264 a} = {z | z.im = a}"}, {"line": "simpa only [frontier_Iic] using frontier_preimage_im (Iic a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_le_re (a : \u211d) : frontier { z : \u2102 | a \u2264 z.re } = { z | z.re = a } := by\n  simpa only [frontier_Ici] using frontier_preimage_re (Ici a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | a \u2264 z.re} = {z | z.re = a}"}, {"line": "simpa only [frontier_Ici] using frontier_preimage_re (Ici a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_le_im (a : \u211d) : frontier { z : \u2102 | a \u2264 z.im } = { z | z.im = a } := by\n  simpa only [frontier_Ici] using frontier_preimage_im (Ici a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | a \u2264 z.im} = {z | z.im = a}"}, {"line": "simpa only [frontier_Ici] using frontier_preimage_im (Ici a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_re_lt (a : \u211d) : frontier { z : \u2102 | z.re < a } = { z | z.re = a } := by\n  simpa only [frontier_Iio] using frontier_preimage_re (Iio a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | z.re < a} = {z | z.re = a}"}, {"line": "simpa only [frontier_Iio] using frontier_preimage_re (Iio a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_im_lt (a : \u211d) : frontier { z : \u2102 | z.im < a } = { z | z.im = a } := by\n  simpa only [frontier_Iio] using frontier_preimage_im (Iio a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | z.im < a} = {z | z.im = a}"}, {"line": "simpa only [frontier_Iio] using frontier_preimage_im (Iio a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_setOf_lt_re (a : \u211d) : frontier { z : \u2102 | a < z.re } = { z | z.re = a } := by\n  simpa only [frontier_Ioi] using frontier_preimage_re (Ioi a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ReImTopology.lean", "context": {"open": ["Set Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 frontier {z | a < z.re} = {z | z.re = a}"}, {"line": "simpa only [frontier_Ioi] using frontier_preimage_re (Ioi a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :\n    HasDerivAt (fun x : \u211d => (e x).re) e'.re z := by\n  have A : HasFDerivAt ((\u2191) : \u211d \u2192 \u2102) ofRealCLM z := ofRealCLM.hasFDerivAt\n  have B :\n    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : \u2102 \u2192L[\u2102] \u2102).restrictScalars \u211d)\n      (ofRealCLM z) :=\n    h.hasFDerivAt.restrictScalars \u211d\n  have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt\n  simpa using (C.comp z (B.comp z A)).hasDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e : \u2102 \u2192 \u2102\ne' : \u2102\nz : \u211d\nh : HasDerivAt e e' \u2191z\n\u22a2 HasDerivAt (fun x => (e \u2191x).re) e'.re z"}, {"line": "have A : HasFDerivAt ((\u2191) : \u211d \u2192 \u2102) ofRealCLM z := ofRealCLM.hasFDerivAt", "tactic_state": "e : \u2102 \u2192 \u2102\ne' : \u2102\nz : \u211d\nh : HasDerivAt e e' \u2191z\nA : HasFDerivAt ofReal ofRealCLM z\n\u22a2 HasDerivAt (fun x => (e \u2191x).re) e'.re z"}, {"line": "have B :\n    HasFDerivAt e ((ContinuousLinearMap.smulRight 1 e' : \u2102 \u2192L[\u2102] \u2102).restrictScalars \u211d)\n      (ofRealCLM z) :=\n    h.hasFDerivAt.restrictScalars \u211d", "tactic_state": "e : \u2102 \u2192 \u2102\ne' : \u2102\nz : \u211d\nh : HasDerivAt e e' \u2191z\nA : HasFDerivAt ofReal ofRealCLM z\nB : HasFDerivAt e (ContinuousLinearMap.restrictScalars \u211d (ContinuousLinearMap.smulRight 1 e')) (ofRealCLM z)\n\u22a2 HasDerivAt (fun x => (e \u2191x).re) e'.re z"}, {"line": "have C : HasFDerivAt re reCLM (e (ofRealCLM z)) := reCLM.hasFDerivAt", "tactic_state": "e : \u2102 \u2192 \u2102\ne' : \u2102\nz : \u211d\nh : HasDerivAt e e' \u2191z\nA : HasFDerivAt ofReal ofRealCLM z\nB : HasFDerivAt e (ContinuousLinearMap.restrictScalars \u211d (ContinuousLinearMap.smulRight 1 e')) (ofRealCLM z)\nC : HasFDerivAt re reCLM (e (ofRealCLM z))\n\u22a2 HasDerivAt (fun x => (e \u2191x).re) e'.re z"}, {"line": "simpa using (C.comp z (B.comp z A)).hasDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffAt.real_of_complex {n : WithTop \u2115\u221e} (h : ContDiffAt \u2102 n e z) :\n    ContDiffAt \u211d n (fun x : \u211d => (e x).re) z := by\n  have A : ContDiffAt \u211d n ((\u2191) : \u211d \u2192 \u2102) z := ofRealCLM.contDiff.contDiffAt\n  have B : ContDiffAt \u211d n e z := h.restrict_scalars \u211d\n  have C : ContDiffAt \u211d n re (e z) := reCLM.contDiff.contDiffAt\n  exact C.comp z (B.comp z A)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e : \u2102 \u2192 \u2102\nz : \u211d\nn : WithTop \u2115\u221e\nh : ContDiffAt \u2102 n e \u2191z\n\u22a2 ContDiffAt \u211d n (fun x => (e \u2191x).re) z"}, {"line": "have A : ContDiffAt \u211d n ((\u2191) : \u211d \u2192 \u2102) z := ofRealCLM.contDiff.contDiffAt", "tactic_state": "e : \u2102 \u2192 \u2102\nz : \u211d\nn : WithTop \u2115\u221e\nh : ContDiffAt \u2102 n e \u2191z\nA : ContDiffAt \u211d n ofReal z\n\u22a2 ContDiffAt \u211d n (fun x => (e \u2191x).re) z"}, {"line": "have B : ContDiffAt \u211d n e z := h.restrict_scalars \u211d", "tactic_state": "e : \u2102 \u2192 \u2102\nz : \u211d\nn : WithTop \u2115\u221e\nh : ContDiffAt \u2102 n e \u2191z\nA : ContDiffAt \u211d n ofReal z\nB : ContDiffAt \u211d n e \u2191z\n\u22a2 ContDiffAt \u211d n (fun x => (e \u2191x).re) z"}, {"line": "have C : ContDiffAt \u211d n re (e z) := reCLM.contDiff.contDiffAt", "tactic_state": "e : \u2102 \u2192 \u2102\nz : \u211d\nn : WithTop \u2115\u221e\nh : ContDiffAt \u2102 n e \u2191z\nA : ContDiffAt \u211d n ofReal z\nB : ContDiffAt \u211d n e \u2191z\nC : ContDiffAt \u211d n re (e \u2191z)\n\u22a2 ContDiffAt \u211d n (fun x => (e \u2191x).re) z"}, {"line": "exact C.comp z (B.comp z A)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E}\n    (h : HasStrictDerivAt f f' x) :\n    HasStrictFDerivAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasStrictFDerivAt.restrictScalars \u211d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nx : \u2102\nf' : E\nh : HasStrictDerivAt f f' x\n\u22a2 HasStrictFDerivAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') x"}, {"line": "simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasStrictFDerivAt.restrictScalars \u211d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E} (h : HasDerivAt f f' x) :\n    HasFDerivAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using h.hasFDerivAt.restrictScalars \u211d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nx : \u2102\nf' : E\nh : HasDerivAt f f' x\n\u22a2 HasFDerivAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') x"}, {"line": "simpa only [Complex.restrictScalars_one_smulRight'] using h.hasFDerivAt.restrictScalars \u211d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {s : Set \u2102} {x : \u2102} {f' : E}\n    (h : HasDerivWithinAt f f' s x) :\n    HasFDerivWithinAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') s x := by\n  simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasFDerivWithinAt.restrictScalars \u211d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\ns : Set \u2102\nx : \u2102\nf' : E\nh : HasDerivWithinAt f f' s x\n\u22a2 HasFDerivWithinAt f (reCLM.smulRight f' + I \u2022 imCLM.smulRight f') s x"}, {"line": "simpa only [Complex.restrictScalars_one_smulRight'] using\n    h.hasFDerivWithinAt.restrictScalars \u211d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.complexToReal_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102} (h : HasStrictDerivAt f f' x) :\n    HasStrictFDerivAt f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.hasStrictFDerivAt.restrictScalars \u211d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192 \u2102\nf' x : \u2102\nh : HasStrictDerivAt f f' x\n\u22a2 HasStrictFDerivAt f (f' \u2022 1) x"}, {"line": "simpa only [Complex.restrictScalars_one_smulRight] using h.hasStrictFDerivAt.restrictScalars \u211d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.complexToReal_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102} (h : HasDerivAt f f' x) :\n    HasFDerivAt f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.hasFDerivAt.restrictScalars \u211d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192 \u2102\nf' x : \u2102\nh : HasDerivAt f f' x\n\u22a2 HasFDerivAt f (f' \u2022 1) x"}, {"line": "simpa only [Complex.restrictScalars_one_smulRight] using h.hasFDerivAt.restrictScalars \u211d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.comp_ofReal (hf : HasDerivAt e e' \u2191z) : HasDerivAt (fun y : \u211d => e \u2191y) e' z := by\n  simpa only [ofRealCLM_apply,ofReal_one,mul_one] using hf.comp z ofRealCLM.hasDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e : \u2102 \u2192 \u2102\ne' : \u2102\nz : \u211d\nhf : HasDerivAt e e' \u2191z\n\u22a2 HasDerivAt (fun y => e \u2191y) e' z"}, {"line": "simpa only [ofRealCLM_apply,ofReal_one,mul_one] using hf.comp z ofRealCLM.hasDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.ofReal_comp {f : \u211d \u2192 \u211d} {u : \u211d} (hf : HasDerivAt f u z) :\n    HasDerivAt (fun y : \u211d => \u2191(f y) : \u211d \u2192 \u2102) u z := by\n  simpa only [ofRealCLM_apply,ofReal_one,real_smul,mul_one] using\n    ofRealCLM.hasDerivAt.scomp z hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RealDeriv.lean", "context": {"open": ["Complex"], "variables": ["{e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u211d\nf : \u211d \u2192 \u211d\nu : \u211d\nhf : HasDerivAt f u z\n\u22a2 HasDerivAt (fun y => \u2191(f y)) (\u2191u) z"}, {"line": "simpa only [ofRealCLM_apply,ofReal_one,real_smul,mul_one] using\n    ofRealCLM.hasDerivAt.scomp z hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_deriv_le_div_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (h\u2080 : 0 < R\u2081) : \u2016deriv f c\u2016 \u2264 R\u2082 / R\u2081 := by\n  simpa only [dslope_same] using norm_dslope_le_div_of_mapsTo_ball hd h_maps (mem_ball_self h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Schwarz.lean", "context": {"open": ["Metric Set Function Filter TopologicalSpace", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {R\u2081 R\u2082 : \u211d} {f : \u2102 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nR\u2081 R\u2082 : \u211d\nf : \u2102 \u2192 E\nc : \u2102\nhd : DifferentiableOn \u2102 f (ball c R\u2081)\nh_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)\nh\u2080 : 0 < R\u2081\n\u22a2 \u2016deriv f c\u2016 \u2264 R\u2082 / R\u2081"}, {"line": "simpa only [dslope_same] using norm_dslope_le_div_of_mapsTo_ball hd h_maps (mem_ball_self h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_div_mul_dist_of_mapsTo_ball (hd : DifferentiableOn \u2102 f (ball c R\u2081))\n    (h_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)) (hz : z \u2208 ball c R\u2081) :\n    dist (f z) (f c) \u2264 R\u2082 / R\u2081 * dist z c := by\n  rcases eq_or_ne z c with (rfl | hne)\n  \u00b7 simp only [dist_self, mul_zero, le_rfl]\n  simpa only [dslope_of_ne _ hne,slope_def_module,norm_smul,norm_inv,\u2190 div_eq_inv_mul,\u2190     dist_eq_norm,div_le_iff\u2080 (dist_pos.2 hne)] using norm_dslope_le_div_of_mapsTo_ball hd h_maps hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Schwarz.lean", "context": {"open": ["Metric Set Function Filter TopologicalSpace", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {R\u2081 R\u2082 : \u211d} {f : \u2102 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nR\u2081 R\u2082 : \u211d\nf : \u2102 \u2192 E\nc z : \u2102\nhd : DifferentiableOn \u2102 f (ball c R\u2081)\nh_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)\nhz : z \u2208 ball c R\u2081\n\u22a2 dist (f z) (f c) \u2264 R\u2082 / R\u2081 * dist z c"}, {"line": "rcases eq_or_ne z c with (rfl | hne)", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nR\u2081 R\u2082 : \u211d\nf : \u2102 \u2192 E\nz : \u2102\nhd : DifferentiableOn \u2102 f (ball z R\u2081)\nh_maps : MapsTo f (ball z R\u2081) (ball (f z) R\u2082)\nhz : z \u2208 ball z R\u2081\n\u22a2 dist (f z) (f z) \u2264 R\u2082 / R\u2081 * dist z z\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nR\u2081 R\u2082 : \u211d\nf : \u2102 \u2192 E\nc z : \u2102\nhd : DifferentiableOn \u2102 f (ball c R\u2081)\nh_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)\nhz : z \u2208 ball c R\u2081\nhne : z \u2260 c\n\u22a2 dist (f z) (f c) \u2264 R\u2082 / R\u2081 * dist z c"}, {"line": "\u00b7 simp only [dist_self, mul_zero, le_rfl]", "tactic_state": "case inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nR\u2081 R\u2082 : \u211d\nf : \u2102 \u2192 E\nc z : \u2102\nhd : DifferentiableOn \u2102 f (ball c R\u2081)\nh_maps : MapsTo f (ball c R\u2081) (ball (f c) R\u2082)\nhz : z \u2208 ball c R\u2081\nhne : z \u2260 c\n\u22a2 dist (f z) (f c) \u2264 R\u2082 / R\u2081 * dist z c"}, {"line": "simpa only [dslope_of_ne _ hne,slope_def_module,norm_smul,norm_inv,\u2190 div_eq_inv_mul,\u2190     dist_eq_norm,div_le_iff\u2080 (dist_pos.2 hne)] using norm_dslope_le_div_of_mapsTo_ball hd h_maps hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_le_norm_of_mapsTo_ball_self (hd : DifferentiableOn \u2102 f (ball 0 R))\n    (h_maps : MapsTo f (ball 0 R) (ball 0 R)) (h\u2080 : f 0 = 0) (hz : \u2016z\u2016 < R) :\n    \u2016f z\u2016 \u2264 \u2016z\u2016 := by\n  replace hz : z \u2208 ball (0 : \u2102) R := mem_ball_zero_iff.2 hz\n  simpa only [dist_zero_right] using dist_le_dist_of_mapsTo_ball_self hd h_maps h\u2080 hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Schwarz.lean", "context": {"open": ["Metric Set Function Filter TopologicalSpace", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {R\u2081 R\u2082 : \u211d} {f : \u2102 \u2192 E}", "{f : \u2102 \u2192 \u2102} {c z : \u2102} {R R\u2081 R\u2082 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192 \u2102\nz : \u2102\nR : \u211d\nhd : DifferentiableOn \u2102 f (ball 0 R)\nh_maps : MapsTo f (ball 0 R) (ball 0 R)\nh\u2080 : f 0 = 0\nhz : \u2016z\u2016 < R\n\u22a2 \u2016f z\u2016 \u2264 \u2016z\u2016"}, {"line": "replace hz : z \u2208 ball (0 : \u2102) R := mem_ball_zero_iff.2 hz", "tactic_state": "f : \u2102 \u2192 \u2102\nz : \u2102\nR : \u211d\nhd : DifferentiableOn \u2102 f (ball 0 R)\nh_maps : MapsTo f (ball 0 R) (ball 0 R)\nh\u2080 : f 0 = 0\nhz : z \u2208 ball 0 R\n\u22a2 \u2016f z\u2016 \u2264 \u2016z\u2016"}, {"line": "simpa only [dist_zero_right] using dist_le_dist_of_mapsTo_ball_self hd h_maps h\u2080 hz", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma stolzCone_subset_stolzSet_aux' (s : \u211d) :\n    \u2203 M \u03b5, 0 < M \u2227 0 < \u03b5 \u2227 \u2200 x y, 0 < x \u2192 x < \u03b5 \u2192 |y| < s * x \u2192\n      sqrt (x ^ 2 + y ^ 2) < M * (1 - sqrt ((1 - x) ^ 2 + y ^ 2)) := by\n  refine \u27e82 * sqrt (1 + s ^ 2) + 1, 1 / (1 + s ^ 2), by positivity, by positivity,\n    fun x y hx\u2080 hx\u2081 hy \u21a6 ?_\u27e9\n  have H : sqrt ((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2 := by\n    calc sqrt ((1 - x) ^ 2 + y ^ 2)\n      _ \u2264 sqrt ((1 - x) ^ 2 + (s * x) ^ 2) := sqrt_le_sqrt <| by rw [\u2190 sq_abs y]; gcongr\n      _ = sqrt (1 - 2 * x + (1 + s ^ 2) * x * x) := by congr 1; ring\n      _ \u2264 sqrt (1 - 2 * x + (1 + s ^ 2) * (1 / (1 + s ^ 2)) * x) := sqrt_le_sqrt <| by gcongr\n      _ = sqrt (1 - x) := by congr 1; field_simp; ring\n      _ \u2264 1 - x / 2 := by\n        simp_rw [sub_eq_add_neg, \u2190 neg_div]\n        refine sqrt_one_add_le <| neg_le_neg_iff.mpr (hx\u2081.trans_le ?_).le\n        rw [div_le_one (by positivity)]\n        exact le_add_of_nonneg_right <| sq_nonneg s\n  calc sqrt (x ^ 2 + y ^ 2)\n    _ \u2264 sqrt (x ^ 2 + (s * x) ^ 2) := sqrt_le_sqrt <| by rw [\u2190 sq_abs y]; gcongr\n    _ = sqrt ((1 + s ^ 2) * x ^ 2) := by congr; ring\n    _ = sqrt (1 + s ^ 2) * x := by rw [sqrt_mul' _ (sq_nonneg x), sqrt_sq hx\u2080.le]\n    _ = 2 * sqrt (1 + s ^ 2) * (x / 2) := by ring\n    _ < (2 * sqrt (1 + s ^ 2) + 1) * (x / 2) := by gcongr; exact lt_add_one _\n    _ \u2264 _ := by gcongr; exact le_sub_comm.mpr H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/AbelLimit.lean", "context": {"open": ["Filter Finset", "scoped Topology", "Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 \u2203 M \u03b5, 0 < M \u2227 0 < \u03b5 \u2227 \u2200 (x y : \u211d), 0 < x \u2192 x < \u03b5 \u2192 |y| < s * x \u2192 \u221a(x ^ 2 + y ^ 2) < M * (1 - \u221a((1 - x) ^ 2 + y ^ 2))"}, {"line": "refine \u27e82 * sqrt (1 + s ^ 2) + 1, 1 / (1 + s ^ 2), by positivity, by positivity,\n    fun x y hx\u2080 hx\u2081 hy \u21a6 ?_\u27e9", "tactic_state": "s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\n\u22a2 \u221a(x ^ 2 + y ^ 2) < (2 * \u221a(1 + s ^ 2) + 1) * (1 - \u221a((1 - x) ^ 2 + y ^ 2))"}, {"line": "have H : sqrt ((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2 := sorry", "tactic_state": "s x y : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x < 1 / (1 + s ^ 2)\nhy : |y| < s * x\nH : \u221a((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2\n\u22a2 \u221a(x ^ 2 + y ^ 2) < (2 * \u221a(1 + s ^ 2) + 1) * (1 - \u221a((1 - x) ^ 2 + y ^ 2))"}, {"line": "calc sqrt (x ^ 2 + y ^ 2)\n    _ \u2264 sqrt (x ^ 2 + (s * x) ^ 2) := sqrt_le_sqrt <| by rw [\u2190 sq_abs y]; gcongr\n    _ = sqrt ((1 + s ^ 2) * x ^ 2) := by congr; ring\n    _ = sqrt (1 + s ^ 2) * x := by rw [sqrt_mul' _ (sq_nonneg x), sqrt_sq hx\u2080.le]\n    _ = 2 * sqrt (1 + s ^ 2) * (x / 2) := by ring\n    _ < (2 * sqrt (1 + s ^ 2) + 1) * (x / 2) := by gcongr; exact lt_add_one _\n    _ \u2264 _ := by gcongr; exact le_sub_comm.mpr H", "tactic_state": "No Goals!"}]}
{"declaration": "lemma angle_eq_abs_arg (hx : x \u2260 0) (hy : y \u2260 0) : angle x y = |(x / y).arg| := by\n  refine Real.arccos_eq_of_eq_cos (abs_nonneg _) (abs_arg_le_pi _) ?_\n  rw [Real.cos_abs]\n  rw [Complex.cos_arg (div_ne_zero hx hy)]\n  have := norm_ne_zero_iff.mpr hy\n  simp [div_eq_mul_inv, Complex.normSq_eq_norm_sq]\n  field_simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Angle.lean", "context": {"open": ["InnerProductGeometry Set", "scoped Real"], "variables": ["{a x y : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 angle x y = |(x / y).arg|"}, {"line": "refine Real.arccos_eq_of_eq_cos (abs_nonneg _) (abs_arg_le_pi _) ?_", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 inner x y / (\u2016x\u2016 * \u2016y\u2016) = Real.cos |(x / y).arg|"}, {"line": "rw [Real.cos_abs]", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 inner x y / (\u2016x\u2016 * \u2016y\u2016) = Real.cos (x / y).arg"}, {"line": "rw [Complex.cos_arg (div_ne_zero hx hy)]", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 inner x y / (\u2016x\u2016 * \u2016y\u2016) = (x / y).re / \u2016x / y\u2016"}, {"line": "have := norm_ne_zero_iff.mpr hy", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\nthis : \u2016y\u2016 \u2260 0\n\u22a2 inner x y / (\u2016x\u2016 * \u2016y\u2016) = (x / y).re / \u2016x / y\u2016"}, {"line": "simp [div_eq_mul_inv, Complex.normSq_eq_norm_sq]", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\nthis : \u2016y\u2016 \u2260 0\n\u22a2 (y.re * x.re + y.im * x.im) * (\u2016y\u2016\u207b\u00b9 * \u2016x\u2016\u207b\u00b9) =\n    (x.re * (y.re * (\u2016y\u2016 ^ 2)\u207b\u00b9) + x.im * (y.im * (\u2016y\u2016 ^ 2)\u207b\u00b9)) * (\u2016y\u2016 * \u2016x\u2016\u207b\u00b9)"}, {"line": "field_simp", "tactic_state": "x y : \u2102\nhx : x \u2260 0\nhy : y \u2260 0\nthis : \u2016y\u2016 \u2260 0\n\u22a2 (y.re * x.re + y.im * x.im) * (\u2016y\u2016 ^ 2 * \u2016x\u2016) = (x.re * y.re + x.im * y.im) * \u2016y\u2016 * (\u2016y\u2016 * \u2016x\u2016)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma angle_div_left_eq_angle_mul_right (a x y : \u2102) : angle (x / a) y = angle x (y * a) := by\n  obtain rfl | ha := eq_or_ne a 0\n  \u00b7 simp\n  \u00b7 rw [\u2190 angle_mul_right ha, div_mul_cancel\u2080 _ ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Angle.lean", "context": {"open": ["InnerProductGeometry Set", "scoped Real"], "variables": ["{a x y : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a x y : \u2102\n\u22a2 angle (x / a) y = angle x (y * a)"}, {"line": "obtain rfl | ha := eq_or_ne a 0", "tactic_state": "case inl\nx y : \u2102\n\u22a2 angle (x / 0) y = angle x (y * 0)\n---\ncase inr\na x y : \u2102\nha : a \u2260 0\n\u22a2 angle (x / a) y = angle x (y * a)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\na x y : \u2102\nha : a \u2260 0\n\u22a2 angle (x / a) y = angle x (y * a)"}, {"line": "\u00b7 rw [\u2190 angle_mul_right ha, div_mul_cancel\u2080 _ ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equivRealProd_apply_le (z : \u2102) : \u2016equivRealProd z\u2016 \u2264 \u2016z\u2016 := by\n  simp [Prod.norm_def, abs_re_le_norm, abs_im_le_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Basic.lean", "context": {"open": ["ComplexConjugate Topology Filter"], "variables": ["{z : \u2102}", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nequivRealProd : x\u271d\nz : \u2102\n\u22a2 \u2016sorry\u2016 \u2264 \u2016z\u2016"}, {"line": "simp [Prod.norm_def, abs_re_le_norm, abs_im_le_norm]", "tactic_state": "x\u271d : Sort u_2\nequivRealProd : x\u271d\nz : \u2102\n\u22a2 \u2016sorry ()\u2016 \u2264 \u2016z\u2016"}]}
{"declaration": "theorem restrictScalars_one_smulRight (x : \u2102) :\n    ContinuousLinearMap.restrictScalars \u211d ((1 : \u2102 \u2192L[\u2102] \u2102).smulRight x : \u2102 \u2192L[\u2102] \u2102) =\n    x \u2022 (1 : \u2102 \u2192L[\u211d] \u2102) := by\n  ext1 z\n  dsimp\n  apply mul_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Basic.lean", "context": {"open": ["ComplexConjugate Topology Filter", "ContinuousLinearMap"], "variables": ["{z : \u2102}", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 restrictScalars \u211d (smulRight 1 x) = x \u2022 1"}, {"line": "ext1 z", "tactic_state": "case h\nx z : \u2102\n\u22a2 (restrictScalars \u211d (smulRight 1 x)) z = (x \u2022 1) z"}, {"line": "dsimp", "tactic_state": "case h\nx z : \u2102\n\u22a2 z * x = x * z"}, {"line": "apply mul_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ringHom_eq_id_or_conj_of_continuous {f : \u2102 \u2192+* \u2102} (hf : Continuous f) :\n    f = RingHom.id \u2102 \u2228 f = conj := by\n  simpa only [DFunLike.ext_iff] using real_algHom_eq_id_or_conj (AlgHom.mk' f (map_real_smul f hf))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Basic.lean", "context": {"open": ["ComplexConjugate Topology Filter", "ContinuousLinearMap"], "variables": ["{z : \u2102}", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192+* \u2102\nhf : Continuous \u21d1f\n\u22a2 f = RingHom.id \u2102 \u2228 f = starRingEnd \u2102"}, {"line": "simpa only [DFunLike.ext_iff] using real_algHom_eq_id_or_conj (AlgHom.mk' f (map_real_smul f hf))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ringHom_eq_ofReal_of_continuous {f : \u211d \u2192+* \u2102} (h : Continuous f) : f = ofRealHom := by\n  convert congr_arg AlgHom.toRingHom <| Subsingleton.elim (AlgHom.mk' f <| map_real_smul f h)\n    (Algebra.ofId \u211d \u2102)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Basic.lean", "context": {"open": ["ComplexConjugate Topology Filter", "ContinuousLinearMap"], "variables": ["{z : \u2102}", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "ofRealHom f : \u211d \u2192+* \u2102\nh : Continuous \u21d1f\n\u22a2 f = ofRealHom"}, {"line": "convert congr_arg AlgHom.toRingHom <| Subsingleton.elim (AlgHom.mk' f <| map_real_smul f h)\n    (Algebra.ofId \u211d \u2102)", "tactic_state": "case h.e'_3\nofRealHom f : \u211d \u2192+* \u2102\nh : Continuous \u21d1f\n\u22a2 ofRealHom = (Algebra.ofId \u211d \u2102).toRingHom"}]}
{"declaration": "theorem integral_boundary_rect_eq_zero_of_differentiable_on_off_countable (f : \u2102 \u2192 E) (z w : \u2102)\n    (s : Set \u2102) (hs : s.Countable) (Hc : ContinuousOn f ([[z.re, w.re]] \u00d7\u2102 [[z.im, w.im]]))\n    (Hd : \u2200 x \u2208 Ioo (min z.re w.re) (max z.re w.re) \u00d7\u2102 Ioo (min z.im w.im) (max z.im w.im) \\ s,\n      DifferentiableAt \u2102 f x) :\n    (\u222b x : \u211d in z.re..w.re, f (x + z.im * I)) - (\u222b x : \u211d in z.re..w.re, f (x + w.im * I)) +\n      I \u2022 (\u222b y : \u211d in z.im..w.im, f (re w + y * I)) -\n      I \u2022 (\u222b y : \u211d in z.im..w.im, f (re z + y * I)) = 0 := by\n  refine (integral_boundary_rect_of_hasFDerivAt_real_off_countable f\n    (fun z => (fderiv \u2102 f z).restrictScalars \u211d) z w s hs Hc\n    (fun x hx => (Hd x hx).hasFDerivAt.restrictScalars \u211d) ?_).trans ?_ <;>\n      simp [\u2190 ContinuousLinearMap.map_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/CauchyIntegral.lean", "context": {"open": ["TopologicalSpace Set MeasureTheory intervalIntegral Metric Filter Function", "scoped Interval Real NNReal ENNReal Topology"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nI : \u2102\nx\u271d : Sort u_1\nre : x\u271d\nf : \u2102 \u2192 E\nz w : \u2102\ns : Set \u2102\nhs : s.Countable\nHc : ContinuousOn f (uIcc z.re w.re \u00d7\u2102 uIcc z.im w.im)\nHd : \u2200 x \u2208 Ioo (min z.re w.re) (max z.re w.re) \u00d7\u2102 Ioo (min z.im w.im) (max z.im w.im) \\ s, DifferentiableAt \u2102 f x\n\u22a2 (((\u222b (x : \u211d) in z.re..w.re, f (\u2191x + \u2191z.im * I)) - \u222b (x : \u211d) in z.re..w.re, f (\u2191x + \u2191w.im * I)) +\n        I \u2022 \u222b (y : \u211d) in z.im..w.im, f (sorry + \u2191y * I)) -\n      I \u2022 \u222b (y : \u211d) in z.im..w.im, f (sorry + \u2191y * I) =\n    0"}, {"line": "refine (integral_boundary_rect_of_hasFDerivAt_real_off_countable f\n    (fun z => (fderiv \u2102 f z).restrictScalars \u211d) z w s hs Hc\n    (fun x hx => (Hd x hx).hasFDerivAt.restrictScalars \u211d) ?_).trans ?_ <;>\n      simp [\u2190 ContinuousLinearMap.map_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleIntegral_div_sub_of_differentiable_on_off_countable {R : \u211d} {c w : \u2102} {s : Set \u2102}\n    (hs : s.Countable) (hw : w \u2208 ball c R) {f : \u2102 \u2192 \u2102} (hc : ContinuousOn f (closedBall c R))\n    (hd : \u2200 z \u2208 ball c R \\ s, DifferentiableAt \u2102 f z) :\n    (\u222e z in C(c, R), f z / (z - w)) = 2 * \u03c0 * I * f w := by\n  simpa only [smul_eq_mul,div_eq_inv_mul] using\n    circleIntegral_sub_inv_smul_of_differentiable_on_off_countable hs hw hc hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/CauchyIntegral.lean", "context": {"open": ["TopologicalSpace Set MeasureTheory intervalIntegral Metric Filter Function", "scoped Interval Real NNReal ENNReal Topology"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u2102\nR : \u211d\nc w : \u2102\ns : Set \u2102\nhs : s.Countable\nhw : w \u2208 ball c R\nf : \u2102 \u2192 \u2102\nhc : ContinuousOn f (closedBall c R)\nhd : \u2200 z \u2208 ball c R \\ s, DifferentiableAt \u2102 f z\n\u22a2 (\u222e (z : \u2102) in C(c, R), f z / (z - w)) = 2 * \u2191Real.pi * I * f w"}, {"line": "simpa only [smul_eq_mul,div_eq_inv_mul] using\n    circleIntegral_sub_inv_smul_of_differentiable_on_off_countable hs hw hc hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticOn_iff_differentiableOn {f : \u2102 \u2192 E} {s : Set \u2102} (o : IsOpen s) :\n    AnalyticOn \u2102 f s \u2194 DifferentiableOn \u2102 f s := by\n  rw [o.analyticOn_iff_analyticOnNhd]\n  exact analyticOnNhd_iff_differentiableOn o\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/CauchyIntegral.lean", "context": {"open": ["TopologicalSpace Set MeasureTheory intervalIntegral Metric Filter Function", "scoped Interval Real NNReal ENNReal Topology"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\no : IsOpen s\n\u22a2 AnalyticOn \u2102 f s \u2194 DifferentiableOn \u2102 f s"}, {"line": "rw [o.analyticOn_iff_analyticOnNhd]", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\no : IsOpen s\n\u22a2 AnalyticOnNhd \u2102 f s \u2194 DifferentiableOn \u2102 f s"}, {"line": "exact analyticOnNhd_iff_differentiableOn o", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticOnNhd_univ_iff_differentiable {f : \u2102 \u2192 E} :\n    AnalyticOnNhd \u2102 f univ \u2194 Differentiable \u2102 f := by\n  simp only [\u2190 differentiableOn_univ]\n  exact analyticOnNhd_iff_differentiableOn isOpen_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/CauchyIntegral.lean", "context": {"open": ["TopologicalSpace Set MeasureTheory intervalIntegral Metric Filter Function", "scoped Interval Real NNReal ENNReal Topology"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\n\u22a2 AnalyticOnNhd \u2102 f univ \u2194 Differentiable \u2102 f"}, {"line": "simp only [\u2190 differentiableOn_univ]", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\n\u22a2 AnalyticOnNhd \u2102 f univ \u2194 DifferentiableOn \u2102 f univ"}, {"line": "exact analyticOnNhd_iff_differentiableOn isOpen_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticOn_univ_iff_differentiable {f : \u2102 \u2192 E} :\n    AnalyticOn \u2102 f univ \u2194 Differentiable \u2102 f := by\n  rw [analyticOn_univ]\n  exact analyticOnNhd_univ_iff_differentiable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/CauchyIntegral.lean", "context": {"open": ["TopologicalSpace Set MeasureTheory intervalIntegral Metric Filter Function", "scoped Interval Real NNReal ENNReal Topology"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\n\u22a2 AnalyticOn \u2102 f univ \u2194 Differentiable \u2102 f"}, {"line": "rw [analyticOn_univ]", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\n\u22a2 AnalyticOnNhd \u2102 f univ \u2194 Differentiable \u2102 f"}, {"line": "exact analyticOnNhd_univ_iff_differentiable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsConformalMap.is_complex_or_conj_linear (h : IsConformalMap g) :\n    (\u2203 map : \u2102 \u2192L[\u2102] \u2102, map.restrictScalars \u211d = g) \u2228\n      \u2203 map : \u2102 \u2192L[\u2102] \u2102, map.restrictScalars \u211d = g \u2218L \u2191conjCLE := by\n  rcases h with \u27e8c, -, li, rfl\u27e9\n  obtain \u27e8li, rfl\u27e9 : \u2203 li' : \u2102 \u2243\u2097\u1d62[\u211d] \u2102, li'.toLinearIsometry = li :=\n    \u27e8li.toLinearIsometryEquiv rfl, by ext1; rfl\u27e9\n  rcases linear_isometry_complex li with \u27e8a, rfl | rfl\u27e9\n  -- let rot := c \u2022 (a : \u2102) \u2022 ContinuousLinearMap.id \u2102 \u2102,\n  \u00b7 refine Or.inl \u27e8c \u2022 (a : \u2102) \u2022 ContinuousLinearMap.id \u2102 \u2102, ?_\u27e9\n    ext1\n    simp\n  \u00b7 refine Or.inr \u27e8c \u2022 (a : \u2102) \u2022 ContinuousLinearMap.id \u2102 \u2102, ?_\u27e9\n    ext1\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Conformal.lean", "context": {"open": ["Complex ContinuousLinearMap ComplexConjugate", "ContinuousLinearMap"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedSpace \u2102 E]", "{g : \u2102 \u2192L[\u211d] \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g : \u2102 \u2192L[\u211d] \u2102\nh : IsConformalMap g\n\u22a2 (\u2203 map, restrictScalars \u211d map = g) \u2228 \u2203 map, restrictScalars \u211d map = g.comp \u2191conjCLE"}, {"line": "rcases h with \u27e8c, -, li, rfl\u27e9", "tactic_state": "case intro.intro.intro\nc : \u211d\nli : \u2102 \u2192\u2097\u1d62[\u211d] \u2102\n\u22a2 (\u2203 map, restrictScalars \u211d map = c \u2022 li.toContinuousLinearMap) \u2228\n    \u2203 map, restrictScalars \u211d map = (c \u2022 li.toContinuousLinearMap).comp \u2191conjCLE"}, {"line": "obtain \u27e8li, rfl\u27e9 : \u2203 li' : \u2102 \u2243\u2097\u1d62[\u211d] \u2102, li'.toLinearIsometry = li :=\n    \u27e8li.toLinearIsometryEquiv rfl, by ext1; rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nc : \u211d\nli : \u2102 \u2243\u2097\u1d62[\u211d] \u2102\n\u22a2 (\u2203 map, restrictScalars \u211d map = c \u2022 li.toLinearIsometry.toContinuousLinearMap) \u2228\n    \u2203 map, restrictScalars \u211d map = (c \u2022 li.toLinearIsometry.toContinuousLinearMap).comp \u2191conjCLE"}, {"line": "rcases linear_isometry_complex li with \u27e8a, rfl | rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.inl\nc : \u211d\na : Circle\n\u22a2 (\u2203 map, restrictScalars \u211d map = c \u2022 (rotation a).toLinearIsometry.toContinuousLinearMap) \u2228\n    \u2203 map, restrictScalars \u211d map = (c \u2022 (rotation a).toLinearIsometry.toContinuousLinearMap).comp \u2191conjCLE\n---\ncase intro.intro.intro.intro.intro.inr\nc : \u211d\na : Circle\n\u22a2 (\u2203 map, restrictScalars \u211d map = c \u2022 (conjLIE.trans (rotation a)).toLinearIsometry.toContinuousLinearMap) \u2228\n    \u2203 map,\n      restrictScalars \u211d map = (c \u2022 (conjLIE.trans (rotation a)).toLinearIsometry.toContinuousLinearMap).comp \u2191conjCLE"}, {"line": "\u00b7 refine Or.inl \u27e8c \u2022 (a : \u2102) \u2022 ContinuousLinearMap.id \u2102 \u2102, ?_\u27e9\n    ext1\n    simp", "tactic_state": "case intro.intro.intro.intro.intro.inr\nc : \u211d\na : Circle\n\u22a2 (\u2203 map, restrictScalars \u211d map = c \u2022 (conjLIE.trans (rotation a)).toLinearIsometry.toContinuousLinearMap) \u2228\n    \u2203 map,\n      restrictScalars \u211d map = (c \u2022 (conjLIE.trans (rotation a)).toLinearIsometry.toContinuousLinearMap).comp \u2191conjCLE"}, {"line": "\u00b7 refine Or.inr \u27e8c \u2022 (a : \u2102) \u2022 ContinuousLinearMap.id \u2102 \u2102, ?_\u27e9\n    ext1\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.isConnected_of_upperHalfPlane {r} {s : Set \u2102} (hs\u2081 : {z | r < z.im} \u2286 s)\n    (hs\u2082 : s \u2286 {z | r \u2264 z.im}) : IsConnected s := by\n  refine .subset_closure ?_ hs\u2081 (by simpa only [closure_setOf_lt_im] using hs\u2082)\n  exact (convex_halfSpace_im_gt r).isConnected \u27e8(r + 1) * I, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Convex.lean", "context": {"open": ["Set", "scoped ComplexOrder", "Complex"], "variables": ["(r : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\ns : Set \u2102\nhs\u2081 : {z | r < z.im} \u2286 s\nhs\u2082 : s \u2286 {z | r \u2264 z.im}\n\u22a2 IsConnected s"}, {"line": "refine .subset_closure ?_ hs\u2081 (by simpa only [closure_setOf_lt_im] using hs\u2082)", "tactic_state": "r : \u211d\ns : Set \u2102\nhs\u2081 : {z | r < z.im} \u2286 s\nhs\u2082 : s \u2286 {z | r \u2264 z.im}\n\u22a2 IsConnected {z | r < z.im}"}, {"line": "exact (convex_halfSpace_im_gt r).isConnected \u27e8(r + 1) * I, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.isConnected_of_lowerHalfPlane {r} {s : Set \u2102} (hs\u2081 : {z | z.im < r} \u2286 s)\n    (hs\u2082 : s \u2286 {z | z.im \u2264 r}) : IsConnected s := by\n  refine .subset_closure ?_ hs\u2081 (by simpa only [closure_setOf_im_lt] using hs\u2082)\n  exact (convex_halfSpace_im_lt r).isConnected \u27e8(r - 1) * I, by simp\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Convex.lean", "context": {"open": ["Set", "scoped ComplexOrder", "Complex"], "variables": ["(r : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\ns : Set \u2102\nhs\u2081 : {z | z.im < r} \u2286 s\nhs\u2082 : s \u2286 {z | z.im \u2264 r}\n\u22a2 IsConnected s"}, {"line": "refine .subset_closure ?_ hs\u2081 (by simpa only [closure_setOf_im_lt] using hs\u2082)", "tactic_state": "r : \u211d\ns : Set \u2102\nhs\u2081 : {z | z.im < r} \u2286 s\nhs\u2082 : s \u2286 {z | z.im \u2264 r}\n\u22a2 IsConnected {z | z.im < r}"}, {"line": "exact (convex_halfSpace_im_lt r).isConnected \u27e8(r - 1) * I, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eventuallyle (z : \u2102) (hB : BddAbove ((norm \u2218 f) '' verticalClosedStrip 0 1))\n    (hd : DiffContOnCl \u2102 f (verticalStrip 0 1)) (hz : z \u2208 verticalStrip 0 1) :\n    (fun _ : \u211d \u21a6 \u2016f z\u2016) \u2264\u1da0[\ud835\udcdd[>] 0]\n    (fun \u03b5 \u21a6 \u2016((\u03b5 + sSupNormIm f 0) ^ (1 - z) * (\u03b5 + sSupNormIm f 1) ^ z : \u2102)\u2016) := by\n  filter_upwards [self_mem_nhdsWithin] with \u03b5 (h\u03b5 : 0 < \u03b5) using\n    norm_le_interpStrip_of_mem_verticalClosedStrip_eps f \u03b5 h\u03b5 z hB hd\n      (mem_of_mem_of_subset hz (preimage_mono Ioo_subset_Icc_self))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Hadamard.lean", "context": {"open": ["Set Filter Function Complex Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E) (z : \u2102)", "[NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E)", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u2102 \u2192 E\ninst\u271d : NormedSpace \u2102 E\nx\u271d\u00b2 : Sort u_3\nverticalClosedStrip : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\nverticalStrip : x\u271d\u00b9\nx\u271d : Sort u_5\nsSupNormIm : x\u271d\nz : \u2102\nhB : BddAbove (norm \u2218 f '' sorry)\nhd : DiffContOnCl \u2102 f sorry\nhz : z \u2208 sorry\n\u22a2 (fun x => \u2016f z\u2016) \u2264\u1da0[nhdsWithin 0 (Ioi 0)] fun \u03b5 => \u2016(\u2191\u03b5 + sorry) ^ (1 - z) * (\u2191\u03b5 + sorry) ^ z\u2016"}, {"line": "filter_upwards [self_mem_nhdsWithin] with \u03b5 (h\u03b5 : 0 < \u03b5) using\n    norm_le_interpStrip_of_mem_verticalClosedStrip_eps f \u03b5 h\u03b5 z hB hd\n      (mem_of_mem_of_subset hz (preimage_mono Ioo_subset_Icc_self))", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma fun_arg_eq {l u : \u211d} (hul : l < u) (z : \u2102) :\n    (\u2191l + (z / (\u2191u - \u2191l) - \u2191l / (\u2191u - \u2191l)) * (\u2191u - \u2191l)) = z := by\n  rw [sub_mul]\n  rw [div_mul_comm]\n  rw [div_self (by norm_cast; linarith)]\n  rw [div_mul_comm]\n  rw [div_self (by norm_cast; linarith)]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Hadamard.lean", "context": {"open": ["Set Filter Function Complex Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E) (z : \u2102)", "[NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E)", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + (z / (\u2191u - \u2191l) - \u2191l / (\u2191u - \u2191l)) * (\u2191u - \u2191l) = z"}, {"line": "rw [sub_mul]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + (z / (\u2191u - \u2191l) * (\u2191u - \u2191l) - \u2191l / (\u2191u - \u2191l) * (\u2191u - \u2191l)) = z"}, {"line": "rw [div_mul_comm]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + ((\u2191u - \u2191l) / (\u2191u - \u2191l) * z - \u2191l / (\u2191u - \u2191l) * (\u2191u - \u2191l)) = z"}, {"line": "rw [div_self (by norm_cast; linarith)]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + (1 * z - \u2191l / (\u2191u - \u2191l) * (\u2191u - \u2191l)) = z"}, {"line": "rw [div_mul_comm]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + (1 * z - (\u2191u - \u2191l) / (\u2191u - \u2191l) * \u2191l) = z"}, {"line": "rw [div_self (by norm_cast; linarith)]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 \u2191l + (1 * z - 1 * \u2191l) = z"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma bound_exp_eq {l u : \u211d} (hul : l < u) (z : \u2102) :\n    (z / (\u2191u - \u2191l)).re - ((l : \u2102) / (\u2191u - \u2191l)).re = (z.re - l) / (u - l) := by\n  norm_cast\n  rw [Complex.div_re]\n  rw [Complex.normSq_ofReal]\n  rw [Complex.ofReal_re]\n  rw [Complex.ofReal_im]\n  rw [mul_div_assoc]\n  rw [div_mul_eq_div_div_swap]\n  rw [div_self (by norm_cast; linarith)]\n  rw [\u2190 div_eq_mul_one_div]\n  simp only [mul_zero]\n  simp only [zero_div]\n  simp only [add_zero]\n  rw [\u2190 div_sub_div_same]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Hadamard.lean", "context": {"open": ["Set Filter Function Complex Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E) (z : \u2102)", "[NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E] (f : \u2102 \u2192 E)", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 (z / (\u2191u - \u2191l)).re - (\u2191l / (\u2191u - \u2191l)).re = (z.re - l) / (u - l)"}, {"line": "norm_cast", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 (z / \u2191(u - l)).re - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [Complex.div_re]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * (\u2191(u - l)).re / normSq \u2191(u - l) + z.im * (\u2191(u - l)).im / normSq \u2191(u - l) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [Complex.normSq_ofReal]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * (\u2191(u - l)).re / ((u - l) * (u - l)) + z.im * (\u2191(u - l)).im / ((u - l) * (u - l)) - l / (u - l) =\n    (z.re - l) / (u - l)"}, {"line": "rw [Complex.ofReal_re]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * (u - l) / ((u - l) * (u - l)) + z.im * (\u2191(u - l)).im / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [Complex.ofReal_im]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * (u - l) / ((u - l) * (u - l)) + z.im * 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [mul_div_assoc]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * ((u - l) / ((u - l) * (u - l))) + z.im * 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [div_mul_eq_div_div_swap]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * ((u - l) / (u - l) / (u - l)) + z.im * 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [div_self (by norm_cast; linarith)]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re * (1 / (u - l)) + z.im * 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [\u2190 div_eq_mul_one_div]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re / (u - l) + z.im * 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "simp only [mul_zero]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re / (u - l) + 0 / ((u - l) * (u - l)) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "simp only [zero_div]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re / (u - l) + 0 - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "simp only [add_zero]", "tactic_state": "l u : \u211d\nhul : l < u\nz : \u2102\n\u22a2 z.re / (u - l) - l / (u - l) = (z.re - l) / (u - l)"}, {"line": "rw [\u2190 div_sub_div_same]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logDeriv_tendsto {\u03b9 : Type*} {p : Filter \u03b9} (f : \u03b9 \u2192 \u2102 \u2192 \u2102) (g : \u2102 \u2192 \u2102)\n    {s : Set \u2102} (hs : IsOpen s) (x : s) (hF : TendstoLocallyUniformlyOn f g p s)\n    (hf : \u2200\u1da0 n : \u03b9 in p, DifferentiableOn \u2102 (f n) s) (hg : g x \u2260 0) :\n    Tendsto (fun n : \u03b9 => logDeriv (f n) x) p (\ud835\udcdd ((logDeriv g) x)) := by\n  simp_rw [logDeriv]\n  apply Tendsto.div ((hF.deriv hf hs).tendsto_at x.2) (hF.tendsto_at x.2) hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/LocallyUniformLimit.lean", "context": {"open": ["Set Metric MeasureTheory Filter Complex intervalIntegral", "scoped Real Topology"], "variables": ["{E \u03b9 : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {U K : Set \u2102}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\np : Filter \u03b9\nf : \u03b9 \u2192 \u2102 \u2192 \u2102\ng : \u2102 \u2192 \u2102\ns : Set \u2102\nhs : IsOpen s\nx : \u2191s\nhF : TendstoLocallyUniformlyOn f g p s\nhf : \u2200\u1da0 (n : \u03b9) in p, DifferentiableOn \u2102 (f n) s\nhg : g \u2191x \u2260 0\n\u22a2 Tendsto (fun n => logDeriv (f n) \u2191x) p (nhds (logDeriv g \u2191x))"}, {"line": "simp_rw [logDeriv]", "tactic_state": "\u03b9 : Type u_3\np : Filter \u03b9\nf : \u03b9 \u2192 \u2102 \u2192 \u2102\ng : \u2102 \u2192 \u2102\ns : Set \u2102\nhs : IsOpen s\nx : \u2191s\nhF : TendstoLocallyUniformlyOn f g p s\nhf : \u2200\u1da0 (n : \u03b9) in p, DifferentiableOn \u2102 (f n) s\nhg : g \u2191x \u2260 0\n\u22a2 Tendsto (fun n => (deriv (f n) / f n) \u2191x) p (nhds ((deriv g / g) \u2191x))"}, {"line": "apply Tendsto.div ((hF.deriv hf hs).tendsto_at x.2) (hF.tendsto_at x.2) hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiableOn_compl_singleton_and_continuousAt_iff {f : \u2102 \u2192 E} {s : Set \u2102} {c : \u2102}\n    (hs : s \u2208 \ud835\udcdd c) :\n    DifferentiableOn \u2102 f (s \\ {c}) \u2227 ContinuousAt f c \u2194 DifferentiableOn \u2102 f s := by\n  refine \u27e8?_, fun hd => \u27e8hd.mono diff_subset, (hd.differentiableAt hs).continuousAt\u27e9\u27e9\n  rintro \u27e8hd, hc\u27e9 x hx\n  rcases eq_or_ne x c with (rfl | hne)\n  \u00b7 refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt\n      ?_ hc).differentiableAt.differentiableWithinAt\n    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds_iff.2 hs).mono fun z hz hzx => ?_)\n    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))\n  \u00b7 simpa only [DifferentiableWithinAt,HasFDerivWithinAt,hne.nhdsWithin_diff_singleton] using\n      hd x \u27e8hx, hne\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/RemovableSingularity.lean", "context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] [CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nc : \u2102\nhs : s \u2208 nhds c\n\u22a2 DifferentiableOn \u2102 f (s \\ {c}) \u2227 ContinuousAt f c \u2194 DifferentiableOn \u2102 f s"}, {"line": "refine \u27e8?_, fun hd => \u27e8hd.mono diff_subset, (hd.differentiableAt hs).continuousAt\u27e9\u27e9", "tactic_state": "E : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nc : \u2102\nhs : s \u2208 nhds c\n\u22a2 DifferentiableOn \u2102 f (s \\ {c}) \u2227 ContinuousAt f c \u2192 DifferentiableOn \u2102 f s"}, {"line": "rintro \u27e8hd, hc\u27e9 x hx", "tactic_state": "case intro\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nc : \u2102\nhs : s \u2208 nhds c\nhd : DifferentiableOn \u2102 f (s \\ {c})\nhc : ContinuousAt f c\nx : \u2102\nhx : x \u2208 s\n\u22a2 DifferentiableWithinAt \u2102 f s x"}, {"line": "rcases eq_or_ne x c with (rfl | hne)", "tactic_state": "case intro.inl\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nx : \u2102\nhx : x \u2208 s\nhs : s \u2208 nhds x\nhd : DifferentiableOn \u2102 f (s \\ {x})\nhc : ContinuousAt f x\n\u22a2 DifferentiableWithinAt \u2102 f s x\n---\ncase intro.inr\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nc : \u2102\nhs : s \u2208 nhds c\nhd : DifferentiableOn \u2102 f (s \\ {c})\nhc : ContinuousAt f c\nx : \u2102\nhx : x \u2208 s\nhne : x \u2260 c\n\u22a2 DifferentiableWithinAt \u2102 f s x"}, {"line": "\u00b7 refine (analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt\n      ?_ hc).differentiableAt.differentiableWithinAt\n    refine eventually_nhdsWithin_iff.2 ((eventually_mem_nhds_iff.2 hs).mono fun z hz hzx => ?_)\n    exact hd.differentiableAt (inter_mem hz (isOpen_ne.mem_nhds hzx))", "tactic_state": "case intro.inr\nE : Type u\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\ninst\u271d : CompleteSpace E\nf : \u2102 \u2192 E\ns : Set \u2102\nc : \u2102\nhs : s \u2208 nhds c\nhd : DifferentiableOn \u2102 f (s \\ {c})\nhc : ContinuousAt f c\nx : \u2102\nhx : x \u2208 s\nhne : x \u2260 c\n\u22a2 DifferentiableWithinAt \u2102 f s x"}, {"line": "\u00b7 simpa only [DifferentiableWithinAt,HasFDerivWithinAt,hne.nhdsWithin_diff_singleton] using\n      hd x \u27e8hx, hne\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Polynomial.mul_star_dvd_of_aeval_eq_zero_im_ne_zero (p : \u211d[X]) {z : \u2102} (h0 : aeval z p = 0)\n    (hz : z.im \u2260 0) : (X - C ((starRingEnd \u2102) z)) * (X - C z) \u2223 map (algebraMap \u211d \u2102) p := by\n  apply IsCoprime.mul_dvd\n  \u00b7 exact isCoprime_X_sub_C_of_isUnit_sub <| .mk0 _ <| sub_ne_zero.2 <| mt conj_eq_iff_im.1 hz\n  \u00b7 simpa [dvd_iff_isRoot, aeval_conj]\n  \u00b7 simpa [dvd_iff_isRoot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Polynomial/Basic.lean", "context": {"open": ["Polynomial Bornology Complex", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 (X - C ((starRingEnd \u2102) z)) * (X - C z) \u2223 map (algebraMap \u211d \u2102) p"}, {"line": "apply IsCoprime.mul_dvd", "tactic_state": "case H\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 IsCoprime (X - C ((starRingEnd \u2102) z)) (X - C z)\n---\ncase H1\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X - C ((starRingEnd \u2102) z) \u2223 map (algebraMap \u211d \u2102) p\n---\ncase H2\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X - C z \u2223 map (algebraMap \u211d \u2102) p"}, {"line": "\u00b7 exact isCoprime_X_sub_C_of_isUnit_sub <| .mk0 _ <| sub_ne_zero.2 <| mt conj_eq_iff_im.1 hz", "tactic_state": "case H1\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X - C ((starRingEnd \u2102) z) \u2223 map (algebraMap \u211d \u2102) p\n---\ncase H2\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X - C z \u2223 map (algebraMap \u211d \u2102) p"}, {"line": "\u00b7 simpa [dvd_iff_isRoot, aeval_conj]", "tactic_state": "case H2\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X - C z \u2223 map (algebraMap \u211d \u2102) p"}, {"line": "\u00b7 simpa [dvd_iff_isRoot]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Polynomial.quadratic_dvd_of_aeval_eq_zero_im_ne_zero (p : \u211d[X]) {z : \u2102} (h0 : aeval z p = 0)\n    (hz : z.im \u2260 0) : X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2) \u2223 p := by\n  rw [\u2190 map_dvd_map' (algebraMap \u211d \u2102)]\n  convert p.mul_star_dvd_of_aeval_eq_zero_im_ne_zero h0 hz\n  calc\n    map (algebraMap \u211d \u2102) (X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2))\n    _ = X ^ 2 - C (\u2191(2 * z.re) : \u2102) * X + C (\u2016z\u2016 ^ 2 : \u2102) := by simp\n    _ = (X - C (conj z)) * (X - C z) := by\n      rw [\u2190 add_conj]\n      rw [map_add]\n      rw [\u2190 mul_conj']\n      rw [map_mul]\n      ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/Polynomial/Basic.lean", "context": {"open": ["Polynomial Bornology Complex", "scoped ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2) \u2223 p"}, {"line": "rw [\u2190 map_dvd_map' (algebraMap \u211d \u2102)]", "tactic_state": "p : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 map (algebraMap \u211d \u2102) (X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2)) \u2223 map (algebraMap \u211d \u2102) p"}, {"line": "convert p.mul_star_dvd_of_aeval_eq_zero_im_ne_zero h0 hz", "tactic_state": "case h.e'_3\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 map (algebraMap \u211d \u2102) (X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2)) = (X - C ((starRingEnd \u2102) z)) * (X - C z)"}, {"line": "calc\n    map (algebraMap \u211d \u2102) (X ^ 2 - C (2 * z.re) * X + C (\u2016z\u2016 ^ 2))\n    _ = X ^ 2 - C (\u2191(2 * z.re) : \u2102) * X + C (\u2016z\u2016 ^ 2 : \u2102) := by simp\n    _ = (X - C (conj z)) * (X - C z) := by\n      rw [\u2190 add_conj]\n      rw [map_add]\n      rw [\u2190 mul_conj']\n      rw [map_mul]\n      ring", "tactic_state": "case h.e'_3.calc.step\np : Polynomial \u211d\nz : \u2102\nh0 : (aeval z) p = 0\nhz : z.im \u2260 0\n\u22a2 (X - C sorry) * (X - C z) = (X - C ((starRingEnd \u2102) z)) * (X - C z)"}]}
{"declaration": "theorem UpperHalfPlane.norm_exp_two_pi_I_lt_one (\u03c4 : \u210d) :\n    \u2016(Complex.exp (2 * \u03c0 * Complex.I * \u03c4))\u2016 < 1 := by\n  simpa [Function.Periodic.norm_qParam, Complex.norm_exp] using \u03c4.norm_qParam_lt_one 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Exp.lean", "context": {"open": ["Real Complex UpperHalfPlane Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : UpperHalfPlane\n\u22a2 \u2016Complex.exp (2 * \u2191Real.pi * Complex.I * \u2191\u03c4)\u2016 < 1"}, {"line": "simpa [Function.Periodic.norm_qParam, Complex.norm_exp] using \u03c4.norm_qParam_lt_one 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBoundedAtImInfty_iff {\u03b1 : Type*} [Norm \u03b1] {f : \u210d \u2192 \u03b1} :\n    IsBoundedAtImInfty f \u2194 \u2203 M A : \u211d, \u2200 z : \u210d, A \u2264 im z \u2192 \u2016f z\u2016 \u2264 M := by\n  simp [IsBoundedAtImInfty, BoundedAtFilter, Asymptotics.isBigO_iff, Filter.Eventually,\n    atImInfty_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/FunctionsBoundedAtInfty.lean", "context": {"open": ["Complex Filter", "scoped Topology UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nIsBoundedAtImInfty : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Norm \u03b1\nf : UpperHalfPlane \u2192 \u03b1\n\u22a2 sorry \u2194 \u2203 M A, \u2200 (z : UpperHalfPlane), A \u2264 (\u2191z).im \u2192 \u2016f z\u2016 \u2264 M"}, {"line": "simp [IsBoundedAtImInfty, BoundedAtFilter, Asymptotics.isBigO_iff, Filter.Eventually,\n    atImInfty_mem]", "tactic_state": "x\u271d : Sort u_2\nIsBoundedAtImInfty : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Norm \u03b1\nf : UpperHalfPlane \u2192 \u03b1\n\u22a2 sorry () \u2194 \u2203 M A, \u2200 (z : UpperHalfPlane), A \u2264 z.im \u2192 \u2016f z\u2016 \u2264 M"}]}
{"declaration": "lemma coe_mk_subtype {z : \u2102} (hz : 0 < z.im) :\n    UpperHalfPlane.coe \u27e8z, hz\u27e9 = z := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nhz : 0 < z.im\n\u22a2 \u2191\u27e8z, hz\u27e9 = z"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem im_inv_neg_coe_pos (z : \u210d) : 0 < (-z : \u2102)\u207b\u00b9.im := by\n  simpa [neg_div] using div_pos z.property (normSq_pos z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\n\u22a2 0 < (-\u2191z)\u207b\u00b9.im"}, {"line": "simpa [neg_div] using div_pos z.property (normSq_pos z)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ne_nat (z : \u210d) : \u2200 n : \u2115, z.1 \u2260 n := by\n  intro n\n  have h1 := z.2\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\n\u22a2 \u2200 (n : \u2115), \u2191z \u2260 \u2191n"}, {"line": "intro n", "tactic_state": "z : UpperHalfPlane\nn : \u2115\n\u22a2 \u2191z \u2260 \u2191n"}, {"line": "have h1 := z.2", "tactic_state": "z : UpperHalfPlane\nn : \u2115\nh1 : 0 < (\u2191z).im\n\u22a2 \u2191z \u2260 \u2191n"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ne_int (z : \u210d) : \u2200 n : \u2124, z.1 \u2260 n := by\n  intro n\n  have h1 := z.2\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\n\u22a2 \u2200 (n : \u2124), \u2191z \u2260 \u2191n"}, {"line": "intro n", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 \u2191z \u2260 \u2191n"}, {"line": "have h1 := z.2", "tactic_state": "z : UpperHalfPlane\nn : \u2124\nh1 : 0 < (\u2191z).im\n\u22a2 \u2191z \u2260 \u2191n"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem c_mul_im_sq_le_normSq_denom : (g 1 0 * z.im) ^ 2 \u2264 Complex.normSq (denom g z) := by\n  set c := g 1 0\n  set d := g 1 1\n  calc\n    (c * z.im) ^ 2 \u2264 (c * z.im) ^ 2 + (c * z.re + d) ^ 2 := by nlinarith\n    _ = Complex.normSq (denom g z) := by dsimp [c, d, denom, Complex.normSq]; ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": ["(g : GL(2, \u211d)\u207a) (z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g : \u21a5(GLPos (Fin 2) \u211d)\nz : UpperHalfPlane\n\u22a2 (\u2191\u2191g 1 0 * z.im) ^ 2 \u2264 Complex.normSq (denom g z)"}, {"line": "set c := g 1 0", "tactic_state": "g : \u21a5(GLPos (Fin 2) \u211d)\nz : UpperHalfPlane\nc : \u211d := \u2191\u2191g 1 0\n\u22a2 (c * z.im) ^ 2 \u2264 Complex.normSq (denom g z)"}, {"line": "set d := g 1 1", "tactic_state": "g : \u21a5(GLPos (Fin 2) \u211d)\nz : UpperHalfPlane\nc : \u211d := \u2191\u2191g 1 0\nd : \u211d := \u2191\u2191g 1 1\n\u22a2 (c * z.im) ^ 2 \u2264 Complex.normSq (denom g z)"}, {"line": "calc\n    (c * z.im) ^ 2 \u2264 (c * z.im) ^ 2 + (c * z.re + d) ^ 2 := by nlinarith\n    _ = Complex.normSq (denom g z) := by dsimp [c, d, denom, Complex.normSq]; ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma denom_one : denom 1 z = 1 := by\n  simp [denom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": ["(g : GL(2, \u211d)\u207a) (z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\n\u22a2 denom 1 z = 1"}, {"line": "simp [denom]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modular_T_zpow_smul (z : \u210d) (n : \u2124) : ModularGroup.T ^ n \u2022 z = (n : \u211d) +\u1d65 z := by\n  rw [UpperHalfPlane.ext_iff]\n  rw [coe_vadd]\n  rw [add_comm]\n  rw [specialLinearGroup_apply]\n  rw [coe_mk]\n  simp [toGL, ModularGroup.coe_T_zpow,\n    of_apply, cons_val_zero, algebraMap.coe_one, Complex.ofReal_one, one_mul, cons_val_one,\n    head_cons, algebraMap.coe_zero, zero_mul, zero_add, div_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": ["(g : GL(2, \u211d)\u207a) (z : \u210d)", "(x : { x : \u211d // 0 < x }) (z : \u210d)", "(x : \u211d) (z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 ModularGroup.T ^ n \u2022 z = \u2191n +\u1d65 z"}, {"line": "rw [UpperHalfPlane.ext_iff]", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 \u2191(ModularGroup.T ^ n \u2022 z) = \u2191(\u2191n +\u1d65 z)"}, {"line": "rw [coe_vadd]", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 \u2191(ModularGroup.T ^ n \u2022 z) = \u2191\u2191n + \u2191z"}, {"line": "rw [add_comm]", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 \u2191(ModularGroup.T ^ n \u2022 z) = \u2191z + \u2191\u2191n"}, {"line": "rw [specialLinearGroup_apply]", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 \u2191(mk\n        ((\u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 0 0)) * \u2191z + \u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 0 1))) /\n          (\u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 1 0)) * \u2191z + \u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 1 1))))\n        \u22ef) =\n    \u2191z + \u2191\u2191n"}, {"line": "rw [coe_mk]", "tactic_state": "z : UpperHalfPlane\nn : \u2124\n\u22a2 (\u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 0 0)) * \u2191z + \u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 0 1))) /\n      (\u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 1 0)) * \u2191z + \u2191((algebraMap \u2124 \u211d) (\u2191(ModularGroup.T ^ n) 1 1))) =\n    \u2191z + \u2191\u2191n"}, {"line": "simp [toGL, ModularGroup.coe_T_zpow,\n    of_apply, cons_val_zero, algebraMap.coe_one, Complex.ofReal_one, one_mul, cons_val_one,\n    head_cons, algebraMap.coe_zero, zero_mul, zero_add, div_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modular_T_smul (z : \u210d) : ModularGroup.T \u2022 z = (1 : \u211d) +\u1d65 z := by\n  simpa only [Int.cast_one] using modular_T_zpow_smul z 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": ["(g : GL(2, \u211d)\u207a) (z : \u210d)", "(x : { x : \u211d // 0 < x }) (z : \u210d)", "(x : \u211d) (z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\n\u22a2 ModularGroup.T \u2022 z = 1 +\u1d65 z"}, {"line": "simpa only [Int.cast_one] using modular_T_zpow_smul z 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem denom_apply (g : SL(2, \u2124)) (z : \u210d) :\n    denom g z = g 1 0 * z + g 1 1 := by\n  simp [denom, coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Basic.lean", "context": {"open": ["Matrix Matrix.SpecialLinearGroup", "scoped MatrixGroups", "UpperHalfPlane", "Lean Meta Qq"], "variables": ["(g : GL(2, \u211d)\u207a) (z : \u210d)", "(x : { x : \u211d // 0 < x }) (z : \u210d)", "(x : \u211d) (z : \u210d)", "(g : SL(2, \u2124)) (z : \u210d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g : SpecialLinearGroup (Fin 2) \u2124\nz : UpperHalfPlane\n\u22a2 denom (\u2191g) z = \u2191(\u2191g 1 0) * \u2191z + \u2191(\u2191g 1 1)"}, {"line": "simp [denom, coe]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mdifferentiableAt_iff {f : \u210d \u2192 \u2102} {\u03c4 : \u210d} :\n    MDifferentiableAt \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) f \u03c4 \u2194 DifferentiableAt \u2102 (f \u2218 ofComplex) \u2191\u03c4 := by\n  rw [\u2190 mdifferentiableAt_iff_differentiableAt]\n  refine \u27e8fun hf \u21a6 ?_, fun hf \u21a6 ?_\u27e9\n  \u00b7 exact (ofComplex_apply \u03c4 \u25b8 hf).comp _ (mdifferentiableAt_ofComplex \u03c4.im_pos)\n  \u00b7 simpa only [Function.comp_def,ofComplex_apply] using hf.comp \u03c4 (mdifferentiable_coe \u03c4)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Manifold.lean", "context": {"open": ["Filter", "scoped Manifold ContDiff"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u210d : Type u_1\nofComplex : \u210d \u2192 \u210d\nf : \u210d \u2192 \u2102\n\u03c4 : \u210d\n\u22a2 sorry \u2194 DifferentiableAt \u2102 (f \u2218 ofComplex) \u03c4"}, {"line": "rw [\u2190 mdifferentiableAt_iff_differentiableAt]", "tactic_state": "\u210d : Type u_1\nofComplex : \u210d \u2192 \u210d\nf : \u210d \u2192 \u2102\n\u03c4 : \u210d\n\u22a2 sorry \u2194 MDifferentiableAt (modelWithCornersSelf \u2102 \u210d) (modelWithCornersSelf \u2102 \u2102) (f \u2218 ofComplex) \u03c4\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedAddCommGroup \u210d\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedSpace \u2102 \u210d"}, {"line": "refine \u27e8fun hf \u21a6 ?_, fun hf \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u210d : Type u_1\nofComplex : \u210d \u2192 \u210d\nf : \u210d \u2192 \u2102\n\u03c4 : \u210d\nhf : sorry\n\u22a2 MDifferentiableAt (modelWithCornersSelf \u2102 \u210d) (modelWithCornersSelf \u2102 \u2102) (f \u2218 ofComplex) \u03c4\n---\ncase refine_2\n\u210d : Type u_1\nofComplex : \u210d \u2192 \u210d\nf : \u210d \u2192 \u2102\n\u03c4 : \u210d\nhf : MDifferentiableAt (modelWithCornersSelf \u2102 \u210d) (modelWithCornersSelf \u2102 \u2102) (f \u2218 ofComplex) \u03c4\n\u22a2 sorry\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedAddCommGroup \u210d\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedSpace \u2102 \u210d"}, {"line": "\u00b7 exact (ofComplex_apply \u03c4 \u25b8 hf).comp _ (mdifferentiableAt_ofComplex \u03c4.im_pos)", "tactic_state": "case refine_2\n\u210d : Type u_1\nofComplex : \u210d \u2192 \u210d\nf : \u210d \u2192 \u2102\n\u03c4 : \u210d\nhf : MDifferentiableAt (modelWithCornersSelf \u2102 \u210d) (modelWithCornersSelf \u2102 \u2102) (f \u2218 ofComplex) \u03c4\n\u22a2 sorry\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedAddCommGroup \u210d\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedSpace \u2102 \u210d"}, {"line": "\u00b7 simpa only [Function.comp_def,ofComplex_apply] using hf.comp \u03c4 (mdifferentiable_coe \u03c4)", "tactic_state": "\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedAddCommGroup \u210d\n---\n\u22a2 {\u210d : Type u_1} \u2192 {ofComplex : \u210d \u2192 \u210d} \u2192 {f : \u210d \u2192 \u2102} \u2192 {\u03c4 : \u210d} \u2192 NormedSpace \u2102 \u210d"}]}
{"declaration": "theorem dist_self_center (z : \u210d) (r : \u211d) :\n    dist (z : \u2102) (z.center r) = z.im * (Real.cosh r - 1) := by\n  rw [dist_of_re_eq (z.center_re r).symm]\n  rw [dist_comm]\n  rw [Real.dist_eq]\n  rw [mul_sub]\n  rw [mul_one]\n  exact abs_of_nonneg (sub_nonneg.2 <| le_mul_of_one_le_right z.im_pos.le (one_le_cosh _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean", "context": {"open": ["Filter Metric Real Set Topology", "scoped UpperHalfPlane ComplexConjugate NNReal Topology MatrixGroups", "Complex"], "variables": ["{z w : \u210d} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 dist \u2191z \u2191(z.center r) = z.im * (Real.cosh r - 1)"}, {"line": "rw [dist_of_re_eq (z.center_re r).symm]", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 dist (\u2191z).im (\u2191(z.center r)).im = z.im * (Real.cosh r - 1)"}, {"line": "rw [dist_comm]", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 dist (\u2191(z.center r)).im (\u2191z).im = z.im * (Real.cosh r - 1)"}, {"line": "rw [Real.dist_eq]", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 |(\u2191(z.center r)).im - (\u2191z).im| = z.im * (Real.cosh r - 1)"}, {"line": "rw [mul_sub]", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 |(\u2191(z.center r)).im - (\u2191z).im| = z.im * Real.cosh r - z.im * 1"}, {"line": "rw [mul_one]", "tactic_state": "z : UpperHalfPlane\nr : \u211d\n\u22a2 |(\u2191(z.center r)).im - (\u2191z).im| = z.im * Real.cosh r - z.im"}, {"line": "exact abs_of_nonneg (sub_nonneg.2 <| le_mul_of_one_le_right z.im_pos.le (one_le_cosh _))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem im_le_im_mul_exp_dist (z w : \u210d) : z.im \u2264 w.im * Real.exp (dist z w) := by\n  rw [\u2190 div_le_iff\u2080' w.im_pos]\n  rw [\u2190 exp_log z.im_pos]\n  rw [\u2190 exp_log w.im_pos]\n  rw [\u2190 Real.exp_sub]\n  rw [exp_le_exp]\n  exact (le_abs_self _).trans (dist_log_im_le z w)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Metric.lean", "context": {"open": ["Filter Metric Real Set Topology", "scoped UpperHalfPlane ComplexConjugate NNReal Topology MatrixGroups", "Complex"], "variables": ["{z w : \u210d} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z w : UpperHalfPlane\n\u22a2 z.im \u2264 w.im * Real.exp (dist z w)"}, {"line": "rw [\u2190 div_le_iff\u2080' w.im_pos]", "tactic_state": "z w : UpperHalfPlane\n\u22a2 z.im / w.im \u2264 Real.exp (dist z w)"}, {"line": "rw [\u2190 exp_log z.im_pos]", "tactic_state": "z w : UpperHalfPlane\n\u22a2 Real.exp (Real.log z.im) / w.im \u2264 Real.exp (dist z w)"}, {"line": "rw [\u2190 exp_log w.im_pos]", "tactic_state": "z w : UpperHalfPlane\n\u22a2 Real.exp (Real.log z.im) / Real.exp (Real.log w.im) \u2264 Real.exp (dist z w)"}, {"line": "rw [\u2190 Real.exp_sub]", "tactic_state": "z w : UpperHalfPlane\n\u22a2 Real.exp (Real.log z.im - Real.log w.im) \u2264 Real.exp (dist z w)"}, {"line": "rw [exp_le_exp]", "tactic_state": "z w : UpperHalfPlane\n\u22a2 Real.log z.im - Real.log w.im \u2264 dist z w"}, {"line": "exact (le_abs_self _).trans (dist_log_im_le z w)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofComplex_apply_eq_ite (w : \u2102) :\n    ofComplex w = if hw : 0 < w.im then \u27e8w, hw\u27e9 else Classical.choice inferInstance := by\n  split_ifs with hw\n  \u00b7 exact ofComplex_apply \u27e8w, hw\u27e9\n  \u00b7 change (Function.invFunOn UpperHalfPlane.coe Set.univ w) = _\n    simp only [invFunOn]\n    simp only [dite_eq_right_iff]\n    simp only [mem_univ]\n    simp only [true_and]\n    rintro \u27e8a, rfl\u27e9\n    exact (a.prop.not_le (by simpa using hw)).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "context": {"open": ["Complex Filter Function Set TopologicalSpace Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\n\u22a2 sorry = if hw : 0 < w.im then ?m.73 else Classical.choice \u22ef"}, {"line": "split_ifs with hw", "tactic_state": "case pos\nx\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\nhw : 0 < w.im\n\u22a2 sorry = ?m.73\n---\ncase neg\nx\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\nhw : \u00ac0 < w.im\n\u22a2 sorry = Classical.choice \u22ef"}, {"line": "\u00b7 exact ofComplex_apply \u27e8w, hw\u27e9", "tactic_state": "case neg\nx\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\nhw : \u00ac0 < w.im\n\u22a2 sorry = Classical.choice \u22ef"}, {"line": "\u00b7 change (Function.invFunOn UpperHalfPlane.coe Set.univ w) = _\n    simp only [invFunOn]\n    simp only [dite_eq_right_iff]\n    simp only [mem_univ]\n    simp only [true_and]\n    rintro \u27e8a, rfl\u27e9\n    exact (a.prop.not_le (by simpa using hw)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofComplex_apply_of_im_pos {z : \u2102} (hz : 0 < z.im) :\n    ofComplex z = \u27e8z, hz\u27e9 := by\n  simpa only [coe_mk_subtype] using ofComplex_apply \u27e8z, hz\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "context": {"open": ["Complex Filter Function Set TopologicalSpace Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofComplex : x\u271d\nz : \u2102\nhz : 0 < z.im\n\u22a2 sorry = sorry"}, {"line": "simpa only [coe_mk_subtype] using ofComplex_apply \u27e8z, hz\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofComplex_apply_of_im_nonpos {w : \u2102} (hw : w.im \u2264 0) :\n    ofComplex w = Classical.choice inferInstance := by\n  simp [ofComplex_apply_eq_ite w, hw]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "context": {"open": ["Complex Filter Function Set TopologicalSpace Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\nhw : w.im \u2264 0\n\u22a2 sorry = Classical.choice \u22ef"}, {"line": "simp [ofComplex_apply_eq_ite w, hw]", "tactic_state": "x\u271d : Sort u_1\nofComplex : x\u271d\nw : \u2102\nhw : w.im \u2264 0\n\u22a2 sorry () = Classical.choice \u22ef"}]}
{"declaration": "lemma ofComplex_apply_eq_of_im_nonpos {w w' : \u2102} (hw : w.im \u2264 0) (hw' : w'.im \u2264 0) :\n    ofComplex w = ofComplex w' := by\n  simp [ofComplex_apply_of_im_nonpos, hw, hw']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "context": {"open": ["Complex Filter Function Set TopologicalSpace Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofComplex : x\u271d\nw w' : \u2102\nhw : w.im \u2264 0\nhw' : w'.im \u2264 0\n\u22a2 sorry = sorry"}, {"line": "simp [ofComplex_apply_of_im_nonpos, hw, hw']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_ofComplex_of_im_le_zero (f : \u210d \u2192 \u2102) (z z' : \u2102) (hz : z.im \u2264 0) (hz' : z'.im \u2264 0)  :\n    (\u2191\u2095 f) z = (\u2191\u2095 f) z' := by\n  simp [ofComplex_apply_of_im_nonpos, hz, hz']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/UpperHalfPlane/Topology.lean", "context": {"open": ["Complex Filter Function Set TopologicalSpace Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u210d : Sort u_1\nf : \u210d \u2192 \u2102\nz z' : \u2102\nhz : z.im \u2264 0\nhz' : z'.im \u2264 0\n\u22a2 sorry = sorry"}, {"line": "simp [ofComplex_apply_of_im_nonpos, hz, hz']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma logCounting_coe_eq_logCounting_sub_const_zero :\n    logCounting f a\u2080 = logCounting (f - fun _ \u21a6 a\u2080) 0 := by\n  simp [logCounting]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Complex/ValueDistribution/CountingFunction.lean", "context": {"open": ["MeromorphicOn Metric Real Set"], "variables": ["", "(f a) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlogCounting : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [logCounting]", "tactic_state": "x\u271d : Sort u_1\nlogCounting : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem ampleSet_univ {F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F] :\n    AmpleSet (univ : Set F) := by\n  intro x _\n  rw [connectedComponentIn_univ]\n  rw [PreconnectedSpace.connectedComponent_eq_univ]\n  rw [convexHull_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/AmpleSet.lean", "context": {"open": ["Set"], "variables": ["{F : Type*} [AddCommGroup F] [Module \u211d F] [TopologicalSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\n\u22a2 AmpleSet univ"}, {"line": "intro x _", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx : F\na\u271d : x \u2208 univ\n\u22a2 (convexHull \u211d) (connectedComponentIn univ x) = univ"}, {"line": "rw [connectedComponentIn_univ]", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx : F\na\u271d : x \u2208 univ\n\u22a2 (convexHull \u211d) (connectedComponent x) = univ"}, {"line": "rw [PreconnectedSpace.connectedComponent_eq_univ]", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx : F\na\u271d : x \u2208 univ\n\u22a2 (convexHull \u211d) univ = univ\n---\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx : F\na\u271d : x \u2208 univ\n\u22a2 PreconnectedSpace F"}, {"line": "rw [convexHull_univ]", "tactic_state": "F : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nx : F\na\u271d : x \u2208 univ\n\u22a2 PreconnectedSpace F"}]}
{"declaration": "theorem affineSegment_image (f : P \u2192\u1d43[R] P') (x y : P) :\n    f '' affineSegment R x y = affineSegment R (f x) (f y) := by\n  rw [affineSegment]\n  rw [affineSegment]\n  rw [Set.image_image]\n  rw [\u2190 comp_lineMap]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nf : P \u2192\u1d43[R] P'\nx y : P\n\u22a2 \u21d1f '' affineSegment R x y = affineSegment R (f x) (f y)"}, {"line": "rw [affineSegment]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nf : P \u2192\u1d43[R] P'\nx y : P\n\u22a2 \u21d1f '' (\u21d1(lineMap x y) '' Set.Icc 0 1) = affineSegment R (f x) (f y)"}, {"line": "rw [affineSegment]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nf : P \u2192\u1d43[R] P'\nx y : P\n\u22a2 \u21d1f '' (\u21d1(lineMap x y) '' Set.Icc 0 1) = \u21d1(lineMap (f x) (f y)) '' Set.Icc 0 1"}, {"line": "rw [Set.image_image]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nf : P \u2192\u1d43[R] P'\nx y : P\n\u22a2 (fun x_1 => f ((lineMap x y) x_1)) '' Set.Icc 0 1 = \u21d1(lineMap (f x) (f y)) '' Set.Icc 0 1"}, {"line": "rw [\u2190 comp_lineMap]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : AddCommGroup V'\ninst\u271d\u00b9 : Module R V'\ninst\u271d : AddTorsor V' P'\nf : P \u2192\u1d43[R] P'\nx y : P\n\u22a2 (fun x_1 => f ((lineMap x y) x_1)) '' Set.Icc 0 1 = \u21d1(f.comp (lineMap x y)) '' Set.Icc 0 1"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineSegment_comm (x y : P) : affineSegment R x y = affineSegment R y x := by\n  refine Set.ext fun z => ?_\n  constructor <;>\n    \u00b7 rintro \u27e8t, ht, hxy\u27e9\n      refine \u27e81 - t, ?_, ?_\u27e9\n      \u00b7 rwa [Set.sub_mem_Icc_iff_right, sub_self, sub_zero]\n      \u00b7 rwa [lineMap_apply_one_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module R V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : IsOrderedRing R\nx y : P\n\u22a2 affineSegment R x y = affineSegment R y x"}, {"line": "refine Set.ext fun z => ?_", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module R V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 z \u2208 affineSegment R x y \u2194 z \u2208 affineSegment R y x"}, {"line": "constructor <;>\n    \u00b7 rintro \u27e8t, ht, hxy\u27e9\n      refine \u27e81 - t, ?_, ?_\u27e9\n      \u00b7 rwa [Set.sub_mem_Icc_iff_right, sub_self, sub_zero]\n      \u00b7 rwa [lineMap_apply_one_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sbtw_comm {x y z : P} : Sbtw R x y z \u2194 Sbtw R z y x := by\n  rw [Sbtw]\n  rw [Sbtw]\n  rw [wbtw_comm]\n  rw [\u2190 and_assoc]\n  rw [\u2190 and_assoc]\n  rw [and_right_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 Sbtw R x y z \u2194 Sbtw R z y x"}, {"line": "rw [Sbtw]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 Wbtw R x y z \u2227 y \u2260 x \u2227 y \u2260 z \u2194 Sbtw R z y x"}, {"line": "rw [Sbtw]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 Wbtw R x y z \u2227 y \u2260 x \u2227 y \u2260 z \u2194 Wbtw R z y x \u2227 y \u2260 z \u2227 y \u2260 x"}, {"line": "rw [wbtw_comm]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 Wbtw R z y x \u2227 y \u2260 x \u2227 y \u2260 z \u2194 Wbtw R z y x \u2227 y \u2260 z \u2227 y \u2260 x\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 IsOrderedRing R"}, {"line": "rw [\u2190 and_assoc]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 (Wbtw R z y x \u2227 y \u2260 x) \u2227 y \u2260 z \u2194 Wbtw R z y x \u2227 y \u2260 z \u2227 y \u2260 x\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 IsOrderedRing R"}, {"line": "rw [\u2190 and_assoc]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 (Wbtw R z y x \u2227 y \u2260 x) \u2227 y \u2260 z \u2194 (Wbtw R z y x \u2227 y \u2260 z) \u2227 y \u2260 x\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 IsOrderedRing R"}, {"line": "rw [and_right_comm]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : PartialOrder R\ninst\u271d\u2074 : AddCommGroup V\ninst\u271d\u00b3 : Module R V\ninst\u271d\u00b2 : AddTorsor V P\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\n\u22a2 IsOrderedRing R"}]}
{"declaration": "theorem Wbtw.map {x y z : P} (h : Wbtw R x y z) (f : P \u2192\u1d43[R] P') : Wbtw R (f x) (f y) (f z) := by\n  rw [Wbtw]\n  rw [\u2190 affineSegment_image]\n  exact Set.mem_image_of_mem _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 : AddCommGroup V'\ninst\u271d\u00b3 : Module R V'\ninst\u271d\u00b2 : AddTorsor V' P'\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\nh : Wbtw R x y z\nf : P \u2192\u1d43[R] P'\n\u22a2 Wbtw R (f x) (f y) (f z)"}, {"line": "rw [Wbtw]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 : AddCommGroup V'\ninst\u271d\u00b3 : Module R V'\ninst\u271d\u00b2 : AddTorsor V' P'\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\nh : Wbtw R x y z\nf : P \u2192\u1d43[R] P'\n\u22a2 f y \u2208 affineSegment R (f x) (f z)"}, {"line": "rw [\u2190 affineSegment_image]", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 : AddCommGroup V'\ninst\u271d\u00b3 : Module R V'\ninst\u271d\u00b2 : AddTorsor V' P'\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\nh : Wbtw R x y z\nf : P \u2192\u1d43[R] P'\n\u22a2 f y \u2208 \u21d1f '' affineSegment R x z"}, {"line": "exact Set.mem_image_of_mem _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Injective.wbtw_map_iff {x y z : P} {f : P \u2192\u1d43[R] P'} (hf : Function.Injective f) :\n    Wbtw R (f x) (f y) (f z) \u2194 Wbtw R x y z := by\n  refine \u27e8fun h => ?_, fun h => h.map _\u27e9\n  rwa [Wbtw, \u2190 affineSegment_image, hf.mem_set_image] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 : AddCommGroup V'\ninst\u271d\u00b3 : Module R V'\ninst\u271d\u00b2 : AddTorsor V' P'\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\nf : P \u2192\u1d43[R] P'\nhf : Injective \u21d1f\n\u22a2 Wbtw R (f x) (f y) (f z) \u2194 Wbtw R x y z"}, {"line": "refine \u27e8fun h => ?_, fun h => h.map _\u27e9", "tactic_state": "R : Type u_1\nV : Type u_2\nV' : Type u_3\nP : Type u_4\nP' : Type u_5\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 : AddCommGroup V'\ninst\u271d\u00b3 : Module R V'\ninst\u271d\u00b2 : AddTorsor V' P'\ninst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx y z : P\nf : P \u2192\u1d43[R] P'\nhf : Injective \u21d1f\nh : Wbtw R (f x) (f y) (f z)\n\u22a2 Wbtw R x y z"}, {"line": "rwa [Wbtw, \u2190 affineSegment_image, hf.mem_set_image] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wbtw_zero_one_iff {x : R} : Wbtw R 0 x 1 \u2194 x \u2208 Set.Icc (0 : R) 1 := by\n  rw [Wbtw]\n  rw [affineSegment]\n  rw [Set.mem_image]\n  simp_rw [lineMap_apply_ring]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Wbtw R 0 x 1 \u2194 x \u2208 Set.Icc 0 1"}, {"line": "rw [Wbtw]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 x \u2208 affineSegment R 0 1 \u2194 x \u2208 Set.Icc 0 1"}, {"line": "rw [affineSegment]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 x \u2208 \u21d1(lineMap 0 1) '' Set.Icc 0 1 \u2194 x \u2208 Set.Icc 0 1"}, {"line": "rw [Set.mem_image]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 (\u2203 x_1 \u2208 Set.Icc 0 1, (lineMap 0 1) x_1 = x) \u2194 x \u2208 Set.Icc 0 1"}, {"line": "simp_rw [lineMap_apply_ring]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 (\u2203 x_1 \u2208 Set.Icc 0 1, (1 - x_1) * 0 + x_1 * 1 = x) \u2194 x \u2208 Set.Icc 0 1"}, {"line": "simp", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 (\u2203 x_1, (0 \u2264 x_1 \u2227 x_1 \u2264 1) \u2227 0 + x_1 * 1 = x) \u2194 0 \u2264 x \u2227 x \u2264 1"}]}
{"declaration": "theorem wbtw_one_zero_iff {x : R} : Wbtw R 1 x 0 \u2194 x \u2208 Set.Icc (0 : R) 1 := by\n  rw [wbtw_comm]\n  rw [wbtw_zero_one_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Wbtw R 1 x 0 \u2194 x \u2208 Set.Icc 0 1"}, {"line": "rw [wbtw_comm]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Wbtw R 0 x 1 \u2194 x \u2208 Set.Icc 0 1\n---\nR : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 IsOrderedRing R"}, {"line": "rw [wbtw_zero_one_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 IsOrderedRing R"}]}
{"declaration": "theorem sbtw_zero_one_iff {x : R} : Sbtw R 0 x 1 \u2194 x \u2208 Set.Ioo (0 : R) 1 := by\n  rw [Sbtw]\n  rw [wbtw_zero_one_iff]\n  rw [Set.mem_Icc]\n  rw [Set.mem_Ioo]\n  exact\n    \u27e8fun h => \u27e8h.1.1.lt_of_ne (Ne.symm h.2.1), h.1.2.lt_of_ne h.2.2\u27e9, fun h =>\n      \u27e8\u27e8h.1.le, h.2.le\u27e9, h.1.ne', h.2.ne\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Sbtw R 0 x 1 \u2194 x \u2208 Set.Ioo 0 1"}, {"line": "rw [Sbtw]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Wbtw R 0 x 1 \u2227 x \u2260 0 \u2227 x \u2260 1 \u2194 x \u2208 Set.Ioo 0 1"}, {"line": "rw [wbtw_zero_one_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 x \u2208 Set.Icc 0 1 \u2227 x \u2260 0 \u2227 x \u2260 1 \u2194 x \u2208 Set.Ioo 0 1"}, {"line": "rw [Set.mem_Icc]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 (0 \u2264 x \u2227 x \u2264 1) \u2227 x \u2260 0 \u2227 x \u2260 1 \u2194 x \u2208 Set.Ioo 0 1"}, {"line": "rw [Set.mem_Ioo]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 (0 \u2264 x \u2227 x \u2264 1) \u2227 x \u2260 0 \u2227 x \u2260 1 \u2194 0 < x \u2227 x < 1"}, {"line": "exact\n    \u27e8fun h => \u27e8h.1.1.lt_of_ne (Ne.symm h.2.1), h.1.2.lt_of_ne h.2.2\u27e9, fun h =>\n      \u27e8\u27e8h.1.le, h.2.le\u27e9, h.1.ne', h.2.ne\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sbtw_one_zero_iff {x : R} : Sbtw R 1 x 0 \u2194 x \u2208 Set.Ioo (0 : R) 1 := by\n  rw [sbtw_comm]\n  rw [sbtw_zero_one_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Sbtw R 1 x 0 \u2194 x \u2208 Set.Ioo 0 1"}, {"line": "rw [sbtw_comm]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 Sbtw R 0 x 1 \u2194 x \u2208 Set.Ioo 0 1\n---\nR : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 IsOrderedRing R"}, {"line": "rw [sbtw_zero_one_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nx : R\n\u22a2 IsOrderedRing R"}]}
{"declaration": "theorem Wbtw.trans_right {w x y z : P} (h\u2081 : Wbtw R w x z) (h\u2082 : Wbtw R x y z) : Wbtw R w y z := by\n  rw [wbtw_comm] at *\n  exact h\u2081.trans_left h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\n\u22a2 Wbtw R w y z"}, {"line": "rw [wbtw_comm] at *", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Wbtw R z y x\n\u22a2 Wbtw R z y w\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R z y x\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\n\u22a2 IsOrderedRing R"}, {"line": "exact h\u2081.trans_left h\u2082", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R z y x\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module R V\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsOrderedRing R\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\n\u22a2 IsOrderedRing R"}]}
{"declaration": "theorem Wbtw.trans_sbtw_left [NoZeroSMulDivisors R V] {w x y z : P} (h\u2081 : Wbtw R w y z)\n    (h\u2082 : Sbtw R w x y) : Sbtw R w x z := by\n  refine \u27e8h\u2081.trans_left h\u2082.wbtw, h\u2082.ne_left, ?_\u27e9\n  rintro rfl\n  exact h\u2082.right_ne ((wbtw_swap_right_iff R w).1 \u27e8h\u2081, h\u2082.wbtw\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w y z\nh\u2082 : Sbtw R w x y\n\u22a2 Sbtw R w x z"}, {"line": "refine \u27e8h\u2081.trans_left h\u2082.wbtw, h\u2082.ne_left, ?_\u27e9", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w y z\nh\u2082 : Sbtw R w x y\n\u22a2 x \u2260 z"}, {"line": "rintro rfl", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y : P\nh\u2082 : Sbtw R w x y\nh\u2081 : Wbtw R w y x\n\u22a2 False"}, {"line": "exact h\u2082.right_ne ((wbtw_swap_right_iff R w).1 \u27e8h\u2081, h\u2082.wbtw\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Wbtw.trans_sbtw_right [NoZeroSMulDivisors R V] {w x y z : P} (h\u2081 : Wbtw R w x z)\n    (h\u2082 : Sbtw R x y z) : Sbtw R w y z := by\n  rw [wbtw_comm] at *\n  rw [sbtw_comm] at *\n  exact h\u2081.trans_sbtw_left h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Sbtw R x y z\n\u22a2 Sbtw R w y z"}, {"line": "rw [wbtw_comm] at *", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R x y z\n\u22a2 Sbtw R w y z\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R"}, {"line": "rw [sbtw_comm] at *", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R z y x\n\u22a2 Sbtw R z y w\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R"}, {"line": "exact h\u2081.trans_sbtw_left h\u2082", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R z x w\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R\n---\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Sbtw R x y z\n\u22a2 IsOrderedRing R"}]}
{"declaration": "theorem Wbtw.trans_left_ne [NoZeroSMulDivisors R V] {w x y z : P} (h\u2081 : Wbtw R w y z)\n    (h\u2082 : Wbtw R w x y) (h : y \u2260 z) : x \u2260 z := by\n  rintro rfl\n  exact h (h\u2081.swap_right_iff.1 h\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w y z\nh\u2082 : Wbtw R w x y\nh : y \u2260 z\n\u22a2 x \u2260 z"}, {"line": "rintro rfl", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y : P\nh\u2082 : Wbtw R w x y\nh\u2081 : Wbtw R w y x\nh : y \u2260 x\n\u22a2 False"}, {"line": "exact h (h\u2081.swap_right_iff.1 h\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Wbtw.trans_right_ne [NoZeroSMulDivisors R V] {w x y z : P} (h\u2081 : Wbtw R w x z)\n    (h\u2082 : Wbtw R x y z) (h : w \u2260 x) : w \u2260 y := by\n  rintro rfl\n  exact h (h\u2081.swap_left_iff.1 h\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x y z : P\nh\u2081 : Wbtw R w x z\nh\u2082 : Wbtw R x y z\nh : w \u2260 x\n\u22a2 w \u2260 y"}, {"line": "rintro rfl", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : PartialOrder R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : AddTorsor V P\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : IsOrderedRing R\ninst\u271d : NoZeroSMulDivisors R V\nw x z : P\nh\u2081 : Wbtw R w x z\nh : w \u2260 x\nh\u2082 : Wbtw R x w z\n\u22a2 False"}, {"line": "exact h (h\u2081.swap_left_iff.1 h\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem wbtw_midpoint (x y : P) : Wbtw R x (midpoint R x y) y := by\n  convert wbtw_pointReflection R (midpoint R x y) x\n  rw [pointReflection_midpoint_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Between.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R} in", "{R}", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "[IsOrderedRing R]", "{R}", "[IsOrderedRing R]", "(R)", "{R}", "[CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{R}", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R]", "{R}", "[Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{R}", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_4\nx y : P\n\u22a2 sorry"}, {"line": "convert wbtw_pointReflection R (midpoint R x y) x", "tactic_state": "case a\nP : Type u_4\nx y : P\n\u22a2 sorry \u2194 Wbtw sorry x (midpoint sorry x y) ((pointReflection sorry (midpoint sorry x y)) x)\n---\ncase convert_1\nP : Type u_4\nx y : P\n\u22a2 Type ?u.43071\n---\ncase convert_2\nP : Type u_4\nx y : P\n\u22a2 Field sorry\n---\ncase convert_3\nP : Type u_4\nx y : P\n\u22a2 LinearOrder sorry\n---\ncase convert_4\nP : Type u_4\nx y : P\n\u22a2 IsStrictOrderedRing sorry\n---\ncase convert_5\nP : Type u_4\nx y : P\n\u22a2 AddCommGroup ?convert_1\n---\ncase convert_6\nP : Type u_4\nx y : P\n\u22a2 Module sorry ?convert_1\n---\ncase convert_7\nP : Type u_4\nx y : P\n\u22a2 AddTorsor ?convert_1 P\n---\ncase convert_8\nP : Type u_4\nx y : P\n\u22a2 Type ?u.43083\n---\ncase convert_9\nP : Type u_4\nx y : P\n\u22a2 Ring sorry\n---\ncase convert_10\nP : Type u_4\nx y : P\n\u22a2 Invertible 2\n---\ncase convert_11\nP : Type u_4\nx y : P\n\u22a2 AddCommGroup ?convert_8\n---\ncase convert_12\nP : Type u_4\nx y : P\n\u22a2 Module sorry ?convert_8\n---\ncase convert_13\nP : Type u_4\nx y : P\n\u22a2 AddTorsor ?convert_8 P"}, {"line": "rw [pointReflection_midpoint_left]", "tactic_state": "case a\nP : Type u_4\nx y : P\n\u22a2 sorry \u2194 Wbtw sorry x (midpoint sorry x y) y\n---\nP : Type u_4\nx y : P\n\u22a2 Type ?u.59033\n---\ncase convert_2\nP : Type u_4\nx y : P\n\u22a2 Field sorry\n---\nP : Type u_4\nx y : P\n\u22a2 Invertible 2\n---\nP : Type u_4\nx y : P\n\u22a2 AddCommGroup ?m.59036\n---\nP : Type u_4\nx y : P\n\u22a2 Module sorry ?m.59036\n---\nP : Type u_4\nx y : P\n\u22a2 AddTorsor ?m.59036 P\n---\ncase convert_2\nP : Type u_4\nx y : P\n\u22a2 Field sorry\n---\ncase convert_3\nP : Type u_4\nx y : P\n\u22a2 LinearOrder sorry\n---\ncase convert_4\nP : Type u_4\nx y : P\n\u22a2 IsStrictOrderedRing sorry"}]}
{"declaration": "lemma wbtw_four {p\u2081 p\u2082 p\u2083 p\u2084 : P} : [p\u2081, p\u2082, p\u2083, p\u2084].Wbtw R \u2194\n    Wbtw R p\u2081 p\u2082 p\u2083 \u2227 Wbtw R p\u2081 p\u2082 p\u2084 \u2227 Wbtw R p\u2081 p\u2083 p\u2084 \u2227 Wbtw R p\u2082 p\u2083 p\u2084 := by\n  simp [List.Wbtw, triplewise_cons, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/BetweenList.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R}", "(R)", "(P)", "{P}", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 List.Wbtw R [p\u2081, p\u2082, p\u2083, p\u2084] \u2194 Wbtw R p\u2081 p\u2082 p\u2083 \u2227 Wbtw R p\u2081 p\u2082 p\u2084 \u2227 Wbtw R p\u2081 p\u2083 p\u2084 \u2227 Wbtw R p\u2082 p\u2083 p\u2084"}, {"line": "simp [List.Wbtw, triplewise_cons, and_assoc]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : AddCommGroup V\ninst\u271d\u00b9 : Module R V\ninst\u271d : AddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084] \u2194 Wbtw R p\u2081 p\u2082 p\u2083 \u2227 Wbtw R p\u2081 p\u2082 p\u2084 \u2227 Wbtw R p\u2081 p\u2083 p\u2084 \u2227 Wbtw R p\u2082 p\u2083 p\u2084"}]}
{"declaration": "lemma sbtw_four [IsOrderedRing R] {p\u2081 p\u2082 p\u2083 p\u2084 : P} : [p\u2081, p\u2082, p\u2083, p\u2084].Sbtw R \u2194\n    Sbtw R p\u2081 p\u2082 p\u2083 \u2227 Sbtw R p\u2081 p\u2082 p\u2084 \u2227 Sbtw R p\u2081 p\u2083 p\u2084 \u2227 Sbtw R p\u2082 p\u2083 p\u2084 := by\n  simp [List.Sbtw, List.Wbtw, triplewise_cons, Sbtw]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/BetweenList.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R}", "(R)", "(P)", "{P}", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module R V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 List.Sbtw R [p\u2081, p\u2082, p\u2083, p\u2084] \u2194 Sbtw R p\u2081 p\u2082 p\u2083 \u2227 Sbtw R p\u2081 p\u2082 p\u2084 \u2227 Sbtw R p\u2081 p\u2083 p\u2084 \u2227 Sbtw R p\u2082 p\u2083 p\u2084"}, {"line": "simp [List.Sbtw, List.Wbtw, triplewise_cons, Sbtw]", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module R V\ninst\u271d\u00b9 : AddTorsor V P\ninst\u271d : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084] \u2227 (\u00acp\u2081 = p\u2082 \u2227 \u00acp\u2081 = p\u2083 \u2227 \u00acp\u2081 = p\u2084) \u2227 (\u00acp\u2082 = p\u2083 \u2227 \u00acp\u2082 = p\u2084) \u2227 \u00acp\u2083 = p\u2084 \u2194\n    (Wbtw R p\u2081 p\u2082 p\u2083 \u2227 \u00acp\u2082 = p\u2081 \u2227 \u00acp\u2082 = p\u2083) \u2227\n      (Wbtw R p\u2081 p\u2082 p\u2084 \u2227 \u00acp\u2082 = p\u2081 \u2227 \u00acp\u2082 = p\u2084) \u2227\n        (Wbtw R p\u2081 p\u2083 p\u2084 \u2227 \u00acp\u2083 = p\u2081 \u2227 \u00acp\u2083 = p\u2084) \u2227 Wbtw R p\u2082 p\u2083 p\u2084 \u2227 \u00acp\u2083 = p\u2082 \u2227 \u00acp\u2083 = p\u2084"}, {"line": "aesop", "tactic_state": "case mp.left.left\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst : Ring R\ninst_1 : PartialOrder R\ninst_2 : AddCommGroup V\ninst_3 : Module R V\ninst_4 : AddTorsor V P\ninst_5 : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\nleft : List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084]\nleft_1 : \u00acp\u2081 = p\u2082\nright : \u00acp\u2083 = p\u2084\nleft_3 : \u00acp\u2081 = p\u2083\nright_1 : \u00acp\u2081 = p\u2084\nleft_2 : \u00acp\u2082 = p\u2083\nright_2 : \u00acp\u2082 = p\u2084\n\u22a2 Wbtw R p\u2081 p\u2082 p\u2083\n---\ncase mp.right.left.left\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst : Ring R\ninst_1 : PartialOrder R\ninst_2 : AddCommGroup V\ninst_3 : Module R V\ninst_4 : AddTorsor V P\ninst_5 : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\nleft : List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084]\nleft_1 : \u00acp\u2081 = p\u2082\nright : \u00acp\u2083 = p\u2084\nleft_3 : \u00acp\u2081 = p\u2083\nright_1 : \u00acp\u2081 = p\u2084\nleft_2 : \u00acp\u2082 = p\u2083\nright_2 : \u00acp\u2082 = p\u2084\n\u22a2 Wbtw R p\u2081 p\u2082 p\u2084\n---\ncase mp.right.right.left.left\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst : Ring R\ninst_1 : PartialOrder R\ninst_2 : AddCommGroup V\ninst_3 : Module R V\ninst_4 : AddTorsor V P\ninst_5 : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\nleft : List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084]\nleft_1 : \u00acp\u2081 = p\u2082\nright : \u00acp\u2083 = p\u2084\nleft_3 : \u00acp\u2081 = p\u2083\nright_1 : \u00acp\u2081 = p\u2084\nleft_2 : \u00acp\u2082 = p\u2083\nright_2 : \u00acp\u2082 = p\u2084\n\u22a2 Wbtw R p\u2081 p\u2083 p\u2084\n---\ncase mp.right.right.right.left\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst : Ring R\ninst_1 : PartialOrder R\ninst_2 : AddCommGroup V\ninst_3 : Module R V\ninst_4 : AddTorsor V P\ninst_5 : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\nleft : List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084]\nleft_1 : \u00acp\u2081 = p\u2082\nright : \u00acp\u2083 = p\u2084\nleft_3 : \u00acp\u2081 = p\u2083\nright_1 : \u00acp\u2081 = p\u2084\nleft_2 : \u00acp\u2082 = p\u2083\nright_2 : \u00acp\u2082 = p\u2084\n\u22a2 Wbtw R p\u2082 p\u2083 p\u2084\n---\ncase mpr.left\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst : Ring R\ninst_1 : PartialOrder R\ninst_2 : AddCommGroup V\ninst_3 : Module R V\ninst_4 : AddTorsor V P\ninst_5 : IsOrderedRing R\np\u2081 p\u2082 p\u2083 p\u2084 : P\nleft : Wbtw R p\u2081 p\u2082 p\u2083\nright_1 : \u00acp\u2082 = p\u2083\nleft_1 : Wbtw R p\u2081 p\u2082 p\u2084\nleft_4 : \u00acp\u2082 = p\u2081\nright_2 : \u00acp\u2082 = p\u2084\nleft_3 : Wbtw R p\u2081 p\u2083 p\u2084\nleft_5 : Wbtw R p\u2082 p\u2083 p\u2084\nleft_6 : \u00acp\u2083 = p\u2081\nleft_7 : \u00acp\u2083 = p\u2082\nright : \u00acp\u2083 = p\u2084\n\u22a2 List.Triplewise (Wbtw R) [p\u2081, p\u2082, p\u2083, p\u2084]"}]}
{"declaration": "lemma exists_map_eq_of_sorted_iff_wbtw {l : List P} :\n    (\u2203 p\u2081 p\u2082 : P, \u2203 l' : List R, l'.Sorted (\u00b7 \u2264 \u00b7) \u2227 l'.map (lineMap p\u2081 p\u2082) = l) \u2194 l.Wbtw R := by\n  refine \u27e8fun \u27e8p\u2081, p\u2082, l', hl's, hl'l\u27e9 \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 subst hl'l\n    exact Wbtw.map hl's.wbtw _\n  \u00b7 by_cases hl : l = []\n    \u00b7 exact \u27e8AddTorsor.nonempty.some, AddTorsor.nonempty.some, [], by simp [hl]\u27e9\n    \u00b7 exact \u27e8l.head hl, l.getLast hl, (exists_map_eq_of_sorted_nonempty_iff_wbtw hl).2 h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/BetweenList.lean", "context": {"open": ["AffineEquiv AffineMap"], "variables": ["(R : Type*) {V V' P P' : Type*}", "[Ring R] [PartialOrder R] [AddCommGroup V] [Module R V] [AddTorsor V P]", "[AddCommGroup V'] [Module R V'] [AddTorsor V' P']", "{R}", "(R)", "(P)", "{P}", "{R}", "[Field R] [LinearOrder R] [IsStrictOrderedRing R]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Field R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\nl : List P\n\u22a2 (\u2203 p\u2081 p\u2082 l', List.Sorted (fun x1 x2 => x1 \u2264 x2) l' \u2227 List.map (\u21d1(lineMap p\u2081 p\u2082)) l' = l) \u2194 List.Wbtw R l"}, {"line": "refine \u27e8fun \u27e8p\u2081, p\u2082, l', hl's, hl'l\u27e9 \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Field R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\nl : List P\nx\u271d : \u2203 p\u2081 p\u2082 l', List.Sorted (fun x1 x2 => x1 \u2264 x2) l' \u2227 List.map (\u21d1(lineMap p\u2081 p\u2082)) l' = l\np\u2081 p\u2082 : P\nl' : List R\nhl's : List.Sorted (fun x1 x2 => x1 \u2264 x2) l'\nhl'l : List.map (\u21d1(lineMap p\u2081 p\u2082)) l' = l\n\u22a2 List.Wbtw R l\n---\ncase refine_2\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Field R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\nl : List P\nh : List.Wbtw R l\n\u22a2 \u2203 p\u2081 p\u2082 l', List.Sorted (fun x1 x2 => x1 \u2264 x2) l' \u2227 List.map (\u21d1(lineMap p\u2081 p\u2082)) l' = l"}, {"line": "\u00b7 subst hl'l\n    exact Wbtw.map hl's.wbtw _", "tactic_state": "case refine_2\nR : Type u_1\nV : Type u_2\nP : Type u_4\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : AddCommGroup V\ninst\u271d\u2074 : Module R V\ninst\u271d\u00b3 : AddTorsor V P\ninst\u271d\u00b2 : Field R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : IsStrictOrderedRing R\nl : List P\nh : List.Wbtw R l\n\u22a2 \u2203 p\u2081 p\u2082 l', List.Sorted (fun x1 x2 => x1 \u2264 x2) l' \u2227 List.map (\u21d1(lineMap p\u2081 p\u2082)) l' = l"}, {"line": "\u00b7 by_cases hl : l = []\n    \u00b7 exact \u27e8AddTorsor.nonempty.some, AddTorsor.nonempty.some, [], by simp [hl]\u27e9\n    \u00b7 exact \u27e8l.head hl, l.getLast hl, (exists_map_eq_of_sorted_nonempty_iff_wbtw hl).2 h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_gaugeRescale_le (s t : Set E) (x : E) :\n    gauge t (gaugeRescale s t x) \u2264 gauge s x := by\n  by_cases hx : gauge t x = 0\n  \u00b7 simp [gaugeRescale, hx, gauge_nonneg]\n  \u00b7 exact (gauge_gaugeRescale' s hx).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/GaugeRescale.lean", "context": {"open": ["Metric Bornology Filter Set", "scoped NNReal Topology Pointwise"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns t : Set E\nx : E\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x"}, {"line": "by_cases hx : gauge t x = 0", "tactic_state": "case pos\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns t : Set E\nx : E\nhx : sorry = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns t : Set E\nx : E\nhx : \u00acsorry = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x"}, {"line": "\u00b7 simp [gaugeRescale, hx, gauge_nonneg]", "tactic_state": "case neg\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns t : Set E\nx : E\nhx : \u00acsorry = 0\n\u22a2 gauge t (gaugeRescale s t x) \u2264 gauge s x"}, {"line": "\u00b7 exact (gauge_gaugeRescale' s hx).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_gaugeRescale (s : Set E) {t : Set E} (hta : Absorbent \u211d t) (htb : IsVonNBounded \u211d t)\n    (x : E) : gauge t (gaugeRescale s t x) = gauge s x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  \u00b7 simp\n  \u00b7 exact gauge_gaugeRescale' s ((gauge_pos hta htb).2 hx).ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/GaugeRescale.lean", "context": {"open": ["Metric Bornology Filter Set", "scoped NNReal Topology Pointwise"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "[TopologicalSpace E]", "[T1Space E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nhta : Absorbent \u211d t\nhtb : IsVonNBounded \u211d t\nx : E\n\u22a2 gauge t (gaugeRescale s t x) = gauge s x"}, {"line": "rcases eq_or_ne x 0 with rfl | hx", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nhta : Absorbent \u211d t\nhtb : IsVonNBounded \u211d t\n\u22a2 gauge t (gaugeRescale s t sorry) = gauge s sorry\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nhta : Absorbent \u211d t\nhtb : IsVonNBounded \u211d t\nx : E\nhx : x \u2260 sorry\n\u22a2 gauge t (gaugeRescale s t x) = gauge s x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nE : Type u_1\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : T1Space E\ns t : Set E\nhta : Absorbent \u211d t\nhtb : IsVonNBounded \u211d t\nx : E\nhx : x \u2260 sorry\n\u22a2 gauge t (gaugeRescale s t x) = gauge s x"}, {"line": "\u00b7 exact gauge_gaugeRescale' s ((gauge_pos hta htb).2 hx).ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_gaugeRescaleHomeomorph_closure {s t : Set E}\n    (hsc : Convex \u211d s) (hs\u2080 : s \u2208 \ud835\udcdd 0) (hsb : IsVonNBounded \u211d s)\n    (htc : Convex \u211d t) (ht\u2080 : t \u2208 \ud835\udcdd 0) (htb : IsVonNBounded \u211d t) :\n    gaugeRescaleHomeomorph s t hsc hs\u2080 hsb htc ht\u2080 htb '' closure s = closure t := by\n  refine Subset.antisymm (mapsTo_gaugeRescale_closure hsc hs\u2080 htc\n    (mem_of_mem_nhds ht\u2080) (absorbent_nhds_zero ht\u2080)).image_subset ?_\n  rw [\u2190 Homeomorph.preimage_symm]\n  rw [\u2190 image_subset_iff]\n  exact (mapsTo_gaugeRescale_closure htc ht\u2080 hsc\n    (mem_of_mem_nhds hs\u2080) (absorbent_nhds_zero hs\u2080)).image_subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/GaugeRescale.lean", "context": {"open": ["Metric Bornology Filter Set", "scoped NNReal Topology Pointwise"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "[TopologicalSpace E]", "[T1Space E]", "[IsTopologicalAddGroup E] [ContinuousSMul \u211d E] {s t : Set E}", "[T1Space E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \u211d E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : T1Space E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : ContinuousSMul \u211d E\ninst\u271d : T1Space E\ns t : Set E\nhsc : Convex \u211d s\nhs\u2080 : s \u2208 nhds 0\nhsb : IsVonNBounded \u211d s\nhtc : Convex \u211d t\nht\u2080 : t \u2208 nhds 0\nhtb : IsVonNBounded \u211d t\n\u22a2 \u21d1(gaugeRescaleHomeomorph s t hsc hs\u2080 hsb htc ht\u2080 htb) '' closure s = closure t"}, {"line": "refine Subset.antisymm (mapsTo_gaugeRescale_closure hsc hs\u2080 htc\n    (mem_of_mem_nhds ht\u2080) (absorbent_nhds_zero ht\u2080)).image_subset ?_", "tactic_state": "E : Type u_1\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \u211d E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : T1Space E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : ContinuousSMul \u211d E\ninst\u271d : T1Space E\ns t : Set E\nhsc : Convex \u211d s\nhs\u2080 : s \u2208 nhds 0\nhsb : IsVonNBounded \u211d s\nhtc : Convex \u211d t\nht\u2080 : t \u2208 nhds 0\nhtb : IsVonNBounded \u211d t\n\u22a2 closure t \u2286 \u21d1(gaugeRescaleHomeomorph s t hsc hs\u2080 hsb htc ht\u2080 htb) '' closure s"}, {"line": "rw [\u2190 Homeomorph.preimage_symm]", "tactic_state": "E : Type u_1\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \u211d E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : T1Space E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : ContinuousSMul \u211d E\ninst\u271d : T1Space E\ns t : Set E\nhsc : Convex \u211d s\nhs\u2080 : s \u2208 nhds 0\nhsb : IsVonNBounded \u211d s\nhtc : Convex \u211d t\nht\u2080 : t \u2208 nhds 0\nhtb : IsVonNBounded \u211d t\n\u22a2 closure t \u2286 \u21d1(gaugeRescaleHomeomorph s t hsc hs\u2080 hsb htc ht\u2080 htb).symm \u207b\u00b9' closure s"}, {"line": "rw [\u2190 image_subset_iff]", "tactic_state": "E : Type u_1\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \u211d E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : T1Space E\ninst\u271d\u00b2 : IsTopologicalAddGroup E\ninst\u271d\u00b9 : ContinuousSMul \u211d E\ninst\u271d : T1Space E\ns t : Set E\nhsc : Convex \u211d s\nhs\u2080 : s \u2208 nhds 0\nhsb : IsVonNBounded \u211d s\nhtc : Convex \u211d t\nht\u2080 : t \u2208 nhds 0\nhtb : IsVonNBounded \u211d t\n\u22a2 \u21d1(gaugeRescaleHomeomorph s t hsc hs\u2080 hsb htc ht\u2080 htb).symm '' closure t \u2286 closure s"}, {"line": "exact (mapsTo_gaugeRescale_closure htc ht\u2080 hsc\n    (mem_of_mem_nhds hs\u2080) (absorbent_nhds_zero hs\u2080)).image_subset", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_homeomorph_image_interior_closure_frontier_eq_unitBall {s : Set E}\n    (hc : Convex \u211d s) (hne : (interior s).Nonempty) (hb : IsBounded s) :\n    \u2203 h : E \u2243\u209c E, h '' interior s = ball 0 1 \u2227 h '' closure s = closedBall 0 1 \u2227\n      h '' frontier s = sphere 0 1 := by\n  simpa [isOpen_ball.interior_eq, closure_ball, frontier_ball]\n    using exists_homeomorph_image_eq hc hne (NormedSpace.isVonNBounded_of_isBounded _ hb)\n    (convex_ball 0 1) (by simp [isOpen_ball.interior_eq]) (NormedSpace.isVonNBounded_ball _ _ _)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/GaugeRescale.lean", "context": {"open": ["Metric Bornology Filter Set", "scoped NNReal Topology Pointwise"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "[TopologicalSpace E]", "[T1Space E]", "[IsTopologicalAddGroup E] [ContinuousSMul \u211d E] {s t : Set E}", "[T1Space E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nhc : Convex \u211d s\nhne : (interior s).Nonempty\nhb : Bornology.IsBounded s\n\u22a2 \u2203 h, \u21d1h '' interior s = ball 0 1 \u2227 \u21d1h '' closure s = closedBall 0 1 \u2227 \u21d1h '' frontier s = sphere 0 1"}, {"line": "simpa [isOpen_ball.interior_eq, closure_ball, frontier_ball]\n    using exists_homeomorph_image_eq hc hne (NormedSpace.isVonNBounded_of_isBounded _ hb)\n    (convex_ball 0 1) (by simp [isOpen_ball.interior_eq]) (NormedSpace.isVonNBounded_ball _ _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicInterior_empty : intrinsicInterior \ud835\udd5c (\u2205 : Set P) = \u2205 := by simp [intrinsicInterior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\n\u22a2 intrinsicInterior \ud835\udd5c \u2205 = \u2205"}, {"line": "simp [intrinsicInterior]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicFrontier_empty : intrinsicFrontier \ud835\udd5c (\u2205 : Set P) = \u2205 := by simp [intrinsicFrontier]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\n\u22a2 intrinsicFrontier \ud835\udd5c \u2205 = \u2205"}, {"line": "simp [intrinsicFrontier]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicClosure_empty : intrinsicClosure \ud835\udd5c (\u2205 : Set P) = \u2205 := by simp [intrinsicClosure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\n\u22a2 intrinsicClosure \ud835\udd5c \u2205 = \u2205"}, {"line": "simp [intrinsicClosure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicInterior_singleton (x : P) : intrinsicInterior \ud835\udd5c ({x} : Set P) = {x} := by\n  simp only [intrinsicInterior]\n  simp only [preimage_coe_affineSpan_singleton]\n  simp only [interior_univ]\n  simp only [image_univ]\n  simp only [Subtype.range_coe_subtype]\n  simp only [mem_affineSpan_singleton]\n  simp only [setOf_eq_eq_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 intrinsicInterior \ud835\udd5c {x} = {x}"}, {"line": "simp only [intrinsicInterior]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' interior (Subtype.val \u207b\u00b9' {x}) = {x}"}, {"line": "simp only [preimage_coe_affineSpan_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' interior univ = {x}"}, {"line": "simp only [interior_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' univ = {x}"}, {"line": "simp only [image_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 range Subtype.val = {x}"}, {"line": "simp only [Subtype.range_coe_subtype]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 {x_1 | x_1 \u2208 affineSpan \ud835\udd5c {x}} = {x}"}, {"line": "simp only [mem_affineSpan_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 {x_1 | x_1 = x} = {x}"}, {"line": "simp only [setOf_eq_eq_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicFrontier_singleton (x : P) : intrinsicFrontier \ud835\udd5c ({x} : Set P) = \u2205 := by\n  rw [intrinsicFrontier]\n  rw [preimage_coe_affineSpan_singleton]\n  rw [frontier_univ]\n  rw [image_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 intrinsicFrontier \ud835\udd5c {x} = \u2205"}, {"line": "rw [intrinsicFrontier]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' frontier (Subtype.val \u207b\u00b9' {x}) = \u2205"}, {"line": "rw [preimage_coe_affineSpan_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' frontier univ = \u2205"}, {"line": "rw [frontier_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' \u2205 = \u2205"}, {"line": "rw [image_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicClosure_singleton (x : P) : intrinsicClosure \ud835\udd5c ({x} : Set P) = {x} := by\n  simp only [intrinsicClosure]\n  simp only [preimage_coe_affineSpan_singleton]\n  simp only [closure_univ]\n  simp only [image_univ]\n  simp only [Subtype.range_coe_subtype]\n  simp only [mem_affineSpan_singleton]\n  simp only [setOf_eq_eq_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 intrinsicClosure \ud835\udd5c {x} = {x}"}, {"line": "simp only [intrinsicClosure]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' closure (Subtype.val \u207b\u00b9' {x}) = {x}"}, {"line": "simp only [preimage_coe_affineSpan_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' closure univ = {x}"}, {"line": "simp only [closure_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 Subtype.val '' univ = {x}"}, {"line": "simp only [image_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 range Subtype.val = {x}"}, {"line": "simp only [Subtype.range_coe_subtype]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 {x_1 | x_1 \u2208 affineSpan \ud835\udd5c {x}} = {x}"}, {"line": "simp only [mem_affineSpan_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\nx : P\n\u22a2 {x_1 | x_1 = x} = {x}"}, {"line": "simp only [setOf_eq_eq_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicInterior_union_intrinsicFrontier (s : Set P) :\n    intrinsicInterior \ud835\udd5c s \u222a intrinsicFrontier \ud835\udd5c s = intrinsicClosure \ud835\udd5c s := by\n  simp [intrinsicClosure, intrinsicInterior, intrinsicFrontier, closure_eq_interior_union_frontier,\n    image_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\ns : Set P\n\u22a2 intrinsicInterior \ud835\udd5c s \u222a intrinsicFrontier \ud835\udd5c s = intrinsicClosure \ud835\udd5c s"}, {"line": "simp [intrinsicClosure, intrinsicInterior, intrinsicFrontier, closure_eq_interior_union_frontier,\n    image_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intrinsicFrontier_union_intrinsicInterior (s : Set P) :\n    intrinsicFrontier \ud835\udd5c s \u222a intrinsicInterior \ud835\udd5c s = intrinsicClosure \ud835\udd5c s := by\n  rw [union_comm]\n  rw [intrinsicInterior_union_intrinsicFrontier]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Intrinsic.lean", "context": {"open": ["AffineSubspace Set Topology", "scoped Pointwise"], "variables": ["{\ud835\udd5c V W Q P : Type*}", "(\ud835\udd5c) [Ring \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V] [TopologicalSpace P] [AddTorsor V P]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\ns : Set P\n\u22a2 intrinsicFrontier \ud835\udd5c s \u222a intrinsicInterior \ud835\udd5c s = intrinsicClosure \ud835\udd5c s"}, {"line": "rw [union_comm]", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\nP : Type u_5\ninst\u271d\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \ud835\udd5c V\ninst\u271d\u00b9 : TopologicalSpace P\ninst\u271d : AddTorsor V P\ns : Set P\n\u22a2 intrinsicInterior \ud835\udd5c s \u222a intrinsicFrontier \ud835\udd5c s = intrinsicClosure \ud835\udd5c s"}, {"line": "rw [intrinsicInterior_union_intrinsicFrontier]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_empty_left (t : Set E) : convexJoin \ud835\udd5c \u2205 t = \u2205 := by simp [convexJoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nt : Set E\n\u22a2 convexJoin \ud835\udd5c \u2205 t = \u2205"}, {"line": "simp [convexJoin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_empty_right (s : Set E) : convexJoin \ud835\udd5c s \u2205 = \u2205 := by simp [convexJoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 convexJoin \ud835\udd5c s \u2205 = \u2205"}, {"line": "simp [convexJoin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_singleton_left (t : Set E) (x : E) :\n    convexJoin \ud835\udd5c {x} t = \u22c3 y \u2208 t, segment \ud835\udd5c x y := by simp [convexJoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nt : Set E\nx : E\n\u22a2 convexJoin \ud835\udd5c {x} t = \u22c3 y \u2208 t, segment \ud835\udd5c x y"}, {"line": "simp [convexJoin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_singleton_right (s : Set E) (y : E) :\n    convexJoin \ud835\udd5c s {y} = \u22c3 x \u2208 s, segment \ud835\udd5c x y := by simp [convexJoin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\ny : E\n\u22a2 convexJoin \ud835\udd5c s {y} = \u22c3 x \u2208 s, segment \ud835\udd5c x y"}, {"line": "simp [convexJoin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_singletons (x : E) : convexJoin \ud835\udd5c {x} {y} = segment \ud835\udd5c x y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ny x : E\n\u22a2 convexJoin \ud835\udd5c {x} {y} = segment \ud835\udd5c x y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_union_left (s\u2081 s\u2082 t : Set E) :\n    convexJoin \ud835\udd5c (s\u2081 \u222a s\u2082) t = convexJoin \ud835\udd5c s\u2081 t \u222a convexJoin \ud835\udd5c s\u2082 t := by\n  simp_rw [convexJoin, mem_union, iUnion_or, iUnion_union_distrib]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns\u2081 s\u2082 t : Set E\n\u22a2 convexJoin \ud835\udd5c (s\u2081 \u222a s\u2082) t = convexJoin \ud835\udd5c s\u2081 t \u222a convexJoin \ud835\udd5c s\u2082 t"}, {"line": "simp_rw [convexJoin, mem_union, iUnion_or, iUnion_union_distrib]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexJoin_iUnion_left (s : \u03b9 \u2192 Set E) (t : Set E) :\n    convexJoin \ud835\udd5c (\u22c3 i, s i) t = \u22c3 i, convexJoin \ud835\udd5c (s i) t := by\n  simp_rw [convexJoin, mem_iUnion, iUnion_exists]\n  exact iUnion_comm _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Join.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\ud835\udd5c E : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : \u03b9 \u2192 Set E\nt : Set E\n\u22a2 convexJoin \ud835\udd5c (\u22c3 i, s i) t = \u22c3 i, convexJoin \ud835\udd5c (s i) t"}, {"line": "simp_rw [convexJoin, mem_iUnion, iUnion_exists]", "tactic_state": "\u03b9 : Sort u_1\n\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : \u03b9 \u2192 Set E\nt : Set E\n\u22a2 \u22c3 x, \u22c3 i, \u22c3 (_ : x \u2208 s i), \u22c3 y \u2208 t, segment \ud835\udd5c x y = \u22c3 i, \u22c3 x \u2208 s i, \u22c3 y \u2208 t, segment \ud835\udd5c x y"}, {"line": "exact iUnion_comm _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConvexOn.convexOn (hf : UniformConvexOn s \u03c6 f) (h\u03c6 : 0 \u2264 \u03c6) : ConvexOn \u211d s f := by\n  simpa using hf.mono h\u03c6\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nh\u03c6 : 0 \u2264 \u03c6\n\u22a2 ConvexOn \u211d s f"}, {"line": "simpa using hf.mono h\u03c6", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConcaveOn.concaveOn (hf : UniformConcaveOn s \u03c6 f) (h\u03c6 : 0 \u2264 \u03c6) : ConcaveOn \u211d s f := by\n  simpa using hf.mono h\u03c6\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\nh\u03c6 : 0 \u2264 \u03c6\n\u22a2 ConcaveOn \u211d s f"}, {"line": "simpa using hf.mono h\u03c6", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConvexOn.add (hf : UniformConvexOn s \u03c6 f) (hg : UniformConvexOn s \u03c8 g) :\n    UniformConvexOn s (\u03c6 + \u03c8) (f + g) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9\n  simpa [mul_add, add_add_add_comm, sub_add_sub_comm]\n    using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 \u03c8 : \u211d \u2192 \u211d\ns : Set E\nf g : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nhg : UniformConvexOn s \u03c8 g\n\u22a2 UniformConvexOn s (\u03c6 + \u03c8) (f + g)"}, {"line": "refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 \u03c8 : \u211d \u2192 \u211d\ns : Set E\nf g : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nhg : UniformConvexOn s \u03c8 g\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 (f + g) (a \u2022 x + b \u2022 y) \u2264 a \u2022 (f + g) x + b \u2022 (f + g) y - a * b * (\u03c6 + \u03c8) \u2016x - y\u2016"}, {"line": "simpa [mul_add, add_add_add_comm, sub_add_sub_comm]\n    using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConcaveOn.add (hf : UniformConcaveOn s \u03c6 f) (hg : UniformConcaveOn s \u03c8 g) :\n    UniformConcaveOn s (\u03c6 + \u03c8) (f + g) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9\n  simpa [mul_add, add_add_add_comm] using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 \u03c8 : \u211d \u2192 \u211d\ns : Set E\nf g : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\nhg : UniformConcaveOn s \u03c8 g\n\u22a2 UniformConcaveOn s (\u03c6 + \u03c8) (f + g)"}, {"line": "refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 ?_\u27e9", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 \u03c8 : \u211d \u2192 \u211d\ns : Set E\nf g : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\nhg : UniformConcaveOn s \u03c8 g\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 (f + g) x + b \u2022 (f + g) y + a * b * (\u03c6 + \u03c8) \u2016x - y\u2016 \u2264 (f + g) (a \u2022 x + b \u2022 y)"}, {"line": "simpa [mul_add, add_add_add_comm] using add_le_add (hf.2 hx hy ha hb hab) (hg.2 hx hy ha hb hab)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConvexOn.neg (hf : UniformConvexOn s \u03c6 f) : UniformConcaveOn s \u03c6 (-f) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9\n  simpa [add_comm, -neg_le_neg_iff, le_sub_iff_add_le'] using hf.2 hx hy ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\n\u22a2 UniformConcaveOn s \u03c6 (-f)"}, {"line": "refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 -(-f) (a \u2022 x + b \u2022 y) \u2264 -(a \u2022 (-f) x + b \u2022 (-f) y + a * b * \u03c6 \u2016x - y\u2016)"}, {"line": "simpa [add_comm, -neg_le_neg_iff, le_sub_iff_add_le'] using hf.2 hx hy ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConcaveOn.neg (hf : UniformConcaveOn s \u03c6 f) : UniformConvexOn s \u03c6 (-f) := by\n  refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9\n  simpa [add_comm, -neg_le_neg_iff, \u2190 le_sub_iff_add_le', sub_eq_add_neg, neg_add]\n    using hf.2 hx hy ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\n\u22a2 UniformConvexOn s \u03c6 (-f)"}, {"line": "refine \u27e8hf.1, fun x hx y hy a b ha hb hab \u21a6 le_of_neg_le_neg ?_\u27e9", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 : \u211d \u2192 \u211d\ns : Set E\nf : E \u2192 \u211d\nhf : UniformConcaveOn s \u03c6 f\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\na b : \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 -(a \u2022 (-f) x + b \u2022 (-f) y - a * b * \u03c6 \u2016x - y\u2016) \u2264 -(-f) (a \u2022 x + b \u2022 y)"}, {"line": "simpa [add_comm, -neg_le_neg_iff, \u2190 le_sub_iff_add_le', sub_eq_add_neg, neg_add]\n    using hf.2 hx hy ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma UniformConvexOn.sub (hf : UniformConvexOn s \u03c6 f) (hg : UniformConcaveOn s \u03c8 g) :\n    UniformConvexOn s (\u03c6 + \u03c8) (f - g) := by simpa using hf.add hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03c6 \u03c8 : \u211d \u2192 \u211d\ns : Set E\nf g : E \u2192 \u211d\nhf : UniformConvexOn s \u03c6 f\nhg : UniformConcaveOn s \u03c8 g\n\u22a2 UniformConvexOn s (\u03c6 + \u03c8) (f - g)"}, {"line": "simpa using hf.add hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma aux_add (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) :\n    a * (f x + m / (2 : \u211d) * \u2016x\u2016 ^ 2) + b * (f y + m / (2 : \u211d) * \u2016y\u2016 ^ 2) -\n      m / (2 : \u211d) * \u2016a \u2022 x + b \u2022 y\u2016 ^ 2\n      = a * f x + b * f y + m / (2 : \u211d) * a * b * \u2016x - y\u2016 ^ 2 := by\n  simpa [neg_div] using aux_sub (E := E) (m := -m) ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strong.lean", "context": {"open": ["Real"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {\u03c6 \u03c8 : \u211d \u2192 \u211d} {s : Set E} {m : \u211d} {f g : E \u2192 \u211d}", "{s : Set E} {f : E \u2192 \u211d} {m n : \u211d}", "[InnerProductSpace \u211d E] {s : Set E} {a b m : \u211d} {x y : E} {f : E \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : InnerProductSpace \u211d E\na b m : \u211d\nx y : E\nf : E \u2192 \u211d\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a * (f x + m / 2 * \u2016x\u2016 ^ 2) + b * (f y + m / 2 * \u2016y\u2016 ^ 2) - m / 2 * \u2016a \u2022 x + b \u2022 y\u2016 ^ 2 =\n    a * f x + b * f y + m / 2 * a * b * \u2016x - y\u2016 ^ 2"}, {"line": "simpa [neg_div] using aux_sub (E := E) (m := -m) ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Directed.convex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n    (hc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)) : Convex \ud835\udd5c (\u22c3 i, s i) := by\n  rintro x hx y hy a b ha hb hab\n  rw [mem_iUnion] at hx hy \u22a2\n  obtain \u27e8i, hx\u27e9 := hx\n  obtain \u27e8j, hy\u27e9 := hy\n  obtain \u27e8k, hik, hjk\u27e9 := hdir i j\n  exact \u27e8k, hc (hik hx) (hjk hy) ha hb hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\n\u22a2 Convex \ud835\udd5c (\u22c3 i, s i)"}, {"line": "rintro x hx y hy a b ha hb hab", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\nx : E\nhx : x \u2208 \u22c3 i, s i\ny : E\nhy : y \u2208 \u22c3 i, s i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 \u22c3 i, s i"}, {"line": "rw [mem_iUnion] at hx hy \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\nx : E\nhx : \u2203 i, x \u2208 s i\ny : E\nhy : \u2203 i, y \u2208 s i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "obtain \u27e8i, hx\u27e9 := hx", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\nx y : E\nhy : \u2203 i, y \u2208 s i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "obtain \u27e8j, hy\u27e9 := hy", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\nx y : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "obtain \u27e8k, hik, hjk\u27e9 := hdir i j", "tactic_state": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)\nx y : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\nk : \u03b9\nhik : s i \u2286 s k\nhjk : s j \u2286 s k\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "exact \u27e8k, hc (hik hx) (hjk hy) ha hb hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectedOn.convex_sUnion {c : Set (Set E)} (hdir : DirectedOn (\u00b7 \u2286 \u00b7) c)\n    (hc : \u2200 \u2983A : Set E\u2984, A \u2208 c \u2192 Convex \ud835\udd5c A) : Convex \ud835\udd5c (\u22c3\u2080 c) := by\n  rw [sUnion_eq_iUnion]\n  exact (directedOn_iff_directed.1 hdir).convex_iUnion fun A => hc A.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nc : Set (Set E)\nhdir : DirectedOn (fun x1 x2 => x1 \u2286 x2) c\nhc : \u2200 \u2983A : Set E\u2984, A \u2208 c \u2192 Convex \ud835\udd5c A\n\u22a2 Convex \ud835\udd5c (\u22c3\u2080 c)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nc : Set (Set E)\nhdir : DirectedOn (fun x1 x2 => x1 \u2286 x2) c\nhc : \u2200 \u2983A : Set E\u2984, A \u2208 c \u2192 Convex \ud835\udd5c A\n\u22a2 Convex \ud835\udd5c (\u22c3 i, \u2191i)"}, {"line": "exact (directedOn_iff_directed.1 hdir).convex_iUnion fun A => hc A.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Convex.linear_image (hs : Convex \ud835\udd5c s) (f : E \u2192\u2097[\ud835\udd5c] F) : Convex \ud835\udd5c (f '' s) := by\n  rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9 a b ha hb hab\n  exact \u27e8a \u2022 x + b \u2022 y, hs hx hy ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : Semiring \ud835\udd5c\ninst\u271d\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : AddCommMonoid F\ninst\u271d\u00b3 : SMul \ud835\udd5c E\ninst\u271d\u00b2 : SMul \ud835\udd5c F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\ns : Set E\nhs : Convex \ud835\udd5c s\nf : E \u2192\u2097[\ud835\udd5c] F\n\u22a2 Convex \ud835\udd5c (\u21d1f '' s)"}, {"line": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9 a b ha hb hab", "tactic_state": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : Semiring \ud835\udd5c\ninst\u271d\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : AddCommMonoid F\ninst\u271d\u00b3 : SMul \ud835\udd5c E\ninst\u271d\u00b2 : SMul \ud835\udd5c F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\ns : Set E\nhs : Convex \ud835\udd5c s\nf : E \u2192\u2097[\ud835\udd5c] F\nx : E\nhx : x \u2208 s\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 f x + b \u2022 f y \u2208 \u21d1f '' s"}, {"line": "exact \u27e8a \u2022 x + b \u2022 y, hs hx hy ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Convex.add {t : Set E} (hs : Convex \ud835\udd5c s) (ht : Convex \ud835\udd5c t) : Convex \ud835\udd5c (s + t) := by\n  rw [\u2190 add_image_prod]\n  exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\ns t : Set E\nhs : Convex \ud835\udd5c s\nht : Convex \ud835\udd5c t\n\u22a2 Convex \ud835\udd5c (s + t)"}, {"line": "rw [\u2190 add_image_prod]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\ns t : Set E\nhs : Convex \ud835\udd5c s\nht : Convex \ud835\udd5c t\n\u22a2 Convex \ud835\udd5c ((fun x => x.1 + x.2) '' s \u00d7\u02e2 t)"}, {"line": "exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stdSimplex_eq_inter : stdSimplex \ud835\udd5c \u03b9 = (\u22c2 x, { f | 0 \u2264 f x }) \u2229 { f | \u2211 x, f x = 1 } := by\n  ext f\n  simp only [stdSimplex]\n  simp only [Set.mem_inter_iff]\n  simp only [Set.mem_iInter]\n  simp only [Set.mem_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E} {x : E}", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedCancelAddMonoid \u03b2]", "[AddCommMonoid \u03b2] [LinearOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E]", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Ring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s t : Set E}", "[AddRightMono \ud835\udd5c]", "[Semiring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c] [AddCommMonoid E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "(\ud835\udd5c) (\u03b9 : Type*) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\n\u22a2 stdSimplex \ud835\udd5c \u03b9 = (\u22c2 x, {f | 0 \u2264 f x}) \u2229 {f | \u2211 x, f x = 1}"}, {"line": "ext f", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 f \u2208 stdSimplex \ud835\udd5c \u03b9 \u2194 f \u2208 (\u22c2 x, {f | 0 \u2264 f x}) \u2229 {f | \u2211 x, f x = 1}"}, {"line": "simp only [stdSimplex]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 f \u2208 {f | (\u2200 (x : \u03b9), 0 \u2264 f x) \u2227 \u2211 x, f x = 1} \u2194 f \u2208 (\u22c2 x, {f | 0 \u2264 f x}) \u2229 {f | \u2211 x, f x = 1}"}, {"line": "simp only [Set.mem_inter_iff]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 f \u2208 {f | (\u2200 (x : \u03b9), 0 \u2264 f x) \u2227 \u2211 x, f x = 1} \u2194 f \u2208 \u22c2 x, {f | 0 \u2264 f x} \u2227 f \u2208 {f | \u2211 x, f x = 1}"}, {"line": "simp only [Set.mem_iInter]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 f \u2208 {f | (\u2200 (x : \u03b9), 0 \u2264 f x) \u2227 \u2211 x, f x = 1} \u2194 (\u2200 (i : \u03b9), f \u2208 {f | 0 \u2264 f i}) \u2227 f \u2208 {f | \u2211 x, f x = 1}"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u2070 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2077 : Field \ud835\udd5c\ninst\u271d\u2076 : LinearOrder \ud835\udd5c\ninst\u271d\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 (\u2200 (x : \u03b9), 0 \u2264 f x) \u2227 \u2211 x, f x = 1 \u2194 (\u2200 (i : \u03b9), 0 \u2264 f i) \u2227 \u2211 x, f x = 1"}]}
{"declaration": "theorem ite_eq_mem_stdSimplex (i : \u03b9) : (if i = \u00b7 then (1 : \ud835\udd5c) else 0) \u2208 stdSimplex \ud835\udd5c \u03b9 := by\n  simpa only [@eq_comm _ i,\u2190 Pi.single_apply] using single_mem_stdSimplex \ud835\udd5c i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E} {x : E}", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedCancelAddMonoid \u03b2]", "[AddCommMonoid \u03b2] [LinearOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E]", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Ring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s t : Set E}", "[AddRightMono \ud835\udd5c]", "[Semiring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c] [AddCommMonoid E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "(\ud835\udd5c) (\u03b9 : Type*) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [Fintype \u03b9]", "{\u03b9} [DecidableEq \u03b9] [ZeroLEOneClass \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2070 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2078 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2075 : Ring \ud835\udd5c\ninst\u271d\u00b9\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2070 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2079 : Field \ud835\udd5c\ninst\u271d\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\n\u03b9 : Type u_5\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : ZeroLEOneClass \ud835\udd5c\ni : \u03b9\n\u22a2 (fun x => if i = x then 1 else 0) \u2208 stdSimplex \ud835\udd5c \u03b9"}, {"line": "simpa only [@eq_comm _ i,\u2190 Pi.single_apply] using single_mem_stdSimplex \ud835\udd5c i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma stdSimplex_fin_two :\n    stdSimplex \ud835\udd5c (Fin 2) = ([Pi.single 0 1 -[\ud835\udd5c] Pi.single 1 1] : Set (Fin 2 \u2192 \ud835\udd5c)) := by\n  refine Subset.antisymm ?_ (segment_single_subset_stdSimplex \ud835\udd5c (0 : Fin 2) 1)\n  rintro f \u27e8hf\u2080, hf\u2081\u27e9\n  rw [Fin.sum_univ_two] at hf\u2081\n  refine \u27e8f 0, f 1, hf\u2080 0, hf\u2080 1, hf\u2081, funext <| Fin.forall_fin_two.2 ?_\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Basic.lean", "context": {"open": ["LinearMap Set", "scoped Convex Pointwise"], "variables": ["{\ud835\udd5c E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E) {x : E}", "{\ud835\udd5c s}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E} {x : E}", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedCancelAddMonoid \u03b2]", "[AddCommMonoid \u03b2] [LinearOrder \u03b2] [IsOrderedAddMonoid \u03b2] [Module \ud835\udd5c \u03b2] [OrderedSMul \ud835\udd5c \u03b2]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E]", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[CommSemiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Ring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s t : Set E}", "[AddRightMono \ud835\udd5c]", "[Semiring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c] [AddCommMonoid E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E]", "(\ud835\udd5c) (\u03b9 : Type*) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [Fintype \u03b9]", "{\u03b9} [DecidableEq \u03b9] [ZeroLEOneClass \ud835\udd5c]", "[IsOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\n\u22a2 stdSimplex \ud835\udd5c (Fin 2) = segment \ud835\udd5c (Pi.single 0 1) (Pi.single 1 1)"}, {"line": "refine Subset.antisymm ?_ (segment_single_subset_stdSimplex \ud835\udd5c (0 : Fin 2) 1)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\n\u22a2 stdSimplex \ud835\udd5c (Fin 2) \u2286 segment \ud835\udd5c (Pi.single 0 1) (Pi.single 1 1)"}, {"line": "rintro f \u27e8hf\u2080, hf\u2081\u27e9", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\nf : Fin 2 \u2192 \ud835\udd5c\nhf\u2080 : \u2200 (x : Fin 2), 0 \u2264 f x\nhf\u2081 : \u2211 x, f x = 1\n\u22a2 f \u2208 segment \ud835\udd5c (Pi.single 0 1) (Pi.single 1 1)"}, {"line": "rw [Fin.sum_univ_two] at hf\u2081", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\nf : Fin 2 \u2192 \ud835\udd5c\nhf\u2080 : \u2200 (x : Fin 2), 0 \u2264 f x\nhf\u2081 : f 0 + f 1 = 1\n\u22a2 f \u2208 segment \ud835\udd5c (Pi.single 0 1) (Pi.single 1 1)"}, {"line": "refine \u27e8f 0, f 1, hf\u2080 0, hf\u2080 1, hf\u2081, funext <| Fin.forall_fin_two.2 ?_\u27e9", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\nf : Fin 2 \u2192 \ud835\udd5c\nhf\u2080 : \u2200 (x : Fin 2), 0 \u2264 f x\nhf\u2081 : f 0 + f 1 = 1\n\u22a2 (f 0 \u2022 Pi.single 0 1 + f 1 \u2022 Pi.single 1 1) 0 = f 0 \u2227 (f 0 \u2022 Pi.single 0 1 + f 1 \u2022 Pi.single 1 1) 1 = f 1"}, {"line": "simp", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\ninst\u271d\u00b2\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : CommSemiring \ud835\udd5c\ninst\u271d\u00b9\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u2075 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsOrderedRing \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d : IsOrderedRing \ud835\udd5c\nf : Fin 2 \u2192 \ud835\udd5c\nhf\u2080 : \u2200 (x : Fin 2), 0 \u2264 f x\nhf\u2081 : f 0 + f 1 = 1\n\u22a2 f 0 * 1 + f 1 * 0 = f 0 \u2227 f 0 * 0 + f 1 * 1 = f 1"}]}
{"declaration": "theorem hausdorffEdist_ne_top {K L : ConvexBody V} : EMetric.hausdorffEdist (K : Set V) L \u2260 \u22a4 := by\n  apply_rules [Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded, ConvexBody.nonempty,\n    ConvexBody.isBounded]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Body.lean", "context": {"open": ["scoped Pointwise Topology NNReal"], "variables": ["{V : Type*}", "[TopologicalSpace V] [AddCommGroup V] [Module \u211d V]", "[ContinuousAdd V]", "[ContinuousSMul \u211d V]", "[ContinuousAdd V]", "[SeminormedAddCommGroup V] [NormedSpace \u211d V] (K L : ConvexBody V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u2077 : TopologicalSpace V\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module \u211d V\ninst\u271d\u2074 : ContinuousAdd V\ninst\u271d\u00b3 : ContinuousSMul \u211d V\ninst\u271d\u00b2 : ContinuousAdd V\ninst\u271d\u00b9 : SeminormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nK L : ConvexBody V\n\u22a2 EMetric.hausdorffEdist \u2191K \u2191L \u2260 \u22a4"}, {"line": "apply_rules [Metric.hausdorffEdist_ne_top_of_nonempty_of_bounded, ConvexBody.nonempty,\n    ConvexBody.isBounded]", "tactic_state": "case bs\nV : Type u_1\ninst\u271d\u2077 : TopologicalSpace V\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module \u211d V\ninst\u271d\u2074 : ContinuousAdd V\ninst\u271d\u00b3 : ContinuousSMul \u211d V\ninst\u271d\u00b2 : ContinuousAdd V\ninst\u271d\u00b9 : SeminormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nK L : ConvexBody V\n\u22a2 Bornology.IsBounded \u2191K\n---\ncase bt\nV : Type u_1\ninst\u271d\u2077 : TopologicalSpace V\ninst\u271d\u2076 : AddCommGroup V\ninst\u271d\u2075 : Module \u211d V\ninst\u271d\u2074 : ContinuousAdd V\ninst\u271d\u00b3 : ContinuousSMul \u211d V\ninst\u271d\u00b2 : ContinuousAdd V\ninst\u271d\u00b9 : SeminormedAddCommGroup V\ninst\u271d : NormedSpace \u211d V\nK L : ConvexBody V\n\u22a2 Bornology.IsBounded \u2191L"}]}
{"declaration": "theorem Convex.sum_mem (hs : Convex R s) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : \u2211 i \u2208 t, w i = 1)\n    (hz : \u2200 i \u2208 t, z i \u2208 s) : (\u2211 i \u2208 t, w i \u2022 z i) \u2208 s := by\n  simpa only [h\u2081,centerMass,inv_one,one_smul] using\n    hs.centerMass_mem h\u2080 (h\u2081.symm \u25b8 zero_lt_one) hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Combination.lean", "context": {"open": ["Set Function Pointwise", "Finset"], "variables": ["{R R' E F \u03b9 \u03b9' \u03b1 : Type*} [Field R] [Field R'] [AddCommGroup E] [AddCommGroup F]", "(i j : \u03b9) (c : R) (t : Finset \u03b9) (w : \u03b9 \u2192 R) (z : \u03b9 \u2192 E)", "{w}", "{t}", "[LinearOrder R] [IsStrictOrderedRing R] [IsOrderedAddMonoid \u03b1] [OrderedSMul R \u03b1]", "{z}", "[LinearOrder R] [IsStrictOrderedRing R] [IsOrderedAddMonoid \u03b1] [OrderedSMul R \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nE : Type u_3\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Field R\ninst\u271d : AddCommGroup E\nt : Finset \u03b9\nw : \u03b9 \u2192 R\nz : \u03b9 \u2192 E\ns : Set E\nhs : sorry\nh\u2080 : (i : \u03b9) \u2192 i \u2208 t \u2192 sorry\nh\u2081 : \u2211 i \u2208 t, w i = 1\nhz : \u2200 i \u2208 t, z i \u2208 s\n\u22a2 \u2211 i \u2208 t, sorry \u2208 s"}, {"line": "simpa only [h\u2081,centerMass,inv_one,one_smul] using\n    hs.centerMass_mem h\u2080 (h\u2081.symm \u25b8 zero_lt_one) hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.convexHull_eq {s : Set E} (hs : s.Finite) : convexHull R s =\n    { x : E | \u2203 w : E \u2192 R, (\u2200 y \u2208 s, 0 \u2264 w y) \u2227 \u2211 y \u2208 hs.toFinset, w y = 1 \u2227\n      hs.toFinset.centerMass w id = x } := by\n  simpa only [Set.Finite.coe_toFinset,Set.Finite.mem_toFinset,exists_prop] using\n    hs.toFinset.convexHull_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Combination.lean", "context": {"open": ["Set Function Pointwise", "Finset"], "variables": ["{R R' E F \u03b9 \u03b9' \u03b1 : Type*} [Field R] [Field R'] [AddCommGroup E] [AddCommGroup F]", "(i j : \u03b9) (c : R) (t : Finset \u03b9) (w : \u03b9 \u2192 R) (z : \u03b9 \u2192 E)", "{w}", "{t}", "[LinearOrder R] [IsStrictOrderedRing R] [IsOrderedAddMonoid \u03b1] [OrderedSMul R \u03b1]", "{z}", "[LinearOrder R] [IsStrictOrderedRing R] [IsOrderedAddMonoid \u03b1] [OrderedSMul R \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : Field R\ninst\u271d : AddCommGroup E\ns : Set E\nhs : s.Finite\n\u22a2 sorry = {x | \u2203 w, (\u2200 y \u2208 s, sorry) \u2227 \u2211 y \u2208 hs.toFinset, w y = 1 \u2227 sorry = x}"}, {"line": "simpa only [Set.Finite.coe_toFinset,Set.Finite.mem_toFinset,exists_prop] using\n    hs.toFinset.convexHull_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrictMonoOn.exists_slope_lt_deriv_aux {x y : \u211d} {f : \u211d \u2192 \u211d} (hf : ContinuousOn f (Icc x y))\n    (hxy : x < y) (hf'_mono : StrictMonoOn (deriv f) (Ioo x y)) (h : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0) :\n    \u2203 a \u2208 Ioo x y, (f y - f x) / (y - x) < deriv f a := by\n  have A : DifferentiableOn \u211d f (Ioo x y) := fun w wmem =>\n    (differentiableAt_of_deriv_ne_zero (h w wmem)).differentiableWithinAt\n  obtain \u27e8a, \u27e8hxa, hay\u27e9, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy hf A\n  rcases nonempty_Ioo.2 hay with \u27e8b, \u27e8hab, hby\u27e9\u27e9\n  refine \u27e8b, \u27e8hxa.trans hab, hby\u27e9, ?_\u27e9\n  rw [\u2190 ha]\n  exact hf'_mono \u27e8hxa, hay\u27e9 \u27e8hxa.trans hab, hby\u27e9 hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\n\u22a2 \u2203 a \u2208 Ioo x y, (f y - f x) / (y - x) < deriv f a"}, {"line": "have A : DifferentiableOn \u211d f (Ioo x y) := fun w wmem =>\n    (differentiableAt_of_deriv_ne_zero (h w wmem)).differentiableWithinAt", "tactic_state": "x y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\n\u22a2 \u2203 a \u2208 Ioo x y, (f y - f x) / (y - x) < deriv f a"}, {"line": "obtain \u27e8a, \u27e8hxa, hay\u27e9, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy hf A", "tactic_state": "case intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\n\u22a2 \u2203 a \u2208 Ioo x y, (f y - f x) / (y - x) < deriv f a"}, {"line": "rcases nonempty_Ioo.2 hay with \u27e8b, \u27e8hab, hby\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhab : a < b\nhby : b < y\n\u22a2 \u2203 a \u2208 Ioo x y, (f y - f x) / (y - x) < deriv f a"}, {"line": "refine \u27e8b, \u27e8hxa.trans hab, hby\u27e9, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhab : a < b\nhby : b < y\n\u22a2 (f y - f x) / (y - x) < deriv f b"}, {"line": "rw [\u2190 ha]", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhab : a < b\nhby : b < y\n\u22a2 deriv f a < deriv f b"}, {"line": "exact hf'_mono \u27e8hxa, hay\u27e9 \u27e8hxa.trans hab, hby\u27e9 hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrictMonoOn.exists_deriv_lt_slope_aux {x y : \u211d} {f : \u211d \u2192 \u211d} (hf : ContinuousOn f (Icc x y))\n    (hxy : x < y) (hf'_mono : StrictMonoOn (deriv f) (Ioo x y)) (h : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0) :\n    \u2203 a \u2208 Ioo x y, deriv f a < (f y - f x) / (y - x) := by\n  have A : DifferentiableOn \u211d f (Ioo x y) := fun w wmem =>\n    (differentiableAt_of_deriv_ne_zero (h w wmem)).differentiableWithinAt\n  obtain \u27e8a, \u27e8hxa, hay\u27e9, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy hf A\n  rcases nonempty_Ioo.2 hxa with \u27e8b, \u27e8hxb, hba\u27e9\u27e9\n  refine \u27e8b, \u27e8hxb, hba.trans hay\u27e9, ?_\u27e9\n  rw [\u2190 ha]\n  exact hf'_mono \u27e8hxb, hba.trans hay\u27e9 \u27e8hxa, hay\u27e9 hba\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\n\u22a2 \u2203 a \u2208 Ioo x y, deriv f a < (f y - f x) / (y - x)"}, {"line": "have A : DifferentiableOn \u211d f (Ioo x y) := fun w wmem =>\n    (differentiableAt_of_deriv_ne_zero (h w wmem)).differentiableWithinAt", "tactic_state": "x y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\n\u22a2 \u2203 a \u2208 Ioo x y, deriv f a < (f y - f x) / (y - x)"}, {"line": "obtain \u27e8a, \u27e8hxa, hay\u27e9, ha\u27e9 : \u2203 a \u2208 Ioo x y, deriv f a = (f y - f x) / (y - x) :=\n    exists_deriv_eq_slope f hxy hf A", "tactic_state": "case intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\n\u22a2 \u2203 a \u2208 Ioo x y, deriv f a < (f y - f x) / (y - x)"}, {"line": "rcases nonempty_Ioo.2 hxa with \u27e8b, \u27e8hxb, hba\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhxb : x < b\nhba : b < a\n\u22a2 \u2203 a \u2208 Ioo x y, deriv f a < (f y - f x) / (y - x)"}, {"line": "refine \u27e8b, \u27e8hxb, hba.trans hay\u27e9, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhxb : x < b\nhba : b < a\n\u22a2 deriv f b < (f y - f x) / (y - x)"}, {"line": "rw [\u2190 ha]", "tactic_state": "case intro.intro.intro.intro.intro\nx y : \u211d\nf : \u211d \u2192 \u211d\nhf : ContinuousOn f (Icc x y)\nhxy : x < y\nhf'_mono : StrictMonoOn (deriv f) (Ioo x y)\nh : \u2200 w \u2208 Ioo x y, deriv f w \u2260 0\nA : DifferentiableOn \u211d f (Ioo x y)\na : \u211d\nha : deriv f a = (f y - f x) / (y - x)\nhxa : x < a\nhay : a < y\nb : \u211d\nhxb : x < b\nhba : b < a\n\u22a2 deriv f b < deriv f a"}, {"line": "exact hf'_mono \u27e8hxb, hba.trans hay\u27e9 \u27e8hxa, hay\u27e9 hba", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_slope_of_hasDerivWithinAt_Ioi (hfc : ConvexOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Ioi x) x) :\n    f' \u2264 slope f x y := by\n  apply le_of_tendsto <| (hasDerivWithinAt_iff_tendsto_slope' not_mem_Ioi_self).mp hf'\n  simp_rw [eventually_nhdsWithin_iff, slope_def_field]\n  filter_upwards [eventually_lt_nhds hxy] with t ht (ht' : x < t)\n  refine hfc.secant_mono hx (?_ : t \u2208 S) hy ht'.ne' hxy.ne' ht.le\n  exact hfc.1.ordConnected.out hx hy \u27e8ht'.le, ht.le\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 f' \u2264 slope f x y"}, {"line": "apply le_of_tendsto <| (hasDerivWithinAt_iff_tendsto_slope' not_mem_Ioi_self).mp hf'", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 \u2200\u1da0 (c : \u211d) in nhdsWithin x (Ioi x), slope f x c \u2264 slope f x y"}, {"line": "simp_rw [eventually_nhdsWithin_iff, slope_def_field]", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 \u2200\u1da0 (x_1 : \u211d) in nhds x, x_1 \u2208 Ioi x \u2192 (f x_1 - f x) / (x_1 - x) \u2264 (f y - f x) / (y - x)"}, {"line": "filter_upwards [eventually_lt_nhds hxy] with t ht (ht' : x < t)", "tactic_state": "case h\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nt : \u211d\nht : t < y\nht' : x < t\n\u22a2 (f t - f x) / (t - x) \u2264 (f y - f x) / (y - x)"}, {"line": "refine hfc.secant_mono hx (?_ : t \u2208 S) hy ht'.ne' hxy.ne' ht.le", "tactic_state": "case h\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nt : \u211d\nht : t < y\nht' : x < t\n\u22a2 t \u2208 S"}, {"line": "exact hfc.1.ordConnected.out hx hy \u27e8ht'.le, ht.le\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_le_of_hasDerivWithinAt_Iio (hfc : ConvexOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Iio y) y) :\n    slope f x y \u2264 f' := by\n  apply ge_of_tendsto <| (hasDerivWithinAt_iff_tendsto_slope' not_mem_Iio_self).mp hf'\n  simp_rw [eventually_nhdsWithin_iff, slope_comm f x y, slope_def_field]\n  filter_upwards [eventually_gt_nhds hxy] with t ht (ht' : t < y)\n  refine hfc.secant_mono hy hx (?_ : t \u2208 S) hxy.ne ht'.ne ht.le\n  exact hfc.1.ordConnected.out hx hy \u27e8ht.le, ht'.le\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 slope f x y \u2264 f'"}, {"line": "apply ge_of_tendsto <| (hasDerivWithinAt_iff_tendsto_slope' not_mem_Iio_self).mp hf'", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 \u2200\u1da0 (c : \u211d) in nhdsWithin y (Iio y), slope f x y \u2264 slope f y c"}, {"line": "simp_rw [eventually_nhdsWithin_iff, slope_comm f x y, slope_def_field]", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 \u2200\u1da0 (x_1 : \u211d) in nhds y, x_1 \u2208 Iio y \u2192 (f x - f y) / (x - y) \u2264 (f x_1 - f y) / (x_1 - y)"}, {"line": "filter_upwards [eventually_gt_nhds hxy] with t ht (ht' : t < y)", "tactic_state": "case h\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nt : \u211d\nht : x < t\nht' : t < y\n\u22a2 (f x - f y) / (x - y) \u2264 (f t - f y) / (t - y)"}, {"line": "refine hfc.secant_mono hy hx (?_ : t \u2208 S) hxy.ne ht'.ne ht.le", "tactic_state": "case h\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nt : \u211d\nht : x < t\nht' : t < y\n\u22a2 t \u2208 S"}, {"line": "exact hfc.1.ordConnected.out hx hy \u27e8ht.le, ht'.le\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotoneOn_derivWithin (hfc : ConvexOn \u211d S f) (hfd : DifferentiableOn \u211d f S) :\n    MonotoneOn (derivWithin f S) S := by\n  intro x hx y hy hxy\n  rcases eq_or_lt_of_le hxy with rfl | hxy'\n  \u00b7 rfl\n  exact (hfc.derivWithin_le_slope hx hy hxy' (hfd x hx)).trans\n    (hfc.slope_le_derivWithin hx hy hxy' (hfd y hy))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\n\u22a2 MonotoneOn (derivWithin f S) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\n\u22a2 derivWithin f S x \u2264 derivWithin f S y"}, {"line": "rcases eq_or_lt_of_le hxy with rfl | hxy'", "tactic_state": "case inl\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx hy : x \u2208 S\nhxy : x \u2264 x\n\u22a2 derivWithin f S x \u2264 derivWithin f S x\n---\ncase inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 derivWithin f S x \u2264 derivWithin f S y"}, {"line": "\u00b7 rfl", "tactic_state": "case inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 derivWithin f S x \u2264 derivWithin f S y"}, {"line": "exact (hfc.derivWithin_le_slope hx hy hxy' (hfd x hx)).trans\n    (hfc.slope_le_derivWithin hx hy hxy' (hfd y hy))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monotoneOn_deriv (hfc : ConvexOn \u211d S f) (hfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x) :\n    MonotoneOn (deriv f) S := by\n  intro x hx y hy hxy\n  rcases eq_or_lt_of_le hxy with rfl | hxy'\n  \u00b7 rfl\n  exact (hfc.deriv_le_slope hx hy hxy' (hfd x hx)).trans (hfc.slope_le_deriv hx hy hxy' (hfd y hy))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\n\u22a2 MonotoneOn (deriv f) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\n\u22a2 deriv f x \u2264 deriv f y"}, {"line": "rcases eq_or_lt_of_le hxy with rfl | hxy'", "tactic_state": "case inl\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\nx : \u211d\nhx hy : x \u2208 S\nhxy : x \u2264 x\n\u22a2 deriv f x \u2264 deriv f x\n---\ncase inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 deriv f x \u2264 deriv f y"}, {"line": "\u00b7 rfl", "tactic_state": "case inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 deriv f x \u2264 deriv f y"}, {"line": "exact (hfc.deriv_le_slope hx hy hxy' (hfd x hx)).trans (hfc.slope_le_deriv hx hy hxy' (hfd y hy))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isMinOn_of_rightDeriv_eq_zero (hf : ConvexOn \u211d S f) (hx : x \u2208 interior S)\n    (hf_rd : derivWithin f (Ioi x) x = 0) :\n    IsMinOn f S x := by\n  refine hf.isMinOn_of_leftDeriv_nonpos_of_rightDeriv_nonneg hx ?_ hf_rd.symm.le\n  exact (hf.leftDeriv_le_rightDeriv_of_mem_interior hx).trans_eq hf_rd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx : \u211d\nhf : ConvexOn \u211d S f\nhx : x \u2208 interior S\nhf_rd : derivWithin f (Ioi x) x = 0\n\u22a2 IsMinOn f S x"}, {"line": "refine hf.isMinOn_of_leftDeriv_nonpos_of_rightDeriv_nonneg hx ?_ hf_rd.symm.le", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx : \u211d\nhf : ConvexOn \u211d S f\nhx : x \u2208 interior S\nhf_rd : derivWithin f (Ioi x) x = 0\n\u22a2 derivWithin f (Iio x) x \u2264 0"}, {"line": "exact (hf.leftDeriv_le_rightDeriv_of_mem_interior hx).trans_eq hf_rd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isMinOn_of_leftDeriv_eq_zero (hf : ConvexOn \u211d S f) (hx : x \u2208 interior S)\n    (hf_ld : derivWithin f (Iio x) x = 0) :\n    IsMinOn f S x := by\n  refine hf.isMinOn_of_leftDeriv_nonpos_of_rightDeriv_nonneg hx hf_ld.le ?_\n  exact hf_ld.symm.le.trans (hf.leftDeriv_le_rightDeriv_of_mem_interior hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx : \u211d\nhf : ConvexOn \u211d S f\nhx : x \u2208 interior S\nhf_ld : derivWithin f (Iio x) x = 0\n\u22a2 IsMinOn f S x"}, {"line": "refine hf.isMinOn_of_leftDeriv_nonpos_of_rightDeriv_nonneg hx hf_ld.le ?_", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx : \u211d\nhf : ConvexOn \u211d S f\nhx : x \u2208 interior S\nhf_ld : derivWithin f (Iio x) x = 0\n\u22a2 0 \u2264 derivWithin f (Ioi x) x"}, {"line": "exact hf_ld.symm.le.trans (hf.leftDeriv_le_rightDeriv_of_mem_interior hx)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_slope_of_hasDerivWithinAt_Ioi (hfc : StrictConvexOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Ioi x) x) :\n    f' < slope f x y := by\n  obtain \u27e8u, hxu, huy\u27e9 := exists_between hxy\n  have hu : u \u2208 S := hfc.1.ordConnected.out hx hy \u27e8hxu.le, huy.le\u27e9\n  have := hfc.secant_strict_mono hx hu hy hxu.ne' hxy.ne' huy\n  simp only [\u2190 slope_def_field] at this\n  exact (hfc.convexOn.le_slope_of_hasDerivWithinAt_Ioi hx hu hxu hf').trans_lt this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 f' < slope f x y"}, {"line": "obtain \u27e8u, hxu, huy\u27e9 := exists_between hxy", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nu : \u211d\nhxu : x < u\nhuy : u < y\n\u22a2 f' < slope f x y"}, {"line": "have hu : u \u2208 S := hfc.1.ordConnected.out hx hy \u27e8hxu.le, huy.le\u27e9", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\n\u22a2 f' < slope f x y"}, {"line": "have := hfc.secant_strict_mono hx hu hy hxu.ne' hxy.ne' huy", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\nthis : (f u - f x) / (u - x) < (f y - f x) / (y - x)\n\u22a2 f' < slope f x y"}, {"line": "simp only [\u2190 slope_def_field] at this", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\nthis : slope f x u < slope f x y\n\u22a2 f' < slope f x y"}, {"line": "exact (hfc.convexOn.le_slope_of_hasDerivWithinAt_Ioi hx hu hxu hf').trans_lt this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_lt_of_hasDerivWithinAt_Iio (hfc : StrictConvexOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Iio y) y)  :\n    slope f x y < f' := by\n  obtain \u27e8u, hxu, huy\u27e9 := exists_between hxy\n  have hu : u \u2208 S := hfc.1.ordConnected.out hx hy \u27e8hxu.le, huy.le\u27e9\n  have := hfc.secant_strict_mono hy hx hu hxy.ne huy.ne hxu\n  simp_rw [\u2190 slope_def_field, slope_comm _ y] at this\n  exact this.trans_le <| hfc.convexOn.slope_le_of_hasDerivWithinAt_Iio hu hy huy hf'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 slope f x y < f'"}, {"line": "obtain \u27e8u, hxu, huy\u27e9 := exists_between hxy", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nu : \u211d\nhxu : x < u\nhuy : u < y\n\u22a2 slope f x y < f'"}, {"line": "have hu : u \u2208 S := hfc.1.ordConnected.out hx hy \u27e8hxu.le, huy.le\u27e9", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\n\u22a2 slope f x y < f'"}, {"line": "have := hfc.secant_strict_mono hy hx hu hxy.ne huy.ne hxu", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\nthis : (f x - f y) / (x - y) < (f u - f y) / (u - y)\n\u22a2 slope f x y < f'"}, {"line": "simp_rw [\u2190 slope_def_field, slope_comm _ y] at this", "tactic_state": "case intro.intro\nS : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConvexOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\nu : \u211d\nhxu : x < u\nhuy : u < y\nhu : u \u2208 S\nthis : slope f x y < slope f u y\n\u22a2 slope f x y < f'"}, {"line": "exact this.trans_le <| hfc.convexOn.slope_le_of_hasDerivWithinAt_Iio hu hy huy hf'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_derivWithin (hfc : StrictConvexOn \u211d S f) (hfd : DifferentiableOn \u211d f S) :\n    StrictMonoOn (derivWithin f S) S := by\n  intro x hx y hy hxy\n  exact (hfc.derivWithin_lt_slope hx hy hxy (hfd x hx)).trans\n    (hfc.slope_lt_derivWithin hx hy hxy (hfd y hy))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\n\u22a2 StrictMonoOn (derivWithin f S) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConvexOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x < y\n\u22a2 derivWithin f S x < derivWithin f S y"}, {"line": "exact (hfc.derivWithin_lt_slope hx hy hxy (hfd x hx)).trans\n    (hfc.slope_lt_derivWithin hx hy hxy (hfd y hy))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_deriv (hfc : StrictConvexOn \u211d S f) (hfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x) :\n    StrictMonoOn (deriv f) S := by\n  intro x hx y hy hxy\n  exact (hfc.deriv_lt_slope hx hy hxy (hfd x hx)).trans (hfc.slope_lt_deriv hx hy hxy (hfd y hy))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\n\u22a2 StrictMonoOn (deriv f) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConvexOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x < y\n\u22a2 deriv f x < deriv f y"}, {"line": "exact (hfc.deriv_lt_slope hx hy hxy (hfd x hx)).trans (hfc.slope_lt_deriv hx hy hxy (hfd y hy))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_le_of_hasDerivWithinAt_Ioi (hfc : ConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Ioi x) x) :\n    slope f x y \u2264 f' := by\n  simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_le_neg (hfc.neg.le_slope_of_hasDerivWithinAt_Ioi hx hy hxy hf'.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 slope f x y \u2264 f'"}, {"line": "simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_le_neg (hfc.neg.le_slope_of_hasDerivWithinAt_Ioi hx hy hxy hf'.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_slope_of_hasDerivWithinAt_Iio (hfc : ConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Iio y) y) :\n    f' \u2264 slope f x y := by\n  simpa only [neg_neg,Pi.neg_def,slope_neg] using\n    neg_le_neg (hfc.neg.slope_le_of_hasDerivWithinAt_Iio hx hy hxy hf'.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : ConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 f' \u2264 slope f x y"}, {"line": "simpa only [neg_neg,Pi.neg_def,slope_neg] using\n    neg_le_neg (hfc.neg.slope_le_of_hasDerivWithinAt_Iio hx hy hxy hf'.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitoneOn_derivWithin (hfc : ConcaveOn \u211d S f) (hfd : DifferentiableOn \u211d f S) :\n    AntitoneOn (derivWithin f S) S := by\n  intro x hx y hy hxy\n  rcases eq_or_lt_of_le hxy with rfl | hxy'\n  \u00b7 rfl\n  exact (hfc.derivWithin_le_slope hx hy hxy' (hfd y hy)).trans\n    (hfc.slope_le_derivWithin hx hy hxy' (hfd x hx))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\n\u22a2 AntitoneOn (derivWithin f S) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\n\u22a2 derivWithin f S y \u2264 derivWithin f S x"}, {"line": "rcases eq_or_lt_of_le hxy with rfl | hxy'", "tactic_state": "case inl\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx hy : x \u2208 S\nhxy : x \u2264 x\n\u22a2 derivWithin f S x \u2264 derivWithin f S x\n---\ncase inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 derivWithin f S y \u2264 derivWithin f S x"}, {"line": "\u00b7 rfl", "tactic_state": "case inr\nS : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x \u2264 y\nhxy' : x < y\n\u22a2 derivWithin f S y \u2264 derivWithin f S x"}, {"line": "exact (hfc.derivWithin_le_slope hx hy hxy' (hfd y hy)).trans\n    (hfc.slope_le_derivWithin hx hy hxy' (hfd x hx))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antitoneOn_deriv (hfc : ConcaveOn \u211d S f) (hfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x) :\n    AntitoneOn (deriv f) S := by\n  simpa only [Pi.neg_def,deriv.neg,neg_neg] using\n    (hfc.neg.monotoneOn_deriv (fun x hx \u21a6 (hfd x hx).neg)).neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : ConcaveOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\n\u22a2 AntitoneOn (deriv f) S"}, {"line": "simpa only [Pi.neg_def,deriv.neg,neg_neg] using\n    (hfc.neg.monotoneOn_deriv (fun x hx \u21a6 (hfd x hx).neg)).neg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_lt_of_hasDerivWithinAt_Ioi (hfc : StrictConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Ioi x) x) :\n    slope f x y < f' := by\n  simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivWithinAt_Ioi hx hy hxy hf'.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Ioi x) x\n\u22a2 slope f x y < f'"}, {"line": "simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivWithinAt_Ioi hx hy hxy hf'.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_lt_of_hasDerivWithinAt (hfc : StrictConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hfd : HasDerivWithinAt f f' S x) :\n    slope f x y < f' := by\n  simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivWithinAt hx hy hxy hfd.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhfd : HasDerivWithinAt f f' S x\n\u22a2 slope f x y < f'"}, {"line": "simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivWithinAt hx hy hxy hfd.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma slope_lt_of_hasDerivAt (hfc : StrictConcaveOn \u211d S f) (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y)\n    (hfd : HasDerivAt f f' x) :\n    slope f x y < f' := by\n  simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivAt hx hy hxy hfd.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhfd : HasDerivAt f f' x\n\u22a2 slope f x y < f'"}, {"line": "simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.lt_slope_of_hasDerivAt hx hy hxy hfd.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_slope_of_hasDerivWithinAt_Iio (hfc : StrictConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' (Iio y) y) :\n    f' < slope f x y := by\n  simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.slope_lt_of_hasDerivWithinAt_Iio hx hy hxy hf'.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' (Iio y) y\n\u22a2 f' < slope f x y"}, {"line": "simpa only [Pi.neg_def,slope_neg,neg_neg] using\n    neg_lt_neg (hfc.neg.slope_lt_of_hasDerivWithinAt_Iio hx hy hxy hf'.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_slope_of_hasDerivWithinAt (hfc : StrictConcaveOn \u211d S f)\n    (hx : x \u2208 S) (hy : y \u2208 S) (hxy : x < y) (hf' : HasDerivWithinAt f f' S y) :\n    f' < slope f x y := by\n  simpa only [neg_neg,Pi.neg_def,slope_neg] using\n    neg_lt_neg (hfc.neg.slope_lt_of_hasDerivWithinAt hx hy hxy hf'.neg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nx y f' : \u211d\nhfc : StrictConcaveOn \u211d S f\nhx : x \u2208 S\nhy : y \u2208 S\nhxy : x < y\nhf' : HasDerivWithinAt f f' S y\n\u22a2 f' < slope f x y"}, {"line": "simpa only [neg_neg,Pi.neg_def,slope_neg] using\n    neg_lt_neg (hfc.neg.slope_lt_of_hasDerivWithinAt hx hy hxy hf'.neg)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAntiOn_derivWithin (hfc : StrictConcaveOn \u211d S f) (hfd : DifferentiableOn \u211d f S) :\n    StrictAntiOn (derivWithin f S) S := by\n  intro x hx y hy hxy\n  exact (hfc.derivWithin_lt_slope hx hy hxy (hfd y hy)).trans\n    (hfc.slope_lt_derivWithin hx hy hxy (hfd x hx))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\n\u22a2 StrictAntiOn (derivWithin f S) S"}, {"line": "intro x hx y hy hxy", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConcaveOn \u211d S f\nhfd : DifferentiableOn \u211d f S\nx : \u211d\nhx : x \u2208 S\ny : \u211d\nhy : y \u2208 S\nhxy : x < y\n\u22a2 derivWithin f S y < derivWithin f S x"}, {"line": "exact (hfc.derivWithin_lt_slope hx hy hxy (hfd y hy)).trans\n    (hfc.slope_lt_derivWithin hx hy hxy (hfd x hx))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictAntiOn_deriv (hfc : StrictConcaveOn \u211d S f) (hfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x) :\n    StrictAntiOn (deriv f) S := by\n  simpa only [Pi.neg_def,deriv.neg,neg_neg] using\n    (hfc.neg.strictMonoOn_deriv (fun x hx \u21a6 (hfd x hx).neg)).neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Deriv.lean", "context": {"open": ["Metric Set Asymptotics ContinuousLinearMap Filter", "scoped Topology NNReal"], "variables": ["{\ud835\udd5c : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}", "{S : Set \u211d} {f : \u211d \u2192 \u211d} {x y f' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Set \u211d\nf : \u211d \u2192 \u211d\nhfc : StrictConcaveOn \u211d S f\nhfd : \u2200 x \u2208 S, DifferentiableAt \u211d f x\n\u22a2 StrictAntiOn (deriv f) S"}, {"line": "simpa only [Pi.neg_def,deriv.neg,neg_neg] using\n    (hfc.neg.strictMonoOn_deriv (fun x hx \u21a6 (hfd x hx).neg)).neg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_eq_top : egauge \ud835\udd5c s x = \u221e \u2194 \u2200 c : \ud835\udd5c, x \u2209 c \u2022 s := by simp [egauge]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\nx : E\n\u22a2 egauge \ud835\udd5c s x = \u22a4 \u2194 \u2200 (c : \ud835\udd5c), x \u2209 c \u2022 s"}, {"line": "simp [egauge]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_lt_iff : egauge \ud835\udd5c s x < r \u2194 \u2203 c : \ud835\udd5c, x \u2208 c \u2022 s \u2227 \u2016c\u2016\u2091 < r := by\n  simp [egauge, iInf_lt_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\nx : E\nr : ENNReal\n\u22a2 egauge \ud835\udd5c s x < r \u2194 \u2203 c, x \u2208 c \u2022 s \u2227 \u2016c\u2016\u2091 < r"}, {"line": "simp [egauge, iInf_lt_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_union (s t : Set E) (x : E) : egauge \ud835\udd5c (s \u222a t) x = egauge \ud835\udd5c s x \u2293 egauge \ud835\udd5c t x := by\n  unfold egauge\n  simp [smul_set_union, iInf_or, iInf_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nx : E\n\u22a2 egauge \ud835\udd5c (s \u222a t) x = min (egauge \ud835\udd5c s x) (egauge \ud835\udd5c t x)"}, {"line": "unfold egauge", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nx : E\n\u22a2 \u2a05 c, \u2a05 (_ : x \u2208 c \u2022 (s \u222a t)), \u2016c\u2016\u2091 = min (\u2a05 c, \u2a05 (_ : x \u2208 c \u2022 s), \u2016c\u2016\u2091) (\u2a05 c, \u2a05 (_ : x \u2208 c \u2022 t), \u2016c\u2016\u2091)"}, {"line": "simp [smul_set_union, iInf_or, iInf_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_le_of_smul_mem (h : c \u2022 x \u2208 s) : egauge \ud835\udd5c s x \u2264 \u2016c\u2016\u2091\u207b\u00b9 := by\n  rcases eq_or_ne c 0 with rfl | hc\n  \u00b7 simp\n  \u00b7 exact (egauge_le_of_smul_mem_of_ne h hc).trans ENNReal.coe_inv_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nh : sorry \u2208 s\n\u22a2 sorry \u2264 \u2016c\u2016\u2091\u207b\u00b9"}, {"line": "rcases eq_or_ne c 0 with rfl | hc", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\nh : sorry \u2208 s\n\u22a2 sorry \u2264 \u2016sorry\u2016\u2091\u207b\u00b9\n---\ncase inr\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nh : sorry \u2208 s\nhc : c \u2260 sorry\n\u22a2 sorry \u2264 \u2016c\u2016\u2091\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NNNorm \ud835\udd5c\nE : Type u_2\ninst\u271d : SMul \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nh : sorry \u2208 s\nhc : c \u2260 sorry\n\u22a2 sorry \u2264 \u2016c\u2016\u2091\u207b\u00b9"}, {"line": "\u00b7 exact (egauge_le_of_smul_mem_of_ne h hc).trans ENNReal.coe_inv_le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_zero_zero : egauge \ud835\udd5c (0 : Set E) 0 = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\n\u22a2 egauge \ud835\udd5c 0 0 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_egauge_smul_right (c : \ud835\udd5c) (s : Set E) (x : E) :\n    \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 egauge \ud835\udd5c s (c \u2022 x) := by\n  rw [le_egauge_iff]\n  rintro a \u27e8y, hy, hxy\u27e9\n  rcases eq_or_ne c 0 with rfl | hc\n  \u00b7 simp\n  \u00b7 refine ENNReal.mul_le_of_le_div' <| le_trans ?_ ENNReal.coe_div_le\n    rw [div_eq_inv_mul]\n    rw [\u2190 nnnorm_inv]\n    rw [\u2190 nnnorm_mul]\n    refine egauge_le_of_mem_smul \u27e8y, hy, ?_\u27e9\n    simp only [mul_smul]\n    simp only [hxy]\n    simp only [inv_smul_smul\u2080 hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nx : E\n\u22a2 \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 egauge \ud835\udd5c s (c \u2022 x)"}, {"line": "rw [le_egauge_iff]", "tactic_state": "\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nx : E\n\u22a2 \u2200 (c_1 : \ud835\udd5c), c \u2022 x \u2208 c_1 \u2022 s \u2192 \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 \u2016c_1\u2016\u2091"}, {"line": "rintro a \u27e8y, hy, hxy\u27e9", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nx : E\na : \ud835\udd5c\ny : E\nhy : y \u2208 s\nhxy : (fun x => a \u2022 x) y = c \u2022 x\n\u22a2 \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 \u2016a\u2016\u2091"}, {"line": "rcases eq_or_ne c 0 with rfl | hc", "tactic_state": "case intro.intro.inl\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\nx : E\na : \ud835\udd5c\ny : E\nhy : y \u2208 s\nhxy : (fun x => a \u2022 x) y = sorry \u2022 x\n\u22a2 \u2016sorry\u2016\u2091 * egauge \ud835\udd5c s x \u2264 \u2016a\u2016\u2091\n---\ncase intro.intro.inr\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nx : E\na : \ud835\udd5c\ny : E\nhy : y \u2208 s\nhxy : (fun x => a \u2022 x) y = c \u2022 x\nhc : c \u2260 sorry\n\u22a2 \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 \u2016a\u2016\u2091"}, {"line": "\u00b7 simp", "tactic_state": "case intro.intro.inr\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedDivisionRing \ud835\udd5c\nE : Type u_7\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\nc : \ud835\udd5c\ns : Set E\nx : E\na : \ud835\udd5c\ny : E\nhy : y \u2208 s\nhxy : (fun x => a \u2022 x) y = c \u2022 x\nhc : c \u2260 sorry\n\u22a2 \u2016c\u2016\u2091 * egauge \ud835\udd5c s x \u2264 \u2016a\u2016\u2091"}, {"line": "\u00b7 refine ENNReal.mul_le_of_le_div' <| le_trans ?_ ENNReal.coe_div_le\n    rw [div_eq_inv_mul]\n    rw [\u2190 nnnorm_inv]\n    rw [\u2190 nnnorm_mul]\n    refine egauge_le_of_mem_smul \u27e8y, hy, ?_\u27e9\n    simp only [mul_smul]\n    simp only [hxy]\n    simp only [inv_smul_smul\u2080 hc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_egauge_closedBall_one (x : E) : \u2016x\u2016\u2091 \u2264 egauge \ud835\udd5c (closedBall 0 1) x := by\n  simpa using div_le_egauge_closedBall \ud835\udd5c 1 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\ud835\udd5c : Type*} {\u03b9 : Type*} {E : \u03b9 \u2192 Type*}", "[NormedDivisionRing \ud835\udd5c] [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "(\ud835\udd5c : Type*) [NormedField \ud835\udd5c] {E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_11\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_12\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\n\u22a2 \u2016x\u2016\u2091 \u2264 egauge \ud835\udd5c (closedBall 0 1) x"}, {"line": "simpa using div_le_egauge_closedBall \ud835\udd5c 1 x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_egauge_ball_one (x : E) : \u2016x\u2016\u2091 \u2264 egauge \ud835\udd5c (ball 0 1) x := by\n  simpa using div_le_egauge_ball \ud835\udd5c 1 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\ud835\udd5c : Type*} {\u03b9 : Type*} {E : \u03b9 \u2192 Type*}", "[NormedDivisionRing \ud835\udd5c] [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "(\ud835\udd5c : Type*) [NormedField \ud835\udd5c] {E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_11\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_12\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\n\u22a2 \u2016x\u2016\u2091 \u2264 egauge \ud835\udd5c (ball 0 1) x"}, {"line": "simpa using div_le_egauge_ball \ud835\udd5c 1 x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma egauge_ball_one_le_of_one_lt_norm (hc : 1 < \u2016c\u2016) (x : E) :\n    egauge \ud835\udd5c (ball 0 1) x \u2264 \u2016c\u2016\u2091 * \u2016x\u2016\u2091 := by\n  simpa using egauge_ball_le_of_one_lt_norm hc (.inl one_ne_zero)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/EGauge.lean", "context": {"open": ["Function Set Filter Metric", "scoped Topology Pointwise ENNReal NNReal"], "variables": ["(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] {E : Type*} [SMul \ud835\udd5c E] {c : \ud835\udd5c} {s t : Set E} {x : E} {r : \u211d\u22650\u221e}", "{\ud835\udd5c}", "{F : Type*} [SMul \ud835\udd5c F]", "(\ud835\udd5c : Type*) [NNNorm \ud835\udd5c] [Nonempty \ud835\udd5c] {E : Type*} [Zero E] [SMulZeroClass \ud835\udd5c E] {x : E}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\ud835\udd5c : Type*} {\u03b9 : Type*} {E : \u03b9 \u2192 Type*}", "[NormedDivisionRing \ud835\udd5c] [\u2200 i, AddCommGroup (E i)] [\u2200 i, Module \ud835\udd5c (E i)]", "(\ud835\udd5c : Type*) [NormedField \ud835\udd5c] {E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c}", "{c : \ud835\udd5c} {x : E} {r : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_11\ninst\u271d\u00b2 : NormedField \ud835\udd5c\nE : Type u_12\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nhc : 1 < \u2016c\u2016\nx : E\n\u22a2 egauge \ud835\udd5c (ball 0 1) x \u2264 \u2016c\u2016\u2091 * \u2016x\u2016\u2091"}, {"line": "simpa using egauge_ball_le_of_one_lt_norm hc (.inl one_ne_zero)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsExtreme.trans (hAB : IsExtreme \ud835\udd5c A B) (hBC : IsExtreme \ud835\udd5c B C) :\n    IsExtreme \ud835\udd5c A C := by\n  refine \u27e8Subset.trans hBC.1 hAB.1, fun x\u2081 hx\u2081A x\u2082 hx\u2082A x hxC hx \u21a6 ?_\u27e9\n  obtain \u27e8hx\u2081B, hx\u2082B\u27e9 := hAB.2 hx\u2081A hx\u2082A (hBC.1 hxC) hx\n  exact hBC.2 hx\u2081B hx\u2082B hxC hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhBC : IsExtreme \ud835\udd5c B C\n\u22a2 IsExtreme \ud835\udd5c A C"}, {"line": "refine \u27e8Subset.trans hBC.1 hAB.1, fun x\u2081 hx\u2081A x\u2082 hx\u2082A x hxC hx \u21a6 ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhBC : IsExtreme \ud835\udd5c B C\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxC : x \u2208 C\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\n\u22a2 x\u2081 \u2208 C \u2227 x\u2082 \u2208 C"}, {"line": "obtain \u27e8hx\u2081B, hx\u2082B\u27e9 := hAB.2 hx\u2081A hx\u2082A (hBC.1 hxC) hx", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhBC : IsExtreme \ud835\udd5c B C\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxC : x \u2208 C\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\nhx\u2081B : x\u2081 \u2208 B\nhx\u2082B : x\u2082 \u2208 B\n\u22a2 x\u2081 \u2208 C \u2227 x\u2082 \u2208 C"}, {"line": "exact hBC.2 hx\u2081B hx\u2082B hxC hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsExtreme.inter (hAB : IsExtreme \ud835\udd5c A B) (hAC : IsExtreme \ud835\udd5c A C) :\n    IsExtreme \ud835\udd5c A (B \u2229 C) := by\n  use Subset.trans inter_subset_left hAB.1\n  rintro x\u2081 hx\u2081A x\u2082 hx\u2082A x \u27e8hxB, hxC\u27e9 hx\n  obtain \u27e8hx\u2081B, hx\u2082B\u27e9 := hAB.2 hx\u2081A hx\u2082A hxB hx\n  obtain \u27e8hx\u2081C, hx\u2082C\u27e9 := hAC.2 hx\u2081A hx\u2082A hxC hx\n  exact \u27e8\u27e8hx\u2081B, hx\u2081C\u27e9, hx\u2082B, hx\u2082C\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhAC : IsExtreme \ud835\udd5c A C\n\u22a2 IsExtreme \ud835\udd5c A (B \u2229 C)"}, {"line": "use Subset.trans inter_subset_left hAB.1", "tactic_state": "case right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhAC : IsExtreme \ud835\udd5c A C\n\u22a2 \u2200 \u2983x\u2081 : E\u2984, x\u2081 \u2208 A \u2192 \u2200 \u2983x\u2082 : E\u2984, x\u2082 \u2208 A \u2192 \u2200 \u2983x : E\u2984, x \u2208 B \u2229 C \u2192 x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 \u2208 B \u2229 C \u2227 x\u2082 \u2208 B \u2229 C"}, {"line": "rintro x\u2081 hx\u2081A x\u2082 hx\u2082A x \u27e8hxB, hxC\u27e9 hx", "tactic_state": "case right.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhAC : IsExtreme \ud835\udd5c A C\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxB : x \u2208 B\nhxC : x \u2208 C\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\n\u22a2 x\u2081 \u2208 B \u2229 C \u2227 x\u2082 \u2208 B \u2229 C"}, {"line": "obtain \u27e8hx\u2081B, hx\u2082B\u27e9 := hAB.2 hx\u2081A hx\u2082A hxB hx", "tactic_state": "case right.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhAC : IsExtreme \ud835\udd5c A C\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxB : x \u2208 B\nhxC : x \u2208 C\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\nhx\u2081B : x\u2081 \u2208 B\nhx\u2082B : x\u2082 \u2208 B\n\u22a2 x\u2081 \u2208 B \u2229 C \u2227 x\u2082 \u2208 B \u2229 C"}, {"line": "obtain \u27e8hx\u2081C, hx\u2082C\u27e9 := hAC.2 hx\u2081A hx\u2082A hxC hx", "tactic_state": "case right.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA B C : Set E\nhAB : IsExtreme \ud835\udd5c A B\nhAC : IsExtreme \ud835\udd5c A C\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxB : x \u2208 B\nhxC : x \u2208 C\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\nhx\u2081B : x\u2081 \u2208 B\nhx\u2082B : x\u2082 \u2208 B\nhx\u2081C : x\u2081 \u2208 C\nhx\u2082C : x\u2082 \u2208 C\n\u22a2 x\u2081 \u2208 B \u2229 C \u2227 x\u2082 \u2208 B \u2229 C"}, {"line": "exact \u27e8\u27e8hx\u2081B, hx\u2081C\u27e9, hx\u2082B, hx\u2082C\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isExtreme_iInter {\u03b9 : Sort*} [Nonempty \u03b9] {F : \u03b9 \u2192 Set E}\n    (hAF : \u2200 i : \u03b9, IsExtreme \ud835\udd5c A (F i)) : IsExtreme \ud835\udd5c A (\u22c2 i : \u03b9, F i) := by\n  obtain i := Classical.arbitrary \u03b9\n  refine \u27e8iInter_subset_of_subset i (hAF i).1, fun x\u2081 hx\u2081A x\u2082 hx\u2082A x hxF hx \u21a6 ?_\u27e9\n  simp_rw [mem_iInter] at hxF \u22a2\n  have h := fun i \u21a6 (hAF i).2 hx\u2081A hx\u2082A (hxF i) hx\n  exact \u27e8fun i \u21a6 (h i).1, fun i \u21a6 (h i).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\nA : Set E\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nF : \u03b9 \u2192 Set E\nhAF : \u2200 (i : \u03b9), IsExtreme \ud835\udd5c A (F i)\n\u22a2 IsExtreme \ud835\udd5c A (\u22c2 i, F i)"}, {"line": "obtain i := Classical.arbitrary \u03b9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\nA : Set E\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nF : \u03b9 \u2192 Set E\nhAF : \u2200 (i : \u03b9), IsExtreme \ud835\udd5c A (F i)\ni : ?m.329\n\u22a2 IsExtreme \ud835\udd5c A (\u22c2 i, F i)"}, {"line": "refine \u27e8iInter_subset_of_subset i (hAF i).1, fun x\u2081 hx\u2081A x\u2082 hx\u2082A x hxF hx \u21a6 ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\nA : Set E\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nF : \u03b9 \u2192 Set E\nhAF : \u2200 (i : \u03b9), IsExtreme \ud835\udd5c A (F i)\ni : \u03b9\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhxF : x \u2208 \u22c2 i, F i\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\n\u22a2 x\u2081 \u2208 \u22c2 i, F i \u2227 x\u2082 \u2208 \u22c2 i, F i"}, {"line": "simp_rw [mem_iInter] at hxF \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\nA : Set E\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nF : \u03b9 \u2192 Set E\nhAF : \u2200 (i : \u03b9), IsExtreme \ud835\udd5c A (F i)\ni : \u03b9\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\nhxF : \u2200 (i : \u03b9), x \u2208 F i\n\u22a2 (\u2200 (i : \u03b9), x\u2081 \u2208 F i) \u2227 \u2200 (i : \u03b9), x\u2082 \u2208 F i"}, {"line": "have h := fun i \u21a6 (hAF i).2 hx\u2081A hx\u2082A (hxF i) hx", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\nA : Set E\n\u03b9 : Sort u_6\ninst\u271d : Nonempty \u03b9\nF : \u03b9 \u2192 Set E\nhAF : \u2200 (i : \u03b9), IsExtreme \ud835\udd5c A (F i)\ni : \u03b9\nx\u2081 : E\nhx\u2081A : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082A : x\u2082 \u2208 A\nx : E\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\nhxF : \u2200 (i : \u03b9), x \u2208 F i\nh : \u2200 (i : \u03b9), x\u2081 \u2208 F i \u2227 x\u2082 \u2208 F i\n\u22a2 (\u2200 (i : \u03b9), x\u2081 \u2208 F i) \u2227 \u2200 (i : \u03b9), x\u2082 \u2208 F i"}, {"line": "exact \u27e8fun i \u21a6 (h i).1, fun i \u21a6 (h i).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isExtreme_biInter {F : Set (Set E)} (hF : F.Nonempty) (hA : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B) :\n    IsExtreme \ud835\udd5c A (\u22c2 B \u2208 F, B) := by\n  haveI := hF.to_subtype\n  simpa only [iInter_subtype] using isExtreme_iInter fun i : F \u21a6 hA _ i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhA : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B\n\u22a2 IsExtreme \ud835\udd5c A (\u22c2 B \u2208 F, B)"}, {"line": "haveI := hF.to_subtype", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhA : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B\nthis : Nonempty \u2191F\n\u22a2 IsExtreme \ud835\udd5c A (\u22c2 B \u2208 F, B)"}, {"line": "simpa only [iInter_subtype] using isExtreme_iInter fun i : F \u21a6 hA _ i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isExtreme_sInter {F : Set (Set E)} (hF : F.Nonempty) (hAF : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B) :\n    IsExtreme \ud835\udd5c A (\u22c2\u2080 F) := by simpa [sInter_eq_biInter] using isExtreme_biInter hF hAF\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nF : Set (Set E)\nhF : F.Nonempty\nhAF : \u2200 B \u2208 F, IsExtreme \ud835\udd5c A B\n\u22a2 IsExtreme \ud835\udd5c A (\u22c2\u2080 F)"}, {"line": "simpa [sInter_eq_biInter] using isExtreme_biInter hF hAF", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_extremePoints_iff_left : x \u2208 A.extremePoints \ud835\udd5c \u2194\n    x \u2208 A \u2227 \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x := by\n  refine \u27e8fun h \u21a6 \u27e8h.1, fun x\u2081 hx\u2081 x\u2082 hx\u2082 hx \u21a6 (h.2 hx\u2081 hx\u2082 hx).1\u27e9, ?_\u27e9\n  rintro \u27e8hxA, Hx\u27e9\n  use hxA\n  refine fun x\u2081 hx\u2081 x\u2082 hx\u2082 hx \u21a6 \u27e8Hx x\u2081 hx\u2081 x\u2082 hx\u2082 hx, Hx x\u2082 hx\u2082 x\u2081 hx\u2081 ?_\u27e9\n  rwa [openSegment_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Extreme.lean", "context": {"open": ["Function Set Affine"], "variables": ["{\ud835\udd5c E F \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [SMul \ud835\udd5c E]", "{\ud835\udd5c} {A B C : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nx : E\n\u22a2 x \u2208 extremePoints \ud835\udd5c A \u2194 x \u2208 A \u2227 \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x"}, {"line": "refine \u27e8fun h \u21a6 \u27e8h.1, fun x\u2081 hx\u2081 x\u2082 hx\u2082 hx \u21a6 (h.2 hx\u2081 hx\u2082 hx).1\u27e9, ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nx : E\n\u22a2 (x \u2208 A \u2227 \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x) \u2192 x \u2208 extremePoints \ud835\udd5c A"}, {"line": "rintro \u27e8hxA, Hx\u27e9", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nx : E\nhxA : x \u2208 A\nHx : \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x\n\u22a2 x \u2208 extremePoints \ud835\udd5c A"}, {"line": "use hxA", "tactic_state": "case right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nx : E\nhxA : x \u2208 A\nHx : \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x\n\u22a2 \u2200 \u2983x\u2081 : E\u2984, x\u2081 \u2208 A \u2192 \u2200 \u2983x\u2082 : E\u2984, x\u2082 \u2208 A \u2192 x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x \u2227 x\u2082 = x"}, {"line": "refine fun x\u2081 hx\u2081 x\u2082 hx\u2082 hx \u21a6 \u27e8Hx x\u2081 hx\u2081 x\u2082 hx\u2082 hx, Hx x\u2082 hx\u2082 x\u2081 hx\u2081 ?_\u27e9", "tactic_state": "case right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nA : Set E\nx : E\nhxA : x \u2208 A\nHx : \u2200 x\u2081 \u2208 A, \u2200 x\u2082 \u2208 A, x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082 \u2192 x\u2081 = x\nx\u2081 : E\nhx\u2081 : x\u2081 \u2208 A\nx\u2082 : E\nhx\u2082 : x\u2082 \u2208 A\nhx : x \u2208 openSegment \ud835\udd5c x\u2081 x\u2082\n\u22a2 x \u2208 openSegment \ud835\udd5c x\u2082 x\u2081"}, {"line": "rwa [openSegment_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_lt_of_gauge_lt (absorbs : Absorbent \u211d s) (h : gauge s x < a) :\n    \u2203 b, 0 < b \u2227 b < a \u2227 x \u2208 b \u2022 s := by\n  obtain \u27e8b, \u27e8hb, hx\u27e9, hba\u27e9 := exists_lt_of_csInf_lt absorbs.gauge_set_nonempty h\n  exact \u27e8b, hb, hba, hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nx : E\na : \u211d\nabsorbs : Absorbent \u211d s\nh : gauge s x < a\n\u22a2 \u2203 b, 0 < b \u2227 b < a \u2227 x \u2208 b \u2022 s"}, {"line": "obtain \u27e8b, \u27e8hb, hx\u27e9, hba\u27e9 := exists_lt_of_csInf_lt absorbs.gauge_set_nonempty h", "tactic_state": "case intro.intro.intro\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nx : E\na : \u211d\nabsorbs : Absorbent \u211d s\nh : gauge s x < a\nb : \u211d\nhba : b < a\nhb : 0 < b\nhx : x \u2208 b \u2022 s\n\u22a2 \u2203 b, 0 < b \u2227 b < a \u2227 x \u2208 b \u2022 s"}, {"line": "exact \u27e8b, hb, hba, hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_zero : gauge s 0 = 0 := by\n  rw [gauge_def']\n  by_cases h : (0 : E) \u2208 s\n  \u00b7 simp only [smul_zero, sep_true, h, csInf_Ioi]\n  \u00b7 simp only [smul_zero, sep_false, h, Real.sInf_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\n\u22a2 gauge s 0 = 0"}, {"line": "rw [gauge_def']", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\n\u22a2 sInf {r | r \u2208 Ioi 0 \u2227 r\u207b\u00b9 \u2022 0 \u2208 s} = 0"}, {"line": "by_cases h : (0 : E) \u2208 s", "tactic_state": "case pos\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nh : sorry \u2208 s\n\u22a2 sInf {r | r \u2208 Ioi 0 \u2227 r\u207b\u00b9 \u2022 0 \u2208 s} = 0\n---\ncase neg\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nh : sorry \u2209 s\n\u22a2 sInf {r | r \u2208 Ioi 0 \u2227 r\u207b\u00b9 \u2022 0 \u2208 s} = 0"}, {"line": "\u00b7 simp only [smul_zero, sep_true, h, csInf_Ioi]", "tactic_state": "case neg\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nh : sorry \u2209 s\n\u22a2 sInf {r | r \u2208 Ioi 0 \u2227 r\u207b\u00b9 \u2022 0 \u2208 s} = 0"}, {"line": "\u00b7 simp only [smul_zero, sep_false, h, Real.sInf_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_of_subset_zero (h : s \u2286 0) : gauge s = 0 := by\n  obtain rfl | rfl := subset_singleton_iff_eq.1 h\n  exacts [gauge_empty, gauge_zero']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nh : s \u2286 0\n\u22a2 gauge s = 0"}, {"line": "obtain rfl | rfl := subset_singleton_iff_eq.1 h", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\nh : \u2205 \u2286 0\n\u22a2 gauge \u2205 = 0\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\nh : {0} \u2286 0\n\u22a2 gauge {0} = 0"}, {"line": "exacts [gauge_empty, gauge_zero']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_neg (symmetric : \u2200 x \u2208 s, -x \u2208 s) (x : E) : gauge s (-x) = gauge s x := by\n  have : \u2200 x, -x \u2208 s \u2194 x \u2208 s := fun x => \u27e8fun h => by simpa using symmetric _ h, symmetric x\u27e9\n  simp_rw [gauge_def', smul_neg, this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nsymmetric : \u2200 x \u2208 s, -x \u2208 s\nx : E\n\u22a2 gauge s (-x) = gauge s x"}, {"line": "have : \u2200 x, -x \u2208 s \u2194 x \u2208 s := fun x => \u27e8fun h => by simpa using symmetric _ h, symmetric x\u27e9", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nsymmetric : \u2200 x \u2208 s, -x \u2208 s\nx : E\nthis : \u2200 (x : E), -x \u2208 s \u2194 x \u2208 s\n\u22a2 gauge s (-x) = gauge s x"}, {"line": "simp_rw [gauge_def', smul_neg, this]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_lt_eq' (absorbs : Absorbent \u211d s) (a : \u211d) :\n    { x | gauge s x < a } = \u22c3 (r : \u211d) (_ : 0 < r) (_ : r < a), r \u2022 s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop]\n  exact\n    \u27e8exists_lt_of_gauge_lt absorbs, fun \u27e8r, hr\u2080, hr\u2081, hx\u27e9 =>\n      (gauge_le_of_mem hr\u2080.le hx).trans_lt hr\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\n\u22a2 {x | gauge s x < a} = \u22c3 r, \u22c3 (_ : 0 < r), \u22c3 (_ : r < a), r \u2022 s"}, {"line": "ext", "tactic_state": "case h\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 {x | gauge s x < a} \u2194 x\u271d \u2208 \u22c3 r, \u22c3 (_ : 0 < r), \u22c3 (_ : r < a), r \u2022 s"}, {"line": "simp_rw [mem_setOf, mem_iUnion, exists_prop]", "tactic_state": "case h\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\nx\u271d : E\n\u22a2 gauge s x\u271d < a \u2194 \u2203 i, 0 < i \u2227 i < a \u2227 x\u271d \u2208 i \u2022 s"}, {"line": "exact\n    \u27e8exists_lt_of_gauge_lt absorbs, fun \u27e8r, hr\u2080, hr\u2081, hx\u27e9 =>\n      (gauge_le_of_mem hr\u2080.le hx).trans_lt hr\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gauge_lt_eq (absorbs : Absorbent \u211d s) (a : \u211d) :\n    { x | gauge s x < a } = \u22c3 r \u2208 Set.Ioo 0 (a : \u211d), r \u2022 s := by\n  ext\n  simp_rw [mem_setOf, mem_iUnion, exists_prop, mem_Ioo, and_assoc]\n  exact\n    \u27e8exists_lt_of_gauge_lt absorbs, fun \u27e8r, hr\u2080, hr\u2081, hx\u27e9 =>\n      (gauge_le_of_mem hr\u2080.le hx).trans_lt hr\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\n\u22a2 {x | gauge s x < a} = \u22c3 r \u2208 Ioo 0 a, r \u2022 s"}, {"line": "ext", "tactic_state": "case h\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 {x | gauge s x < a} \u2194 x\u271d \u2208 \u22c3 r \u2208 Ioo 0 a, r \u2022 s"}, {"line": "simp_rw [mem_setOf, mem_iUnion, exists_prop, mem_Ioo, and_assoc]", "tactic_state": "case h\nE : Type u_2\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nabsorbs : Absorbent \u211d s\na : \u211d\nx\u271d : E\n\u22a2 gauge s x\u271d < a \u2194 \u2203 i, 0 < i \u2227 i < a \u2227 x\u271d \u2208 i \u2022 s"}, {"line": "exact\n    \u27e8exists_lt_of_gauge_lt absorbs, fun \u27e8r, hr\u2080, hr\u2081, hx\u27e9 =>\n      (gauge_le_of_mem hr\u2080.le hx).trans_lt hr\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_gauge_nhds_zero_nhdsGE (hs : s \u2208 \ud835\udcdd 0) : Tendsto (gauge s) (\ud835\udcdd 0) (\ud835\udcdd[\u2265] 0) := by\n  refine nhdsGE_basis_Icc.tendsto_right_iff.2 fun \u03b5 h\u03b5 \u21a6 ?_\n  rw [\u2190 set_smul_mem_nhds_zero_iff h\u03b5.ne'] at hs\n  filter_upwards [hs] with x hx\n  exact \u27e8gauge_nonneg _, gauge_le_of_mem h\u03b5.le hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal", "Filter", "Filter in"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[RCLike \ud835\udd5c] [Module \ud835\udd5c E] [IsScalarTower \u211d \ud835\udd5c E]", "[TopologicalSpace E]", "[T1Space E]", "[TopologicalSpace E] [ContinuousSMul \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u22a2 Tendsto (gauge s) (nhds 0) (nhdsWithin 0 (Ici 0))"}, {"line": "refine nhdsGE_basis_Icc.tendsto_right_iff.2 fun \u03b5 h\u03b5 \u21a6 ?_", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in nhds 0, gauge s x \u2208 Icc 0 \u03b5"}, {"line": "rw [\u2190 set_smul_mem_nhds_zero_iff h\u03b5.ne'] at hs", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs\u271d : s \u2208 nhds 0\n\u03b5 : \u211d\nhs : \u03b5 \u2022 s \u2208 nhds 0\nh\u03b5 : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : E) in nhds 0, gauge s x \u2208 Icc 0 \u03b5\n---\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 DistribMulAction \u211d E\n---\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 ContinuousConstSMul \u211d E"}, {"line": "filter_upwards [hs] with x hx", "tactic_state": "case h\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs\u271d : s \u2208 nhds 0\n\u03b5 : \u211d\nhs : \u03b5 \u2022 s \u2208 nhds 0\nh\u03b5 : 0 < \u03b5\nx : E\nhx : x \u2208 ?m.39511\n\u22a2 gauge s x \u2208 Icc 0 \u03b5\n---\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 DistribMulAction \u211d E\n---\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 ContinuousConstSMul \u211d E"}, {"line": "exact \u27e8gauge_nonneg _, gauge_le_of_mem h\u03b5.le hx\u27e9", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 DistribMulAction \u211d E\n---\nE : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\n\u22a2 ContinuousConstSMul \u211d E"}]}
{"declaration": "theorem continuousAt_gauge_zero (hs : s \u2208 \ud835\udcdd 0) : ContinuousAt (gauge s) 0 := by\n  rw [ContinuousAt]\n  rw [gauge_zero]\n  exact tendsto_gauge_nhds_zero hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal", "Filter", "Filter in"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[RCLike \ud835\udd5c] [Module \ud835\udd5c E] [IsScalarTower \u211d \ud835\udd5c E]", "[TopologicalSpace E]", "[T1Space E]", "[TopologicalSpace E] [ContinuousSMul \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u22a2 ContinuousAt (gauge s) 0"}, {"line": "rw [ContinuousAt]", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u22a2 Tendsto (gauge s) (nhds 0) (nhds (gauge s 0))"}, {"line": "rw [gauge_zero]", "tactic_state": "E : Type u_2\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : T1Space E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ContinuousSMul \u211d E\nhs : s \u2208 nhds 0\n\u22a2 Tendsto (gauge s) (nhds 0) (nhds 0)"}, {"line": "exact tendsto_gauge_nhds_zero hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gaugeSeminorm_ball_one (hs : IsOpen s) : (gaugeSeminorm hs\u2080 hs\u2081 hs\u2082).ball 0 1 = s := by\n  rw [Seminorm.ball_zero_eq]\n  exact gauge_lt_one_eq_self_of_isOpen hs\u2081 hs\u2082.zero_mem hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Gauge.lean", "context": {"open": ["NormedField Set", "scoped Pointwise Topology NNReal", "Filter", "Filter in", "Filter"], "variables": ["{\ud835\udd5c E : Type*}", "[AddCommGroup E] [Module \u211d E]", "{s t : Set E} {x : E} {a : \u211d}", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[RCLike \ud835\udd5c] [Module \ud835\udd5c E] [IsScalarTower \u211d \ud835\udd5c E]", "[TopologicalSpace E]", "[T1Space E]", "[TopologicalSpace E] [ContinuousSMul \u211d E]", "[TopologicalSpace E] [IsTopologicalAddGroup E] [ContinuousSMul \u211d E]", "[RCLike \ud835\udd5c] [Module \ud835\udd5c E] [IsScalarTower \u211d \ud835\udd5c E]", "{hs\u2080 : Balanced \ud835\udd5c s} {hs\u2081 : Convex \u211d s} {hs\u2082 : Absorbent \u211d s} [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : AddCommGroup E\ninst\u271d\u00b9\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b9\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : IsScalarTower \u211d \ud835\udd5c E\ninst\u271d\u00b9\u2070 : TopologicalSpace E\ninst\u271d\u2079 : T1Space E\ninst\u271d\u2078 : TopologicalSpace E\ninst\u271d\u2077 : ContinuousSMul \u211d E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : IsTopologicalAddGroup E\ninst\u271d\u2074 : ContinuousSMul \u211d E\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : IsScalarTower \u211d \ud835\udd5c E\nhs\u2080 : Balanced \ud835\udd5c s\nhs\u2081 : Convex \u211d s\nhs\u2082 : Absorbent \u211d s\ninst\u271d : TopologicalSpace E\nhs : IsOpen s\n\u22a2 (gaugeSeminorm hs\u2080 hs\u2081 hs\u2082).ball 0 1 = s"}, {"line": "rw [Seminorm.ball_zero_eq]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : AddCommGroup E\ninst\u271d\u00b9\u2074 : Module \u211d E\ns : Set E\ninst\u271d\u00b9\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : IsScalarTower \u211d \ud835\udd5c E\ninst\u271d\u00b9\u2070 : TopologicalSpace E\ninst\u271d\u2079 : T1Space E\ninst\u271d\u2078 : TopologicalSpace E\ninst\u271d\u2077 : ContinuousSMul \u211d E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : IsTopologicalAddGroup E\ninst\u271d\u2074 : ContinuousSMul \u211d E\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : IsScalarTower \u211d \ud835\udd5c E\nhs\u2080 : Balanced \ud835\udd5c s\nhs\u2081 : Convex \u211d s\nhs\u2082 : Absorbent \u211d s\ninst\u271d : TopologicalSpace E\nhs : IsOpen s\n\u22a2 {y | (gaugeSeminorm hs\u2080 hs\u2081 hs\u2082) y < 1} = s"}, {"line": "exact gauge_lt_one_eq_self_of_isOpen hs\u2081 hs\u2082.zero_mem hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexHull_eq_iInter : convexHull \ud835\udd5c s = \u22c2 (t : Set E) (_ : s \u2286 t) (_ : Convex \ud835\udd5c t), t := by\n  simp [convexHull, iInter_subtype, iInter_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Hull.lean", "context": {"open": ["Set", "Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "(\ud835\udd5c)", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(s : Set E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 (convexHull \ud835\udd5c) s = \u22c2 t, \u22c2 (_ : s \u2286 t), \u22c2 (_ : Convex \ud835\udd5c t), t"}, {"line": "simp [convexHull, iInter_subtype, iInter_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_convexHull_iff : x \u2208 convexHull \ud835\udd5c s \u2194 \u2200 t, s \u2286 t \u2192 Convex \ud835\udd5c t \u2192 x \u2208 t := by\n  simp_rw [convexHull_eq_iInter, mem_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Hull.lean", "context": {"open": ["Set", "Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "(\ud835\udd5c)", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(s : Set E)", "{\ud835\udd5c s} {t : Set E} {x y : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\nx : E\n\u22a2 x \u2208 (convexHull \ud835\udd5c) s \u2194 \u2200 (t : Set E), s \u2286 t \u2192 Convex \ud835\udd5c t \u2192 x \u2208 t"}, {"line": "simp_rw [convexHull_eq_iInter, mem_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexHull_empty_iff : convexHull \ud835\udd5c s = \u2205 \u2194 s = \u2205 := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 Set.subset_empty_iff]\n    rw [\u2190 h]\n    exact subset_convexHull \ud835\udd5c _\n  \u00b7 rintro rfl\n    exact convexHull_empty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Hull.lean", "context": {"open": ["Set", "Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "(\ud835\udd5c)", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(s : Set E)", "{\ud835\udd5c s} {t : Set E} {x y : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 (convexHull \ud835\udd5c) s = \u2205 \u2194 s = \u2205"}, {"line": "constructor", "tactic_state": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 (convexHull \ud835\udd5c) s = \u2205 \u2192 s = \u2205\n---\ncase mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 s = \u2205 \u2192 (convexHull \ud835\udd5c) s = \u2205"}, {"line": "\u00b7 intro h\n    rw [\u2190 Set.subset_empty_iff]\n    rw [\u2190 h]\n    exact subset_convexHull \ud835\udd5c _", "tactic_state": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 s = \u2205 \u2192 (convexHull \ud835\udd5c) s = \u2205"}, {"line": "\u00b7 rintro rfl\n    exact convexHull_empty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexHull_nonempty_iff : (convexHull \ud835\udd5c s).Nonempty \u2194 s.Nonempty := by\n  rw [nonempty_iff_ne_empty]\n  rw [nonempty_iff_ne_empty]\n  rw [Ne]\n  rw [Ne]\n  exact not_congr convexHull_empty_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Hull.lean", "context": {"open": ["Set", "Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "(\ud835\udd5c)", "[AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(s : Set E)", "{\ud835\udd5c s} {t : Set E} {x y : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 ((convexHull \ud835\udd5c) s).Nonempty \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 (convexHull \ud835\udd5c) s \u2260 \u2205 \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 (convexHull \ud835\udd5c) s \u2260 \u2205 \u2194 s \u2260 \u2205"}, {"line": "rw [Ne]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 \u00ac(convexHull \ud835\udd5c) s = \u2205 \u2194 s \u2260 \u2205"}, {"line": "rw [Ne]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\ns : Set E\n\u22a2 \u00ac(convexHull \ud835\udd5c) s = \u2205 \u2194 \u00acs = \u2205"}, {"line": "exact not_congr convexHull_empty_iff", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem ConvexIndependent.injective {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p) :\n    Function.Injective p := by\n  refine fun i j hij => hc {j} i ?_\n  rw [hij]\n  rw [Set.image_singleton]\n  rw [convexHull_singleton]\n  exact Set.mem_singleton _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Independent.lean", "context": {"open": ["Affine Finset Function"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\n\u22a2 Injective p"}, {"line": "refine fun i j hij => hc {j} i ?_", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ni j : \u03b9\nhij : p i = p j\n\u22a2 p i \u2208 (convexHull \ud835\udd5c) (p '' {j})"}, {"line": "rw [hij]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ni j : \u03b9\nhij : p i = p j\n\u22a2 p j \u2208 (convexHull \ud835\udd5c) (p '' {j})"}, {"line": "rw [Set.image_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ni j : \u03b9\nhij : p i = p j\n\u22a2 p j \u2208 (convexHull \ud835\udd5c) {p j}"}, {"line": "rw [convexHull_singleton]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ni j : \u03b9\nhij : p i = p j\n\u22a2 p j \u2208 {p j}"}, {"line": "exact Set.mem_singleton _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ConvexIndependent.comp_embedding {\u03b9' : Type*} (f : \u03b9' \u21aa \u03b9) {p : \u03b9 \u2192 E}\n    (hc : ConvexIndependent \ud835\udd5c p) : ConvexIndependent \ud835\udd5c (p \u2218 f) := by\n  intro s x hx\n  rw [\u2190 f.injective.mem_set_image]\n  exact hc _ _ (by rwa [Set.image_image])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Independent.lean", "context": {"open": ["Affine Finset Function"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\n\u03b9' : Type u_4\nf : \u03b9' \u21aa \u03b9\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\n\u22a2 ConvexIndependent \ud835\udd5c (p \u2218 \u21d1f)"}, {"line": "intro s x hx", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\n\u03b9' : Type u_4\nf : \u03b9' \u21aa \u03b9\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ns : Set \u03b9'\nx : \u03b9'\nhx : (p \u2218 \u21d1f) x \u2208 (convexHull \ud835\udd5c) (p \u2218 \u21d1f '' s)\n\u22a2 x \u2208 s"}, {"line": "rw [\u2190 f.injective.mem_set_image]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\n\u03b9' : Type u_4\nf : \u03b9' \u21aa \u03b9\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\ns : Set \u03b9'\nx : \u03b9'\nhx : (p \u2218 \u21d1f) x \u2208 (convexHull \ud835\udd5c) (p \u2218 \u21d1f '' s)\n\u22a2 f x \u2208 \u21d1f '' s"}, {"line": "exact hc _ _ (by rwa [Set.image_image])", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem ConvexIndependent.range {p : \u03b9 \u2192 E} (hc : ConvexIndependent \ud835\udd5c p) :\n    ConvexIndependent \ud835\udd5c ((\u2191) : Set.range p \u2192 E) := by\n  let f : Set.range p \u2192 \u03b9 := fun x => x.property.choose\n  have hf : \u2200 x, p (f x) = x := fun x => x.property.choose_spec\n  let fe : Set.range p \u21aa \u03b9 := \u27e8f, fun x\u2081 x\u2082 he => Subtype.ext (hf x\u2081 \u25b8 hf x\u2082 \u25b8 he \u25b8 rfl)\u27e9\n  convert hc.comp_embedding fe\n  ext\n  rw [Embedding.coeFn_mk]\n  rw [comp_apply]\n  rw [hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Independent.lean", "context": {"open": ["Affine Finset Function"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "(\ud835\udd5c) [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\n\u22a2 ConvexIndependent \ud835\udd5c Subtype.val"}, {"line": "let f : Set.range p \u2192 \u03b9 := fun x => x.property.choose", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\n\u22a2 ConvexIndependent \ud835\udd5c Subtype.val"}, {"line": "have hf : \u2200 x, p (f x) = x := fun x => x.property.choose_spec", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\n\u22a2 ConvexIndependent \ud835\udd5c Subtype.val"}, {"line": "let fe : Set.range p \u21aa \u03b9 := \u27e8f, fun x\u2081 x\u2082 he => Subtype.ext (hf x\u2081 \u25b8 hf x\u2082 \u25b8 he \u25b8 rfl)\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\n\u22a2 ConvexIndependent \ud835\udd5c Subtype.val"}, {"line": "convert hc.comp_embedding fe", "tactic_state": "case h.e'_8\n\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\n\u22a2 Subtype.val = p \u2218 \u21d1fe"}, {"line": "ext", "tactic_state": "case h.e'_8.h\n\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\nx\u271d : { x // x \u2208 Set.range p }\n\u22a2 \u2191x\u271d = (p \u2218 \u21d1fe) x\u271d"}, {"line": "rw [Embedding.coeFn_mk]", "tactic_state": "case h.e'_8.h\n\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\nx\u271d : { x // x \u2208 Set.range p }\n\u22a2 \u2191x\u271d = (p \u2218 f) x\u271d"}, {"line": "rw [comp_apply]", "tactic_state": "case h.e'_8.h\n\ud835\udd5c : Type u_1\nE : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \ud835\udd5c E\np : \u03b9 \u2192 E\nhc : ConvexIndependent \ud835\udd5c p\nf : \u2191(Set.range p) \u2192 \u03b9 := fun x => Exists.choose \u22ef\nhf : \u2200 (x : \u2191(Set.range p)), p (f x) = \u2191x\nfe : \u2191(Set.range p) \u21aa \u03b9 := { toFun := f, inj' := \u22ef }\nx\u271d : { x // x \u2208 Set.range p }\n\u22a2 \u2191x\u271d = p (f x\u271d)"}, {"line": "rw [hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ConvexOn.average_mem_epigraph [IsFiniteMeasure \u03bc] [NeZero \u03bc] (hg : ConvexOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s)\n    (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    (\u2a0d x, f x \u2202\u03bc, \u2a0d x, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 g p.1 \u2264 p.2} := by\n  have ht_mem : \u2200\u1d50 x \u2202\u03bc, (f x, g (f x)) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 g p.1 \u2264 p.2} :=\n    hfs.mono fun x hx => \u27e8hx, le_rfl\u27e9\n  exact average_pair hfi hgi \u25b8\n    hg.convex_epigraph.average_mem (hsc.epigraph hgc) ht_mem (hfi.prodMk hgi)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Integral.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\n\u03b1\u271d : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set E\ng : E \u2192 \u211d\nf : \u03b1\u271d \u2192 E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : NeZero \u03bc\nhg : ConvexOn \u211d s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : \u2200\u1d50 (x : \u03b1\u271d) \u2202\u03bc, f x \u2208 s\nhfi : Integrable f \u03bc\nhgi : Integrable (g \u2218 f) \u03bc\n\u22a2 (\u2a0d (x : \u03b1\u271d), f x \u2202\u03bc, \u2a0d (x : \u03b1\u271d), g (f x) \u2202\u03bc) \u2208 {p | p.1 \u2208 s \u2227 g p.1 \u2264 p.2}"}, {"line": "have ht_mem : \u2200\u1d50 x \u2202\u03bc, (f x, g (f x)) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 g p.1 \u2264 p.2} :=\n    hfs.mono fun x hx => \u27e8hx, le_rfl\u27e9", "tactic_state": "E : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\n\u03b1\u271d : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set E\ng : E \u2192 \u211d\nf : \u03b1\u271d \u2192 E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : NeZero \u03bc\nhg : ConvexOn \u211d s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : \u2200\u1d50 (x : \u03b1\u271d) \u2202\u03bc, f x \u2208 s\nhfi : Integrable f \u03bc\nhgi : Integrable (g \u2218 f) \u03bc\nht_mem : \u2200\u1d50 (x : \u03b1\u271d) \u2202\u03bc, (f x, g (f x)) \u2208 {p | p.1 \u2208 s \u2227 g p.1 \u2264 p.2}\n\u22a2 (\u2a0d (x : \u03b1\u271d), f x \u2202\u03bc, \u2a0d (x : \u03b1\u271d), g (f x) \u2202\u03bc) \u2208 {p | p.1 \u2208 s \u2227 g p.1 \u2264 p.2}"}, {"line": "exact average_pair hfi hgi \u25b8\n    hg.convex_epigraph.average_mem (hsc.epigraph hgc) ht_mem (hfi.prodMk hgi)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ConcaveOn.average_mem_hypograph [IsFiniteMeasure \u03bc] [NeZero \u03bc] (hg : ConcaveOn \u211d s g)\n    (hgc : ContinuousOn g s) (hsc : IsClosed s) (hfs : \u2200\u1d50 x \u2202\u03bc, f x \u2208 s)\n    (hfi : Integrable f \u03bc) (hgi : Integrable (g \u2218 f) \u03bc) :\n    (\u2a0d x, f x \u2202\u03bc, \u2a0d x, g (f x) \u2202\u03bc) \u2208 {p : E \u00d7 \u211d | p.1 \u2208 s \u2227 p.2 \u2264 g p.1} := by\n  simpa only [mem_setOf_eq,Pi.neg_apply,average_neg,neg_le_neg_iff] using\n    hg.neg.average_mem_epigraph hgc.neg hsc hfs hfi hgi.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Integral.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\n\u03b1\u271d : Type u_3\ninst\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set E\ng : E \u2192 \u211d\nf : \u03b1\u271d \u2192 E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : NeZero \u03bc\nhg : ConcaveOn \u211d s g\nhgc : ContinuousOn g s\nhsc : IsClosed s\nhfs : \u2200\u1d50 (x : \u03b1\u271d) \u2202\u03bc, f x \u2208 s\nhfi : Integrable f \u03bc\nhgi : Integrable (g \u2218 f) \u03bc\n\u22a2 (\u2a0d (x : \u03b1\u271d), f x \u2202\u03bc, \u2a0d (x : \u03b1\u271d), g (f x) \u2202\u03bc) \u2208 {p | p.1 \u2208 s \u2227 p.2 \u2264 g p.1}"}, {"line": "simpa only [mem_setOf_eq,Pi.neg_apply,average_neg,neg_le_neg_iff] using\n    hg.neg.average_mem_epigraph hgc.neg hsc hfs hfi hgi.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem segment_subset_Icc (h : x \u2264 y) : [x -[\ud835\udd5c] y] \u2286 Icc x y := by\n  rintro z \u27e8a, b, ha, hb, hab, rfl\u27e9\n  constructor\n  \u00b7 calc\n      x = a \u2022 x + b \u2022 x := (Convex.combo_self hab _).symm\n      _ \u2264 a \u2022 x + b \u2022 y := by gcongr\n  \u00b7 calc\n      a \u2022 x + b \u2022 y \u2264 a \u2022 y + b \u2022 y := by gcongr\n      _ = y := Convex.combo_self hab _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2075 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u00b3 : AddCommMonoid E\ninst\u271d\u00b3\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u2070 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2\u2079 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2077 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b3 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u00b2 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2078 : AddCommGroup E\ninst\u271d\u00b9\u2077 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : Field \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : PartialOrder E\ninst\u271d\u00b2 : IsOrderedAddMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nh : x \u2264 y\n\u22a2 segment \ud835\udd5c x y \u2286 Icc x y"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2075 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u00b3 : AddCommMonoid E\ninst\u271d\u00b3\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u2070 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2\u2079 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2077 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b3 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u00b2 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2078 : AddCommGroup E\ninst\u271d\u00b9\u2077 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : Field \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : PartialOrder E\ninst\u271d\u00b2 : IsOrderedAddMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 Icc x y"}, {"line": "constructor", "tactic_state": "case intro.intro.intro.intro.intro.left\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2075 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u00b3 : AddCommMonoid E\ninst\u271d\u00b3\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u2070 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2\u2079 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2077 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b3 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u00b2 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2078 : AddCommGroup E\ninst\u271d\u00b9\u2077 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : Field \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : PartialOrder E\ninst\u271d\u00b2 : IsOrderedAddMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 x \u2264 a \u2022 x + b \u2022 y\n---\ncase intro.intro.intro.intro.intro.right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2075 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u00b3 : AddCommMonoid E\ninst\u271d\u00b3\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u2070 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2\u2079 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2077 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b3 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u00b2 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2078 : AddCommGroup E\ninst\u271d\u00b9\u2077 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : Field \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : PartialOrder E\ninst\u271d\u00b2 : IsOrderedAddMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2264 y"}, {"line": "\u00b7 calc\n      x = a \u2022 x + b \u2022 x := (Convex.combo_self hab _).symm\n      _ \u2264 a \u2022 x + b \u2022 y := by gcongr", "tactic_state": "case intro.intro.intro.intro.intro.right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2075 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u00b3 : AddCommMonoid E\ninst\u271d\u00b3\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u2070 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2\u2079 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2077 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b3 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u00b2 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2078 : AddCommGroup E\ninst\u271d\u00b9\u2077 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : Field \ud835\udd5c\ninst\u271d\u00b9\u2070 : LinearOrder \ud835\udd5c\ninst\u271d\u2079 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : AddCommMonoid E\ninst\u271d\u00b3 : PartialOrder E\ninst\u271d\u00b2 : IsOrderedAddMonoid E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : OrderedSMul \ud835\udd5c E\nh : x \u2264 y\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2264 y"}, {"line": "\u00b7 calc\n      a \u2022 x + b \u2022 y \u2264 a \u2022 y + b \u2022 y := by gcongr\n      _ = y := Convex.combo_self hab _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem openSegment_subset_Ioo (h : x < y) : openSegment \ud835\udd5c x y \u2286 Ioo x y := by\n  rintro z \u27e8a, b, ha, hb, hab, rfl\u27e9\n  constructor\n  \u00b7 calc\n      x = a \u2022 x + b \u2022 x := (Convex.combo_self hab _).symm\n      _ < a \u2022 x + b \u2022 y := by gcongr\n  \u00b7 calc\n      a \u2022 x + b \u2022 y < a \u2022 y + b \u2022 y := by gcongr\n      _ = y := Convex.combo_self hab _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2078 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : AddCommMonoid E\ninst\u271d\u00b3\u2075 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b3\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b9 : Module \ud835\udd5c E\ninst\u271d\u00b3\u2070 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2078 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2076 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2075 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b2\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommGroup E\ninst\u271d\u00b2\u2070 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2079 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2074 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u2077 : AddCommMonoid E\ninst\u271d\u2076 : PartialOrder E\ninst\u271d\u2075 : IsOrderedAddMonoid E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : PartialOrder E\ninst\u271d : IsOrderedCancelAddMonoid E\nh : x < y\n\u22a2 openSegment \ud835\udd5c x y \u2286 Ioo x y"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2078 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : AddCommMonoid E\ninst\u271d\u00b3\u2075 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b3\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b9 : Module \ud835\udd5c E\ninst\u271d\u00b3\u2070 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2078 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2076 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2075 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b2\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommGroup E\ninst\u271d\u00b2\u2070 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2079 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2074 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u2077 : AddCommMonoid E\ninst\u271d\u2076 : PartialOrder E\ninst\u271d\u2075 : IsOrderedAddMonoid E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : PartialOrder E\ninst\u271d : IsOrderedCancelAddMonoid E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 Ioo x y"}, {"line": "constructor", "tactic_state": "case intro.intro.intro.intro.intro.left\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2078 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : AddCommMonoid E\ninst\u271d\u00b3\u2075 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b3\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b9 : Module \ud835\udd5c E\ninst\u271d\u00b3\u2070 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2078 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2076 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2075 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b2\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommGroup E\ninst\u271d\u00b2\u2070 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2079 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2074 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u2077 : AddCommMonoid E\ninst\u271d\u2076 : PartialOrder E\ninst\u271d\u2075 : IsOrderedAddMonoid E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : PartialOrder E\ninst\u271d : IsOrderedCancelAddMonoid E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 x < a \u2022 x + b \u2022 y\n---\ncase intro.intro.intro.intro.intro.right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2078 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : AddCommMonoid E\ninst\u271d\u00b3\u2075 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b3\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b9 : Module \ud835\udd5c E\ninst\u271d\u00b3\u2070 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2078 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2076 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2075 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b2\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommGroup E\ninst\u271d\u00b2\u2070 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2079 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2074 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u2077 : AddCommMonoid E\ninst\u271d\u2076 : PartialOrder E\ninst\u271d\u2075 : IsOrderedAddMonoid E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : PartialOrder E\ninst\u271d : IsOrderedCancelAddMonoid E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y < y"}, {"line": "\u00b7 calc\n      x = a \u2022 x + b \u2022 x := (Convex.combo_self hab _).symm\n      _ < a \u2022 x + b \u2022 y := by gcongr", "tactic_state": "case intro.intro.intro.intro.intro.right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3\u2078 : Semiring \ud835\udd5c\ninst\u271d\u00b3\u2077 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : AddCommMonoid E\ninst\u271d\u00b3\u2075 : SMul \ud835\udd5c E\ninst\u271d\u00b3\u2074 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b3\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b3\u00b9 : Module \ud835\udd5c E\ninst\u271d\u00b3\u2070 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2078 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u2077 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2076 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2075 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2\u2074 : Ring \ud835\udd5c\ninst\u271d\u00b2\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommGroup E\ninst\u271d\u00b2\u2070 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2079 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2074 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\nx y : E\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u2077 : AddCommMonoid E\ninst\u271d\u2076 : PartialOrder E\ninst\u271d\u2075 : IsOrderedAddMonoid E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : PartialOrder E\ninst\u271d : IsOrderedCancelAddMonoid E\nh : x < y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y < y"}, {"line": "\u00b7 calc\n      a \u2022 x + b \u2022 y < a \u2022 y + b \u2022 y := by gcongr\n      _ = y := Convex.combo_self hab _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem segment_subset (x y : E \u00d7 F) : segment \ud835\udd5c x y \u2286 segment \ud835\udd5c x.1 y.1 \u00d7\u02e2 segment \ud835\udd5c x.2 y.2 := by\n  rintro z \u27e8a, b, ha, hb, hab, hz\u27e9\n  exact \u27e8\u27e8a, b, ha, hb, hab, congr_arg Prod.fst hz\u27e9, a, b, ha, hb, hab, congr_arg Prod.snd hz\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y : E \u00d7 F\n\u22a2 segment \ud835\udd5c x y \u2286 segment \ud835\udd5c x.1 y.1 \u00d7\u02e2 segment \ud835\udd5c x.2 y.2"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, hz\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z : E \u00d7 F\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhz : a \u2022 x + b \u2022 y = z\n\u22a2 z \u2208 segment \ud835\udd5c x.1 y.1 \u00d7\u02e2 segment \ud835\udd5c x.2 y.2"}, {"line": "exact \u27e8\u27e8a, b, ha, hb, hab, congr_arg Prod.fst hz\u27e9, a, b, ha, hb, hab, congr_arg Prod.snd hz\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem openSegment_subset (x y : E \u00d7 F) :\n    openSegment \ud835\udd5c x y \u2286 openSegment \ud835\udd5c x.1 y.1 \u00d7\u02e2 openSegment \ud835\udd5c x.2 y.2 := by\n  rintro z \u27e8a, b, ha, hb, hab, hz\u27e9\n  exact \u27e8\u27e8a, b, ha, hb, hab, congr_arg Prod.fst hz\u27e9, a, b, ha, hb, hab, congr_arg Prod.snd hz\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y : E \u00d7 F\n\u22a2 openSegment \ud835\udd5c x y \u2286 openSegment \ud835\udd5c x.1 y.1 \u00d7\u02e2 openSegment \ud835\udd5c x.2 y.2"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, hz\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx y z : E \u00d7 F\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhz : a \u2022 x + b \u2022 y = z\n\u22a2 z \u2208 openSegment \ud835\udd5c x.1 y.1 \u00d7\u02e2 openSegment \ud835\udd5c x.2 y.2"}, {"line": "exact \u27e8\u27e8a, b, ha, hb, hab, congr_arg Prod.fst hz\u27e9, a, b, ha, hb, hab, congr_arg Prod.snd hz\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_mk_segment_left (x\u2081 x\u2082 : E) (y : F) :\n    (fun x => (x, y)) '' [x\u2081 -[\ud835\udd5c] x\u2082] = [(x\u2081, y) -[\ud835\udd5c] (x\u2082, y)] := by\n  rw [segment_eq_image\u2082]\n  rw [segment_eq_image\u2082]\n  rw [image_image]\n  refine EqOn.image_eq fun a ha \u21a6 ?_\n  simp [Convex.combo_self ha.2.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' segment \ud835\udd5c x\u2081 x\u2082 = segment \ud835\udd5c (x\u2081, y) (x\u2082, y)"}, {"line": "rw [segment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' ((fun p => p.1 \u2022 x\u2081 + p.2 \u2022 x\u2082) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}) =\n    segment \ud835\udd5c (x\u2081, y) (x\u2082, y)"}, {"line": "rw [segment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' ((fun p => p.1 \u2022 x\u2081 + p.2 \u2022 x\u2082) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}) =\n    (fun p => p.1 \u2022 (x\u2081, y) + p.2 \u2022 (x\u2082, y)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "rw [image_image]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x.1 \u2022 x\u2081 + x.2 \u2022 x\u2082, y)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1} =\n    (fun p => p.1 \u2022 (x\u2081, y) + p.2 \u2022 (x\u2082, y)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "refine EqOn.image_eq fun a ha \u21a6 ?_", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 (a.1 \u2022 x\u2081 + a.2 \u2022 x\u2082, y) = a.1 \u2022 (x\u2081, y) + a.2 \u2022 (x\u2082, y)"}, {"line": "simp [Convex.combo_self ha.2.2]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 y = a.1 \u2022 y + a.2 \u2022 y"}]}
{"declaration": "theorem image_mk_segment_right (x : E) (y\u2081 y\u2082 : F) :\n    (fun y => (x, y)) '' [y\u2081 -[\ud835\udd5c] y\u2082] = [(x, y\u2081) -[\ud835\udd5c] (x, y\u2082)] := by\n  rw [segment_eq_image\u2082]\n  rw [segment_eq_image\u2082]\n  rw [image_image]\n  refine EqOn.image_eq fun a ha \u21a6 ?_\n  simp [Convex.combo_self ha.2.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' segment \ud835\udd5c y\u2081 y\u2082 = segment \ud835\udd5c (x, y\u2081) (x, y\u2082)"}, {"line": "rw [segment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' ((fun p => p.1 \u2022 y\u2081 + p.2 \u2022 y\u2082) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}) =\n    segment \ud835\udd5c (x, y\u2081) (x, y\u2082)"}, {"line": "rw [segment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' ((fun p => p.1 \u2022 y\u2081 + p.2 \u2022 y\u2082) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}) =\n    (fun p => p.1 \u2022 (x, y\u2081) + p.2 \u2022 (x, y\u2082)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "rw [image_image]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun x_1 => (x, x_1.1 \u2022 y\u2081 + x_1.2 \u2022 y\u2082)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1} =\n    (fun p => p.1 \u2022 (x, y\u2081) + p.2 \u2022 (x, y\u2082)) '' {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "refine EqOn.image_eq fun a ha \u21a6 ?_", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 (x, a.1 \u2022 y\u2081 + a.2 \u2022 y\u2082) = a.1 \u2022 (x, y\u2081) + a.2 \u2022 (x, y\u2082)"}, {"line": "simp [Convex.combo_self ha.2.2]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 \u2264 p.1 \u2227 0 \u2264 p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 x = a.1 \u2022 x + a.2 \u2022 x"}]}
{"declaration": "theorem image_mk_openSegment_left (x\u2081 x\u2082 : E) (y : F) :\n    (fun x => (x, y)) '' openSegment \ud835\udd5c x\u2081 x\u2082 = openSegment \ud835\udd5c (x\u2081, y) (x\u2082, y) := by\n  rw [openSegment_eq_image\u2082]\n  rw [openSegment_eq_image\u2082]\n  rw [image_image]\n  refine EqOn.image_eq fun a ha \u21a6 ?_\n  simp [Convex.combo_self ha.2.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' openSegment \ud835\udd5c x\u2081 x\u2082 = openSegment \ud835\udd5c (x\u2081, y) (x\u2082, y)"}, {"line": "rw [openSegment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' ((fun p => p.1 \u2022 x\u2081 + p.2 \u2022 x\u2082) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}) =\n    openSegment \ud835\udd5c (x\u2081, y) (x\u2082, y)"}, {"line": "rw [openSegment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x, y)) '' ((fun p => p.1 \u2022 x\u2081 + p.2 \u2022 x\u2082) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}) =\n    (fun p => p.1 \u2022 (x\u2081, y) + p.2 \u2022 (x\u2082, y)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "rw [image_image]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\n\u22a2 (fun x => (x.1 \u2022 x\u2081 + x.2 \u2022 x\u2082, y)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1} =\n    (fun p => p.1 \u2022 (x\u2081, y) + p.2 \u2022 (x\u2082, y)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "refine EqOn.image_eq fun a ha \u21a6 ?_", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 (a.1 \u2022 x\u2081 + a.2 \u2022 x\u2082, y) = a.1 \u2022 (x\u2081, y) + a.2 \u2022 (x\u2082, y)"}, {"line": "simp [Convex.combo_self ha.2.2]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx\u2081 x\u2082 : E\ny : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 y = a.1 \u2022 y + a.2 \u2022 y"}]}
{"declaration": "theorem image_mk_openSegment_right (x : E) (y\u2081 y\u2082 : F) :\n    (fun y => (x, y)) '' openSegment \ud835\udd5c y\u2081 y\u2082 = openSegment \ud835\udd5c (x, y\u2081) (x, y\u2082) := by\n  rw [openSegment_eq_image\u2082]\n  rw [openSegment_eq_image\u2082]\n  rw [image_image]\n  refine EqOn.image_eq fun a ha \u21a6 ?_\n  simp [Convex.combo_self ha.2.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' openSegment \ud835\udd5c y\u2081 y\u2082 = openSegment \ud835\udd5c (x, y\u2081) (x, y\u2082)"}, {"line": "rw [openSegment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' ((fun p => p.1 \u2022 y\u2081 + p.2 \u2022 y\u2082) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}) =\n    openSegment \ud835\udd5c (x, y\u2081) (x, y\u2082)"}, {"line": "rw [openSegment_eq_image\u2082]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun y => (x, y)) '' ((fun p => p.1 \u2022 y\u2081 + p.2 \u2022 y\u2082) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}) =\n    (fun p => p.1 \u2022 (x, y\u2081) + p.2 \u2022 (x, y\u2082)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "rw [image_image]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\n\u22a2 (fun x_1 => (x, x_1.1 \u2022 y\u2081 + x_1.2 \u2022 y\u2082)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1} =\n    (fun p => p.1 \u2022 (x, y\u2081) + p.2 \u2022 (x, y\u2082)) '' {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}"}, {"line": "refine EqOn.image_eq fun a ha \u21a6 ?_", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 (x, a.1 \u2022 y\u2081 + a.2 \u2022 y\u2082) = a.1 \u2022 (x, y\u2081) + a.2 \u2022 (x, y\u2082)"}, {"line": "simp [Convex.combo_self ha.2.2]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2075\u00b2 : Semiring \ud835\udd5c\ninst\u271d\u2075\u00b9 : PartialOrder \ud835\udd5c\ninst\u271d\u2075\u2070 : AddCommMonoid E\ninst\u271d\u2074\u2079 : SMul \ud835\udd5c E\ninst\u271d\u2074\u2078 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2077 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u2074\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074\u2074 : Ring \ud835\udd5c\ninst\u271d\u2074\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u2074\u00b2 : AddRightMono \ud835\udd5c\ninst\u271d\u2074\u00b9 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u2074\u2070 : Nontrivial \ud835\udd5c\ninst\u271d\u00b3\u2079 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b3\u2078 : Ring \ud835\udd5c\ninst\u271d\u00b3\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2075 : AddCommGroup E\ninst\u271d\u00b3\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3\u00b3 : Semifield \ud835\udd5c\ninst\u271d\u00b3\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b3\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3\u2070 : AddCommGroup E\ninst\u271d\u00b2\u2079 : Module \ud835\udd5c E\ninst\u271d\u00b2\u2078 : Field \ud835\udd5c\ninst\u271d\u00b2\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b2\u2075 : AddCommGroup E\ninst\u271d\u00b2\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b2\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b9 : AddCommMonoid E\ninst\u271d\u00b2\u2070 : PartialOrder E\ninst\u271d\u00b9\u2079 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2078 : Module \ud835\udd5c E\ninst\u271d\u00b9\u2077 : OrderedSMul \ud835\udd5c E\ninst\u271d\u00b9\u2076 : AddCommMonoid E\ninst\u271d\u00b9\u2075 : PartialOrder E\ninst\u271d\u00b9\u2074 : IsOrderedCancelAddMonoid E\ninst\u271d\u00b9\u00b3 : AddCommMonoid E\ninst\u271d\u00b9\u00b2 : LinearOrder E\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\ninst\u271d\u00b9\u2070 : Module \ud835\udd5c E\ninst\u271d\u2079 : OrderedSMul \ud835\udd5c E\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ny\u2081 y\u2082 : F\na : \ud835\udd5c \u00d7 \ud835\udd5c\nha : a \u2208 {p | 0 < p.1 \u2227 0 < p.2 \u2227 p.1 + p.2 = 1}\n\u22a2 x = a.1 \u2022 x + a.2 \u2022 x"}]}
{"declaration": "theorem segment_subset (x y : \u2200 i, M i) : segment \ud835\udd5c x y \u2286 s.pi fun i => segment \ud835\udd5c (x i) (y i) := by\n  rintro z \u27e8a, b, ha, hb, hab, hz\u27e9 i -\n  exact \u27e8a, b, ha, hb, hab, congr_fun hz i\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module \ud835\udd5c (M i)] {s : Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\u03b9 : Type u_5\nM : \u03b9 \u2192 Type u_6\ninst\u271d\u00b2\u2079 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2075 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b3 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2070 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b9\u2079 : Ring \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d : (i : \u03b9) \u2192 Module \ud835\udd5c (M i)\ns : Set \u03b9\nx y : (i : \u03b9) \u2192 M i\n\u22a2 segment \ud835\udd5c x y \u2286 s.pi fun i => segment \ud835\udd5c (x i) (y i)"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, hz\u27e9 i -", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_5\nM : \u03b9 \u2192 Type u_6\ninst\u271d\u00b2\u2079 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2075 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b3 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2070 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b9\u2079 : Ring \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d : (i : \u03b9) \u2192 Module \ud835\udd5c (M i)\ns : Set \u03b9\nx y z : (i : \u03b9) \u2192 M i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nhz : a \u2022 x + b \u2022 y = z\ni : \u03b9\n\u22a2 z i \u2208 (fun i => segment \ud835\udd5c (x i) (y i)) i"}, {"line": "exact \u27e8a, b, ha, hb, hab, congr_fun hz i\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem openSegment_subset (x y : \u2200 i, M i) :\n    openSegment \ud835\udd5c x y \u2286 s.pi fun i => openSegment \ud835\udd5c (x i) (y i) := by\n  rintro z \u27e8a, b, ha, hb, hab, hz\u27e9 i -\n  exact \u27e8a, b, ha, hb, hab, congr_fun hz i\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Segment.lean", "context": {"open": ["Function Set", "Pointwise Convex", "Convex", "Convex", "AffineMap"], "variables": ["{\ud835\udd5c E F G \u03b9 : Type*} {M : \u03b9 \u2192 Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s : Set E} {x y : E}", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [MulActionWithZero \ud835\udd5c E]", "(\ud835\udd5c)", "[ZeroLEOneClass \ud835\udd5c] [Module \ud835\udd5c E] {s : Set E} {x y z : E}", "{\ud835\udd5c}", "(\ud835\udd5c) [Ring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddRightMono \ud835\udd5c]", "[ZeroLEOneClass \ud835\udd5c] [Nontrivial \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y : E}", "[Semifield \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {x y z : E}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[AddCommMonoid E] [PartialOrder E] [IsOrderedCancelAddMonoid E]", "[AddCommMonoid E] [LinearOrder E] [IsOrderedAddMonoid E] [Module \ud835\udd5c E] [OrderedSMul \ud835\udd5c E]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] {x y z : \ud835\udd5c}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module \ud835\udd5c (M i)] {s : Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\u03b9 : Type u_5\nM : \u03b9 \u2192 Type u_6\ninst\u271d\u00b2\u2079 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2075 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b3 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2070 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b9\u2079 : Ring \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d : (i : \u03b9) \u2192 Module \ud835\udd5c (M i)\ns : Set \u03b9\nx y : (i : \u03b9) \u2192 M i\n\u22a2 openSegment \ud835\udd5c x y \u2286 s.pi fun i => openSegment \ud835\udd5c (x i) (y i)"}, {"line": "rintro z \u27e8a, b, ha, hb, hab, hz\u27e9 i -", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_5\nM : \u03b9 \u2192 Type u_6\ninst\u271d\u00b2\u2079 : Semiring \ud835\udd5c\ninst\u271d\u00b2\u2078 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u2077 inst\u271d\u00b2\u2076 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u2075 : Ring \ud835\udd5c\ninst\u271d\u00b2\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2\u00b3 : AddRightMono \ud835\udd5c\ninst\u271d\u00b2\u00b2 : ZeroLEOneClass \ud835\udd5c\ninst\u271d\u00b2\u00b9 : Nontrivial \ud835\udd5c\ninst\u271d\u00b2\u2070 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b9\u2079 : Ring \ud835\udd5c\ninst\u271d\u00b9\u2078 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2077 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2076 : Semifield \ud835\udd5c\ninst\u271d\u00b9\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u00b3 : Field \ud835\udd5c\ninst\u271d\u00b9\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9\u00b9 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : Semiring \ud835\udd5c\ninst\u271d\u2079 : PartialOrder \ud835\udd5c\ninst\u271d\u2078 : Field \ud835\udd5c\ninst\u271d\u2077 : LinearOrder \ud835\udd5c\ninst\u271d\u2076 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2075 : Semiring \ud835\udd5c\ninst\u271d\u2074 : PartialOrder \ud835\udd5c\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d : (i : \u03b9) \u2192 Module \ud835\udd5c (M i)\ns : Set \u03b9\nx y z : (i : \u03b9) \u2192 M i\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhz : a \u2022 x + b \u2022 y = z\ni : \u03b9\n\u22a2 z i \u2208 (fun i => openSegment \ud835\udd5c (x i) (y i)) i"}, {"line": "exact \u27e8a, b, ha, hb, hab, congr_fun hz i\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem starConvex_iff_segment_subset : StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y\u2984, y \u2208 s \u2192 [x -[\ud835\udd5c] y] \u2286 s := by\n  constructor\n  \u00b7 rintro h y hy z \u27e8a, b, ha, hb, hab, rfl\u27e9\n    exact h hy ha hb hab\n  \u00b7 rintro h y hy a b ha hb hab\n    exact h hy \u27e8a, b, ha, hb, hab, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 segment \ud835\udd5c x y \u2286 s"}, {"line": "constructor", "tactic_state": "case mp\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2192 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 segment \ud835\udd5c x y \u2286 s\n---\ncase mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 (\u2200 \u2983y : E\u2984, y \u2208 s \u2192 segment \ud835\udd5c x y \u2286 s) \u2192 StarConvex \ud835\udd5c x s"}, {"line": "\u00b7 rintro h y hy z \u27e8a, b, ha, hb, hab, rfl\u27e9\n    exact h hy ha hb hab", "tactic_state": "case mpr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 (\u2200 \u2983y : E\u2984, y \u2208 s \u2192 segment \ud835\udd5c x y \u2286 s) \u2192 StarConvex \ud835\udd5c x s"}, {"line": "\u00b7 rintro h y hy a b ha hb hab\n    exact h hy \u27e8a, b, ha, hb, hab, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem starConvex_iff_pointwise_add_subset :\n    StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 {x} + b \u2022 s \u2286 s := by\n  refine\n    \u27e8?_, fun h y hy a b ha hb hab =>\n      h ha hb hab (add_mem_add (smul_mem_smul_set <| mem_singleton _) \u27e8_, hy, rfl\u27e9)\u27e9\n  rintro hA a b ha hb hab w \u27e8au, \u27e8u, rfl : u = x, rfl\u27e9, bv, \u27e8v, hv, rfl\u27e9, rfl\u27e9\n  exact hA hv ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2194 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 {x} + b \u2022 s \u2286 s"}, {"line": "refine\n    \u27e8?_, fun h y hy a b ha hb hab =>\n      h ha hb hab (add_mem_add (smul_mem_smul_set <| mem_singleton _) \u27e8_, hy, rfl\u27e9)\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns : Set E\n\u22a2 StarConvex \ud835\udd5c x s \u2192 \u2200 \u2983a b : \ud835\udd5c\u2984, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 {x} + b \u2022 s \u2286 s"}, {"line": "rintro hA a b ha hb hab w \u27e8au, \u27e8u, rfl : u = x, rfl\u27e9, bv, \u27e8v, hv, rfl\u27e9, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\nu : E\nhA : StarConvex \ud835\udd5c u s\nv : E\nhv : v \u2208 s\n\u22a2 (fun x1 x2 => x1 + x2) ((fun x => a \u2022 x) u) ((fun x => b \u2022 x) v) \u2208 s"}, {"line": "exact hA hv ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StarConvex.union (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c x t) :\n    StarConvex \ud835\udd5c x (s \u222a t) := by\n  rintro y (hy | hy) a b ha hb hab\n  \u00b7 exact Or.inl (hs hy ha hb hab)\n  \u00b7 exact Or.inr (ht hy ha hb hab)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c x t\n\u22a2 StarConvex \ud835\udd5c x (s \u222a t)"}, {"line": "rintro y (hy | hy) a b ha hb hab", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c x t\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s \u222a t\n---\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c x t\ny : E\nhy : y \u2208 t\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s \u222a t"}, {"line": "\u00b7 exact Or.inl (hs hy ha hb hab)", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c x t\ny : E\nhy : y \u2208 t\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 s \u222a t"}, {"line": "\u00b7 exact Or.inr (ht hy ha hb hab)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem starConvex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hs : \u2200 i, StarConvex \ud835\udd5c x (s i)) :\n    StarConvex \ud835\udd5c x (\u22c3 i, s i) := by\n  rintro y hy a b ha hb hab\n  rw [mem_iUnion] at hy \u22a2\n  obtain \u27e8i, hy\u27e9 := hy\n  exact \u27e8i, hs i hy ha hb hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 Set E\nhs : \u2200 (i : \u03b9), StarConvex \ud835\udd5c x (s i)\n\u22a2 StarConvex \ud835\udd5c x (\u22c3 i, s i)"}, {"line": "rintro y hy a b ha hb hab", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 Set E\nhs : \u2200 (i : \u03b9), StarConvex \ud835\udd5c x (s i)\ny : E\nhy : y \u2208 \u22c3 i, s i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 \u22c3 i, s i"}, {"line": "rw [mem_iUnion] at hy \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 Set E\nhs : \u2200 (i : \u03b9), StarConvex \ud835\udd5c x (s i)\ny : E\nhy : \u2203 i, y \u2208 s i\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "obtain \u27e8i, hy\u27e9 := hy", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\n\u03b9 : Sort u_4\ns : \u03b9 \u2192 Set E\nhs : \u2200 (i : \u03b9), StarConvex \ud835\udd5c x (s i)\ny : E\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\ni : \u03b9\nhy : y \u2208 s i\n\u22a2 \u2203 i, a \u2022 x + b \u2022 y \u2208 s i"}, {"line": "exact \u27e8i, hs i hy ha hb hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem starConvex_sUnion {S : Set (Set E)} (hS : \u2200 s \u2208 S, StarConvex \ud835\udd5c x s) :\n    StarConvex \ud835\udd5c x (\u22c3\u2080 S) := by\n  rw [sUnion_eq_iUnion]\n  exact starConvex_iUnion fun s => hS _ s.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\nS : Set (Set E)\nhS : \u2200 s \u2208 S, StarConvex \ud835\udd5c x s\n\u22a2 StarConvex \ud835\udd5c x (\u22c3\u2080 S)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : Semiring \ud835\udd5c\ninst\u271d\u00b2 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\nS : Set (Set E)\nhS : \u2200 s \u2208 S, StarConvex \ud835\udd5c x s\n\u22a2 StarConvex \ud835\udd5c x (\u22c3 i, \u2191i)"}, {"line": "exact starConvex_iUnion fun s => hS _ s.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem starConvex_singleton (x : E) : StarConvex \ud835\udd5c x {x} := by\n  rintro y (rfl : y = x) a b _ _ hab\n  exact Convex.combo_self hab _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {x y z : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\nx : E\n\u22a2 StarConvex \ud835\udd5c x {x}"}, {"line": "rintro y (rfl : y = x) a b _ _ hab", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\ny : E\na b : \ud835\udd5c\na\u271d\u00b9 : 0 \u2264 a\na\u271d : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 y + b \u2022 y \u2208 {y}"}, {"line": "exact Convex.combo_self hab _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StarConvex.linear_image (hs : StarConvex \ud835\udd5c x s) (f : E \u2192\u2097[\ud835\udd5c] F) :\n    StarConvex \ud835\udd5c (f x) (f '' s) := by\n  rintro _ \u27e8y, hy, rfl\u27e9 a b ha hb hab\n  exact \u27e8a \u2022 x + b \u2022 y, hs hy ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {x y z : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : Semiring \ud835\udd5c\ninst\u271d\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : AddCommMonoid F\ninst\u271d\u00b3 : SMul \ud835\udd5c E\ninst\u271d\u00b2 : SMul \ud835\udd5c F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nf : E \u2192\u2097[\ud835\udd5c] F\n\u22a2 StarConvex \ud835\udd5c (f x) (\u21d1f '' s)"}, {"line": "rintro _ \u27e8y, hy, rfl\u27e9 a b ha hb hab", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : Semiring \ud835\udd5c\ninst\u271d\u2076 : PartialOrder \ud835\udd5c\ninst\u271d\u2075 : AddCommMonoid E\ninst\u271d\u2074 : AddCommMonoid F\ninst\u271d\u00b3 : SMul \ud835\udd5c E\ninst\u271d\u00b2 : SMul \ud835\udd5c F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nx : E\ns : Set E\nhs : StarConvex \ud835\udd5c x s\nf : E \u2192\u2097[\ud835\udd5c] F\ny : E\nhy : y \u2208 s\na b : \ud835\udd5c\nha : 0 \u2264 a\nhb : 0 \u2264 b\nhab : a + b = 1\n\u22a2 a \u2022 f x + b \u2022 f y \u2208 \u21d1f '' s"}, {"line": "exact \u27e8a \u2022 x + b \u2022 y, hs hy ha hb hab, by rw [f.map_add, f.map_smul, f.map_smul]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StarConvex.add {t : Set E} (hs : StarConvex \ud835\udd5c x s) (ht : StarConvex \ud835\udd5c y t) :\n    StarConvex \ud835\udd5c (x + y) (s + t) := by\n  rw [\u2190 add_image_prod]\n  exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Star.lean", "context": {"open": ["Set", "Convex Pointwise"], "variables": ["{\ud835\udd5c E F : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[AddCommMonoid E] [AddCommMonoid F]", "(\ud835\udd5c) [SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (x : E) (s : Set E)", "{\ud835\udd5c x s} {t : Set E}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {x y z : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\nx y : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c y t\n\u22a2 StarConvex \ud835\udd5c (x + y) (s + t)"}, {"line": "rw [\u2190 add_image_prod]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : AddCommMonoid E\ninst\u271d\u00b9 : SMul \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c E\nx y : E\ns t : Set E\nhs : StarConvex \ud835\udd5c x s\nht : StarConvex \ud835\udd5c y t\n\u22a2 StarConvex \ud835\udd5c (x + y) ((fun x => x.1 + x.2) '' s \u00d7\u02e2 t)"}, {"line": "exact (hs.prod ht).is_linear_image IsLinearMap.isLinearMap_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictConvex_univ : StrictConvex \ud835\udd5c (univ : Set E) := by\n  intro x _ y _ _ a b _ _ _\n  rw [interior_univ]\n  exact mem_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u22a2 StrictConvex \ud835\udd5c univ"}, {"line": "intro x _ y _ _ a b _ _ _", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\na\u271d\u2075 : x \u2208 univ\ny : E\na\u271d\u2074 : y \u2208 univ\na\u271d\u00b3 : x \u2260 y\na b : \ud835\udd5c\na\u271d\u00b2 : 0 < a\na\u271d\u00b9 : 0 < b\na\u271d : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior univ"}, {"line": "rw [interior_univ]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nx : E\na\u271d\u2075 : x \u2208 univ\ny : E\na\u271d\u2074 : y \u2208 univ\na\u271d\u00b3 : x \u2260 y\na b : \ud835\udd5c\na\u271d\u00b2 : 0 < a\na\u271d\u00b9 : 0 < b\na\u271d : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 univ"}, {"line": "exact mem_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem StrictConvex.inter {t : Set E} (hs : StrictConvex \ud835\udd5c s) (ht : StrictConvex \ud835\udd5c t) :\n    StrictConvex \ud835\udd5c (s \u2229 t) := by\n  intro x hx y hy hxy a b ha hb hab\n  rw [interior_inter]\n  exact \u27e8hs hx.1 hy.1 hxy ha hb hab, ht hx.2 hy.2 hxy ha hb hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhs : StrictConvex \ud835\udd5c s\nht : StrictConvex \ud835\udd5c t\n\u22a2 StrictConvex \ud835\udd5c (s \u2229 t)"}, {"line": "intro x hx y hy hxy a b ha hb hab", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhs : StrictConvex \ud835\udd5c s\nht : StrictConvex \ud835\udd5c t\nx : E\nhx : x \u2208 s \u2229 t\ny : E\nhy : y \u2208 s \u2229 t\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (s \u2229 t)"}, {"line": "rw [interior_inter]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhs : StrictConvex \ud835\udd5c s\nht : StrictConvex \ud835\udd5c t\nx : E\nhx : x \u2208 s \u2229 t\ny : E\nhy : y \u2208 s \u2229 t\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior s \u2229 interior t"}, {"line": "exact \u27e8hs hx.1 hy.1 hxy ha hb hab, ht hx.2 hy.2 hxy ha hb hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Directed.strictConvex_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n    (hs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)) : StrictConvex \ud835\udd5c (\u22c3 i, s i) := by\n  rintro x hx y hy hxy a b ha hb hab\n  rw [mem_iUnion] at hx hy\n  obtain \u27e8i, hx\u27e9 := hx\n  obtain \u27e8j, hy\u27e9 := hy\n  obtain \u27e8k, hik, hjk\u27e9 := hdir i j\n  exact interior_mono (subset_iUnion s k) (hs (hik hx) (hjk hy) hxy ha hb hab)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\n\u22a2 StrictConvex \ud835\udd5c (\u22c3 i, s i)"}, {"line": "rintro x hx y hy hxy a b ha hb hab", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\nx : E\nhx : x \u2208 \u22c3 i, s i\ny : E\nhy : y \u2208 \u22c3 i, s i\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (\u22c3 i, s i)"}, {"line": "rw [mem_iUnion] at hx hy", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\nx : E\nhx : \u2203 i, x \u2208 s i\ny : E\nhy : \u2203 i, y \u2208 s i\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (\u22c3 i, s i)"}, {"line": "obtain \u27e8i, hx\u27e9 := hx", "tactic_state": "case intro\n\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\nx y : E\nhy : \u2203 i, y \u2208 s i\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (\u22c3 i, s i)"}, {"line": "obtain \u27e8j, hy\u27e9 := hy", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\nx y : E\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (\u22c3 i, s i)"}, {"line": "obtain \u27e8k, hik, hjk\u27e9 := hdir i j", "tactic_state": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_6\ns : \u03b9 \u2192 Set E\nhdir : Directed (fun x1 x2 => x1 \u2286 x2) s\nhs : \u2200 \u2983i : \u03b9\u2984, StrictConvex \ud835\udd5c (s i)\nx y : E\nhxy : x \u2260 y\na b : \ud835\udd5c\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\nk : \u03b9\nhik : s i \u2286 s k\nhjk : s j \u2286 s k\n\u22a2 a \u2022 x + b \u2022 y \u2208 interior (\u22c3 i, s i)"}, {"line": "exact interior_mono (subset_iUnion s k) (hs (hik hx) (hjk hy) hxy ha hb hab)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectedOn.strictConvex_sUnion {S : Set (Set E)} (hdir : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (hS : \u2200 s \u2208 S, StrictConvex \ud835\udd5c s) : StrictConvex \ud835\udd5c (\u22c3\u2080 S) := by\n  rw [sUnion_eq_iUnion]\n  exact (directedOn_iff_directed.1 hdir).strictConvex_iUnion fun s => hS _ s.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nS : Set (Set E)\nhdir : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nhS : \u2200 s \u2208 S, StrictConvex \ud835\udd5c s\n\u22a2 StrictConvex \ud835\udd5c (\u22c3\u2080 S)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\nS : Set (Set E)\nhdir : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nhS : \u2200 s \u2208 S, StrictConvex \ud835\udd5c s\n\u22a2 StrictConvex \ud835\udd5c (\u22c3 i, \u2191i)"}, {"line": "exact (directedOn_iff_directed.1 hdir).strictConvex_iUnion fun s => hS _ s.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrictConvex.add_left (hs : StrictConvex \ud835\udd5c s) (z : E) :\n    StrictConvex \ud835\udd5c ((fun x => z + x) '' s) := by\n  simpa only [singleton_add] using (strictConvex_singleton z).add hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[TopologicalSpace \u03b2] [AddCommMonoid \u03b2] [LinearOrder \u03b2] [IsOrderedCancelAddMonoid \u03b2]", "[AddCancelCommMonoid E] [ContinuousAdd E] [Module \ud835\udd5c E] {s : Set E}", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "[ContinuousAdd E] {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_3\ninst\u271d\u00b9\u00b9 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u2070 : PartialOrder \ud835\udd5c\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : AddCommMonoid E\ninst\u271d\u2077 : SMul \ud835\udd5c E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : AddCancelCommMonoid E\ninst\u271d\u2074 : ContinuousAdd E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : ContinuousAdd E\ns : Set E\nhs : StrictConvex \ud835\udd5c s\nz : E\n\u22a2 StrictConvex \ud835\udd5c ((fun x => z + x) '' s)"}, {"line": "simpa only [singleton_add] using (strictConvex_singleton z).add hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem StrictConvex.smul (hs : StrictConvex \ud835\udd5c s) (c : \ud835\udd5d) : StrictConvex \ud835\udd5c (c \u2022 s) := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 exact (subsingleton_zero_smul_set _).strictConvex\n  \u00b7 exact hs.linear_image (LinearMap.lsmul _ _ c) (isOpenMap_smul\u2080 hc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Strict.lean", "context": {"open": ["Set", "Convex Pointwise", "Function Set", "Convex"], "variables": ["{\ud835\udd5c \ud835\udd5d E F \u03b2 : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [TopologicalSpace E] [TopologicalSpace F]", "[AddCommMonoid E] [AddCommMonoid F]", "[SMul \ud835\udd5c E] [SMul \ud835\udd5c F] (s : Set E)", "{s}", "{x y : E} {a b : \ud835\udd5c}", "[Module \ud835\udd5c E] [Module \ud835\udd5c F] {s : Set E}", "[TopologicalSpace \u03b2] [AddCommMonoid \u03b2] [LinearOrder \u03b2] [IsOrderedCancelAddMonoid \u03b2]", "[AddCancelCommMonoid E] [ContinuousAdd E] [Module \ud835\udd5c E] {s : Set E}", "[AddCommGroup E] [AddCommGroup F] [Module \ud835\udd5c E] [Module \ud835\udd5c F]", "[ContinuousAdd E] {s t : Set E}", "[Field \ud835\udd5d] [Module \ud835\udd5d E] [ContinuousConstSMul \ud835\udd5d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5d : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommMonoid E\ninst\u271d\u00b9\u2070 : SMul \ud835\udd5c E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : AddCancelCommMonoid E\ninst\u271d\u2077 : ContinuousAdd E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : ContinuousAdd E\ns : Set E\ninst\u271d\u00b2 : Field \ud835\udd5d\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : ContinuousConstSMul \ud835\udd5d E\nhs : StrictConvex \ud835\udd5c s\nc : \ud835\udd5d\n\u22a2 StrictConvex \ud835\udd5c (c \u2022 s)"}, {"line": "obtain rfl | hc := eq_or_ne c 0", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\n\ud835\udd5d : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommMonoid E\ninst\u271d\u00b9\u2070 : SMul \ud835\udd5c E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : AddCancelCommMonoid E\ninst\u271d\u2077 : ContinuousAdd E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : ContinuousAdd E\ns : Set E\ninst\u271d\u00b2 : Field \ud835\udd5d\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : ContinuousConstSMul \ud835\udd5d E\nhs : StrictConvex \ud835\udd5c s\n\u22a2 StrictConvex \ud835\udd5c (sorry \u2022 s)\n---\ncase inr\n\ud835\udd5c : Type u_1\n\ud835\udd5d : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommMonoid E\ninst\u271d\u00b9\u2070 : SMul \ud835\udd5c E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : AddCancelCommMonoid E\ninst\u271d\u2077 : ContinuousAdd E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : ContinuousAdd E\ns : Set E\ninst\u271d\u00b2 : Field \ud835\udd5d\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : ContinuousConstSMul \ud835\udd5d E\nhs : StrictConvex \ud835\udd5c s\nc : \ud835\udd5d\nhc : c \u2260 sorry\n\u22a2 StrictConvex \ud835\udd5c (c \u2022 s)"}, {"line": "\u00b7 exact (subsingleton_zero_smul_set _).strictConvex", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\n\ud835\udd5d : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b9\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommMonoid E\ninst\u271d\u00b9\u2070 : SMul \ud835\udd5c E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : AddCancelCommMonoid E\ninst\u271d\u2077 : ContinuousAdd E\ninst\u271d\u2076 : Module \ud835\udd5c E\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : ContinuousAdd E\ns : Set E\ninst\u271d\u00b2 : Field \ud835\udd5d\ninst\u271d\u00b9 : Module \ud835\udd5d E\ninst\u271d : ContinuousConstSMul \ud835\udd5d E\nhs : StrictConvex \ud835\udd5c s\nc : \ud835\udd5d\nhc : c \u2260 sorry\n\u22a2 StrictConvex \ud835\udd5c (c \u2022 s)"}, {"line": "\u00b7 exact hs.linear_image (LinearMap.lsmul _ _ c) (isOpenMap_smul\u2080 hc)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Collinear.sbtw_of_dist_eq_of_dist_lt {p p\u2081 p\u2082 p\u2083 : P} {r : \u211d}\n    (h : Collinear \u211d ({p\u2081, p\u2082, p\u2083} : Set P)) (hp\u2081 : dist p\u2081 p = r) (hp\u2082 : dist p\u2082 p < r)\n    (hp\u2083 : dist p\u2083 p = r) (hp\u2081p\u2083 : p\u2081 \u2260 p\u2083) : Sbtw \u211d p\u2081 p\u2082 p\u2083 := by\n  refine \u27e8h.wbtw_of_dist_eq_of_dist_le hp\u2081 hp\u2082.le hp\u2083 hp\u2081p\u2083, ?_, ?_\u27e9\n  \u00b7 rintro rfl\n    exact hp\u2082.ne hp\u2081\n  \u00b7 rintro rfl\n    exact hp\u2082.ne hp\u2083\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/StrictConvexBetween.lean", "context": {"open": ["Metric", "scoped Convex"], "variables": ["{V P : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]", "[StrictConvexSpace \u211d V]", "[PseudoMetricSpace P] [NormedAddTorsor V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : NormedSpace \u211d V\ninst\u271d\u00b2 : StrictConvexSpace \u211d V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np p\u2081 p\u2082 p\u2083 : P\nr : \u211d\nh : Collinear \u211d {p\u2081, p\u2082, p\u2083}\nhp\u2081 : dist p\u2081 p = r\nhp\u2082 : dist p\u2082 p < r\nhp\u2083 : dist p\u2083 p = r\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\n\u22a2 Sbtw \u211d p\u2081 p\u2082 p\u2083"}, {"line": "refine \u27e8h.wbtw_of_dist_eq_of_dist_le hp\u2081 hp\u2082.le hp\u2083 hp\u2081p\u2083, ?_, ?_\u27e9", "tactic_state": "case refine_1\nV : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : NormedSpace \u211d V\ninst\u271d\u00b2 : StrictConvexSpace \u211d V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np p\u2081 p\u2082 p\u2083 : P\nr : \u211d\nh : Collinear \u211d {p\u2081, p\u2082, p\u2083}\nhp\u2081 : dist p\u2081 p = r\nhp\u2082 : dist p\u2082 p < r\nhp\u2083 : dist p\u2083 p = r\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\n\u22a2 p\u2082 \u2260 p\u2081\n---\ncase refine_2\nV : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : NormedSpace \u211d V\ninst\u271d\u00b2 : StrictConvexSpace \u211d V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np p\u2081 p\u2082 p\u2083 : P\nr : \u211d\nh : Collinear \u211d {p\u2081, p\u2082, p\u2083}\nhp\u2081 : dist p\u2081 p = r\nhp\u2082 : dist p\u2082 p < r\nhp\u2083 : dist p\u2083 p = r\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\n\u22a2 p\u2082 \u2260 p\u2083"}, {"line": "\u00b7 rintro rfl\n    exact hp\u2082.ne hp\u2081", "tactic_state": "case refine_2\nV : Type u_1\nP : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup V\ninst\u271d\u00b3 : NormedSpace \u211d V\ninst\u271d\u00b2 : StrictConvexSpace \u211d V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np p\u2081 p\u2082 p\u2083 : P\nr : \u211d\nh : Collinear \u211d {p\u2081, p\u2082, p\u2083}\nhp\u2081 : dist p\u2081 p = r\nhp\u2082 : dist p\u2082 p < r\nhp\u2083 : dist p\u2083 p = r\nhp\u2081p\u2083 : p\u2081 \u2260 p\u2083\n\u22a2 p\u2082 \u2260 p\u2083"}, {"line": "\u00b7 rintro rfl\n    exact hp\u2082.ne hp\u2083", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Convex.add_smul_sub_mem_interior' {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n    (hx : x \u2208 closure s) (hy : y \u2208 interior s) {t : \ud835\udd5c} (ht : t \u2208 Ioc (0 : \ud835\udd5c) 1) :\n    x + t \u2022 (y - x) \u2208 interior s := by\n  simpa only [sub_smul,smul_sub,one_smul,add_sub,add_comm] using\n    hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2)\n      (add_sub_cancel _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Topology.lean", "context": {"open": ["Metric Bornology Set Pointwise Convex"], "variables": ["{\u03b9 \ud835\udd5c E : Type*}", "{s : Set \u211d} {r \u03b5 : \u211d}", "[Fintype \u03b9]", "(\u03b9)", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c]", "[AddRightMono \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_2\nE : Type u_3\ninst\u271d\u00b9\u2070 : Ring \ud835\udd5c\ninst\u271d\u2079 : LinearOrder \ud835\udd5c\ninst\u271d\u2078 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u2077 : DenselyOrdered \ud835\udd5c\ninst\u271d\u2076 : Ring \ud835\udd5c\ninst\u271d\u2075 : LinearOrder \ud835\udd5c\ninst\u271d\u2074 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b3 : DenselyOrdered \ud835\udd5c\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : AddRightMono \ud835\udd5c\ns : Set E\nhs : sorry\nx y : E\nhx : x \u2208 sorry\nhy : y \u2208 sorry\nt : \ud835\udd5c\nht : t \u2208 Ioc 0 1\n\u22a2 sorry \u2208 sorry"}, {"line": "simpa only [sub_smul,smul_sub,one_smul,add_sub,add_comm] using\n    hs.combo_interior_closure_mem_interior hy hx ht.1 (sub_nonneg.mpr ht.2)\n      (add_sub_cancel _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Convex.isPathConnected {s : Set E} (hconv : Convex \u211d s) (hne : s.Nonempty) :\n    IsPathConnected s := by\n  refine isPathConnected_iff.mpr \u27e8hne, ?_\u27e9\n  intro x x_in y y_in\n  exact JoinedIn.of_segment_subset ((segment_subset_iff \u211d).2 (hconv x_in y_in))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Topology.lean", "context": {"open": ["Metric Bornology Set Pointwise Convex", "AffineMap", "AffineMap"], "variables": ["{\u03b9 \ud835\udd5c E : Type*}", "{s : Set \u211d} {r \u03b5 : \u211d}", "[Fintype \u03b9]", "(\u03b9)", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Ring \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [DenselyOrdered \ud835\udd5c]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c]", "[AddRightMono \ud835\udd5c]", "[IsStrictOrderedRing \ud835\udd5c]", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "(\ud835\udd5c) in", "[Field \ud835\udd5c] [LinearOrder \ud835\udd5c]", "[AddCommGroup E] [Module \u211d E] [TopologicalSpace E] [IsTopologicalAddGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : IsTopologicalAddGroup E\ns : Set E\nhconv : Convex \u211d s\nhne : s.Nonempty\n\u22a2 IsPathConnected s"}, {"line": "refine isPathConnected_iff.mpr \u27e8hne, ?_\u27e9", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : IsTopologicalAddGroup E\ns : Set E\nhconv : Convex \u211d s\nhne : s.Nonempty\n\u22a2 \u2200 x \u2208 s, \u2200 y \u2208 s, JoinedIn s x y"}, {"line": "intro x x_in y y_in", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : IsTopologicalAddGroup E\ns : Set E\nhconv : Convex \u211d s\nhne : s.Nonempty\nx : E\nx_in : x \u2208 s\ny : E\ny_in : y \u2208 s\n\u22a2 JoinedIn s x y"}, {"line": "exact JoinedIn.of_segment_subset ((segment_subset_iff \u211d).2 (hconv x_in y_in))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} (f : \u03b9 \u2192 ConvexCone \ud835\udd5c E) : \u2191(iInf f) = \u22c2 i, (f i : Set E) := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/Basic.lean", "context": {"open": ["Set LinearMap Pointwise"], "variables": ["{\ud835\udd5c E F G : Type*}", "(\ud835\udd5c E)", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c]", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c] [AddCommMonoid E]", "[SMul \ud835\udd5c E] (S T : ConvexCone \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : IsOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : SMul \ud835\udd5c E\n\u03b9 : Sort u_5\nf : \u03b9 \u2192 ConvexCone \ud835\udd5c E\n\u22a2 \u2191(iInf f) = \u22c2 i, \u2191(f i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem innerDualCone_univ : (univ : Set H).innerDualCone = 0 := by\n  suffices \u2200 x : H, x \u2208 (univ : Set H).innerDualCone \u2192 x = 0 by\n    apply SetLike.coe_injective\n    exact eq_singleton_iff_unique_mem.mpr \u27e8fun x _ => (inner_zero_right _).ge, this\u27e9\n  exact fun x hx => by simpa [\u2190 real_inner_self_nonpos] using hx (-x) (mem_univ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/InnerDual.lean", "context": {"open": ["Set LinearMap Pointwise", "RealInnerProductSpace"], "variables": ["{H : Type*} [NormedAddCommGroup H] [InnerProductSpace \u211d H] (s t : Set H)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 univ.innerDualCone = 0"}, {"line": "suffices \u2200 x : H, x \u2208 (univ : Set H).innerDualCone \u2192 x = 0 by\n    apply SetLike.coe_injective\n    exact eq_singleton_iff_unique_mem.mpr \u27e8fun x _ => (inner_zero_right _).ge, this\u27e9", "tactic_state": "case refine_4\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 \u2200 x \u2208 sorry, x = 0\n---\ncase refine_1\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 H \u2192 NormedAddCommGroup H\n---\ncase refine_2\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 (x : H) \u2192 InnerProductSpace \u211d H\n---\ncase refine_3\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 H \u2192 OfNat H 0"}, {"line": "exact fun x hx => by simpa [\u2190 real_inner_self_nonpos] using hx (-x) (mem_univ _)", "tactic_state": "case refine_1\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 H \u2192 NormedAddCommGroup H\n---\ncase refine_2\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 (x : H) \u2192 InnerProductSpace \u211d H\n---\ncase refine_3\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u22a2 H \u2192 OfNat H 0"}]}
{"declaration": "theorem innerDualCone_insert (x : H) (s : Set H) :\n    (insert x s).innerDualCone = Set.innerDualCone {x} \u2293 s.innerDualCone := by\n  rw [insert_eq]\n  rw [innerDualCone_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/InnerDual.lean", "context": {"open": ["Set LinearMap Pointwise", "RealInnerProductSpace"], "variables": ["{H : Type*} [NormedAddCommGroup H] [InnerProductSpace \u211d H] (s t : Set H)", "{s t} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\nx : H\ns : Set H\n\u22a2 (insert x s).innerDualCone = {x}.innerDualCone \u2293 s.innerDualCone"}, {"line": "rw [insert_eq]", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\nx : H\ns : Set H\n\u22a2 ({x} \u222a s).innerDualCone = {x}.innerDualCone \u2293 s.innerDualCone"}, {"line": "rw [innerDualCone_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem innerDualCone_iUnion {\u03b9 : Sort*} (f : \u03b9 \u2192 Set H) :\n    (\u22c3 i, f i).innerDualCone = \u2a05 i, (f i).innerDualCone := by\n  refine le_antisymm (le_iInf fun i x hx y hy => hx _ <| mem_iUnion_of_mem _ hy) ?_\n  intro x hx y hy\n  rw [ConvexCone.mem_iInf] at hx\n  obtain \u27e8j, hj\u27e9 := mem_iUnion.mp hy\n  exact hx _ _ hj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/InnerDual.lean", "context": {"open": ["Set LinearMap Pointwise", "RealInnerProductSpace"], "variables": ["{H : Type*} [NormedAddCommGroup H] [InnerProductSpace \u211d H] (s t : Set H)", "{s t} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 Set H\n\u22a2 (\u22c3 i, f i).innerDualCone = \u2a05 i, (f i).innerDualCone"}, {"line": "refine le_antisymm (le_iInf fun i x hx y hy => hx _ <| mem_iUnion_of_mem _ hy) ?_", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 Set H\n\u22a2 \u2a05 i, (f i).innerDualCone \u2264 (\u22c3 i, f i).innerDualCone"}, {"line": "intro x hx y hy", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 Set H\nx : H\nhx : x \u2208 \u2a05 i, (f i).innerDualCone\ny : H\nhy : y \u2208 \u22c3 i, f i\n\u22a2 0 \u2264 inner y x"}, {"line": "rw [ConvexCone.mem_iInf] at hx", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 Set H\nx : H\nhx : \u2200 (i : \u03b9), x \u2208 (f i).innerDualCone\ny : H\nhy : y \u2208 \u22c3 i, f i\n\u22a2 0 \u2264 inner y x"}, {"line": "obtain \u27e8j, hj\u27e9 := mem_iUnion.mp hy", "tactic_state": "case intro\nH : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 Set H\nx : H\nhx : \u2200 (i : \u03b9), x \u2208 (f i).innerDualCone\ny : H\nhy : y \u2208 \u22c3 i, f i\nj : \u03b9\nhj : y \u2208 f j\n\u22a2 0 \u2264 inner y x"}, {"line": "exact hx _ _ hj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem innerDualCone_sUnion (S : Set (Set H)) :\n    (\u22c3\u2080 S).innerDualCone = sInf (Set.innerDualCone '' S) := by\n  simp_rw [sInf_image, sUnion_eq_biUnion, innerDualCone_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/InnerDual.lean", "context": {"open": ["Set LinearMap Pointwise", "RealInnerProductSpace"], "variables": ["{H : Type*} [NormedAddCommGroup H] [InnerProductSpace \u211d H] (s t : Set H)", "{s t} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\nS : Set (Set H)\n\u22a2 (\u22c3\u2080 S).innerDualCone = sInf (innerDualCone '' S)"}, {"line": "simp_rw [sInf_image, sUnion_eq_biUnion, innerDualCone_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem innerDualCone_eq_iInter_innerDualCone_singleton :\n    (s.innerDualCone : Set H) = \u22c2 i : s, (({\u2191i} : Set H).innerDualCone : Set H) := by\n  rw [\u2190 ConvexCone.coe_iInf]\n  rw [\u2190 innerDualCone_iUnion]\n  rw [iUnion_of_singleton_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/InnerDual.lean", "context": {"open": ["Set LinearMap Pointwise", "RealInnerProductSpace"], "variables": ["{H : Type*} [NormedAddCommGroup H] [InnerProductSpace \u211d H] (s t : Set H)", "{s t} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\ns : Set H\n\u22a2 \u2191s.innerDualCone = \u22c2 i, \u2191{\u2191i}.innerDualCone"}, {"line": "rw [\u2190 ConvexCone.coe_iInf]", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\ns : Set H\n\u22a2 \u2191s.innerDualCone = \u2191(\u2a05 i, {\u2191i}.innerDualCone)"}, {"line": "rw [\u2190 innerDualCone_iUnion]", "tactic_state": "H : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup H\ninst\u271d : InnerProductSpace \u211d H\ns : Set H\n\u22a2 \u2191s.innerDualCone = \u2191(\u22c3 i, {\u2191i}).innerDualCone"}, {"line": "rw [iUnion_of_singleton_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toConvexCone_pointed (S : PointedCone \ud835\udd5c E) : (S : ConvexCone \ud835\udd5c E).Pointed := by\n  simp [toConvexCone, ConvexCone.Pointed]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/Pointed.lean", "context": {"open": ["Function"], "variables": ["{\ud835\udd5c E F G : Type*}", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c]", "[AddCommMonoid E] [Module \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : IsOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nS : PointedCone \ud835\udd5c E\n\u22a2 (\u2191S).Pointed"}, {"line": "simp [toConvexCone, ConvexCone.Pointed]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : Semiring \ud835\udd5c\ninst\u271d\u00b3 : PartialOrder \ud835\udd5c\ninst\u271d\u00b2 : IsOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : AddCommMonoid E\ninst\u271d : Module \ud835\udd5c E\nS : PointedCone \ud835\udd5c E\n\u22a2 0 \u2208 \u2191S"}]}
{"declaration": "theorem pointed_zero : ((0 : ProperCone \ud835\udd5c E) : ConvexCone \ud835\udd5c E).Pointed := by\n  simp [ConvexCone.pointed_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/Cone/Proper.lean", "context": {"open": ["ContinuousLinearMap Filter Set"], "variables": ["{\ud835\udd5c : Type*} [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [TopologicalSpace E] [Module \ud835\udd5c E]", "(\ud835\udd5c E)", "[Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c]", "{\ud835\udd5c : Type*} [Semiring \ud835\udd5c] [PartialOrder \ud835\udd5c] [IsOrderedRing \ud835\udd5c]", "{E : Type*} [AddCommMonoid E] [TopologicalSpace E] [T1Space E] [Module \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\ninst\u271d\u2076 : Semiring \ud835\udd5c\ninst\u271d\u2075 : PartialOrder \ud835\udd5c\ninst\u271d\u2074 : IsOrderedRing \ud835\udd5c\nE : Type u_4\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : T1Space E\ninst\u271d : Module \ud835\udd5c E\n\u22a2 (\u2191\u21910).Pointed"}, {"line": "simp [ConvexCone.pointed_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma concaveOn_rpow {p : \u211d} (hp\u2080 : 0 \u2264 p) (hp\u2081 : p \u2264 1) :\n    ConcaveOn \u211d\u22650 univ fun x : \u211d\u22650 \u21a6 x ^ p := by\n  rcases eq_or_lt_of_le hp\u2080 with (rfl | hp\u2080)\n  \u00b7 simpa only [rpow_zero] using concaveOn_const (c := 1) convex_univ\n  rcases eq_or_lt_of_le hp\u2081 with (rfl | hp\u2081)\n  \u00b7 simpa only [rpow_one] using concaveOn_id convex_univ\n  exact (strictConcaveOn_rpow hp\u2080 hp\u2081).concaveOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Pow.lean", "context": {"open": ["Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nhp\u2080 : 0 \u2264 p\nhp\u2081 : p \u2264 1\n\u22a2 ConcaveOn \u211d \u2265 sorry"}, {"line": "rcases eq_or_lt_of_le hp\u2080 with (rfl | hp\u2080)", "tactic_state": "case inl\nhp\u2080 : 0 \u2264 0\nhp\u2081 : 0 \u2264 1\n\u22a2 ConcaveOn \u211d \u2265 sorry\n---\ncase inr\np : \u211d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 ConcaveOn \u211d \u2265 sorry"}, {"line": "\u00b7 simpa only [rpow_zero] using concaveOn_const (c := 1) convex_univ", "tactic_state": "case inr\np : \u211d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 ConcaveOn \u211d \u2265 sorry"}, {"line": "rcases eq_or_lt_of_le hp\u2081 with (rfl | hp\u2081)", "tactic_state": "case inr.inl\nhp\u2080\u271d : 0 \u2264 1\nhp\u2081 : 1 \u2264 1\nhp\u2080 : 0 < 1\n\u22a2 ConcaveOn \u211d \u2265 sorry\n---\ncase inr.inr\np : \u211d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 ConcaveOn \u211d \u2265 sorry"}, {"line": "\u00b7 simpa only [rpow_one] using concaveOn_id convex_univ", "tactic_state": "case inr.inr\np : \u211d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 ConcaveOn \u211d \u2265 sorry"}, {"line": "exact (strictConcaveOn_rpow hp\u2080 hp\u2081).concaveOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_one_add_le_one_add_mul_self {s : \u211d} (hs : -1 \u2264 s) {p : \u211d} (hp1 : 0 \u2264 p) (hp2 : p \u2264 1) :\n    (1 + s) ^ p \u2264 1 + p * s := by\n  rcases eq_or_lt_of_le hp1 with (rfl | hp1)\n  \u00b7 simp\n  rcases eq_or_lt_of_le hp2 with (rfl | hp2)\n  \u00b7 simp\n  by_cases hs' : s = 0\n  \u00b7 simp [hs']\n  exact (rpow_one_add_lt_one_add_mul_self hs hs' hp1 hp2).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "context": {"open": ["Real Set NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1 : 0 \u2264 p\nhp2 : p \u2264 1\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "rcases eq_or_lt_of_le hp1 with (rfl | hp1)", "tactic_state": "case inl\ns : \u211d\nhs : -1 \u2264 s\nhp1 : 0 \u2264 0\nhp2 : 0 \u2264 1\n\u22a2 (1 + s) ^ 0 \u2264 1 + 0 * s\n---\ncase inr\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2 : p \u2264 1\nhp1 : 0 < p\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "\u00b7 simp", "tactic_state": "case inr\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2 : p \u2264 1\nhp1 : 0 < p\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "rcases eq_or_lt_of_le hp2 with (rfl | hp2)", "tactic_state": "case inr.inl\ns : \u211d\nhs : -1 \u2264 s\nhp1\u271d : 0 \u2264 1\nhp2 : 1 \u2264 1\nhp1 : 0 < 1\n\u22a2 (1 + s) ^ 1 \u2264 1 + 1 * s\n---\ncase inr.inr\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2\u271d : p \u2264 1\nhp1 : 0 < p\nhp2 : p < 1\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2\u271d : p \u2264 1\nhp1 : 0 < p\nhp2 : p < 1\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "by_cases hs' : s = 0", "tactic_state": "case pos\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2\u271d : p \u2264 1\nhp1 : 0 < p\nhp2 : p < 1\nhs' : s = 0\n\u22a2 (1 + s) ^ p \u2264 1 + p * s\n---\ncase neg\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2\u271d : p \u2264 1\nhp1 : 0 < p\nhp2 : p < 1\nhs' : \u00acs = 0\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "\u00b7 simp [hs']", "tactic_state": "case neg\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp1\u271d : 0 \u2264 p\nhp2\u271d : p \u2264 1\nhp1 : 0 < p\nhp2 : p < 1\nhs' : \u00acs = 0\n\u22a2 (1 + s) ^ p \u2264 1 + p * s"}, {"line": "exact (rpow_one_add_lt_one_add_mul_self hs hs' hp1 hp2).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexOn_rpow {p : \u211d} (hp : 1 \u2264 p) : ConvexOn \u211d (Ici 0) fun x : \u211d \u21a6 x ^ p := by\n  rcases eq_or_lt_of_le hp with (rfl | hp)\n  \u00b7 simpa using convexOn_id (convex_Ici _)\n  exact (strictConvexOn_rpow hp).convexOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "context": {"open": ["Real Set NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nhp : 1 \u2264 p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p"}, {"line": "rcases eq_or_lt_of_le hp with (rfl | hp)", "tactic_state": "case inl\nhp : 1 \u2264 1\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ 1\n---\ncase inr\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p"}, {"line": "\u00b7 simpa using convexOn_id (convex_Ici _)", "tactic_state": "case inr\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p"}, {"line": "exact (strictConvexOn_rpow hp).convexOn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_mul_le_cosh_add_mul_sinh {t : \u211d} (ht : |t| \u2264 1) (x : \u211d) :\n    exp (t * x) \u2264 cosh x + t * sinh x := by\n  rw [abs_le] at ht\n  calc\n    _ = exp ((1 + t) / 2 * x + (1 - t) / 2 * (-x)) := by ring_nf\n    _ \u2264 (1 + t) / 2 * exp x + (1 - t) / 2 * exp (-x) :=\n        convexOn_exp.2 (Set.mem_univ _) (Set.mem_univ _) (by linarith) (by linarith) <| by ring\n    _ = _ := by rw [cosh_eq, sinh_eq]; ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Basic.lean", "context": {"open": ["Real Set NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : \u211d\nht : |t| \u2264 1\nx : \u211d\n\u22a2 exp (t * x) \u2264 cosh x + t * sinh x"}, {"line": "rw [abs_le] at ht", "tactic_state": "t : \u211d\nht : -1 \u2264 t \u2227 t \u2264 1\nx : \u211d\n\u22a2 exp (t * x) \u2264 cosh x + t * sinh x"}, {"line": "calc\n    _ = exp ((1 + t) / 2 * x + (1 - t) / 2 * (-x)) := by ring_nf\n    _ \u2264 (1 + t) / 2 * exp x + (1 - t) / 2 * exp (-x) :=\n        convexOn_exp.2 (Set.mem_univ _) (Set.mem_univ _) (by linarith) (by linarith) <| by ring\n    _ = _ := by rw [cosh_eq, sinh_eq]; ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictConvexOn_pow {n : \u2115} (hn : 2 \u2264 n) : StrictConvexOn \u211d (Ici 0) fun x : \u211d => x ^ n := by\n  apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)\n  rw [deriv_pow']\n  rw [interior_Ici]\n  exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left\n    (pow_lt_pow_left\u2080 hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 StrictConvexOn \u211d (Ici 0) fun x => x ^ n"}, {"line": "apply StrictMonoOn.strictConvexOn_of_deriv (convex_Ici _) (continuousOn_pow _)", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 StrictMonoOn (deriv fun x => x ^ n) (interior (Ici 0))"}, {"line": "rw [deriv_pow']", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 StrictMonoOn (fun x => \u2191n * x ^ (n - 1)) (interior (Ici 0))"}, {"line": "rw [interior_Ici]", "tactic_state": "n : \u2115\nhn : 2 \u2264 n\n\u22a2 StrictMonoOn (fun x => \u2191n * x ^ (n - 1)) (Ioi 0)"}, {"line": "exact fun x (hx : 0 < x) y _ hxy => mul_lt_mul_of_pos_left\n    (pow_lt_pow_left\u2080 hxy hx.le <| Nat.sub_ne_zero_of_lt hn) (by positivity)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Even.strictConvexOn_pow {n : \u2115} (hn : Even n) (h : n \u2260 0) :\n    StrictConvexOn \u211d Set.univ fun x : \u211d => x ^ n := by\n  apply StrictMono.strictConvexOn_univ_of_deriv (continuous_pow n)\n  rw [deriv_pow']\n  replace h := Nat.pos_of_ne_zero h\n  exact StrictMono.const_mul (Odd.strictMono_pow <| Nat.Even.sub_odd h hn <| Nat.odd_iff.2 rfl)\n    (Nat.cast_pos.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : Even n\nh : n \u2260 0\n\u22a2 StrictConvexOn \u211d univ fun x => x ^ n"}, {"line": "apply StrictMono.strictConvexOn_univ_of_deriv (continuous_pow n)", "tactic_state": "n : \u2115\nhn : Even n\nh : n \u2260 0\n\u22a2 StrictMono (deriv fun a => a ^ n)"}, {"line": "rw [deriv_pow']", "tactic_state": "n : \u2115\nhn : Even n\nh : n \u2260 0\n\u22a2 StrictMono fun x => \u2191n * x ^ (n - 1)"}, {"line": "replace h := Nat.pos_of_ne_zero h", "tactic_state": "n : \u2115\nhn : Even n\nh : 0 < n\n\u22a2 StrictMono fun x => \u2191n * x ^ (n - 1)"}, {"line": "exact StrictMono.const_mul (Odd.strictMono_pow <| Nat.Even.sub_odd h hn <| Nat.odd_iff.2 rfl)\n    (Nat.cast_pos.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_prod_range_pos {m : \u2124} {n : \u2115} (hn : Even n) (hm : m \u2209 Ico (0 : \u2124) n) :\n    0 < \u220f k \u2208 Finset.range n, (m - k) := by\n  refine (int_prod_range_nonneg m n hn).lt_of_ne fun h => hm ?_\n  rw [eq_comm] at h\n  rw [Finset.prod_eq_zero_iff] at h\n  obtain \u27e8a, ha, h\u27e9 := h\n  rw [sub_eq_zero.1 h]\n  exact \u27e8Int.ofNat_zero_le _, Int.ofNat_lt.2 <| Finset.mem_range.1 ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\n\u22a2 0 < \u220f k \u2208 Finset.range n, (m - \u2191k)"}, {"line": "refine (int_prod_range_nonneg m n hn).lt_of_ne fun h => hm ?_", "tactic_state": "m : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\nh : 0 = \u220f k \u2208 Finset.range n, (m - \u2191k)\n\u22a2 m \u2208 Ico 0 \u2191n"}, {"line": "rw [eq_comm] at h", "tactic_state": "m : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\nh : \u220f k \u2208 Finset.range n, (m - \u2191k) = 0\n\u22a2 m \u2208 Ico 0 \u2191n"}, {"line": "rw [Finset.prod_eq_zero_iff] at h", "tactic_state": "m : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\nh : \u2203 a \u2208 Finset.range n, m - \u2191a = 0\n\u22a2 m \u2208 Ico 0 \u2191n"}, {"line": "obtain \u27e8a, ha, h\u27e9 := h", "tactic_state": "case intro.intro\nm : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\na : \u2115\nha : a \u2208 Finset.range n\nh : m - \u2191a = 0\n\u22a2 m \u2208 Ico 0 \u2191n"}, {"line": "rw [sub_eq_zero.1 h]", "tactic_state": "case intro.intro\nm : \u2124\nn : \u2115\nhn : Even n\nhm : m \u2209 Ico 0 \u2191n\na : \u2115\nha : a \u2208 Finset.range n\nh : m - \u2191a = 0\n\u22a2 \u2191a \u2208 Ico 0 \u2191n"}, {"line": "exact \u27e8Int.ofNat_zero_le _, Int.ofNat_lt.2 <| Finset.mem_range.1 ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictConvexOn_zpow {m : \u2124} (hm\u2080 : m \u2260 0) (hm\u2081 : m \u2260 1) :\n    StrictConvexOn \u211d (Ioi 0) fun x : \u211d => x ^ m := by\n  apply strictConvexOn_of_deriv2_pos' (convex_Ioi 0)\n  \u00b7 exact (continuousOn_zpow\u2080 m).mono fun x hx => ne_of_gt hx\n  intro x hx\n  rw [mem_Ioi] at hx\n  rw [iter_deriv_zpow]\n  refine mul_pos ?_ (zpow_pos hx _)\n  norm_cast\n  refine int_prod_range_pos (by decide) fun hm => ?_\n  rw [\u2190 Finset.coe_Ico] at hm\n  norm_cast at hm\n  fin_cases hm <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\n\u22a2 StrictConvexOn \u211d (Ioi 0) fun x => x ^ m"}, {"line": "apply strictConvexOn_of_deriv2_pos' (convex_Ioi 0)", "tactic_state": "case hf\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\n\u22a2 ContinuousOn (fun x => x ^ m) (Ioi 0)\n---\ncase hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\n\u22a2 \u2200 x \u2208 Ioi 0, 0 < deriv^[2] (fun x => x ^ m) x"}, {"line": "\u00b7 exact (continuousOn_zpow\u2080 m).mono fun x hx => ne_of_gt hx", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\n\u22a2 \u2200 x \u2208 Ioi 0, 0 < deriv^[2] (fun x => x ^ m) x"}, {"line": "intro x hx", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : x \u2208 Ioi 0\n\u22a2 0 < deriv^[2] (fun x => x ^ m) x"}, {"line": "rw [mem_Ioi] at hx", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\n\u22a2 0 < deriv^[2] (fun x => x ^ m) x"}, {"line": "rw [iter_deriv_zpow]", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\n\u22a2 0 < (\u220f i \u2208 Finset.range 2, (\u2191m - \u2191i)) * x ^ (m - \u21912)"}, {"line": "refine mul_pos ?_ (zpow_pos hx _)", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\n\u22a2 0 < \u220f i \u2208 Finset.range 2, (\u2191m - \u2191i)"}, {"line": "norm_cast", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\n\u22a2 0 < \u220f i \u2208 Finset.range 2, (m - \u2191i)"}, {"line": "refine int_prod_range_pos (by decide) fun hm => ?_", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\nhm : m \u2208 Ico 0 \u21912\n\u22a2 False"}, {"line": "rw [\u2190 Finset.coe_Ico] at hm", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\nhm : m \u2208 \u2191(Finset.Ico 0 \u21912)\n\u22a2 False"}, {"line": "norm_cast at hm", "tactic_state": "case hf''\nm : \u2124\nhm\u2080 : m \u2260 0\nhm\u2081 : m \u2260 1\nx : \u211d\nhx : 0 < x\nhm : m \u2208 Finset.Ico 0 2\n\u22a2 False"}, {"line": "fin_cases hm <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_sqrt_mul_log {x : \u211d} (hx : x \u2260 0) :\n    HasDerivAt (fun x => \u221ax * log x) ((2 + log x) / (2 * \u221ax)) x := by\n  convert (hasDerivAt_sqrt hx).mul (hasDerivAt_log hx) using 1\n  rw [add_div]\n  rw [div_mul_cancel_left\u2080 two_ne_zero]\n  rw [\u2190 div_eq_mul_inv]\n  rw [sqrt_div_self']\n  rw [add_comm]\n  rw [one_div]\n  rw [one_div]\n  rw [\u2190 div_eq_inv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\n\u22a2 HasDerivAt (fun x => \u221ax * log x) ((2 + log x) / (2 * \u221ax)) x"}, {"line": "convert (hasDerivAt_sqrt hx).mul (hasDerivAt_log hx) using 1", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 (2 + log x) / (2 * \u221ax) = 1 / (2 * \u221ax) * log x + \u221ax * x\u207b\u00b9"}, {"line": "rw [add_div]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 2 / (2 * \u221ax) + log x / (2 * \u221ax) = 1 / (2 * \u221ax) * log x + \u221ax * x\u207b\u00b9"}, {"line": "rw [div_mul_cancel_left\u2080 two_ne_zero]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 (\u221ax)\u207b\u00b9 + log x / (2 * \u221ax) = 1 / (2 * \u221ax) * log x + \u221ax * x\u207b\u00b9"}, {"line": "rw [\u2190 div_eq_mul_inv]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 (\u221ax)\u207b\u00b9 + log x / (2 * \u221ax) = 1 / (2 * \u221ax) * log x + \u221ax / x"}, {"line": "rw [sqrt_div_self']", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 (\u221ax)\u207b\u00b9 + log x / (2 * \u221ax) = 1 / (2 * \u221ax) * log x + 1 / \u221ax"}, {"line": "rw [add_comm]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 log x / (2 * \u221ax) + (\u221ax)\u207b\u00b9 = 1 / (2 * \u221ax) * log x + 1 / \u221ax"}, {"line": "rw [one_div]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 log x / (2 * \u221ax) + (\u221ax)\u207b\u00b9 = (2 * \u221ax)\u207b\u00b9 * log x + 1 / \u221ax"}, {"line": "rw [one_div]", "tactic_state": "case h.e'_9\nx : \u211d\nhx : x \u2260 0\n\u22a2 log x / (2 * \u221ax) + (\u221ax)\u207b\u00b9 = (2 * \u221ax)\u207b\u00b9 * log x + (\u221ax)\u207b\u00b9"}, {"line": "rw [\u2190 div_eq_inv_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictConcaveOn_sin_Icc : StrictConcaveOn \u211d (Icc 0 \u03c0) sin := by\n  apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_sin fun x hx => ?_\n  rw [interior_Icc] at hx\n  simp [sin_pos_of_mem_Ioo hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 StrictConcaveOn \u211d (Icc 0 Real.pi) sin"}, {"line": "apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_sin fun x hx => ?_", "tactic_state": "x : \u211d\nhx : x \u2208 interior (Icc 0 Real.pi)\n\u22a2 deriv^[2] sin x < 0"}, {"line": "rw [interior_Icc] at hx", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo 0 Real.pi\n\u22a2 deriv^[2] sin x < 0"}, {"line": "simp [sin_pos_of_mem_Ioo hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictConcaveOn_cos_Icc : StrictConcaveOn \u211d (Icc (-(\u03c0 / 2)) (\u03c0 / 2)) cos := by\n  apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_cos fun x hx => ?_\n  rw [interior_Icc] at hx\n  simp [cos_pos_of_mem_Ioo hx]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Convex/SpecificFunctions/Deriv.lean", "context": {"open": ["Real Set", "scoped NNReal", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 StrictConcaveOn \u211d (Icc (-(Real.pi / 2)) (Real.pi / 2)) cos"}, {"line": "apply strictConcaveOn_of_deriv2_neg (convex_Icc _ _) continuousOn_cos fun x hx => ?_", "tactic_state": "x : \u211d\nhx : x \u2208 interior (Icc (-(Real.pi / 2)) (Real.pi / 2))\n\u22a2 deriv^[2] cos x < 0"}, {"line": "rw [interior_Icc] at hx", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\n\u22a2 deriv^[2] cos x < 0"}, {"line": "simp [cos_pos_of_mem_Ioo hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integrable_pow_neg_integrablePower\n    (\u03bc : Measure D) [h : \u03bc.HasTemperateGrowth] :\n    Integrable (fun x \u21a6 (1 + \u2016x\u2016) ^ (- (\u03bc.integrablePower : \u211d))) \u03bc := by\n  simpa [Measure.integrablePower, h] using h.exists_integrable.choose_spec\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Distribution/SchwartzSpace.lean", "context": {"open": ["scoped Nat NNReal ContDiff", "Asymptotics Filter", "MeasureTheory Module", "scoped ENNReal", "Classical in"], "variables": ["{\ud835\udd5c \ud835\udd5c' D E F G V : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[NormedAddCommGroup F] [NormedSpace \u211d F]", "(E F)", "{E F}", "(f : \ud835\udce2(E, F))", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F] [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "(E F)", "{E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c)", "(E F)", "{\ud835\udd5c E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c E F)", "{\ud835\udd5c E F}", "[NormedAddCommGroup D] [MeasurableSpace D]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "D : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup D\ninst\u271d : MeasurableSpace D\n\u03bc : Measure D\nh : \u03bc.HasTemperateGrowth\n\u22a2 Integrable (fun x => (1 + \u2016x\u2016) ^ (-\u2191\u03bc.integrablePower)) \u03bc"}, {"line": "simpa [Measure.integrablePower, h] using h.exists_integrable.choose_spec", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_mul_le_of_le_of_pow_mul_le {C\u2081 C\u2082 : \u211d} {k l : \u2115} {x f : \u211d} (hx : 0 \u2264 x) (hf : 0 \u2264 f)\n    (h\u2081 : f \u2264 C\u2081) (h\u2082 : x ^ (k + l) * f \u2264 C\u2082) :\n    x ^ k * f \u2264 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (- (l : \u211d)) := by\n  have : 0 \u2264 C\u2082 := le_trans (by positivity) h\u2082\n  have : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (- (l : \u211d)) = ((1 + x) / 2) ^ (-(l : \u211d)) * (C\u2081 + C\u2082) := by\n    rw [Real.div_rpow (by linarith) zero_le_two]\n    simp [div_eq_inv_mul, \u2190 Real.rpow_neg_one, \u2190 Real.rpow_mul]\n    ring\n  rw [this]\n  rcases le_total x 1 with h'x|h'x\n  \u00b7 gcongr\n    \u00b7 apply (pow_le_one\u2080 hx h'x).trans\n      apply Real.one_le_rpow_of_pos_of_le_one_of_nonpos\n      \u00b7 linarith\n      \u00b7 linarith\n      \u00b7 simp\n    \u00b7 linarith\n  \u00b7 calc\n    x ^ k * f = x ^ (-(l : \u211d)) * (x ^ (k + l) * f) := by\n      rw [\u2190 Real.rpow_natCast]\n      rw [\u2190 Real.rpow_natCast]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 Real.rpow_add (by linarith)]\n      simp\n    _ \u2264 ((1 + x) / 2) ^ (-(l : \u211d)) * (C\u2081 + C\u2082) := by\n      apply mul_le_mul _ _ (by positivity) (by positivity)\n      \u00b7 exact Real.rpow_le_rpow_of_nonpos (by linarith) (by linarith) (by simp)\n      \u00b7 exact h\u2082.trans (by linarith)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Distribution/SchwartzSpace.lean", "context": {"open": ["scoped Nat NNReal ContDiff", "Asymptotics Filter", "MeasureTheory Module", "scoped ENNReal", "Classical in"], "variables": ["{\ud835\udd5c \ud835\udd5c' D E F G V : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[NormedAddCommGroup F] [NormedSpace \u211d F]", "(E F)", "{E F}", "(f : \ud835\udce2(E, F))", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F] [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "(E F)", "{E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c)", "(E F)", "{\ud835\udd5c E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c E F)", "{\ud835\udd5c E F}", "[NormedAddCommGroup D] [MeasurableSpace D]", "[NormedSpace \u211d D] [FiniteDimensional \u211d D] [BorelSpace D] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\n\u22a2 x ^ k * f \u2264 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l)"}, {"line": "have : 0 \u2264 C\u2082 := le_trans (by positivity) h\u2082", "tactic_state": "C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis : 0 \u2264 C\u2082\n\u22a2 x ^ k * f \u2264 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l)"}, {"line": "have : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (- (l : \u211d)) = ((1 + x) / 2) ^ (-(l : \u211d)) * (C\u2081 + C\u2082) := by\n    rw [Real.div_rpow (by linarith) zero_le_two]\n    simp [div_eq_inv_mul, \u2190 Real.rpow_neg_one, \u2190 Real.rpow_mul]\n    ring", "tactic_state": "C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\n\u22a2 x ^ k * f \u2264 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l)"}, {"line": "rw [this]", "tactic_state": "C\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\n\u22a2 x ^ k * f \u2264 ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)"}, {"line": "rcases le_total x 1 with h'x|h'x", "tactic_state": "case inl\nC\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\nh'x : x \u2264 1\n\u22a2 x ^ k * f \u2264 ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\n---\ncase inr\nC\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\nh'x : 1 \u2264 x\n\u22a2 x ^ k * f \u2264 ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)"}, {"line": "\u00b7 gcongr\n    \u00b7 apply (pow_le_one\u2080 hx h'x).trans\n      apply Real.one_le_rpow_of_pos_of_le_one_of_nonpos\n      \u00b7 linarith\n      \u00b7 linarith\n      \u00b7 simp\n    \u00b7 linarith", "tactic_state": "case inr\nC\u2081 C\u2082 : \u211d\nk l : \u2115\nx f : \u211d\nhx : 0 \u2264 x\nhf : 0 \u2264 f\nh\u2081 : f \u2264 C\u2081\nh\u2082 : x ^ (k + l) * f \u2264 C\u2082\nthis\u271d : 0 \u2264 C\u2082\nthis : 2 ^ l * (C\u2081 + C\u2082) * (1 + x) ^ (-\u2191l) = ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)\nh'x : 1 \u2264 x\n\u22a2 x ^ k * f \u2264 ((1 + x) / 2) ^ (-\u2191l) * (C\u2081 + C\u2082)"}, {"line": "\u00b7 calc\n    x ^ k * f = x ^ (-(l : \u211d)) * (x ^ (k + l) * f) := by\n      rw [\u2190 Real.rpow_natCast]\n      rw [\u2190 Real.rpow_natCast]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 Real.rpow_add (by linarith)]\n      simp\n    _ \u2264 ((1 + x) / 2) ^ (-(l : \u211d)) * (C\u2081 + C\u2082) := by\n      apply mul_le_mul _ _ (by positivity) (by positivity)\n      \u00b7 exact Real.rpow_le_rpow_of_nonpos (by linarith) (by linarith) (by simp)\n      \u00b7 exact h\u2082.trans (by linarith)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_pow_mul_le_of_le_of_pow_mul_le\n    {E : Type*} [NormedAddCommGroup E]\n    {\u03bc : Measure D} [\u03bc.HasTemperateGrowth] {f : D \u2192 E} {C\u2081 C\u2082 : \u211d} {k : \u2115}\n    (hf : \u2200 x, \u2016f x\u2016 \u2264 C\u2081) (h'f : \u2200 x, \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082) :\n    \u222b x, \u2016x\u2016 ^ k * \u2016f x\u2016 \u2202\u03bc \u2264 2 ^ \u03bc.integrablePower *\n      (\u222b x, (1 + \u2016x\u2016) ^ (- (\u03bc.integrablePower : \u211d)) \u2202\u03bc) * (C\u2081 + C\u2082) := by\n  rw [\u2190 integral_const_mul]\n  rw [\u2190 integral_mul_const]\n  apply integral_mono_of_nonneg\n  \u00b7 filter_upwards with v using by positivity\n  \u00b7 exact ((integrable_pow_neg_integrablePower \u03bc).const_mul _).mul_const _\n  filter_upwards with v\n  exact (pow_mul_le_of_le_of_pow_mul_le (norm_nonneg _) (norm_nonneg _) (hf v) (h'f v)).trans\n    (le_of_eq (by ring))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Distribution/SchwartzSpace.lean", "context": {"open": ["scoped Nat NNReal ContDiff", "Asymptotics Filter", "MeasureTheory Module", "scoped ENNReal", "Classical in"], "variables": ["{\ud835\udd5c \ud835\udd5c' D E F G V : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[NormedAddCommGroup F] [NormedSpace \u211d F]", "(E F)", "{E F}", "(f : \ud835\udce2(E, F))", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F] [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' F]", "(E F)", "{E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c)", "(E F)", "{\ud835\udd5c E F}", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c F] [SMulCommClass \u211d \ud835\udd5c F]", "(\ud835\udd5c E F)", "{\ud835\udd5c E F}", "[NormedAddCommGroup D] [MeasurableSpace D]", "[NormedSpace \u211d D] [FiniteDimensional \u211d D] [BorelSpace D] in", "[BorelSpace D] [SecondCountableTopology D] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "D : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 \u222b (x : D), \u2016x\u2016 ^ k * \u2016f x\u2016 \u2202\u03bc \u2264 (2 ^ \u03bc.integrablePower * \u222b (x : D), (1 + \u2016x\u2016) ^ (-\u2191\u03bc.integrablePower) \u2202\u03bc) * (C\u2081 + C\u2082)"}, {"line": "rw [\u2190 integral_const_mul]", "tactic_state": "D : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 \u222b (x : D), \u2016x\u2016 ^ k * \u2016f x\u2016 \u2202\u03bc \u2264 (\u222b (a : D), 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) \u2202\u03bc) * (C\u2081 + C\u2082)"}, {"line": "rw [\u2190 integral_mul_const]", "tactic_state": "D : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 \u222b (x : D), \u2016x\u2016 ^ k * \u2016f x\u2016 \u2202\u03bc \u2264 \u222b (a : D), 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082) \u2202\u03bc"}, {"line": "apply integral_mono_of_nonneg", "tactic_state": "case hf\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 0 \u2264\u1da0[ae \u03bc] fun a => \u2016a\u2016 ^ k * \u2016f a\u2016\n---\ncase hgi\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 Integrable (fun a => 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)) \u03bc\n---\ncase h\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 (fun a => \u2016a\u2016 ^ k * \u2016f a\u2016) \u2264\u1da0[ae \u03bc] fun a => 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)"}, {"line": "\u00b7 filter_upwards with v using by positivity", "tactic_state": "case hgi\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 Integrable (fun a => 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)) \u03bc\n---\ncase h\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 (fun a => \u2016a\u2016 ^ k * \u2016f a\u2016) \u2264\u1da0[ae \u03bc] fun a => 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)"}, {"line": "\u00b7 exact ((integrable_pow_neg_integrablePower \u03bc).const_mul _).mul_const _", "tactic_state": "case h\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\n\u22a2 (fun a => \u2016a\u2016 ^ k * \u2016f a\u2016) \u2264\u1da0[ae \u03bc] fun a => 2 ^ \u03bc.integrablePower * (1 + \u2016a\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)"}, {"line": "filter_upwards with v", "tactic_state": "case h.h\nD : Type u_2\ninst\u271d\u2078 : NormedAddCommGroup D\ninst\u271d\u2077 : MeasurableSpace D\ninst\u271d\u2076 : NormedSpace \u211d D\ninst\u271d\u2075 : FiniteDimensional \u211d D\ninst\u271d\u2074 inst\u271d\u00b3 : BorelSpace D\ninst\u271d\u00b2 : SecondCountableTopology D\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\n\u03bc : Measure D\ninst\u271d : \u03bc.HasTemperateGrowth\nf : D \u2192 E\nC\u2081 C\u2082 : \u211d\nk : \u2115\nhf : \u2200 (x : D), \u2016f x\u2016 \u2264 C\u2081\nh'f : \u2200 (x : D), \u2016x\u2016 ^ (k + \u03bc.integrablePower) * \u2016f x\u2016 \u2264 C\u2082\nv : D\n\u22a2 \u2016v\u2016 ^ k * \u2016f v\u2016 \u2264 2 ^ \u03bc.integrablePower * (1 + \u2016v\u2016) ^ (-\u2191\u03bc.integrablePower) * (C\u2081 + C\u2082)"}, {"line": "exact (pow_mul_le_of_le_of_pow_mul_le (norm_nonneg _) (norm_nonneg _) (hf v) (h'f v)).trans\n    (le_of_eq (by ring))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_zero {x : AddCircle T} : fourier 0 x = 1 := by\n  induction x using QuotientAddGroup.induction_on\n  simp only [fourier_coe_apply]\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nx : AddCircle T\n\u22a2 (fourier 0) x = 1"}, {"line": "induction x using QuotientAddGroup.induction_on", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nz\u271d : \u211d\n\u22a2 (fourier 0) \u2191z\u271d = 1"}, {"line": "simp only [fourier_coe_apply]", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nz\u271d : \u211d\n\u22a2 Complex.exp (2 * \u2191Real.pi * Complex.I * \u21910 * \u2191z\u271d / \u2191T) = 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_eval_zero (n : \u2124) : fourier n (0 : AddCircle T) = 1 := by\n  rw [\u2190 QuotientAddGroup.mk_zero]\n  rw [fourier_coe_apply]\n  rw [Complex.ofReal_zero]\n  rw [mul_zero]\n  rw [zero_div]\n  rw [Complex.exp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 (fourier n) 0 = 1"}, {"line": "rw [\u2190 QuotientAddGroup.mk_zero]", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 (fourier n) \u21910 = 1"}, {"line": "rw [fourier_coe_apply]", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 Complex.exp (2 * \u2191Real.pi * Complex.I * \u2191n * \u21910 / \u2191T) = 1"}, {"line": "rw [Complex.ofReal_zero]", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 Complex.exp (2 * \u2191Real.pi * Complex.I * \u2191n * 0 / \u2191T) = 1"}, {"line": "rw [mul_zero]", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 Complex.exp (0 / \u2191T) = 1"}, {"line": "rw [zero_div]", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\n\u22a2 Complex.exp 0 = 1"}, {"line": "rw [Complex.exp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_one {x : AddCircle T} : fourier 1 x = toCircle x := by rw [fourier_apply, one_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nx : AddCircle T\n\u22a2 (fourier 1) x = \u2191x.toCircle"}, {"line": "rw [fourier_apply, one_zsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_neg {n : \u2124} {x : AddCircle T} : fourier (-n) x = conj (fourier n x) := by\n  induction x using QuotientAddGroup.induction_on\n  simp_rw [fourier_apply, toCircle]\n  rw [\u2190 QuotientAddGroup.mk_zsmul]\n  rw [\u2190 QuotientAddGroup.mk_zsmul]\n  simp_rw [Function.Periodic.lift_coe, \u2190 Circle.coe_inv_eq_conj, \u2190 Circle.exp_neg,\n    neg_smul, mul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nn : \u2124\nx : AddCircle T\n\u22a2 (fourier (-n)) x = (starRingEnd \u2102) ((fourier n) x)"}, {"line": "induction x using QuotientAddGroup.induction_on", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nn : \u2124\nz\u271d : \u211d\n\u22a2 (fourier (-n)) \u2191z\u271d = (starRingEnd \u2102) ((fourier n) \u2191z\u271d)"}, {"line": "simp_rw [fourier_apply, toCircle]", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nn : \u2124\nz\u271d : \u211d\n\u22a2 \u2191(\u22ef.lift (-n \u2022 \u2191z\u271d)) = (starRingEnd \u2102) \u2191(\u22ef.lift (n \u2022 \u2191z\u271d))"}, {"line": "rw [\u2190 QuotientAddGroup.mk_zsmul]", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nn : \u2124\nz\u271d : \u211d\n\u22a2 \u2191(\u22ef.lift \u2191(-n \u2022 z\u271d)) = (starRingEnd \u2102) \u2191(\u22ef.lift (n \u2022 \u2191z\u271d))"}, {"line": "rw [\u2190 QuotientAddGroup.mk_zsmul]", "tactic_state": "case H\nT : \u211d\nhT : Fact (0 < T)\nn : \u2124\nz\u271d : \u211d\n\u22a2 \u2191(\u22ef.lift \u2191(-n \u2022 z\u271d)) = (starRingEnd \u2102) \u2191(\u22ef.lift \u2191(n \u2022 z\u271d))"}, {"line": "simp_rw [Function.Periodic.lift_coe, \u2190 Circle.coe_inv_eq_conj, \u2190 Circle.exp_neg,\n    neg_smul, mul_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_add {m n : \u2124} {x : AddCircle T} : fourier (m+n) x = fourier m x * fourier n x := by\n  simp_rw [fourier_apply, add_zsmul, toCircle_add, Circle.coe_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT : Fact (0 < T)\nm n : \u2124\nx : AddCircle T\n\u22a2 (fourier (m + n)) x = (fourier m) x * (fourier n) x"}, {"line": "simp_rw [fourier_apply, add_zsmul, toCircle_add, Circle.coe_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fourier_norm [Fact (0 < T)] (n : \u2124) : \u2016@fourier T n\u2016 = 1 := by\n  rw [ContinuousMap.norm_eq_iSup_norm]\n  have : \u2200 x : AddCircle T, \u2016fourier n x\u2016 = 1 := fun x => Circle.norm_coe _\n  simp_rw [this]\n  exact @ciSup_const _ _ _ Zero.instNonempty _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT inst\u271d : Fact (0 < T)\nn : \u2124\n\u22a2 \u2016fourier n\u2016 = 1"}, {"line": "rw [ContinuousMap.norm_eq_iSup_norm]", "tactic_state": "T : \u211d\nhT inst\u271d : Fact (0 < T)\nn : \u2124\n\u22a2 \u2a06 x, \u2016(fourier n) x\u2016 = 1"}, {"line": "have : \u2200 x : AddCircle T, \u2016fourier n x\u2016 = 1 := fun x => Circle.norm_coe _", "tactic_state": "T : \u211d\nhT inst\u271d : Fact (0 < T)\nn : \u2124\nthis : \u2200 (x : AddCircle T), \u2016(fourier n) x\u2016 = 1\n\u22a2 \u2a06 x, \u2016(fourier n) x\u2016 = 1"}, {"line": "simp_rw [this]", "tactic_state": "T : \u211d\nhT inst\u271d : Fact (0 < T)\nn : \u2124\nthis : \u2200 (x : AddCircle T), \u2016(fourier n) x\u2016 = 1\n\u22a2 \u2a06 x, 1 = 1"}, {"line": "exact @ciSup_const _ _ _ Zero.instNonempty _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem span_fourierLp_closure_eq_top {p : \u211d\u22650\u221e} [Fact (1 \u2264 p)] (hp : p \u2260 \u221e) :\n    (span \u2102 (range (@fourierLp T _ p _))).topologicalClosure = \u22a4 := by\n  convert\n    (ContinuousMap.toLp_denseRange \u2102 (@haarAddCircle T hT) \u2102 hp).topologicalClosure_map_submodule\n      span_fourier_closure_eq_top\n  rw [map_span]\n  unfold fourierLp\n  rw [range_comp']\n  simp only [ContinuousLinearMap.coe_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 (span \u2102 (range (fourierLp p))).topologicalClosure = \u22a4"}, {"line": "convert\n    (ContinuousMap.toLp_denseRange \u2102 (@haarAddCircle T hT) \u2102 hp).topologicalClosure_map_submodule\n      span_fourier_closure_eq_top", "tactic_state": "case h.e'_2.h.e'_9.h.h\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\ne_3\u271d : Complex.instSemiring = DivisionSemiring.toSemiring\nhe\u271d : Lp.instModule = Lp.instModule\n\u22a2 span \u2102 (range (fourierLp p)) = Submodule.map (\u2191(toLp p haarAddCircle \u2102)) (span \u2102 (range fourier))\n---\ncase convert_2\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 CompactSpace (AddCircle T)\n---\ncase convert_3\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 Fact (0 < T)"}, {"line": "rw [map_span]", "tactic_state": "case h.e'_2.h.e'_9.h.h\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\ne_3\u271d : Complex.instSemiring = DivisionSemiring.toSemiring\nhe\u271d : Lp.instModule = Lp.instModule\n\u22a2 span \u2102 (range (fourierLp p)) = span \u2102 (\u21d1\u2191(toLp p haarAddCircle \u2102) '' range fourier)\n---\ncase convert_2\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 CompactSpace (AddCircle T)\n---\ncase convert_3\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 Fact (0 < T)"}, {"line": "unfold fourierLp", "tactic_state": "case h.e'_2.h.e'_9.h.h\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\ne_3\u271d : Complex.instSemiring = DivisionSemiring.toSemiring\nhe\u271d : Lp.instModule = Lp.instModule\n\u22a2 span \u2102 (range fun n => (toLp p haarAddCircle \u2102) (fourier n)) = span \u2102 (\u21d1\u2191(toLp p haarAddCircle \u2102) '' range fourier)\n---\ncase convert_2\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 CompactSpace (AddCircle T)\n---\ncase convert_3\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 Fact (0 < T)"}, {"line": "rw [range_comp']", "tactic_state": "case h.e'_2.h.e'_9.h.h\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\ne_3\u271d : Complex.instSemiring = DivisionSemiring.toSemiring\nhe\u271d : Lp.instModule = Lp.instModule\n\u22a2 span \u2102 (\u21d1(toLp p haarAddCircle \u2102) '' range fourier) = span \u2102 (\u21d1\u2191(toLp p haarAddCircle \u2102) '' range fourier)\n---\ncase convert_2\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 CompactSpace (AddCircle T)\n---\ncase convert_3\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 Fact (0 < T)"}, {"line": "simp only [ContinuousLinearMap.coe_coe]", "tactic_state": "case convert_2\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 CompactSpace (AddCircle T)\n---\ncase convert_3\nT : \u211d\nhT\u271d hT : Fact (0 < T)\np : ENNReal\ninst\u271d : Fact (1 \u2264 p)\nhp : p \u2260 \u22a4\n\u22a2 Fact (0 < T)"}]}
{"declaration": "theorem has_pointwise_sum_fourier_series_of_summable (h : Summable (fourierCoeff f))\n    (x : AddCircle T) : HasSum (fun i => fourierCoeff f i \u2022 fourier i x) (f x) := by\n  convert (ContinuousMap.evalCLM \u2102 x).hasSum (hasSum_fourier_series_of_summable h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "(f : C(AddCircle T, \u2102))", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nf : C(AddCircle T, \u2102)\nh : Summable (fourierCoeff \u21d1f)\nx : AddCircle T\n\u22a2 HasSum (fun i => fourierCoeff (\u21d1f) i \u2022 (fourier i) x) (f x)"}, {"line": "convert (ContinuousMap.evalCLM \u2102 x).hasSum (hasSum_fourier_series_of_summable h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_fourier_neg (n : \u2124) (x : \u211d) :\n    HasDerivAt (fun y : \u211d => fourier (-n) (y : AddCircle T))\n      (-2 * \u03c0 * I * n / T * fourier (-n) (x : AddCircle T)) x := by\n  simpa using hasDerivAt_fourier T (-n) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle", "Complex intervalIntegral", "scoped Interval"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "(f : C(AddCircle T, \u2102))", "{f}", "(T)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nn : \u2124\nx : \u211d\n\u22a2 HasDerivAt (fun y => (fourier (-n)) \u2191y) (-2 * \u2191Real.pi * I * \u2191n / \u2191T * (fourier (-n)) \u2191x) x"}, {"line": "simpa using hasDerivAt_fourier T (-n) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem has_antideriv_at_fourier_neg (hT : Fact (0 < T)) {n : \u2124} (hn : n \u2260 0) (x : \u211d) :\n    HasDerivAt (fun y : \u211d => (T : \u2102) / (-2 * \u03c0 * I * n) * fourier (-n) (y : AddCircle T))\n      (fourier (-n) (x : AddCircle T)) x := by\n  convert (hasDerivAt_fourier_neg T n x).div_const (-2 * \u03c0 * I * n / T) using 1\n  \u00b7 ext1 y; rw [div_div_eq_mul_div]; ring\n  \u00b7 simp [mul_div_cancel_left\u2080, hn, (Fact.out : 0 < T).ne', Real.pi_pos.ne']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/AddCircle.lean", "context": {"open": ["scoped ENNReal ComplexConjugate Real", "TopologicalSpace ContinuousMap MeasureTheory MeasureTheory.Measure Algebra Submodule Set", "AddCircle", "Complex intervalIntegral", "scoped Interval"], "variables": ["{T : \u211d}", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "[hT : Fact (0 < T)]", "{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "(f : C(AddCircle T, \u2102))", "{f}", "(T)", "{T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\nhT\u271d\u00b2 hT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nn : \u2124\nhn : n \u2260 0\nx : \u211d\n\u22a2 HasDerivAt (fun y => \u2191T / (-2 * \u2191Real.pi * I * \u2191n) * (fourier (-n)) \u2191y) ((fourier (-n)) \u2191x) x"}, {"line": "convert (hasDerivAt_fourier_neg T n x).div_const (-2 * \u03c0 * I * n / T) using 1", "tactic_state": "case h.e'_8\nT : \u211d\nhT\u271d\u00b2 hT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nn : \u2124\nhn : n \u2260 0\nx : \u211d\n\u22a2 (fun y => \u2191T / (-2 * \u2191Real.pi * I * \u2191n) * (fourier (-n)) \u2191y) = fun x => (fourier (-n)) \u2191x / (-2 * sorry * I * \u2191n / \u2191T)\n---\ncase h.e'_9\nT : \u211d\nhT\u271d\u00b2 hT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nn : \u2124\nhn : n \u2260 0\nx : \u211d\n\u22a2 (fourier (-n)) \u2191x = -2 * \u2191Real.pi * I * \u2191n / \u2191T * (fourier (-n)) \u2191x / (-2 * sorry * I * \u2191n / \u2191T)"}, {"line": "\u00b7 ext1 y; rw [div_div_eq_mul_div]; ring", "tactic_state": "case h.e'_9\nT : \u211d\nhT\u271d\u00b2 hT\u271d\u00b9 hT\u271d hT : Fact (0 < T)\nn : \u2124\nhn : n \u2260 0\nx : \u211d\n\u22a2 (fourier (-n)) \u2191x = -2 * \u2191Real.pi * I * \u2191n / \u2191T * (fourier (-n)) \u2191x / (-2 * sorry * I * \u2191n / \u2191T)"}, {"line": "\u00b7 simp [mul_div_cancel_left\u2080, hn, (Fact.out : 0 < T).ne', Real.pi_pos.ne']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.tendsto_integral_exp_smul_cocompact (f : \u211d \u2192 E) :\n    Tendsto (fun w : \u211d => \u222b v : \u211d, \ud835\udc1e (-(v * w)) \u2022 f v) (cocompact \u211d) (\ud835\udcdd 0) := by\n  simp_rw [mul_comm]\n  exact tendsto_integral_exp_inner_smul_cocompact f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/RiemannLebesgueLemma.lean", "context": {"open": ["MeasureTheory Filter Complex Set Module", "scoped Filter Topology Real ENNReal FourierTransform RealInnerProductSpace NNReal"], "variables": ["{E V : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f : V \u2192 E}", "[NormedAddCommGroup V] [MeasurableSpace V] [BorelSpace V] [InnerProductSpace \u211d V]", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\n\u22a2 Tendsto (fun w => \u222b (v : \u211d), fourierChar (-(v * w)) \u2022 f v) (cocompact \u211d) (nhds 0)"}, {"line": "simp_rw [mul_comm]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\n\u22a2 Tendsto (fun w => \u222b (v : \u211d), fourierChar (-(w * v)) \u2022 f v) (cocompact \u211d) (nhds 0)"}, {"line": "exact tendsto_integral_exp_inner_smul_cocompact f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dft_apply_zero (\u03a6 : ZMod N \u2192 E) : \ud835\udcd5 \u03a6 0 = \u2211 j, \u03a6 j := by\n  simp only [dft_apply]\n  simp only [mul_zero]\n  simp only [neg_zero]\n  simp only [map_zero_eq_one]\n  simp only [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/ZMod.lean", "context": {"open": ["MeasureTheory Finset AddChar ZMod"], "variables": ["{N : \u2115} [NeZero N] {E : Type*} [AddCommGroup E] [Module \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d\u00b2 : NeZero N\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u2102 E\n\u03a6 : ZMod N \u2192 E\n\u22a2 dft \u03a6 0 = \u2211 j, \u03a6 j"}, {"line": "simp only [dft_apply]", "tactic_state": "N : \u2115\ninst\u271d\u00b2 : NeZero N\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u2102 E\n\u03a6 : ZMod N \u2192 E\n\u22a2 \u2211 j, stdAddChar (-(j * 0)) \u2022 \u03a6 j = \u2211 j, \u03a6 j"}, {"line": "simp only [mul_zero]", "tactic_state": "N : \u2115\ninst\u271d\u00b2 : NeZero N\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u2102 E\n\u03a6 : ZMod N \u2192 E\n\u22a2 \u2211 x, stdAddChar (-0) \u2022 \u03a6 x = \u2211 j, \u03a6 j"}, {"line": "simp only [neg_zero]", "tactic_state": "N : \u2115\ninst\u271d\u00b2 : NeZero N\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u2102 E\n\u03a6 : ZMod N \u2192 E\n\u22a2 \u2211 x, stdAddChar 0 \u2022 \u03a6 x = \u2211 j, \u03a6 j"}, {"line": "simp only [map_zero_eq_one]", "tactic_state": "N : \u2115\ninst\u271d\u00b2 : NeZero N\nE : Type u_1\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u2102 E\n\u03a6 : ZMod N \u2192 E\n\u22a2 \u2211 x, 1 \u2022 \u03a6 x = \u2211 j, \u03a6 j"}, {"line": "simp only [one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fourierTransform_eq_gaussSum_mulShift (\u03c7 : DirichletCharacter \u2102 N) (k : ZMod N) :\n    \ud835\udcd5 \u03c7 k = gaussSum \u03c7 (stdAddChar.mulShift (-k)) := by\n  simp only [dft_apply]\n  simp only [smul_eq_mul]\n  congr 1 with j\n  rw [mulShift_apply]\n  rw [mul_comm j]\n  rw [neg_mul]\n  rw [stdAddChar_apply]\n  rw [mul_comm (\u03c7 _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/ZMod.lean", "context": {"open": ["MeasureTheory Finset AddChar ZMod"], "variables": ["{N : \u2115} [NeZero N] {E : Type*} [AddCommGroup E] [Module \u2102 E]", "{N : \u2115} [NeZero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk : ZMod N\n\u22a2 dft (\u21d1\u03c7) k = gaussSum \u03c7 (stdAddChar.mulShift (-k))"}, {"line": "simp only [dft_apply]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk : ZMod N\n\u22a2 \u2211 j, stdAddChar (-(j * k)) \u2022 \u03c7 j = gaussSum \u03c7 (stdAddChar.mulShift (-k))"}, {"line": "simp only [smul_eq_mul]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk : ZMod N\n\u22a2 \u2211 x, stdAddChar (-(x * k)) * \u03c7 x = gaussSum \u03c7 (stdAddChar.mulShift (-k))"}, {"line": "congr 1 with j", "tactic_state": "case e_f.h\nN : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk j : ZMod N\n\u22a2 stdAddChar (-(j * k)) * \u03c7 j = \u03c7 j * (stdAddChar.mulShift (-k)) j"}, {"line": "rw [mulShift_apply]", "tactic_state": "case e_f.h\nN : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk j : ZMod N\n\u22a2 stdAddChar (-(j * k)) * \u03c7 j = \u03c7 j * stdAddChar (-k * j)"}, {"line": "rw [mul_comm j]", "tactic_state": "case e_f.h\nN : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk j : ZMod N\n\u22a2 stdAddChar (-(k * j)) * \u03c7 j = \u03c7 j * stdAddChar (-k * j)"}, {"line": "rw [neg_mul]", "tactic_state": "case e_f.h\nN : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk j : ZMod N\n\u22a2 stdAddChar (-(k * j)) * \u03c7 j = \u03c7 j * stdAddChar (-(k * j))"}, {"line": "rw [stdAddChar_apply]", "tactic_state": "case e_f.h\nN : \u2115\ninst\u271d : NeZero N\n\u03c7 : DirichletCharacter \u2102 N\nk j : ZMod N\n\u22a2 \u2191(toCircle (-(k * j))) * \u03c7 j = \u03c7 j * \u2191(toCircle (-(k * j)))"}, {"line": "rw [mul_comm (\u03c7 _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma charMonoidHom_apply (w : Multiplicative W) (v : V) :\n    charMonoidHom he hL w v = e (L v w) := by simp [charMonoidHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/BoundedContinuousFunctionChar.lean", "context": {"open": ["Filter BoundedContinuousFunction Complex"], "variables": ["{V W : Type*} [AddCommGroup V] [Module \u211d V] [TopologicalSpace V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nW : Type u_2\ninst\u271d\u00b3 : AddCommGroup V\ninst\u271d\u00b2 : Module \u211d V\ninst\u271d\u00b9 : TopologicalSpace V\na\u271d\u00b9 : AddChar \u211d Circle\nhe : Continuous \u21d1a\u271d\u00b9\nt\u2082\u271d : TopologicalSpace W\nself\u271d : AddCommGroup W\ninst\u271d : Module \u211d W\na\u271d : V \u2192\u2097[\u211d] W \u2192\u2097[\u211d] \u211d\nhL : Continuous fun p => (a\u271d p.1) p.2\nx\u271d : Sort u_3\ne : x\u271d\nw : Multiplicative W\nv : V\n\u22a2 sorry = sorry"}, {"line": "simp [charMonoidHom]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fourierIntegralInv_eq (f : V \u2192 E) (w : V) :\n    \ud835\udcd5\u207b f w = \u222b v, \ud835\udc1e \u27eav, w\u27eb \u2022 f v := by\n  simp [fourierIntegralInv, VectorFourier.fourierIntegral]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FourierTransform.lean", "context": {"open": ["MeasureTheory Filter", "scoped Topology", "scoped Real", "FourierTransform", "scoped RealInnerProductSpace"], "variables": ["{\ud835\udd5c : Type*} [CommRing \ud835\udd5c] {V : Type*} [AddCommGroup V] [Module \ud835\udd5c V] [MeasurableSpace V]", "[TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c] [TopologicalSpace V] [BorelSpace V]", "[TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c] [TopologicalSpace V] [BorelSpace V]", "[CompleteSpace E] [CompleteSpace F]", "{\ud835\udd5c \u03b9 E F V W : Type*} [Fintype \u03b9] [NontriviallyNormedField \ud835\udd5c]", "{\ud835\udd5c : Type*} [CommRing \ud835\udd5c] [MeasurableSpace \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{\u03b9 F V W : Type*} [Fintype \u03b9]", "{V : Type*} [NormedAddCommGroup V]", "[FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_11\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nV : Type u_16\ninst\u271d : NormedAddCommGroup V\nf : V \u2192 E\nw : V\n\u22a2 Real.fourierIntegralInv f w = \u222b (v : V), Real.fourierChar sorry \u2022 f v"}, {"line": "simp [fourierIntegralInv, VectorFourier.fourierIntegral]", "tactic_state": "E : Type u_11\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u2102 E\nV : Type u_16\ninst\u271d : NormedAddCommGroup V\nf : V \u2192 E\nw : V\n\u22a2 Real.fourierIntegralInv f w = \u222b (v : V), Real.fourierChar (sorry ()) \u2022 f v"}]}
{"declaration": "theorem deriv_fourierIntegral\n    {f : \u211d \u2192 E} (hf : Integrable f) (hf' : Integrable (fun x : \u211d \u21a6 x \u2022 f x)) :\n    deriv (\ud835\udcd5 f) = \ud835\udcd5 (fun x : \u211d \u21a6 (-2 * \u03c0 * I * x) \u2022 f x) := by\n  ext x\n  exact (hasDerivAt_fourierIntegral hf hf' x).deriv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FourierTransformDeriv.lean", "context": {"open": ["Real Complex MeasureTheory Filter TopologicalSpace", "scoped FourierTransform Topology ContDiff", "ContinuousMultilinearMap", "VectorFourier"], "variables": ["{V W : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{V W : Type*} [NormedAddCommGroup V] [NormedSpace \u211d V]", "{f}", "[MeasurableSpace V] [BorelSpace V] {\u03bc : Measure V}", "[SecondCountableTopology V]", "{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\nhf : Integrable f volume\nhf' : Integrable (fun x => x \u2022 f x) volume\n\u22a2 deriv (Real.fourierIntegral f) = Real.fourierIntegral fun x => (-2 * \u2191Real.pi * I * \u2191x) \u2022 f x"}, {"line": "ext x", "tactic_state": "case h\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u211d \u2192 E\nhf : Integrable f volume\nhf' : Integrable (fun x => x \u2022 f x) volume\nx : \u211d\n\u22a2 deriv (Real.fourierIntegral f) x = Real.fourierIntegral (fun x => (-2 * \u2191Real.pi * I * \u2191x) \u2022 f x) x"}, {"line": "exact (hasDerivAt_fourierIntegral hf hf' x).deriv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.fourierCoeff_tsum_comp_add {f : C(\u211d, \u2102)}\n    (hf : \u2200 K : Compacts \u211d, Summable fun n : \u2124 => \u2016(f.comp (ContinuousMap.addRight n)).restrict K\u2016)\n    (m : \u2124) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = \ud835\udcd5 f m := by\n  -- NB: This proof can be shortened somewhat by telescoping together some of the steps in the calc\n  -- block, but I think it's more legible this way. We start with preliminaries about the integrand.\n  let e : C(\u211d, \u2102) := (fourier (-m)).comp \u27e8((\u2191) : \u211d \u2192 UnitAddCircle), continuous_quotient_mk'\u27e9\n  have neK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016(e * g).restrict K\u2016 = \u2016g.restrict K\u2016 := by\n    have (x : \u211d) : \u2016e x\u2016 = 1 := (AddCircle.toCircle (-m \u2022 x)).norm_coe\n    intro K g\n    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]\n  have eadd : \u2200 (n : \u2124), e.comp (ContinuousMap.addRight n) = e := by\n    intro n; ext1 x\n    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))\n    simpa only [mul_one] using this.int_mul n x\n  -- Now the main argument. First unwind some definitions.\n  calc\n    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =\n        \u222b x in (0 : \u211d)..1, e x * (\u2211' n : \u2124, f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,\n        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]\n    -- Transform sum in C(\u211d, \u2102) evaluated at x into pointwise sum of values.\n    _ = \u222b x in (0 : \u211d)..1, \u2211' n : \u2124, (e * f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [coe_mul, Pi.mul_apply,\n        \u2190 ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]\n    -- Swap sum and integral.\n    _ = \u2211' n : \u2124, \u222b x in (0 : \u211d)..1, (e * f.comp (ContinuousMap.addRight n)) x := by\n      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm\n      convert hf \u27e8uIcc 0 1, isCompact_uIcc\u27e9 using 1\n      exact funext fun n => neK _ _\n    _ = \u2211' n : \u2124, \u222b x in (0 : \u211d)..1, (e * f).comp (ContinuousMap.addRight n) x := by\n      simp only [ContinuousMap.comp_apply] at eadd \u22a2\n      simp only [mul_comp] at eadd \u22a2\n      simp_rw [eadd]\n    -- Rearrange sum of interval integrals into an integral over `\u211d`.\n    _ = \u222b x, e x * f x := by\n      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq\n      apply integrable_of_summable_norm_Icc\n      convert hf \u27e8Icc 0 1, isCompact_Icc\u27e9 using 1\n      simp_rw [mul_comp] at eadd \u22a2\n      simp_rw [eadd]\n      exact funext fun n => neK \u27e8Icc 0 1, isCompact_Icc\u27e9 _\n    -- Minor tidying to finish\n    _ = \ud835\udcd5 f m := by\n      rw [fourierIntegral_real_eq_integral_exp_smul]\n      congr 1 with x : 1\n      rw [smul_eq_mul]\n      rw [comp_apply]\n      rw [coe_mk]\n      rw [coe_mk]\n      rw [ContinuousMap.toFun_eq_coe]\n      rw [fourier_coe_apply]\n      congr 2\n      push_cast\n      ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/PoissonSummation.lean", "context": {"open": ["Function hiding comp_apply", "Set hiding restrict_apply", "Complex hiding abs_of_nonneg", "Real", "TopologicalSpace Filter MeasureTheory Asymptotics", "scoped Real Filter FourierTransform", "ContinuousMap"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n => \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\n\u22a2 fourierCoeff \u22ef.lift m = fourierIntegral \u21d1f \u2191m"}, {"line": "let e : C(\u211d, \u2102) := (fourier (-m)).comp \u27e8((\u2191) : \u211d \u2192 UnitAddCircle), continuous_quotient_mk'\u27e9", "tactic_state": "f : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n => \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\ne : C(\u211d, \u2102) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := \u22ef }\n\u22a2 fourierCoeff \u22ef.lift m = fourierIntegral \u21d1f \u2191m"}, {"line": "have neK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016(e * g).restrict K\u2016 = \u2016g.restrict K\u2016 := by\n    have (x : \u211d) : \u2016e x\u2016 = 1 := (AddCircle.toCircle (-m \u2022 x)).norm_coe\n    intro K g\n    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]", "tactic_state": "f : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n => \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\ne : C(\u211d, \u2102) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := \u22ef }\nneK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016ContinuousMap.restrict (\u2191K) (e * g)\u2016 = \u2016ContinuousMap.restrict (\u2191K) g\u2016\n\u22a2 fourierCoeff \u22ef.lift m = fourierIntegral \u21d1f \u2191m"}, {"line": "have eadd : \u2200 (n : \u2124), e.comp (ContinuousMap.addRight n) = e := by\n    intro n; ext1 x\n    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))\n    simpa only [mul_one] using this.int_mul n x", "tactic_state": "f : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n => \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\ne : C(\u211d, \u2102) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := \u22ef }\nneK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016ContinuousMap.restrict (\u2191K) (e * g)\u2016 = \u2016ContinuousMap.restrict (\u2191K) g\u2016\neadd : \u2200 (n : \u2124), e.comp (ContinuousMap.addRight \u2191n) = e\n\u22a2 fourierCoeff \u22ef.lift m = fourierIntegral \u21d1f \u2191m"}, {"line": "calc\n    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =\n        \u222b x in (0 : \u211d)..1, e x * (\u2211' n : \u2124, f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,\n        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]\n    _ = \u222b x in (0 : \u211d)..1, \u2211' n : \u2124, (e * f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [coe_mul, Pi.mul_apply,\n        \u2190 ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]\n    _ = \u2211' n : \u2124, \u222b x in (0 : \u211d)..1, (e * f.comp (ContinuousMap.addRight n)) x := by\n      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm\n      convert hf \u27e8uIcc 0 1, isCompact_uIcc\u27e9 using 1\n      exact funext fun n => neK _ _\n    _ = \u2211' n : \u2124, \u222b x in (0 : \u211d)..1, (e * f).comp (ContinuousMap.addRight n) x := by\n      simp only [ContinuousMap.comp_apply] at eadd \u22a2\n      simp only [mul_comp] at eadd \u22a2\n      simp_rw [eadd]\n    _ = \u222b x, e x * f x := by\n      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq\n      apply integrable_of_summable_norm_Icc\n      convert hf \u27e8Icc 0 1, isCompact_Icc\u27e9 using 1\n      simp_rw [mul_comp] at eadd \u22a2\n      simp_rw [eadd]\n      exact funext fun n => neK \u27e8Icc 0 1, isCompact_Icc\u27e9 _\n    _ = \ud835\udcd5 f m := by\n      rw [fourierIntegral_real_eq_integral_exp_smul]\n      congr 1 with x : 1\n      rw [smul_eq_mul]\n      rw [comp_apply]\n      rw [coe_mk]\n      rw [coe_mk]\n      rw [ContinuousMap.toFun_eq_coe]\n      rw [fourier_coe_apply]\n      congr 2\n      push_cast\n      ring", "tactic_state": "case calc.step\nf : C(\u211d, \u2102)\nhf : \u2200 (K : Compacts \u211d), Summable fun n => \u2016ContinuousMap.restrict (\u2191K) (f.comp (ContinuousMap.addRight \u2191n))\u2016\nm : \u2124\ne : C(\u211d, \u2102) := (fourier (-m)).comp { toFun := QuotientAddGroup.mk, continuous_toFun := \u22ef }\nneK : \u2200 (K : Compacts \u211d) (g : C(\u211d, \u2102)), \u2016ContinuousMap.restrict (\u2191K) (e * g)\u2016 = \u2016ContinuousMap.restrict (\u2191K) g\u2016\neadd : \u2200 (n : \u2124), e.comp (ContinuousMap.addRight \u2191n) = e\n\u22a2 sorry = fourierIntegral \u21d1f \u2191m"}]}
{"declaration": "theorem SchwartzMap.tsum_eq_tsum_fourierIntegral (f : SchwartzMap \u211d \u2102) (x : \u211d) :\n    \u2211' n : \u2124, f (x + n) = \u2211' n : \u2124, fourierTransformCLM \u211d f n * fourier n (x : UnitAddCircle) := by\n  -- We know that Schwartz functions are `O(\u2016x ^ (-b)\u2016)` for *every* `b`; for this argument we take\n  -- `b = 2` and work with that.\n  apply Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay f.continuous one_lt_two\n    (f.isBigO_cocompact_rpow (-2)) ((fourierTransformCLM \u211d f).isBigO_cocompact_rpow (-2))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/PoissonSummation.lean", "context": {"open": ["Function hiding comp_apply", "Set hiding restrict_apply", "Complex hiding abs_of_nonneg", "Real", "TopologicalSpace Filter MeasureTheory Asymptotics", "scoped Real Filter FourierTransform", "ContinuousMap"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : SchwartzMap \u211d \u2102\nx : \u211d\n\u22a2 \u2211' (n : \u2124), f (x + \u2191n) = \u2211' (n : \u2124), ((fourierTransformCLM \u211d) f) \u2191n * (fourier n) \u2191x"}, {"line": "apply Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay f.continuous one_lt_two\n    (f.isBigO_cocompact_rpow (-2)) ((fourierTransformCLM \u211d f).isBigO_cocompact_rpow (-2))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_eq_ite (\u03c8 : AddChar G R) : \ud835\udd3c a, \u03c8 a = if \u03c8 = 0 then 1 else 0 := by\n  simp [Fintype.expect_eq_sum_div_card, sum_eq_ite, ite_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FiniteAbelian/Orthogonality.lean", "context": {"open": ["Finset hiding card", "Fintype (card)", "Function RCLike", "scoped BigOperators ComplexConjugate DirectSum"], "variables": ["{G H R : Type*}", "[AddGroup G]", "[Fintype G] [Semifield R] [IsDomain R] [CharZero R] {\u03c8 : AddChar G R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nR : Type u_3\ninst\u271d\u2074 : AddGroup G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\n\u03c8 : AddChar G R\n\u22a2 (univ.expect fun a => \u03c8 a) = if \u03c8 = 0 then 1 else 0"}, {"line": "simp [Fintype.expect_eq_sum_div_card, sum_eq_ite, ite_div]", "tactic_state": "G : Type u_1\nR : Type u_3\ninst\u271d\u2074 : AddGroup G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Semifield R\ninst\u271d\u00b9 : IsDomain R\ninst\u271d : CharZero R\n\u03c8 : AddChar G R\n\u22a2 (\u2211 a, \u03c8 a) / \u2191(card G) = if \u03c8 = 0 then 1 else 0"}]}
{"declaration": "lemma forall_apply_eq_zero : (\u2200 \u03c8 : AddChar \u03b1 \u2102, \u03c8 a = 1) \u2194 a = 0 := by\n  simpa using exists_apply_ne_zero.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FiniteAbelian/PontryaginDuality.lean", "context": {"open": ["Circle Finset Function Multiplicative", "Fintype (card)", "Real hiding exp", "scoped BigOperators DirectSum"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] {n : \u2115} {a b : \u03b1}", "(n : \u2115) [NeZero n]", "{n}", "(\u03b1) [Finite \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : AddCommGroup \u03b1\na : \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 (\u2200 (\u03c8 : AddChar \u03b1 \u2102), \u03c8 a = 1) \u2194 a = 0"}, {"line": "simpa using exists_apply_ne_zero.not", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_apply_eq_ite [Fintype \u03b1] [DecidableEq \u03b1] (a : \u03b1) :\n    \u2211 \u03c8 : AddChar \u03b1 \u2102, \u03c8 a = if a = 0 then (Fintype.card \u03b1 : \u2102) else 0 := by\n  simpa using sum_eq_ite (doubleDualEmb a : AddChar (AddChar \u03b1 \u2102) \u2102)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FiniteAbelian/PontryaginDuality.lean", "context": {"open": ["Circle Finset Function Multiplicative", "Fintype (card)", "Real hiding exp", "scoped BigOperators DirectSum"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] {n : \u2115} {a b : \u03b1}", "(n : \u2115) [NeZero n]", "{n}", "(\u03b1) [Finite \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 \u2211 \u03c8, \u03c8 a = if a = 0 then \u2191(Fintype.card \u03b1) else 0"}, {"line": "simpa using sum_eq_ite (doubleDualEmb a : AddChar (AddChar \u03b1 \u2102) \u2102)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_apply_eq_ite [Finite \u03b1] [DecidableEq \u03b1] (a : \u03b1) :\n    \ud835\udd3c \u03c8 : AddChar \u03b1 \u2102, \u03c8 a = if a = 0 then 1 else 0 := by\n  simpa using expect_eq_ite (doubleDualEmb a : AddChar (AddChar \u03b1 \u2102) \u2102)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Fourier/FiniteAbelian/PontryaginDuality.lean", "context": {"open": ["Circle Finset Function Multiplicative", "Fintype (card)", "Real hiding exp", "scoped BigOperators DirectSum"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] {n : \u2115} {a b : \u03b1}", "(n : \u2115) [NeZero n]", "{n}", "(\u03b1) [Finite \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Finite \u03b1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\n\u22a2 (univ.expect fun \u03c8 => \u03c8 a) = if a = 0 then 1 else 0"}, {"line": "simpa using expect_eq_ite (doubleDualEmb a : AddChar (AddChar \u03b1 \u2102) \u2102)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_abs_rpow (x : \u211d) {p : \u211d} (hp : 1 < p) :\n    HasDerivAt (fun x : \u211d \u21a6 |x| ^ p) (p * |x| ^ (p - 2) * x) x := by\n  simpa using hasDerivAt_norm_rpow x hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/NormPow.lean", "context": {"open": ["Asymptotics Real Topology", "scoped NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x p : \u211d\nhp : 1 < p\n\u22a2 HasDerivAt (fun x => |x| ^ p) (p * |x| ^ (p - 2) * x) x"}, {"line": "simpa using hasDerivAt_norm_rpow x hp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_fderiv_norm_rpow_le {f : F \u2192 E} (hf : Differentiable \u211d f)\n    {x : F} {p : \u211d\u22650} (hp : 1 < p) :\n    \u2016fderiv \u211d (fun x \u21a6 \u2016f x\u2016 ^ (p : \u211d)) x\u2016\u2091 \u2264 p * \u2016f x\u2016\u2091 ^ ((p : \u211d) - 1) * \u2016fderiv \u211d f x\u2016\u2091 := by\n  simpa [enorm, \u2190 ENNReal.coe_rpow_of_nonneg _ (sub_nonneg.2 <| NNReal.one_le_coe.2 hp.le),\n    \u2190 ENNReal.coe_mul] using nnnorm_fderiv_norm_rpow_le hf hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/NormPow.lean", "context": {"open": ["Asymptotics Real Topology", "scoped NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : NormedSpace \u211d F\nf : F \u2192 E\nhf : Differentiable \u211d f\nx : F\np : NNReal\nhp : 1 < p\n\u22a2 \u2016fderiv \u211d (fun x => \u2016f x\u2016 ^ \u2191p) x\u2016\u2091 \u2264 \u2191p * \u2016f x\u2016\u2091 ^ (\u2191p - 1) * \u2016fderiv \u211d f x\u2016\u2091"}, {"line": "simpa [enorm, \u2190 ENNReal.coe_rpow_of_nonneg _ (sub_nonneg.2 <| NNReal.one_le_coe.2 hp.le),\n    \u2190 ENNReal.coe_mul] using nnnorm_fderiv_norm_rpow_le hf hp", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux1 (x y z : E) :\n    \u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016\n    = 2 * (\u2016x + y + z\u2016 * \u2016x + y + z\u2016 + \u2016x - z\u2016 * \u2016x - z\u2016) := by\n  convert parallelogram_identity (x + y + z) (x - z) using 4 <;> abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpaceable E\nx y z : E\n\u22a2 \u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 = 2 * (\u2016x + y + z\u2016 * \u2016x + y + z\u2016 + \u2016x - z\u2016 * \u2016x - z\u2016)"}, {"line": "convert parallelogram_identity (x + y + z) (x - z) using 4 <;> abel", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux2 (x y z : E) : \u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016\n    = 2 * (\u2016x + y - z\u2016 * \u2016x + y - z\u2016 + \u2016x + z\u2016 * \u2016x + z\u2016) := by\n  convert parallelogram_identity (x + y - z) (x + z) using 4 <;> abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpaceable E\nx y z : E\n\u22a2 \u20162 \u2022 x + y\u2016 * \u20162 \u2022 x + y\u2016 + \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016 = 2 * (\u2016x + y - z\u2016 * \u2016x + y - z\u2016 + \u2016x + z\u2016 * \u2016x + z\u2016)"}, {"line": "convert parallelogram_identity (x + y - z) (x + z) using 4 <;> abel", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux3 (y z : E) :\n    \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 + \u2016y\u2016 * \u2016y\u2016 = 2 * (\u2016y + z\u2016 * \u2016y + z\u2016 + \u2016z\u2016 * \u2016z\u2016) := by\n  convert parallelogram_identity (y + z) z using 4 <;> abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpaceable E\ny z : E\n\u22a2 \u20162 \u2022 z + y\u2016 * \u20162 \u2022 z + y\u2016 + \u2016y\u2016 * \u2016y\u2016 = 2 * (\u2016y + z\u2016 * \u2016y + z\u2016 + \u2016z\u2016 * \u2016z\u2016)"}, {"line": "convert parallelogram_identity (y + z) z using 4 <;> abel", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux4 (y z : E) :\n    \u2016y\u2016 * \u2016y\u2016 + \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016 = 2 * (\u2016y - z\u2016 * \u2016y - z\u2016 + \u2016z\u2016 * \u2016z\u2016) := by\n  convert parallelogram_identity (y - z) z using 4 <;> abel\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpaceable E\ny z : E\n\u22a2 \u2016y\u2016 * \u2016y\u2016 + \u2016y - 2 \u2022 z\u2016 * \u2016y - 2 \u2022 z\u2016 = 2 * (\u2016y - z\u2016 * \u2016y - z\u2016 + \u2016z\u2016 * \u2016z\u2016)"}, {"line": "convert parallelogram_identity (y - z) z using 4 <;> abel", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux5 (x y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 * \u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016\n    + \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016\n    = 2 * (\u2016(I : \ud835\udd5c) \u2022 (x + y) + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 (x + y) + z\u2016\n    + \u2016(I : \ud835\udd5c) \u2022 x - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 x - z\u2016) := by\n  convert parallelogram_identity ((I : \ud835\udd5c) \u2022 (x + y) + z) ((I : \ud835\udd5c) \u2022 x - z) using 4 <;> module\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : InnerProductSpaceable E\nx y z : E\n\u22a2 \u2016I \u2022 (2 \u2022 x + y)\u2016 * \u2016I \u2022 (2 \u2022 x + y)\u2016 + \u2016I \u2022 y + 2 \u2022 z\u2016 * \u2016I \u2022 y + 2 \u2022 z\u2016 =\n    2 * (\u2016I \u2022 (x + y) + z\u2016 * \u2016I \u2022 (x + y) + z\u2016 + \u2016I \u2022 x - z\u2016 * \u2016I \u2022 x - z\u2016)"}, {"line": "convert parallelogram_identity ((I : \ud835\udd5c) \u2022 (x + y) + z) ((I : \ud835\udd5c) \u2022 x - z) using 4 <;> module", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux6 (x y z : E) :\n    (\u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 * \u2016(I : \ud835\udd5c) \u2022 (2 \u2022 x + y)\u2016 +\n    \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016)\n    = 2 * (\u2016(I : \ud835\udd5c) \u2022 (x + y) - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 (x + y) - z\u2016 +\n    \u2016(I : \ud835\udd5c) \u2022 x + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 x + z\u2016) := by\n  convert parallelogram_identity ((I : \ud835\udd5c) \u2022 (x + y) - z) ((I : \ud835\udd5c) \u2022 x + z) using 4 <;> module\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : InnerProductSpaceable E\nx y z : E\n\u22a2 \u2016I \u2022 (2 \u2022 x + y)\u2016 * \u2016I \u2022 (2 \u2022 x + y)\u2016 + \u2016I \u2022 y - 2 \u2022 z\u2016 * \u2016I \u2022 y - 2 \u2022 z\u2016 =\n    2 * (\u2016I \u2022 (x + y) - z\u2016 * \u2016I \u2022 (x + y) - z\u2016 + \u2016I \u2022 x + z\u2016 * \u2016I \u2022 x + z\u2016)"}, {"line": "convert parallelogram_identity ((I : \ud835\udd5c) \u2022 (x + y) - z) ((I : \ud835\udd5c) \u2022 x + z) using 4 <;> module", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux7 (y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + 2 \u2022 z\u2016 + \u2016(I : \ud835\udd5c) \u2022 y\u2016 * \u2016(I : \ud835\udd5c) \u2022 y\u2016 =\n    2 * (\u2016(I : \ud835\udd5c) \u2022 y + z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y + z\u2016 + \u2016z\u2016 * \u2016z\u2016) := by\n  convert parallelogram_identity ((I : \ud835\udd5c) \u2022 y + z) z using 4 <;> module\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : InnerProductSpaceable E\ny z : E\n\u22a2 \u2016I \u2022 y + 2 \u2022 z\u2016 * \u2016I \u2022 y + 2 \u2022 z\u2016 + \u2016I \u2022 y\u2016 * \u2016I \u2022 y\u2016 = 2 * (\u2016I \u2022 y + z\u2016 * \u2016I \u2022 y + z\u2016 + \u2016z\u2016 * \u2016z\u2016)"}, {"line": "convert parallelogram_identity ((I : \ud835\udd5c) \u2022 y + z) z using 4 <;> module", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem add_left_aux8 (y z : E) :\n    \u2016(I : \ud835\udd5c) \u2022 y\u2016 * \u2016(I : \ud835\udd5c) \u2022 y\u2016 + \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - 2 \u2022 z\u2016 =\n    2 * (\u2016(I : \ud835\udd5c) \u2022 y - z\u2016 * \u2016(I : \ud835\udd5c) \u2022 y - z\u2016 + \u2016z\u2016 * \u2016z\u2016) := by\n  convert parallelogram_identity ((I : \ud835\udd5c) \u2022 y - z) z using 4 <;> module\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/OfNorm.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (E : Type*) [NormedAddCommGroup E]", "(\ud835\udd5c) {E}", "[NormedSpace \ud835\udd5c E]", "{\ud835\udd5c} (E)", "{E}", "[InnerProductSpaceable E]", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\ninst\u271d : InnerProductSpaceable E\ny z : E\n\u22a2 \u2016I \u2022 y\u2016 * \u2016I \u2022 y\u2016 + \u2016I \u2022 y - 2 \u2022 z\u2016 * \u2016I \u2022 y - 2 \u2022 z\u2016 = 2 * (\u2016I \u2022 y - z\u2016 * \u2016I \u2022 y - z\u2016 + \u2016z\u2016 * \u2016z\u2016)"}, {"line": "convert parallelogram_identity ((I : \ud835\udd5c) \u2022 y - z) z using 4 <;> module", "tactic_state": "No Goals!"}]}
{"declaration": "theorem same_orientation_iff_det_eq_det :\n    e.toBasis.det = f.toBasis.det \u2194 e.toBasis.orientation = f.toBasis.orientation := by\n  constructor\n  \u00b7 intro h\n    dsimp [Basis.orientation]\n    congr\n  \u00b7 intro h\n    rw [e.toBasis.det.eq_smul_basis_det f.toBasis]\n    simp [e.det_to_matrix_orthonormalBasis_of_same_orientation f h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\n\u22a2 e.toBasis.det = f.toBasis.det \u2194 e.toBasis.orientation = f.toBasis.orientation"}, {"line": "constructor", "tactic_state": "case mp\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\n\u22a2 e.toBasis.det = f.toBasis.det \u2192 e.toBasis.orientation = f.toBasis.orientation\n---\ncase mpr\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\n\u22a2 e.toBasis.orientation = f.toBasis.orientation \u2192 e.toBasis.det = f.toBasis.det"}, {"line": "\u00b7 intro h\n    dsimp [Basis.orientation]\n    congr", "tactic_state": "case mpr\nE : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne f : OrthonormalBasis \u03b9 \u211d E\n\u22a2 e.toBasis.orientation = f.toBasis.orientation \u2192 e.toBasis.det = f.toBasis.det"}, {"line": "\u00b7 intro h\n    rw [e.toBasis.det.eq_smul_basis_det f.toBasis]\n    simp [e.det_to_matrix_orthonormalBasis_of_same_orientation f h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjustToOrientation_apply_eq_or_eq_neg (i : \u03b9) :\n    e.adjustToOrientation x i = e i \u2228 e.adjustToOrientation x i = -e i := by\n  simpa [\u2190 e.toBasis_adjustToOrientation] using\n    e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}", "(e f)", "[Nonempty \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ne : OrthonormalBasis \u03b9 \u211d E\ninst\u271d : Nonempty \u03b9\nx : Orientation \u211d E \u03b9\ni : \u03b9\n\u22a2 (e.adjustToOrientation x) i = e i \u2228 (e.adjustToOrientation x) i = -e i"}, {"line": "simpa [\u2190 e.toBasis_adjustToOrientation] using\n    e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_adjustToOrientation :\n    (e.adjustToOrientation x).toBasis.det = e.toBasis.det \u2228\n      (e.adjustToOrientation x).toBasis.det = -e.toBasis.det := by\n  simpa using e.toBasis.det_adjustToOrientation x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}", "(e f)", "[Nonempty \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \u211d E\n\u03b9 : Type u_2\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ne : OrthonormalBasis \u03b9 \u211d E\ninst\u271d : Nonempty \u03b9\nx : Orientation \u211d E \u03b9\n\u22a2 (e.adjustToOrientation x).toBasis.det = e.toBasis.det \u2228 (e.adjustToOrientation x).toBasis.det = -e.toBasis.det"}, {"line": "simpa using e.toBasis.det_adjustToOrientation x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finOrthonormalBasis_orientation (hn : 0 < n) (h : finrank \u211d E = n)\n    (x : Orientation \u211d E (Fin n)) : (x.finOrthonormalBasis hn h).toBasis.orientation = x := by\n  haveI := Fin.pos_iff_nonempty.1 hn\n  haveI : FiniteDimensional \u211d E := .of_finrank_pos <| h.symm \u25b8 hn\n  exact ((@stdOrthonormalBasis _ _ _ _ _ this).reindex <|\n    finCongr h).orientation_adjustToOrientation x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace", "OrthonormalBasis"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}", "(e f)", "[Nonempty \u03b9]", "{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn : \u2115\nhn : 0 < n\nh : finrank \u211d E = n\nx : Orientation \u211d E (Fin n)\n\u22a2 (Orientation.finOrthonormalBasis hn h x).toBasis.orientation = x"}, {"line": "haveI := Fin.pos_iff_nonempty.1 hn", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn : \u2115\nhn : 0 < n\nh : finrank \u211d E = n\nx : Orientation \u211d E (Fin n)\nthis : Nonempty (Fin n)\n\u22a2 (Orientation.finOrthonormalBasis hn h x).toBasis.orientation = x"}, {"line": "haveI : FiniteDimensional \u211d E := .of_finrank_pos <| h.symm \u25b8 hn", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn : \u2115\nhn : 0 < n\nh : finrank \u211d E = n\nx : Orientation \u211d E (Fin n)\nthis\u271d : Nonempty (Fin n)\nthis : sorry\n\u22a2 (Orientation.finOrthonormalBasis hn h x).toBasis.orientation = x"}, {"line": "exact ((@stdOrthonormalBasis _ _ _ _ _ this).reindex <|\n    finCongr h).orientation_adjustToOrientation x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem volumeForm_zero_pos [_i : Fact (finrank \u211d E = 0)] :\n    Orientation.volumeForm (positiveOrientation : Orientation \u211d E (Fin 0)) =\n      AlternatingMap.constLinearEquivOfIsEmpty 1 := by\n  simp [volumeForm, Or.by_cases, if_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace", "OrthonormalBasis"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}", "(e f)", "[Nonempty \u03b9]", "{n : \u2115}", "[_i : Fact (finrank \u211d E = n)] (o : Orientation \u211d E (Fin n))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\n_i : Fact (finrank \u211d E = 0)\n\u22a2 positiveOrientation.volumeForm = AlternatingMap.constLinearEquivOfIsEmpty 1"}, {"line": "simp [volumeForm, Or.by_cases, if_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem volumeForm_robust' (b : OrthonormalBasis (Fin n) \u211d E) (v : Fin n \u2192 E) :\n    |o.volumeForm v| = |b.toBasis.det v| := by\n  cases n\n  \u00b7 refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  \u00b7 rw [o.volumeForm_robust (b.adjustToOrientation o) (b.orientation_adjustToOrientation o),\n      b.abs_det_adjustToOrientation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orientation.lean", "context": {"open": ["Module", "scoped RealInnerProductSpace", "OrthonormalBasis"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "{\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (e f : OrthonormalBasis \u03b9 \u211d E)", "{e f}", "(e f)", "[Nonempty \u03b9]", "{n : \u2115}", "[_i : Fact (finrank \u211d E = n)] (o : Orientation \u211d E (Fin n))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn : \u2115\n_i : Fact (finrank \u211d E = n)\no : Orientation \u211d E (Fin n)\nb : OrthonormalBasis (Fin n) \u211d E\nv : Fin n \u2192 E\n\u22a2 |o.volumeForm v| = |b.toBasis.det v|"}, {"line": "cases n", "tactic_state": "case zero\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\n_i : Fact (finrank \u211d E = 0)\no : Orientation \u211d E (Fin 0)\nb : OrthonormalBasis (Fin 0) \u211d E\nv : Fin 0 \u2192 E\n\u22a2 |o.volumeForm v| = |b.toBasis.det v|\n---\ncase succ\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn\u271d : \u2115\n_i : Fact (finrank \u211d E = n\u271d + 1)\no : Orientation \u211d E (Fin (n\u271d + 1))\nb : OrthonormalBasis (Fin (n\u271d + 1)) \u211d E\nv : Fin (n\u271d + 1) \u2192 E\n\u22a2 |o.volumeForm v| = |b.toBasis.det v|"}, {"line": "\u00b7 refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp", "tactic_state": "case succ\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nn\u271d : \u2115\n_i : Fact (finrank \u211d E = n\u271d + 1)\no : Orientation \u211d E (Fin (n\u271d + 1))\nb : OrthonormalBasis (Fin (n\u271d + 1)) \u211d E\nv : Fin (n\u271d + 1) \u2192 E\n\u22a2 |o.volumeForm v| = |b.toBasis.det v|"}, {"line": "\u00b7 rw [o.volumeForm_robust (b.adjustToOrientation o) (b.orientation_adjustToOrientation o),\n      b.abs_det_adjustToOrientation]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E \u2192L[\ud835\udd5c] E}\n    (hA : (A : E \u2192\u2097[\ud835\udd5c] E).IsSymmetric) : IsSelfAdjoint A := by\n  rwa [\u2190 ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric] at hA\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Adjoint.lean", "context": {"open": ["RCLike", "scoped ComplexConjugate", "InnerProductSpace", "InnerProduct", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c E F G : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F] [NormedAddCommGroup G]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c F] [InnerProductSpace \ud835\udd5c G]", "[CompleteSpace E] [CompleteSpace G]", "[CompleteSpace F]", "[CompleteSpace E] [CompleteSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 inst\u271d : CompleteSpace E\nA : E \u2192L[\ud835\udd5c] E\nhA : (\u2191A).IsSymmetric\n\u22a2 IsSelfAdjoint A"}, {"line": "rwa [\u2190 ContinuousLinearMap.isSelfAdjoint_iff_isSymmetric] at hA", "tactic_state": "No Goals!"}]}
{"declaration": "theorem real_inner_self_eq_norm_sq (x : F) : \u27eax, x\u27eb_\u211d = \u2016x\u2016 ^ 2 := by\n  rw [pow_two]\n  rw [real_inner_self_eq_norm_mul_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Basic.lean", "context": {"open": ["RCLike Real Filter Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)", "scoped InnerProductSpace", "scoped InnerProductSpace in", "scoped InnerProductSpace in", "scoped InnerProductSpace"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{\ud835\udd5d : Type*} [CommSemiring \ud835\udd5d] [StarRing \ud835\udd5d] [Algebra \ud835\udd5d \ud835\udd5c] [Module \ud835\udd5d E]", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [InnerProductSpace \u211d F]", "(\ud835\udd5c)", "{\ud835\udd5c}", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : InnerProductSpace \u211d F\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx : F\n\u22a2 inner x x = \u2016x\u2016 ^ 2"}, {"line": "rw [pow_two]", "tactic_state": "F : Type u_3\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : InnerProductSpace \u211d F\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx : F\n\u22a2 inner x x = \u2016x\u2016 * \u2016x\u2016"}, {"line": "rw [real_inner_self_eq_norm_mul_norm]", "tactic_state": "F : Type u_3\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : InnerProductSpace \u211d F\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\ninst\u271d\u00b9 : SeminormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nx : F\n\u22a2 \u2016x\u2016 * \u2016x\u2016 = \u2016x\u2016 * \u2016x\u2016"}]}
{"declaration": "theorem HasDerivAt.norm_sq {f : \u211d \u2192 F} {f' : F} {x : \u211d} (hf : HasDerivAt f f' x) :\n    HasDerivAt (\u2016f \u00b7\u2016 ^ 2) (2 * Inner.inner (f x) f') x := by\n  simpa using hf.hasFDerivAt.norm_sq.hasDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Calculus.lean", "context": {"open": ["RCLike Real Filter"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [InnerProductSpace \u211d F]", "(\ud835\udd5c) [NormedSpace \u211d E]", "{\ud835\udd5c}", "(\ud835\udd5c)", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \u211d G] {f g : G \u2192 E} {f' g' : G \u2192L[\u211d] E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nf : \u211d \u2192 F\nf' : F\nx : \u211d\nhf : HasDerivAt f f' x\n\u22a2 HasDerivAt (fun x => \u2016f x\u2016 ^ 2) (2 * Inner.inner (f x) f') x"}, {"line": "simpa using hf.hasFDerivAt.norm_sq.hasDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.norm_sq {f : \u211d \u2192 F} {f' : F} {s : Set \u211d} {x : \u211d}\n    (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (\u2016f \u00b7\u2016 ^ 2) (2 * Inner.inner (f x) f') s x := by\n  simpa using hf.hasFDerivWithinAt.norm_sq.hasDerivWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Calculus.lean", "context": {"open": ["RCLike Real Filter"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [InnerProductSpace \u211d F]", "(\ud835\udd5c) [NormedSpace \u211d E]", "{\ud835\udd5c}", "(\ud835\udd5c)", "{G : Type*} [NormedAddCommGroup G] [NormedSpace \u211d G] {f g : G \u2192 E} {f' g' : G \u2192L[\u211d] E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nf : \u211d \u2192 F\nf' : F\ns : Set \u211d\nx : \u211d\nhf : HasDerivWithinAt f f' s x\n\u22a2 HasDerivWithinAt (fun x => \u2016f x\u2016 ^ 2) (2 * Inner.inner (f x) f') s x"}, {"line": "simpa using hf.hasFDerivWithinAt.norm_sq.hasDerivWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_eq_zero_of_eq_zero {x : F} : x = 0 \u2192 normSqF x = 0 := by\n  rintro rfl\n  simp [normSq, inner_self_of_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Defs.lean", "context": {"open": ["RCLike Real Filter Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[AddCommGroup F] [Module \ud835\udd5c F] [c : PreInnerProductSpace.Core \ud835\udd5c F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d : AddCommGroup F\nx\u271d : Sort u_4\nnormSqF : x\u271d\nx : F\n\u22a2 x = 0 \u2192 sorry = 0"}, {"line": "rintro rfl", "tactic_state": "F : Type u_3\ninst\u271d : AddCommGroup F\nx\u271d : Sort u_4\nnormSqF : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [normSq, inner_self_of_eq_zero]", "tactic_state": "F : Type u_3\ninst\u271d : AddCommGroup F\nx\u271d : Sort u_4\nnormSqF : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem gramSchmidt_def' (f : \u03b9 \u2192 E) (n : \u03b9) :\n    f n = gramSchmidt \ud835\udd5c f n + \u2211 i \u2208 Iio n, (\ud835\udd5c \u2219 gramSchmidt \ud835\udd5c f i).orthogonalProjection (f n) := by\n  rw [gramSchmidt_def]\n  rw [sub_add_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "context": {"open": ["Finset Submodule Module"], "variables": ["(\ud835\udd5c : Type*) {E : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [WellFoundedLT \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nn : \u03b9\n\u22a2 f n = gramSchmidt \ud835\udd5c f n + \u2211 i \u2208 Iio n, \u2191((span \ud835\udd5c {gramSchmidt \ud835\udd5c f i}).orthogonalProjection (f n))"}, {"line": "rw [gramSchmidt_def]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nn : \u03b9\n\u22a2 f n =\n    f n - \u2211 i \u2208 Iio n, \u2191((span \ud835\udd5c {gramSchmidt \ud835\udd5c f i}).orthogonalProjection (f n)) +\n      \u2211 i \u2208 Iio n, \u2191((span \ud835\udd5c {gramSchmidt \ud835\udd5c f i}).orthogonalProjection (f n))"}, {"line": "rw [sub_add_cancel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gramSchmidt_orthonormal {f : \u03b9 \u2192 E} (h\u2080 : LinearIndependent \ud835\udd5c f) :\n    Orthonormal \ud835\udd5c (gramSchmidtNormed \ud835\udd5c f) := by\n  unfold Orthonormal\n  constructor\n  \u00b7 simp only [gramSchmidtNormed_unit_length, h\u2080, eq_self_iff_true, imp_true_iff]\n  \u00b7 intro i j hij\n    simp only [gramSchmidtNormed]\n    simp only [inner_smul_left]\n    simp only [inner_smul_right]\n    simp only [RCLike.conj_inv]\n    simp only [RCLike.conj_ofReal]\n    simp only [mul_eq_zero]\n    simp only [inv_eq_zero]\n    simp only [RCLike.ofReal_eq_zero]\n    simp only [norm_eq_zero]\n    repeat' right\n    exact gramSchmidt_orthogonal \ud835\udd5c f hij\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "context": {"open": ["Finset Submodule Module", "Submodule Set Order"], "variables": ["(\ud835\udd5c : Type*) {E : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [WellFoundedLT \u03b9]", "{\ud835\udd5c}", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nh\u2080 : LinearIndependent \ud835\udd5c f\n\u22a2 Orthonormal \ud835\udd5c (gramSchmidtNormed \ud835\udd5c f)"}, {"line": "unfold Orthonormal", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nh\u2080 : LinearIndependent \ud835\udd5c f\n\u22a2 (\u2200 (i : \u03b9), \u2016gramSchmidtNormed \ud835\udd5c f i\u2016 = 1) \u2227\n    Pairwise fun i j => inner (gramSchmidtNormed \ud835\udd5c f i) (gramSchmidtNormed \ud835\udd5c f j) = 0"}, {"line": "constructor", "tactic_state": "case left\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nh\u2080 : LinearIndependent \ud835\udd5c f\n\u22a2 \u2200 (i : \u03b9), \u2016gramSchmidtNormed \ud835\udd5c f i\u2016 = 1\n---\ncase right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nh\u2080 : LinearIndependent \ud835\udd5c f\n\u22a2 Pairwise fun i j => inner (gramSchmidtNormed \ud835\udd5c f i) (gramSchmidtNormed \ud835\udd5c f j) = 0"}, {"line": "\u00b7 simp only [gramSchmidtNormed_unit_length, h\u2080, eq_self_iff_true, imp_true_iff]", "tactic_state": "case right\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\nh\u2080 : LinearIndependent \ud835\udd5c f\n\u22a2 Pairwise fun i j => inner (gramSchmidtNormed \ud835\udd5c f i) (gramSchmidtNormed \ud835\udd5c f j) = 0"}, {"line": "\u00b7 intro i j hij\n    simp only [gramSchmidtNormed]\n    simp only [inner_smul_left]\n    simp only [inner_smul_right]\n    simp only [RCLike.conj_inv]\n    simp only [RCLike.conj_ofReal]\n    simp only [mul_eq_zero]\n    simp only [inv_eq_zero]\n    simp only [RCLike.ofReal_eq_zero]\n    simp only [norm_eq_zero]\n    repeat' right\n    exact gramSchmidt_orthogonal \ud835\udd5c f hij", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gramSchmidt_orthonormal' (f : \u03b9 \u2192 E) :\n    Orthonormal \ud835\udd5c fun i : { i | gramSchmidtNormed \ud835\udd5c f i \u2260 0 } => gramSchmidtNormed \ud835\udd5c f i := by\n  refine \u27e8fun i => gramSchmidtNormed_unit_length' i.prop, ?_\u27e9\n  rintro i j (hij : \u00ac_)\n  rw [Subtype.ext_iff] at hij\n  simp [gramSchmidtNormed, inner_smul_left, inner_smul_right, gramSchmidt_orthogonal \ud835\udd5c f hij]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "context": {"open": ["Finset Submodule Module", "Submodule Set Order"], "variables": ["(\ud835\udd5c : Type*) {E : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [WellFoundedLT \u03b9]", "{\ud835\udd5c}", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\n\u22a2 Orthonormal \ud835\udd5c fun i => gramSchmidtNormed \ud835\udd5c f \u2191i"}, {"line": "refine \u27e8fun i => gramSchmidtNormed_unit_length' i.prop, ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\n\u22a2 Pairwise fun i j => inner ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) i) ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) j) = 0"}, {"line": "rintro i j (hij : \u00ac_)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\ni j : \u2191{i | gramSchmidtNormed \ud835\udd5c f i \u2260 0}\nhij : \u00aci = j\n\u22a2 inner ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) i) ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) j) = 0"}, {"line": "rw [Subtype.ext_iff] at hij", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\ni j : \u2191{i | gramSchmidtNormed \ud835\udd5c f i \u2260 0}\nhij : \u00ac\u2191i = \u2191j\n\u22a2 inner ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) i) ((fun i => gramSchmidtNormed \ud835\udd5c f \u2191i) j) = 0"}, {"line": "simp [gramSchmidtNormed, inner_smul_left, inner_smul_right, gramSchmidt_orthogonal \ud835\udd5c f hij]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\ni j : \u2191{i | gramSchmidtNormed \ud835\udd5c f i \u2260 0}\nhij : \u00ac\u2191i = \u2191j\n\u22a2 (\u2191\u2016gramSchmidt \ud835\udd5c f \u2191j\u2016)\u207b\u00b9 *\n      ((starRingEnd \ud835\udd5c) (\u2191\u2016gramSchmidt \ud835\udd5c f \u2191i\u2016)\u207b\u00b9 * inner (gramSchmidt \ud835\udd5c f \u2191i) (gramSchmidt \ud835\udd5c f \u2191j)) =\n    0"}]}
{"declaration": "theorem span_gramSchmidtNormed_range (f : \u03b9 \u2192 E) :\n    span \ud835\udd5c (range (gramSchmidtNormed \ud835\udd5c f)) = span \ud835\udd5c (range (gramSchmidt \ud835\udd5c f)) := by\n  simpa only [image_univ.symm] using span_gramSchmidtNormed f univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "context": {"open": ["Finset Submodule Module", "Submodule Set Order"], "variables": ["(\ud835\udd5c : Type*) {E : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [WellFoundedLT \u03b9]", "{\ud835\udd5c}", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_3\ninst\u271d\u00b2 : LinearOrder \u03b9\ninst\u271d\u00b9 : LocallyFiniteOrderBot \u03b9\ninst\u271d : WellFoundedLT \u03b9\nf : \u03b9 \u2192 E\n\u22a2 span \ud835\udd5c (Set.range (gramSchmidtNormed \ud835\udd5c f)) = span \ud835\udd5c (Set.range (gramSchmidt \ud835\udd5c f))"}, {"line": "simpa only [image_univ.symm] using span_gramSchmidtNormed f univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gramSchmidtOrthonormalBasis_inv_triangular' {i j : \u03b9} (hij : i < j) :\n    (gramSchmidtOrthonormalBasis h f).repr (f i) j = 0 := by\n  simpa [OrthonormalBasis.repr_apply_apply] using gramSchmidtOrthonormalBasis_inv_triangular h f hij\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/GramSchmidtOrtho.lean", "context": {"open": ["Finset Submodule Module", "Submodule Set Order"], "variables": ["(\ud835\udd5c : Type*) {E : Type*} [RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b9 : Type*} [LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [WellFoundedLT \u03b9]", "{\ud835\udd5c}", "(\ud835\udd5c) in", "[Fintype \u03b9] [FiniteDimensional \ud835\udd5c E] (h : finrank \ud835\udd5c E = Fintype.card \u03b9) (f : \u03b9 \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\ninst\u271d\u2075 : LinearOrder \u03b9\ninst\u271d\u2074 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u00b3 : WellFoundedLT \u03b9\nK\u271d : Type u_4\nE\u271d : Type u_5\ninst\u271d\u00b2 : RCLike K\u271d\ninst\u271d\u00b9 : NormedAddCommGroup E\u271d\nself\u271d : InnerProductSpace K\u271d E\u271d\ninst\u271d : Fintype \u03b9\nh : finrank K\u271d E\u271d = Fintype.card \u03b9\nf : \u03b9 \u2192 E\u271d\ni j : \u03b9\nhij : i < j\n\u22a2 sorry = 0"}, {"line": "simpa [OrthonormalBasis.repr_apply_apply] using gramSchmidtOrthonormalBasis_inv_triangular h f hij", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearMap.IsSymmetric.directSum_isInternal_of_pairwise_commute [DecidableEq (n \u2192 \ud835\udd5c)]\n    (hT : \u2200 i, (T i).IsSymmetric) (hC : Pairwise (Commute on T)) :\n    DirectSum.IsInternal (fun \u03b1 : n \u2192 \ud835\udd5c \u21a6 \u2a05 j, eigenspace (T j) (\u03b1 j)) := by\n  rw [OrthogonalFamily.isInternal_iff]\n  \u00b7 rw [iSup_iInf_eq_top_of_commute hT hC, top_orthogonal_eq_bot]\n  \u00b7 exact orthogonalFamily_iInf_eigenspaces hT\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/JointEigenspace.lean", "context": {"open": ["Module.End", "Submodule", "IsFinitelySemisimple", "scoped Function -- required for scoped `on` notation"], "variables": ["{\ud835\udd5c E n m : Type*}", "[RCLike \ud835\udd5c] [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{\u03b1 : \ud835\udd5c} {A B : E \u2192\u2097[\ud835\udd5c] E} {T : n \u2192 Module.End \ud835\udd5c E}", "[FiniteDimensional \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 DirectSum.IsInternal fun \u03b1 => \u2a05 j, (T j).eigenspace (\u03b1 j)"}, {"line": "rw [OrthogonalFamily.isInternal_iff]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 (\u2a06 \u03b1, \u2a05 j, (T j).eigenspace (\u03b1 j))\u15ee = \u22a5\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 OrthogonalFamily \ud835\udd5c (fun i => \u21a5(\u2a05 j, (T j).eigenspace (i j))) fun i => (\u2a05 j, (T j).eigenspace (i j)).subtype\u2097\u1d62\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 FiniteDimensional \ud835\udd5c E"}, {"line": "\u00b7 rw [iSup_iInf_eq_top_of_commute hT hC, top_orthogonal_eq_bot]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 OrthogonalFamily \ud835\udd5c (fun i => \u21a5(\u2a05 j, (T j).eigenspace (i j))) fun i => (\u2a05 j, (T j).eigenspace (i j)).subtype\u2097\u1d62\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 FiniteDimensional \ud835\udd5c E"}, {"line": "\u00b7 exact orthogonalFamily_iInf_eigenspaces hT", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nn : Type u_3\ninst\u271d\u2074 : RCLike \ud835\udd5c\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\nT : n \u2192 Module.End \ud835\udd5c E\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\ninst\u271d : DecidableEq (n \u2192 \ud835\udd5c)\nhT : \u2200 (i : n), IsSymmetric (T i)\nhC : Pairwise (Function.onFun Commute T)\n\u22a2 FiniteDimensional \ud835\udd5c E"}]}
{"declaration": "theorem ext_inner_map (S T : V \u2192\u2097[\u2102] V) : (\u2200 x : V, \u27eaS x, x\u27eb_\u2102 = \u27eaT x, x\u27eb_\u2102) \u2194 S = T := by\n  rw [\u2190 sub_eq_zero]\n  rw [\u2190 inner_map_self_eq_zero]\n  refine forall_congr' fun x => ?_\n  rw [LinearMap.sub_apply]\n  rw [inner_sub_left]\n  rw [sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/LinearMap.lean", "context": {"open": ["RCLike Real Filter Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)", "scoped InnerProductSpace"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{V : Type*} [SeminormedAddCommGroup V] [InnerProductSpace \u2102 V]", "{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u2102 V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\n\u22a2 (\u2200 (x : V), inner (S x) x = inner (T x) x) \u2194 S = T"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\n\u22a2 (\u2200 (x : V), inner (S x) x = inner (T x) x) \u2194 S - T = 0"}, {"line": "rw [\u2190 inner_map_self_eq_zero]", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\n\u22a2 (\u2200 (x : V), inner (S x) x = inner (T x) x) \u2194 \u2200 (x : V), inner ((S - T) x) x = 0"}, {"line": "refine forall_congr' fun x => ?_", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\nx : V\n\u22a2 inner (S x) x = inner (T x) x \u2194 inner ((S - T) x) x = 0"}, {"line": "rw [LinearMap.sub_apply]", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\nx : V\n\u22a2 inner (S x) x = inner (T x) x \u2194 inner (S x - T x) x = 0"}, {"line": "rw [inner_sub_left]", "tactic_state": "V : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup V\ninst\u271d : InnerProductSpace \u2102 V\nS T : V \u2192\u2097[\u2102] V\nx : V\n\u22a2 inner (S x) x = inner (T x) x \u2194 inner (S x) x - inner (T x) x = 0"}, {"line": "rw [sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orthogonal_disjoint : Disjoint K K\u15ee := by simp [disjoint_iff, K.inf_orthogonal_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orthogonal.lean", "context": {"open": [], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[NormedAddCommGroup F] [InnerProductSpace \ud835\udd5c F]", "(K : Submodule \ud835\udd5c E)", "{K}", "(K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 Disjoint K K\u15ee"}, {"line": "simp [disjoint_iff, K.inf_orthogonal_eq_bot]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 K \u2293 K\u15ee = \u22a5"}]}
{"declaration": "lemma Orthonormal.nnnorm_eq_one {v : \u03b9 \u2192 E} (h : Orthonormal \ud835\udd5c v) (i : \u03b9) :\n    \u2016v i\u2016\u208a = 1 := by\n  suffices (\u2016v i\u2016\u208a : \u211d) = 1 by norm_cast at this\n  simp [h.norm_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orthonormal.lean", "context": {"open": ["RCLike Real Filter", "Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{\u03b9 : Type*} (\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nh : Orthonormal \ud835\udd5c v\ni : \u03b9\n\u22a2 \u2016v i\u2016\u208a = 1"}, {"line": "suffices (\u2016v i\u2016\u208a : \u211d) = 1 by norm_cast at this", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nh : Orthonormal \ud835\udd5c v\ni : \u03b9\n\u22a2 sorry = 1"}, {"line": "simp [h.norm_eq_one]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nh : Orthonormal \ud835\udd5c v\ni : \u03b9\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem orthonormal_subtype_range {v : \u03b9 \u2192 E} (hv : Function.Injective v) :\n    Orthonormal \ud835\udd5c (Subtype.val : Set.range v \u2192 E) \u2194 Orthonormal \ud835\udd5c v := by\n  let f : \u03b9 \u2243 Set.range v := Equiv.ofInjective v hv\n  refine \u27e8fun h => h.comp f f.injective, fun h => ?_\u27e9\n  rw [\u2190 Equiv.self_comp_ofInjective_symm hv]\n  exact h.comp f.symm f.symm.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orthonormal.lean", "context": {"open": ["RCLike Real Filter", "Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{\u03b9 : Type*} (\ud835\udd5c)", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhv : Function.Injective v\n\u22a2 Orthonormal \ud835\udd5c Subtype.val \u2194 Orthonormal \ud835\udd5c v"}, {"line": "let f : \u03b9 \u2243 Set.range v := Equiv.ofInjective v hv", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhv : Function.Injective v\nf : \u03b9 \u2243 \u2191(Set.range v) := Equiv.ofInjective v hv\n\u22a2 Orthonormal \ud835\udd5c Subtype.val \u2194 Orthonormal \ud835\udd5c v"}, {"line": "refine \u27e8fun h => h.comp f f.injective, fun h => ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhv : Function.Injective v\nf : \u03b9 \u2243 \u2191(Set.range v) := Equiv.ofInjective v hv\nh : Orthonormal \ud835\udd5c v\n\u22a2 Orthonormal \ud835\udd5c Subtype.val"}, {"line": "rw [\u2190 Equiv.self_comp_ofInjective_symm hv]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_4\nv : \u03b9 \u2192 E\nhv : Function.Injective v\nf : \u03b9 \u2243 \u2191(Set.range v) := Equiv.ofInjective v hv\nh : Orthonormal \ud835\udd5c v\n\u22a2 Orthonormal \ud835\udd5c (v \u2218 \u21d1(Equiv.ofInjective v hv).symm)"}, {"line": "exact h.comp f.symm f.symm.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIsometry.orthonormal_comp_iff {v : \u03b9 \u2192 E} (f : E \u2192\u2097\u1d62[\ud835\udd5c] E') :\n    Orthonormal \ud835\udd5c (f \u2218 v) \u2194 Orthonormal \ud835\udd5c v := by\n  classical simp_rw [orthonormal_iff_ite, Function.comp_apply, LinearIsometry.inner_map_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Orthonormal.lean", "context": {"open": ["RCLike Real Filter", "Topology ComplexConjugate Finsupp", "LinearMap (BilinForm)", "Module", "scoped InnerProductSpace"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{\u03b9 : Type*} (\ud835\udd5c)", "{\ud835\udd5c}", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "[SeminormedAddCommGroup F] [InnerProductSpace \u211d F]", "{\u03b9 : Type*} {\u03b9' : Type*} {\u03b9'' : Type*}", "{E' : Type*} [SeminormedAddCommGroup E'] [InnerProductSpace \ud835\udd5c E']", "{E'' : Type*} [SeminormedAddCommGroup E''] [InnerProductSpace \ud835\udd5c E'']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : SeminormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\n\u03b9 : Type u_5\nE' : Type u_8\ninst\u271d\u00b9 : SeminormedAddCommGroup E'\ninst\u271d : InnerProductSpace \ud835\udd5c E'\nv : \u03b9 \u2192 E\nf : E \u2192\u2097\u1d62[\ud835\udd5c] E'\n\u22a2 Orthonormal \ud835\udd5c (\u21d1f \u2218 v) \u2194 Orthonormal \ud835\udd5c v"}, {"line": "classical simp_rw [orthonormal_iff_ite, Function.comp_apply, LinearIsometry.inner_map_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_euclideanSpace :\n    Module.finrank \ud835\udd5c (EuclideanSpace \ud835\udd5c \u03b9) = Fintype.card \u03b9 := by\n  simp [EuclideanSpace, PiLp, WithLp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : Fintype \u03b9\n\u22a2 Module.finrank \ud835\udd5c (EuclideanSpace \ud835\udd5c \u03b9) = Fintype.card \u03b9"}, {"line": "simp [EuclideanSpace, PiLp, WithLp]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : Fintype \u03b9\n\u22a2 Module.finrank \ud835\udd5c (\u03b9 \u2192 \ud835\udd5c) = Fintype.card \u03b9"}]}
{"declaration": "theorem finrank_euclideanSpace_fin {n : \u2115} :\n    Module.finrank \ud835\udd5c (EuclideanSpace \ud835\udd5c (Fin n)) = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_3\ninst\u271d : RCLike \ud835\udd5c\nn : \u2115\n\u22a2 Module.finrank \ud835\udd5c (EuclideanSpace \ud835\udd5c (Fin n)) = n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_ofRepr [DecidableEq \u03b9] (e : E \u2243\u2097\u1d62[\ud835\udd5c] EuclideanSpace \ud835\udd5c \u03b9) :\n    \u21d1(OrthonormalBasis.ofRepr e) = fun i => e.symm (EuclideanSpace.single i (1 : \ud835\udd5c)) := by\n  dsimp only [DFunLike.coe]\n  funext\n  congr!\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne : E \u2243\u2097\u1d62[\ud835\udd5c] EuclideanSpace \ud835\udd5c \u03b9\n\u22a2 \u21d1{ repr := e } = fun i => e.symm (EuclideanSpace.single i 1)"}, {"line": "dsimp only [DFunLike.coe]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne : E \u2243\u2097\u1d62[\ud835\udd5c] EuclideanSpace \ud835\udd5c \u03b9\n\u22a2 (fun i => EquivLike.coe e.symm (EuclideanSpace.single i 1)) = fun i =>\n    EquivLike.coe e.symm (EuclideanSpace.single i 1)"}, {"line": "funext", "tactic_state": "case h\n\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne : E \u2243\u2097\u1d62[\ud835\udd5c] EuclideanSpace \ud835\udd5c \u03b9\nx\u271d : \u03b9\n\u22a2 EquivLike.coe e.symm (EuclideanSpace.single x\u271d 1) = EquivLike.coe e.symm (EuclideanSpace.single x\u271d 1)"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.coe_orthonormalBasisOneI :\n    (Complex.orthonormalBasisOneI : Fin 2 \u2192 \u2102) = ![1, I] := by\n  simp [Complex.orthonormalBasisOneI]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u21d1orthonormalBasisOneI = ![1, I]"}, {"line": "simp [Complex.orthonormalBasisOneI]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.map_isometryOfOrthonormal (v : OrthonormalBasis (Fin 2) \u211d F) (f : F \u2243\u2097\u1d62[\u211d] F') :\n    Complex.isometryOfOrthonormal (v.map f) = (Complex.isometryOfOrthonormal v).trans f := by\n  simp only [isometryOfOrthonormal]\n  simp only [OrthonormalBasis.map]\n  simp only [LinearIsometryEquiv.symm_trans]\n  simp only [LinearIsometryEquiv.symm_symm]\n  -- Porting note: `LinearIsometryEquiv.trans_assoc` doesn't trigger in the `simp` above\n  rw [LinearIsometryEquiv.trans_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nF' : Type u_6\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : InnerProductSpace \u211d F'\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F \u2243\u2097\u1d62[\u211d] F'\n\u22a2 isometryOfOrthonormal (v.map f) = (isometryOfOrthonormal v).trans f"}, {"line": "simp only [isometryOfOrthonormal]", "tactic_state": "F : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nF' : Type u_6\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : InnerProductSpace \u211d F'\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F \u2243\u2097\u1d62[\u211d] F'\n\u22a2 orthonormalBasisOneI.repr.trans (v.map f).repr.symm = (orthonormalBasisOneI.repr.trans v.repr.symm).trans f"}, {"line": "simp only [OrthonormalBasis.map]", "tactic_state": "F : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nF' : Type u_6\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : InnerProductSpace \u211d F'\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F \u2243\u2097\u1d62[\u211d] F'\n\u22a2 orthonormalBasisOneI.repr.trans (f.symm.trans v.repr).symm = (orthonormalBasisOneI.repr.trans v.repr.symm).trans f"}, {"line": "simp only [LinearIsometryEquiv.symm_trans]", "tactic_state": "F : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nF' : Type u_6\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : InnerProductSpace \u211d F'\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F \u2243\u2097\u1d62[\u211d] F'\n\u22a2 orthonormalBasisOneI.repr.trans (v.repr.symm.trans f.symm.symm) =\n    (orthonormalBasisOneI.repr.trans v.repr.symm).trans f"}, {"line": "simp only [LinearIsometryEquiv.symm_symm]", "tactic_state": "F : Type u_5\ninst\u271d\u00b3 : NormedAddCommGroup F\ninst\u271d\u00b2 : InnerProductSpace \u211d F\nF' : Type u_6\ninst\u271d\u00b9 : NormedAddCommGroup F'\ninst\u271d : InnerProductSpace \u211d F'\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F \u2243\u2097\u1d62[\u211d] F'\n\u22a2 orthonormalBasisOneI.repr.trans (v.repr.symm.trans f) = (orthonormalBasisOneI.repr.trans v.repr.symm).trans f"}, {"line": "rw [LinearIsometryEquiv.trans_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.isometryOfOrthonormal_symm_apply (v : OrthonormalBasis (Fin 2) \u211d F) (f : F) :\n    (Complex.isometryOfOrthonormal v).symm f =\n      (v.toBasis.coord 0 f : \u2102) + (v.toBasis.coord 1 f : \u2102) * I := by\n  simp [Complex.isometryOfOrthonormal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nv : OrthonormalBasis (Fin 2) \u211d F\nf : F\n\u22a2 (isometryOfOrthonormal v).symm f = \u2191((v.toBasis.coord 0) f) + \u2191((v.toBasis.coord 1) f) * I"}, {"line": "simp [Complex.isometryOfOrthonormal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.isometryOfOrthonormal_apply (v : OrthonormalBasis (Fin 2) \u211d F) (z : \u2102) :\n    Complex.isometryOfOrthonormal v z = z.re \u2022 v 0 + z.im \u2022 v 1 := by\n  simp [Complex.isometryOfOrthonormal, \u2190 v.sum_repr_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nv : OrthonormalBasis (Fin 2) \u211d F\nz : \u2102\n\u22a2 (isometryOfOrthonormal v) z = z.re \u2022 v 0 + z.im \u2022 v 1"}, {"line": "simp [Complex.isometryOfOrthonormal, \u2190 v.sum_repr_symm]", "tactic_state": "F : Type u_5\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : InnerProductSpace \u211d F\nv : OrthonormalBasis (Fin 2) \u211d F\nz : \u2102\n\u22a2 v.repr.symm ![z.re, z.im] = z.re \u2022 v 0 + z.im \u2022 v 1"}]}
{"declaration": "theorem OrthonormalBasis.toMatrix_orthonormalBasis_mem_unitary :\n    a.toBasis.toMatrix b \u2208 Matrix.unitaryGroup \u03b9 \ud835\udd5c := by\n  rw [Matrix.mem_unitaryGroup_iff']\n  exact a.toMatrix_orthonormalBasis_conjTranspose_mul_self b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule", "Module", "scoped Matrix"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)", "[DecidableEq \u03b9]", "(a b : OrthonormalBasis \u03b9 \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\na b : OrthonormalBasis \u03b9 \ud835\udd5c E\n\u22a2 a.toBasis.toMatrix \u21d1b \u2208 Matrix.unitaryGroup \u03b9 \ud835\udd5c"}, {"line": "rw [Matrix.mem_unitaryGroup_iff']", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\na b : OrthonormalBasis \u03b9 \ud835\udd5c E\n\u22a2 star (a.toBasis.toMatrix \u21d1b) * a.toBasis.toMatrix \u21d1b = 1"}, {"line": "exact a.toMatrix_orthonormalBasis_conjTranspose_mul_self b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem OrthonormalBasis.det_to_matrix_orthonormalBasis_real :\n    a.toBasis.det b = 1 \u2228 a.toBasis.det b = -1 := by\n  rw [\u2190 sq_eq_one_iff]\n  simpa [unitary, sq] using Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule", "Module", "scoped Matrix"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)", "[DecidableEq \u03b9]", "(a b : OrthonormalBasis \u03b9 \ud835\udd5c E)", "(a b : OrthonormalBasis \u03b9 \u211d F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nF : Type u_5\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : InnerProductSpace \u211d F\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\na b : OrthonormalBasis \u03b9 \u211d F\n\u22a2 a.toBasis.det \u21d1b = 1 \u2228 a.toBasis.det \u21d1b = -1"}, {"line": "rw [\u2190 sq_eq_one_iff]", "tactic_state": "\u03b9 : Type u_1\nF : Type u_5\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : InnerProductSpace \u211d F\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\na b : OrthonormalBasis \u03b9 \u211d F\n\u22a2 a.toBasis.det \u21d1b ^ 2 = 1"}, {"line": "simpa [unitary, sq] using Matrix.det_of_mem_unitary (a.toMatrix_orthonormalBasis_mem_unitary b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectSum.IsInternal.collectedOrthonormalBasis_mem [DecidableEq \u03b9]\n    (h : DirectSum.IsInternal A) {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Fintype (\u03b1 i)]\n    (hV : OrthogonalFamily \ud835\udd5c (fun i => A i) fun i => (A i).subtype\u2097\u1d62)\n    (v : \u2200 i, OrthonormalBasis (\u03b1 i) \ud835\udd5c (A i)) (a : \u03a3 i, \u03b1 i) :\n    h.collectedOrthonormalBasis hV v a \u2208 A a.1 := by\n  simp [DirectSum.IsInternal.collectedOrthonormalBasis]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule", "Module", "scoped Matrix"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)", "[DecidableEq \u03b9]", "(a b : OrthonormalBasis \u03b9 \ud835\udd5c E)", "(a b : OrthonormalBasis \u03b9 \u211d F)", "{v : Set E}", "{A : \u03b9 \u2192 Submodule \ud835\udd5c E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2079 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : DecidableEq \u03b9\nA : \u03b9 \u2192 Submodule \ud835\udd5c E\ninst\u271d\u00b9 : DecidableEq \u03b9\nh : IsInternal A\n\u03b1 : \u03b9 \u2192 Type u_7\ninst\u271d : (i : \u03b9) \u2192 Fintype (\u03b1 i)\nhV : OrthogonalFamily \ud835\udd5c (fun i => \u21a5(A i)) fun i => (A i).subtype\u2097\u1d62\nv : (i : \u03b9) \u2192 OrthonormalBasis (\u03b1 i) \ud835\udd5c \u21a5(A i)\na : (i : \u03b9) \u00d7 \u03b1 i\n\u22a2 (collectedOrthonormalBasis hV h v) a \u2208 A a.fst"}, {"line": "simp [DirectSum.IsInternal.collectedOrthonormalBasis]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orthonormalBasis_one_dim (b : OrthonormalBasis \u03b9 \u211d \u211d) :\n    (\u21d1b = fun _ => (1 : \u211d)) \u2228 \u21d1b = fun _ => (-1 : \u211d) := by\n  have : Unique \u03b9 := b.toBasis.unique\n  have : b default = 1 \u2228 b default = -1 := by\n    have : \u2016b default\u2016 = 1 := b.orthonormal.1 _\n    rwa [Real.norm_eq_abs, abs_eq (zero_le_one' \u211d)] at this\n  rw [eq_const_of_unique b]\n  refine this.imp ?_ ?_ <;> (intro; ext; simp [*])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule", "Module", "scoped Matrix"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)", "[DecidableEq \u03b9]", "(a b : OrthonormalBasis \u03b9 \ud835\udd5c E)", "(a b : OrthonormalBasis \u03b9 \u211d F)", "{v : Set E}", "{A : \u03b9 \u2192 Submodule \ud835\udd5c E}", "[FiniteDimensional \ud835\udd5c E]", "(\ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : OrthonormalBasis \u03b9 \u211d \u211d\n\u22a2 (\u21d1b = fun x => 1) \u2228 \u21d1b = fun x => -1"}, {"line": "have : Unique \u03b9 := b.toBasis.unique", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : OrthonormalBasis \u03b9 \u211d \u211d\nthis : Unique \u03b9\n\u22a2 (\u21d1b = fun x => 1) \u2228 \u21d1b = fun x => -1"}, {"line": "have : b default = 1 \u2228 b default = -1 := by\n    have : \u2016b default\u2016 = 1 := b.orthonormal.1 _\n    rwa [Real.norm_eq_abs, abs_eq (zero_le_one' \u211d)] at this", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : OrthonormalBasis \u03b9 \u211d \u211d\nthis\u271d : Unique \u03b9\nthis : b default = 1 \u2228 b default = -1\n\u22a2 (\u21d1b = fun x => 1) \u2228 \u21d1b = fun x => -1"}, {"line": "rw [eq_const_of_unique b]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : OrthonormalBasis \u03b9 \u211d \u211d\nthis\u271d : Unique \u03b9\nthis : b default = 1 \u2228 b default = -1\n\u22a2 (const \u03b9 (b default) = fun x => 1) \u2228 const \u03b9 (b default) = fun x => -1"}, {"line": "refine this.imp ?_ ?_ <;> (intro; ext; simp [*])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectSum.IsInternal.subordinateOrthonormalBasis_subordinate (a : Fin n)\n    (hV' : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62) :\n    hV.subordinateOrthonormalBasis hn hV' a \u2208 V (hV.subordinateOrthonormalBasisIndex hn a hV') := by\n  simpa only [DirectSum.IsInternal.subordinateOrthonormalBasis,OrthonormalBasis.coe_reindex,DirectSum.IsInternal.subordinateOrthonormalBasisIndex] using\n    hV.collectedOrthonormalBasis_mem hV' (fun i => stdOrthonormalBasis \ud835\udd5c (V i))\n      ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/PiL2.lean", "context": {"open": ["Real Set Filter RCLike Submodule Function Uniformity Topology NNReal ENNReal", "Lean Meta Elab Term Macro TSyntax PrettyPrinter.Delaborator SubExpr", "Mathlib.Tactic (subscriptTerm)", "scoped InnerProductSpace in", "Submodule", "Module", "scoped Matrix", "DirectSum"], "variables": ["{\u03b9 \u03b9' \ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [InnerProductSpace \u211d F]", "{F' : Type*} [NormedAddCommGroup F'] [InnerProductSpace \u211d F']", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c)", "{\u03b9 \ud835\udd5c}", "[DecidableEq \u03b9]", "[Fintype \u03b9]", "(\u03b9 \ud835\udd5c E)", "[Fintype \u03b9]", "{\u03b9 \ud835\udd5c E}", "{v : \u03b9 \u2192 E}", "[Fintype \u03b9']", "(\ud835\udd5c \u03b9)", "[DecidableEq \u03b9]", "(a b : OrthonormalBasis \u03b9 \ud835\udd5c E)", "(a b : OrthonormalBasis \u03b9 \u211d F)", "{v : Set E}", "{A : \u03b9 \u2192 Submodule \ud835\udd5c E}", "[FiniteDimensional \ud835\udd5c E]", "(\ud835\udd5c E)", "{\ud835\udd5c E}", "{n : \u2115} (hn : finrank \ud835\udd5c E = n) [DecidableEq \u03b9] {V : \u03b9 \u2192 Submodule \ud835\udd5c E} (hV : IsInternal V)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u2079 : RCLike \ud835\udd5c\nE : Type u_4\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : DecidableEq \u03b9\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : FiniteDimensional \ud835\udd5c E\nn : \u2115\nhn : finrank \ud835\udd5c E = n\ninst\u271d : DecidableEq \u03b9\nV : \u03b9 \u2192 Submodule \ud835\udd5c E\nhV : IsInternal V\na : Fin n\nhV' : OrthogonalFamily \ud835\udd5c (fun i => \u21a5(V i)) fun i => (V i).subtype\u2097\u1d62\n\u22a2 (subordinateOrthonormalBasis hn hV hV') a \u2208 V (subordinateOrthonormalBasisIndex hn hV a hV')"}, {"line": "simpa only [DirectSum.IsInternal.subordinateOrthonormalBasis,OrthonormalBasis.coe_reindex,DirectSum.IsInternal.subordinateOrthonormalBasisIndex] using\n    hV.collectedOrthonormalBasis_mem hV' (fun i => stdOrthonormalBasis \ud835\udd5c (V i))\n      ((hV.sigmaOrthonormalBasisIndexEquiv hn hV').symm a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPositive.conj_adjoint {T : E \u2192L[\ud835\udd5c] E} (hT : T.IsPositive) (S : E \u2192L[\ud835\udd5c] F) :\n    (S \u2218L T \u2218L S\u2020).IsPositive := by\n  refine \u27e8hT.isSelfAdjoint.conj_adjoint S, fun x => ?_\u27e9\n  rw [reApplyInnerSelf]\n  rw [comp_apply]\n  rw [\u2190 adjoint_inner_right]\n  exact hT.inner_nonneg_left _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Positive.lean", "context": {"open": ["InnerProductSpace RCLike ContinuousLinearMap", "scoped InnerProduct ComplexConjugate"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c F]", "[CompleteSpace E] [CompleteSpace F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\n\u22a2 (S.comp (T.comp (adjoint S))).IsPositive"}, {"line": "refine \u27e8hT.isSelfAdjoint.conj_adjoint S, fun x => ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 0 \u2264 (S.comp (T.comp (adjoint S))).reApplyInnerSelf x"}, {"line": "rw [reApplyInnerSelf]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 0 \u2264 re (inner ((S.comp (T.comp (adjoint S))) x) x)"}, {"line": "rw [comp_apply]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 0 \u2264 re (inner (S ((T.comp (adjoint S)) x)) x)"}, {"line": "rw [\u2190 adjoint_inner_right]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 0 \u2264 re (inner ((T.comp (adjoint S)) x) ((adjoint S) x))\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 CompleteSpace E\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2076 : RCLike \ud835\udd5c\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedAddCommGroup F\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c F\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : CompleteSpace F\nT : E \u2192L[\ud835\udd5c] E\nhT : T.IsPositive\nS : E \u2192L[\ud835\udd5c] F\nx : F\n\u22a2 CompleteSpace F"}, {"line": "exact hT.inner_nonneg_left _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPositive_iff_complex (T : E' \u2192L[\u2102] E') :\n    IsPositive T \u2194 \u2200 x, (re \u27eaT x, x\u27eb_\u2102 : \u2102) = \u27eaT x, x\u27eb_\u2102 \u2227 0 \u2264 re \u27eaT x, x\u27eb_\u2102 := by\n  simp_rw [IsPositive, forall_and, isSelfAdjoint_iff_isSymmetric,\n    LinearMap.isSymmetric_iff_inner_map_self_real, conj_eq_iff_re]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Positive.lean", "context": {"open": ["InnerProductSpace RCLike ContinuousLinearMap", "scoped InnerProduct ComplexConjugate", "scoped NNReal"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c F]", "[CompleteSpace E] [CompleteSpace F]", "{E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace \u2102 E'] [CompleteSpace E']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E' : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E'\ninst\u271d\u00b9 : InnerProductSpace \u2102 E'\ninst\u271d : CompleteSpace E'\nT : E' \u2192L[\u2102] E'\n\u22a2 T.IsPositive \u2194 \u2200 (x : E'), \u2191(re (inner (T x) x)) = inner (T x) x \u2227 0 \u2264 re (inner (T x) x)"}, {"line": "simp_rw [IsPositive, forall_and, isSelfAdjoint_iff_isSymmetric,\n    LinearMap.isSymmetric_iff_inner_map_self_real, conj_eq_iff_re]", "tactic_state": "E' : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E'\ninst\u271d\u00b9 : InnerProductSpace \u2102 E'\ninst\u271d : CompleteSpace E'\nT : E' \u2192L[\u2102] E'\n\u22a2 ((\u2200 (v : E'), \u2191(re (inner (\u2191T v) v)) = inner (\u2191T v) v) \u2227 \u2200 (x : E'), 0 \u2264 T.reApplyInnerSelf x) \u2194\n    (\u2200 (x : E'), \u2191(re (inner (T x) x)) = inner (T x) x) \u2227 \u2200 (x : E'), 0 \u2264 re (inner (T x) x)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nonneg_iff_isPositive (f : E \u2192L[\ud835\udd5c] E) : 0 \u2264 f \u2194 f.IsPositive := by\n  simpa using le_def 0 f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Positive.lean", "context": {"open": ["InnerProductSpace RCLike ContinuousLinearMap", "scoped InnerProduct ComplexConjugate", "scoped NNReal"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c F]", "[CompleteSpace E] [CompleteSpace F]", "{E' : Type*} [NormedAddCommGroup E'] [InnerProductSpace \u2102 E'] [CompleteSpace E']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : CompleteSpace E\nf : E \u2192L[\ud835\udd5c] E\n\u22a2 0 \u2264 f \u2194 f.IsPositive"}, {"line": "simpa using le_def 0 f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_norm_eq_iInf_of_complete_subspace (h : IsComplete (\u2191K : Set E)) :\n    \u2200 u : E, \u2203 v \u2208 K, \u2016u - v\u2016 = \u2a05 w : (K : Set E), \u2016u - w\u2016 := by\n  letI : InnerProductSpace \u211d E := InnerProductSpace.rclikeToReal \ud835\udd5c E\n  letI : Module \u211d E := RestrictScalars.module \u211d \ud835\udd5c E\n  let K' : Submodule \u211d E := Submodule.restrictScalars \u211d K\n  exact exists_norm_eq_iInf_of_complete_convex \u27e80, K'.zero_mem\u27e9 h K'.convex\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\nh : IsComplete \u2191K\n\u22a2 \u2200 (u : E), \u2203 v \u2208 K, \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016"}, {"line": "letI : InnerProductSpace \u211d E := InnerProductSpace.rclikeToReal \ud835\udd5c E", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\nh : IsComplete \u2191K\nthis : sorry := sorry\n\u22a2 \u2200 (u : E), \u2203 v \u2208 K, \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016"}, {"line": "letI : Module \u211d E := RestrictScalars.module \u211d \ud835\udd5c E", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\nh : IsComplete \u2191K\nthis\u271d : sorry := sorry\nthis : sorry := sorry\n\u22a2 \u2200 (u : E), \u2203 v \u2208 K, \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016"}, {"line": "let K' : Submodule \u211d E := Submodule.restrictScalars \u211d K", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\nh : IsComplete \u2191K\nthis\u271d : sorry := sorry\nthis : sorry := sorry\nK' : sorry := sorry\n\u22a2 \u2200 (u : E), \u2203 v \u2208 K, \u2016u - v\u2016 = \u2a05 w, \u2016u - \u2191w\u2016"}, {"line": "exact exists_norm_eq_iInf_of_complete_convex \u27e80, K'.zero_mem\u27e9 h K'.convex", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_orthogonalProjection_mem_orthogonal (v : E) : v - K.orthogonalProjection v \u2208 K\u15ee := by\n  intro w hw\n  rw [inner_eq_zero_symm]\n  exact orthogonalProjection_inner_eq_zero _ _ hw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nv : E\n\u22a2 v - \u2191(K.orthogonalProjection v) \u2208 K\u15ee"}, {"line": "intro w hw", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nv w : E\nhw : w \u2208 K\n\u22a2 inner w (v - \u2191(K.orthogonalProjection v)) = 0"}, {"line": "rw [inner_eq_zero_symm]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nv w : E\nhw : w \u2208 K\n\u22a2 inner (v - \u2191(K.orthogonalProjection v)) w = 0"}, {"line": "exact orthogonalProjection_inner_eq_zero _ _ hw", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orthogonalProjection_mem_subspace_eq_self (v : K) : K.orthogonalProjection v = v := by\n  ext\n  apply eq_orthogonalProjection_of_mem_of_inner_eq_zero <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nv : \u21a5K\n\u22a2 K.orthogonalProjection \u2191v = v"}, {"line": "ext", "tactic_state": "case a\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nv : \u21a5K\n\u22a2 \u2191(K.orthogonalProjection \u2191v) = \u2191v"}, {"line": "apply eq_orthogonalProjection_of_mem_of_inner_eq_zero <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orthogonalProjection_map_apply {E E' : Type*} [NormedAddCommGroup E]\n    [NormedAddCommGroup E'] [InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c E'] (f : E \u2243\u2097\u1d62[\ud835\udd5c] E')\n    (p : Submodule \ud835\udd5c E) [p.HasOrthogonalProjection] (x : E') :\n    ((p.map (f.toLinearEquiv : E \u2192\u2097[\ud835\udd5c] E')).orthogonalProjection x : E') =\n      f (p.orthogonalProjection (f.symm x)) := by\n  simpa only [f.coe_toLinearIsometry,f.apply_symm_apply] using\n    (f.toLinearIsometry.map_orthogonalProjection' p (f.symm x)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : RCLike \ud835\udd5c\nE : Type u_4\nE' : Type u_5\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup E'\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E'\nf : E \u2243\u2097\u1d62[\ud835\udd5c] E'\np : Submodule \ud835\udd5c E\ninst\u271d : p.HasOrthogonalProjection\nx : E'\n\u22a2 \u2191((Submodule.map (\u2191f.toLinearEquiv) p).orthogonalProjection x) = f \u2191(p.orthogonalProjection (f.symm x))"}, {"line": "simpa only [f.coe_toLinearIsometry,f.apply_symm_apply] using\n    (f.toLinearIsometry.map_orthogonalProjection' p (f.symm x)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reflection_map_apply {E E' : Type*} [NormedAddCommGroup E] [NormedAddCommGroup E']\n    [InnerProductSpace \ud835\udd5c E] [InnerProductSpace \ud835\udd5c E'] (f : E \u2243\u2097\u1d62[\ud835\udd5c] E') (K : Submodule \ud835\udd5c E)\n    [K.HasOrthogonalProjection] (x : E') :\n    reflection (K.map (f.toLinearEquiv : E \u2192\u2097[\ud835\udd5c] E')) x = f (K.reflection (f.symm x)) := by\n  simp [two_smul, reflection_apply, orthogonalProjection_map_apply f K x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : RCLike \ud835\udd5c\nx\u271d : Sort u_6\nreflection : x\u271d\nE : Type u_4\nE' : Type u_5\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup E'\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E'\nf : E \u2243\u2097\u1d62[\ud835\udd5c] E'\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nx : E'\n\u22a2 sorry = f (K.reflection (f.symm x))"}, {"line": "simp [two_smul, reflection_apply, orthogonalProjection_map_apply f K x]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2075 : RCLike \ud835\udd5c\nx\u271d : Sort u_6\nreflection : x\u271d\nE : Type u_4\nE' : Type u_5\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedAddCommGroup E'\ninst\u271d\u00b2 : InnerProductSpace \ud835\udd5c E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E'\nf : E \u2243\u2097\u1d62[\ud835\udd5c] E'\nK : Submodule \ud835\udd5c E\ninst\u271d : K.HasOrthogonalProjection\nx : E'\n\u22a2 sorry () = f (K.reflection (f.symm x))"}]}
{"declaration": "theorem sup_orthogonal_of_completeSpace [K.HasOrthogonalProjection] : K \u2294 K\u15ee = \u22a4 := by\n  convert Submodule.sup_orthogonal_inf_of_completeSpace (le_top : K \u2264 \u22a4) using 2\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "{K} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\n\u22a2 K \u2294 K\u15ee = \u22a4"}, {"line": "convert Submodule.sup_orthogonal_inf_of_completeSpace (le_top : K \u2264 \u22a4) using 2", "tactic_state": "case h.e'_2.h.e'_4\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\n\u22a2 K\u15ee = K\u15ee \u2293 \u22a4\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\n\u22a2 K.HasOrthogonalProjection"}, {"line": "simp", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\n\u22a2 K.HasOrthogonalProjection"}]}
{"declaration": "theorem orthogonalProjection_mem_subspace_orthogonalComplement_eq_zero [K.HasOrthogonalProjection]\n    {v : E} (hv : v \u2208 K\u15ee) : K.orthogonalProjection v = 0 := by\n  ext\n  convert eq_orthogonalProjection_of_mem_orthogonal (K := K) _ _ <;> simp [hv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "{K} in", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\nv : E\nhv : v \u2208 K\u15ee\n\u22a2 K.orthogonalProjection v = 0"}, {"line": "ext", "tactic_state": "case a\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u2075 : RCLike \ud835\udd5c\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : InnerProductSpace \ud835\udd5c E\nK : Submodule \ud835\udd5c E\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : K.HasOrthogonalProjection\nv : E\nhv : v \u2208 K\u15ee\n\u22a2 \u2191(K.orthogonalProjection v) = \u21910"}, {"line": "convert eq_orthogonalProjection_of_mem_orthogonal (K := K) _ _ <;> simp [hv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_add_finrank_orthogonal [FiniteDimensional \ud835\udd5c E] (K : Submodule \ud835\udd5c E) :\n    finrank \ud835\udd5c K + finrank \ud835\udd5c K\u15ee = finrank \ud835\udd5c E := by\n  convert Submodule.finrank_add_inf_finrank_orthogonal (le_top : K \u2264 \u22a4) using 1\n  \u00b7 rw [inf_top_eq]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp", "Submodule", "Module", "Module"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "{K} in", "{K}", "{K} {x y : E}", "{K}", "(K)", "[FiniteDimensional \ud835\udd5c K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 finrank \ud835\udd5c \u21a5K + finrank \ud835\udd5c \u21a5K\u15ee = finrank \ud835\udd5c E"}, {"line": "convert Submodule.finrank_add_inf_finrank_orthogonal (le_top : K \u2264 \u22a4) using 1", "tactic_state": "case h.e'_2\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 finrank \ud835\udd5c \u21a5K + finrank \ud835\udd5c \u21a5K\u15ee = finrank \ud835\udd5c \u21a5K + finrank \ud835\udd5c \u21a5(K\u15ee \u2293 \u22a4)\n---\ncase h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 finrank \ud835\udd5c E = finrank \ud835\udd5c \u21a5\u22a4\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 FiniteDimensional \ud835\udd5c \u21a5\u22a4"}, {"line": "\u00b7 rw [inf_top_eq]", "tactic_state": "case h.e'_3\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 finrank \ud835\udd5c E = finrank \ud835\udd5c \u21a5\u22a4\n---\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 FiniteDimensional \ud835\udd5c \u21a5\u22a4"}, {"line": "\u00b7 simp", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \ud835\udd5c E\ninst\u271d : FiniteDimensional \ud835\udd5c E\nK : Submodule \ud835\udd5c E\n\u22a2 FiniteDimensional \ud835\udd5c \u21a5\u22a4"}]}
{"declaration": "theorem finrank_orthogonal_span_singleton {n : \u2115} [_i : Fact (finrank \ud835\udd5c E = n + 1)] {v : E}\n    (hv : v \u2260 0) : finrank \ud835\udd5c (\ud835\udd5c \u2219 v)\u15ee = n := by\n  haveI : FiniteDimensional \ud835\udd5c E := .of_fact_finrank_eq_succ n\n  exact finrank_add_finrank_orthogonal' <| by\n    simp [finrank_span_singleton hv, _i.elim, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp", "Submodule", "Module", "Module"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "{K} in", "{K}", "{K} {x y : E}", "{K}", "(K)", "[FiniteDimensional \ud835\udd5c K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nn : \u2115\n_i : Fact (finrank \ud835\udd5c E = n + 1)\nv : E\nhv : v \u2260 0\n\u22a2 finrank \ud835\udd5c \u21a5(span \ud835\udd5c {v})\u15ee = n"}, {"line": "haveI : FiniteDimensional \ud835\udd5c E := .of_fact_finrank_eq_succ n", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nn : \u2115\n_i : Fact (finrank \ud835\udd5c E = n + 1)\nv : E\nhv : v \u2260 0\nthis : sorry\n\u22a2 finrank \ud835\udd5c \u21a5(span \ud835\udd5c {v})\u15ee = n"}, {"line": "exact finrank_add_finrank_orthogonal' <| by\n    simp [finrank_span_singleton hv, _i.elim, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LinearIsometryEquiv.reflections_generate_dim_aux [FiniteDimensional \u211d F] {n : \u2115}\n    (\u03c6 : F \u2243\u2097\u1d62[\u211d] F) (hn : finrank \u211d (ker (ContinuousLinearMap.id \u211d F - \u03c6))\u15ee \u2264 n) :\n    \u2203 l : List F, l.length \u2264 n \u2227 \u03c6 = (l.map fun v => (\u211d \u2219 v)\u15ee.reflection).prod := by\n  -- We prove this by strong induction on `n`, the dimension of the orthogonal complement of the\n  -- fixed subspace of the endomorphism `\u03c6`\n  induction' n with n IH generalizing \u03c6\n  \u00b7 -- Base case: `n = 0`, the fixed subspace is the whole space, so `\u03c6 = id`\n    refine \u27e8[], rfl.le, show \u03c6 = 1 from ?_\u27e9\n    have : ker (ContinuousLinearMap.id \u211d F - \u03c6) = \u22a4 := by\n      rwa [le_zero_iff, finrank_eq_zero, orthogonal_eq_bot_iff] at hn\n    symm\n    ext x\n    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x\n    simpa only [sub_eq_zero,ContinuousLinearMap.coe_sub,LinearMap.sub_apply,LinearMap.zero_apply] using this\n  \u00b7 -- Inductive step.  Let `W` be the fixed subspace of `\u03c6`.  We suppose its complement to have\n    -- dimension at most n + 1.\n    let W := ker (ContinuousLinearMap.id \u211d F - \u03c6)\n    have hW : \u2200 w \u2208 W, \u03c6 w = w := fun w hw => (sub_eq_zero.mp hw).symm\n    by_cases hn' : finrank \u211d W\u15ee \u2264 n\n    \u00b7 obtain \u27e8V, hV\u2081, hV\u2082\u27e9 := IH \u03c6 hn'\n      exact \u27e8V, hV\u2081.trans n.le_succ, hV\u2082\u27e9\n    -- Take a nonzero element `v` of the orthogonal complement of `W`.\n    haveI : Nontrivial W\u15ee := nontrivial_of_finrank_pos (by omega : 0 < finrank \u211d W\u15ee)\n    obtain \u27e8v, hv\u27e9 := exists_ne (0 : W\u15ee)\n    have h\u03c6v : \u03c6 v \u2208 W\u15ee := by\n      intro w hw\n      rw [\u2190 hW w hw]\n      rw [LinearIsometryEquiv.inner_map_map]\n      exact v.prop w hw\n    have hv' : (v : F) \u2209 W := by\n      intro h\n      exact hv ((mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)\n    -- Let `\u03c1` be the reflection in `v - \u03c6 v`; this is designed to swap `v` and `\u03c6 v`\n    let x : F := v - \u03c6 v\n    let \u03c1 := (\u211d \u2219 x)\u15ee.reflection\n    -- Notation: Let `V` be the fixed subspace of `\u03c6.trans \u03c1`\n    let V := ker (ContinuousLinearMap.id \u211d F - \u03c6.trans \u03c1)\n    have hV : \u2200 w, \u03c1 (\u03c6 w) = w \u2192 w \u2208 V := by\n      intro w hw\n      change w - \u03c1 (\u03c6 w) = 0\n      rw [sub_eq_zero]\n      rw [hw]\n    -- Everything fixed by `\u03c6` is fixed by `\u03c6.trans \u03c1`\n    have H\u2082V : W \u2264 V := by\n      intro w hw\n      apply hV\n      rw [hW w hw]\n      refine reflection_mem_subspace_eq_self ?_\n      rw [mem_orthogonal_singleton_iff_inner_left]\n      exact Submodule.sub_mem _ v.prop h\u03c6v _ hw\n    -- `v` is also fixed by `\u03c6.trans \u03c1`\n    have H\u2081V : (v : F) \u2208 V := by\n      apply hV\n      have : \u03c1 v = \u03c6 v := reflection_sub (\u03c6.norm_map v).symm\n      rw [\u2190 this]\n      exact reflection_reflection _ _\n    -- By dimension-counting, the complement of the fixed subspace of `\u03c6.trans \u03c1` has dimension at\n    -- most `n`\n    have : finrank \u211d V\u15ee \u2264 n := by\n      change finrank \u211d W\u15ee \u2264 n + 1 at hn\n      have : finrank \u211d W + 1 \u2264 finrank \u211d V :=\n        finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 \u27e8H\u2082V, v, H\u2081V, hv'\u27e9)\n      have : finrank \u211d V + finrank \u211d V\u15ee = finrank \u211d F := V.finrank_add_finrank_orthogonal\n      have : finrank \u211d W + finrank \u211d W\u15ee = finrank \u211d F := W.finrank_add_finrank_orthogonal\n      omega\n    -- So apply the inductive hypothesis to `\u03c6.trans \u03c1`\n    obtain \u27e8l, hl, h\u03c6l\u27e9 := IH (\u03c1 * \u03c6) this\n    -- Prepend `\u03c1` to the factorization into reflections obtained for `\u03c6.trans \u03c1`; this gives a\n    -- factorization into reflections for `\u03c6`.\n    refine \u27e8x::l, Nat.succ_le_succ hl, ?_\u27e9\n    rw [List.map_cons]\n    rw [List.prod_cons]\n    have := congr_arg (\u03c1 * \u00b7) h\u03c6l\n    dsimp only at this\n    rwa [\u2190 mul_assoc, reflection_mul_reflection, one_mul] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Projection.lean", "context": {"open": ["InnerProductSpace", "RCLike Real Filter", "LinearMap (ker range)", "Topology Finsupp", "Submodule", "Module", "Module", "Module Submodule"], "variables": ["{\ud835\udd5c E F : Type*} [RCLike \ud835\udd5c]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "[InnerProductSpace \ud835\udd5c E] [InnerProductSpace \u211d F]", "(K : Submodule \ud835\udd5c E)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "(K)", "(\ud835\udd5c)", "[K.HasOrthogonalProjection]", "{K}", "(K)", "{K}", "{K} in", "{K}", "{K} {x y : E}", "{K}", "(K)", "[FiniteDimensional \ud835\udd5c K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\nn : \u2115\n\u03c6 : F \u2243\u2097\u1d62[\u211d] F\nhn :\n  finrank \u211d\n      \u21a5(LinearMap.ker\n            (ContinuousLinearMap.id \u211d F -\n              \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n    n\n\u22a2 \u2203 l, l.length \u2264 n \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod"}, {"line": "induction' n with n IH generalizing \u03c6", "tactic_state": "case zero\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\n\u03c6 : F \u2243\u2097\u1d62[\u211d] F\nhn :\n  finrank \u211d\n      \u21a5(LinearMap.ker\n            (ContinuousLinearMap.id \u211d F -\n              \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n    0\n\u22a2 \u2203 l, l.length \u2264 0 \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod\n---\ncase succ\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\nn : \u2115\nIH :\n  \u2200 (\u03c6 : F \u2243\u2097\u1d62[\u211d] F),\n    finrank \u211d\n          \u21a5(LinearMap.ker\n                (ContinuousLinearMap.id \u211d F -\n                  \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n        n \u2192\n      \u2203 l, l.length \u2264 n \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod\n\u03c6 : F \u2243\u2097\u1d62[\u211d] F\nhn :\n  finrank \u211d\n      \u21a5(LinearMap.ker\n            (ContinuousLinearMap.id \u211d F -\n              \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n    n + 1\n\u22a2 \u2203 l, l.length \u2264 n + 1 \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod"}, {"line": "\u00b7 -- Base case: `n = 0`, the fixed subspace is the whole space, so `\u03c6 = id`\n    refine \u27e8[], rfl.le, show \u03c6 = 1 from ?_\u27e9\n    have : ker (ContinuousLinearMap.id \u211d F - \u03c6) = \u22a4 := by\n      rwa [le_zero_iff, finrank_eq_zero, orthogonal_eq_bot_iff] at hn\n    symm\n    ext x\n    have := LinearMap.congr_fun (LinearMap.ker_eq_top.mp this) x\n    simpa only [sub_eq_zero,ContinuousLinearMap.coe_sub,LinearMap.sub_apply,LinearMap.zero_apply] using this", "tactic_state": "case succ\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : InnerProductSpace \u211d F\ninst\u271d : FiniteDimensional \u211d F\nn : \u2115\nIH :\n  \u2200 (\u03c6 : F \u2243\u2097\u1d62[\u211d] F),\n    finrank \u211d\n          \u21a5(LinearMap.ker\n                (ContinuousLinearMap.id \u211d F -\n                  \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n        n \u2192\n      \u2203 l, l.length \u2264 n \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod\n\u03c6 : F \u2243\u2097\u1d62[\u211d] F\nhn :\n  finrank \u211d\n      \u21a5(LinearMap.ker\n            (ContinuousLinearMap.id \u211d F -\n              \u2191{ toLinearEquiv := \u03c6.toLinearEquiv, continuous_toFun := \u22ef, continuous_invFun := \u22ef }))\u15ee \u2264\n    n + 1\n\u22a2 \u2203 l, l.length \u2264 n + 1 \u2227 \u03c6 = (List.map (fun v => (span \u211d {v})\u15ee.reflection) l).prod"}, {"line": "\u00b7 -- Inductive step.  Let `W` be the fixed subspace of `\u03c6`.  We suppose its complement to have\n    let W := ker (ContinuousLinearMap.id \u211d F - \u03c6)\n    have hW : \u2200 w \u2208 W, \u03c6 w = w := fun w hw => (sub_eq_zero.mp hw).symm\n    by_cases hn' : finrank \u211d W\u15ee \u2264 n\n    \u00b7 obtain \u27e8V, hV\u2081, hV\u2082\u27e9 := IH \u03c6 hn'\n      exact \u27e8V, hV\u2081.trans n.le_succ, hV\u2082\u27e9\n    haveI : Nontrivial W\u15ee := nontrivial_of_finrank_pos (by omega : 0 < finrank \u211d W\u15ee)\n    obtain \u27e8v, hv\u27e9 := exists_ne (0 : W\u15ee)\n    have h\u03c6v : \u03c6 v \u2208 W\u15ee := by\n      intro w hw\n      rw [\u2190 hW w hw]\n      rw [LinearIsometryEquiv.inner_map_map]\n      exact v.prop w hw\n    have hv' : (v : F) \u2209 W := by\n      intro h\n      exact hv ((mem_left_iff_eq_zero_of_disjoint W.orthogonal_disjoint).mp h)\n    let x : F := v - \u03c6 v\n    let \u03c1 := (\u211d \u2219 x)\u15ee.reflection\n    let V := ker (ContinuousLinearMap.id \u211d F - \u03c6.trans \u03c1)\n    have hV : \u2200 w, \u03c1 (\u03c6 w) = w \u2192 w \u2208 V := by\n      intro w hw\n      change w - \u03c1 (\u03c6 w) = 0\n      rw [sub_eq_zero]\n      rw [hw]\n    have H\u2082V : W \u2264 V := by\n      intro w hw\n      apply hV\n      rw [hW w hw]\n      refine reflection_mem_subspace_eq_self ?_\n      rw [mem_orthogonal_singleton_iff_inner_left]\n      exact Submodule.sub_mem _ v.prop h\u03c6v _ hw\n    have H\u2081V : (v : F) \u2208 V := by\n      apply hV\n      have : \u03c1 v = \u03c6 v := reflection_sub (\u03c6.norm_map v).symm\n      rw [\u2190 this]\n      exact reflection_reflection _ _\n    have : finrank \u211d V\u15ee \u2264 n := by\n      change finrank \u211d W\u15ee \u2264 n + 1 at hn\n      have : finrank \u211d W + 1 \u2264 finrank \u211d V :=\n        finrank_lt_finrank_of_lt (SetLike.lt_iff_le_and_exists.2 \u27e8H\u2082V, v, H\u2081V, hv'\u27e9)\n      have : finrank \u211d V + finrank \u211d V\u15ee = finrank \u211d F := V.finrank_add_finrank_orthogonal\n      have : finrank \u211d W + finrank \u211d W\u15ee = finrank \u211d F := W.finrank_add_finrank_orthogonal\n      omega\n    obtain \u27e8l, hl, h\u03c6l\u27e9 := IH (\u03c1 * \u03c6) this\n    refine \u27e8x::l, Nat.succ_le_succ hl, ?_\u27e9\n    rw [List.map_cons]\n    rw [List.prod_cons]\n    have := congr_arg (\u03c1 * \u00b7) h\u03c6l\n    dsimp only at this\n    rwa [\u2190 mul_assoc, reflection_mul_reflection, one_mul] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invariant_orthogonalComplement_eigenspace (hT : T.IsSymmetric) (\u03bc : \ud835\udd5c)\n    (v : E) (hv : v \u2208 (eigenspace T \u03bc)\u15ee) : T v \u2208 (eigenspace T \u03bc)\u15ee := by\n  intro w hw\n  have : T w = (\u03bc : \ud835\udd5c) \u2022 w := by rwa [mem_eigenspace_iff] at hw\n  simp [\u2190 hT w, this, inner_smul_left, hv w hw]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Spectrum.lean", "context": {"open": ["scoped ComplexConjugate", "Module.End"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{T : E \u2192\u2097[\ud835\udd5c] E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\n\u03bc : \ud835\udd5c\nv : E\nhv : v \u2208 (eigenspace T \u03bc)\u15ee\n\u22a2 T v \u2208 (eigenspace T \u03bc)\u15ee"}, {"line": "intro w hw", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\n\u03bc : \ud835\udd5c\nv : E\nhv : v \u2208 (eigenspace T \u03bc)\u15ee\nw : E\nhw : w \u2208 eigenspace T \u03bc\n\u22a2 inner w (T v) = 0"}, {"line": "have : T w = (\u03bc : \ud835\udd5c) \u2022 w := by rwa [mem_eigenspace_iff] at hw", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\n\u03bc : \ud835\udd5c\nv : E\nhv : v \u2208 (eigenspace T \u03bc)\u15ee\nw : E\nhw : w \u2208 eigenspace T \u03bc\nthis : sorry\n\u22a2 inner w (T v) = 0"}, {"line": "simp [\u2190 hT w, this, inner_smul_left, hv w hw]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\n\u03bc : \ud835\udd5c\nv : E\nhv : v \u2208 (eigenspace T \u03bc)\u15ee\nw : E\nhw : w \u2208 eigenspace T \u03bc\nthis : sorry\n\u22a2 inner (T w) v = 0"}]}
{"declaration": "theorem orthogonalComplement_iSup_eigenspaces_invariant (hT : T.IsSymmetric)\n    \u2983v : E\u2984 (hv : v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee) : T v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee := by\n  rw [\u2190 Submodule.iInf_orthogonal] at hv \u22a2\n  exact T.iInf_invariant hT.invariant_orthogonalComplement_eigenspace v hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Spectrum.lean", "context": {"open": ["scoped ComplexConjugate", "Module.End"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{T : E \u2192\u2097[\ud835\udd5c] E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nv : E\nhv : v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee\n\u22a2 T v \u2208 (\u2a06 \u03bc, eigenspace T \u03bc)\u15ee"}, {"line": "rw [\u2190 Submodule.iInf_orthogonal] at hv \u22a2", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : RCLike \ud835\udd5c\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nv : E\nhv : v \u2208 \u2a05 i, (eigenspace T i)\u15ee\n\u22a2 T v \u2208 \u2a05 i, (eigenspace T i)\u15ee"}, {"line": "exact T.iInf_invariant hT.invariant_orthogonalComplement_eigenspace v hv", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsSymmetric.pow {T : E \u2192\u2097[\ud835\udd5c] E} (hT : T.IsSymmetric) (n : \u2115) : (T ^ n).IsSymmetric := by\n  refine Nat.le_induction (by simp [Module.End.one_eq_id]) (fun k _ ih \u21a6 ?_) n n.zero_le\n  rw [Module.End.iterate_succ]\n  rw [\u2190 Module.End.mul_eq_comp]\n  exact ih.mul_of_commute hT <| .pow_left rfl k\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/Symmetric.lean", "context": {"open": ["RCLike", "ComplexConjugate"], "variables": ["{\ud835\udd5c E : Type*} [RCLike \ud835\udd5c]", "[SeminormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nn : \u2115\n\u22a2 (T ^ n).IsSymmetric"}, {"line": "refine Nat.le_induction (by simp [Module.End.one_eq_id]) (fun k _ ih \u21a6 ?_) n n.zero_le", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nn k : \u2115\nx\u271d : 0 \u2264 k\nih : (T ^ k).IsSymmetric\n\u22a2 (T ^ (k + 1)).IsSymmetric"}, {"line": "rw [Module.End.iterate_succ]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nn k : \u2115\nx\u271d : 0 \u2264 k\nih : (T ^ k).IsSymmetric\n\u22a2 ((T ^ k) \u2218\u2097 T).IsSymmetric"}, {"line": "rw [\u2190 Module.End.mul_eq_comp]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : InnerProductSpace \ud835\udd5c E\nT : E \u2192\u2097[\ud835\udd5c] E\nhT : T.IsSymmetric\nn k : \u2115\nx\u271d : 0 \u2264 k\nih : (T ^ k).IsSymmetric\n\u22a2 LinearMap.IsSymmetric (T ^ k * T)"}, {"line": "exact ih.mul_of_commute hT <| .pow_left rfl k", "tactic_state": "No Goals!"}]}
{"declaration": "theorem areaForm_to_volumeForm (x y : E) : \u03c9 x y = o.volumeForm ![x, y] := by simp [areaForm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 sorry = sorry"}, {"line": "simp [areaForm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_areaForm_le (x y : E) : |\u03c9 x y| \u2264 \u2016x\u2016 * \u2016y\u2016 := by\n  simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.abs_volumeForm_apply_le ![x, y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 |sorry| \u2264 \u2016x\u2016 * \u2016y\u2016"}, {"line": "simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.abs_volumeForm_apply_le ![x, y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem areaForm_le (x y : E) : \u03c9 x y \u2264 \u2016x\u2016 * \u2016y\u2016 := by\n  simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.volumeForm_apply_le ![x, y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 sorry \u2264 \u2016x\u2016 * \u2016y\u2016"}, {"line": "simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.volumeForm_apply_le ![x, y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inner_rightAngleRotationAux\u2081_right (x y : E) :\n    \u27eax, o.rightAngleRotationAux\u2081 y\u27eb = -\u03c9 x y := by\n  rw [real_inner_comm]\n  simp [o.areaForm_swap y x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 inner x sorry = -sorry"}, {"line": "rw [real_inner_comm]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 inner sorry x = -sorry"}, {"line": "simp [o.areaForm_swap y x]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 inner (sorry ()) x = -sorry ()"}]}
{"declaration": "theorem inner_rightAngleRotation_swap (x y : E) : \u27eax, J y\u27eb = -\u27eaJ x, y\u27eb := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\nJ : x\u271d\nx y : E\n\u22a2 inner x sorry = -inner sorry y"}, {"line": "simp", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\nJ : x\u271d\nx y : E\n\u22a2 inner x (sorry ()) = -inner (sorry ()) y"}]}
{"declaration": "theorem inner_rightAngleRotation_swap' (x y : E) : \u27eaJ x, y\u27eb = -\u27eax, J y\u27eb := by\n  simp [o.inner_rightAngleRotation_swap x y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\nJ : x\u271d\nx y : E\n\u22a2 inner sorry y = -inner x sorry"}, {"line": "simp [o.inner_rightAngleRotation_swap x y]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\nJ : x\u271d\nx y : E\n\u22a2 inner (sorry ()) y = -inner x (sorry ())"}]}
{"declaration": "theorem areaForm_comp_rightAngleRotation (x y : E) : \u03c9 (J x) (J y) = \u03c9 x y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\nx y : E\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inner_mul_inner_add_areaForm_mul_areaForm' (a x : E) :\n    \u27eaa, x\u27eb \u2022 inner\u209b\u2097 \u211d a + \u03c9 a x \u2022 \u03c9 a = \u2016a\u2016 ^ 2 \u2022 inner\u209b\u2097 \u211d x := by\n  by_cases ha : a = 0\n  \u00b7 simp [ha]\n  apply (o.basisRightAngleRotation a ha).ext\n  intro i\n  fin_cases i\n  \u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, real_inner_comm]\n  \u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, o.areaForm_swap a x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "by_cases ha : a = 0", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\n\u22a2 OfNat E 0\n---\ncase pos\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : a = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "\u00b7 simp [ha]", "tactic_state": "case pos\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : a = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "apply (o.basisRightAngleRotation a ha).ext", "tactic_state": "\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192 [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 E \u2192 E \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 (a x : E) \u2192 HSMul (?m.7548 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "intro i", "tactic_state": "i : Type u_1\n\u22a2 [inst : NormedAddCommGroup i] \u2192\n    [inst_1 : InnerProductSpace \u211d i] \u2192 [inst_2 : Fact (finrank \u211d i = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 i \u2192 i \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 (a x : E) \u2192 HSMul (?m.8665 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "fin_cases i", "tactic_state": "i : Type u_1\n\u22a2 [inst : NormedAddCommGroup i] \u2192\n    [inst_1 : InnerProductSpace \u211d i] \u2192 [inst_2 : Fact (finrank \u211d i = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 i \u2192 i \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 (a x : E) \u2192 HSMul (?m.8665 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "\u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, real_inner_comm]", "tactic_state": "\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7547} \u2192 (a x : E) \u2192 HSMul (?m.8665 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}, {"line": "\u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, o.areaForm_swap a x]", "tactic_state": "case neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 (inner\u209b\u2097 \u211d) a + sorry \u2022 sorry = \u2016a\u2016 ^ 2 \u2022 (inner\u209b\u2097 \u211d) x"}]}
{"declaration": "theorem inner_sq_add_areaForm_sq (a b : E) : \u27eaa, b\u27eb ^ 2 + \u03c9 a b ^ 2 = \u2016a\u2016 ^ 2 * \u2016b\u2016 ^ 2 := by\n  simpa [sq, real_inner_self_eq_norm_sq] using o.inner_mul_inner_add_areaForm_mul_areaForm a b b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na b : E\n\u22a2 inner a b ^ 2 + sorry ^ 2 = \u2016a\u2016 ^ 2 * \u2016b\u2016 ^ 2"}, {"line": "simpa [sq, real_inner_self_eq_norm_sq] using o.inner_mul_inner_add_areaForm_mul_areaForm a b b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inner_mul_areaForm_sub' (a x : E) : \u27eaa, x\u27eb \u2022 \u03c9 a - \u03c9 a x \u2022 inner\u209b\u2097 \u211d a = \u2016a\u2016 ^ 2 \u2022 \u03c9 x := by\n  by_cases ha : a = 0\n  \u00b7 simp [ha]\n  apply (o.basisRightAngleRotation a ha).ext\n  intro i\n  fin_cases i\n  \u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, o.areaForm_swap a x]\n  \u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, real_inner_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "by_cases ha : a = 0", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\n\u22a2 OfNat E 0\n---\ncase pos\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : a = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "\u00b7 simp [ha]", "tactic_state": "case pos\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : a = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "apply (o.basisRightAngleRotation a ha).ext", "tactic_state": "\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192 [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 E \u2192 E \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 (a x : E) \u2192 HSMul (?m.7894 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "intro i", "tactic_state": "i : Type u_1\n\u22a2 [inst : NormedAddCommGroup i] \u2192\n    [inst_1 : InnerProductSpace \u211d i] \u2192 [inst_2 : Fact (finrank \u211d i = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 i \u2192 i \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 (a x : E) \u2192 HSMul (?m.9011 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "fin_cases i", "tactic_state": "i : Type u_1\n\u22a2 [inst : NormedAddCommGroup i] \u2192\n    [inst_1 : InnerProductSpace \u211d i] \u2192 [inst_2 : Fact (finrank \u211d i = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 i \u2192 i \u2192 Type u_3\n---\n\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 (a x : E) \u2192 HSMul (?m.9011 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "\u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, o.areaForm_swap a x]", "tactic_state": "\u22a2 {E : Type u_1} \u2192\n    [inst : NormedAddCommGroup E] \u2192\n      [inst_1 : InnerProductSpace \u211d E] \u2192\n        [inst_2 : Fact (finrank \u211d E = 2)] \u2192 {\u03c9 : ?m.7893} \u2192 (a x : E) \u2192 HSMul (?m.9011 a x) (E \u2192\u2097[\u211d] \u211d) (E \u2192\u2097[\u211d] \u211d)\n---\ncase neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}, {"line": "\u00b7 simp [real_inner_self_eq_norm_sq, mul_comm, real_inner_comm]", "tactic_state": "case neg\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx\u271d : Sort u_2\n\u03c9 : x\u271d\na x : E\nha : \u00aca = 0\n\u22a2 inner a x \u2022 sorry - sorry \u2022 (inner\u209b\u2097 \u211d) a = \u2016a\u2016 ^ 2 \u2022 sorry"}]}
{"declaration": "theorem kahler_apply_self (x : E) : o.kahler x x = \u2016x\u2016 ^ 2 := by\n  simp [kahler_apply_apply, real_inner_self_eq_norm_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx : E\n\u22a2 sorry = \u2016x\u2016 ^ 2"}, {"line": "simp [kahler_apply_apply, real_inner_self_eq_norm_sq]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx : E\n\u22a2 sorry () = \u2016x\u2016 ^ 2"}]}
{"declaration": "theorem kahler_comp_rightAngleRotation' (x y : E) :\n    -(Complex.I * (Complex.I * o.kahler x y)) = o.kahler x y := by\n  linear_combination -o.kahler x y * Complex.I_sq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\n\u22a2 -(Complex.I * (Complex.I * sorry)) = sorry"}, {"line": "linear_combination -o.kahler x y * Complex.I_sq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kahler_neg_orientation (x y : E) : (-o).kahler x y = conj (o.kahler x y) := by\n  simp [kahler_apply_apply, Complex.conj_ofReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : \u2124\nx y : E\n\u22a2 sorry = (starRingEnd (?m.5998 x y)) sorry"}, {"line": "simp [kahler_apply_apply, Complex.conj_ofReal]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\no : \u2124\nx y : E\n\u22a2 sorry () = (starRingEnd (?m.5998 x y)) (sorry ())"}]}
{"declaration": "theorem kahler_mul (a x y : E) : o.kahler x a * o.kahler a y = \u2016a\u2016 ^ 2 * o.kahler x y := by\n  trans ((\u2016a\u2016 ^ 2 :) : \u2102) * o.kahler x y\n  \u00b7 apply Complex.ext\n    \u00b7 simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x]\n      rw [o.areaForm_swap x a]\n      linear_combination o.inner_mul_inner_add_areaForm_mul_areaForm a x y\n    \u00b7 simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x]\n      rw [o.areaForm_swap x a]\n      linear_combination o.inner_mul_areaForm_sub a x y\n  \u00b7 norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\na x y : E\n\u22a2 sorry * sorry = \u2016a\u2016 ^ 2 * sorry"}, {"line": "trans ((\u2016a\u2016 ^ 2 :) : \u2102) * o.kahler x y", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\na x y : E\n\u22a2 sorry * sorry = sorry\n---\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\na x y : E\n\u22a2 sorry = \u2016a\u2016 ^ 2 * sorry"}, {"line": "\u00b7 apply Complex.ext\n    \u00b7 simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x]\n      rw [o.areaForm_swap x a]\n      linear_combination o.inner_mul_inner_add_areaForm_mul_areaForm a x y\n    \u00b7 simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x]\n      rw [o.areaForm_swap x a]\n      linear_combination o.inner_mul_areaForm_sub a x y", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\na x y : E\n\u22a2 sorry = \u2016a\u2016 ^ 2 * sorry"}, {"line": "\u00b7 norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_kahler (x y : E) : Complex.normSq (o.kahler x y) = \u2016x\u2016 ^ 2 * \u2016y\u2016 ^ 2 := by\n  simpa [kahler_apply_apply, Complex.normSq, sq] using o.inner_sq_add_areaForm_sq x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\n\u22a2 Complex.normSq sorry = \u2016x\u2016 ^ 2 * \u2016y\u2016 ^ 2"}, {"line": "simpa [kahler_apply_apply, Complex.normSq, sq] using o.inner_sq_add_areaForm_sq x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kahler_eq_zero_iff (x y : E) : o.kahler x y = 0 \u2194 x = 0 \u2228 y = 0 := by\n  refine \u27e8o.eq_zero_or_eq_zero_of_kahler_eq_zero, ?_\u27e9\n  rintro (rfl | rfl) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\n\u22a2 sorry = 0 \u2194 x = 0 \u2228 y = 0"}, {"line": "refine \u27e8o.eq_zero_or_eq_zero_of_kahler_eq_zero, ?_\u27e9", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\n\u22a2 x = 0 \u2228 y = 0 \u2192 sorry = 0"}, {"line": "rintro (rfl | rfl) <;> simp", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\ny : E\n\u22a2 sorry () = 0\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx : E\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem kahler_ne_zero {x y : E} (hx : x \u2260 0) (hy : y \u2260 0) : o.kahler x y \u2260 0 := by\n  apply mt o.eq_zero_or_eq_zero_of_kahler_eq_zero\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 sorry \u2260 0"}, {"line": "apply mt o.eq_zero_or_eq_zero_of_kahler_eq_zero", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 \u00ac?m.2071\n---\nE : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\nx y : E\nhx : x \u2260 0\nhy : y \u2260 0\n\u22a2 Prop"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem kahler_comp_linearIsometryEquiv (\u03c6 : E \u2243\u2097\u1d62[\u211d] E)\n    (h\u03c6 : 0 < LinearMap.det (\u03c6.toLinearEquiv : E \u2192\u2097[\u211d] E)) (x y : E) :\n    o.kahler (\u03c6 x) (\u03c6 y) = o.kahler x y := by\n  simp [kahler_apply_apply, o.areaForm_comp_linearIsometryEquiv \u03c6 h\u03c6]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/TwoDim.lean", "context": {"open": ["scoped RealInnerProductSpace ComplexConjugate", "Module"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E] [Fact (finrank \u211d E = 2)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\ninst\u271d : Fact (finrank \u211d E = 2)\n\u03c6 : E \u2243\u2097\u1d62[\u211d] E\nh\u03c6 : 0 < LinearMap.det \u2191\u03c6.toLinearEquiv\nx y : E\n\u22a2 sorry = sorry"}, {"line": "simp [kahler_apply_apply, o.areaForm_comp_linearIsometryEquiv \u03c6 h\u03c6]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsHilbertSum.linearIsometryEquiv_symm_apply (hV : IsHilbertSum \ud835\udd5c G V)\n    (w : lp G 2) : hV.linearIsometryEquiv.symm w = \u2211' i, V i (w i) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/l2Space.lean", "context": {"open": ["RCLike Submodule Filter", "scoped NNReal ENNReal ComplexConjugate Topology"], "variables": ["{\u03b9 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {E : Type*}", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{G : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (G i)] [\u2200 i, InnerProductSpace \ud835\udd5c (G i)]", "[CompleteSpace E] {V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E} (hV : OrthogonalFamily \ud835\udd5c G V)", "(\ud835\udd5c G)", "[CompleteSpace E] (V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E) (F : \u03b9 \u2192 Submodule \ud835\udd5c E)", "{\ud835\udd5c G V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2076 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d\u00b9 inst\u271d : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : IsHilbertSum \ud835\udd5c G V\nw : \u21a5(lp G 2)\n\u22a2 hV.linearIsometryEquiv.symm w = \u2211' (i : \u03b9), (V i) (\u2191w i)"}, {"line": "simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum \ud835\udd5c G V)\n    (w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.hasSum_linearIsometry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/l2Space.lean", "context": {"open": ["RCLike Submodule Filter", "scoped NNReal ENNReal ComplexConjugate Topology"], "variables": ["{\u03b9 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {E : Type*}", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{G : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (G i)] [\u2200 i, InnerProductSpace \ud835\udd5c (G i)]", "[CompleteSpace E] {V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E} (hV : OrthogonalFamily \ud835\udd5c G V)", "(\ud835\udd5c G)", "[CompleteSpace E] (V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E) (F : \u03b9 \u2192 Submodule \ud835\udd5c E)", "{\ud835\udd5c G V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2076 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d\u00b9 inst\u271d : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\nhV : IsHilbertSum \ud835\udd5c G V\nw : \u21a5(lp G 2)\n\u22a2 HasSum (fun i => (V i) (\u2191w i)) (hV.linearIsometryEquiv.symm w)"}, {"line": "simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.hasSum_linearIsometry]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsHilbertSum.linearIsometryEquiv_symm_apply_single\n    [DecidableEq \u03b9] (hV : IsHilbertSum \ud835\udd5c G V) {i : \u03b9} (x : G i) :\n    hV.linearIsometryEquiv.symm (lp.single 2 i x) = V i x := by\n  simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply_single]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/InnerProductSpace/l2Space.lean", "context": {"open": ["RCLike Submodule Filter", "scoped NNReal ENNReal ComplexConjugate Topology"], "variables": ["{\u03b9 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {E : Type*}", "[NormedAddCommGroup E] [InnerProductSpace \ud835\udd5c E]", "{G : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (G i)] [\u2200 i, InnerProductSpace \ud835\udd5c (G i)]", "[CompleteSpace E] {V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E} (hV : OrthogonalFamily \ud835\udd5c G V)", "(\ud835\udd5c G)", "[CompleteSpace E] (V : \u2200 i, G i \u2192\u2097\u1d62[\ud835\udd5c] E) (F : \u03b9 \u2192 Submodule \ud835\udd5c E)", "{\ud835\udd5c G V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2077 : RCLike \ud835\udd5c\nE : Type u_3\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : InnerProductSpace \ud835\udd5c E\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u2074 : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (G i)\ninst\u271d\u00b2 inst\u271d\u00b9 : CompleteSpace E\nV : (i : \u03b9) \u2192 G i \u2192\u2097\u1d62[\ud835\udd5c] E\ninst\u271d : DecidableEq \u03b9\nhV : IsHilbertSum \ud835\udd5c G V\ni : \u03b9\nx : G i\n\u22a2 hV.linearIsometryEquiv.symm (lp.single 2 i x) = (V i) x"}, {"line": "simp [IsHilbertSum.linearIsometryEquiv, OrthogonalFamily.linearIsometry_apply_single]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem absConvexHull_eq_iInter :\n    absConvexHull \ud835\udd5c s = \u22c2 (t : Set E) (_ : s \u2286 t) (_ : AbsConvex \ud835\udd5c t), t := by\n  simp [absConvexHull, iInter_subtype, iInter_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/AbsConvex.lean", "context": {"open": ["NormedField Set", "NNReal Pointwise Topology"], "variables": ["{\ud835\udd5c E : Type*}", "(\ud835\udd5c) [SeminormedRing \ud835\udd5c] [SMul \ud835\udd5c E] [SMul \u211d E] [AddCommMonoid E]", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c} {s : Set E}", "(\ud835\udd5c s) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 (absConvexHull \ud835\udd5c) s = \u22c2 t, \u22c2 (_ : s \u2286 t), \u22c2 (_ : AbsConvex \ud835\udd5c t), t"}, {"line": "simp [absConvexHull, iInter_subtype, iInter_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_absConvexHull_iff : x \u2208 absConvexHull \ud835\udd5c s \u2194 \u2200 t, s \u2286 t \u2192 AbsConvex \ud835\udd5c t \u2192 x \u2208 t := by\n  simp_rw [absConvexHull_eq_iInter, mem_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/AbsConvex.lean", "context": {"open": ["NormedField Set", "NNReal Pointwise Topology"], "variables": ["{\ud835\udd5c E : Type*}", "(\ud835\udd5c) [SeminormedRing \ud835\udd5c] [SMul \ud835\udd5c E] [SMul \u211d E] [AddCommMonoid E]", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c} {s : Set E}", "(\ud835\udd5c s) in", "{t : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\nx : E\n\u22a2 x \u2208 (absConvexHull \ud835\udd5c) s \u2194 \u2200 (t : Set E), s \u2286 t \u2192 AbsConvex \ud835\udd5c t \u2192 x \u2208 t"}, {"line": "simp_rw [absConvexHull_eq_iInter, mem_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem absConvexHull_nonempty : (absConvexHull \ud835\udd5c s).Nonempty \u2194 s.Nonempty := by\n  rw [nonempty_iff_ne_empty]\n  rw [nonempty_iff_ne_empty]\n  rw [Ne]\n  rw [Ne]\n  exact not_congr absConvexHull_eq_empty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/AbsConvex.lean", "context": {"open": ["NormedField Set", "NNReal Pointwise Topology"], "variables": ["{\ud835\udd5c E : Type*}", "(\ud835\udd5c) [SeminormedRing \ud835\udd5c] [SMul \ud835\udd5c E] [SMul \u211d E] [AddCommMonoid E]", "{\ud835\udd5c}", "(\ud835\udd5c)", "{\ud835\udd5c} {s : Set E}", "(\ud835\udd5c s) in", "{t : Set E} {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 ((absConvexHull \ud835\udd5c) s).Nonempty \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 (absConvexHull \ud835\udd5c) s \u2260 \u2205 \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 (absConvexHull \ud835\udd5c) s \u2260 \u2205 \u2194 s \u2260 \u2205"}, {"line": "rw [Ne]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 \u00ac(absConvexHull \ud835\udd5c) s = \u2205 \u2194 s \u2260 \u2205"}, {"line": "rw [Ne]", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : SeminormedRing \ud835\udd5c\ninst\u271d\u00b2 : SMul \ud835\udd5c E\ninst\u271d\u00b9 : SMul \u211d E\ninst\u271d : AddCommMonoid E\ns : Set E\n\u22a2 \u00ac(absConvexHull \ud835\udd5c) s = \u2205 \u2194 \u00acs = \u2205"}, {"line": "exact not_congr absConvexHull_eq_empty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polar_nonempty (s : Set E) : Set.Nonempty (B.polar s) := by\n  use 0\n  exact zero_mem_polar B s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/Polar.lean", "context": {"open": ["Topology"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedCommRing \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\n\u22a2 (B.polar s).Nonempty"}, {"line": "use 0", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\n\u22a2 sorry \u2208 B.polar s"}, {"line": "exact zero_mem_polar B s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_polar_finite_subset_eq_polar (s : Set E) :\n    \u22c2\u2080 (B.polar '' { F | F.Finite \u2227 F \u2286 s }) = B.polar s := by\n  ext x\n  simp only [Set.sInter_image]\n  simp only [Set.mem_setOf_eq]\n  simp only [Set.mem_iInter]\n  simp only [and_imp]\n  refine \u27e8fun hx a ha \u21a6 ?_, fun hx F _ hF\u2082 => polar_antitone _ hF\u2082 hx\u27e9\n  simpa [mem_polar_singleton] using hx _ (Set.finite_singleton a) (Set.singleton_subset_iff.mpr ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/Polar.lean", "context": {"open": ["Topology"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedCommRing \ud835\udd5c] [AddCommMonoid E] [AddCommMonoid F]", "[Module \ud835\udd5c E] [Module \ud835\udd5c F]", "(B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\n\u22a2 \u22c2\u2080 (B.polar '' {F | F.Finite \u2227 F \u2286 s}) = B.polar s"}, {"line": "ext x", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\n\u22a2 x \u2208 \u22c2\u2080 (B.polar '' {F | F.Finite \u2227 F \u2286 s}) \u2194 x \u2208 B.polar s"}, {"line": "simp only [Set.sInter_image]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\n\u22a2 x \u2208 \u22c2 a \u2208 {F | F.Finite \u2227 F \u2286 s}, B.polar a \u2194 x \u2208 B.polar s"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\n\u22a2 x \u2208 \u22c2 a, \u22c2 (_ : a.Finite \u2227 a \u2286 s), B.polar a \u2194 x \u2208 B.polar s"}, {"line": "simp only [Set.mem_iInter]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\n\u22a2 (\u2200 (i : Set E), i.Finite \u2227 i \u2286 s \u2192 x \u2208 B.polar i) \u2194 x \u2208 B.polar s"}, {"line": "simp only [and_imp]", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\n\u22a2 (\u2200 (i : Set E), i.Finite \u2192 i \u2286 s \u2192 x \u2208 B.polar i) \u2194 x \u2208 B.polar s"}, {"line": "refine \u27e8fun hx a ha \u21a6 ?_, fun hx F _ hF\u2082 => polar_antitone _ hF\u2082 hx\u27e9", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2074 : NormedCommRing \ud835\udd5c\ninst\u271d\u00b3 : AddCommMonoid E\ninst\u271d\u00b2 : AddCommMonoid F\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : Module \ud835\udd5c F\nB : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c\ns : Set E\nx : F\nhx : \u2200 (i : Set E), i.Finite \u2192 i \u2286 s \u2192 x \u2208 B.polar i\na : E\nha : a \u2208 s\n\u22a2 \u2016(B a) x\u2016 \u2264 1"}, {"line": "simpa [mem_polar_singleton] using hx _ (Set.finite_singleton a) (Set.singleton_subset_iff.mpr ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_balancedCore_iff : x \u2208 balancedCore \ud835\udd5c s \u2194 \u2203 t, Balanced \ud835\udd5c t \u2227 t \u2286 s \u2227 x \u2208 t := by\n  simp_rw [balancedCore, mem_sUnion, mem_setOf_eq, and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "context": {"open": ["Set Pointwise Topology Filter"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s t : Set E} {x : E}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\nx : E\n\u22a2 x \u2208 balancedCore \ud835\udd5c s \u2194 \u2203 t, Balanced \ud835\udd5c t \u2227 t \u2286 s \u2227 x \u2208 t"}, {"line": "simp_rw [balancedCore, mem_sUnion, mem_setOf_eq, and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_balancedCore_subset (s : Set E) {a : \ud835\udd5c} (ha : \u2016a\u2016 \u2264 1) :\n    a \u2022 balancedCore \ud835\udd5c s \u2286 balancedCore \ud835\udd5c s := by\n  rintro x \u27e8y, hy, rfl\u27e9\n  rw [mem_balancedCore_iff] at hy\n  rcases hy with \u27e8t, ht1, ht2, hy\u27e9\n  exact \u27e8t, \u27e8ht1, ht2\u27e9, ht1 a ha (smul_mem_smul_set hy)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "context": {"open": ["Set Pointwise Topology Filter"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s t : Set E} {x : E}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\na : \ud835\udd5c\nha : \u2016a\u2016 \u2264 1\n\u22a2 a \u2022 balancedCore \ud835\udd5c s \u2286 balancedCore \ud835\udd5c s"}, {"line": "rintro x \u27e8y, hy, rfl\u27e9", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\na : \ud835\udd5c\nha : \u2016a\u2016 \u2264 1\ny : E\nhy : y \u2208 balancedCore \ud835\udd5c s\n\u22a2 (fun x => a \u2022 x) y \u2208 balancedCore \ud835\udd5c s"}, {"line": "rw [mem_balancedCore_iff] at hy", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\na : \ud835\udd5c\nha : \u2016a\u2016 \u2264 1\ny : E\nhy : \u2203 t, Balanced \ud835\udd5c t \u2227 t \u2286 s \u2227 y \u2208 t\n\u22a2 (fun x => a \u2022 x) y \u2208 balancedCore \ud835\udd5c s"}, {"line": "rcases hy with \u27e8t, ht1, ht2, hy\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\na : \ud835\udd5c\nha : \u2016a\u2016 \u2264 1\ny : E\nt : Set E\nht1 : Balanced \ud835\udd5c t\nht2 : t \u2286 s\nhy : y \u2208 t\n\u22a2 (fun x => a \u2022 x) y \u2208 balancedCore \ud835\udd5c s"}, {"line": "exact \u27e8t, \u27e8ht1, ht2\u27e9, ht1 a ha (smul_mem_smul_set hy)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_balancedHull_iff : x \u2208 balancedHull \ud835\udd5c s \u2194 \u2203 r : \ud835\udd5c, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 s := by\n  simp [balancedHull]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "context": {"open": ["Set Pointwise Topology Filter"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s t : Set E} {x : E}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns : Set E\nx : E\n\u22a2 x \u2208 balancedHull \ud835\udd5c s \u2194 \u2203 r, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 s"}, {"line": "simp [balancedHull]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Balanced.balancedHull_subset_of_subset (ht : Balanced \ud835\udd5c t) (h : s \u2286 t) :\n    balancedHull \ud835\udd5c s \u2286 t := by\n  intros x hx\n  obtain \u27e8r, hr, y, hy, rfl\u27e9 := mem_balancedHull_iff.1 hx\n  exact ht.smul_mem hr (h hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "context": {"open": ["Set Pointwise Topology Filter"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s t : Set E} {x : E}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nht : Balanced \ud835\udd5c t\nh : s \u2286 t\n\u22a2 balancedHull \ud835\udd5c s \u2286 t"}, {"line": "intros x hx", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nht : Balanced \ud835\udd5c t\nh : s \u2286 t\nx : E\nhx : x \u2208 balancedHull \ud835\udd5c s\n\u22a2 x \u2208 t"}, {"line": "obtain \u27e8r, hr, y, hy, rfl\u27e9 := mem_balancedHull_iff.1 hx", "tactic_state": "case intro.intro.intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nht : Balanced \ud835\udd5c t\nh : s \u2286 t\nr : \ud835\udd5c\nhr : \u2016r\u2016 \u2264 1\ny : E\nhy : y \u2208 s\nhx : (fun x => r \u2022 x) y \u2208 balancedHull \ud835\udd5c s\n\u22a2 (fun x => r \u2022 x) y \u2208 t"}, {"line": "exact ht.smul_mem hr (h hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem balancedHull_mono (hst : s \u2286 t) : balancedHull \ud835\udd5c s \u2286 balancedHull \ud835\udd5c t := by\n  intro x hx\n  rw [mem_balancedHull_iff] at *\n  obtain \u27e8r, hr\u2081, hr\u2082\u27e9 := hx\n  use r\n  exact \u27e8hr\u2081, smul_set_mono hst hr\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/BalancedCoreHull.lean", "context": {"open": ["Set Pointwise Topology Filter"], "variables": ["{\ud835\udd5c E \u03b9 : Type*}", "[SeminormedRing \ud835\udd5c]", "(\ud835\udd5c) [SMul \ud835\udd5c E] {s t : Set E} {x : E}", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhst : s \u2286 t\n\u22a2 balancedHull \ud835\udd5c s \u2286 balancedHull \ud835\udd5c t"}, {"line": "intro x hx", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhst : s \u2286 t\nx : E\nhx : x \u2208 balancedHull \ud835\udd5c s\n\u22a2 x \u2208 balancedHull \ud835\udd5c t"}, {"line": "rw [mem_balancedHull_iff] at *", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhst : s \u2286 t\nx : E\nhx : \u2203 r, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 s\n\u22a2 \u2203 r, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 t"}, {"line": "obtain \u27e8r, hr\u2081, hr\u2082\u27e9 := hx", "tactic_state": "case intro.intro\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhst : s \u2286 t\nx : E\nr : \ud835\udd5c\nhr\u2081 : \u2016r\u2016 \u2264 1\nhr\u2082 : x \u2208 r \u2022 s\n\u22a2 \u2203 r, \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 t"}, {"line": "use r", "tactic_state": "case h\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedRing \ud835\udd5c\ninst\u271d : SMul \ud835\udd5c E\ns t : Set E\nhst : s \u2286 t\nx : E\nr : \ud835\udd5c\nhr\u2081 : \u2016r\u2016 \u2264 1\nhr\u2082 : x \u2208 r \u2022 s\n\u22a2 \u2016r\u2016 \u2264 1 \u2227 x \u2208 r \u2022 t"}, {"line": "exact \u27e8hr\u2081, smul_set_mono hst hr\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem balanced_iff_neg_mem (hs : Convex \u211d s) : Balanced \u211d s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 -x \u2208 s := by\n  refine \u27e8fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => ?_\u27e9\n  rw [Real.norm_eq_abs] at ha\n  rw [abs_le] at ha\n  rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring]\n  rw [add_smul]\n  rw [neg_smul]\n  rw [\u2190 smul_neg]\n  exact hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two)\n    (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two) (by ring)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/Basic.lean", "context": {"open": ["Set", "Pointwise Topology"], "variables": ["{\ud835\udd5c \ud835\udd5d E F : Type*} {\u03b9 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "[SeminormedRing \ud835\udd5c]", "[SMul \ud835\udd5c E] {s A B : Set E}", "(\ud835\udd5c) in", "[SMul \ud835\udd5d E] [SMulCommClass \ud835\udd5c \ud835\udd5d E]", "[AddCommGroup E] [Module \ud835\udd5c E] {s t : Set E}", "[NormedDivisionRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {s t : Set E}", "[NormedRing \ud835\udd5d] [Module \ud835\udd5c \ud835\udd5d] [IsBoundedSMul \ud835\udd5c \ud835\udd5d] [SMulWithZero \ud835\udd5d E] [IsScalarTower \ud835\udd5c \ud835\udd5d E]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {s A : Set E} {x : E} {a b : \ud835\udd5c}", "[TopologicalSpace E] [ContinuousSMul \ud835\udd5c E]", "[NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] {s : Set E}", "[Module \u211d E] [SMulCommClass \u211d \ud835\udd5c E]", "[AddCommGroup E] [Module \u211d E] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\n\u22a2 Balanced \u211d s \u2194 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s"}, {"line": "refine \u27e8fun h x => h.neg_mem_iff.2, fun h a ha => smul_set_subset_iff.2 fun x hx => ?_\u27e9", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : \u2016a\u2016 \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 a \u2022 x \u2208 s"}, {"line": "rw [Real.norm_eq_abs] at ha", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : |a| \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 a \u2022 x \u2208 s"}, {"line": "rw [abs_le] at ha", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : -1 \u2264 a \u2227 a \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 a \u2022 x \u2208 s"}, {"line": "rw [show a = -((1 - a) / 2) + (a - -1) / 2 by ring]", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : -1 \u2264 a \u2227 a \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 (-((1 - a) / 2) + (a - -1) / 2) \u2022 x \u2208 s"}, {"line": "rw [add_smul]", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : -1 \u2264 a \u2227 a \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 -((1 - a) / 2) \u2022 x + ((a - -1) / 2) \u2022 x \u2208 s"}, {"line": "rw [neg_smul]", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : -1 \u2264 a \u2227 a \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 -(((1 - a) / 2) \u2022 x) + ((a - -1) / 2) \u2022 x \u2208 s"}, {"line": "rw [\u2190 smul_neg]", "tactic_state": "E : Type u_3\ninst\u271d\u2077 inst\u271d\u2076 inst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : TopologicalSpace E\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \u211d E\ninst\u271d\u00b9 : AddCommGroup E\ninst\u271d : Module \u211d E\ns : Set E\nhs : Convex \u211d s\nh : \u2200 \u2983x : E\u2984, x \u2208 s \u2192 -x \u2208 s\na : \u211d\nha : -1 \u2264 a \u2227 a \u2264 1\nx : E\nhx : x \u2208 s\n\u22a2 ((1 - a) / 2) \u2022 -x + ((a - -1) / 2) \u2022 x \u2208 s"}, {"line": "exact hs (h hx) hx (div_nonneg (sub_nonneg_of_le ha.2) zero_le_two)\n    (div_nonneg (sub_nonneg_of_le ha.1) zero_le_two) (by ring)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isVonNBounded_sub_of_nonempty (hs : s.Nonempty) (ht : t.Nonempty) :\n    IsVonNBounded \ud835\udd5c (s - t) \u2194 IsVonNBounded \ud835\udd5c s \u2227 IsVonNBounded \ud835\udd5c t := by\n  simp [sub_eq_add_neg, isVonNBounded_add_of_nonempty, hs, ht]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/Bounded.lean", "context": {"open": ["Set Filter Function", "scoped Topology Pointwise"], "variables": ["{\ud835\udd5c \ud835\udd5c' E F \u03b9 : Type*}", "(\ud835\udd5c)", "[SeminormedRing \ud835\udd5c] [SMul \ud835\udd5c E] [Zero E]", "[TopologicalSpace E]", "(E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c] [AddZeroClass E] [TopologicalSpace E] [ContinuousAdd E]", "[SeminormedRing \ud835\udd5c] [AddGroup E] [TopologicalSpace E] [IsTopologicalAddGroup E]", "[SeminormedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type*} [NormedDivisionRing \ud835\udd5c\u2081] [NormedDivisionRing \ud835\udd5c\u2082] [AddCommGroup E]", "[NontriviallyNormedField \ud835\udd5c]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[TopologicalSpace E] [ContinuousSMul \ud835\udd5c E]", "[ContinuousAdd E] {s t : Set E}", "[IsTopologicalAddGroup E] {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9\u00b3 : Zero E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddZeroClass E\ninst\u271d\u00b9\u2070 : TopologicalSpace E\ninst\u271d\u2079 : ContinuousAdd E\ninst\u271d\u2078 : AddGroup E\ninst\u271d\u2077 : TopologicalSpace E\ninst\u271d\u2076 : IsTopologicalAddGroup E\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : IsTopologicalAddGroup E\ns t : Set E\nx\u271d : Sort u_8\nIsVonNBounded : x\u271d\nhs : s.Nonempty\nht : t.Nonempty\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [sub_eq_add_neg, isVonNBounded_add_of_nonempty, hs, ht]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isVonNBounded_sub :\n    IsVonNBounded \ud835\udd5c (s - t) \u2194 s = \u2205 \u2228 t = \u2205 \u2228 IsVonNBounded \ud835\udd5c s \u2227 IsVonNBounded \ud835\udd5c t := by\n  simp [sub_eq_add_neg, isVonNBounded_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/Bounded.lean", "context": {"open": ["Set Filter Function", "scoped Topology Pointwise"], "variables": ["{\ud835\udd5c \ud835\udd5c' E F \u03b9 : Type*}", "(\ud835\udd5c)", "[SeminormedRing \ud835\udd5c] [SMul \ud835\udd5c E] [Zero E]", "[TopologicalSpace E]", "(E)", "{\ud835\udd5c E}", "[SeminormedRing \ud835\udd5c] [AddZeroClass E] [TopologicalSpace E] [ContinuousAdd E]", "[SeminormedRing \ud835\udd5c] [AddGroup E] [TopologicalSpace E] [IsTopologicalAddGroup E]", "[SeminormedRing \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c\u2081 \ud835\udd5c\u2082 : Type*} [NormedDivisionRing \ud835\udd5c\u2081] [NormedDivisionRing \ud835\udd5c\u2082] [AddCommGroup E]", "[NontriviallyNormedField \ud835\udd5c]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[TopologicalSpace E] [ContinuousSMul \ud835\udd5c E]", "[ContinuousAdd E] {s t : Set E}", "[IsTopologicalAddGroup E] {s t : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9\u00b3 : Zero E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddZeroClass E\ninst\u271d\u00b9\u2070 : TopologicalSpace E\ninst\u271d\u2079 : ContinuousAdd E\ninst\u271d\u2078 : AddGroup E\ninst\u271d\u2077 : TopologicalSpace E\ninst\u271d\u2076 : IsTopologicalAddGroup E\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : IsTopologicalAddGroup E\ns t : Set E\nx\u271d : Sort u_8\nIsVonNBounded : x\u271d\n\u22a2 sorry \u2194 s = \u2205 \u2228 t = \u2205 \u2228 sorry \u2227 sorry"}, {"line": "simp [sub_eq_add_neg, isVonNBounded_add]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9\u00b3 : Zero E\ninst\u271d\u00b9\u00b2 : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddZeroClass E\ninst\u271d\u00b9\u2070 : TopologicalSpace E\ninst\u271d\u2079 : ContinuousAdd E\ninst\u271d\u2078 : AddGroup E\ninst\u271d\u2077 : TopologicalSpace E\ninst\u271d\u2076 : IsTopologicalAddGroup E\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : IsTopologicalAddGroup E\ns t : Set E\nx\u271d : Sort u_8\nIsVonNBounded : x\u271d\n\u22a2 sorry () \u2194 s = \u2205 \u2228 t = \u2205 \u2228 sorry ()"}]}
{"declaration": "theorem basisSets_nonempty [Nonempty \u03b9] : p.basisSets.Nonempty := by\n  let i := Classical.arbitrary \u03b9\n  refine nonempty_def.mpr \u27e8(p i).ball 0 1, ?_\u27e9\n  exact p.basisSets_singleton_mem i zero_lt_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "context": {"open": ["NormedField Set Seminorm TopologicalSpace Filter List", "NNReal Pointwise Topology Uniformity"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5d \ud835\udd5d\u2082 E F G \u03b9 \u03b9' : Type*}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c E \u03b9)", "{\ud835\udd5c E \u03b9}", "(p : SeminormFamily \ud835\udd5c E \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\ninst\u271d : Nonempty \u03b9\n\u22a2 p.basisSets.Nonempty"}, {"line": "let i := Classical.arbitrary \u03b9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\ninst\u271d : Nonempty \u03b9\ni : \u03b9 := sorry\n\u22a2 p.basisSets.Nonempty"}, {"line": "refine nonempty_def.mpr \u27e8(p i).ball 0 1, ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module \ud835\udd5c E\np : SeminormFamily \ud835\udd5c E \u03b9\ninst\u271d : Nonempty \u03b9\ni : \u03b9 := sorry\n\u22a2 sorry \u2208 p.basisSets"}, {"line": "exact p.basisSets_singleton_mem i zero_lt_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem WithSeminorms.separating_iff_T1 (hp : WithSeminorms p) :\n    (\u2200 x, x \u2260 0 \u2192 \u2203 i, p i x \u2260 0) \u2194 T1Space E := by\n  refine \u27e8WithSeminorms.T1_of_separating hp, ?_\u27e9\n  intro\n  exact WithSeminorms.separating_of_T1 hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "context": {"open": ["NormedField Set Seminorm TopologicalSpace Filter List", "NNReal Pointwise Topology Uniformity"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5d \ud835\udd5d\u2082 E F G \u03b9 \u03b9' : Type*}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c E \u03b9)", "{\ud835\udd5c E \u03b9}", "(p : SeminormFamily \ud835\udd5c E \u03b9)", "[Nonempty \u03b9]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[NormedField \ud835\udd5c\u2082] [AddCommGroup F] [Module \ud835\udd5c\u2082 F]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9]", "[TopologicalSpace E]", "{p : SeminormFamily \ud835\udd5c E \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b9\u00b9 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : Nonempty \u03b9\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : TopologicalSpace E\np : SeminormFamily \ud835\udd5c E \u03b9\nhp : WithSeminorms p\n\u22a2 (\u2200 (x : E), x \u2260 0 \u2192 \u2203 i, (p i) x \u2260 0) \u2194 T1Space E"}, {"line": "refine \u27e8WithSeminorms.T1_of_separating hp, ?_\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b9\u00b9 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : Nonempty \u03b9\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : TopologicalSpace E\np : SeminormFamily \ud835\udd5c E \u03b9\nhp : WithSeminorms p\n\u22a2 T1Space E \u2192 \u2200 (x : E), x \u2260 0 \u2192 \u2203 i, (p i) x \u2260 0"}, {"line": "intro", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b9\u00b9 : NormedField \ud835\udd5c\ninst\u271d\u00b9\u2070 : AddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : Nonempty \u03b9\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : AddCommGroup E\ninst\u271d\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074 : NormedField \ud835\udd5c\ninst\u271d\u00b3 : AddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : TopologicalSpace E\np : SeminormFamily \ud835\udd5c E \u03b9\nhp : WithSeminorms p\na\u271d : T1Space E\n\u22a2 \u2200 (x : E), x \u2260 0 \u2192 \u2203 i, (p i) x \u2260 0"}, {"line": "exact WithSeminorms.separating_of_T1 hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cont_withSeminorms_normedSpace (F) [SeminormedAddCommGroup F] [NormedSpace \ud835\udd5d\u2082 F]\n    [TopologicalSpace E] {p : \u03b9 \u2192 Seminorm \ud835\udd5d E} (hp : WithSeminorms p)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : \u2203 (s : Finset \u03b9) (C : \u211d\u22650), (normSeminorm \ud835\udd5d\u2082 F).comp f \u2264 C \u2022 s.sup p) :\n    Continuous f := by\n  rw [\u2190 Seminorm.isBounded_const (Fin 1)] at hf\n  exact continuous_from_bounded hp (norm_withSeminorms \ud835\udd5d\u2082 F) f hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "context": {"open": ["NormedField Set Seminorm TopologicalSpace Filter List", "NNReal Pointwise Topology Uniformity"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5d \ud835\udd5d\u2082 E F G \u03b9 \u03b9' : Type*}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c E \u03b9)", "{\ud835\udd5c E \u03b9}", "(p : SeminormFamily \ud835\udd5c E \u03b9)", "[Nonempty \u03b9]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[NormedField \ud835\udd5c\u2082] [AddCommGroup F] [Module \ud835\udd5c\u2082 F]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9]", "[TopologicalSpace E]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9] [TopologicalSpace E]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[SemilatticeSup F] [Nonempty F]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Nonempty \u03b9]", "[t : TopologicalSpace E]", "[NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[TopologicalSpace E]", "[NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[NormedField \ud835\udd5d] [Module \ud835\udd5d E]", "[NontriviallyNormedField \ud835\udd5c\u2082] [AddCommGroup F] [Module \ud835\udd5c\u2082 F]", "[NormedField \ud835\udd5d\u2082] [Module \ud835\udd5d\u2082 F]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082} [RingHomIsometric \u03c4\u2081\u2082]", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b2\u00b2 : AddCommGroup E\ninst\u271d\u00b2\u00b9 : Nonempty \u03b9\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 : AddCommGroup E\ninst\u271d\u00b9\u2078 : Nonempty \u03b9\ninst\u271d\u00b9\u2077 : TopologicalSpace E\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Nonempty \u03b9\ninst\u271d\u00b9\u2074 : TopologicalSpace E\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Nonempty \u03b9\nt : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Nonempty \u03b9\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : NormedField \ud835\udd5d\ninst\u271d\u2076 : Module \ud835\udd5d E\ninst\u271d\u2075 : NormedField \ud835\udd5d\u2082\n\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082\ninst\u271d\u2074 : RingHomIsometric \u03c4\u2081\u2082\ninst\u271d\u00b3 : Nonempty \u03b9\nF : Type u_10\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5d\u2082 F\ninst\u271d : TopologicalSpace E\np : \u03b9 \u2192 Seminorm \ud835\udd5d E\nhp : WithSeminorms p\nf : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F\nhf : \u2203 s C, (normSeminorm \ud835\udd5d\u2082 F).comp f \u2264 C \u2022 s.sup p\n\u22a2 Continuous \u21d1f"}, {"line": "rw [\u2190 Seminorm.isBounded_const (Fin 1)] at hf", "tactic_state": "\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nE : Type u_5\n\u03b9 : Type u_8\ninst\u271d\u00b2\u00b2 : AddCommGroup E\ninst\u271d\u00b2\u00b9 : Nonempty \u03b9\ninst\u271d\u00b2\u2070 inst\u271d\u00b9\u2079 : AddCommGroup E\ninst\u271d\u00b9\u2078 : Nonempty \u03b9\ninst\u271d\u00b9\u2077 : TopologicalSpace E\ninst\u271d\u00b9\u2076 : AddCommGroup E\ninst\u271d\u00b9\u2075 : Nonempty \u03b9\ninst\u271d\u00b9\u2074 : TopologicalSpace E\ninst\u271d\u00b9\u00b3 : AddCommGroup E\ninst\u271d\u00b9\u00b2 : Nonempty \u03b9\nt : TopologicalSpace E\ninst\u271d\u00b9\u00b9 : AddCommGroup E\ninst\u271d\u00b9\u2070 : Nonempty \u03b9\ninst\u271d\u2079 : TopologicalSpace E\ninst\u271d\u2078 : AddCommGroup E\ninst\u271d\u2077 : NormedField \ud835\udd5d\ninst\u271d\u2076 : Module \ud835\udd5d E\ninst\u271d\u2075 : NormedField \ud835\udd5d\u2082\n\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082\ninst\u271d\u2074 : RingHomIsometric \u03c4\u2081\u2082\ninst\u271d\u00b3 : Nonempty \u03b9\nF : Type u_10\ninst\u271d\u00b2 : SeminormedAddCommGroup F\ninst\u271d\u00b9 : NormedSpace \ud835\udd5d\u2082 F\ninst\u271d : TopologicalSpace E\np : \u03b9 \u2192 Seminorm \ud835\udd5d E\nhp : WithSeminorms p\nf : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F\nhf : Seminorm.IsBounded p (fun x => normSeminorm \ud835\udd5d\u2082 F) f\n\u22a2 Continuous \u21d1f"}, {"line": "exact continuous_from_bounded hp (norm_withSeminorms \ud835\udd5d\u2082 F) f hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cont_normedSpace_to_withSeminorms (E) [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5d E]\n    [TopologicalSpace F] {q : \u03b9 \u2192 Seminorm \ud835\udd5d\u2082 F} (hq : WithSeminorms q)\n    (f : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F) (hf : \u2200 i : \u03b9, \u2203 C : \u211d\u22650, (q i).comp f \u2264 C \u2022 normSeminorm \ud835\udd5d E) :\n    Continuous f := by\n  rw [\u2190 Seminorm.const_isBounded (Fin 1)] at hf\n  exact continuous_from_bounded (norm_withSeminorms \ud835\udd5d E) hq f hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/LocallyConvex/WithSeminorms.lean", "context": {"open": ["NormedField Set Seminorm TopologicalSpace Filter List", "NNReal Pointwise Topology Uniformity"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5d \ud835\udd5d\u2082 E F G \u03b9 \u03b9' : Type*}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "(\ud835\udd5c E \u03b9)", "{\ud835\udd5c E \u03b9}", "(p : SeminormFamily \ud835\udd5c E \u03b9)", "[Nonempty \u03b9]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[NormedField \ud835\udd5c\u2082] [AddCommGroup F] [Module \ud835\udd5c\u2082 F]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9]", "[TopologicalSpace E]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9] [TopologicalSpace E]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[SemilatticeSup F] [Nonempty F]", "[NormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[Nonempty \u03b9]", "[t : TopologicalSpace E]", "[NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E] [Nonempty \u03b9]", "{p : SeminormFamily \ud835\udd5c E \u03b9}", "[TopologicalSpace E]", "[NontriviallyNormedField \ud835\udd5c] [AddCommGroup E] [Module \ud835\udd5c E]", "[NormedField \ud835\udd5d] [Module \ud835\udd5d E]", "[NontriviallyNormedField \ud835\udd5c\u2082] [AddCommGroup F] [Module \ud835\udd5c\u2082 F]", "[NormedField \ud835\udd5d\u2082] [Module \ud835\udd5d\u2082 F]", "{\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082} [RingHomIsometric \u03c3\u2081\u2082]", "{\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082} [RingHomIsometric \u03c4\u2081\u2082]", "[Nonempty \u03b9] [Nonempty \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nF : Type u_6\n\u03b9 : Type u_8\ninst\u271d\u00b9\u2076 : Nonempty \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup F\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : Nonempty \u03b9\ninst\u271d\u00b9\u00b2 : SemilatticeSup F\ninst\u271d\u00b9\u00b9 : Nonempty F\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Nonempty \u03b9\ninst\u271d\u2078 : NormedField \ud835\udd5d\ninst\u271d\u2077 : AddCommGroup F\ninst\u271d\u2076 : NormedField \ud835\udd5d\u2082\ninst\u271d\u2075 : Module \ud835\udd5d\u2082 F\n\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082\ninst\u271d\u2074 : RingHomIsometric \u03c4\u2081\u2082\ninst\u271d\u00b3 : Nonempty \u03b9\nE : Type u_10\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5d E\ninst\u271d : TopologicalSpace F\nq : \u03b9 \u2192 Seminorm \ud835\udd5d\u2082 F\nhq : WithSeminorms q\nf : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F\nhf : \u2200 (i : \u03b9), \u2203 C, (q i).comp f \u2264 C \u2022 normSeminorm \ud835\udd5d E\n\u22a2 Continuous \u21d1f"}, {"line": "rw [\u2190 Seminorm.const_isBounded (Fin 1)] at hf", "tactic_state": "\ud835\udd5d : Type u_3\n\ud835\udd5d\u2082 : Type u_4\nF : Type u_6\n\u03b9 : Type u_8\ninst\u271d\u00b9\u2076 : Nonempty \u03b9\ninst\u271d\u00b9\u2075 : AddCommGroup F\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : Nonempty \u03b9\ninst\u271d\u00b9\u00b2 : SemilatticeSup F\ninst\u271d\u00b9\u00b9 : Nonempty F\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : Nonempty \u03b9\ninst\u271d\u2078 : NormedField \ud835\udd5d\ninst\u271d\u2077 : AddCommGroup F\ninst\u271d\u2076 : NormedField \ud835\udd5d\u2082\ninst\u271d\u2075 : Module \ud835\udd5d\u2082 F\n\u03c4\u2081\u2082 : \ud835\udd5d \u2192+* \ud835\udd5d\u2082\ninst\u271d\u2074 : RingHomIsometric \u03c4\u2081\u2082\ninst\u271d\u00b3 : Nonempty \u03b9\nE : Type u_10\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5d E\ninst\u271d : TopologicalSpace F\nq : \u03b9 \u2192 Seminorm \ud835\udd5d\u2082 F\nhq : WithSeminorms q\nf : E \u2192\u209b\u2097[\u03c4\u2081\u2082] F\nhf : Seminorm.IsBounded (fun x => normSeminorm \ud835\udd5d E) q f\n\u22a2 Continuous \u21d1f"}, {"line": "exact continuous_from_bounded (norm_withSeminorms \ud835\udd5d E) hq f hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma divisor_apply {f : \ud835\udd5c \u2192 E} (hf : MeromorphicOn f U) (hz : z \u2208 U) :\n    divisor f U z = (hf z hz).order.untop\u2080 := by simp_all [MeromorphicOn.divisor_def, hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Meromorphic/Divisor.lean", "context": {"open": ["Filter Topology", "Classical in", "Classical in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {U : Set \ud835\udd5c} {z : \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\nU : Set \ud835\udd5c\nz : \ud835\udd5c\nx\u271d : Sort u_3\ndivisor : x\u271d\nf : \ud835\udd5c \u2192 E\nhf : sorry\nhz : z \u2208 U\n\u22a2 sorry = sorry"}, {"line": "simp_all [MeromorphicOn.divisor_def, hz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticAt.meromorphicNFAt (hf : AnalyticAt \ud835\udd5c f x) :\n    MeromorphicNFAt f x := by\n  simp [meromorphicNFAt_iff_analyticAt_or, hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Meromorphic/NormalForm.lean", "context": {"open": ["Topology WithTop"], "variables": ["", "(f x) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : ?m.37 \u2192 ?m.34\nx : ?m.37\n\ud835\udd5c : Type u_1\nhf : sorry\n\u22a2 MeromorphicNFAt f x"}, {"line": "simp [meromorphicNFAt_iff_analyticAt_or, hf]", "tactic_state": "f : ?m.37 \u2192 ?m.34\nx : ?m.37\n\ud835\udd5c : Type u_1\nhf : sorry\n\u22a2 AnalyticAt ?m.37 f x \u2228 (\u2203 (x_1 : MeromorphicAt f x), x_1.order < 0) \u2227 f x = 0"}]}
{"declaration": "theorem eventually_analyticAt_or_mem_compl {f : \ud835\udd5c \u2192 E} {x : \ud835\udd5c}\n    (h : MeromorphicOn f U) (hx : x \u2208 U) : \u2200\u1da0 y in \ud835\udcdd[\u2260] x, AnalyticAt \ud835\udd5c f y \u2228 y \u2208 U\u1d9c := by\n  have : {x}\u1d9c = (U \\ {x}) \u222a U\u1d9c := by aesop (add simp Classical.em)\n  rw [this]\n  rw [nhdsWithin_union]\n  simp only [mem_compl_iff]\n  simp only [eventually_sup]\n  refine \u27e8?_, ?_\u27e9\n  \u00b7 filter_upwards [h.eventually_analyticAt hx] with y hy using Or.inl hy\n  \u00b7 filter_upwards [self_mem_nhdsWithin] with y hy using Or.inr hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Meromorphic/Order.lean", "context": {"open": ["Filter Set WithTop.LinearOrderedAddCommGroup", "scoped Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{U : Set \ud835\udd5c} (hf : MeromorphicOn f U)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, sorry \u2228 y \u2208 U\u1d9c"}, {"line": "have : {x}\u1d9c = (U \\ {x}) \u222a U\u1d9c := by aesop (add simp Classical.em)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x {x}\u1d9c, sorry \u2228 y \u2208 U\u1d9c"}, {"line": "rw [this]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x (U \\ {x} \u222a U\u1d9c), sorry \u2228 y \u2208 U\u1d9c"}, {"line": "rw [nhdsWithin_union]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x (U \\ {x}) \u2294 nhdsWithin x U\u1d9c, sorry \u2228 y \u2208 U\u1d9c"}, {"line": "simp only [mem_compl_iff]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x (U \\ {x}) \u2294 nhdsWithin x U\u1d9c, sorry \u2228 y \u2209 U"}, {"line": "simp only [eventually_sup]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 (\u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x (U \\ {x}), sorry \u2228 y \u2209 U) \u2227 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x U\u1d9c, sorry \u2228 y \u2209 U"}, {"line": "refine \u27e8?_, ?_\u27e9", "tactic_state": "case refine_1\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x (U \\ {x}), sorry \u2228 y \u2209 U\n---\ncase refine_2\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x U\u1d9c, sorry \u2228 y \u2209 U"}, {"line": "\u00b7 filter_upwards [h.eventually_analyticAt hx] with y hy using Or.inl hy", "tactic_state": "case refine_2\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\nU : Set \ud835\udd5c\nf : \ud835\udd5c \u2192 E\nx : \ud835\udd5c\nh : sorry\nhx : x \u2208 U\nthis : {x}\u1d9c = U \\ {x} \u222a U\u1d9c\n\u22a2 \u2200\u1da0 (y : \ud835\udd5c) in nhdsWithin x U\u1d9c, sorry \u2228 y \u2209 U"}, {"line": "\u00b7 filter_upwards [self_mem_nhdsWithin] with y hy using Or.inr hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_smul_le (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016 \u2264 \u2016r\u2016 * \u2016x\u2016 := by\n  simpa [smul_zero] using dist_smul_pair r 0 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/MulAction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[SeminormedAddGroup \u03b1] [SeminormedAddGroup \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[IsBoundedSMul \u03b1 \u03b2] {r : \u03b1} {x : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : SeminormedAddGroup \u03b1\ninst\u271d\u00b2 : SeminormedAddGroup \u03b2\ninst\u271d\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\nr : \u03b1\nx : \u03b2\n\u22a2 \u2016r \u2022 x\u2016 \u2264 \u2016r\u2016 * \u2016x\u2016"}, {"line": "simpa [smul_zero] using dist_smul_pair r 0 x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_smul_le (s : \u03b1) (x y : \u03b2) : dist (s \u2022 x) (s \u2022 y) \u2264 \u2016s\u2016 * dist x y := by\n  simpa only [dist_eq_norm,sub_zero] using dist_smul_pair s x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/MulAction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[SeminormedAddGroup \u03b1] [SeminormedAddGroup \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[IsBoundedSMul \u03b1 \u03b2] {r : \u03b1} {x : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : SeminormedAddGroup \u03b1\ninst\u271d\u00b2 : SeminormedAddGroup \u03b2\ninst\u271d\u00b9 : SMulZeroClass \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\ns : \u03b1\nx y : \u03b2\n\u22a2 dist (s \u2022 x) (s \u2022 y) \u2264 \u2016s\u2016 * dist x y"}, {"line": "simpa only [dist_eq_norm,sub_zero] using dist_smul_pair s x y", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_smul (r : \u03b1) (x : \u03b2) : \u2016r \u2022 x\u2016\u2091 = \u2016r\u2016\u2091 * \u2016x\u2016\u2091 := by simp [enorm, nnnorm_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/MulAction.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[SeminormedAddGroup \u03b1] [SeminormedAddGroup \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[IsBoundedSMul \u03b1 \u03b2] {r : \u03b1} {x : \u03b2}", "[SeminormedRing \u03b1] [SeminormedAddCommGroup \u03b2] [Module \u03b1 \u03b2]", "[NormedDivisionRing \u03b1] [SeminormedAddGroup \u03b2]", "[MulActionWithZero \u03b1 \u03b2] [IsBoundedSMul \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2070 : SeminormedAddGroup \u03b1\ninst\u271d\u2079 : SeminormedAddGroup \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : IsBoundedSMul \u03b1 \u03b2\ninst\u271d\u2076 : SeminormedRing \u03b1\ninst\u271d\u2075 : SeminormedAddCommGroup \u03b2\ninst\u271d\u2074 : Module \u03b1 \u03b2\ninst\u271d\u00b3 : NormedDivisionRing \u03b1\ninst\u271d\u00b2 : SeminormedAddGroup \u03b2\ninst\u271d\u00b9 : MulActionWithZero \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\nr : \u03b1\nx : \u03b2\n\u22a2 \u2016r \u2022 x\u2016\u2091 = \u2016r\u2016\u2091 * \u2016x\u2016\u2091"}, {"line": "simp [enorm, nnnorm_smul]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2070 : SeminormedAddGroup \u03b1\ninst\u271d\u2079 : SeminormedAddGroup \u03b2\ninst\u271d\u2078 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u2077 : IsBoundedSMul \u03b1 \u03b2\ninst\u271d\u2076 : SeminormedRing \u03b1\ninst\u271d\u2075 : SeminormedAddCommGroup \u03b2\ninst\u271d\u2074 : Module \u03b1 \u03b2\ninst\u271d\u00b3 : NormedDivisionRing \u03b1\ninst\u271d\u00b2 : SeminormedAddGroup \u03b2\ninst\u271d\u00b9 : MulActionWithZero \u03b1 \u03b2\ninst\u271d : IsBoundedSMul \u03b1 \u03b2\nr : \u03b1\nx : \u03b2\n\u22a2 \u2191\u2016r \u2022 x\u2016\u208a = \u2191\u2016r\u2016\u208a * \u2191\u2016x\u2016\u208a"}]}
{"declaration": "theorem Wbtw.dist_add_dist {x y z : P} (h : Wbtw \u211d x y z) :\n    dist x y + dist y z = dist x z := by\n  obtain \u27e8a, \u27e8ha\u2080, ha\u2081\u27e9, rfl\u27e9 := h\n  simp [abs_of_nonneg, ha\u2080, ha\u2081, sub_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/Convex.lean", "context": {"open": ["AffineBasis Module Metric Set", "scoped Convex Pointwise Topology"], "variables": ["{E P : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E] [PseudoMetricSpace P] [NormedAddTorsor E P]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor E P\nx y z : P\nh : Wbtw \u211d x y z\n\u22a2 dist x y + dist y z = dist x z"}, {"line": "obtain \u27e8a, \u27e8ha\u2080, ha\u2081\u27e9, rfl\u27e9 := h", "tactic_state": "case intro.intro.intro\nE : Type u_1\nP : Type u_2\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor E P\nx z : P\na : \u211d\nha\u2080 : 0 \u2264 a\nha\u2081 : a \u2264 1\n\u22a2 dist x ((AffineMap.lineMap x z) a) + dist ((AffineMap.lineMap x z) a) z = dist x z"}, {"line": "simp [abs_of_nonneg, ha\u2080, ha\u2081, sub_mul]", "tactic_state": "No Goals!"}]}
