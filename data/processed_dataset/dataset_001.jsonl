{"declaration": "theorem mem_zmod_2 (a : ZMod 2) : a = 0 \u2228 a = 1 := by\n  rcases a with \u27e8_ | _, _ | _ | _ | _\u27e9\n  \u00b7 exact Or.inl rfl\n  \u00b7 exact Or.inr rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/CanonicallyOrderedCommSemiringTwoMul.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : ZMod 2\n\u22a2 a = 0 \u2228 a = 1"}, {"line": "rcases a with \u27e8_ | _, _ | _ | _ | _\u27e9", "tactic_state": "case mk.zero.step.refl\n\u22a2 \u27e80, \u22ef\u27e9 = 0 \u2228 \u27e80, \u22ef\u27e9 = 1\n---\ncase mk.succ.refl\n\u22a2 \u27e80 + 1, \u22ef\u27e9 = 0 \u2228 \u27e80 + 1, \u22ef\u27e9 = 1"}, {"line": "\u00b7 exact Or.inl rfl", "tactic_state": "case mk.succ.refl\n\u22a2 \u27e80 + 1, \u22ef\u27e9 = 0 \u2228 \u27e80 + 1, \u22ef\u27e9 = 1"}, {"line": "\u00b7 exact Or.inr rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClopen_Iio (a : \u211d\u2097) : IsClopen (Iio a) := by\n  simpa only [compl_Ici] using (isClopen_Ici a).compl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\na : \u211d\u2097\n\u22a2 sorry"}, {"line": "simpa only [compl_Ici] using (isClopen_Ici a).compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_prod_antitone_basis_inv_pnat (x y : \u211d\u2097) :\n    (\ud835\udcdd (x, y)).HasAntitoneBasis fun n : \u2115+ => Ico x (x + (n : \u211d\u2097)\u207b\u00b9) \u00d7\u02e2 Ico y (y + (n : \u211d\u2097)\u207b\u00b9) := by\n  rw [nhds_prod_eq]\n  exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine", "Subtype in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\nx y : \u211d\u2097\n\u22a2 (nhds (x, y)).HasAntitoneBasis fun n => sorry \u00d7\u02e2 sorry"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "\u211d\u2097 : Type u_1\nx y : \u211d\u2097\n\u22a2 (nhds x \u00d7\u02e2 nhds y).HasAntitoneBasis fun n => sorry \u00d7\u02e2 sorry\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097"}, {"line": "exact (nhds_antitone_basis_Ico_inv_pnat x).prod (nhds_antitone_basis_Ico_inv_pnat y)", "tactic_state": "\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097\n---\n\u22a2 {\u211d\u2097 : Type u_1} \u2192 \u211d\u2097 \u2192 \u211d\u2097 \u2192 TopologicalSpace \u211d\u2097"}]}
{"declaration": "theorem not_metrizableSpace : \u00acMetrizableSpace \u211d\u2097 := by\n  intro\n  letI := metrizableSpaceMetric \u211d\u2097\n  exact not_normalSpace_prod inferInstance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/SorgenfreyLine.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Topology Filter Cardinal", "scoped SorgenfreyLine", "Subtype in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u211d\u2097 : Type u_1\n\u22a2 \u00acsorry"}, {"line": "intro", "tactic_state": "\u211d\u2097 : Type u_1\na\u271d : sorry\n\u22a2 False"}, {"line": "letI := metrizableSpaceMetric \u211d\u2097", "tactic_state": "\u211d\u2097 : Type u_1\na\u271d : sorry\nthis : MetricSpace \u211d\u2097 := sorry\n\u22a2 False"}, {"line": "exact not_normalSpace_prod inferInstance", "tactic_state": "No Goals!"}]}
{"declaration": "example : AddRightMono F := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : LinearOrder F := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 LinearOrder F"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : AddMonoid F := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/ZeroDivisorsInAddMonoidAlgebras.lean", "context": {"open": ["Finsupp hiding single", "AddMonoidAlgebra", "Lean Elab Command in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\n\u22a2 AddMonoid F"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma no_strictly_decreasing {\u03b1 : Type*} [Preorder \u03b1] [WellFoundedLT \u03b1] (f : \u2115 \u2192 \u03b1) {n\u2080 : \u2115}\n    (hf : \u2200 n \u2265 n\u2080, f (n + 1) < f n) : False := by\n  let g (n : \u2115) : \u03b1 := f (n\u2080 + n)\n  have : (\u00b7 > \u00b7) \u21aar (\u00b7 < \u00b7) := RelEmbedding.natGT g (fun n \u21a6 hf _ (by simp))\n  exact this.not_wellFounded_of_decreasing_seq wellFounded_lt\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/AharoniKorman.lean", "context": {"open": ["Hollom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\n\u22a2 False"}, {"line": "let g (n : \u2115) : \u03b1 := f (n\u2080 + n)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\ng : \u2115 \u2192 \u03b1 := fun n => f (n\u2080 + n)\n\u22a2 False"}, {"line": "have : (\u00b7 > \u00b7) \u21aar (\u00b7 < \u00b7) := RelEmbedding.natGT g (fun n \u21a6 hf _ (by simp))", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : WellFoundedLT \u03b1\nf : \u2115 \u2192 \u03b1\nn\u2080 : \u2115\nhf : \u2200 n \u2265 n\u2080, f (n + 1) < f n\ng : \u2115 \u2192 \u03b1 := fun n => f (n\u2080 + n)\nthis : (fun x1 x2 => x1 > x2) \u21aar fun x1 x2 => x1 < x2\n\u22a2 False"}, {"line": "exact this.not_wellFounded_of_decreasing_seq wellFounded_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Q'_apply (a : Fin 3 \u2192 K) : Q' a = a 0 * a 0 + a 1 * a 1 + a 2 * a 2 :=\n  calc\n    Q' a = a 0 * a 0 + (a 1 * a 1 + (a 2 * a 2 + 0)) := rfl\n    _ = _ := by ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/CliffordAlgebraNotInjective.lean", "context": {"open": ["LinearMap (BilinForm)", "LinearMap (BilinMap)", "MvPolynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nx\u271d : Sort u_2\nQ' : x\u271d\na : Fin 3 \u2192 K\n\u22a2 Function.const Lean.Name () `7.4.7.52.4.52._sorry._@._hyg.82 =\n    Function.const Lean.Name () `5.35.5.75.35.75._sorry._@._hyg.48"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UnitsInt.one_ne_neg_one : (1 : \u2124\u02e3) \u2260 -1 := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/DirectSumIsInternal.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 \u2260 -1"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_range_fundamentalEntourage (S : Set (\u2115 \u00d7 \u2115)) :\n    S \u2208 (range fundamentalEntourage) \u2194 \u2203 n, fundamentalEntourage n = S := by\n  simp only [Set.mem_range, Eq.symm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/DiscreteTopologyNonDiscreteUniformity.lean", "context": {"open": ["Set Function Filter Metric"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u271d : Sort u_1\nfundamentalEntourage : \u03b9\u271d \u2192 Set (\u2115 \u00d7 \u2115)\nS : Set (\u2115 \u00d7 \u2115)\n\u22a2 S \u2208 range fundamentalEntourage \u2194 \u2203 n, fundamentalEntourage n = S"}, {"line": "simp only [Set.mem_range, Eq.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cyclotomic_3 : cyclotomic 3 \u2124 = 1 + X + X ^ 2 := by\n  simp only [cyclotomic_prime, sum_range_succ, range_one, sum_singleton, pow_zero, pow_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/Cyclotomic105.lean", "context": {"open": ["Nat (properDivisors)", "Finset", "Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cyclotomic 3 \u2124 = 1 + X + X ^ 2"}, {"line": "simp only [cyclotomic_prime, sum_range_succ, range_one, sum_singleton, pow_zero, pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "example : CompleteSpace (DiscreteCopy \u211d \u2192\u1d47 \u211d) := by infer_instance\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/Phillips.lean", "context": {"open": ["Set BoundedContinuousFunction MeasureTheory", "Cardinal (aleph)", "scoped Cardinal BoundedContinuousFunction", "BoundedAdditiveMeasure"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nDiscreteCopy : x\u271d\n\u22a2 CompleteSpace (BoundedContinuousFunction sorry \u211d)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem star'_mul_star_lf : star' * star \u29cf star := by\n  rw [lf_iff_exists_le]\n  refine Or.inr \u27e8toRightMovesMul (Sum.inr \u27e8\u27e81, Nat.one_lt_two\u27e9, default\u27e9), ?_\u27e9\n  rw [mul_moveRight_inr, le_iff_game_le]\n  simp [star']\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Counterexamples/GameMultiplication.lean", "context": {"open": ["SetTheory PGame"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "star' : PGame\n\u22a2 (star' * PGame.star).LF PGame.star"}, {"line": "rw [lf_iff_exists_le]", "tactic_state": "star' : PGame\n\u22a2 (\u2203 i, star' * PGame.star \u2264 PGame.star.moveLeft i) \u2228 \u2203 j, (star' * PGame.star).moveRight j \u2264 PGame.star"}, {"line": "refine Or.inr \u27e8toRightMovesMul (Sum.inr \u27e8\u27e81, Nat.one_lt_two\u27e9, default\u27e9), ?_\u27e9", "tactic_state": "star' : PGame\n\u22a2 (star' * PGame.star).moveRight (toRightMovesMul (Sum.inr (sorry, default))) \u2264 PGame.star"}, {"line": "rw [mul_moveRight_inr, le_iff_game_le]", "tactic_state": "star' : PGame\n\u22a2 \u27e6star'.moveRight sorry * PGame.star + star' * PGame.star.moveLeft default -\n        star'.moveRight sorry * PGame.star.moveLeft default\u27e7 \u2264\n    \u27e6PGame.star\u27e7"}, {"line": "simp [star']", "tactic_state": "star' : PGame\n\u22a2 \u27e6star'.moveRight (sorry ()) * PGame.star\u27e7 \u2264 \u27e6PGame.star\u27e7"}]}
{"declaration": "theorem card : card (Q n) = 2 ^ n := by simp [Q]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Sensitivity.lean", "context": {"open": ["Bool Finset Fintype Function LinearMap Module Module.DualBases"], "variables": ["(n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nQ : x\u271d\n\u22a2 sorry = 2 ^ n"}, {"line": "simp [Q]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nQ : x\u271d\n\u22a2 sorry () = 2 ^ n"}]}
{"declaration": "protected theorem StateEqRs.refl (t : Register) (\u03b6 : State) : \u03b6 \u2243[t]/ac \u03b6 := by simp [StateEqRs]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6 : State\n\u22a2 sorry \u2243 [t] / sorry"}, {"line": "simp [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6 : State\n\u22a2 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "protected theorem StateEqRs.symm {t : Register} (\u03b6\u2081 \u03b6\u2082 : State) :\n    \u03b6\u2081 \u2243[t]/ac \u03b6\u2082 \u2192 \u03b6\u2082 \u2243[t]/ac \u03b6\u2081 := by\n  simp_all [StateEqRs]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 : State\n\u22a2 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry"}, {"line": "simp_all [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 : State\n\u22a2 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "protected theorem StateEqRs.trans {t : Register} (\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State) :\n    \u03b6\u2081 \u2243[t]/ac \u03b6\u2082 \u2192 \u03b6\u2082 \u2243[t]/ac \u03b6\u2083 \u2192 \u03b6\u2081 \u2243[t]/ac \u03b6\u2083 := by\n  simp_all [StateEqRs]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Arithcc.lean", "context": {"open": ["Instruction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State\n\u22a2 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry \u2192 sorry \u2243 [t] / sorry"}, {"line": "simp_all [StateEqRs]", "tactic_state": "Register : Type u_1\nState : Sort u_2\nx\u271d : Sort u_3\nac : x\u271d\nt : Register\n\u03b6\u2081 \u03b6\u2082 \u03b6\u2083 : State\n\u22a2 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry () \u2192 sorry () \u2243 [t] / sorry ()"}]}
{"declaration": "theorem existsPolitician_of_degree_le_two (hd : G.IsRegularOfDegree d) (h : d \u2264 2) :\n    ExistsPolitician G := by\n  interval_cases d\n  iterate 2 apply existsPolitician_of_degree_le_one hG hd; norm_num\n  exact existsPolitician_of_degree_eq_two hG hd\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/FriendshipGraphs.lean", "context": {"open": ["Finset SimpleGraph Matrix", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{V : Type u} {R : Type v} [Semiring R]", "(G : SimpleGraph V)", "[Fintype V] {G : SimpleGraph V} {d : \u2115} (hG : Friendship G)", "(R)", "{R}", "[Nonempty V]", "[Nonempty V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : d \u2264 2\n\u22a2 sorry"}, {"line": "interval_cases d", "tactic_state": "case \u00ab0\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 0 \u2264 2\n\u22a2 sorry\n---\ncase \u00ab1\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 1 \u2264 2\n\u22a2 sorry\n---\ncase \u00ab2\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 2 \u2264 2\n\u22a2 sorry"}, {"line": "iterate 2 apply existsPolitician_of_degree_le_one hG hd; norm_num", "tactic_state": "case \u00ab2\u00bb\nV : Type ?u.2289\nFriendship : ?m.2286\nG\u271d : SimpleGraph V\ninst\u271d\u00b2 : Fintype V\nG : SimpleGraph V\nd\u271d : \u2115\nhG : sorry\nR : ?m.2716 G\u271d hG\ninst\u271d\u00b9 inst\u271d : Nonempty V\nd : \u2115\nx\u271d : Sort u_1\nExistsPolitician : x\u271d\nhd : sorry\nh : 2 \u2264 2\n\u22a2 sorry ()"}, {"line": "exact existsPolitician_of_degree_eq_two hG hd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intervalIntegrable_min_const_sin_mul (a b : \u211d) :\n    IntervalIntegrable (fun (\u03b8 : \u211d) => min d (\u03b8.sin * l)) \u2119 a b := by\n  apply Continuous.intervalIntegrable\n  exact Continuous.min continuous_const (Continuous.mul Real.continuous_sin continuous_const)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BuffonsNeedle.lean", "context": {"open": ["MeasureTheory (MeasureSpace IsProbabilityMeasure Measure pdf.IsUniform)", "ProbabilityTheory Real"], "variables": [""]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d l a b : \u211d\n\u22a2 IntervalIntegrable (fun \u03b8 => min d (sin \u03b8 * l)) MeasureTheory.volume a b"}, {"line": "apply Continuous.intervalIntegrable", "tactic_state": "case hu\nd l a b : \u211d\n\u22a2 Continuous fun \u03b8 => min d (sin \u03b8 * l)"}, {"line": "exact Continuous.min continuous_const (Continuous.mul Real.continuous_sin continuous_const)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_two_pow_eq_mersenne_succ (k : \u2115) : \u03c3 1 (2 ^ k) = mersenne (k + 1) := by\n  simp_rw [sigma_one_apply, mersenne, show 2 = 1 + 1 from rfl, \u2190 geom_sum_mul_add 1 (k + 1)]\n  norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 (sigma 1) (2 ^ k) = mersenne (k + 1)"}, {"line": "simp_rw [sigma_one_apply, mersenne, show 2 = 1 + 1 from rfl, \u2190 geom_sum_mul_add 1 (k + 1)]", "tactic_state": "k : \u2115\n\u22a2 \u2211 x \u2208 ((1 + 1) ^ k).divisors, x = (\u2211 i \u2208 range (k + 1), (1 + 1) ^ i) * 1 + 1 - 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem even_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).Prime) :\n    Even (2 ^ k * mersenne (k + 1)) := by simp [ne_zero_of_prime_mersenne k pr, parity_simps]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\n\u22a2 Even (2 ^ k * mersenne (k + 1))"}, {"line": "simp [ne_zero_of_prime_mersenne k pr, parity_simps]", "tactic_state": "k : \u2115\npr : Nat.Prime (mersenne (k + 1))\n\u22a2 \u00ack = 0 \u2228 Even (mersenne (k + 1))"}]}
{"declaration": "theorem eq_two_pow_mul_odd {n : \u2115} (hpos : 0 < n) : \u2203 k m : \u2115, n = 2 ^ k * m \u2227 \u00acEven m := by\n  have h := Nat.finiteMultiplicity_iff.2 \u27e8Nat.prime_two.ne_one, hpos\u27e9\n  obtain \u27e8m, hm\u27e9 := pow_multiplicity_dvd 2 n\n  use multiplicity 2 n, m\n  refine \u27e8hm, ?_\u27e9\n  rw [even_iff_two_dvd]\n  have hg := h.not_pow_dvd_of_multiplicity_lt (Nat.lt_succ_self _)\n  contrapose! hg\n  rcases hg with \u27e8k, rfl\u27e9\n  apply Dvd.intro k\n  rw [pow_succ, mul_assoc, \u2190 hm]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/PerfectNumbers.lean", "context": {"open": ["ArithmeticFunction Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhpos : 0 < n\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "have h := Nat.finiteMultiplicity_iff.2 \u27e8Nat.prime_two.ne_one, hpos\u27e9", "tactic_state": "n : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "obtain \u27e8m, hm\u27e9 := pow_multiplicity_dvd 2 n", "tactic_state": "case intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u2203 k m, n = 2 ^ k * m \u2227 \u00acEven m"}, {"line": "use multiplicity 2 n, m", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 n = 2 ^ multiplicity 2 n * m \u2227 \u00acEven m"}, {"line": "refine \u27e8hm, ?_\u27e9", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u00acEven m"}, {"line": "rw [even_iff_two_dvd]", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\n\u22a2 \u00ac2 \u2223 m"}, {"line": "have hg := h.not_pow_dvd_of_multiplicity_lt (Nat.lt_succ_self _)", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\nhg : \u00ac2 ^ (multiplicity 2 n).succ \u2223 n\n\u22a2 \u00ac2 \u2223 m"}, {"line": "contrapose! hg", "tactic_state": "case h\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nm : \u2115\nhm : n = 2 ^ multiplicity 2 n * m\nhg : 2 \u2223 m\n\u22a2 2 ^ (multiplicity 2 n).succ \u2223 n"}, {"line": "rcases hg with \u27e8k, rfl\u27e9", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ (multiplicity 2 n).succ \u2223 n"}, {"line": "apply Dvd.intro k", "tactic_state": "case h.intro\nn : \u2115\nhpos : 0 < n\nh : FiniteMultiplicity 2 n\nk : \u2115\nhm : n = 2 ^ multiplicity 2 n * (2 * k)\n\u22a2 2 ^ (multiplicity 2 n).succ * k = n"}, {"line": "rw [pow_succ, mul_assoc, \u2190 hm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ico_lemma {\u03b1} [LinearOrder \u03b1] {x\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1} (h\u2081 : x\u2081 < y\u2081) (hy : y\u2081 < y\u2082)\n    (h\u2082 : y\u2082 < x\u2082) (hz\u2081 : z\u2081 \u2264 y\u2082) (hz\u2082 : y\u2081 \u2264 z\u2082) (hw : w \u2209 Ico y\u2081 y\u2082 \u2227 w \u2208 Ico z\u2081 z\u2082) :\n    \u2203 w, w \u2208 Ico x\u2081 x\u2082 \u2227 w \u2209 Ico y\u2081 y\u2082 \u2227 w \u2208 Ico z\u2081 z\u2082 := by\n  simp only [not_and, not_lt, mem_Ico] at hw\n  refine \u27e8max x\u2081 (min w y\u2082), ?_, ?_, ?_\u27e9\n  \u00b7 simp [le_refl, lt_trans h\u2081 (lt_trans hy h\u2082), h\u2082]\n  \u00b7 simp +contextual [hw, lt_irrefl, not_le_of_lt h\u2081]\n  \u00b7 simp [hw.2.1, hw.2.2, hz\u2081, lt_of_lt_of_le h\u2081 hz\u2082]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : w \u2209 Ico y\u2081 y\u2082 \u2227 w \u2208 Ico z\u2081 z\u2082\n\u22a2 \u2203 w \u2208 Ico x\u2081 x\u2082, w \u2209 Ico y\u2081 y\u2082 \u2227 w \u2208 Ico z\u2081 z\u2082"}, {"line": "simp only [not_and, not_lt, mem_Ico] at hw", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 \u2203 w \u2208 Ico x\u2081 x\u2082, w \u2209 Ico y\u2081 y\u2082 \u2227 w \u2208 Ico z\u2081 z\u2082"}, {"line": "refine \u27e8max x\u2081 (min w y\u2082), ?_, ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2208 Ico x\u2081 x\u2082\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2209 Ico y\u2081 y\u2082\n---\ncase refine_3\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2208 Ico z\u2081 z\u2082"}, {"line": "\u00b7 simp [le_refl, lt_trans h\u2081 (lt_trans hy h\u2082), h\u2082]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2209 Ico y\u2081 y\u2082\n---\ncase refine_3\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2208 Ico z\u2081 z\u2082"}, {"line": "\u00b7 simp +contextual [hw, lt_irrefl, not_le_of_lt h\u2081]", "tactic_state": "case refine_3\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nx\u2081 x\u2082 y\u2081 y\u2082 z\u2081 z\u2082 w : \u03b1\nh\u2081 : x\u2081 < y\u2081\nhy : y\u2081 < y\u2082\nh\u2082 : y\u2082 < x\u2082\nhz\u2081 : z\u2081 \u2264 y\u2082\nhz\u2082 : y\u2081 \u2264 z\u2082\nhw : (y\u2081 \u2264 w \u2192 y\u2082 \u2264 w) \u2227 z\u2081 \u2264 w \u2227 w < z\u2082\n\u22a2 sorry \u2208 Ico z\u2081 z\u2082"}, {"line": "\u00b7 simp [hw.2.1, hw.2.2, hz\u2081, lt_of_lt_of_le h\u2081 hz\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem b_mem_side (c : Cube n) (j : Fin n) : c.b j \u2208 c.side j := by simp [side, Cube.hw, le_refl]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nCube : x\u271d\nc : sorry\nj : Fin n\n\u22a2 sorry \u2208 sorry"}, {"line": "simp [side, Cube.hw, le_refl]", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nCube : x\u271d\nc : sorry\nj : Fin n\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem side_nonempty (c : Cube n) (i : Fin n) : (side c i).Nonempty := by simp [side, c.hw]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nCube : x\u271d\u00b9\nx\u271d : Sort u_2\nside : x\u271d\nc : sorry\ni : Fin n\n\u22a2 sorry"}, {"line": "simp [side, c.hw]", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nCube : x\u271d\u00b9\nx\u271d : Sort u_2\nside : x\u271d\nc : sorry\ni : Fin n\n\u22a2 sorry ()"}]}
{"declaration": "theorem b_mem_toSet (c : Cube n) : c.b \u2208 c.toSet := by simp [toSet]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry \u2208 sorry"}, {"line": "simp [toSet]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem b_lt_xm (c : Cube (n + 1)) : c.b 0 < c.xm := by simp [xm, hw]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry < sorry"}, {"line": "simp [xm, hw]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () < sorry ()"}]}
{"declaration": "theorem tail_shiftUp (c : Cube (n + 1)) : c.shiftUp.tail = c.tail := by simp [shiftUp, Cube.tail]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [shiftUp, Cube.tail]", "tactic_state": "x\u271d : Sort u_1\nCube : x\u271d\nc : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem side_unitCube {j : Fin n} : unitCube.side j = Ico 0 1 := by\n  norm_num [unitCube, side]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry = Ico 0 1"}, {"line": "norm_num [unitCube, side]", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry () = Ico 0 1"}]}
{"declaration": "theorem side_subset {i j} : (cs i).side j \u2286 Ico 0 1 := by\n  simpa only [side_unitCube] using toSet_subset.1 h.toSet_subset_unitCube j\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/CubingACube.lean", "context": {"open": ["Real Set Function Fin", "Cube"], "variables": ["{n : \u2115}", "{\u03b9 : Type} {cs : \u03b9 \u2192 Cube (n + 1)} {i i' : \u03b9}", "(h : Correct cs)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Cube : ?m.1284\nCorrect : ?m.1301\nn : \u2115\n\u03b9\u271d : Type\ncs : \u03b9\u271d \u2192 sorry\ni\u271d i' : \u03b9\u271d\nh : sorry\n\u03b9 : Type\ni : \u03b9\nj : ?m.2631\n\u22a2 sorry \u2286 Ico 0 1"}, {"line": "simpa only [side_unitCube] using toSet_subset.1 h.toSet_subset_unitCube j", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cube_root_of_unity_sum (h\u03c9 : IsPrimitiveRoot \u03c9 3) : 1 + \u03c9 + \u03c9 ^ 2 = 0 := by\n  simpa [cyclotomic_prime, Finset.sum_range_succ] using h\u03c9.isRoot_cyclotomic (by decide)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/SolutionOfCubicQuartic.lean", "context": {"open": ["Polynomial"], "variables": ["{K : Type*} [Field K] (a b c d e : K) {\u03c9 p q r s t u v w x y : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\n\u03c9 : K\nh\u03c9 : IsPrimitiveRoot \u03c9 3\n\u22a2 1 + \u03c9 + \u03c9 ^ 2 = 0"}, {"line": "simpa [cyclotomic_prime, Finset.sum_range_succ] using h\u03c9.isRoot_cyclotomic (by decide)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem counted_ne_nil_left {p q : \u2115} (hp : p \u2260 0) {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l \u2260 [] := by simp [counted_eq_nil_iff hl, hp]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhp : p \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l \u2260 []"}, {"line": "simp [counted_eq_nil_iff hl, hp]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhp : p \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 \u00acl = []"}]}
{"declaration": "theorem counted_ne_nil_right {p q : \u2115} (hq : q \u2260 0) {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l \u2260 [] := by simp [counted_eq_nil_iff hl, hq]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhq : q \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l \u2260 []"}, {"line": "simp [counted_eq_nil_iff hl, hq]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\nhq : q \u2260 0\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 \u00acl = []"}]}
{"declaration": "theorem sum_of_mem_countedSequence {p q} {l : List \u2124} (hl : l \u2208 countedSequence p q) :\n    l.sum = p - q := by simp [(mem_countedSequence_iff_perm.1 hl).sum_eq, sub_eq_add_neg]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2124\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l.sum = p - q"}, {"line": "simp [(mem_countedSequence_iff_perm.1 hl).sum_eq, sub_eq_add_neg]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2124\nl : List \u2124\nhl : l \u2208 sorry\n\u22a2 l.sum = p + -q"}]}
{"declaration": "theorem disjoint_bits (p q : \u2115) :\n    Disjoint (List.cons 1 '' countedSequence p (q + 1))\n      (List.cons (-1) '' countedSequence (p + 1) q) := by\n  simp_rw [disjoint_left, mem_image, not_exists, exists_imp]\n  rintro _ _ \u27e8_, rfl\u27e9 _ \u27e8_, _, _\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/BallotProblem.lean", "context": {"open": ["Set ProbabilityTheory MeasureTheory", "scoped ENNReal", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\n\u22a2 Disjoint (List.cons 1 '' sorry) (List.cons (-1) '' sorry)"}, {"line": "simp_rw [disjoint_left, mem_image, not_exists, exists_imp]", "tactic_state": "x\u271d : Sort u_1\ncountedSequence : x\u271d\np q : \u2115\n\u22a2 \u2200 \u2983a : List \u2124\u2984 (x : List \u2124), x \u2208 sorry \u2227 1 :: x = a \u2192 \u2200 (x : List \u2124), \u00ac(x \u2208 sorry \u2227 -1 :: x = a)"}, {"line": "rintro _ _ \u27e8_, rfl\u27e9 _ \u27e8_, _, _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_Phi {S : Type*} [CommRing S] (f : R \u2192+* S) : (\u03a6 R a b).map f = \u03a6 S a b := by simp [\u03a6]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\n\u03a6 : x\u271d\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\n\u22a2 sorry = sorry"}, {"line": "simp [\u03a6]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_3\n\u03a6 : x\u271d\nS : Type u_2\ninst\u271d : CommRing S\nf : R \u2192+* S\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem coeff_zero_Phi : (\u03a6 R a b).coeff 0 = (b : R) := by simp [\u03a6, coeff_X_pow]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nb : \u2115\nx\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry = \u2191b"}, {"line": "simp [\u03a6, coeff_X_pow]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nb : \u2115\nx\u271d : Sort u_2\n\u03a6 : x\u271d\n\u22a2 sorry () = \u2191b"}]}
{"declaration": "theorem not_solvable_by_rad' (x : \u2102) (hx : aeval x (\u03a6 \u211a 4 2) = 0) : \u00acIsSolvableByRad \u211a x := by\n  apply not_solvable_by_rad 4 2 2 x hx <;> decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/AbelRuffini.lean", "context": {"open": ["Function Polynomial Polynomial.Gal Ideal", "scoped Polynomial"], "variables": ["(R : Type*) [CommRing R] (a b : \u2115)", "{R}", "[Nontrivial R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\n\u03a6 : x\u271d\nx : \u2102\nhx : (aeval x) sorry = 0\n\u22a2 \u00acIsSolvableByRad \u211a x"}, {"line": "apply not_solvable_by_rad 4 2 2 x hx <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Theorems100.inverse_triangle_sum :\n    \u2200 n, \u2211 k \u2208 range n, (2 : \u211a) / (k * (k + 1)) = if n = 0 then 0 else 2 - (2 : \u211a) / n := by\n  refine sum_range_induction _ _ rfl ?_\n  rintro (_ | _)\n  \u00b7 norm_num\n  field_simp\n  ring", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Wiedijk100Theorems/InverseTriangleSum.lean", "context": {"open": ["Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), \u2211 k \u2208 range n, 2 / (\u2191k * (\u2191k + 1)) = if n = 0 then 0 else 2 - 2 / \u2191n"}, {"line": "refine sum_range_induction _ _ rfl ?_", "tactic_state": "\u22a2 \u2200 (n : \u2115), (if n + 1 = 0 then 0 else 2 - 2 / \u2191(n + 1)) = (if n = 0 then 0 else 2 - 2 / \u2191n) + 2 / (\u2191n * (\u2191n + 1))"}, {"line": "rintro (_ | _)", "tactic_state": "case zero\n\u22a2 (if 0 + 1 = 0 then 0 else 2 - 2 / \u2191(0 + 1)) = (if 0 = 0 then 0 else 2 - 2 / \u21910) + 2 / (\u21910 * (\u21910 + 1))\n---\ncase succ\nn\u271d : \u2115\n\u22a2 (if n\u271d + 1 + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1 + 1)) =\n    (if n\u271d + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1)) + 2 / (\u2191(n\u271d + 1) * (\u2191(n\u271d + 1) + 1))"}, {"line": "\u00b7 norm_num", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (if n\u271d + 1 + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1 + 1)) =\n    (if n\u271d + 1 = 0 then 0 else 2 - 2 / \u2191(n\u271d + 1)) + 2 / (\u2191(n\u271d + 1) * (\u2191(n\u271d + 1) + 1))"}, {"line": "field_simp", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 (2 * (\u2191n\u271d + 1 + 1) - 2) * ((\u2191n\u271d + 1) * ((\u2191n\u271d + 1) * (\u2191n\u271d + 1 + 1))) =\n    ((2 * (\u2191n\u271d + 1) - 2) * ((\u2191n\u271d + 1) * (\u2191n\u271d + 1 + 1)) + 2 * (\u2191n\u271d + 1)) * (\u2191n\u271d + 1 + 1)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"UMI\") : Derivable \"UMIU\" := by\n  change Derivable ([U, M] ++ [I, U])\n  exact Derivable.r1 h -- Rule 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([U, M] ++ [I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r1 h -- Rule 1", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"MIIU\") : Derivable \"MIIUIIU\" := by\n  change Derivable (M :: [I, I, U] ++ [I, I, U])\n  exact Derivable.r2 h -- Rule 2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable (M :: [I, I, U] ++ [I, I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r2 h -- Rule 2", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"UIUMIIIMMM\") : Derivable \"UIUMUMMM\" := by\n  change Derivable ([U, I, U, M] ++ U :: [M, M, M])\n  exact Derivable.r3 h -- Rule 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([U, I, U, M] ++ U :: [M, M, M])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r3 h -- Rule 3", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Derivable \"MIMIMUUIIM\") : Derivable \"MIMIMIIM\" := by\n  change Derivable ([M, I, M, I, M] ++ [I, I, M])\n  exact Derivable.r4 h -- Rule 4\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "change Derivable ([M, I, M, I, M] ++ [I, I, M])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\nh : sorry\n\u22a2 sorry"}, {"line": "exact Derivable.r4 h -- Rule 4", "tactic_state": "No Goals!"}]}
{"declaration": "example : Derivable \"MIUIU\" := by\n  change Derivable (M :: [I, U] ++ [I, U])\n  exact Derivable.r2 MIU_der -- `\"MIUIU\"` can be derived as `\"MIU\"` can.\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/MiuLanguage/Basic.lean", "context": {"open": ["MiuAtom"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry"}, {"line": "change Derivable (M :: [I, U] ++ [I, U])", "tactic_state": "x\u271d : Sort u_1\nDerivable : x\u271d\n\u22a2 sorry"}, {"line": "exact Derivable.r2 MIU_der -- `\"MIUIU\"` can be derived as `\"MIU\"` can.", "tactic_state": "No Goals!"}]}
{"declaration": "theorem four_pow_four_pos : (0 : \u211d) < 4 ^ 4 := by norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 4 ^ 4"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rhs_ineq {x y : \u211d} : 3 * (x + y) ^ 2 \u2264 2 * (x ^ 2 + y ^ 2 + (x + y) ^ 2) := by\n  have : 0 \u2264 (x - y) ^ 2 := by positivity\n  linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 3 * (x + y) ^ 2 \u2264 2 * (x ^ 2 + y ^ 2 + (x + y) ^ 2)"}, {"line": "have : 0 \u2264 (x - y) ^ 2 := by positivity", "tactic_state": "x y : \u211d\nthis : 0 \u2264 (x - y) ^ 2\n\u22a2 3 * (x + y) ^ 2 \u2264 2 * (x ^ 2 + y ^ 2 + (x + y) ^ 2)"}, {"line": "linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_32 : (0 : \u211d) < 32 := by norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q3.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 0 < 32"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "lemma row2_mem_monsterCells_monsterData12 (hN : 2 \u2264 N) {c\u2081 c\u2082 : Fin (N + 1)} (h : c\u2081 \u2260 c\u2082) :\n    (\u27e82, by omega\u27e9, c\u2082) \u2208 (monsterData12 hN c\u2081 c\u2082).monsterCells := by\n  convert Set.mem_range_self (row2 hN)\n  exact (monsterData12_apply_row2 hN h).symm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 (sorry, c\u2082) \u2208 sorry"}, {"line": "convert Set.mem_range_self (row2 hN)", "tactic_state": "case a\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 (sorry, c\u2082) \u2208 sorry \u2194 ?convert_3 sorry \u2208 Set.range ?convert_3\n---\ncase convert_1\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Type ?u.1834\n---\ncase convert_2\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Sort ?u.1833\n---\ncase convert_3\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 ?convert_2 \u2192 ?convert_1"}, {"line": "exact (monsterData12_apply_row2 hN h).symm", "tactic_state": "case convert_1\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Type ?u.1834\n---\ncase convert_2\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 Sort ?u.1833\n---\ncase convert_3\nN : \u2115\nx\u271d : Sort u_1\nmonsterData12 : x\u271d\nhN : 2 \u2264 N\nc\u2081 c\u2082 : Fin (N + 1)\nh : c\u2081 \u2260 c\u2082\n\u22a2 ?convert_2 \u2192 ?convert_1"}]}
{"declaration": "lemma Strategy.ForcesWinIn.three_le {s : Strategy N} {k : \u2115} (hf : s.ForcesWinIn k)\n    (hN : 2 \u2264 N) : 3 \u2264 k := by\n  by_contra hk\n  exact s.not_forcesWinIn_two hN (Strategy.ForcesWinIn.mono s hf (by omega))\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q5.lean", "context": {"open": [], "variables": ["{N : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nStrategy : x\u271d\ns : sorry\nk : \u2115\nhf : sorry\nhN : 2 \u2264 N\n\u22a2 3 \u2264 k"}, {"line": "by_contra hk", "tactic_state": "N : \u2115\nx\u271d : Sort u_1\nStrategy : x\u271d\ns : sorry\nk : \u2115\nhf : sorry\nhN : 2 \u2264 N\nhk : \u00ac3 \u2264 k\n\u22a2 False"}, {"line": "exact s.not_forcesWinIn_two hN (Strategy.ForcesWinIn.mono s hf (by omega))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arith_lemma (k n : \u2115) : 0 < 2 * n + 2 ^ k.succ := by positivity\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2013Q1.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k n : \u2115\n\u22a2 0 < 2 * n + 2 ^ k.succ"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma helper_5_digits {c : \u2124} (hc : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)) : c = 15384 := by\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2124\nhc : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)\n\u22a2 c = 15384"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma case_5_digits {c n : \u2115} (hc : (digits 10 c).length = 5) (hpp : ProblemPredicate' c n) :\n    c = 15384 := by\n  have hpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [hc]\n  have hmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6) := by rw [hpow, hpp.right, hpp.left]\n  zify at *\n  exact helper_5_digits hmul\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q1.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\n\u22a2 c = 15384"}, {"line": "have hpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c := by rw [hc]", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\nhpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c\n\u22a2 c = 15384"}, {"line": "have hmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6) := by rw [hpow, hpp.right, hpp.left]", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhc : (digits 10 c).length = 5\nhpp : sorry\nhpow : 6 * 10 ^ 5 + c = 6 * 10 ^ (digits 10 c).length + c\nhmul : 6 * 10 ^ 5 + c = 4 * (10 * c + 6)\n\u22a2 c = 15384"}, {"line": "zify at *", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate' : x\u271d\nc n : \u2115\nhpp : sorry\nhc : \u2191(digits 10 c).length = 5\nhpow : 6 * 10 ^ 5 + \u2191c = 6 * 10 ^ (digits 10 c).length + \u2191c\nhmul : 6 * 10 ^ 5 + \u2191c = 4 * (10 * \u2191c + 6)\n\u22a2 \u2191c = 15384"}, {"line": "exact helper_5_digits hmul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sum_equiv {x : \u211d} :\n    (cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 - 1) / 4 = altFormula x := by\n  simp only [Real.cos_two_mul, cos_three_mul, altFormula]\n  ring\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\naltFormula : x\u271d\nx : \u211d\n\u22a2 (cos x ^ 2 + cos (2 * x) ^ 2 + cos (3 * x) ^ 2 - 1) / 4 = sorry"}, {"line": "simp only [Real.cos_two_mul, cos_three_mul, altFormula]", "tactic_state": "x\u271d : Sort u_1\naltFormula : x\u271d\nx : \u211d\n\u22a2 (cos x ^ 2 + (2 * cos x ^ 2 - 1) ^ 2 + (4 * cos x ^ 3 - 3 * cos x) ^ 2 - 1) / 4 = sorry"}, {"line": "ring", "tactic_state": "x\u271d : Sort u_1\naltFormula : x\u271d\nx : \u211d\n\u22a2 cos x ^ 2 * (3 / 2) - cos x ^ 4 * 5 + cos x ^ 6 * 4 = sorry"}]}
{"declaration": "theorem solve_cos3x_0 {x : \u211d} : cos (3 * x) = 0 \u2194 \u2203 k : \u2124, x = (2 * \u2191k + 1) * \u03c0 / 6 := by\n  rw [cos_eq_zero_iff]\n  refine exists_congr fun k => ?_\n  constructor <;> intro <;> linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (3 * x) = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "rw [cos_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 k, 3 * x = (2 * \u2191k + 1) * Real.pi / 2) \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "refine exists_congr fun k => ?_", "tactic_state": "x : \u211d\nk : \u2124\n\u22a2 3 * x = (2 * \u2191k + 1) * Real.pi / 2 \u2194 x = (2 * \u2191k + 1) * Real.pi / 6"}, {"line": "constructor <;> intro <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem solve_cos2x_0 {x : \u211d} : cos (2 * x) = 0 \u2194 \u2203 k : \u2124, x = (2 * \u2191k + 1) * \u03c0 / 4 := by\n  rw [cos_eq_zero_iff]\n  refine exists_congr fun k => ?_\n  constructor <;> intro <;> linarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1962Q4.lean", "context": {"open": ["Real", "scoped Real", "Imo1962Q4"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (2 * x) = 0 \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "rw [cos_eq_zero_iff]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 k, 2 * x = (2 * \u2191k + 1) * Real.pi / 2) \u2194 \u2203 k, x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "refine exists_congr fun k => ?_", "tactic_state": "x : \u211d\nk : \u2124\n\u22a2 2 * x = (2 * \u2191k + 1) * Real.pi / 2 \u2194 x = (2 * \u2191k + 1) * Real.pi / 4"}, {"line": "constructor <;> intro <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_two_mul_sub_one_le_one : sqrt (2 * x - 1) \u2264 1 \u2194 x \u2264 1 := by\n  simp [sqrt_le_iff]\n  simp [\u2190 two_mul]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1959Q2.lean", "context": {"open": ["Set Real"], "variables": ["{x A : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u221a(2 * x - 1) \u2264 1 \u2194 x \u2264 1"}, {"line": "simp [sqrt_le_iff]", "tactic_state": "x : \u211d\n\u22a2 2 * x \u2264 1 + 1 \u2194 x \u2264 1"}, {"line": "simp [\u2190 two_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGood_sqrt2_iff : IsGood x (sqrt 2) \u2194 x \u2208 Icc (1 / 2) 1 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 (isGood_iff_eq_sqrt_two h).2 rfl\u27e9\n  exact \u27e8h.one_half_le, not_lt.1 fun h\u2081 \u21a6 (h.sqrt_two_lt_of_one_lt h\u2081).false\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1959Q2.lean", "context": {"open": ["Set Real"], "variables": ["{x A : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nIsGood : x\u271d\n\u22a2 sorry \u2194 x \u2208 Icc (1 / 2) 1"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 (isGood_iff_eq_sqrt_two h).2 rfl\u27e9", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nIsGood : x\u271d\nh : sorry\n\u22a2 x \u2208 Icc (1 / 2) 1"}, {"line": "exact \u27e8h.one_half_le, not_lt.1 fun h\u2081 \u21a6 (h.sqrt_two_lt_of_one_lt h\u2081).false\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_eq_one_of_pow_eq_one (x : \u211d) (n : \u2115) (hn : n \u2260 0) (h : x ^ n = 1) : |x| = 1 := by\n  rw [\u2190 pow_left_inj\u2080 (abs_nonneg x) zero_le_one hn, one_pow, pow_abs, h, abs_one]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2008Q4.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\nhn : n \u2260 0\nh : x ^ n = 1\n\u22a2 |x| = 1"}, {"line": "rw [\u2190 pow_left_inj\u2080 (abs_nonneg x) zero_le_one hn, one_pow, pow_abs, h, abs_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem left_factor_large {m : \u2124} (n : \u2124) (h : 1 < m) : 1 < (n - m) ^ 2 + m ^ 2 := by nlinarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\nh : 1 < m\n\u22a2 1 < (n - m) ^ 2 + m ^ 2"}, {"line": "nlinarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem right_factor_large {m : \u2124} (n : \u2124) (h : 1 < m) : 1 < (n + m) ^ 2 + m ^ 2 := by nlinarith\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2124\nh : 1 < m\n\u22a2 1 < (n + m) ^ 2 + m ^ 2"}, {"line": "nlinarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem int_large {m : \u2124} (h : 1 < m) : 1 < m.natAbs := by\n  exact_mod_cast lt_of_lt_of_le h le_natAbs\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1969Q1.lean", "context": {"open": ["Int Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2124\nh : 1 < m\n\u22a2 1 < m.natAbs"}, {"line": "exact_mod_cast lt_of_lt_of_le h le_natAbs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem main\u2080 (n : \u2115) : \u2211 k \u2208 range (n + 1), k * p (Fin n) k = n * (n - 1)! := by\n  simpa using main_fintype (Fin n)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1987Q1.lean", "context": {"open": ["scoped Nat", "Equiv Fintype Function", "Finset (range sum_const)", "Set (Iic)"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\np : x\u271d\nn : \u2115\n\u22a2 \u2211 k \u2208 range (n + 1), k * sorry = n * (n - 1).factorial"}, {"line": "simpa using main_fintype (Fin n)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_apply (x : G) : f (-(f x)) = -x := by\n  rw [\u2190 add_eq_zero_iff_eq_neg]\n  exact h.apply_neg_apply_add x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx : G\n\u22a2 f (-f x) = -x"}, {"line": "rw [\u2190 add_eq_zero_iff_eq_neg]", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx : G\n\u22a2 f (-f x) + x = 0"}, {"line": "exact h.apply_neg_apply_add x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_of_apply_eq {x\u2081 x\u2082 : G} (hx : f x\u2081 = x\u2082) : f (-x\u2082) = -x\u2081 := by\n  rw [\u2190 hx]\n  exact h.apply_neg_apply _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhx : f x\u2081 = x\u2082\n\u22a2 f (-x\u2082) = -x\u2081"}, {"line": "rw [\u2190 hx]", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhx : f x\u2081 = x\u2082\n\u22a2 f (-f x\u2081) = -x\u2081"}, {"line": "exact h.apply_neg_apply _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.apply_neg_eq_neg_iff {x\u2081 x\u2082 : G} : f (-x\u2082) = -x\u2081 \u2194 f x\u2081 = x\u2082 := by\n  refine \u27e8fun hn \u21a6 ?_, h.apply_neg_of_apply_eq\u27e9\n  convert h.apply_neg_of_apply_eq hn <;> rw [neg_neg]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\n\u22a2 f (-x\u2082) = -x\u2081 \u2194 f x\u2081 = x\u2082"}, {"line": "refine \u27e8fun hn \u21a6 ?_, h.apply_neg_of_apply_eq\u27e9", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx\u2081 x\u2082 : G\nhn : f (-x\u2082) = -x\u2081\n\u22a2 f x\u2081 = x\u2082"}, {"line": "convert h.apply_neg_of_apply_eq hn <;> rw [neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Aquaesulian.pair_lemma {x u v : G} (huv : u \u2260 v) (hx : f x = u \u2228 f u = x)\n    (hy : f x = v \u2228 f v = x) : f x = v \u2228 f x = u := by\n  rcases hx with hx | hx <;> rcases hy with hy | hy\n  \u00b7 exact (huv (hx.symm.trans hy)).elim\n  \u00b7 exact .inr hx\n  \u00b7 exact .inl hy\n  \u00b7 exact ((h.injective.ne huv) (hx.trans hy.symm)).elim\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u \u2228 f u = x\nhy : f x = v \u2228 f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "rcases hx with hx | hx <;> rcases hy with hy | hy", "tactic_state": "case inl.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inl.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact (huv (hx.symm.trans hy)).elim", "tactic_state": "case inl.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f x = u\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact .inr hx", "tactic_state": "case inr.inl\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f x = v\n\u22a2 f x = v \u2228 f x = u\n---\ncase inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact .inl hy", "tactic_state": "case inr.inr\nAquaesulian : ?m.445\nG\u271d : Type u_1\ninst\u271d\u00b9 : AddCommGroup G\u271d\nf\u271d : G\u271d \u2192 G\u271d\nh : sorry\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nx u v : G\nhuv : u \u2260 v\nhx : f u = x\nhy : f v = x\n\u22a2 f x = v \u2228 f x = u"}, {"line": "\u00b7 exact ((h.injective.ne huv) (hx.trans hy.symm)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fract_fExample (x : \u211a) :\n    Int.fract (fExample x) = if Int.fract x = 0 then 0 else 1 - Int.fract x := by\n  by_cases h : Int.fract x = 0\n  \u00b7 simp [fExample, h]\n  \u00b7 simp [fExample, h, sub_eq_add_neg, Int.fract_neg]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q6.lean", "context": {"open": ["scoped Cardinal"], "variables": ["{G : Type*} [AddCommGroup G]", "{f : G \u2192 G} (h : Aquaesulian f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Aquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "by_cases h : Int.fract x = 0", "tactic_state": "case pos\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : Int.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x\n---\ncase neg\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : \u00acInt.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "\u00b7 simp [fExample, h]", "tactic_state": "case neg\nAquaesulian : ?m.445\nG : Type u_1\ninst\u271d : AddCommGroup G\nf : G \u2192 G\nh\u271d : sorry\nx\u271d : Sort u_2\nfExample : x\u271d\nx : \u211a\nh : \u00acInt.fract x = 0\n\u22a2 Int.fract sorry = if Int.fract x = 0 then 0 else 1 - Int.fract x"}, {"line": "\u00b7 simp [fExample, h, sub_eq_add_neg, Int.fract_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem A_maps_to_offDiag_judgePair (a : AgreedTriple C J) :\n    a \u2208 A r \u2192 a.judgePair \u2208 Finset.offDiag (@Finset.univ J _) := by simp [A, Finset.mem_offDiag]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1998Q2.lean", "context": {"open": ["scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{C J : Type*} (r : C \u2192 J \u2192 Prop)", "[Fintype J] [Fintype C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type u_5\ninst\u271d : Fintype J\nx\u271d\u00b9 : Sort u_1\nAgreedTriple : x\u271d\u00b9\nx\u271d : Sort u_2\nA : x\u271d\na : sorry\n\u22a2 a \u2208 sorry \u2192 sorry \u2208 sorry"}, {"line": "simp [A, Finset.mem_offDiag]", "tactic_state": "J : Type u_5\ninst\u271d : Fintype J\nx\u271d\u00b9 : Sort u_1\nAgreedTriple : x\u271d\u00b9\nx\u271d : Sort u_2\nA : x\u271d\na : sorry\n\u22a2 a \u2208 sorry () \u2192 sorry () \u2208 sorry ()"}]}
{"declaration": "theorem clear_denominators {a b k : \u2115} (ha : 0 < a) (hb : 0 < b) :\n    (b - 1 : \u211a) / (2 * b) \u2264 k / a \u2194 ((b : \u2115) - 1) * a \u2264 k * (2 * b) := by\n  rw [div_le_div_iff\u2080]\n  on_goal 1 => convert Nat.cast_le (\u03b1 := \u211a)\n  all_goals simp [ha, hb]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1998Q2.lean", "context": {"open": ["scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{C J : Type*} (r : C \u2192 J \u2192 Prop)", "[Fintype J] [Fintype C]", "[Fintype J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) / (2 * \u2191b) \u2264 \u2191k / \u2191a \u2194 (b - 1) * a \u2264 k * (2 * b)"}, {"line": "rw [div_le_div_iff\u2080]", "tactic_state": "a b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) * \u2191a \u2264 \u2191k * (2 * \u2191b) \u2194 (b - 1) * a \u2264 k * (2 * b)\n---\ncase hb\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < 2 * \u2191b\n---\ncase hd\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < \u2191a"}, {"line": "on_goal 1 => convert Nat.cast_le (\u03b1 := \u211a)", "tactic_state": "case h.e'_1.h.e'_3\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 (\u2191b - 1) * \u2191a = \u2191((b - 1) * a)\n---\ncase h.e'_1.h.e'_4\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 \u2191k * (2 * \u2191b) = \u2191(k * (2 * b))\n---\ncase hb\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < 2 * \u2191b\n---\ncase hd\na b k : \u2115\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < \u2191a"}, {"line": "all_goals simp [ha, hb]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma a_coprime_ab_add_one : a.Coprime (a * b + 1) := by\n  simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 a.Coprime (a * b + 1)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_large_n_sub_neg_one : (\u03c6 (a * b + 1) : \u2124) \u2223 (h.large_n : \u2124) - (-1 : \u2124) := by\n  simp [large_n]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry - -1"}, {"line": "simp [large_n]", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry () + 1"}]}
{"declaration": "lemma dvd_large_n_0_sub_zero : (\u03c6 (a * b + 1) : \u2124) \u2223 (h.large_n_0 : \u2124) - (0 : \u2124) := by\n  simp [large_n_0]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q2.lean", "context": {"open": ["scoped Nat"], "variables": ["{a b : \u2115} (h : Condition a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry - 0"}, {"line": "simp [large_n_0]", "tactic_state": "Condition : ?m.427\na\u271d b\u271d : \u2115\nh : sorry\na b : \u2115\n\u22a2 \u2191(a * b + 1).totient \u2223 sorry ()"}]}
{"declaration": "theorem m_le_n {m n : \u2124} (h1 : ProblemPredicate N m n) : m \u2264 n := by\n  by_contra h2\n  have h3 : 1 = (n * (n - m) - m ^ 2) ^ 2 := by linear_combination - h1.eq_one\n  have h4 : n * (n - m) - m ^ 2 < -1 := by nlinarith [h1.n_range.left]\n  have h5 : 1 < (n * (n - m) - m ^ 2) ^ 2 := by nlinarith\n  exact h5.ne h3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1981Q3.lean", "context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\n\u22a2 m \u2264 n"}, {"line": "by_contra h2", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\n\u22a2 False"}, {"line": "have h3 : 1 = (n * (n - m) - m ^ 2) ^ 2 := by linear_combination - h1.eq_one", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\n\u22a2 False"}, {"line": "have h4 : n * (n - m) - m ^ 2 < -1 := by nlinarith [h1.n_range.left]", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\nh4 : n * (n - m) - m ^ 2 < -1\n\u22a2 False"}, {"line": "have h5 : 1 < (n * (n - m) - m ^ 2) ^ 2 := by nlinarith", "tactic_state": "x\u271d : Sort u_1\nProblemPredicate : x\u271d\nm n : \u2124\nh1 : sorry\nh2 : \u00acm \u2264 n\nh3 : 1 = (n * (n - m) - m ^ 2) ^ 2\nh4 : n * (n - m) - m ^ 2 < -1\nh5 : 1 < (n * (n - m) - m ^ 2) ^ 2\n\u22a2 False"}, {"line": "exact h5.ne h3", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.natAbs_eq_of_chain_dvd {l : Cycle \u2124} {x y : \u2124} (hl : l.Chain (\u00b7 \u2223 \u00b7)) (hx : x \u2208 l)\n    (hy : y \u2208 l) : x.natAbs = y.natAbs := by\n  rw [Cycle.chain_iff_pairwise] at hl\n  exact Int.natAbs_eq_of_dvd_dvd (hl x hx y hy) (hl y hy x hx)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q5.lean", "context": {"open": ["Function Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Cycle \u2124\nx y : \u2124\nhl : Cycle.Chain (fun x1 x2 => x1 \u2223 x2) l\nhx : x \u2208 l\nhy : y \u2208 l\n\u22a2 x.natAbs = y.natAbs"}, {"line": "rw [Cycle.chain_iff_pairwise] at hl", "tactic_state": "l : Cycle \u2124\nx y : \u2124\nhl : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2223 b\nhx : x \u2208 l\nhy : y \u2208 l\n\u22a2 x.natAbs = y.natAbs"}, {"line": "exact Int.natAbs_eq_of_dvd_dvd (hl x hx y hy) (hl y hy x hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Polynomial.iterate_comp_sub_X_ne {P : Polynomial \u2124} (hP : 1 < P.natDegree) {k : \u2115}\n    (hk : 0 < k) : P.comp^[k] X - X \u2260 0 := by\n  rw [sub_ne_zero]\n  apply_fun natDegree\n  simpa using (one_lt_pow\u2080 hP hk.ne').ne'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2006Q5.lean", "context": {"open": ["Function Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 P.comp^[k] X - X \u2260 0"}, {"line": "rw [sub_ne_zero]", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 P.comp^[k] X \u2260 X"}, {"line": "apply_fun natDegree", "tactic_state": "P : Polynomial \u2124\nhP : 1 < P.natDegree\nk : \u2115\nhk : 0 < k\n\u22a2 (P.comp^[k] X).natDegree \u2260 X.natDegree"}, {"line": "simpa using (one_lt_pow\u2080 hP hk.ne').ne'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_sin_pi_div_seven_ne_zero : 2 * sin (\u03c0 / 7) \u2260 0 := by\n  apply mul_ne_zero two_ne_zero (Real.sin_pos_of_pos_of_lt_pi _ _).ne' <;> linarith [pi_pos]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1963Q5.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 * sin (Real.pi / 7) \u2260 0"}, {"line": "apply mul_ne_zero two_ne_zero (Real.sin_pos_of_pos_of_lt_pi _ _).ne' <;> linarith [pi_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_pi_mul_neg_div (a b : \u211d) : sin (\u03c0 * (- a / b)) = - sin (\u03c0 * (a / b)) := by\n  ring_nf\n  exact sin_neg _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1963Q5.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 sin (Real.pi * (-a / b)) = -sin (Real.pi * (a / b))"}, {"line": "ring_nf", "tactic_state": "a b : \u211d\n\u22a2 sin (-(Real.pi * a * b\u207b\u00b9)) = -sin (Real.pi * a * b\u207b\u00b9)"}, {"line": "exact sin_neg _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma part_1 : 660 \u2264 f (1980) := by\n  exact hf.le_mul_three_apply 660\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1982Q1.lean", "context": {"open": [], "variables": ["{f : \u2115+ \u2192 \u2115} (hf : IsGood f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsGood : ?m.427\nf\u271d : \u2115+ \u2192 \u2115\nhf : sorry\nf : \u2115+ \u2192 \u2115\n\u22a2 660 \u2264 f 1980"}, {"line": "exact hf.le_mul_three_apply 660", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_sum_pool : \u2211 i \u2208 range b, (i : \u2124) \u2264 \u2211 x \u2208 pool a t, x := by\n  convert sum_range_le_sum fun x mx \u21a6 (mem_Icc.mp ((pool_subset_Icc ha) mx)).1\n  \u00b7 rw [hbN _ ht]\n  \u00b7 rw [zero_add]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2015Q6.lean", "context": {"open": ["Finset"], "variables": ["{a : \u2115 \u2192 \u2124} (ha : Condition a) {t : \u2115}", "{b N : \u2115} (hbN : \u2200 t \u2265 N, #(pool a t) = b) (ht : t \u2265 N)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.1311\npool : ?m.1343\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2211 i \u2208 range b, \u2191i \u2264 \u2211 x \u2208 sorry, x"}, {"line": "convert sum_range_le_sum fun x mx \u21a6 (mem_Icc.mp ((pool_subset_Icc ha) mx)).1", "tactic_state": "case h.e'_3.h.h.e'_1\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 b = card ?m.5232\n---\ncase h.e'_3.a\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb x\u271d : \u2115\na\u271d : x\u271d \u2208 range (card ?m.5232)\n\u22a2 \u2191x\u271d = ?convert_2 + \u2191x\u271d\n---\ncase convert_2\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2124\n---\ncase convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}, {"line": "\u00b7 rw [hbN _ ht]", "tactic_state": "case h.e'_3.a\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb x\u271d : \u2115\na\u271d : x\u271d \u2208 range (card ?m.5232)\n\u22a2 \u2191x\u271d = ?convert_2 + \u2191x\u271d\n---\ncase convert_2\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 \u2124\n---\ncase convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}, {"line": "\u00b7 rw [zero_add]", "tactic_state": "case convert_3\nCondition : ?m.1311\npool : \u2211 x \u2208 sorry, x = \u2211 x \u2208 ?m.5232, x\na : \u2115 \u2192 \u2124\nha : sorry\nt b\u271d N : \u2115\nhbN : \u2200 t_1 \u2265 N, card ?m.1371 = b\u271d\nht : t \u2265 N\nb : \u2115\n\u22a2 (x : \u2124) \u2192 x \u2208 ?m.5232 \u2192 \u2124"}]}
{"declaration": "lemma finite_setOf_apply_eq_iff_not_small {j : \u2115} (hj : 0 < j) :\n    {i | a i = j}.Finite \u2194 \u00acSmall a j := by\n  simpa only [Set.not_infinite] using (hc.infinite_setOf_apply_eq_iff_small hj).not\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.1291\na\u271d : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\na : \u2115 \u2192 \u2115\nj : \u2115\nhj : 0 < j\n\u22a2 {i | a i = j}.Finite \u2194 \u00acsorry"}, {"line": "simpa only [Set.not_infinite] using (hc.infinite_setOf_apply_eq_iff_small hj).not", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_small_of_big {j : \u2115} (h : Big a j) : \u00acSmall a j := by simp [Small, hc.k_lt_of_big h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo2024Q3.lean", "context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)", "(a)", "{a}", "(a)", "{a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Condition : ?m.2149\na : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\nx\u271d : Sort u_1\nBig : x\u271d\nj : \u2115\nh : sorry\n\u22a2 \u00acsorry"}, {"line": "simp [Small, hc.k_lt_of_big h]", "tactic_state": "Condition : ?m.2149\na : \u2115 \u2192 \u2115\nN : \u2115\nhc : sorry\nx\u271d : Sort u_1\nBig : x\u271d\nj : \u2115\nh : sorry\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem tedious (m : \u2115) (k : Fin (m + 1)) : m - ((m + 1 - \u2191k) + m) % (m + 1) = \u2191k := by\n  obtain \u27e8k, hk\u27e9 := k\n  rw [Nat.lt_succ_iff, le_iff_exists_add] at hk\n  rcases hk with \u27e8c, rfl\u27e9\n  have : (k + c + 1 - k) + (k + c) = c + (k + c + 1) := by omega\n  rw [Fin.val_mk, this, Nat.add_mod_right, Nat.mod_eq_of_lt, Nat.add_sub_cancel]\n  omega\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Imo/Imo1994Q1.lean", "context": {"open": ["Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nk : Fin (m + 1)\n\u22a2 m - (m + 1 - \u2191k + m) % (m + 1) = \u2191k"}, {"line": "obtain \u27e8k, hk\u27e9 := k", "tactic_state": "case mk\nm k : \u2115\nhk : k < m + 1\n\u22a2 m - (m + 1 - \u2191\u27e8k, hk\u27e9 + m) % (m + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "rw [Nat.lt_succ_iff, le_iff_exists_add] at hk", "tactic_state": "case mk\nm k : \u2115\nhk\u271d : k < m + 1\nhk : \u2203 c, m = k + c\n\u22a2 m - (m + 1 - \u2191\u27e8k, hk\u271d\u27e9 + m) % (m + 1) = \u2191\u27e8k, hk\u271d\u27e9"}, {"line": "rcases hk with \u27e8c, rfl\u27e9", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\n\u22a2 k + c - (k + c + 1 - \u2191\u27e8k, hk\u27e9 + (k + c)) % (k + c + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "have : (k + c + 1 - k) + (k + c) = c + (k + c + 1) := by omega", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 k + c - (k + c + 1 - \u2191\u27e8k, hk\u27e9 + (k + c)) % (k + c + 1) = \u2191\u27e8k, hk\u27e9"}, {"line": "rw [Fin.val_mk, this, Nat.add_mod_right, Nat.mod_eq_of_lt, Nat.add_sub_cancel]", "tactic_state": "case mk.intro\nk c : \u2115\nhk : k < k + c + 1\nthis : k + c + 1 - k + (k + c) = c + (k + c + 1)\n\u22a2 c < k + c + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00ac LucasLehmerTest 2 := by norm_num\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Examples/MersennePrimes.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acLucasLehmerTest 2"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "example : (mersenne 2).Prime := by decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/Archive/Examples/MersennePrimes.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Nat.Prime (mersenne 2)"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "use 42", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by use! 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "use! 42", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42, h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}, {"line": "use 42, h", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : 42 = y) : \u2203 x : Nat, x = y := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u2115\nh : 42 = y\n\u22a2 \u2203 x, x = y"}, {"line": "use 42", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by use 42, 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}, {"line": "use 42, 42", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 p : Nat \u00d7 Nat, p.1 = p.2 := by use! (42, 42)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = p.2"}, {"line": "use! (42, 42)", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use (\"a\", \"a\")\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}, {"line": "use (\"a\", \"a\")", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : String \u00d7 String, x.1 = x.2 := by use! \"a\", \"a\"\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x.1 = x.2"}, {"line": "use! \"a\", \"a\"", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  use ?_\n  exact 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "use ?_", "tactic_state": "case w\n\u22a2 \u2115"}, {"line": "exact 42", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type) : \u2203 S : List \u03b1, S = S := by use \u2205\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type\n\u22a2 \u2203 S, S = S"}, {"line": "use \u2205", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Int, x = x := by use 42\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "use 42", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 a b c : Int, a + b + c = 6 := by\n  use 1, 2, 3\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 a b c, a + b + c = 6"}, {"line": "use 1, 2, 3", "tactic_state": "case h\n\u22a2 1 + 2 + 3 = 6"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 p : Int \u00d7 Int, p.1 = 1 := by use \u27e81, 42\u27e9\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, p.1 = 1"}, {"line": "use \u27e81, 42\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 n : Int, n * 3 = 3 * 2 := by\n  use 2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 n, n * 3 = 3 * 2"}, {"line": "use 2", "tactic_state": "case h\n\u22a2 2 * 3 = 3 * 2"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u03a3 _x _y : Int, Int \u00d7 Int \u00d7 Int := by\n  use 1, 2, 3, 4, 5\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (_ : \u2124) \u00d7 (_ : \u2124) \u00d7 \u2124 \u00d7 \u2124 \u00d7 \u2124"}, {"line": "use 1, 2, 3, 4, 5", "tactic_state": "No Goals!"}]}
{"declaration": "example : Option Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Option \u2115"}, {"line": "use 1", "tactic_state": "No Goals!"}]}
{"declaration": "example : Nat \u2192 Nat := by use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115 \u2192 \u2115"}, {"line": "use 1", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 p : {x : Nat // 0 < x}, 1 < p.1 := by use! 2 <;> decide\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 p, 1 < \u2191p"}, {"line": "use! 2 <;> decide", "tactic_state": "No Goals!"}]}
{"declaration": "example : Baz 0 3 := by use _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBaz : x\u271d\n\u22a2 sorry"}, {"line": "use _", "tactic_state": "x\u271d : Sort u_1\nBaz : x\u271d\n\u22a2 sorry"}]}
{"declaration": "example : Baz 0 3 := by use 3\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBaz : x\u271d\n\u22a2 sorry"}, {"line": "use 3", "tactic_state": "No Goals!"}]}
{"declaration": "example : Baz 0 3 := by use 4\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBaz : x\u271d\n\u22a2 sorry"}, {"line": "use 4", "tactic_state": "No Goals!"}]}
{"declaration": "example : Baz 1 3 := by use (3 : Nat)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nBaz : x\u271d\n\u22a2 sorry"}, {"line": "use (3 : Nat)", "tactic_state": "No Goals!"}]}
{"declaration": "example : DecidableType := by\n  use Nat\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort u_1\n\u22a2 DecidableType"}, {"line": "use Nat", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b2 : Type) [DecidableEq \u03b2] : DecidableType := by\n  use \u03b2\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "DecidableType : Sort u_1\n\u03b2 : Type\ninst\u271d : DecidableEq \u03b2\n\u22a2 DecidableType"}, {"line": "use \u03b2", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : Nat) : Nat := by use n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2115"}, {"line": "use n", "tactic_state": "No Goals!"}]}
{"declaration": "example (h1 : 1 > 0) : \u2203 (n : Nat) (_h : n > 0), n = n := by\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h1 : 1 > 0\n\u22a2 \u2203 n, \u2203 (_ : n > 0), n = n"}, {"line": "use 1", "tactic_state": "No Goals!"}]}
{"declaration": "example : let P : Nat \u2192 Prop := fun _x => \u2203 _n : Nat, True; P 1 := by\n  intro P\n  use 1\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 let P := fun _x => \u2203 _n, True;\n  P 1"}, {"line": "intro P", "tactic_state": "P : \u2115 \u2192 Prop := fun _x => \u2203 _n, True\n\u22a2 P 1"}, {"line": "use 1", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use \u00b7\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "use \u00b7", "tactic_state": "case h\n\u22a2 sorry 1 = 1"}]}
{"declaration": "example : \u2203 f : Nat \u2192 Nat, f 1 = 1 := by\n  use (\u00b7)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Use.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 f, f 1 = 1"}, {"line": "use (\u00b7)", "tactic_state": "No Goals!"}]}
{"declaration": "example {F : \u2115 \u2192 \u03b1 \u2192 \u03b2} (hF : \u2200 i, Measurable (F i)) : Measurable (F 0) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nF : \u2115 \u2192 \u03b1 \u2192 \u03b2\nhF : \u2200 (i : \u2115), Measurable (F i)\n\u22a2 Measurable (F 0)"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u211d} : MeasurableSet (Set.Icc a b) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\na b : \u211d\n\u22a2 MeasurableSet (Set.Icc a b)"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example : Measurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 Measurable fun x => Real.exp (2 * inner 3 x)"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example : StronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u22a2 StronglyMeasurable fun x => Real.exp (2 * inner 3 x)"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b3 : MeasureTheory.Measure \u211d} :\n  AEStronglyMeasurable (fun x : \u211d => Real.exp (2 * inner 3 x)) \u03b3 := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b3 : Measure \u211d\n\u22a2 AEStronglyMeasurable (fun x => Real.exp (2 * inner 3 x)) \u03b3"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b9 : Type _} (i k : \u03b9) (hik : i \u2260 k) : Measurable (id : \u03b1 \u2192 \u03b1) := by measurability\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/measurability.lean", "context": {"open": ["MeasureTheory TopologicalSpace"], "variables": ["{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]", "[TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : PseudoMetrizableSpace \u03b2\ninst\u271d : BorelSpace \u03b2\n\u03b9 : Type u_3\ni k : \u03b9\nhik : i \u2260 k\n\u22a2 Measurable id"}, {"line": "measurability", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foo : True := by\n  obtain := trivial\n  obtain _h := trivial\n  obtain : True := trivial\n  obtain _h : True := trivial\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/oldObtain.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "obtain := trivial", "tactic_state": "x\u271d : True\n\u22a2 True"}, {"line": "obtain _h := trivial", "tactic_state": "x\u271d _h : True\n\u22a2 True"}, {"line": "obtain : True := trivial", "tactic_state": "x\u271d\u00b9 _h x\u271d : True\n\u22a2 True"}, {"line": "obtain _h : True := trivial", "tactic_state": "x\u271d\u00b9 _h\u271d x\u271d _h : True\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foo' : True := by\n  obtain : True\n  \u00b7 trivial\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/oldObtain.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "obtain : True", "tactic_state": "\u22a2 True\n---\nthis\u271d : True\n\u22a2 True"}, {"line": "\u00b7 trivial", "tactic_state": "this\u271d : True\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem foo'' : True := by\n  obtain h : True\n  \u00b7 trivial\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/oldObtain.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "obtain h : True", "tactic_state": "\u22a2 True\n---\nh\u271d : True\n\u22a2 True"}, {"line": "\u00b7 trivial", "tactic_state": "h\u271d : True\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "apply_rules [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c d e : Nat} (h1 : a \u2264 b) (h2 : c \u2264 d) (h3 : 0 \u2264 e) :\n    a + c * e + a + c + 0 \u2264 b + d * e + b + d + e := by\n  apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]\n  guard_target = 0 \u2264 e\n  assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 a + c * e + a + c + 0 \u2264 b + d * e + b + d + e"}, {"line": "apply_rules (config := {maxDepth := 9}) [Nat.add_le_add, Nat.mul_le_mul_right]", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "guard_target = 0 \u2264 e", "tactic_state": "case h\u2082\na b c d e : \u2115\nh1 : a \u2264 b\nh2 : c \u2264 d\nh3 : 0 \u2264 e\n\u22a2 0 \u2264 e"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules only [f]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "apply_rules only [f]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "exact p", "tactic_state": "No Goals!"}]}
{"declaration": "example {P Q : Prop} (p : P) (f : P \u2192 Q) : Q := by\n  apply_rules [-p]\n  exact p\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 Q"}, {"line": "apply_rules [-p]", "tactic_state": "P Q : Prop\np : P\nf : P \u2192 Q\n\u22a2 P"}, {"line": "exact p", "tactic_state": "No Goals!"}]}
{"declaration": "example (P : Nat \u2192 Type) (f : {n : Nat} \u2192 P n \u2192 P (n + 1)) (g : P 0) : P 2 := by\n  apply_rules only [f, g]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Type\nf : {n : \u2115} \u2192 P n \u2192 P (n + 1)\ng : P 0\n\u22a2 P 2"}, {"line": "apply_rules only [f, g]", "tactic_state": "No Goals!"}]}
{"declaration": "example (Q : Type) (f : Nat \u2192 Q) : Int \u00d7 Q := by\n  apply_rules only [Prod.mk, f]\n  guard_target = Int\n  exact 0\n  guard_target = Nat\n  exact 37\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/apply_rules.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "Q : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124 \u00d7 Q"}, {"line": "apply_rules only [Prod.mk, f]", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "guard_target = Int", "tactic_state": "case fst\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2124\n---\ncase snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "exact 0", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "guard_target = Nat", "tactic_state": "case snd\nQ : Type\nf : \u2115 \u2192 Q\n\u22a2 \u2115"}, {"line": "exact 37", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  lift n to \u2115 using hn\n  guard_target =\u209b 0 \u2264 (n : Int) + 1\n  exact Int.le_add_one (Int.ofNat_zero_le _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn", "tactic_state": "case intro\nn : \u2115\n\u22a2 0 \u2264 \u2191n + 1"}, {"line": "guard_target =\u209b 0 \u2264 (n : Int) + 1", "tactic_state": "case intro\nn : \u2115\n\u22a2 0 \u2264 \u2191n + 1"}, {"line": "exact Int.le_add_one (Int.ofNat_zero_le _)", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  have hn' := hn\n  lift n to \u2115 using hn with k hk\n  guard_target =\u209b 0 \u2264 (k : Int) + 1\n  guard_hyp hk : (k : Int) = n\n  exact Int.le_add_one hn'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "have hn' := hn", "tactic_state": "n : \u2124\nhn hn' : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with k hk", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_target =\u209b 0 \u2264 (k : Int) + 1", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_hyp hk : (k : Int) = n", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "exact Int.le_add_one hn'", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  have hn' := hn\n  lift n to \u2115 using hn with k\n  guard_target =\u209b 0 \u2264 (k : Int) + 1\n  exact Int.le_add_one hn'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "have hn' := hn", "tactic_state": "n : \u2124\nhn hn' : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with k", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_target =\u209b 0 \u2264 (k : Int) + 1", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "exact Int.le_add_one hn'", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  lift n to \u2115 using hn with k hk hn\n  guard_target =\u209b 0 \u2264 (k : Int) + 1\n  guard_hyp hn : 0 \u2264 (k : Int)\n  guard_hyp hk : k = n\n  exact Int.le_add_one hn\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with k hk hn", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_target =\u209b 0 \u2264 (k : Int) + 1", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_hyp hn : 0 \u2264 (k : Int)", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_hyp hk : k = n", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "exact Int.le_add_one hn", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  lift n to \u2115 using hn with k rfl hn\n  guard_target =\u209b 0 \u2264 (k : Int) + 1\n  guard_hyp hn : 0 \u2264 (k : Int)\n  exact Int.le_add_one hn\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with k rfl hn", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_target =\u209b 0 \u2264 (k : Int) + 1", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_hyp hn : 0 \u2264 (k : Int)", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "exact Int.le_add_one hn", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  have hn' := hn\n  lift n to \u2115 using hn with k rfl\n  guard_target =\u209b 0 \u2264 (k : Int) + 1\n  exact Int.le_add_one hn'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "have hn' := hn", "tactic_state": "n : \u2124\nhn hn' : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with k rfl", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "guard_target =\u209b 0 \u2264 (k : Int) + 1", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhn' : 0 \u2264 \u2191k\n\u22a2 0 \u2264 \u2191k + 1"}, {"line": "exact Int.le_add_one hn'", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  have hn' := hn\n  lift n to \u2115 using hn with n\n  guard_target =\u209b 0 \u2264 (n : Int) + 1\n  exact Int.le_add_one hn'\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "have hn' := hn", "tactic_state": "n : \u2124\nhn hn' : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n to \u2115 using hn with n", "tactic_state": "case intro\nn\u271d : \u2124\nn : \u2115\nhn' : 0 \u2264 \u2191n\n\u22a2 0 \u2264 \u2191n + 1"}, {"line": "guard_target =\u209b 0 \u2264 (n : Int) + 1", "tactic_state": "case intro\nn\u271d : \u2124\nn : \u2115\nhn' : 0 \u2264 \u2191n\n\u22a2 0 \u2264 \u2191n + 1"}, {"line": "exact Int.le_add_one hn'", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 \u2264 n) : 0 \u2264 n + 1 := by\n  -- Should fail because we didn't provide a variable name when lifting an expression\n  fail_if_success lift n + 1 to \u2115 using (Int.le_add_one hn)\n  -- Now it should succeed\n  lift n + 1 to \u2115 using (Int.le_add_one hn) with k hk\n  exact of_decide_eq_true rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "fail_if_success lift n + 1 to \u2115 using (Int.le_add_one hn)", "tactic_state": "n : \u2124\nhn : 0 \u2264 n\n\u22a2 0 \u2264 n + 1"}, {"line": "lift n + 1 to \u2115 using (Int.le_add_one hn) with k hk", "tactic_state": "case intro\nn : \u2124\nhn : 0 \u2264 n\nk : \u2115\nhk : \u2191k = n + 1\n\u22a2 0 \u2264 \u2191k"}, {"line": "exact of_decide_eq_true rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type _) (f : \u03b1 \u2192 \u2124) (hf : \u2200 a, 0 \u2264 f a) (hf' : \u2200 a, f a < 1) (a : \u03b1) :\n    0 \u2264 2 * f a := by\n  lift f to \u03b1 \u2192 \u2115 using hf\n  guard_target =\u209b (0 : \u2124) \u2264 2 * (fun i : \u03b1 \u21a6 (f i : \u2124)) a\n  guard_hyp hf' : \u2200 a, ((fun i : \u03b1 \u21a6 (f i : \u2124)) a) < 1\n  constructor\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2124\nhf : \u2200 (a : \u03b1), 0 \u2264 f a\nhf' : \u2200 (a : \u03b1), f a < 1\na : \u03b1\n\u22a2 0 \u2264 2 * f a"}, {"line": "lift f to \u03b1 \u2192 \u2115 using hf", "tactic_state": "case intro\n\u03b1 : Type u_1\na : \u03b1\nf : \u03b1 \u2192 \u2115\nhf' : \u2200 (a : \u03b1), (fun i => \u2191(f i)) a < 1\n\u22a2 0 \u2264 2 * (fun i => \u2191(f i)) a"}, {"line": "guard_target =\u209b (0 : \u2124) \u2264 2 * (fun i : \u03b1 \u21a6 (f i : \u2124)) a", "tactic_state": "case intro\n\u03b1 : Type u_1\na : \u03b1\nf : \u03b1 \u2192 \u2115\nhf' : \u2200 (a : \u03b1), (fun i => \u2191(f i)) a < 1\n\u22a2 0 \u2264 2 * (fun i => \u2191(f i)) a"}, {"line": "guard_hyp hf' : \u2200 a, ((fun i : \u03b1 \u21a6 (f i : \u2124)) a) < 1", "tactic_state": "case intro\n\u03b1 : Type u_1\na : \u03b1\nf : \u03b1 \u2192 \u2115\nhf' : \u2200 (a : \u03b1), (fun i => \u2191(f i)) a < 1\n\u22a2 0 \u2264 2 * (fun i => \u2191(f i)) a"}, {"line": "constructor", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type _) (f : \u03b1 \u2192 \u2124) (hf : \u2200 a, 0 \u2264 f a) (_ : \u2200 a, f a < 1) (a : \u03b1) :\n    0 \u2264 2 * f a := by\n  lift f to \u03b1 \u2192 \u2115 using hf with g hg\n  guard_target =\u209b 0 \u2264 2 * (g a : Int)\n  guard_hyp hg : (fun i => (g i : Int)) = f\n  constructor\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2124\nhf : \u2200 (a : \u03b1), 0 \u2264 f a\nx\u271d : \u2200 (a : \u03b1), f a < 1\na : \u03b1\n\u22a2 0 \u2264 2 * f a"}, {"line": "lift f to \u03b1 \u2192 \u2115 using hf with g hg", "tactic_state": "case intro\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2124\na : \u03b1\ng : \u03b1 \u2192 \u2115\nhg : (fun i => \u2191(g i)) = f\nx\u271d : \u2200 (a : \u03b1), \u2191(g a) < 1\n\u22a2 0 \u2264 2 * \u2191(g a)"}, {"line": "guard_target =\u209b 0 \u2264 2 * (g a : Int)", "tactic_state": "case intro\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2124\na : \u03b1\ng : \u03b1 \u2192 \u2115\nhg : (fun i => \u2191(g i)) = f\nx\u271d : \u2200 (a : \u03b1), \u2191(g a) < 1\n\u22a2 0 \u2264 2 * \u2191(g a)"}, {"line": "guard_hyp hg : (fun i => (g i : Int)) = f", "tactic_state": "case intro\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2124\na : \u03b1\ng : \u03b1 \u2192 \u2115\nhg : (fun i => \u2191(g i)) = f\nx\u271d : \u2200 (a : \u03b1), \u2191(g a) < 1\n\u22a2 0 \u2264 2 * \u2191(g a)"}, {"line": "constructor", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (hn : 0 < n) : True := by\n  fail_if_success lift n to \u2115 using hn\n  fail_if_success lift (n : Option \u2124) to \u2115\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nhn : 0 < n\n\u22a2 True"}, {"line": "fail_if_success lift n to \u2115 using hn", "tactic_state": "n : \u2124\nhn : 0 < n\n\u22a2 True"}, {"line": "fail_if_success lift (n : Option \u2124) to \u2115", "tactic_state": "n : \u2124\nhn : 0 < n\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) : \u2115 := by\n  fail_if_success lift n to \u2115\n  exact 0\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 \u2115"}, {"line": "fail_if_success lift n to \u2115", "tactic_state": "n : \u2124\n\u22a2 \u2115"}, {"line": "exact 0", "tactic_state": "No Goals!"}]}
{"declaration": "example {R : Type _} {P : R \u2192 Prop} (x : R) (hx : P x) : P x := by\n  lift x to {x // P x} using hx with y hy hx\n  guard_target =\u209b P y\n  guard_hyp hy : y = x\n  guard_hyp hx : P y\n  exact hx\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nP : R \u2192 Prop\nx : R\nhx : P x\n\u22a2 P x"}, {"line": "lift x to {x // P x} using hx with y hy hx", "tactic_state": "case intro\nR : Type u_1\nP : R \u2192 Prop\nx : R\ny : { x // P x }\nhy : \u2191y = x\nhx : P \u2191y\n\u22a2 P \u2191y"}, {"line": "guard_target =\u209b P y", "tactic_state": "case intro\nR : Type u_1\nP : R \u2192 Prop\nx : R\ny : { x // P x }\nhy : \u2191y = x\nhx : P \u2191y\n\u22a2 P \u2191y"}, {"line": "guard_hyp hy : y = x", "tactic_state": "case intro\nR : Type u_1\nP : R \u2192 Prop\nx : R\ny : { x // P x }\nhy : \u2191y = x\nhx : P \u2191y\n\u22a2 P \u2191y"}, {"line": "guard_hyp hx : P y", "tactic_state": "case intro\nR : Type u_1\nP : R \u2192 Prop\nx : R\ny : { x // P x }\nhy : \u2191y = x\nhx : P \u2191y\n\u22a2 P \u2191y"}, {"line": "exact hx", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2124) (h_ans : n = 5) (hn : 0 \u2264 1 * n) : n = 5 := by\n  lift n to \u2115 using by { simpa [Int.one_mul] using hn } with k hk\n  guard_target =\u209b (k : Int) = 5\n  guard_hyp hk : k = n\n  guard_hyp hn : 0 \u2264 1 * (k : Int)\n  guard_hyp h_ans : (k : Int) = 5\n  exact h_ans\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nh_ans : n = 5\nhn : 0 \u2264 1 * n\n\u22a2 n = 5"}, {"line": "lift n to \u2115 using by { simpa [Int.one_mul] using hn } with k hk", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nh_ans : \u2191k = 5\nhn : 0 \u2264 1 * \u2191k\n\u22a2 \u2191k = 5"}, {"line": "guard_target =\u209b (k : Int) = 5", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nh_ans : \u2191k = 5\nhn : 0 \u2264 1 * \u2191k\n\u22a2 \u2191k = 5"}, {"line": "guard_hyp hk : k = n", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nh_ans : \u2191k = 5\nhn : 0 \u2264 1 * \u2191k\n\u22a2 \u2191k = 5"}, {"line": "guard_hyp hn : 0 \u2264 1 * (k : Int)", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nh_ans : \u2191k = 5\nhn : 0 \u2264 1 * \u2191k\n\u22a2 \u2191k = 5"}, {"line": "guard_hyp h_ans : (k : Int) = 5", "tactic_state": "case intro\nn : \u2124\nk : \u2115\nhk : \u2191k = n\nh_ans : \u2191k = 5\nhn : 0 \u2264 1 * \u2191k\n\u22a2 \u2191k = 5"}, {"line": "exact h_ans", "tactic_state": "No Goals!"}]}
{"declaration": "example {x : WithTop \u2115} (hx : x \u2260 \u22a4) (P : WithTop \u2115 \u2192 Prop) (h : P x) : P x := by\n  lift x to \u2115 using hx with u hu\n  trace_state\n  exact h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/lift.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : WithTop \u2115\nhx : x \u2260 \u22a4\nP : WithTop \u2115 \u2192 Prop\nh : P x\n\u22a2 P x"}, {"line": "lift x to \u2115 using hx with u hu", "tactic_state": "case intro\nx : WithTop \u2115\nP : WithTop \u2115 \u2192 Prop\nu : \u2115\nhu : \u2191u = x\nh : P \u2191u\n\u22a2 P \u2191u"}, {"line": "trace_state", "tactic_state": "case intro\nx : WithTop \u2115\nP : WithTop \u2115 \u2192 Prop\nu : \u2115\nhu : \u2191u = x\nh : P \u2191u\n\u22a2 P \u2191u"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : (SubNegMonoid.toZSMul : SMul \u2124 \u2102) = (Complex.SMul.instSMulRealComplex : SMul \u2124 \u2102) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 SubNegMonoid.toZSMul = Complex.SMul.instSMulRealComplex"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : RestrictScalars.module \u211d \u2102 \u2102 = Complex.instModule := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 RestrictScalars.module \u211d \u2102 \u2102 = Complex.instModule"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : RestrictScalars.algebra \u211d \u2102 \u2102 = Complex.instAlgebraOfReal := by\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 RestrictScalars.algebra \u211d \u2102 \u2102 = Complex.instAlgebraOfReal"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 \u03b2 : Type _) [AddMonoid \u03b1] [AddMonoid \u03b2] :\n    (Prod.instSMul : SMul \u2115 (\u03b1 \u00d7 \u03b2)) = AddMonoid.toNatSMul := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddMonoid \u03b1\ninst\u271d : AddMonoid \u03b2\n\u22a2 Prod.instSMul = AddMonoid.toNatSMul"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 \u03b2 : Type _) [SubNegMonoid \u03b1] [SubNegMonoid \u03b2] :\n    (Prod.instSMul : SMul \u2124 (\u03b1 \u00d7 \u03b2)) = SubNegMonoid.toZSMul := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : SubNegMonoid \u03b1\ninst\u271d : SubNegMonoid \u03b2\n\u22a2 Prod.instSMul = SubNegMonoid.toZSMul"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type _) (\u03b2 : \u03b1 \u2192 Type _) [\u2200 a, AddMonoid (\u03b2 a)] :\n    (Pi.instSMul : SMul \u2115 (\u2200 a, \u03b2 a)) = AddMonoid.toNatSMul := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : (a : \u03b1) \u2192 AddMonoid (\u03b2 a)\n\u22a2 Pi.instSMul = AddMonoid.toNatSMul"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Type _) (\u03b2 : \u03b1 \u2192 Type _) [\u2200 a, SubNegMonoid (\u03b2 a)] :\n    (Pi.instSMul : SMul \u2124 (\u2200 a, \u03b2 a)) = SubNegMonoid.toZSMul := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_2\ninst\u271d : (a : \u03b1) \u2192 SubNegMonoid (\u03b2 a)\n\u22a2 Pi.instSMul = SubNegMonoid.toZSMul"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem f_apply (z w : \u2102) : f (z \u2297\u209c[\u211d] w) = z.re * w.re := by simp [f]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\nz w : \u2102\n\u22a2 sorry = z.re * w.re"}, {"line": "simp [f]", "tactic_state": "x\u271d : Sort u_1\nf : x\u271d\nz w : \u2102\n\u22a2 sorry () = z.re * w.re"}]}
{"declaration": "example (\u03b1 : Type _) [Monoid \u03b1] :\n    (Units.instMulAction : MulAction \u03b1\u02e3 (\u03b1 \u00d7 \u03b1)) = Prod.mulAction := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\n\u22a2 Units.instMulAction = Prod.mulAction"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (R \u03b1 : Type _) (\u03b2 : \u03b1 \u2192 Type _) [Monoid R] [\u2200 i, MulAction R (\u03b2 i)] :\n    (Units.instMulAction : MulAction R\u02e3 (\u2200 i, \u03b2 i)) = Pi.mulAction _ := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\n\u03b2 : \u03b1 \u2192 Type u_3\ninst\u271d\u00b9 : Monoid R\ninst\u271d : (i : \u03b1) \u2192 MulAction R (\u03b2 i)\n\u22a2 Units.instMulAction = Pi.mulAction R\u02e3"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (R \u03b1 : Type _) [Monoid R] [Semiring \u03b1] [DistribMulAction R \u03b1] :\n    (Units.instDistribMulAction : DistribMulAction R\u02e3 \u03b1[X]) = Polynomial.distribMulAction := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Monoid R\ninst\u271d\u00b9 : Semiring \u03b1\ninst\u271d : DistribMulAction R \u03b1\n\u22a2 Units.instDistribMulAction = Polynomial.distribMulAction"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : @Monoid.toMulOneClass (Multiplicative \u2115) CommMonoid.toMonoid =\n    Multiplicative.mulOneClass := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Monoid.toMulOneClass = Multiplicative.mulOneClass"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example {\u03b1} [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [Fintype \u03b1] [DecidableLT \u03b1]\n    [DecidableLE \u03b1] (p : \u03b1 \u2192 Prop) [DecidablePred p] :\n    Subtype.instLocallyFiniteOrder p = Fintype.toLocallyFiniteOrder := by\n  fail_if_success rfl\n  exact Subsingleton.elim _ _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex", "Finsupp", "scoped Polynomial", "Polynomial"], "variables": ["(R A : Type _)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.8\nA : Type ?u.11\n\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableLT \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 Subtype.instLocallyFiniteOrder p = Fintype.toLocallyFiniteOrder"}, {"line": "fail_if_success rfl", "tactic_state": "R : Type ?u.8\nA : Type ?u.11\n\u03b1 : Type u_1\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : LocallyFiniteOrder \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : DecidableLT \u03b1\ninst\u271d\u00b9 : DecidableLE \u03b1\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\n\u22a2 Subtype.instLocallyFiniteOrder p = Fintype.toLocallyFiniteOrder"}, {"line": "exact Subsingleton.elim _ _", "tactic_state": "No Goals!"}]}
{"declaration": "example :\n    @EuclideanDomain.toCommRing _ (@Field.toEuclideanDomain _ (ZMod.instField p)) =\n      ZMod.commRing p := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex", "Finsupp", "scoped Polynomial", "Polynomial"], "variables": ["(R A : Type _)", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.19\nA : Type ?u.22\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 EuclideanDomain.toCommRing = ZMod.commRing p"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : ZMod.commRing (n + 1) = Fin.instCommRing (n + 1) := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex", "Finsupp", "scoped Polynomial", "Polynomial"], "variables": ["(R A : Type _)", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.19\nA : Type ?u.22\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nn : \u2115\n\u22a2 ZMod.commRing (n + 1) = Fin.instCommRing (n + 1)"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : ZMod.commRing 0 = Int.instCommRing := by\n  with_reducible_and_instances rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/instance_diamonds.lean", "context": {"open": ["scoped Polynomial", "scoped TensorProduct", "Complex", "Finsupp", "scoped Polynomial", "Polynomial"], "variables": ["(R A : Type _)", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type ?u.19\nA : Type ?u.22\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 ZMod.commRing 0 = Int.instCommRing"}, {"line": "with_reducible_and_instances rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  refine' (by refine' .intro)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "refine' (by refine' .intro)", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "cases' a with b b <;> cases' b <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : (True \u2228 True) \u2228 (True \u2228 True)): True := by\n  cases' a with b b <;> cases' b <;> trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : (True \u2228 True) \u2228 True \u2228 True\n\u22a2 True"}, {"line": "cases' a with b b <;> cases' b <;> trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "admit", "tactic_state": "No Goals!"}]}
{"declaration": "example : False := by admit\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/DeprecatedSyntaxLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 False"}, {"line": "admit", "tactic_state": "No Goals!"}]}
{"declaration": "example : p \u2227 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : Prop\nh : p \u2227 q \u2228 p \u2227 r\n\u22a2 p \u2227 p"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x, p x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d q\u271d r\u271d : Prop\nh\u271d : p\u271d \u2227 q\u271d \u2228 p\u271d \u2227 r\u271d\n\u03b1 : Type\np q r : \u03b1 \u2192 Prop\nh : (\u2203 x, p x \u2227 q x) \u2228 \u2203 x, p x \u2227 r x\n\u22a2 \u2203 x, p x"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x, r x := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\n\u22a2 \u2203 x, r x"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) : p \u2227 True \u2194 p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2227 True \u2194 p"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) : p \u2228 False \u2194 p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2228 False \u2194 p"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : p \u2260 q) : \u00ac p \u2194 q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : p \u2260 q\n\u22a2 \u00acp \u2194 q"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac p = q) : \u00ac p \u2194 q := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00acp = q\n\u22a2 \u00acp \u2194 q"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) : p \u2228 (q \u2227 r) \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\n\u22a2 p \u2228 q \u2227 r \u2194 (p \u2228 q) \u2227 (r \u2228 p \u2228 r)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac p) : q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acp\n\u22a2 q"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : p) : \u00ac q := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : p\n\u22a2 \u00acq"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : q) : \u00ac p := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : q\n\u22a2 \u00acp"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) : p := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\n\u22a2 p"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q : Prop) (h : \u00ac (p \u2194 q)) (h' : \u00ac q) (h'' : \u00ac p) : False := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q : Prop\nh : \u00ac(p \u2194 q)\nh' : \u00acq\nh'' : \u00acp\n\u22a2 False"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) (h'' : \u00ac r) : \u00ac p := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\nh'' : \u00acr\n\u22a2 \u00acp"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) (h : p \u2194 q) (h' : r \u2194 q) : p \u2194 r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : p \u2194 q\nh' : r \u2194 q\n\u22a2 p \u2194 r"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p q r : Prop) (h : \u00ac p = q) (h' : r = q) : p \u2194 \u00ac r := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1 : Type\nx : \u03b1\np\u271d q\u271d r\u271d : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\nh\u2081 : p\u271d x\nh\u2082 : q\u271d x\np q r : Prop\nh : \u00acp = q\nh' : r = q\n\u22a2 p \u2194 \u00acr"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) : p \u2192 \u00ac (p \u2192 \u00ac p) := by tauto", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\n\u22a2 p \u2192 \u00ac(p \u2192 \u00acp)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) (em : p \u2228 \u00ac p) : \u00ac (p \u2194 \u00ac p) := by tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": [], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nem : p \u2228 \u00acp\n\u22a2 \u00ac(p \u2194 \u00acp)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (p : Prop) (h : False) : p := by\n  -- causes `h'` to have a type that's a metavariable:\n  have h' := h\n  clear h\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh : False\n\u22a2 p"}, {"line": "have h' := h", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d\u00b9 : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh\u271d : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh h' : False\n\u22a2 p"}, {"line": "clear h", "tactic_state": "p\u271d\u00b2 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b2 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d\u00b9 q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np\u271d q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p\u271d x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p\u271d x\nh\u2082 : q x\np : Prop\nh' : False\n\u22a2 p"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (P : Nat \u2192 Prop) (n : Nat) : P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac (n = 7 \u2228 n = 0) \u2227 P n := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\nP : \u2115 \u2192 Prop\nn : \u2115\n\u22a2 P n \u2192 n = 7 \u2228 n = 0 \u2228 \u00ac(n = 7 \u2228 n = 0) \u2227 P n"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : Prop\nh\u271d : p\u271d\u00b9 \u2227 q\u271d\u00b9 \u2228 p\u271d\u00b9 \u2227 r\u271d\u00b9\n\u03b1\u271d : Type\np\u271d q\u271d r\u271d : \u03b1\u271d \u2192 Prop\nh : (\u2203 x, p\u271d x \u2227 q\u271d x) \u2228 \u2203 x, p\u271d x \u2227 r\u271d x\n\u03b1 : Type\nx : \u03b1\np q r : \u03b1 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1), p x \u2192 q x \u2192 r x) \u2228 r x\nh\u2081 : p x\nh\u2082 : q x\na b c : \u2115\n\u22a2 \u00ac(\u00aca \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 a \u2264 b) \u2194 a \u2264 b \u2227 a \u2264 c \u2228 \u00aca \u2264 c \u2227 \u00aca \u2264 b"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example {x y : Nat} (h : \u00acx \u2260 y) : x = y := by\n  tauto\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Tauto.lean", "context": {"open": ["scoped Classical in"], "variables": ["(p q r : Prop)", "(h : p \u2227 q \u2228 p \u2227 r)", "(\u03b1 : Type) (p q r : \u03b1 \u2192 Prop)", "(h : (\u2203 x, p x \u2227 q x) \u2228 (\u2203 x, p x \u2227 r x))", "(\u03b1 : Type)", "(x : \u03b1)", "(p q r : \u03b1 \u2192 Prop)", "(h\u2080 : (\u2200 x, p x \u2192 q x \u2192 r x) \u2228 r x)", "(h\u2081 : p x)", "(h\u2082 : q x)", "(a b c : Nat)", "{p q r : Prop} {\u03b1 : Type} {x y : \u03b1}", "(h : x = y)", "(h'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q))", "(\u03b1 : Type)", "(x y z w : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p\u271d\u00b2 q\u271d\u00b2 r\u271d\u00b2 : Prop\nh\u271d\u00b2 : p\u271d\u00b2 \u2227 q\u271d\u00b2 \u2228 p\u271d\u00b2 \u2227 r\u271d\u00b2\n\u03b1\u271d\u00b2 : Type\np\u271d\u00b9 q\u271d\u00b9 r\u271d\u00b9 : \u03b1\u271d\u00b2 \u2192 Prop\nh\u271d\u00b9 : (\u2203 x, p\u271d\u00b9 x \u2227 q\u271d\u00b9 x) \u2228 \u2203 x, p\u271d\u00b9 x \u2227 r\u271d\u00b9 x\n\u03b1\u271d\u00b9 : Type\nx\u271d\u00b2 : \u03b1\u271d\u00b9\np\u271d q\u271d r\u271d : \u03b1\u271d\u00b9 \u2192 Prop\nh\u2080 : (\u2200 (x : \u03b1\u271d\u00b9), p\u271d x \u2192 q\u271d x \u2192 r\u271d x) \u2228 r\u271d x\u271d\u00b2\nh\u2081 : p\u271d x\u271d\u00b2\nh\u2082 : q\u271d x\u271d\u00b2\na b c : \u2115\np q r : Prop\n\u03b1\u271d : Type\nx\u271d\u00b9 y\u271d\u00b9 : \u03b1\u271d\nh\u271d : x\u271d\u00b9 = y\u271d\u00b9\nh'' : (p \u2227 q \u2194 q \u2228 r) \u2194 (r \u2227 p \u2194 r \u2228 q)\n\u03b1 : Type\nx\u271d y\u271d z w : \u03b1\nx y : \u2115\nh : \u00acx \u2260 y\n\u22a2 x = y"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : Nat) (h : x = x) : x = x := by\n  set! p := h\n  set q : x = x := p\n  apply q\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x = x\n\u22a2 x = x"}, {"line": "set! p := h", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\n\u22a2 x = x"}, {"line": "set q : x = x := p", "tactic_state": "x : \u2115\nh : x = x\np : x = x := h\nq : x = x := p\n\u22a2 x = x"}, {"line": "apply q", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by\n  set! y := x with \u2190 h2\n  set w := x\n  guard_hyp y := x\n  guard_hyp w := x\n  guard_hyp h : w + w - w = 3\n  guard_hyp h2 : w = y\n  set z := w with _h3\n  set a := 3\n  guard_target = z + z - z = a\n  set i'm_the_goal : Prop := z + z - z = a\n  guard_target = i'm_the_goal\n  apply h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x + x - x = 3\n\u22a2 x + x - x = 3"}, {"line": "set! y := x with \u2190 h2", "tactic_state": "x : \u2115\nh : x + x - x = 3\ny : \u2115 := x\nh2 : x = y\n\u22a2 x + x - x = 3"}, {"line": "set w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "guard_hyp y := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "guard_hyp w := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "guard_hyp h : w + w - w = 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "guard_hyp h2 : w = y", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nh : w + w - w = 3\nh2 : w = y\n\u22a2 w + w - w = 3"}, {"line": "set z := w with _h3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh : z + z - z = 3\nh2 : z = y\n_h3 : z = w\n\u22a2 z + z - z = 3"}, {"line": "set a := 3", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "guard_target = z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\nh : z + z - z = a\n\u22a2 z + z - z = a"}, {"line": "set i'm_the_goal : Prop := z + z - z = a", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "guard_target = i'm_the_goal", "tactic_state": "x : \u2115\ny : \u2115 := x\nw : \u2115 := x\nz : \u2115 := w\nh2 : z = y\n_h3 : z = w\na : \u2115 := 3\ni'm_the_goal : Prop := z + z - z = a\nh : i'm_the_goal\n\u22a2 i'm_the_goal"}, {"line": "apply h", "tactic_state": "No Goals!"}]}
{"declaration": "example (x : Nat) (h : x - x = 0) : x = x := by\n  set y : Nat := x\n  set! z := y + 1 with \u2190 _eq1\n  set! p : x - x = 0 := h with _eq2\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\nh : x - x = 0\n\u22a2 x = x"}, {"line": "set y : Nat := x", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\n\u22a2 y = y"}, {"line": "set! z := y + 1 with \u2190 _eq1", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\n\u22a2 y = y"}, {"line": "set! p : x - x = 0 := h with _eq2", "tactic_state": "x : \u2115\ny : \u2115 := x\nh : y - y = 0\nz : \u2115 := y + 1\n_eq1 : y + 1 = z\np : x - x = 0 := h\n_eq2 : p = h\n\u22a2 y = y"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "set g : Nat \u2192 Int := (fun \u03b5 => \u03b5) with _h", "tactic_state": "g : \u2115 \u2192 \u2124 := fun \u03b5 => \u2191\u03b5\n_h : g = fun \u03b5 => \u2191\u03b5\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example {_a _b _c _d _e _f _g _h : Nat} : 1 = 1 := by\n  set a : Nat := test with _h\n  trivial", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Set.lean", "context": {"open": ["Qq in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "_a _b _c _d _e _f _g _h : \u2115\n\u22a2 1 = 1"}, {"line": "set a : Nat := test with _h", "tactic_state": "_a _b _c _d _e _f _g _h\u271d : \u2115\na : \u2115 := sorry\n_h : a = sorry\n\u22a2 1 = 1"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "exact .intro", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9\n  exact .intro\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/HaveLetLinter.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True"}, {"line": "have \u27e8_zero, _\u27e9 : Fin 1 := \u27e80, Nat.zero_lt_one\u27e9", "tactic_state": "_zero : \u2115\nisLt\u271d : _zero < 1\n\u22a2 True"}, {"line": "exact .intro", "tactic_state": "No Goals!"}]}
{"declaration": "example : 0 = 0 := by\n  rw [] -- this goal is closed by the `rfl` implied by `rw`", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/PPRoundtrip.lean", "context": {"open": [], "variables": ["{a: Nat}", "{a :Nat}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a\u271d a : \u2115\n\u22a2 0 = 0"}, {"line": "rw [] -- this goal is closed by the `rfl` implied by `rw`", "tactic_state": "No Goals!"}]}
{"declaration": "example [AddCommGroup \u03b1] (a b : \u03b1) : a-2\u2022b = a -2\u2022b := by abel\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d : \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : \u03b1\n\u22a2 a - 2 \u2022 b = a - 2 \u2022 b"}, {"line": "abel", "tactic_state": "No Goals!"}]}
{"declaration": "example : True := by\n  have := 0\n  abel_nf\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/abel.lean", "context": {"open": [], "variables": ["{\u03b1 : Type _} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\n\u22a2 True"}, {"line": "have := 0", "tactic_state": "\u03b1 : Type ?u.9\na b : \u03b1\nthis : \u2115\n\u22a2 True"}, {"line": "abel_nf", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a] 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a] 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a] 1 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a] 1 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a] 2 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a] 2 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a] (-1) = a := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a] (-1) = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c] 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c] 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c] 1 = b := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c] 1 = b"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c] 2 = c := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c] 2 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] 1 = b := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] 1 = b"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] 2 = c := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] 2 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] 3 = d := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] 3 = d"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] 42 = c := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] 42 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d] (-2) = c := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d] (-2) = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 1 = b := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 1 = b"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 2 = c := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 2 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 3 = d := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 3 = d"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 4 = e := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 4 = e"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 5 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 5 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 6 = b := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 6 = b"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 7 = c := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 7 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 8 = d := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 8 = d"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 9 = e := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 9 = e"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 10 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 10 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 123 = d := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 123 = d"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e] 123456789 = e := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e] 123456789 = e"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e, f, g, h] 5 = f := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e, f, g, h] 5 = f"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e, f, g, h] (5 : Fin (4 + 4)) = f := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e, f, g, h] 5 = f"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e, f, g, h] 7 = h := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e, f, g, h] 7 = h"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e, f, g, h] 37 = f := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e, f, g, h] 37 = f"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example : ![a, b, c, d, e, f, g, h] 99 = d := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c d e f g h : \u03b1\n\u22a2 ![a, b, c, d, e, f, g, h] 99 = d"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {f : Fin 3 \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nf : Fin 3 \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {f : Fin 3 \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) 2 = c := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nf : Fin 3 \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 2 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {f : Fin 3 \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) (-1) = f 2 := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nf : Fin 3 \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) (-1) = f 2"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {f : Fin 3 \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) 8 = c := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nf : Fin 3 \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 8 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {n : \u2115} {f : Fin n \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) 0 = a := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nn : \u2115\nf : Fin n \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 0 = a"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {n : \u2115} {f : Fin n \u2192 \u03b1} : vecCons a (vecCons b (vecCons c f)) 2 = c := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nn : \u2115\nf : Fin n \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 2 = c"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {n : \u2115} {f : Fin n.succ \u2192 \u03b1} :\n    vecCons a (vecCons b (vecCons c f)) 3 = f 0 := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nn : \u2115\nf : Fin n.succ \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 3 = f 0"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {n : \u2115} {f : Fin n.succ \u2192 \u03b1} :\n    vecCons a (vecCons b (vecCons c f)) 3 = f 0 := by dsimp only [Matrix.cons_val]", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nn : \u2115\nf : Fin n.succ \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 3 = f 0"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b c : \u03b1} {n : \u2115} {f : Fin (n + 2) \u2192 \u03b1} :\n    vecCons a (vecCons b (vecCons c f)) 4 = f 1 := by dsimp only [Matrix.cons_val]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/vec_notation.lean", "context": {"open": ["Lean", "Lean.Meta", "Qq", "Matrix"], "variables": ["{a b c d e f g h : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na\u271d b\u271d c\u271d d e f\u271d g h a b c : \u03b1\nn : \u2115\nf : Fin (n + 2) \u2192 \u03b1\n\u22a2 vecCons a (vecCons b (vecCons c f)) 4 = f 1"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2227 d) (h2 : e \u2227 f) : True := by\n  casesm* _\u2228_, _\u2227_\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial\n  \u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d e f : Prop\nh : a \u2227 b \u2228 c \u2227 d\nh2 : e \u2227 f\n\u22a2 True"}, {"line": "casesm* _\u2228_, _\u2227_", "tactic_state": "case inl.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : a\nright\u271d : b\n\u22a2 True\n---\ncase inr.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : c\nright\u271d : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a\u203a \u2039b\u203a \u2039e\u203a \u2039f\u203a; (fail_if_success clear \u2039c\u203a); trivial", "tactic_state": "case inr.intro.intro\na b c d e f : Prop\nleft\u271d\u00b9 : e\nright\u271d\u00b9 : f\nleft\u271d : c\nright\u271d : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c\u203a \u2039d\u203a \u2039e\u203a \u2039f\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm* _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "casesm* _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c\u203a; trivial", "tactic_state": "case inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  casesm _\u2228_\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "casesm _\u2228_", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type And Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "cases_type And Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type* And -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "fail_if_success cases_type* And -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "cases_type Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inr\na b c d : Prop\nh : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  cases_type* Or\n  \u00b7 clear \u2039a \u2227 b\u203a; trivial\n  \u00b7 clear \u2039c\u203a; trivial\n  \u00b7 clear \u2039d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "cases_type* Or", "tactic_state": "case inl\na b c d : Prop\nh : a \u2227 b\n\u22a2 True\n---\ncase inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b\u203a; trivial", "tactic_state": "case inr.inl\na b c d : Prop\nh : c\n\u22a2 True\n---\ncase inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039c\u203a; trivial", "tactic_state": "case inr.inr\na b c d : Prop\nh : d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2228 c \u2228 d) : True := by\n  fail_if_success cases_type!* And Or -- no match expected\n  \u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "fail_if_success cases_type!* And Or -- no match expected", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2228 c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a \u2227 b \u2228 c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type! And Or\n  \u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "cases_type! And Or", "tactic_state": "case intro\na b c d : Prop\nh : a\nright\u271d : b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a\u203a \u2039b \u2227 (c \u2228 d)\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : a \u2227 b \u2227 (c \u2228 d)) : True := by\n  cases_type!* And Or\n  \u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : Prop\nh : a \u2227 b \u2227 (c \u2228 d)\n\u22a2 True"}, {"line": "cases_type!* And Or", "tactic_state": "case intro.intro\na b c d : Prop\nh : a\nright\u271d\u00b9 : b\nright\u271d : c \u2228 d\n\u22a2 True"}, {"line": "\u00b7 clear \u2039a\u203a \u2039b\u203a \u2039c \u2228 d\u203a; trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example : True \u2227 True \u2227 True := by\n  fail_if_success constructorm* True, _\u2228_ -- no match expected\n  guard_target = True \u2227 True \u2227 True\n  constructorm _\u2227_\n  \u00b7 guard_target = True; constructorm True\n  \u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "fail_if_success constructorm* True, _\u2228_ -- no match expected", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "guard_target = True \u2227 True \u2227 True", "tactic_state": "\u22a2 True \u2227 True \u2227 True"}, {"line": "constructorm _\u2227_", "tactic_state": "case left\n\u22a2 True\n---\ncase right\n\u22a2 True \u2227 True"}, {"line": "\u00b7 guard_target = True; constructorm True", "tactic_state": "case right\n\u22a2 True \u2227 True"}, {"line": "\u00b7 guard_target = True \u2227 True; constructorm* True, _\u2227_", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : Nat) : True := by\n  fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "fail_if_success casesm! Nat  -- two constructors, so `casesm!` doesn't fire", "tactic_state": "n : \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm! Array _\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "casesm! Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : Array Nat) : True := by\n  casesm Array _\n  -- user facing name is preserved:\n  guard_hyp h : List Nat\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "h : Array \u2115\n\u22a2 True"}, {"line": "casesm Array _", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "guard_hyp h : List Nat", "tactic_state": "case mk\nh : List \u2115\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example (h : P \u2227 Q) : True := by\n  casesm _ \u2227 _\n  -- user facing name is not used here, because there are multiple new hypotheses.\n  fail_if_success guard_hyp h : P\n  rename_i p q\n  guard_hyp p : P\n  guard_hyp q : Q\n  trivial\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/casesm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q : Prop\nh : P \u2227 Q\n\u22a2 True"}, {"line": "casesm _ \u2227 _", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "fail_if_success guard_hyp h : P", "tactic_state": "case intro\nP Q : Prop\nleft\u271d : P\nright\u271d : Q\n\u22a2 True"}, {"line": "rename_i p q", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "guard_hyp p : P", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "guard_hyp q : Q", "tactic_state": "case intro\nP Q : Prop\np : P\nq : Q\n\u22a2 True"}, {"line": "trivial", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u2115} (h : a = b) : (fun _y : \u2115 => \u2200 z, a + a = z) = (fun _x => \u2200 z, b + a = z) := by\n  congrm fun x => \u2200 w, ?_ + a = w\n  guard_hyp x : \u2115\n  guard_hyp w : \u2115\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun _y => \u2200 (z : \u2115), a + a = z) = fun _x => \u2200 (z : \u2115), b + a = z"}, {"line": "congrm fun x => \u2200 w, ?_ + a = w", "tactic_state": "a b : \u2115\nh : a = b\nx w : \u2115\n\u22a2 a = b"}, {"line": "guard_hyp x : \u2115", "tactic_state": "a b : \u2115\nh : a = b\nx w : \u2115\n\u22a2 a = b"}, {"line": "guard_hyp w : \u2115", "tactic_state": "a b : \u2115\nh : a = b\nx w : \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u03b1 \u2192 Prop) (h : \u2200 a, f a \u2194 True) : (\u2200 a : \u03b1, f a) \u2194 (\u2200 _ : \u03b1, True) := by\n  fail_if_success congrm f ?_\n  congrm \u2200 x, ?_\n  guard_hyp x : \u03b1\n  exact h x\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "fail_if_success congrm f ?_", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "congrm \u2200 x, ?_", "tactic_state": "case a\n\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\nx : \u03b1\n\u22a2 f x \u2194 True"}, {"line": "guard_hyp x : \u03b1", "tactic_state": "case a\n\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\nx : \u03b1\n\u22a2 f x \u2194 True"}, {"line": "exact h x", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u03b1 \u2192 Prop) (h : \u2200 a, f a = True) : (\u2200 a : \u03b1, f a) \u2194 (\u2200 _ : \u03b1, True) := by\n  congrm \u2200 x, $(h _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a = True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "congrm \u2200 x, $(h _)", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u03b1 \u2192 Prop) (h : \u2200 a, f a \u2194 True) : (\u2200 a : \u03b1, f a) \u2194 (\u2200 _ : \u03b1, True) := by\n  congrm \u2200 x, $(h _)\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "congrm \u2200 x, $(h _)", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 a b, f a b \u2194 True) :\n    (\u2200 a b, f a b) \u2194 (\u2200 _ _ : \u03b1, True) := by\n  congrm \u2200 x y, ?_\n  exact h x y\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a b : \u03b1), f a b \u2194 True\n\u22a2 (\u2200 (a b : \u03b1), f a b) \u2194 \u03b1 \u2192 \u03b1 \u2192 True"}, {"line": "congrm \u2200 x y, ?_", "tactic_state": "case a\n\u03b1 : Sort u_1\nf : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 (a b : \u03b1), f a b \u2194 True\nx y : \u03b1\n\u22a2 f x y \u2194 True"}, {"line": "exact h x y", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u2115} (h : a = b) : (fun y : \u2115 => y + a) = (fun x => x + b) := by\n  congrm fun x => ?_\n  guard_target = x + a = x + b\n  rw [h]\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun y => y + a) = fun x => x + b"}, {"line": "congrm fun x => ?_", "tactic_state": "a b : \u2115\nh : a = b\nx : \u2115\n\u22a2 x + a = x + b"}, {"line": "guard_target = x + a = x + b", "tactic_state": "a b : \u2115\nh : a = b\nx : \u2115\n\u22a2 x + a = x + b"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u2115} (h : a = b) : (fun y : \u2115 => y + a) = (fun x => x + b) := by\n  congrm fun (x : \u2115) => x + ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun y => y + a) = fun x => x + b"}, {"line": "congrm fun (x : \u2115) => x + ?_", "tactic_state": "a b : \u2115\nh : a = b\nx : \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) (h : a = b) (f : \u2115 \u2192 \u2115) : f a = f b := by\n  congrm f ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\nf : \u2115 \u2192 \u2115\n\u22a2 f a = f b"}, {"line": "congrm f ?_", "tactic_state": "a b : \u2115\nh : a = b\nf : \u2115 \u2192 \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c d : \u2115) (h : a = b) (h' : c = d) (f : \u2115 \u2192 \u2115 \u2192 \u2115) : f a c = f b d := by\n  congrm f ?_ ?_ <;> assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nh : a = b\nh' : c = d\nf : \u2115 \u2192 \u2115 \u2192 \u2115\n\u22a2 f a c = f b d"}, {"line": "congrm f ?_ ?_ <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) (h : a = b) (f : \u2115 \u2192 \u2115) : f (f a) = f (f b) := by\n  congrm f (f ?_)\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\nf : \u2115 \u2192 \u2115\n\u22a2 f (f a) = f (f b)"}, {"line": "congrm f (f ?_)", "tactic_state": "a b : \u2115\nh : a = b\nf : \u2115 \u2192 \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : b = c) : a = b \u2194 a = c := by\n  congrm _ = ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "congrm _ = ?_", "tactic_state": "case a\na b c : \u2115\nh : b = c\n\u22a2 b = c"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : b = c) : a = b \u2194 a = c := by\n  fail_if_success congrm b = ?_\n  congrm a = ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "fail_if_success congrm b = ?_", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "congrm a = ?_", "tactic_state": "case a\na b c : \u2115\nh : b = c\n\u22a2 b = c"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {b d : \u2115} (h : b = d) : (\u2200 a, a = b) \u2194 (\u2200 c, c = d) := by\n  congrm \u2200 a, _ = ?_\n  guard_target = b = d\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b d : \u2115\nh : b = d\n\u22a2 (\u2200 (a : \u2115), a = b) \u2194 \u2200 (c : \u2115), c = d"}, {"line": "congrm \u2200 a, _ = ?_", "tactic_state": "case a\nb d : \u2115\nh : b = d\na : \u2115\n\u22a2 b = d"}, {"line": "guard_target = b = d", "tactic_state": "case a\nb d : \u2115\nh : b = d\na : \u2115\n\u22a2 b = d"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {p q r s : Prop} (pr : p \u2194 r) (qs : q \u2194 s) : p \u2227 q \u2194 r \u2227 s := by\n  congrm ?h1 \u2227 ?h2\n  case h1 => guard_target = p \u2194 r; assumption\n  case h2 => guard_target = q \u2194 s; assumption\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r s : Prop\npr : p \u2194 r\nqs : q \u2194 s\n\u22a2 p \u2227 q \u2194 r \u2227 s"}, {"line": "congrm ?h1 \u2227 ?h2", "tactic_state": "case h1\np q r s : Prop\npr : p \u2194 r\nqs : q \u2194 s\n\u22a2 p \u2194 r\n---\ncase h2\np q r s : Prop\npr : p \u2194 r\nqs : q \u2194 s\n\u22a2 q \u2194 s"}, {"line": "case h1 => guard_target = p \u2194 r; assumption", "tactic_state": "case h2\np q r s : Prop\npr : p \u2194 r\nqs : q \u2194 s\n\u22a2 q \u2194 s"}, {"line": "case h2 => guard_target = q \u2194 s; assumption", "tactic_state": "No Goals!"}]}
{"declaration": "example {f : \u2115 \u2192 Prop} :\n    (\u2203 k, f (3 + 2 + k) \u2228 f (8 + 1 + k)) \u2194 \u2203 k, f (1 + 4 + k) \u2228 f (2 + 7 + k) := by\n  congrm (\u2203 k, f (?_ + k) \u2228 f (?_ + k))\n  \u00b7 guard_target =\u209b 3 + 2 = 1 + 4; simp\n  \u00b7 guard_target =\u209b 8 + 1 = 2 + 7; simp\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 Prop\n\u22a2 (\u2203 k, f (3 + 2 + k) \u2228 f (8 + 1 + k)) \u2194 \u2203 k, f (1 + 4 + k) \u2228 f (2 + 7 + k)"}, {"line": "congrm (\u2203 k, f (?_ + k) \u2228 f (?_ + k))", "tactic_state": "case a.refine_1\nf : \u2115 \u2192 Prop\nk : \u2115\n\u22a2 3 + 2 = 1 + 4\n---\ncase a.refine_2\nf : \u2115 \u2192 Prop\nk : \u2115\n\u22a2 8 + 1 = 2 + 7"}, {"line": "\u00b7 guard_target =\u209b 3 + 2 = 1 + 4; simp", "tactic_state": "case a.refine_2\nf : \u2115 \u2192 Prop\nk : \u2115\n\u22a2 8 + 1 = 2 + 7"}, {"line": "\u00b7 guard_target =\u209b 8 + 1 = 2 + 7; simp", "tactic_state": "No Goals!"}]}
{"declaration": "example {a b : \u2115} (h : a = b) : (fun _ : \u2115 => \u2200 z, a + a = z) = (fun _ => \u2200 z, b + a = z) := by\n  congrm fun x => \u2200 w, ?_ + a = w\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun x => \u2200 (z : \u2115), a + a = z) = fun x => \u2200 (z : \u2115), b + a = z"}, {"line": "congrm fun x => \u2200 w, ?_ + a = w", "tactic_state": "a b : \u2115\nh : a = b\nx w : \u2115\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : b = c) : a = b \u2194 a = c := by\n  fail_if_success congrm Eq ?_ ?_ ?_\n  congrm _ = ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "fail_if_success congrm Eq ?_ ?_ ?_", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "congrm _ = ?_", "tactic_state": "case a\na b c : \u2115\nh : b = c\n\u22a2 b = c"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : b = c) : a = b \u2194 a = c := by\n  congrm _ = $h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : b = c\n\u22a2 a = b \u2194 a = c"}, {"line": "congrm _ = $h", "tactic_state": "No Goals!"}]}
{"declaration": "example (f : \u03b1 \u2192 Prop) (h : \u2200 a, f a \u2194 True) : (\u2200 a : \u03b1, f a) \u2194 (\u2200 _ : \u03b1, True) := by\n  fail_if_success congrm f ?_\n  congrm \u2200 _, ?_\n  exact h _\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "fail_if_success congrm f ?_", "tactic_state": "\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\n\u22a2 (\u2200 (a : \u03b1), f a) \u2194 \u03b1 \u2192 True"}, {"line": "congrm \u2200 _, ?_", "tactic_state": "case a\n\u03b1 : Sort u_1\nf : \u03b1 \u2192 Prop\nh : \u2200 (a : \u03b1), f a \u2194 True\nx\u271d : \u03b1\n\u22a2 f x\u271d \u2194 True"}, {"line": "exact h _", "tactic_state": "No Goals!"}]}
{"declaration": "example (\u03b1 : Nat \u2192 Type) (f : (x : Nat) \u2192 \u03b1 x) (h : i = j) : HEq (f i) (f j) := by\n  congrm f ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j : \u2115\n\u03b1 : \u2115 \u2192 Type\nf : (x : \u2115) \u2192 \u03b1 x\nh : i = j\n\u22a2 HEq (f i) (f j)"}, {"line": "congrm f ?_", "tactic_state": "i j : \u2115\n\u03b1 : \u2115 \u2192 Type\nf : (x : \u2115) \u2192 \u03b1 x\nh : i = j\n\u22a2 i = j"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example (n m : Nat) (h : n = m) : foo' (2 + n) = foo' (2 + m) := by\n  fail_if_success congrm 1 + (2 + ?_)\n  cases h\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfoo' : x\u271d\nn m : \u2115\nh : n = m\n\u22a2 sorry = sorry"}, {"line": "fail_if_success congrm 1 + (2 + ?_)", "tactic_state": "x\u271d : Sort u_1\nfoo' : x\u271d\nn m : \u2115\nh : n = m\n\u22a2 sorry = sorry"}, {"line": "cases h", "tactic_state": "case refl\nx\u271d : Sort u_1\nfoo' : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : Nat) (h : a = b) : 1 + a \u2264 1 + b := by\n  congrm 1 + ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 1 + a \u2264 1 + b"}, {"line": "congrm 1 + ?_", "tactic_state": "case hxy\na b : \u2115\nh : a = b\n\u22a2 a = b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example [Fintype \u03b1] [Fintype \u03b2] (h : \u03b1 = \u03b2) : Fintype.card \u03b1 = Fintype.card \u03b2 := by\n  congrm Fintype.card ?_\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congrm.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : \u03b1 = \u03b2\n\u22a2 Fintype.card \u03b1 = Fintype.card \u03b2"}, {"line": "congrm Fintype.card ?_", "tactic_state": "\u03b1 \u03b2 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nh : \u03b1 = \u03b2\n\u22a2 \u03b1 = \u03b2"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : (2 : \u211d) ^ (3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ 3 = 8"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (1 : \u211d) ^ (20 : \u211d) = 1 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 ^ 20 = 1"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (-2 : \u211d) ^ (3 : \u211d) = -8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ 3 = -8"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (1/5 : \u211d) ^ (2 : \u211d) = 1/25 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 5) ^ 2 = 1 / 25"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (-1/3 : \u211d) ^ (-3 : \u211d) = -27 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-1 / 3) ^ (-3) = -27"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (1/2 : \u211d) ^ (-3 : \u211d) = 8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (1 / 2) ^ (-3) = 8"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (2 : \u211d) ^ (-3 : \u211d) = 1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 ^ (-3) = 1 / 8"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example : (-2 : \u211d) ^ (-3 : \u211d) = -1/8 := by norm_num1", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/norm_num_rpow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (-2) ^ (-3) = -1 / 8"}, {"line": "norm_num1", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a < \u2191b \u2194 a < b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a = \u2191b \u2194 a = b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2115) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a < \u2191b \u2194 a < b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a = \u2191b \u2194 a = b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u2124) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2264 b \u2194 a \u2264 b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2264 \u2191b \u2194 a \u2264 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) < b \u2194 a < b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a < \u2191b \u2194 a < b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) = b \u2194 a = b := by qify", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a = \u2191b \u2194 a = b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b : \u211a\u22650) : (a : \u211a) \u2260 b \u2194 a \u2260 b := by qify\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211a\u22650\n\u22a2 \u2191a \u2260 \u2191b \u2194 a \u2260 b"}, {"line": "qify", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2 -- `zify` does the same thing here.\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "qify [hab] at h \u22a2 -- `zify` does the same thing here.", "tactic_state": "a b c : \u2115\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "exact sub_eq_iff_eq_add.1 h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u211a\u22650) (h : a - b = c) (hab : b \u2264 a) : a = c + b := by\n  qify [hab] at h \u22a2\n  exact sub_eq_iff_eq_add.1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211a\u22650\nh : a - b = c\nhab : b \u2264 a\n\u22a2 a = c + b"}, {"line": "qify [hab] at h \u22a2", "tactic_state": "a b c : \u211a\u22650\nhab : b \u2264 a\nh : \u2191a - \u2191b = \u2191c\n\u22a2 \u2191a = \u2191c + \u2191b"}, {"line": "exact sub_eq_iff_eq_add.1 h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2124) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2124\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2124\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "exact (div_eq_iff hb).1 h", "tactic_state": "No Goals!"}]}
{"declaration": "example (a b c : \u2115) (h : a / b = c) (hab : b \u2223 a) (hb : b \u2260 0) : a = c * b := by\n  qify [hab] at h hb \u22a2\n  exact (div_eq_iff hb).1 h", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Qify.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a / b = c\nhab : b \u2223 a\nhb : b \u2260 0\n\u22a2 a = c * b"}, {"line": "qify [hab] at h hb \u22a2", "tactic_state": "a b c : \u2115\nhab : b \u2223 a\nh : \u2191a / \u2191b = \u2191c\nhb : \u2191b \u2260 0\n\u22a2 \u2191a = \u2191c * \u2191b"}, {"line": "exact (div_eq_iff hb).1 h", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, x = x := by\n  existsi 42\n  rfl\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x, x = x"}, {"line": "existsi 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u2203 x : Nat, \u2203 y : Nat, x = y := by\n  existsi 42, 42\n  rfl", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/ExistsI.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2203 x y, x = y"}, {"line": "existsi 42, 42", "tactic_state": "\u22a2 42 = 42"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example : Measurable fun x : \u211d => (x * x - 1) / x + (x - x*x) := by fun_prop\n\n\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/fun_prop.lean", "context": {"open": ["Mathlib"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Measurable fun x => (x * x - 1) / x + (x - x * x)"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "example : Nat := by\n  have h : Nat\n  exact 5\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "have h : Nat", "tactic_state": "case h\n\u22a2 \u2115\n---\nh : \u2115\n\u22a2 \u2115"}, {"line": "exact 5", "tactic_state": "h : \u2115\n\u22a2 \u2115"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example : Nat := by\n  have : Nat\n  \u00b7 exact 5\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2115"}, {"line": "have : Nat", "tactic_state": "case this\n\u22a2 \u2115\n---\nthis : \u2115\n\u22a2 \u2115"}, {"line": "\u00b7 exact 5", "tactic_state": "this : \u2115\n\u22a2 \u2115"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "example {a : Nat} : a = a := by\n  have h : a = a\n  \u00b7 rfl\n  exact h\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "have h : a = a", "tactic_state": "case h\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "\u00b7 rfl", "tactic_state": "a : \u2115\nh : a = a\n\u22a2 a = a"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "example {a : Nat} : a = a := by\n  have : a = a\n  \u00b7 rfl\n  exact this\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/Have.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 a = a"}, {"line": "have : a = a", "tactic_state": "case this\na : \u2115\n\u22a2 a = a\n---\na : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "\u00b7 rfl", "tactic_state": "a : \u2115\nthis : a = a\n\u22a2 a = a"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex1 (a b c : Nat) (h : a = b) : a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : a = b\n\u22a2 a + c = b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex2 (a b : Nat) (h : a = b) : \u2200 c, a + c = b + c := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 \u2200 (c : \u2115), a + c = b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex3 (a b : Nat) (h : a = b) : (fun c => a + c) = (fun c => b + c) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 (fun c => a + c) = fun c => b + c"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex4 (a b : Nat) : Fin (a + b) = Fin (b + a) := by\n  congr! 1\n  guard_target = a + b = b + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 Fin (a + b) = Fin (b + a)"}, {"line": "congr! 1", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "guard_target = a + b = b + a", "tactic_state": "case h.e'_1\na b : \u2115\n\u22a2 a + b = b + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex5 : ((a : Nat) \u2192 Fin (a + 1)) = ((a : Nat) \u2192 Fin (1 + a)) := by\n  congr! 2 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u2192 Fin (a + 1)) = ((a : \u2115) \u2192 Fin (1 + a))"}, {"line": "congr! 2 with a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "guard_target = a + 1 = 1 + a", "tactic_state": "case h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex6 : ((a : Nat) \u00d7 Fin (a + 1)) = ((a : Nat) \u00d7 Fin (1 + a)) := by\n  congr! 3 with a\n  guard_target = a + 1 = 1 + a\n  apply Nat.add_comm\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 ((a : \u2115) \u00d7 Fin (a + 1)) = ((a : \u2115) \u00d7 Fin (1 + a))"}, {"line": "congr! 3 with a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "guard_target = a + 1 = 1 + a", "tactic_state": "case h.e'_2.h.h.e'_1\na : \u2115\n\u22a2 a + 1 = 1 + a"}, {"line": "apply Nat.add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex7 (p : Prop) (h1 h2 : p) : h1 = h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\nh1 h2 : p\n\u22a2 h1 = h2"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex8 (p q : Prop) (h1 : p) (h2 : q) : HEq h1 h2 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh1 : p\nh2 : q\n\u22a2 HEq h1 h2"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex9 (a b : Nat) (h : a = b) : a + 1 \u2264 b + 1 := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\n\u22a2 a + 1 \u2264 b + 1"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex10 (x y : Unit) : x = y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : Unit\n\u22a2 x = y"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex11 (p q r : Nat \u2192 Prop) (h : q = r) : (\u2200 n, p n \u2192 q n) \u2194 (\u2200 n, p n \u2192 r n) := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u2115 \u2192 Prop\nh : q = r\n\u22a2 (\u2200 (n : \u2115), p n \u2192 q n) \u2194 \u2200 (n : \u2115), p n \u2192 r n"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex12 (p q : Prop) (h : p \u2194 q) : p = q := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\nh : p \u2194 q\n\u22a2 p = q"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex13 (x y : \u03b1) (h : x = y) (f : \u03b1 \u2192 Nat) : f x = f y := by\n  congr!\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\nx y : \u03b1\nh : x = y\nf : \u03b1 \u2192 \u2115\n\u22a2 f x = f y"}, {"line": "congr!", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ex15 (p q : Nat \u2192 Prop) :\n    (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5 := by\n  congr! 2 with \u03b5 h\u03b5\n  guard_hyp h\u03b5 : \u03b5 > 0\n  guard_target = p \u03b5 \u2194 q \u03b5\n  exact test_sorry\n", "file": "/lustre07/scratch/kevew/DuelModelResearch/mathlib4/MathlibTest/congr.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u2115 \u2192 Prop\n\u22a2 (\u2200 \u03b5 > 0, p \u03b5) \u2194 \u2200 \u03b5 > 0, q \u03b5"}, {"line": "congr! 2 with \u03b5 h\u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "guard_hyp h\u03b5 : \u03b5 > 0", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "guard_target = p \u03b5 \u2194 q \u03b5", "tactic_state": "case a.h.h'.a\np q : \u2115 \u2192 Prop\n\u03b5 : \u2115\nh\u03b5 : \u03b5 > 0\n\u22a2 p \u03b5 \u2194 q \u03b5"}, {"line": "exact test_sorry", "tactic_state": "No Goals!"}]}
