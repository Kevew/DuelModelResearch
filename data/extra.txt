{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_1 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) : \u2200 x, \u2016f x\u2016 \u2264 k :=\n  by have h : BddAbove S := \u27e81, Set.forall_mem_range.mpr hf2\u27e9\n    intro x\n    exact le_csSup h (Set.mem_range_self x)"}
{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_2 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) (hk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k) (hk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k) : k' < k :=\n  by have h\u2081 : 0 < k := by\n      obtain \u27e8x, hx\u27e9 := hf3\n      calc\n        0 < \u2016f x\u2016 := norm_pos_iff.mpr hx\n        _ \u2264 k := hk\u2081 x\n    rw [div_lt_iff\u2080]\n    \u00b7 apply lt_mul_of_one_lt_right h\u2081 hneg\n    \u00b7 exact zero_lt_one.trans hneg"}
{"context": {"open": [], "variables": []}, "declaration": "theorem imo1972_q5_have_3 (hf1 : \u2200 (x y : \u211d), f (x + y) + f (x - y) = 2 * f x * g y) (hf2 : \u2200 (y : \u211d), \u2016f y\u2016 \u2264 1) (hf3 : \u2203 x, f x \u2260 0) (y : \u211d) (hneg : 1 < \u2016g y\u2016) (S : Set \u211d := Set.range fun x => \u2016f x\u2016) (k : \u211d := sSup S) (hk\u2081 : \u2200 (x : \u211d), \u2016f x\u2016 \u2264 k) (hk\u2082 : \u2200 (x : \u211d), 2 * (\u2016f x\u2016 * \u2016g y\u2016) \u2264 2 * k) (H\u2081 : k' < k) : k \u2264 k' :=\n  by have h\u2081 : \u2203 x : \u211d, x \u2208 S := by use \u2016f 0\u2016; exact Set.mem_range_self 0\n    have h\u2082 : \u2200 x, \u2016f x\u2016 \u2264 k' := by\n      intro x\n      rw [le_div_iff\u2080]\n      \u00b7 apply (mul_le_mul_left zero_lt_two).mp (hk\u2082 x)\n      \u00b7 exact zero_lt_one.trans hneg\n    apply csSup_le h\u2081\n    rintro y' \u27e8yy, rfl\u27e9\n    exact h\u2082 yy"}
{"context": {"open": [], "variables": []}, "declaration": "theorem key_insight_have_1 (hx : x > 0) (hy : y > 0) (hz : z > 0) (h : x * y * z \u2265 1) (key : ) : ((x ^ 5 + y ^ 2 + z ^ 2) * (x ^ 3 * (x ^ 2 + y ^ 2 + z ^ 2))) \u2265 0 :=\n  by positivity"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_1 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) : p % 4 \u2260 3 :=\n  by linarith [show p % 4 = 1 from hp_mod_4_eq_1]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_2 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) : p \u2223 n ^ 2 + 1 :=\n  by refine Int.natCast_dvd_natCast.mp ?_\n    simp only [n]\n    simp only [Int.natAbs_sq]\n    simp only [Int.natCast_pow]\n    simp only [Int.natCast_succ]\n    simp only [Int.natCast_dvd_natCast.mp]\n    refine (ZMod.intCast_zmod_eq_zero_iff_dvd (m ^ 2 + 1) p).mp ?_\n    simp only [m]\n    simp only [Int.cast_pow]\n    simp only [Int.cast_add]\n    simp only [Int.cast_one]\n    simp only [ZMod.coe_valMinAbs]\n    rw [pow_two]; exact neg_add_cancel 1\n    rw [\u2190 hy]; exact neg_add_cancel 1"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_3 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) : p \u2265 2 * n :=\n  by omega"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_4 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) : p \u2223 k ^ 2 + 4 :=\n  by obtain \u27e8x, hx\u27e9 := hnat\u2081\n    have : (p : \u2124) \u2223 (k : \u2124) ^ 2 + 4 := by\n      use (p : \u2124) - 4 * n + 4 * x\n      have hcast\u2081 : (k : \u2124) = p - 2 * n := by assumption_mod_cast\n      have hcast\u2082 : (n : \u2124) ^ 2 + 1 = p * x := by assumption_mod_cast\n      linear_combination ((k : \u2124) + p - 2 * n) * hcast\u2081 + 4 * hcast\u2082\n    assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_5 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) : (p : \u211d) > 20 :=\n  by assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_6 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) : (k : \u211d) ^ 2 + 4 \u2265 p :=\n  by assumption_mod_cast"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_7 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) (hreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p) : (k : \u211d) > 4 :=\n  by refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    linarith only [hreal\u2082, hreal\u2083]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem p_lemma_have_8 (p : \u2115) (hpp : Nat.Prime p) (hp_mod_4_eq_1 : p \u2261 1 [MOD 4]) (hp_gt_20 : p > 20) (this : Fact (Nat.Prime p)) (hp_mod_4_ne_3 : p % 4 \u2260 3) (y : ZMod p) (hy : -1 = y * y) (m : \u2124 := y.valMinAbs) (n : \u2115 := m.natAbs) (hnat\u2081 : p \u2223 n ^ 2 + 1) (hnat\u2082 : n \u2264 p / 2) (hnat\u2083 : p \u2265 2 * n) (k : \u2115 := p - 2 * n) (hnat\u2084 : k = p - 2 * n) (hnat\u2085 : p \u2223 k ^ 2 + 4) (hnat\u2086 : k ^ 2 + 4 \u2265 p) (hreal\u2081 : \u2191k = \u2191p - 2 * \u2191n) (hreal\u2082 : \u2191p > 20) (hreal\u2083 : \u2191k ^ 2 + 4 \u2265 \u2191p) (hreal\u2085 : \u2191k > 4) : (k : \u211d) > sqrt (2 * n) :=\n  by refine lt_of_pow_lt_pow_left\u2080 2 k.cast_nonneg ?_\n    rw [sq_sqrt (mul_nonneg zero_le_two n.cast_nonneg)]\n    linarith only [hreal\u2081, hreal\u2083, hreal\u2085]"}
{"context": {"open": ["Real"], "variables": []}, "declaration": "theorem imo2020_q2_have_1 (hd0 : 0 < d) (hdc : d \u2264 c) (hcb : c \u2264 b) (hba : b \u2264 a) (h1 : a + b + c + d = 1) : a ^ a * b ^ b * c ^ c * d ^ d \u2264 a * a + b * b + c * c + d * d :=\n  by refine geom_mean_le_arith_mean4_weighted ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ h1 <;> linarith"}
{"context": {"open": ["Nat"], "variables": []}, "declaration": "theorem ge_100_have_1 (ProblemPredicate : x\u271d) (n : \u2115) (h1 : sorry) : 10 ^ 3 \u2264 10 * n :=\n  by rw [\u2190 h1.left]\n    refine Nat.base_pow_length_digits_le 10 n ?_ (not_zero h1)\n    simp"}
{"context": {"open": ["Nat"], "variables": []}, "declaration": "theorem lt_1000_have_1 (ProblemPredicate : x\u271d) (n : \u2115) (h1 : sorry) : n < 10 ^ 3 :=\n  by rw [\u2190 h1.left]\n    refine Nat.lt_base_pow_length_digits ?_\n    simp"}
{"context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "declaration": "theorem m_le_n_have_1 (ProblemPredicate : x\u271d) (h1 : sorry) (h2 : \u00acm \u2264 n) (h3 : 1 = (n * (n - m) - m ^ 2) ^ 2) : n * (n - m) - m ^ 2 < -1 :=\n  by nlinarith [h1.n_range.left]"}
{"context": {"open": ["Int Nat Set"], "variables": ["(N : \u2115)", "{N}"]}, "declaration": "theorem m_le_n_have_2 (ProblemPredicate : x\u271d) (h1 : sorry) (h2 : \u00acm \u2264 n) (h3 : 1 = (n * (n - m) - m ^ 2) ^ 2) (h4 : n * (n - m) - m ^ 2 < -1) : 1 < (n * (n - m) - m ^ 2) ^ 2 :=\n  by nlinarith"}
{"context": {"open": ["Function Polynomial"], "variables": []}, "declaration": "theorem Polynomial_have_1 (P : Polynomial \u2124) (t : \u2124) (ht : t \u2208 periodicPts fun x => eval x P) (C : Cycle \u2124 := Cycle.map (fun x => eval x P - x) (periodicOrbit (fun x => eval x P) t)) (HC : \u2200 {n : \u2115}, (fun x => eval x P)^[n + 1] t - (fun x => eval x P)^[n] t \u2208 C) : C.Chain (\u00b7 \u2223 \u00b7) :=\n  by rw [Cycle.chain_map]\n    rw [periodicOrbit_chain' _ ht]\n    intro n\n    convert sub_dvd_eval_sub ((fun x => P.eval x)^[n + 1] t) ((fun x => P.eval x)^[n] t) P <;>\n      rw [Function.iterate_succ_apply']"}
{"context": {"open": [], "variables": []}, "declaration": "theorem le_of_all_pow_lt_succ_have_1 (hx : 1 < x) (hy : 1 < y) (h : \u2200 (n : \u2115), 0 < n \u2192 x ^ n - 1 < y ^ n) (hxy : y < x) (hxmy : 0 < x - y) : \u2200 n : \u2115, 0 < n \u2192 (x - y) * (n : \u211d) \u2264 x ^ n - y ^ n :=\n  by intro n _\n    have hterm : \u2200 i : \u2115, i \u2208 Finset.range n \u2192 1 \u2264 x ^ i * y ^ (n - 1 - i) := by\n      intro i _\n      calc\n        1 \u2264 x ^ i := one_le_pow\u2080 hx.le\n        _ = x ^ i * 1 := by ring\n        _ \u2264 x ^ i * y ^ (n - 1 - i) := by gcongr; apply one_le_pow\u2080 hy.le\n    calc\n      (x - y) * (n : \u211d) = (n : \u211d) * (x - y) := by ring\n      _ = (\u2211 _i \u2208 Finset.range n, (1 : \u211d)) * (x - y) := by\n        simp only [mul_one]\n        simp only [Finset.sum_const]\n        simp only [nsmul_eq_mul]\n        simp only [Finset.card_range]\n      _ \u2264 (\u2211 i \u2208 Finset.range n, x ^ i * y ^ (n - 1 - i)) * (x - y) := by\n        gcongr with i hi; apply hterm i hi\n      _ = x ^ n - y ^ n := geom_sum\u2082_mul x y n"}
{"context": {"open": [], "variables": []}, "declaration": "theorem pow_f_le_f_pow_have_1 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (pn : \u2115) (hpn : 0 < pn + 1 \u2192 f (x ^ (pn + 1)) \u2264 f x ^ (pn + 1)) (hn : 0 < pn + 1 + 1) : 0 < x :=\n  by positivity"}
{"context": {"open": [], "variables": []}, "declaration": "theorem fixed_point_of_gt_1_have_1 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (H5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x) (a : \u211a) (ha1 : 1 < a) (hae : f a = \u2191a) (N : \u2115) (hN : 1 + x < a ^ N) (h_big_enough : 1 < a ^ N - x) (h1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)) : 0 < x :=\n  by positivity"}
{"context": {"open": [], "variables": []}, "declaration": "theorem fixed_point_of_gt_1_have_2 (f : \u211a \u2192 \u211d) (x : \u211a) (hx : 1 < x) (H1 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f (x * y) \u2264 f x * f y) (H2 : \u2200 (x y : \u211a), 0 < x \u2192 0 < y \u2192 f x + f y \u2264 f (x + y)) (H4 : \u2200 (n : \u2115), 0 < n \u2192 \u2191n \u2264 f \u2191n) (H5 : \u2200 (x : \u211a), 1 < x \u2192 \u2191x \u2264 f x) (a : \u211a) (ha1 : 1 < a) (hae : f a = \u2191a) (N : \u2115) (hN : 1 + x < a ^ N) (h_big_enough : 1 < a ^ N - x) (h1 : \u2191x + \u2191(a ^ N - x) \u2264 f x + f (a ^ N - x)) (hxp : 0 < x) : 0 < N :=\n  by_contra! H; rw [Nat.le_zero.mp H] at hN; linarith"}
{"context": {"open": ["scoped Finset"], "variables": ["{a : \u2115 \u2192 \u2115} {N : \u2115} (hc : Condition a N)"]}, "declaration": "theorem exists_infinite_setOf_apply_eq_have_1 (Condition : ?m.433) (N : \u2115) (hc : sorry) (a : \u2115 \u2192 \u2115) (hi : \u00ac\u2203 m, {i | a i = m}.Infinite) : (Set.range a).Infinite :=\n  by contrapose! hi with hr\n    rw [Set.not_infinite] at hr\n    rw [\u2190 Set.finite_coe_iff] at hr\n    obtain \u27e8n, hn\u27e9 := Finite.exists_infinite_fiber (Set.rangeFactorization a)\n    rw [Set.infinite_coe_iff] at hn\n    rw [Set.preimage] at hn\n    simp only [Set.mem_singleton_iff] at hn\n    simp only [Set.rangeFactorization] at hn\n    simp only [Subtype.ext_iff] at hn\n    exact \u27e8\u2191n, hn\u27e9"}
{"context": {"open": ["MiuAtom"], "variables": []}, "declaration": "theorem my_theorem_have_1 (Derivable : x\u271d) : Derivable \"MII\" :=\n  by change Derivable (M :: [I] ++ [I])\n    exact Derivable.r2 Derivable.mk"}
{"context": {"open": ["MiuAtom"], "variables": []}, "declaration": "theorem my_theorem_have_2 (Derivable : x\u271d) (h\u2082 : sorry) : Derivable \"MIIII\" :=\n  by change Derivable (M :: [I, I] ++ [I, I])\n    exact Derivable.r2 h\u2082"}
{"context": {"open": ["SetTheory PGame"], "variables": []}, "declaration": "theorem star_sq_have_1  : star * star \u2264 star :=\n  by rw [le_iff_forall_lf]\n    constructor <;>\n    intro i\n    \u00b7 apply leftMoves_mul_cases i <;>\n      intro _ _\n      case' hl => rw [mul_moveLeft_inl]\n      case' hr => rw [mul_moveLeft_inr]\n      all_goals rw [lf_iff_game_lf]; simpa using zero_lf_star\n    \u00b7 refine lf_zero.2 \u27e8toRightMovesMul (Sum.inl default), ?_\u27e9\n      rintro (j | j) <;> -- Instance can't be inferred otherwise.\n      exact isEmptyElim j"}
{"context": {"open": ["scoped Pointwise", "QuotientGroup", "CategoryTheory", "XWithInfinity Equiv.Perm"], "variables": ["{A : Type u} {B : Type v}", "[Group A] [Group B]", "[CommGroup A] [CommGroup B]", "{A B : Grp.{u}} (f : A \u27f6 B)", "{A B : AddGrp.{u}} (f : A \u27f6 B)"]}, "declaration": "theorem epi_iff_surjective_have_1 (f : A \u27f6 B) : Epi f \u2194 Epi (groupAddGroupEquivalence.inverse.map f) :=\n  by refine \u27e8?_, groupAddGroupEquivalence.inverse.epi_of_epi_map\u27e9\n    intro e'\n    apply groupAddGroupEquivalence.inverse.map_epi"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_1 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) : IsNilpotent (LinearMap.mulLeft R a) :=\n  by rwa [LinearMap.isNilpotent_mulLeft_iff]"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_2 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) (hl : sorry) : IsNilpotent (LinearMap.mulRight R a) :=\n  by rwa [LinearMap.isNilpotent_mulRight_iff]"}{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_1 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) : IsNilpotent (LinearMap.mulLeft R a) :=\n  by rwa [LinearMap.isNilpotent_mulLeft_iff]"}
{"context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "declaration": "theorem _root__have_2 (R : Type u) (A : Type v) (a : A) (h : _root_.IsNilpotent a) (hl : sorry) : IsNilpotent (LinearMap.mulRight R a) :=\n  by rwa [LinearMap.isNilpotent_mulRight_iff]"}
{"context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] {a b : R} {m n : \u2115}"]}, "declaration": "theorem finset_image_add_have_1 (R : Type u_1) (F : Type u_2) (\u03b1 : Type u_3) (\u03b2 : Type u_4) (f : F) (hna : IsNonarchimedean \u21d1f) (g : \u03b2 \u2192 \u03b1) (t : Finset \u03b2) : t.Nonempty \u2194 t.val \u2260 0 :=\n  by simp [Finset.nonempty_iff_ne_empty]"}
{"context": {"open": ["Polynomial", "Finset in", "EuclideanDomain"], "variables": ["{R : Type u} {S : Type v} {k : Type y} {A : Type z} {a b : R} {n : \u2115}", "[CommRing R]", "[CommRing R] [IsDomain R]", "[NormalizationMonoid R]", "[DivisionRing R] {p q : R[X]}", "[Field R] {p q : R[X]}"]}, "declaration": "theorem divByMonic_add_X_sub_C_mul_derivate_divByMonic_eq_derivative_have_1 (K : Type u_1) (f : Polynomial K) (a : K) : key :=\n  by apply congrArg derivative <| X_sub_C_mul_divByMonic_eq_sub_modByMonic f a"}
{"context": {"open": ["Polynomial", "Finsupp Finset", "scoped Function -- required for scoped `on` notation"], "variables": ["{R : Type u} {S : Type v} {\u03b9 : Type w} {a b : R} {m n : \u2115}", "[Semiring R] {p q r : R[X]}", "[Semiring S]"]}, "declaration": "theorem natDegree_map_eq_iff_have_1 (R : Type u) (S : Type v) (f : R \u2192+* S) (p : Polynomial R) (h : sorry \u2260 0) : p \u2260 0 :=\n  by rintro rfl; simp at h"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_1 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) : 0 < p :=\n  by positivity"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_2 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) (hp_pos : 0 < p) : 0 \u2264 p :=\n  by positivity"}
{"context": {"open": ["Finset NNReal ENNReal"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem rpow_arith_mean_le_arith_mean_rpow_have_3 (\u03b9 : Type u) (s : Finset \u03b9) (p : \u211d) (hp : 1 \u2264 p) (hp_pos : 0 < p) (hp_nonneg : 0 \u2264 p) : \u00acp < 0 :=\n  by simp [hp_nonneg]"}
{"context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem inner_le_Lp_mul_Lq_tsum_have_1 (\u03b9 : Type u) (hpq : p.HolderConjugate q) (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) : \u2211 i \u2208 s, f i * g i \u2264 (\u2211' i, f i ^ p) ^ (1 / p) * (\u2211' i, g i ^ q) ^ (1 / q) :=\n  by intro s\n    refine le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul ?_ ?_ bot_le bot_le)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]\n      exact hf.sum_le_tsum _ (fun _ _ => zero_le _)\n    \u00b7 rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]\n      exact hg.sum_le_tsum _ (fun _ _ => zero_le _)"}
{"context": {"open": ["Finset NNReal ENNReal", "scoped BigOperators"], "variables": ["{\u03b9 : Type u} (s : Finset \u03b9)"]}, "declaration": "theorem Lp_add_le_tsum_have_1 (\u03b9 : Type u) (p : \u211d) (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ p) (pos : 0 < p) : ((\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p)) ^ p :=\n  by intro s\n    rw [one_div]\n    rw [\u2190 NNReal.rpow_inv_le_iff pos]\n    rw [\u2190 one_div]\n    refine le_trans (Lp_add_le s f g hp) (add_le_add ?_ ?_) <;>\n        rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr pos)] <;>\n      refine Summable.sum_le_tsum _ (fun _ _ => zero_le _) ?_\n    exacts [hf, hg]"}
{"context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "declaration": "theorem hasMellin_one_Ioc_have_1 (s : \u2102) (hs : 0 < s.re) : -1 < (s - 1).re :=\n  by simpa only [sub_re,one_re,sub_eq_add_neg] using lt_add_of_pos_left _ hs"}
{"context": {"open": ["MeasureTheory Set Filter Asymptotics TopologicalSpace", "Real", "Complex hiding exp log abs_of_nonneg", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{E : Type*} [NormedAddCommGroup E]"]}, "declaration": "theorem hasMellin_one_Ioc_have_2 (s : \u2102) (hs : 0 < s.re) (aux1 : -1 < (s - 1).re) : s \u2260 0 :=\n  by contrapose! hs; rw [hs, zero_re]"}
{"context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "declaration": "theorem uniform_oscillationWithin_have_1 (E : Type u) (F : Type v) (K : Set E) (f : E \u2192 F) (D : Set E) (\u03b5 : ENNReal) (comp : IsCompact K) (hK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5) (S : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}) : \u2200 r > 0, IsOpen (S r) :=\n  by refine fun r _ \u21a6 isOpen_iff.mpr fun x \u27e8a, ar, ha\u27e9 \u21a6\n      \u27e8ENNReal.ofReal ((a - r) / 2), by simp [ar], ?_\u27e9\n    refine fun y hy \u21a6 \u27e8a - (a - r) / 2, by linarith,\n      le_trans (diam_mono (image_mono fun z hz \u21a6 ?_)) ha\u27e9\n    refine \u27e8lt_of_le_of_lt (edist_triangle z y x) (lt_of_lt_of_eq (ENNReal.add_lt_add hz.1 hy) ?_),\n      hz.2\u27e9\n    rw [\u2190 ofReal_add (by linarith) (by linarith)]\n    rw [sub_add_cancel]"}
{"context": {"open": ["Topology EMetric Set ENNReal"], "variables": ["{E : Type u} {F : Type v} [PseudoEMetricSpace F]", "[PseudoEMetricSpace E] {K : Set E}", "{f : E \u2192 F} {D : Set E} {\u03b5 : ENNReal}"]}, "declaration": "theorem uniform_oscillationWithin_have_2 (E : Type u) (F : Type v) (K : Set E) (f : E \u2192 F) (D : Set E) (\u03b5 : ENNReal) (comp : IsCompact K) (hK : \u2200 x \u2208 K, oscillationWithin f D x < \u03b5) (S : \u211d \u2192 Set E := fun r => {x | \u2203 a > r, sorry \u2264 \u03b5}) (S_open : \u2200 r > 0, sorry) : K \u2286 \u22c3 r > 0, S r :=\n  by intro x hx\n    have : oscillationWithin f D x < \u03b5 := hK x hx\n    simp only [oscillationWithin] at this\n    simp only [Filter.mem_map] at this\n    simp only [iInf_lt_iff] at this\n    obtain \u27e8n, hn\u2081, hn\u2082\u27e9 := this\n    obtain \u27e8r, r0, hr\u27e9 := mem_nhdsWithin_iff.1 hn\u2081\n    simp only [gt_iff_lt]\n    simp only [mem_iUnion]\n    simp only [exists_prop]\n    have : \u2200 r', (ENNReal.ofReal r') \u2264 r \u2192 diam (f '' (ball x (ENNReal.ofReal r') \u2229 D)) \u2264 \u03b5 := by\n      intro r' hr'\n      refine le_trans (diam_mono (subset_trans ?_ (image_subset_iff.2 hr))) (le_of_lt hn\u2082)\n      exact image_mono (inter_subset_inter_left D (ball_subset_ball hr'))\n    by_cases r_top : r = \u22a4\n    \u00b7 use 1, one_pos, 2, one_lt_two, this 2 (by simp only [r_top, le_top])\n    \u00b7 obtain \u27e8r', hr'\u27e9 := exists_between (toReal_pos (ne_of_gt r0) r_top)\n      use r', hr'.1, r.toReal, hr'.2, this r.toReal ofReal_toReal_le"}
{"context": {"open": ["Filter Finset", "NNReal in", "Finset", "ENNReal in", "ENNReal in", "NNReal in"], "variables": ["{M : Type*} [AddCommMonoid M] [PartialOrder M] [IsOrderedAddMonoid M]", "{u : \u2115 \u2192 \u2115} {f : \u2115 \u2192 \u211d\u22650\u221e}"]}, "declaration": "theorem summable_condensed_iff_of_nonneg_have_1 (f : \u2115 \u2192 \u211d) (h_nonneg : \u2200 (n : \u2115), 0 \u2264 f n) (h_mono : \u2200 \u2983m n : \u2115\u2984, 0 < m \u2192 m \u2264 n \u2192 f n \u2264 f m) : SuccDiffBounded 2 (2 ^ \u00b7) :=\n  by intro n\n    simp [pow_succ, mul_two, two_mul]"}
{"context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "declaration": "theorem AntitoneOn_have_1 (x\u2080 : \u211d) (a : \u2115) (f : \u211d \u2192 \u211d) (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))) : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) :=\n  by intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]"}
{"context": {"open": ["Set MeasureTheory MeasureSpace"], "variables": ["{x\u2080 : \u211d} {a b : \u2115} {f g : \u211d \u2192 \u211d}"]}, "declaration": "theorem AntitoneOn_have_1 (x\u2080 : \u211d) (a : \u2115) (f : \u211d \u2192 \u211d) (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + \u2191a))) : \u2200 k : \u2115, k < a \u2192 IntervalIntegrable f volume (x\u2080 + k) (x\u2080 + (k + 1 : \u2115)) :=\n  by intro k hk\n    refine (hf.mono ?_).intervalIntegrable\n    rw [uIcc_of_le]\n    \u00b7 apply Icc_subset_Icc\n      \u00b7 simp only [le_add_iff_nonneg_right, Nat.cast_nonneg]\n      \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.succ_le_of_lt hk]\n    \u00b7 simp only [add_le_add_iff_left, Nat.cast_le, Nat.le_succ]"}
{"context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "declaration": "theorem tendsto_atTop_of_linGrowthInf_pos_have_1 (v : \u2115 \u2192 \u2115) (h : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0) (M : \u2115) (a : EReal) (a_0 : 0 < a) (a_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop) : \u2200\u1da0 n : \u2115 in atTop, M \u2264 a * n :=\n  by obtain \u27e8n, hn\u27e9 := EReal.exists_nat_ge_mul a.inv_lt_top.ne M\n    rw [\u2190 EReal.div_eq_inv_mul] at hn\n    rw [EReal.div_le_iff_le_mul a_0 (ne_top_of_lt a_v)] at hn\n    refine eventually_atTop.2 \u27e8n, fun k k_n \u21a6 ?_\u27e9\n    exact hn.trans (mul_le_mul_of_nonneg_left (Nat.cast_le.2 k_n) a_0.le)"}
{"context": {"open": ["ENNReal EReal Filter Function Set", "scoped Topology"], "variables": ["{u v : \u2115 \u2192 \u211d\u22650\u221e} {a : EReal} {b : \u211d\u22650\u221e}", "{u : \u2115 \u2192 \u211d\u22650\u221e} {v : \u2115 \u2192 \u2115}"]}, "declaration": "theorem tendsto_atTop_of_linGrowthInf_pos_have_2 (v : \u2115 \u2192 \u2115) (h : liminf (fun n => \u2191(v n) / \u2191n) atTop \u2260 0) (M : \u2115) (a : EReal) (a_0 : 0 < a) (a_v : a < liminf (fun n => \u2191(v n) / \u2191n) atTop) (h\u2081 : \u2200\u1da0 (n : \u2115) in atTop, \u2191M \u2264 a * \u2191n) : \u2200\u1da0 n : \u2115 in atTop, a * n \u2264 v n :=\n  by refine (eventually_lt_of_lt_liminf a_v).mp (eventually_atTop.2 \u27e81, fun n n_1 a_vn \u21a6 ?_\u27e9)\n    rw [lt_div_iff (Nat.cast_pos'.2 n_1) (natCast_ne_top n)] at a_vn\n    exact a_vn.le"}
{"context": {"open": ["Filter Set", "scoped Filter Topology Pointwise"], "variables": ["{a b : \u211d} {l : Filter \u211d} {f f' g g' : \u211d \u2192 \u211d}"]}, "declaration": "theorem lhopital_zero_right_on_Ioo_have_1 (l : Filter \u211d) (hab : a < b) (hfa : Tendsto f (nhdsWithin a (Ioi a)) (nhds 0)) (hga : Tendsto g (nhdsWithin a (Ioi a)) (nhds 0)) (hdiv : Tendsto (fun x => f' x / g' x) (nhdsWithin a (Ioi a)) l) (sub : \u2200 x \u2208 Ioo a b, Ioo a x \u2286 Ioo a b) : \u2200 x \u2208 Ioo a b, g x \u2260 0 :=\n  by intro x hx h\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd 0) := by\n      rw [\u2190 h]\n      rw [\u2190 nhdsWithin_Ioo_eq_nhdsLT hx.1]\n      exact ((hgg' x hx).continuousAt.continuousWithinAt.mono <| sub x hx).tendsto\n    obtain \u27e8y, hyx, hy\u27e9 : \u2203 c \u2208 Ioo a x, g' c = 0 :=\n      exists_hasDerivAt_eq_zero' hx.1 hga this fun y hy => hgg' y <| sub x hx hy\n    exact hg' y (sub x hx hyx) hy"}
{"context": {"open": ["scoped Interval Topology Nat", "Set"], "variables": ["{\ud835\udd5c E F : Type*}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "declaration": "theorem taylor_mean_remainder_cauchy_have_1 (f : \u211d \u2192 \u211d) (n : \u2115) (hx : x\u2080 < x) (hf : ContDiffOn \u211d (\u2191n) f (Icc x\u2080 x)) : ContinuousOn id (Icc x\u2080 x) :=\n  by fun_prop"}
{"context": {"open": ["Filter Asymptotics Set", "scoped ENNReal Topology", "FormalMultilinearSeries", "Finset in"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type v} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{p : FormalMultilinearSeries \ud835\udd5c E F} {r : \u211d\u22650\u221e} {n : \u2115}", "{f : E \u2192 F} {x : E} {s : Set E}", "{p : FormalMultilinearSeries \ud835\udd5c \ud835\udd5c F} {r : \u211d\u22650\u221e}", "{f : \ud835\udd5c \u2192 F} {x : \ud835\udd5c} {s : Set \ud835\udd5c}", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)] [\u2200 i, NormedSpace \ud835\udd5c (E i)]", "{n : WithTop \u2115\u221e} (x : \u2200 i, E i)"]}, "declaration": "theorem _root__have_1 (\u03b9 : Type u_1) (n : \u2115) (e : Fin (n + 1) \u21aa \u03b9) (j : Fin (n + 1)) : j \u2260 0 :=\n  by rintro rfl\n    simp at h'k"}
{"context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne_have_1 (E : Type u_1) (x : \u211d) (f_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y) (hf : ContinuousAt f x) (hg : ContinuousAt g x) : HasDerivWithinAt f (g x) (Ici x) x :=\n  by have diff : DifferentiableOn \u211d f (Ioi x) := fun y hy =>\n      (f_diff y (ne_of_gt hy)).differentiableAt.differentiableWithinAt\n    apply\n      hasDerivWithinAt_Ici_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[>] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_gt hy)).deriv.symm"}
{"context": {"open": ["Filter Set Metric ContinuousLinearMap", "scoped Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {F : Type*} [NormedAddCommGroup F]"]}, "declaration": "theorem hasDerivAt_of_hasDerivAt_of_ne_have_2 (E : Type u_1) (x : \u211d) (f_diff : \u2200 (y : \u211d), y \u2260 x \u2192 HasDerivAt f (g y) y) (hf : ContinuousAt f x) (hg : ContinuousAt g x) (A : sorry) : HasDerivWithinAt f (g x) (Iic x) x :=\n  by have diff : DifferentiableOn \u211d f (Iio x) := fun y hy =>\n      (f_diff y (ne_of_lt hy)).differentiableAt.differentiableWithinAt\n    apply\n      hasDerivWithinAt_Iic_of_tendsto_deriv diff hf.continuousWithinAt\n        self_mem_nhdsWithin\n    have : Tendsto g (\ud835\udcdd[<] x) (\ud835\udcdd (g x)) := tendsto_inf_left hg\n    apply this.congr' _\n    apply mem_of_superset self_mem_nhdsWithin fun y hy => _\n    intros y hy\n    exact (f_diff y (ne_of_lt hy)).deriv.symm"}
{"context": {"open": ["Set", "scoped NNReal"], "variables": []}, "declaration": "theorem exists_homeomorph_extension_have_1 (E : Type u_1) (F : Type u_2) (s : Set E) (f : E \u2192 F) (c : NNReal) (hf : ApproximatesLinearOn f (\u2191f') s c) (hc : Subsingleton E \u2228 lipschitzExtensionConstant F * c < \u2016\u2191f'.symm\u2016\u208a\u207b\u00b9) (u : E \u2192 F) (hu : sorry) (uf : EqOn sorry u s) (g : E \u2192 F := fun x => sorry) (fg : EqOn f g s) : ApproximatesLinearOn g (f' : E \u2192L[\u211d] F) univ (lipschitzExtensionConstant F * c) :=\n  by apply LipschitzOnWith.approximatesLinearOn\n    rw [lipschitzOnWith_univ]\n    convert hu\n    ext x\n    simp only [g]\n    simp only [add_sub_cancel_left]\n    simp only [ContinuousLinearEquiv.coe_coe]\n    simp only [Pi.sub_apply]"}
{"context": {"open": ["scoped Topology Filter ENNReal NNReal", "Filter Asymptotics Set"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c)", "{E : Type*} [AddCommGroup E] [Module \ud835\udd5c E]", "{\ud835\udd5c}", "{f f\u2081 : E \u2192 F} {f' f\u2080' f\u2081' : F} {s t : Set E} {x v : E}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "declaration": "theorem Filter_have_1 (\ud835\udd5c : Type u_1) (F : Type u_2) (E : Type u_3) (s : Set E) (hs : f\u2081 =\u1da0[sorry] f) (hx : f\u2081 x = f x) : Continuous (fun (t : \ud835\udd5c) \u21a6 x + t \u2022 v) :=\n  by fun_prop"}
{"context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "declaration": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm_have_1 (E : Type u) (f : E \u2192 \u2102) (c : E) (hf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) (h : \u00acf c = 0) (h1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0) (h2 : sorry) : IsLocalMax (norm \u2218 f\u207b\u00b9) c :=\n  by refine h2.congr (Eventually.of_forall ?_); simp"}
{"context": {"open": ["TopologicalSpace Metric Set Filter Asymptotics Function MeasureTheory AffineMap Bornology", "scoped Topology Filter NNReal Real"], "variables": ["{E : Type u} [NormedAddCommGroup E] [NormedSpace \u2102 E] {F : Type v} [NormedAddCommGroup F]", "[StrictConvexSpace \u211d F]"]}, "declaration": "theorem eventually_eq_or_eq_zero_of_isLocalMin_norm_have_2 (E : Type u) (f : E \u2192 \u2102) (c : E) (hf : \u2200\u1da0 (z : E) in nhds c, DifferentiableAt \u2102 f z) (hc : IsLocalMin (norm \u2218 f) c) (h : \u00acf c = 0) (h1 : \u2200\u1da0 (z : E) in sorry, f z \u2260 0) (h2 : sorry) (h3 : sorry) : \u2200\u1da0 z in \ud835\udcdd c, DifferentiableAt \u2102 f\u207b\u00b9 z :=\n  by filter_upwards [hf, h1] with z h using h.inv"}
{"context": {"open": ["Filter Finset", "scoped Topology", "Real"], "variables": []}, "declaration": "theorem stolzCone_subset_stolzSet_aux_have_1 (hx\u2080 : 0 < x) (hx\u2081 : x < 1 / (1 + s ^ 2)) (hy : |y| < s * x) : sqrt ((1 - x) ^ 2 + y ^ 2) \u2264 1 - x / 2 :=\n  by calc sqrt ((1 - x) ^ 2 + y ^ 2)\n      _ \u2264 sqrt ((1 - x) ^ 2 + (s * x) ^ 2) := sqrt_le_sqrt <| by rw [\u2190 sq_abs y]; gcongr\n      _ = sqrt (1 - 2 * x + (1 + s ^ 2) * x * x) := by congr 1; ring\n      _ \u2264 sqrt (1 - 2 * x + (1 + s ^ 2) * (1 / (1 + s ^ 2)) * x) := sqrt_le_sqrt <| by gcongr\n      _ = sqrt (1 - x) := by congr 1; field_simp; ring\n      _ \u2264 1 - x / 2 := by\n        simp_rw [sub_eq_add_neg, \u2190 neg_div]\n        refine sqrt_one_add_le <| neg_le_neg_iff.mpr (hx\u2081.trans_le ?_).le\n        rw [div_le_one (by positivity)]\n        exact le_add_of_nonneg_right <| sq_nonneg s"}
{"context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "declaration": "theorem le_gronwallBound_of_liminf_deriv_right_le_have_1 (hf : ContinuousOn f (Icc a b)) (ha : f a \u2264 \u03b4) (bound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5) : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a) :=\n  by intro x hx \u03b5' h\u03b5'\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'\n    \u00b7 rwa [sub_self, gronwallBound_x0]\n    \u00b7 exact fun x => hasDerivAt_gronwallBound_shift \u03b4 K \u03b5' x a\n    \u00b7 intro x hx hfB\n      rw [\u2190 hfB]\n      apply lt_of_le_of_lt (bound x hx)\n      exact add_lt_add_left (mem_Ioi.1 h\u03b5') _\n    \u00b7 exact hx"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval"], "variables": []}, "declaration": "theorem bernstein_nonneg_have_1 (x : \u2191unitInterval) : (0 : \u211d) \u2264 x :=\n  by unit_interval"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval"], "variables": []}, "declaration": "theorem bernstein_nonneg_have_2 (x : \u2191unitInterval) (h\u2081 : 0 \u2264 \u2191x) : (0 : \u211d) \u2264 1 - x :=\n  by unit_interval"}
{"context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function", "bernstein", "bernsteinApproximation", "BoundedContinuousFunction", "Filter", "scoped Topology"], "variables": []}, "declaration": "theorem bernsteinApproximation_uniform_have_1 (f : C(\u2191unitInterval, \u211d)) (\u03b5 : \u211d) (h : 0 < \u03b5) (\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h) (nhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)) (n : \u2115) (nh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2) : 0 < (n : \u211d) :=\n  by positivity"}
{"context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "declaration": "theorem integrableOn_Ioi_deriv_ofReal_cpow_have_1 (s : \u2102) (t : \u211d) (ht : 0 < t) (hs : s.re < 0) : IntegrableOn (fun x : \u211d \u21a6 s * x ^ (s - 1)) (Set.Ioi t) :=\n  by refine (integrableOn_Ioi_cpow_of_lt ?_ ht).const_mul _\n    rwa [Complex.sub_re, Complex.one_re, sub_lt_iff_lt_add, neg_add_cancel]"}
{"context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology"], "variables": []}, "declaration": "theorem polarCoord_source_ae_eq_univ_have_1  : polarCoord.source\u1d9c \u2286 LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) :=\n  by intro x hx\n    simp only [polarCoord_source] at hx\n    simp only [compl_union] at hx\n    simp only [mem_inter_iff] at hx\n    simp only [mem_compl_iff] at hx\n    simp only [mem_setOf_eq] at hx\n    simp only [not_lt] at hx\n    simp only [Classical.not_not] at hx\n    exact hx.2"}
{"context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "declaration": "theorem inv_Gamma\u211d_one_sub_have_1 (s : \u2102) (hs : \u2200 (n : \u2115), s \u2260 -\u2191n) : Gamma\u211d s \u2260 0 :=\n  by rw [Ne]\n    rw [Gamma\u211d_eq_zero_iff]\n    rw [not_exists]\n    intro n h\n    specialize hs (2 * n)\n    simp_all"}
{"context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "declaration": "theorem inv_Gamma\u211d_one_sub_have_2 (s : \u2102) (hs : \u2200 (n : \u2115), s \u2260 -\u2191n) (h1 : s.Gamma\u211d \u2260 0) : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1) :=\n  by intro n h\n    specialize hs (2 * n + 1)\n    simp_all"}
{"context": {"open": ["Filter Set MeasureTheory", "scoped Nat ENNReal Topology Real"], "variables": ["{f : \u211d \u2192 \u211d} {x : \u211d} {n : \u2115}"]}, "declaration": "theorem f_add_nat_ge_have_1 (f : \u211d \u2192 \u211d) (x : \u211d) (n : \u2115) (log : x\u271d) (hf_conv : ConvexOn \u211d (Ioi 0) f) (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry) (hn : 2 \u2264 n) (hx : 0 < x) : 0 < (n : \u211d) - 1 :=\n  by rw [\u2190 Nat.cast_one, sub_pos, Nat.cast_lt]; omega"}
{"context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "declaration": "theorem integral_gaussian_complex_have_1 (b : \u2102) (hb : 0 < b.re) : \u2200 {b : \u2102}, 0 < re b \u2192 b \u2260 0 :=\n  by intro b hb; contrapose! hb; rw [hb]; simp"}
{"context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "declaration": "theorem log_b_ne_zero_have_1 (log : x\u271d) : b \u2260 0 :=\n  by linarith"}
{"context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "declaration": "theorem log_b_ne_zero_have_2 (log : x\u271d) (b_ne_zero : sorry \u2260 0) : b \u2260 -1 :=\n  by linarith"}
{"context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "declaration": "theorem quadratic_root_cos_pi_div_five_have_1 (\u03b8 : \u2115 := sorry / 5) (h\u03b8 : \u03b8 = sorry / 5) (c : \u211d := cos \u2191\u03b8) (s : \u211d := sin \u2191\u03b8) : s \u2260 0 :=\n  by rw [ne_eq]\n    rw [sin_eq_zero_iff]\n    rw [h\u03b8]\n    push_neg\n    intro n hn\n    replace hn : n * 5 = 1 := by field_simp [mul_comm _ \u03c0, mul_assoc] at hn; norm_cast at hn\n    omega"}
{"context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "declaration": "theorem tan_pi_div_four_have_1  : \u221a2 / 2 > 0 :=\n  by positivity"}
{"context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "declaration": "theorem tendsto_integral_cos_pow_mul_div_have_1 (f : \u211d \u2192 \u2102) (hf : ContinuousOn f (Icc 0 (Real.pi / 2))) (c_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0) (c_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x) : 0 < cos 0 :=\n  by rw [cos_zero]; exact zero_lt_one"}
{"context": {"open": ["scoped Real Topology", "Real Set Filter intervalIntegral MeasureTheory.MeasureSpace"], "variables": ["{z : \u2102} {n : \u2115}"]}, "declaration": "theorem tendsto_integral_cos_pow_mul_div_have_2 (f : \u211d \u2192 \u2102) (hf : ContinuousOn f (Icc 0 (Real.pi / 2))) (c_lt : \u2200 y \u2208 Icc 0 (sorry / 2), y \u2260 0 \u2192 cos y < cos 0) (c_nonneg : \u2200 x \u2208 Icc 0 (sorry / 2), 0 \u2264 cos x) (c_zero_pos : 0 < cos 0) : (0 : \u211d) \u2208 closure (interior (Icc 0 (\u03c0 / 2))) :=\n  by rw [interior_Icc]\n    rw [closure_Ioo pi_div_two_pos.ne]\n    rw [left_mem_Icc]\n    exact pi_div_two_pos.le"}
{"context": {"open": ["Filter Finset", "Topology"], "variables": []}, "declaration": "theorem sum_div_pow_sq_le_div_sq_have_1 (N : \u2115) (j : \u211d) (hj : 0 < j) (c : \u211d) (hc : 1 < c) (cpos : 0 < c) (A : 0 < c\u207b\u00b9 ^ 2) : c ^ 2 * ((1 : \u211d) - c\u207b\u00b9 ^ 2)\u207b\u00b9 \u2264 c ^ 3 * (c - 1)\u207b\u00b9 :=\n  by rw [\u2190 div_eq_mul_inv]\n    rw [\u2190 div_eq_mul_inv]\n    rw [div_le_div_iff\u2080 _ (sub_pos.2 hc)]\n    swap\n    \u00b7 exact sub_pos.2 (pow_lt_one\u2080 (inv_nonneg.2 cpos.le) (inv_lt_one_of_one_lt\u2080 hc) two_ne_zero)\n    have : c ^ 3 = c ^ 2 * c := by ring\n    simp only [mul_sub]\n    simp only [this]\n    simp only [mul_one]\n    simp only [inv_pow]\n    simp only [sub_le_sub_iff_left]\n    rw [mul_assoc]\n    rw [mul_comm c]\n    rw [\u2190 mul_assoc]\n    rw [mul_inv_cancel\u2080 (sq_pos_of_pos cpos).ne']\n    rw [one_mul]\n    simpa using pow_right_mono\u2080 hc.le one_le_two"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Monotone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfm : Monotone f) (k : \u2115) : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) :=\n  by refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, sub_le_iff_le_add]\n    gcongr\n    exact hfm (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Monotone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfm : Monotone f) (k : \u2115) : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) :=\n  by refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ _ (2 * n + 1 + 1)]\n    rw [sum_range_succ _ (2 * n + 1)]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, le_sub_iff_add_le]\n    gcongr\n    exact hfm (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Antitone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfa : Antitone f) (k : \u2115) : Monotone (fun n \u21a6 \u2211 i \u2208 range (2 * n), (-1) ^ i * f i) :=\n  by refine monotone_nat_of_le_succ (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, one_mul,\n      \u2190 sub_eq_add_neg, le_sub_iff_add_le]\n    gcongr\n    exact hfa (by omega)"}
{"context": {"open": ["Set Function Filter Finset Metric Asymptotics Topology Nat NNReal ENNReal", "List in", "NormedSpace", "Polynomial in"], "variables": ["{\u03b1 : Type*}", "{R : Type*} [NormedRing R]", "[HasSummableGeomSeries R]", "{K : Type*} [NormedDivisionRing K] {\u03be : K}", "{R : Type*} [NormedRing R] {\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c]", "[HasSummableGeomSeries R]", "[SeminormedAddCommGroup \u03b1] {r C : \u211d} {f : \u2115 \u2192 \u03b1}", "[NormedDivisionRing \u03b1] [CompleteSpace \u03b1] {f : \u2115 \u2192 \u03b1}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{b : \u211d} {f : \u2115 \u2192 \u211d} {z : \u2115 \u2192 E}", "{E : Type*} [Ring E] [PartialOrder E] [IsOrderedRing E]"]}, "declaration": "theorem Antitone_have_1 (f : \u2115 \u2192 \u211d) (l : \u211d) (hfl : Tendsto (fun n => \u2211 i \u2208 Finset.range n, (-1) ^ i * f i) atTop (nhds l)) (hfa : Antitone f) (k : \u2115) : Antitone (fun n \u21a6 \u2211 i \u2208 range (2 * n + 1), (-1) ^ i * f i) :=\n  by refine antitone_nat_of_succ_le (fun n \u21a6 ?_)\n    rw [show 2 * (n + 1) = 2 * n + 1 + 1 by ring]\n    rw [sum_range_succ]\n    rw [sum_range_succ]\n    simp_rw [_root_.pow_succ', show (-1 : E) ^ (2 * n) = 1 by simp, neg_one_mul, neg_neg, one_mul,\n      \u2190 sub_eq_add_neg, sub_add_eq_add_sub, sub_le_iff_le_add]\n    gcongr\n    exact hfa (by omega)"}
{"context": {"open": ["Limits"], "variables": ["{C : Type*} [Category C] [Preregular C] {X : C}"]}, "declaration": "theorem mem_sieves_of_hasEffectiveEpi_have_1 (Sieve : x\u271d\u00b2) (C : Type u_2) (X : C) (EffectiveEpi : x\u271d\u00b9) (regularTopology : x\u271d) (S : sorry) (Y : C) (\u03c0 : sorry) (h : sorry \u2227 sorry) : Sieve.generate (Presieve.ofArrows (fun () \u21a6 Y) (fun _ \u21a6 \u03c0)) \u2264 S :=\n  by rw [Sieve.generate_le_iff (Presieve.ofArrows _ _) S]\n    apply Presieve.le_of_factorsThru_sieve (Presieve.ofArrows _ _) S _\n    intro W g f\n    refine \u27e8W, \ud835\udfd9 W, ?_\u27e9\n    cases f\n    exact \u27e8\u03c0, \u27e8h.2, Category.id_comp \u03c0\u27e9\u27e9"}
{"context": {"open": ["Nat hiding log", "Finset Metric Real", "scoped Pointwise", "scoped Filter Topology", "Real"], "variables": ["{n d k N : \u2115} {x : Fin n \u2192 \u2115}"]}, "declaration": "theorem exp_neg_two_mul_le_have_1 (x : \u211d) (hx : 0 < x) (h\u2081 : \u2191\u2308x\u2309\u208a < x + 1) : 1 - x \u2264 2 - \u2308x\u2309\u208a :=\n  by linarith"}
{"context": {"open": ["List"], "variables": ["{n : \u2115}", "(c : Composition n)"]}, "declaration": "theorem sizeUpTo_index_le_have_1 (n : \u2115) (c : Composition n) (j : Fin n) (i : Fin c.length := c.index j) (H : \u2191j < c.sizeUpTo \u2191i) : (0 : \u2115) < i :=\n  by_contra! i_pos\n    revert H\n    simp [nonpos_iff_eq_zero.1 i_pos, c.sizeUpTo_zero]"}
{"context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "declaration": "theorem rpow_p_mul_one_sub_smoothingFn_le_have_1 (\u03b1 : Type u_2) (b : \u03b1 \u2192 \u211d) (r : \u03b1 \u2192 \u2115 \u2192 \u2115) (p : x\u271d\u00b9) (\u03b5 : x\u271d) (i : \u03b1) (q : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 - sorry)) (\u03b1 : Type u_2) (b : \u03b1 \u2192 \u211d) (r : \u03b1 \u2192 \u2115 \u2192 \u2115) (p : x\u271d\u00b9) (\u03b5 : x\u271d) : DifferentiableOn \u211d q (Set.Ioi 1) :=\n  by refine DifferentiableOn.mul\n      (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_sub_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz"}
{"context": {"open": ["Finset Real Filter Asymptotics", "scoped Topology"], "variables": ["{\u03b1 : Type*} [Finite \u03b1] [Nonempty \u03b1]", "{\u03b1 : Type*} [Fintype \u03b1] {T : \u2115 \u2192 \u211d} {g : \u211d \u2192 \u211d} {a b : \u03b1 \u2192 \u211d} {r : \u03b1 \u2192 \u2115 \u2192 \u2115}", "[Nonempty \u03b1] (R : AkraBazziRecurrence T g a b r)", "(a b) in", "(g) (a) (b)", "{g} {a} {b}"]}, "declaration": "theorem rpow_p_mul_one_add_smoothingFn_ge_have_1 (\u03b1 : Type u_2) (b : \u03b1 \u2192 \u211d) (r : \u03b1 \u2192 \u2115 \u2192 \u2115) (p : x\u271d\u00b9) (\u03b5 : x\u271d) (i : \u03b1) (q : \u211d \u2192 \u211d := fun x => x ^ sorry * (1 + sorry)) (\u03b1 : Type u_2) (b : \u03b1 \u2192 \u211d) (r : \u03b1 \u2192 \u2115 \u2192 \u2115) (p : x\u271d\u00b9) (\u03b5 : x\u271d) : DifferentiableOn \u211d q (Set.Ioi 1) :=\n  by refine DifferentiableOn.mul\n        (DifferentiableOn.mono (differentiableOn_rpow_const _) fun z hz => ?_)\n        differentiableOn_one_add_smoothingFn\n    rw [Set.mem_compl_singleton_iff]\n    rw [Set.mem_Ioi] at hz\n    exact ne_of_gt <| zero_lt_one.trans hz"}
{"context": {"open": ["CauSeq Finset IsAbsoluteValue", "scoped ComplexConjugate", "Complex", "Complex", "IsAbsoluteValue Nat", "Complex Finset"], "variables": ["(x y : \u2102)", "(x y : \u211d)"]}, "declaration": "theorem exp_bound_have_1 (x : \u211d) (h1 : 0 \u2264 x) (h2 : x \u2264 1) (n : \u2115) (hn : 0 < n) (h3 : |x| = x) : |x| \u2264 1 :=\n  by rwa [h3]"}
{"context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "declaration": "theorem exists_eq_add_of_le_have_1 (n : \u2115) (h : a \u2264 b) (k : \u2115) (hk : \u2191b = \u2191a + k) : k \u2264 b :=\n  by omega"}
{"context": {"open": ["Fin Nat Function", "Int", "scoped Relator in", "Nat Int"], "variables": ["{n m : \u2115}", "{a b : \u2115}", "{p : Fin (n + 1)} {i j : Fin n}"]}, "declaration": "theorem exists_eq_add_of_lt_have_1 (h : a < b) (k : \u2115) (hk : \u2191b = \u2191a + k + 1) : k < b :=\n  by omega"}
{"context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1}", "{IsBase : Set \u03b1 \u2192 Prop} {B B' : Set \u03b1}", "{B\u2081 B\u2082 : Set \u03b1}", "{X Y : Set \u03b1} {e : \u03b1}", "{B B\u2081 B\u2082 : Set \u03b1}", "{B B' I J D X : Set \u03b1} {e f : \u03b1}"]}, "declaration": "theorem IsBase_have_1 (\u03b1 : Type u_1) (M : Matroid \u03b1) (e : \u03b1) (hB : M.IsBase B) (h : B \\ B' = {e}) (f : \u03b1) (hf : f \u2208 B' \\ B) (hb : M.IsBase (insert f (B \\ {e}))) : f \u2260 e :=\n  by rintro rfl; exact hf.2 (h.symm.subset (mem_singleton f)).1"}
{"context": {"open": ["Set"], "variables": ["{\u03b9 \u03b1 : Type*} {M : Matroid \u03b1} {F X Y : Set \u03b1} {e f : \u03b1}", "(X) in", "{\u03b9 : Sort*} {I J B : Set \u03b1} {x : \u03b1}"]}, "declaration": "theorem Indep_have_1 (\u03b1 : Type u_2) (M : Matroid \u03b1) (hI : M.Indep I) (hJ : M.Indep J) (h : \u2200 e \u2208 J \\ I, e \u2209 M.closure (I \u222a J \\ {e})) (K : Set \u03b1) (hKIJ : M.IsBasis K (I \u222a J)) (hK : I \u2286 K) (hssu : K \u2282 I \u222a J) (e : \u03b1) (heI : e \u2208 I \u222a J) (heK : e \u2209 K) : e \u2208 J \\ I :=\n  by rw [\u2190 union_diff_right]\n    rw [union_comm]\n    exact \u27e8heI, not_mem_subset hK heK\u27e9"}
{"context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} {M : Matroid \u03b1} {R I X Y : Set \u03b1}", "{N : Matroid \u03b1}", "{B J : Set \u03b1} {e : \u03b1}"]}, "declaration": "theorem Indep_have_1 (\u03b1 : Type u_1) (M : Matroid \u03b1) (hI : M.Indep I) (hJ : M.Indep J) (hIJ : I.encard < J.encard) (he : \u2200 e \u2208 J \\ I, \u00acM.Indep (insert e I)) : M.IsBasis I (I \u222a J) :=\n  by simp_rw [hI.isBasis_iff_forall_insert_dep subset_union_left, union_diff_left, mem_diff,\n      and_imp, dep_iff, insert_subset_iff, and_iff_left hI.subset_ground]\n    exact fun e heJ heI \u21a6 \u27e8he e \u27e8heJ, heI\u27e9, hJ.subset_ground heJ\u27e9"}
{"context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "declaration": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul_have_1 (p : \u2115) (p_prime : sorry) (hpm : p ^ k \u2223 m) (hpn : p ^ l \u2223 n) (hpmn : p ^ (k + l + 1) \u2223 m * n) : p ^ (k + l) * p \u2223 m * n :=\n  by let hpmn' : p ^ (succ (k + l)) \u2223 m * n := hpmn\n      rwa [pow_succ'] at hpmn'"}
{"context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "declaration": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul_have_2 (p : \u2115) (p_prime : sorry) (hpm : p ^ k \u2223 m) (hpn : p ^ l \u2223 n) (hpmn : p ^ (k + l + 1) \u2223 m * n) (hpd : p ^ (k + l) * p \u2223 m * n) (hpd2 : p \u2223 m * n / p ^ (k + l)) : p \u2223 m * n / (p ^ k * p ^ l) :=\n  by simpa [pow_add] using hpd2"}
{"context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "declaration": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul_have_3 (p : \u2115) (p_prime : sorry) (hpm : p ^ k \u2223 m) (hpn : p ^ l \u2223 n) (hpmn : p ^ (k + l + 1) \u2223 m * n) (hpd : p ^ (k + l) * p \u2223 m * n) (hpd2 : p \u2223 m * n / p ^ (k + l)) (hpd3 : p \u2223 m * n / (p ^ k * p ^ l)) : p \u2223 m / p ^ k * (n / p ^ l) :=\n  by simpa [Nat.div_mul_div_comm hpm hpn] using hpd3"}
{"context": {"open": ["Int", "Mathlib.Meta.NormNum Qq"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "declaration": "theorem fract_inv_num_lt_num_of_pos_have_1 (q : \u211a) (q_pos : 0 < q) (q_num_pos : 0 < q.num) (q_num_abs_eq_q_num : \u2191q.num.natAbs = q.num) (q_inv : \u211a := \u2191q.den / \u2191q.num) (q_inv_def : q_inv = \u2191q.den / \u2191q.num) (q_inv_eq : q\u207b\u00b9 = q_inv) : q\u207b\u00b9.num - \u230aq\u207b\u00b9\u230b * q\u207b\u00b9.den < q\u207b\u00b9.den :=\n  by have : q\u207b\u00b9.num < (\u230aq\u207b\u00b9\u230b + 1) * q\u207b\u00b9.den := Rat.num_lt_succ_floor_mul_den q\u207b\u00b9\n    have : q\u207b\u00b9.num < \u230aq\u207b\u00b9\u230b * q\u207b\u00b9.den + q\u207b\u00b9.den := by rwa [right_distrib, one_mul] at this\n    rwa [\u2190 sub_lt_iff_lt_add'] at this"}
{"context": {"open": [], "variables": []}, "declaration": "theorem num_den_mk_have_1 (q : \u211a) (hd : d \u2260 0) (qdf : q = \u2191n / sorry) (hn : n \u2260 0) (this : q.num * d = n * \u2191q.den) : q.num \u2223 n :=\n  by rw [qdf]\n    exact Rat.num_dvd _ hd"}
{"context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650\u221e}", "(r) in", "(r) in", "(r) in", "(r) in"]}, "declaration": "theorem toReal_iff_have_1 (hp : 1 < p.toReal) (h : p.HolderConjugate q) : 0 < q.toReal :=\n  by rw [toReal_pos_iff]\n    refine \u27e8pos q p, lt_top_iff_one_lt q p |>.mpr ?_\u27e9\n    contrapose! hp\n    exact toReal_mono one_ne_top hp"}
{"context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "declaration": "theorem fib_golden_conj_exp_have_1 (n : \u2115) : sqrt 5 \u2260 0 :=\n  by norm_num"}
{"context": {"open": ["Rat Real"], "variables": []}, "declaration": "theorem irrational_nrt_of_notint_nrt_have_1 (n : \u2115) (m : \u2124) (hnpos : 0 < n) (N : \u2124) (D : \u2115) (P : D \u2260 0) (C : N.natAbs.Coprime D) (hxr : \u2191({ num := N, den := D, den_nz := P, reduced := C } ^ n) = \u2191m) (hv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y) : ((D : \u2124) : \u211d) \u2260 0 :=\n  by rw [Int.cast_ne_zero]\n    rw [Int.natCast_ne_zero]\n    exact P"}
{"context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}"]}, "declaration": "theorem biUnion_compl_eq_of_pairwise_disjoint_of_iUnion_eq_univ_have_1 (\u03b1 : Type u_1) (\u03b9 : Type u_14) (Es : \u03b9 \u2192 Set \u03b1) (Es_union : \u22c3 i, Es i = univ) (Es_disj : Pairwise fun i j => Disjoint (Es i) (Es j)) (I : Set \u03b9) (x : \u03b1) (i : \u03b9) (hix : x \u2208 Es i) : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J :=\n  by refine fun J \u21a6 \u27e8?_, fun i_in_J \u21a6 by simpa only [mem_iUnion, exists_prop] using \u27e8i, i_in_J, hix\u27e9\u27e9\n    intro x_in_U\n    simp only [mem_iUnion] at x_in_U\n    simp only [exists_prop] at x_in_U\n    obtain \u27e8j, j_in_J, hjx\u27e9 := x_in_U\n    rwa [show i = j by by_contra i_ne_j; exact Disjoint.ne_of_mem (Es_disj i_ne_j) hix hjx rfl]"}
{"context": {"open": ["Subgroup"], "variables": ["{G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'}", "(G)", "(f) in", "(G)", "{G}", "(G) in", "[IsSimpleGroup G]"]}, "declaration": "theorem Equiv_have_1 (X : Type u_3) (hX : 5 \u2264 Cardinal.mk X) (h : IsSolvable (Perm X)) : Nonempty (Fin 5 \u21aa X) :=\n  by rwa [\u2190 Cardinal.lift_mk_le, Cardinal.mk_fin, Cardinal.lift_natCast, Cardinal.lift_id]"}
{"context": {"open": ["Basis Cardinal Function Module Set Submodule"], "variables": ["{R : Type u} {M M\u2081 : Type v} {M' : Type v'} {\u03b9 : Type w}", "[Ring R] [AddCommGroup M] [AddCommGroup M'] [AddCommGroup M\u2081]", "[Module R M] [Module R M'] [Module R M\u2081]", "[Nontrivial R]", "[NoZeroSMulDivisors R M]", "(R M)", "{R M}", "[StrongRankCondition R]", "[StrongRankCondition R]", "[Module.Finite R M] [StrongRankCondition R] in", "[NoZeroSMulDivisors R M]"]}, "declaration": "theorem iSupIndep_have_1 (R : Type u) (M : Type v) (\u03b9 : Type w) (V : \u03b9 \u2192 Submodule R M) (hV : iSupIndep V) (I : Type w := { i // V i \u2260 \u22a5 }) : \u2200 i : I, \u2203 v \u2208 V i, v \u2260 (0 : M) :=\n  by intro i\n    rw [\u2190 Submodule.ne_bot_iff]\n    exact i.prop"}
{"context": {"open": ["Function Set Submodule", "LinearMap Finsupp"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}"]}, "declaration": "theorem eq_of_linearIndepOn_id_of_span_subtype_have_1 (R : Type u_2) (M : Type u_4) (hs : LinearIndepOn R _root_.id s) (h : t \u2286 s) (hst : s \u2286 \u2191(span R t)) (f : \u2191t \u21aa \u2191s := { toFun := fun x => \u27e8\u2191x, \u22ef\u27e9, inj' := \u22ef }) : Surjective f :=\n  by apply surjective_of_linearIndependent_of_span hs f _\n    convert hst <;> simp [f, comp_def]"}
{"context": {"open": ["Function Set Submodule", "LinearMap Finsupp"], "variables": ["{\u03b9 : Type u'} {\u03b9' : Type*} {R : Type*} {K : Type*} {s : Set \u03b9}", "{M : Type*} {M' : Type*} {V : Type u}", "{v : \u03b9 \u2192 M}", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M']", "[Module R M] [Module R M']", "(R) (v)", "{R v}", "(hv : LinearIndependent R v)", "(R)"]}, "declaration": "theorem exists_maximal_linearIndepOn_have_1 (\u03b9 : Type u') (R : Type u_2) (M : Type u_4) (v : \u03b9 \u2192 M) (indep : Set \u03b9 \u2192 Prop := fun s => sorry) (X : Type (max 0 u') := { I // indep I }) (r : X \u2192 X \u2192 Prop := fun I J => \u2191I \u2286 \u2191J) : \u2200 c : Set X, IsChain r c \u2192 indep (\u22c3 (I : X) (_ : I \u2208 c), I) :=\n  by intro c hc\n    dsimp [indep]\n    rw [linearIndepOn_iff\u209b]\n    intro f hfsupp g hgsupp hsum\n    rcases eq_empty_or_nonempty c with (rfl | hn)\n    \u00b7 rw [show f = 0 by simpa using hfsupp, show g = 0 by simpa using hgsupp]\n    haveI : IsRefl X r := \u27e8fun _ => Set.Subset.refl _\u27e9\n    classical\n    obtain \u27e8I, _I_mem, hI\u27e9 : \u2203 I \u2208 c, (f.support \u222a g.support : Set \u03b9) \u2286 I :=\n      f.support.coe_union _ \u25b8 hc.directedOn.exists_mem_subset_of_finset_subset_biUnion hn <| by\n        simpa using And.intro hfsupp hgsupp\n    exact linearIndepOn_iff\u209b.mp I.2 f (subset_union_left.trans hI)\n      g (subset_union_right.trans hI) hsum"}
{"context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}"]}, "declaration": "theorem subset_piiUnionInter_have_1 (\u03b1 : Type u_5) (\u03b9 : Type u_6) (\u03c0 : \u03b9 \u2192 Set (Set \u03b1)) (S : Set \u03b9) (i : \u03b9) (his : i \u2208 S) : {i} \u2286 S :=\n  by intro j hj\n    rw [mem_singleton_iff] at hj\n    rwa [hj]"}
{"context": {"open": ["MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure", "scoped Filter ENNReal MeasureTheory NNReal Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "declaration": "theorem ae_eventually_measure_pos_have_1 (\u03b1 : Type u_1) (m0 : MeasurableSpace \u03b1) (\u03bc : Measure \u03b1) (s : Set \u03b1 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}) (hs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}) (f : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03bc a = 0}) : v.FineSubfamilyOn f s :=\n  by intro x hx \u03b5 \u03b5pos\n    rw [hs] at hx\n    simp only [frequently_filterAt_iff] at hx\n    simp only [exists_prop] at hx\n    simp only [gt_iff_lt] at hx\n    simp only [mem_setOf_eq] at hx\n    rcases hx \u03b5 \u03b5pos with \u27e8a, a_sets, ax, \u03bca\u27e9\n    exact \u27e8a, \u27e8a_sets, \u03bca\u27e9, ax\u27e9"}
{"context": {"open": ["MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure", "scoped Filter ENNReal MeasureTheory NNReal Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "declaration": "theorem measure_le_of_frequently_le_have_1 (\u03b1 : Type u_1) (m0 : MeasurableSpace \u03b1) (\u03bc : Measure \u03b1) (h\u03c1 : \u03c1.AbsolutelyContinuous \u03bc) (s : Set \u03b1) (hs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a) (\u03b5 : NNReal) (\u03b5pos : 0 < \u03b5) (U : Set \u03b1) (sU : s \u2286 U) (U_open : sorry) (\u03bdU : \u03bd U \u2264 \u03bd s + \u2191\u03b5) (f : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}) : v.FineSubfamilyOn f s :=\n  by apply v.fineSubfamilyOn_of_frequently f s fun x hx => ?_\n    have :=\n      (hs x hx).and_eventually\n        ((v.eventually_filterAt_mem_setsAt x).and\n          (v.eventually_filterAt_subset_of_nhds (U_open.mem_nhds (sU hx))))\n    apply Frequently.mono this\n    rintro a \u27e8\u03c1a, _, aU\u27e9\n    exact \u27e8\u03c1a, aU\u27e9"}
{"context": {"open": ["Filter MeasureTheory ProbabilityTheory Set TopologicalSpace", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "[Nonempty \u03b1]", "[MeasurableSingletonClass \u03b1]", "[ConditionallyCompleteLinearOrder \u03b2] {x : \u03b2} {f : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [FirstCountableTopology \u03b2] [OrderTopology \u03b2]", "[CompleteLattice \u03b2]", "{\u03b3 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b2}", "[MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2]", "{f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "declaration": "theorem essSup_restrict_eq_of_support_subset_have_1 (\u03b1 : Type u_1) (m : MeasurableSpace \u03b1) (\u03bc : Measure \u03b1) (s : Set \u03b1) (f : \u03b1 \u2192 ENNReal) (hsf : Function.support f \u2286 s) (c : ENNReal) (hc : c < essSup f \u03bc) (d : ENNReal) (cd : c < d) (hd : d < essSup f \u03bc) (t : Set \u03b1 := {x | d < f x}) : 0 < (\u03bc.restrict t) t :=\n  by simp only [Measure.restrict_apply_self]\n    rw [essSup_eq_sInf] at hd\n    have : d \u2209 {a | \u03bc {x | a < f x} = 0} := not_mem_of_lt_csInf hd (OrderBot.bddBelow _)\n    exact bot_lt_iff_ne_bot.2 this"}
{"context": {"open": ["Filter MeasureTheory ProbabilityTheory Set TopologicalSpace", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "[Nonempty \u03b1]", "[MeasurableSingletonClass \u03b1]", "[ConditionallyCompleteLinearOrder \u03b2] {x : \u03b2} {f : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [FirstCountableTopology \u03b2] [OrderTopology \u03b2]", "[CompleteLattice \u03b2]", "{\u03b3 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b2}", "[MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2]", "{f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "declaration": "theorem essSup_restrict_eq_of_support_subset_have_2 (\u03b1 : Type u_1) (m : MeasurableSpace \u03b1) (\u03bc : Measure \u03b1) (s : Set \u03b1) (f : \u03b1 \u2192 ENNReal) (hsf : Function.support f \u2286 s) (c : ENNReal) (hc : c < essSup f \u03bc) (d : ENNReal) (cd : c < d) (hd : d < essSup f \u03bc) (t : Set \u03b1 := {x | d < f x}) (A : 0 < (\u03bc.restrict t) t) : 0 < (\u03bc.restrict s) t :=\n  by have : \u03bc.restrict t \u2264 \u03bc.restrict s := by\n      apply Measure.restrict_mono _ le_rfl\n      apply subset_trans _ hsf\n      intro x (hx : d < f x)\n      exact (lt_of_le_of_lt bot_le hx).ne'\n    exact lt_of_lt_of_le A (this _)"}
{"context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]"]}, "declaration": "theorem integrableOn_Ioi_deriv_of_nonneg_have_1 (hcont : ContinuousWithinAt g (Ici a) a) (hderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x) (hg : Tendsto g atTop (nhds l)) : ContinuousOn g (Ici a) :=\n  by intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    \u00b7 exact hcont\n    \u00b7 exact (hderiv x hx).continuousAt.continuousWithinAt"}
{"context": {"open": ["scoped ENNReal MeasureTheory Topology", "Set MeasureTheory Filter Measure"], "variables": ["{\u03b1 R : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) [LinearOrder R]", "{\u03b1 : Type*} [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u211d} {g : \u211d \u2192 \u211d}"]}, "declaration": "theorem lintegral_comp_eq_lintegral_meas_le_mul_have_1 (\u03b1 : Type u_3) (f : \u03b1 \u2192 \u211d) (g : \u211d \u2192 \u211d) (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1da0[ae \u03bc] f) (f_mble : AEMeasurable f \u03bc) (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t) (g_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t) (G : \u211d \u2192 \u211d) (G_mble : Measurable G) (G_nn : 0 \u2264 G) (g_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G) (g_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G) : \u2200 t > 0, IntervalIntegrable G volume 0 t :=\n  by refine fun t t_pos => \u27e8(g_intble t t_pos).1.congr_fun_ae (g_eq_G_on t), ?_\u27e9\n    rw [Ioc_eq_empty_of_le t_pos.lt.le]\n    exact integrableOn_empty"}
{"context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "declaration": "theorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top_have_1 (\u03b1 : Type u_1) (\u03bc : Measure \u03b1) (hp0_lt : 0 < p) (hq0 : 0 \u2264 q) (hf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4) (hg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0) : 0 < 1 / p :=\n  by simp [hp0_lt]"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le_Ico_have_1 (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b) volume) (h\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x) (\u03b5 : \u211d) (\u03b5pos : 0 < \u03b5) (s : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b) : IsClosed s :=\n  by have : ContinuousOn (fun t => (g t - g a, \u222b u in a..t, (G' u).toReal)) (Icc a b) := by\n      rw [\u2190 uIcc_of_le hab] at G'int hcont \u22a2\n      exact (hcont.sub continuousOn_const).prodMk (continuousOn_primitive_interval G'int)\n    simp only [s]\n    simp only [inter_comm]\n    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le_Ico_have_2 (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b) volume) (h\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x) (\u03b5 : \u211d) (\u03b5pos : 0 < \u03b5) (s : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b) (s_closed : IsClosed s) : Icc a b \u2286 {t | g t - g a \u2264 \u222b u in a..t, (G' u).toReal} :=\n  by refine s_closed.Icc_subset_of_forall_exists_gt\n      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_\n    obtain \u27e8y, g'_lt_y', y_lt_G'\u27e9 : \u2203 y : \u211d, (g' t : EReal) < y \u2227 (y : EReal) < G' t :=\n      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (h\u03c6g t ht.2)).trans_lt (f_lt_G' t))\n    have I1 : \u2200\u1da0 u in \ud835\udcdd[>] t, (u - t) * y \u2264 \u222b w in t..u, (G' w).toReal := by\n      have B : \u2200\u1da0 u in \ud835\udcdd t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'\n      rcases mem_nhds_iff_exists_Ioo_subset.1 B with \u27e8m, M, \u27e8hm, hM\u27e9, H\u27e9\n      have : Ioo t (min M b) \u2208 \ud835\udcdd[>] t := Ioo_mem_nhdsGT (lt_min hM ht.right.right)\n      filter_upwards [this] with u hu\n      have I : Icc t u \u2286 Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))\n      calc\n        (u - t) * y = \u222b _ in Icc t u, y := by\n          simp only [MeasureTheory.integral_const]\n          simp only [MeasurableSet.univ]\n          simp only [measureReal_restrict_apply]\n          simp only [univ_inter]\n          simp only [hu.left.le]\n          simp only [Real.volume_real_Icc_of_le]\n          simp only [smul_eq_mul]\n          simp only [s]\n        _ \u2264 \u222b w in t..u, (G' w).toReal := by\n          rw [intervalIntegral.integral_of_le hu.1.le]\n          rw [\u2190 integral_Icc_eq_integral_Ioc]\n          apply setIntegral_mono_ae_restrict\n          \u00b7 simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true]\n          \u00b7 exact IntegrableOn.mono_set G'int I\n          \u00b7 have C1 : \u2200\u1d50 x : \u211d \u2202volume.restrict (Icc t u), G' x < \u221e :=\n              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top\n            have C2 : \u2200\u1d50 x : \u211d \u2202volume.restrict (Icc t u), x \u2208 Icc t u :=\n              ae_restrict_mem measurableSet_Icc\n            filter_upwards [C1, C2] with x G'x hx\n            apply EReal.coe_le_coe_iff.1\n            have : x \u2208 Ioo m M := by\n              simp only [hm.trans_le hx.left]\n              simp only [(hx.right.trans_lt hu.right).trans_le (min_le_left M b)]\n              simp only [mem_Ioo]\n              simp only [and_self_iff]\n            refine (H this).out.le.trans_eq ?_\n            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm\n    have I2 : \u2200\u1da0 u in \ud835\udcdd[>] t, g u - g t \u2264 (u - t) * y := by\n      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'\n      filter_upwards [(hderiv t \u27e8ht.2.1, ht.2.2\u27e9).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,\n        self_mem_nhdsWithin] with u hu t_lt_u\n      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le\n      rwa [\u2190 smul_eq_mul, sub_smul_slope] at this\n    have I3 : \u2200\u1da0 u in \ud835\udcdd[>] t, g u - g t \u2264 \u222b w in t..u, (G' w).toReal := by\n      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1\n    have I4 : \u2200\u1da0 u in \ud835\udcdd[>] t, u \u2208 Ioc t (min v b) := Ioc_mem_nhdsGT <| lt_min t_lt_v ht.2.2\n    rcases (I3.and I4).exists with \u27e8x, hx, h'x\u27e9\n    refine \u27e8x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x\u27e9\n    calc\n      g x - g a = g t - g a + (g x - g t) := by abel\n      _ \u2264 (\u222b w in a..t, (G' w).toReal) + \u222b w in t..x, (G' w).toReal := add_le_add ht.1 hx\n      _ = \u222b w in a..x, (G' w).toReal := by\n        apply integral_add_adjacent_intervals\n        \u00b7 rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]\n          exact IntegrableOn.mono_set G'int\n            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))\n        \u00b7 rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]\n          apply IntegrableOn.mono_set G'int\n          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le_have_1 (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b) volume) (h\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x) (a_lt_b : a < b) (s : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b) : IsClosed s :=\n  by have : ContinuousOn (fun t => (g b - g t, \u222b u in t..b, \u03c6 u)) (Icc a b) := by\n      rw [\u2190 uIcc_of_le hab] at hcont \u03c6int \u22a2\n      exact (continuousOn_const.sub hcont).prodMk (continuousOn_primitive_interval_left \u03c6int)\n    simp only [s]\n    simp only [inter_comm]\n    exact this.preimage_isClosed_of_isClosed isClosed_Icc isClosed_le_prod"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le_have_2 (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b) volume) (h\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x) (a_lt_b : a < b) (s : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b) (s_closed : IsClosed s) : closure (Ioc a b) \u2286 s :=\n  by apply s_closed.closure_subset_iff.2\n    intro t ht\n    refine \u27e8?_, \u27e8ht.1.le, ht.2\u27e9\u27e9\n    exact\n      sub_le_integral_of_hasDeriv_right_of_le_Ico ht.2 (hcont.mono (Icc_subset_Icc ht.1.le le_rfl))\n        (fun x hx => hderiv x \u27e8ht.1.trans_le hx.1, hx.2\u27e9)\n        (\u03c6int.mono_set (Icc_subset_Icc ht.1.le le_rfl)) fun x hx => h\u03c6g x \u27e8ht.1.trans_le hx.1, hx.2\u27e9"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}", "[CompleteSpace E] {f f' : \u211d \u2192 E}"]}, "declaration": "theorem integral_eq_sub_of_hasDerivAt_of_tendsto_have_1 (E : Type u_3) (hab : a < b) (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' volume a b) (ha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)) (hb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)) (F : \u211d \u2192 E := update (update f a fa) b fb) : \u2200 x \u2208 Ioo a b, HasDerivAt F (f' x) x :=\n  by refine fun x hx => (hderiv x hx).congr_of_eventuallyEq ?_\n    filter_upwards [Ioo_mem_nhds hx.1 hx.2] with _ hy\n    unfold F\n    rw [update_of_ne hy.2.ne]\n    rw [update_of_ne hy.1.ne']"}
{"context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}", "[CompleteSpace E] {f f' : \u211d \u2192 E}"]}, "declaration": "theorem integral_eq_sub_of_hasDerivAt_of_tendsto_have_2 (E : Type u_3) (hab : a < b) (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' volume a b) (ha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)) (hb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)) (F : \u211d \u2192 E := update (update f a fa) b fb) (Fderiv : \u2200 x \u2208 Ioo a b, sorry) : ContinuousOn F (Icc a b) :=\n  by rw [continuousOn_update_iff]\n    rw [continuousOn_update_iff]\n    rw [Icc_diff_right]\n    rw [Ico_diff_left]\n    refine \u27e8\u27e8fun z hz => (hderiv z hz).continuousAt.continuousWithinAt, ?_\u27e9, ?_\u27e9\n    \u00b7 exact fun _ => ha.mono_left (nhdsWithin_mono _ Ioo_subset_Ioi_self)\n    \u00b7 rintro -\n      refine (hb.congr' ?_).mono_left (nhdsWithin_mono _ Ico_subset_Iio_self)\n      filter_upwards [Ioo_mem_nhdsLT hab] with _ hz using (update_of_ne hz.1.ne' _ _).symm"}
{"context": {"open": ["Function", "Finset Nat ZMod", "scoped BigOperators", "Nat", "Finset", "ZMod"], "variables": []}, "declaration": "theorem pow_pow_add_primeFactors_one_lt_have_1 (hp : Nat.Prime p) (hp2 : p \u2260 2) (hpdvd : p \u2223 a ^ 2 ^ n + 1) (this : Fact (Nat.Prime p)) (ha1 : \u2191a ^ 2 ^ n = -1) : (a : ZMod p) \u2260 0 :=\n  by intro h\n    rw [h] at ha1\n    rw [zero_pow (pow_ne_zero n two_ne_zero)] at ha1\n    rw [zero_eq_neg] at ha1\n    exact one_ne_zero ha1"}
{"context": {"open": ["Function", "Finset Nat ZMod", "scoped BigOperators", "Nat", "Finset", "ZMod"], "variables": []}, "declaration": "theorem fermat_primeFactors_one_lt_have_1 (hn : 1 < n) (hp : Nat.Prime p) (hpdvd : p \u2223 n.fermatNumber) (this : Fact (Nat.Prime p)) : p \u2260 2 :=\n  by exact ((even_pow.mpr \u27e8even_two, pow_ne_zero n two_ne_zero\u27e9).add_one).ne_two_of_dvd_nat hpdvd"}
{"context": {"open": [], "variables": []}, "declaration": "theorem lucas_primality_have_1 (p : \u2115) (a : ZMod p) (ha : a ^ (p - 1) = 1) (hd : \u2200 (q : \u2115), Nat.Prime q \u2192 q \u2223 p - 1 \u2192 a ^ ((p - 1) / q) \u2260 1) : p \u2260 0 \u2227 p \u2260 1 :=\n  by constructor <;> rintro rfl <;> exact hd 2 Nat.prime_two (dvd_zero _) (pow_zero _)"}
{"context": {"open": [], "variables": []}, "declaration": "theorem a_id_helper_have_1 (ha : 2 \u2264 a) (hb : 2 \u2264 b) : a - 1 \u2223 a ^ b - 1 :=\n  by simpa only [one_pow] using nat_sub_dvd_pow_sub_pow a 1 b"}
{"context": {"open": [], "variables": []}, "declaration": "theorem AB_id_helper_have_1 (hp : Odd p) : b - 1 \u2223 b ^ p - 1 :=\n  by simpa only [one_pow] using nat_sub_dvd_pow_sub_pow b 1 p"}
{"context": {"open": [], "variables": []}, "declaration": "theorem AB_id_helper_have_2 (hp : Odd p) (q\u2081 : b - 1 \u2223 b ^ p - 1) : b + 1 \u2223 b ^ p + 1 :=\n  by simpa only [one_pow] using hp.nat_add_dvd_pow_add_pow b 1"}
{"context": {"open": ["Complex hiding abs_two", "Matrix hiding mul_smul", "Matrix.SpecialLinearGroup UpperHalfPlane ModularGroup Topology", "scoped ComplexConjugate MatrixGroups", "Filter ContinuousLinearMap", "scoped Modular"], "variables": ["{g : SL(2, \u2124)} (z : \u210d)", "{z}"]}, "declaration": "theorem abs_c_le_one_have_1 (g : SpecialLinearGroup (Fin 2) \u2124) (z : UpperHalfPlane) (hz : z \u2208 fdo) (hg : g \u2022 z \u2208 fdo) (c : \u211d := \u2191c') (hc : c \u2260 0) : 3 * 3 * c ^ 4 < 4 * (g \u2022 z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4 :=\n  by gcongr <;> apply three_lt_four_mul_im_sq_of_mem_fdo <;> assumption"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]"]}, "declaration": "theorem coprime_sq_sub_sq_sum_of_odd_odd_have_1 (hm : (m0 * 2 + 1) % 2 = 1) (hn : (n0 * 2 + 1) % 2 = 1) (h : (m0 * 2 + 1).gcd (n0 * 2 + 1) = 1) (h1 : (m0 * 2 + 1) ^ 2 + (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 + n0 ^ 2 + m0 + n0) + 1)) (h2 : (m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2 = 2 * (2 * (m0 ^ 2 - n0 ^ 2 + m0 - n0))) (h3 : ((m0 * 2 + 1) ^ 2 - (n0 * 2 + 1) ^ 2) / 2 % 2 = 0) : (2 : \u2124) \u2260 0 :=\n  by decide"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_1 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) : v \u2260 0 :=\n  by field_simp [v]\n    exact h0"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_2 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) (hvz : v \u2260 0) : w \u2260 -1 :=\n  by contrapose! hvz with hw1\n    rw [hw1] at hq\n    rw [neg_sq] at hq\n    rw [one_pow] at hq\n    rw [add_eq_right] at hq\n    exact pow_eq_zero hq"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_3 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) (hvz : v \u2260 0) (hw1 : w \u2260 -1) : \u2200 x : \u211a, 1 + x ^ 2 \u2260 0 :=\n  by intro q\n    apply ne_of_gt\n    exact lt_add_of_pos_of_le zero_lt_one (sq_nonneg q)"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_4 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) (hvz : v \u2260 0) (hw1 : w \u2260 -1) (hQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0) (hp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}) (q : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9) (ht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)) (m : \u2124 := \u2191q.den) (n : \u2124 := q.num) : m \u2260 0 :=\n  by unfold m\n    norm_cast\n    apply Rat.den_nz q"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_5 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) (hvz : v \u2260 0) (hw1 : w \u2260 -1) (hQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0) (hp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}) (q : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9) (ht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)) (m : \u2124 := \u2191q.den) (n : \u2124 := q.num) (hm0 : m \u2260 0) (hq2 : q = \u2191n / \u2191m) : 0 < m ^ 2 + n ^ 2 :=\n  by positivity"}
{"context": {"open": [], "variables": ["{x y z : \u2124}", "(h : PythagoreanTriple x y z)", "{K : Type*} [Field K]", "{x y z : \u2124} (h : PythagoreanTriple x y z)"]}, "declaration": "theorem isPrimitiveClassified_of_coprime_of_odd_of_pos_have_6 (h : PythagoreanTriple x y z) (hc : x.gcd y = 1) (hyo : y % 2 = 1) (hzpos : 0 < z) (h0 : \u00acx = 0) (v : \u211a := \u2191x / \u2191z) (w : \u211a := \u2191y / \u2191z) (hq : v ^ 2 + w ^ 2 = 1) (hvz : v \u2260 0) (hw1 : w \u2260 -1) (hQ : \u2200 (x : \u211a), 1 + x ^ 2 \u2260 0) (hp : (v, w) \u2208 {p | p.1 ^ 2 + p.2 ^ 2 = 1 \u2227 p.2 \u2260 -1}) (q : \u211a := (circleEquivGen hQ).symm \u27e8(v, w), hp\u27e9) (ht4 : v = 2 * q / (1 + q ^ 2) \u2227 w = (1 - q ^ 2) / (1 + q ^ 2)) (m : \u2124 := \u2191q.den) (n : \u2124 := q.num) (hm0 : m \u2260 0) (hq2 : q = \u2191n / \u2191m) (hm2n2 : 0 < m ^ 2 + n ^ 2) : (m ^ 2 + n ^ 2 : \u211a) \u2260 0 :=\n  by positivity"}
{"context": {"open": ["ZMod", "Finset in"], "variables": []}, "declaration": "theorem fermatLastTheoremThree_of_dvd_a_of_gcd_eq_one_of_case2_have_1 (ha : a \u2260 0) (h3a : 3 \u2223 a) (Hgcd : {a, b, c}.gcd id = 1) (H : \u2200 (a b c : \u2124), c \u2260 0 \u2192 \u00ac3 \u2223 a \u2192 \u00ac3 \u2223 b \u2192 3 \u2223 c \u2192 IsCoprime a b \u2192 a ^ 3 + b ^ 3 \u2260 c ^ 3) (HF : a ^ 3 + b ^ 3 + c ^ 3 = 0) (x : \u2124) (hx : x = a \u2228 x = b \u2228 x = c) : 3 \u2223 b :=\n  by refine three_dvd_b_of_dvd_a_of_gcd_eq_one_of_case2 ha ?_ h3a HF H\n    simp only [\u2190 Hgcd]\n    simp only [gcd_insert]\n    simp only [gcd_singleton]\n    simp only [id_eq]\n    simp only [\u2190 Int.abs_eq_normalize]\n    simp only [abs_neg]"}
{"context": {"open": ["Real Set MeasureTheory Filter Topology"], "variables": []}, "declaration": "theorem term_one_have_1 (term : x\u271d) (n : \u2115) (hn : 0 < n) : \u2200 x \u2208 uIcc (n : \u211d) (n + 1), 0 < x :=\n  by intro x hx\n    rw [uIcc_of_le (by simp only [le_add_iff_nonneg_right])] at hx\n    rw [zero_le_one])] at hx\n    exact (Nat.cast_pos.mpr hn).trans_le hx.1"}
{"context": {"open": ["Complex", "scoped ComplexOrder", "LSeries", "Filter in", "Filter in", "scoped LSeries.notation", "Nat Complex", "Filter in"], "variables": []}, "declaration": "theorem LSeriesSummable_of_le_const_mul_rpow_have_1 (f : \u2115 \u2192 \u2102) (x : \u211d) (s : \u2102) (hs : x < s.re) (C : \u211d) (hC : \u2200 (n : \u2115), n \u2260 0 \u2192 \u2016f n\u2016 \u2264 C * \u2191n ^ (x - 1)) (hC\u2080 : 0 \u2264 C) : Summable fun n : \u2115 \u21a6 \u2016(C : \u2102) / n ^ (s + (1 - x))\u2016 :=\n  by simp_rw [div_eq_mul_inv, norm_mul, \u2190 cpow_neg]\n    have hsx : -s.re + x - 1 < -1 := by linarith only [hs]\n    refine Summable.mul_left _ <|\n      Summable.of_norm_bounded_eventually_nat (fun n \u21a6 (n : \u211d) ^ (-s.re + x - 1)) ?_ ?_\n    \u00b7 simpa\n    \u00b7 simp only [norm_norm, Filter.eventually_atTop]\n      refine \u27e81, fun n hn \u21a6 le_of_eq ?_\u27e9\n      simp only [norm_natCast_cpow_of_pos hn]\n      simp only [add_re]\n      simp only [sub_re]\n      simp only [neg_re]\n      simp only [ofReal_re]\n      simp only [one_re]\n      ring_nf"}
{"context": {"open": ["LSeries Complex"], "variables": []}, "declaration": "theorem cpow_mul_div_cpow_eq_div_div_cpow_have_1 (z : \u2102) (x : \u211d) : (0 : \u211d) \u2264 (n + 1 : \u211d)\u207b\u00b9 :=\n  by positivity"}
{"context": {"open": ["LSeries Complex", "Filter Real in", "Filter in", "Filter Nat in", "Nat in", "Filter in"], "variables": []}, "declaration": "theorem LSeries_sub_eventuallyEq_zero_of_LSeries_eventually_eq_have_1 (hf : abscissaOfAbsConv f < \u22a4) (hg : abscissaOfAbsConv g < \u22a4) (x\u2080 : \u211d) (hx\u2080 : \u2200 b \u2265 x\u2080, LSeries f \u2191b = LSeries g \u2191b) (yf : \u211d) (hyf\u2081 : abscissaOfAbsConv f < \u2191yf) (hyf\u2082 : \u2191yf < \u22a4) (yg : \u211d) (hyg\u2081 : abscissaOfAbsConv g < \u2191yg) (hyg\u2082 : \u2191yg < \u22a4) (x : \u211d) (hx : x \u2265 max x\u2080 (max yf yg)) : LSeriesSummable f x :=\n  by refine LSeriesSummable_of_abscissaOfAbsConv_lt_re <|\n      (ofReal_re x).symm \u25b8 hyf\u2081.trans_le (EReal.coe_le_coe_iff.mpr ?_)\n    exact (le_max_left _ yg).trans <| (le_max_right x\u2080 _).trans hx"}
{"context": {"open": ["LSeries Complex", "Filter Real in", "Filter in", "Filter Nat in", "Nat in", "Filter in"], "variables": []}, "declaration": "theorem LSeries_sub_eventuallyEq_zero_of_LSeries_eventually_eq_have_2 (hf : abscissaOfAbsConv f < \u22a4) (hg : abscissaOfAbsConv g < \u22a4) (x\u2080 : \u211d) (hx\u2080 : \u2200 b \u2265 x\u2080, LSeries f \u2191b = LSeries g \u2191b) (yf : \u211d) (hyf\u2081 : abscissaOfAbsConv f < \u2191yf) (hyf\u2082 : \u2191yf < \u22a4) (yg : \u211d) (hyg\u2081 : abscissaOfAbsConv g < \u2191yg) (hyg\u2082 : \u2191yg < \u22a4) (x : \u211d) (hx : x \u2265 max x\u2080 (max yf yg)) (Hf : LSeriesSummable f \u2191x) : LSeriesSummable g x :=\n  by refine LSeriesSummable_of_abscissaOfAbsConv_lt_re <|\n      (ofReal_re x).symm \u25b8 hyg\u2081.trans_le (EReal.coe_le_coe_iff.mpr ?_)\n    exact (le_max_right yf _).trans <| (le_max_right x\u2080 _).trans hx"}
{"context": {"open": ["Finset Filter MeasureTheory Topology Complex Asymptotics"], "variables": ["{f : \u2115 \u2192 \u2102} {r : \u211d} {s : \u2102}"]}, "declaration": "theorem LSeriesSummable_of_sum_norm_bigO_aux_have_1 (f : \u2115 \u2192 \u2102) (r : \u211d) (s : \u2102) (hf : f 0 = 0) (hO : (fun n => \u2211 k \u2208 Icc 1 n, \u2016f k\u2016) =O[atTop] fun n => \u2191n ^ r) (hr : 0 \u2264 r) (hs : r < s.re) (h\u2081 : -s \u2260 0) : (-s).re + r \u2264 0 :=\n  by rw [neg_re]\n    rw [neg_add_nonpos_iff]\n    exact hs.le"}
{"context": {"open": ["Finset Filter MeasureTheory Topology Complex Asymptotics"], "variables": ["{f : \u2115 \u2192 \u2102} {r : \u211d} {s : \u2102}", "{f : \u2115 \u2192 \u2102} {l : \u2102}"]}, "declaration": "theorem lemma\u2081_have_1 (f : \u2115 \u2192 \u2102) (l : \u2102) (hlim : Tendsto (fun n => (\u2211 k \u2208 Icc 1 n, f k) / \u2191n) atTop (nhds l)) (s : \u211d) (hs : 1 < s) : (Set.Ici 1) :=\n  by simp_rw [mul_comm]\n    refine locallyIntegrableOn_mul_sum_Icc f zero_le_one ?_\n    refine ContinuousOn.locallyIntegrableOn (fun t ht \u21a6 ?_) measurableSet_Ici\n    exact (continuousAt_ofReal_cpow_const _ _ <|\n      Or.inr (zero_lt_one.trans_le ht).ne').continuousWithinAt"}
{"context": {"open": ["Finset Filter MeasureTheory Topology Complex Asymptotics"], "variables": ["{f : \u2115 \u2192 \u2102} {r : \u211d} {s : \u2102}", "{f : \u2115 \u2192 \u2102} {l : \u2102}"]}, "declaration": "theorem lemma\u2082_have_1 (S : \u211d \u2192 \u2102) (hs : 1 < s) (hS\u2081 : LocallyIntegrableOn (fun t => S t) (Set.Ici 1) volume) (hS\u2082 : \u2200 t \u2265 T, \u2016S t\u2016 \u2264 \u03b5 * t) : LocallyIntegrableOn (fun t : \u211d \u21a6 \u2016S t\u2016 * (t ^ (-s - 1))) (Set.Ici 1) :=\n  by refine hS\u2081.norm.mul_continuousOn ?_ isLocallyClosed_Ici\n    exact fun t ht \u21a6 (Real.continuousAt_rpow_const _ _\n      <| Or.inl (zero_lt_one.trans_le ht).ne').continuousWithinAt"}
{"context": {"open": ["Finset Nat", "scoped Nat"], "variables": []}, "declaration": "theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id_have_1 (p : \u2115) (hp : Fact (Nat.Prime p)) (a : ZMod p) (hap : a \u2260 0) : \u2200 {x}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2 :=\n  by simp +contextual [Nat.lt_succ_iff, Nat.succ_le_iff, pos_iff_ne_zero]"}
{"context": {"open": ["Finset Nat", "scoped Nat"], "variables": []}, "declaration": "theorem Ico_map_valMinAbs_natAbs_eq_Ico_map_id_have_2 (p : \u2115) (hp : Fact (Nat.Prime p)) (a : ZMod p) (hap : a \u2260 0) (he : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x \u2260 0 \u2227 x \u2264 p / 2) (hep : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 x < p) (hpe : \u2200 {x : \u2115}, x \u2208 Ico 1 (p / 2).succ \u2192 \u00acp \u2223 x) : (a * x : ZMod p).valMinAbs.natAbs \u2208 Ico 1 (p / 2).succ :=\n  by intro x hx\n    simp [hap, CharP.cast_eq_zero_iff (ZMod p) p, hpe hx, Nat.lt_succ_iff, succ_le_iff,\n      pos_iff_ne_zero, natAbs_valMinAbs_le _]"}
{"context": {"open": ["UpperHalfPlane ModularGroup SlashInvariantForm ModularForm Complex"], "variables": ["{F : Type*} [FunLike F \u210d \u2102] {k : \u2124}", "[SlashInvariantFormClass F \u0393(1) k]", "(k) in", "[ModularFormClass F \u0393(1) k]"]}, "declaration": "theorem levelOne_nonpos_wt_const_have_1 (F : Type u_1) (k : \u2124) (cuspFunction : x\u271d) (hk : k \u2264 0) (f : F) (z : UpperHalfPlane) : \ud835\udd62 1 z \u2208 (Metric.ball 0 1) :=\n  by simpa only [Metric.mem_ball,dist_zero_right,neg_mul,mul_zero,div_one,Real.exp_zero]\n      using (norm_qParam_lt_iff zero_lt_one 0 z.1).mpr z.2"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped Real UpperHalfPlane"], "variables": []}, "declaration": "theorem jacobiTheta_S_smul_have_1 (\u03c4 : UpperHalfPlane) (h0 : \u2191\u03c4 \u2260 0) : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 :=\n  by rw [Ne]\n    rw [cpow_eq_zero_iff]\n    rw [not_and_or]\n    exact Or.inl <| mul_ne_zero (neg_ne_zero.mpr I_ne_zero) h0"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem hasFDerivAt_jacobiTheta\u2082_have_1 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) : IsOpen V :=\n  by refine ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _ isOpen_Iio).prod ?_\n    exact continuous_im.isOpen_preimage _ isOpen_Ioi"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem hasFDerivAt_jacobiTheta\u2082_have_2 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) (hVo : IsOpen V) (hVmem : (z, \u03c4) \u2208 V) : IsPreconnected V :=\n  by refine (Convex.isPreconnected ?_).prod (convex_halfSpace_im_gt T).isPreconnected\n    simpa only [abs_lt] using (convex_halfSpace_im_gt _).inter (convex_halfSpace_im_lt _)"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem hasFDerivAt_jacobiTheta\u2082_have_3 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) (hVo : IsOpen V) (hVmem : (z, \u03c4) \u2208 V) (hVp : IsPreconnected V) (f : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2) (hf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p) (u : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))) : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n :=\n  by refine fun n p hp \u21a6 (norm_jacobiTheta\u2082_term_fderiv_le n p.1 p.2).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n    exact norm_jacobiTheta\u2082_term_le hT (le_of_lt hp.1) (le_of_lt hp.2) n"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem hasFDerivAt_jacobiTheta\u2082_have_4 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) (hVo : IsOpen V) (hVmem : (z, \u03c4) \u2208 V) (hVp : IsPreconnected V) (f : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2) (hf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p) (u : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))) (hu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n) : Summable u :=\n  by simp_rw [u, mul_assoc (3 * \u03c0)]\n    exact (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 2).mul_left _"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem hasFDerivAt_jacobiTheta\u2082_have_5 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) (hVo : IsOpen V) (hVmem : (z, \u03c4) \u2208 V) (hVp : IsPreconnected V) (f : \u2124 \u2192 \u2102 \u00d7 \u2102 \u2192 \u2102 := fun n p => jacobiTheta\u2082_term n p.1 p.2) (hf : \u2200 (n : \u2124), \u2200 p \u2208 V, HasFDerivAt (f n) (f' n p) p) (u : \u2124 \u2192 \u211d := fun n => 3 * sorry * \u2191|n| ^ 2 * Real.exp (-sorry * (T * \u2191n ^ 2 - 2 * S * \u2191|n|))) (hu : \u2200 (n : \u2124), \u2200 x \u2208 V, \u2016f' n x\u2016 \u2264 u n) (hu_sum : Summable u) : Summable fun n : \u2124 \u21a6 f n (z, \u03c4) :=\n  by refine (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 0).of_norm_bounded _ ?_\n    simpa only [pow_zero,one_mul] using norm_jacobiTheta\u2082_term_le hT hz.le h\u03c4'.le"}
{"context": {"open": ["Complex Real Asymptotics Filter Topology", "scoped ComplexConjugate"], "variables": []}, "declaration": "theorem continuousAt_jacobiTheta\u2082_have_1 (h\u03c4 : 0 < \u03c4.im) (T : \u211d) (hT : 0 < T) (S : \u211d) (hz : |z.im| < S) (V : Set (\u2102 \u00d7 \u2102) := {u | |u.im| < S} \u00d7\u02e2 {v | T < v.im}) (hVo : IsOpen V) (u : \u2124 \u2192 \u211d := fun n => 2 * sorry * \u2191|n| * sorry) : Summable u :=\n  by simpa only [u, mul_assoc, pow_one]\n      using (summable_pow_mul_jacobiTheta\u2082_term_bound S hT 1).mul_left (2 * \u03c0)"}
{"context": {"open": ["Set RelSeries", "JordanHolderLattice"], "variables": ["{X : Type u} [Lattice X] [JordanHolderLattice X]", "{X : Type u} [Lattice X] [JordanHolderLattice X]"]}, "declaration": "theorem mem_eraseLast_of_ne_of_mem_have_1 (X : Type u) (s : CompositionSeries X) (i : Fin (s.length + 1)) (hx : s.toFun i \u2260 last s) : (i : \u2115) < (s.length - 1).succ :=\n  by conv_rhs => rw [\u2190 Nat.succ_sub (length_pos_of_nontrivial \u27e8_, \u27e8i, rfl\u27e9, _, s.last_mem, hx\u27e9),\n      Nat.add_one_sub_one]\n    exact lt_of_le_of_ne (Nat.le_of_lt_succ i.2) (by simpa [last, s.inj, Fin.ext_iff] using hx)"}
{"context": {"open": ["Set Filter Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f f\u2081 f\u2082 : Filter \u03b1} {g g\u2081 g\u2082 : Set \u03b1 \u2192 Filter \u03b2}"]}, "declaration": "theorem lift_iInf_have_1 (\u03b1 : Type u_1) (\u03b2 : Type u_2) (\u03b9 : Sort u_4) (f : \u03b9 \u2192 Filter \u03b1) (g : Set \u03b1 \u2192 Filter \u03b2) (hg : \u2200 (s t : Set \u03b1), g (s \u2229 t) = g s \u2293 g t) (s : Set \u03b2) : \u2200 t \u2208 iInf f, \u2a05 i, (f i).lift g \u2264 g t :=\n  by intro t ht\n    refine iInf_sets_induct ht ?_ fun hs ht => ?_\n    \u00b7 inhabit \u03b9\n      exact iInf\u2082_le_of_le default univ (iInf_le _ univ_mem)\n    \u00b7 rw [hg]\n      exact le_inf (iInf\u2082_le_of_le _ _ <| iInf_le _ hs) ht"}
{"context": {"open": ["MeasureTheory Set Filter TopologicalSpace", "scoped NNReal ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 : Type*}", "{f : \u03b1 \u2192 \u211a \u2192 \u211d}"]}, "declaration": "theorem measurableSet_isRatStieltjesPoint_have_1 (\u03b1 : Type u_1) (f : \u03b1 \u2192 \u211a \u2192 \u211d) (IsRatStieltjesPoint : x\u271d) (hf : Measurable f) : MeasurableSet {a | Monotone (f a)} :=\n  by change MeasurableSet {a | \u2200 q r (_ : q \u2264 r), f a q \u2264 f a r}\n    simp_rw [Set.setOf_forall]\n    refine MeasurableSet.iInter (fun q \u21a6 ?_)\n    refine MeasurableSet.iInter (fun r \u21a6 ?_)\n    refine MeasurableSet.iInter (fun _ \u21a6 ?_)\n    exact measurableSet_le hf.eval hf.eval"}
{"context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "declaration": "theorem add_half_inf_sub_mem_Ioo_have_1 (hv : v \u2208 Set.Ioo l u) : 0 < (v - l) \u2293 (u - v) :=\n  by simp [hv.1, hv.2]"}
{"context": {"open": ["MeasureTheory Filter Finset Real", "scoped MeasureTheory ProbabilityTheory ENNReal NNReal Topology"], "variables": ["{\u03a9 \u03b9 : Type*} {m : MeasurableSpace \u03a9} {X : \u03a9 \u2192 \u211d} {\u03bc : Measure \u03a9} {t u v : \u211d}"]}, "declaration": "theorem sub_half_inf_sub_mem_Ioo_have_1 (hv : v \u2208 Set.Ioo l u) : 0 < (v - l) \u2293 (u - v) :=\n  by simp [hv.1, hv.2]"}
{"context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "declaration": "theorem multiplicity_eq_zero_of_coprime_have_1 (hp : p \u2260 1) (hle : multiplicity p a \u2264 multiplicity p b) (hab : a.Coprime b) (nh : 0 < multiplicity p a) : p \u2223 a :=\n  by simpa [multiplicity_eq_zero] using nh.ne.symm"}
{"context": {"open": ["Nat", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Monoid \u03b1] [Monoid \u03b2] {a b : \u03b1}", "[CommMonoid \u03b1]", "[MonoidWithZero \u03b1]", "[Semiring \u03b1]", "[Ring \u03b1]", "[CancelCommMonoidWithZero \u03b1]"]}, "declaration": "theorem multiplicity_eq_zero_of_coprime_have_2 (hp : p \u2260 1) (hle : multiplicity p a \u2264 multiplicity p b) (hab : a.Coprime b) (nh : 0 < multiplicity p a) (da : p \u2223 a) : p \u2223 b :=\n  by simpa [multiplicity_eq_zero] using (nh.trans_le hle).ne.symm"}
{"context": {"open": ["IsLocalization"], "variables": ["{R : Type*} [CommSemiring R] (S : Type*) [CommSemiring S]", "[Algebra R S] {P : Type*} [CommSemiring P]", "(P : Ideal R) [hp : P.IsPrime]", "{A : Type*} [CommRing A] [IsDomain A]", "(I : Ideal R) [hI : I.IsPrime] [IsLocalization.AtPrime S I]", "(I : Ideal R) [hI : I.IsPrime]", "{I}", "(I)", "{A B : Type*} [CommRing A] [CommRing B] [Algebra A B]", "{\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, CommSemiring (R i)]", "{i : \u03b9} (I : Ideal (R i)) [I.IsPrime]", "{R : Type*} [CommRing R] (q : Ideal R) [q.IsPrime] {S : Type*} [CommRing S] [Algebra R S]"]}, "declaration": "theorem Ideal_have_1 (R : Type u_9) (q : Ideal R) (S : Type u_10) (p : Ideal R) (hpq : p \u2264 q) : Disjoint (q.primeCompl : Set R) p :=\n  by simp [Ideal.primeCompl, \u2190 le_compl_iff_disjoint_left, hpq]"}
{"context": {"open": ["Nat PowerSeries"], "variables": ["(F : Type*) [Field F]", "{F}", "(F) in", "[CharZero F]"]}, "declaration": "theorem natDegree_hilbertPoly_of_ne_zero_have_1 (F : Type u_1) (hilbertPoly : x\u271d F X) (p : sorry) (d : \u2115) (hh : sorry \u2260 0) : p \u2260 0 :=\n  by intro h\n    rw [h] at hh\n    exact hh (hilbertPoly_zero_left d)"}
{"context": {"open": ["Nat PowerSeries"], "variables": ["(F : Type*) [Field F]", "{F}", "(F) in", "[CharZero F]"]}, "declaration": "theorem natDegree_hilbertPoly_of_ne_zero_have_2 (F : Type u_1) (hilbertPoly : x\u271d F X) (p : sorry) (d : \u2115) (hh : sorry \u2260 0) (hp : p \u2260 sorry) : p.rootMultiplicity 1 < d :=\n  by_contra h\n    exact hh (hilbertPoly_eq_zero_of_le_rootMultiplicity_one <| not_lt.1 h)"}
{"context": {"open": [], "variables": ["{R : Type*} [CommSemiring R]"]}, "declaration": "theorem _root__have_1 (R : Type u_1) (p : Polynomial R) (hp : Irreducible p) (r : R) (q : Polynomial R) (hq : p = Polynomial.C r * q) (H : IsUnit q) : r \u2260 0 :=\n  by rintro rfl; simp_all"}
{"context": {"open": ["MvPolynomial Set", "Finset (range)", "Finsupp (single)", "scoped Witt"], "variables": ["{p : \u2115} {R : Type*} {idx : Type*} [CommRing R]", "(p)", "[hp : Fact p.Prime]", "{p}", "(p)"]}, "declaration": "theorem constantCoeff_wittStructureInt_zero_have_1 (p : \u2115) (idx : Type u_2) (hp : Fact (Nat.Prime p)) (\u03a6 : MvPolynomial idx \u2124) : Function.Injective (Int.castRingHom \u211a) :=\n  by intro m n; exact Int.cast_inj.mp"}
{"context": {"open": ["MvPolynomial Set", "Finset (range)", "Finsupp (single)", "scoped Witt"], "variables": ["{p : \u2115} {R : Type*} {idx : Type*} [CommRing R]", "(p)", "[hp : Fact p.Prime]", "{p}", "(p)"]}, "declaration": "theorem constantCoeff_wittStructureInt_have_1 (p : \u2115) (idx : Type u_2) (hp : Fact (Nat.Prime p)) (\u03a6 : MvPolynomial idx \u2124) (h : constantCoeff \u03a6 = 0) (n : \u2115) : Function.Injective (Int.castRingHom \u211a) :=\n  by intro m n; exact Int.cast_inj.mp"}
{"context": {"open": ["Set TopologicalSpace Topology", "scoped Set.Notation"], "variables": ["{\u03b9 : Sort*} {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : X \u2192 Y}", "[T2Space X]"]}, "declaration": "theorem IsRetrocompact_have_1 (X : Type u_2) (Y : Type u_3) (f : X \u2192 Y) (s : Set Y) (hf : IsClosedEmbedding f) (hs : IsRetrocompact s) (U : Set X) (hUcomp : IsCompact U) (hUopen : IsOpen U) : IsOpen (f '' U \u222a (range f)\u1d9c) :=\n  by simpa [\u2190 range_diff_image hf.injective, sdiff_eq, compl_inter, union_comm]\n      using (hf.isClosedMap _ hUopen.isClosed_compl).isOpen_compl"}
{"context": {"open": ["Topology", "Set"], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 \ud835\udd5c : Type*} {f g : \u03b1 \u2192 \ud835\udd5c} {S : Set \u03b1} [TopologicalSpace \u03b1] [TopologicalSpace \ud835\udd5c]"]}, "declaration": "theorem IsPreconnected_have_1 (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) (this : DiscreteTopology \u2191{1, -1}) (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) (\u03b1 : Type u_6) (\ud835\udd5c : Type u_7) (f : \u03b1 \u2192 \ud835\udd5c) (S : Set \u03b1) (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) : MapsTo f S {1, -1} :=\n  by simpa only [EqOn,Pi.one_apply,Pi.pow_apply,sq_eq_one_iff] using hsq"}
{"context": {"open": ["CategoryTheory"], "variables": ["(P : TopCat.{u} \u2192 Prop)", "(X : Type u) [TopologicalSpace X] [CompactSpace X] [T2Space X]", "[HasProp P X]", "{X} {Y : Type u} [TopologicalSpace Y] [CompactSpace Y] [T2Space Y] [HasProp P Y]", "{Z : Type u} [TopologicalSpace Z] [CompactSpace Z] [T2Space Z] [HasProp P Z]", "{P}", "{P P' : TopCat \u2192 Prop} (h : \u2200 (X : CompHausLike P), P X.toTop \u2192 P' X.toTop)", "(P)", "{P}"]}, "declaration": "theorem isIso_of_bijective_have_1 (P : TopCat \u2192 Prop) (f : X \u27f6 Y) (bij : Function.Bijective \u21d1(ConcreteCategory.hom f)) (E : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij) : Continuous E.symm :=\n  by rw [continuous_iff_isClosed]\n    intro S hS\n    rw [\u2190 E.image_eq_preimage]\n    exact isClosedMap f S hS"}
{"context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "declaration": "theorem Topology_have_1 (X : Type u_1) (Y : Type u_2) (F : Set X) (f : X \u2192 Y) (hf : IsInducing f) (hx : x \u2208 F) (hy : y \u2208 F) (\u03b3 : Path (f x) (f y)) : x \u2933 \u03b3' 0 :=\n  by rw [\u2190 hf.specializes_iff, h\u03b3', \u03b3.source]"}
{"context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "declaration": "theorem Topology_have_2 (X : Type u_1) (Y : Type u_2) (F : Set X) (f : X \u2192 Y) (hf : IsInducing f) (hx : x \u2208 F) (hy : y \u2208 F) (\u03b3 : Path (f x) (f y)) (h\u2080 : sorry) : \u03b3' 1 \u2933 y :=\n  by rw [\u2190 hf.specializes_iff, h\u03b3', \u03b3.target]"}
{"context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "declaration": "theorem Topology_have_3 (X : Type u_1) (Y : Type u_2) (F : Set X) (f : X \u2192 Y) (hf : IsInducing f) (hx : x \u2208 F) (hy : y \u2208 F) (\u03b3 : Path (f x) (f y)) (h\u2080 : sorry) (h\u2081 : sorry) : JoinedIn F (\u03b3' 0) (\u03b3' 1) :=\n  by refine \u27e8\u27e8\u27e8\u03b3', ?_\u27e9, rfl, rfl\u27e9, h\u03b3'F\u27e9\n    simpa only [hf.continuous_iff,comp_def,h\u03b3'] using map_continuous \u03b3"}
{"context": {"open": ["ENNReal", "Function", "ENNReal", "Set Function"], "variables": ["{\u03b1 \u03b2 : Type*}", "[EDist \u03b1] {x y : \u03b1} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y z : \u03b1} {s : Set \u03b1}", "[PseudoMetricSpace \u03b1] {s : Set \u03b1}", "[EMetricSpace \u03b1] {s : Set \u03b1}", "[EDist \u03b1] {x y : \u03b1} {s : Set \u03b1}", "[PseudoEMetricSpace \u03b1] {x y : \u03b1}", "[PseudoMetricSpace \u03b1] {x y z : \u03b1} {s t : Set \u03b1}"]}, "declaration": "theorem _root__have_1 (\u03b1 : Type u_1) (s : Finset \u03b1) : (s : Set \u03b1).Nontrivial \u2194 s.offDiag.Nonempty :=\n  by rw [\u2190 Set.offDiag_nonempty]\n    rw [\u2190 Finset.coe_offDiag]\n    rw [Finset.coe_nonempty]"}
{"context": {"open": ["Set Filter Topology", "Uniformity", "UniformSpace (ball)", "UniformSpace", "uniformity", "Additive Multiplicative", "UniformSpace", "UniformSpace Function", "Sum"], "variables": ["{\u03b1 : Type ua} {\u03b2 : Type ub} {\u03b3 : Type uc} {\u03b4 : Type ud} {\u03b9 : Sort*}", "[UniformSpace \u03b1]", "(\u03b1)", "[UniformSpace \u03b1]", "[UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3]", "{\u03b4' : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] [UniformSpace \u03b3] [UniformSpace \u03b4]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[UniformSpace \u03b1]"]}, "declaration": "theorem exists_is_open_mem_uniformity_of_forall_mem_eq_have_1 (\u03b1 : Type ua) (\u03b2 : Type ub) (r : Set (\u03b1 \u00d7 \u03b1)) (s : Set \u03b2) (hf : \u2200 x \u2208 s, ContinuousAt f x) (hg : \u2200 x \u2208 s, ContinuousAt g x) (hfg : EqOn f g s) (hr : r \u2208 _root_.uniformity \u03b1) : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 \u2200 z \u2208 t, (f z, g z) \u2208 r :=\n  by intro x hx\n    obtain \u27e8t, ht, htsymm, htr\u27e9 := comp_symm_mem_uniformity_sets hr\n    have A : {z | (f x, f z) \u2208 t} \u2208 \ud835\udcdd x := (hf x hx).preimage_mem_nhds (mem_nhds_left (f x) ht)\n    have B : {z | (g x, g z) \u2208 t} \u2208 \ud835\udcdd x := (hg x hx).preimage_mem_nhds (mem_nhds_left (g x) ht)\n    rcases _root_.mem_nhds_iff.1 (inter_mem A B) with \u27e8u, hu, u_open, xu\u27e9\n    refine \u27e8u, u_open, xu, fun y hy \u21a6 ?_\u27e9\n    have I1 : (f y, f x) \u2208 t := (htsymm.mk_mem_comm).2 (hu hy).1\n    have I2 : (g x, g y) \u2208 t := (hu hy).2\n    rw [hfg hx] at I1\n    exact htr (prodMk_mem_compRel I1 I2)"}
{"context": {"open": [], "variables": []}, "declaration": "theorem my_theorem_have_1 (h\u2081 : 8 \u2264 n) (h\u2082 : 2 * k > n) (h\u2083 : k + 1 < n) : k + 1 \u2264 n :=\n  by linarith"}
{"context": {"open": [], "variables": []}, "declaration": "theorem my_theorem_have_2 (h\u2081 : 8 \u2264 n) (h\u2082 : 2 * k > n) (h\u2083 : k + 1 < n) (f\u2081 : k + 1 \u2264 n) : n - (k + 1) \u2264 n :=\n  by rify [f\u2081]; linarith"}
