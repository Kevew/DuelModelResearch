{"declaration": "theorem one_gradedMul (x : (\u2a01 i, \ud835\udc9c i) \u2297[R] (\u2a01 i, \u212c i)) :\n    gradedMul R \ud835\udc9c \u212c 1 x = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one,one_smul] using algebraMap_gradedMul \ud835\udc9c \u212c 1 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/TensorProduct/Graded/External.lean", "context": {"open": ["scoped TensorProduct DirectSum", "DirectSum (lof)", "TensorProduct (assoc map) in"], "variables": ["{R \u03b9 : Type*}", "[CommSemiring \u03b9] [Module \u03b9 (Additive \u2124\u02e3)] [DecidableEq \u03b9]", "(\ud835\udc9c : \u03b9 \u2192 Type*) (\u212c : \u03b9 \u2192 Type*)", "[CommRing R]", "[\u2200 i, AddCommGroup (\ud835\udc9c i)] [\u2200 i, AddCommGroup (\u212c i)]", "[\u2200 i, Module R (\ud835\udc9c i)] [\u2200 i, Module R (\u212c i)]", "(R)", "[DirectSum.GRing \ud835\udc9c] [DirectSum.GRing \u212c]", "[DirectSum.GAlgebra R \ud835\udc9c] [DirectSum.GAlgebra R \u212c]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ngradedMul : x\u271d\nx : sorry\n\u22a2 sorry = x"}, {"line": "simpa only [RingHom.map_one,one_smul] using algebraMap_gradedMul \ud835\udc9c \u212c 1 x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gradedMul_one (x : (\u2a01 i, \ud835\udc9c i) \u2297[R] (\u2a01 i, \u212c i)) :\n    gradedMul R \ud835\udc9c \u212c x 1 = x := by\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_one` to avoid timeouts.\n  simpa only [RingHom.map_one,one_smul] using gradedMul_algebraMap \ud835\udc9c \u212c x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/TensorProduct/Graded/External.lean", "context": {"open": ["scoped TensorProduct DirectSum", "DirectSum (lof)", "TensorProduct (assoc map) in"], "variables": ["{R \u03b9 : Type*}", "[CommSemiring \u03b9] [Module \u03b9 (Additive \u2124\u02e3)] [DecidableEq \u03b9]", "(\ud835\udc9c : \u03b9 \u2192 Type*) (\u212c : \u03b9 \u2192 Type*)", "[CommRing R]", "[\u2200 i, AddCommGroup (\ud835\udc9c i)] [\u2200 i, AddCommGroup (\u212c i)]", "[\u2200 i, Module R (\ud835\udc9c i)] [\u2200 i, Module R (\u212c i)]", "(R)", "[DirectSum.GRing \ud835\udc9c] [DirectSum.GRing \u212c]", "[DirectSum.GAlgebra R \ud835\udc9c] [DirectSum.GAlgebra R \u212c]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ngradedMul : x\u271d\nx : sorry\n\u22a2 sorry = x"}, {"line": "simpa only [RingHom.map_one,one_smul] using gradedMul_algebraMap \ud835\udc9c \u212c x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem existsUnique_prop {p q : Prop} : (\u2203! _ : p, q) \u2194 p \u2227 q := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/ExistsUnique.lean", "context": {"open": ["Lean", "TSyntax.Compat in"], "variables": ["{\u03b1 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\n\u22a2 (\u2203! x, q) \u2194 p \u2227 q"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "example [h : Nonempty \u03b1] [IsEmpty \u03b2] : IsEmpty (\u03b1 \u2192 \u03b2) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\n\u03b3 : Sort u_3\nh : Nonempty \u03b1\ninst\u271d : IsEmpty \u03b2\n\u22a2 IsEmpty (\u03b1 \u2192 \u03b2)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_Prop {p : Prop} : IsEmpty p \u2194 \u00acp := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\n\u22a2 IsEmpty p \u2194 \u00acp"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "p : Prop\n\u22a2 \u00acNonempty p \u2194 \u00acp"}, {"line": "simp only [nonempty_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_pi {\u03c0 : \u03b1 \u2192 Sort*} : IsEmpty (\u2200 a, \u03c0 a) \u2194 \u2203 a, IsEmpty (\u03c0 a) := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [Classical.nonempty_pi]\n  simp only [not_forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\n\u03c0 : \u03b1 \u2192 Sort u_4\n\u22a2 IsEmpty ((a : \u03b1) \u2192 \u03c0 a) \u2194 \u2203 a, IsEmpty (\u03c0 a)"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\n\u03c0 : \u03b1 \u2192 Sort u_4\n\u22a2 \u00acNonempty ((a : \u03b1) \u2192 \u03c0 a) \u2194 \u2203 a, \u00acNonempty (\u03c0 a)"}, {"line": "simp only [Classical.nonempty_pi]", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\n\u03c0 : \u03b1 \u2192 Sort u_4\n\u22a2 (\u00ac\u2200 (i : \u03b1), Nonempty (\u03c0 i)) \u2194 \u2203 a, \u00acNonempty (\u03c0 a)"}, {"line": "simp only [not_forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_fun : IsEmpty (\u03b1 \u2192 \u03b2) \u2194 Nonempty \u03b1 \u2227 IsEmpty \u03b2 := by\n  rw [isEmpty_pi]\n  rw [\u2190 exists_true_iff_nonempty]\n  rw [\u2190 exists_and_right]\n  rw [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 IsEmpty (\u03b1 \u2192 \u03b2) \u2194 Nonempty \u03b1 \u2227 IsEmpty \u03b2"}, {"line": "rw [isEmpty_pi]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 (\u2203 a, IsEmpty \u03b2) \u2194 Nonempty \u03b1 \u2227 IsEmpty \u03b2"}, {"line": "rw [\u2190 exists_true_iff_nonempty]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 (\u2203 a, IsEmpty \u03b2) \u2194 (\u2203 x, True) \u2227 IsEmpty \u03b2"}, {"line": "rw [\u2190 exists_and_right]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 (\u2203 a, IsEmpty \u03b2) \u2194 \u2203 x, True \u2227 IsEmpty \u03b2"}, {"line": "rw [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_sigma {\u03b1} {E : \u03b1 \u2192 Type*} : IsEmpty (Sigma E) \u2194 \u2200 a, IsEmpty (E a) := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_sigma]\n  simp only [not_exists]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nE : \u03b1 \u2192 Type u_4\n\u22a2 IsEmpty (Sigma E) \u2194 \u2200 (a : \u03b1), IsEmpty (E a)"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u_5\nE : \u03b1 \u2192 Type u_4\n\u22a2 \u00acNonempty (Sigma E) \u2194 \u2200 (a : \u03b1), \u00acNonempty (E a)"}, {"line": "simp only [nonempty_sigma]", "tactic_state": "\u03b1 : Type u_5\nE : \u03b1 \u2192 Type u_4\n\u22a2 (\u00ac\u2203 a, Nonempty (E a)) \u2194 \u2200 (a : \u03b1), \u00acNonempty (E a)"}, {"line": "simp only [not_exists]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_subtype (p : \u03b1 \u2192 Prop) : IsEmpty (Subtype p) \u2194 \u2200 x, \u00acp x := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_subtype]\n  simp only [not_exists]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 IsEmpty (Subtype p) \u2194 \u2200 (x : \u03b1), \u00acp x"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 \u00acNonempty (Subtype p) \u2194 \u2200 (x : \u03b1), \u00acp x"}, {"line": "simp only [nonempty_subtype]", "tactic_state": "\u03b1 : Sort u_1\ninst\u271d : IsEmpty \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u00ac\u2203 a, p a) \u2194 \u2200 (x : \u03b1), \u00acp x"}, {"line": "simp only [not_exists]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_prod {\u03b1 \u03b2 : Type*} : IsEmpty (\u03b1 \u00d7 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_prod]\n  simp only [not_and_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 IsEmpty (\u03b1 \u00d7 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 \u00acNonempty (\u03b1 \u00d7 \u03b2) \u2194 \u00acNonempty \u03b1 \u2228 \u00acNonempty \u03b2"}, {"line": "simp only [nonempty_prod]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 \u00ac(Nonempty \u03b1 \u2227 Nonempty \u03b2) \u2194 \u00acNonempty \u03b1 \u2228 \u00acNonempty \u03b2"}, {"line": "simp only [not_and_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_pprod : IsEmpty (PProd \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_pprod]\n  simp only [not_and_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 IsEmpty (\u03b1 \u00d7' \u03b2) \u2194 IsEmpty \u03b1 \u2228 IsEmpty \u03b2"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 \u00acNonempty (\u03b1 \u00d7' \u03b2) \u2194 \u00acNonempty \u03b1 \u2228 \u00acNonempty \u03b2"}, {"line": "simp only [nonempty_pprod]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : IsEmpty \u03b1\n\u22a2 \u00ac(Nonempty \u03b1 \u2227 Nonempty \u03b2) \u2194 \u00acNonempty \u03b1 \u2228 \u00acNonempty \u03b2"}, {"line": "simp only [not_and_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_sum {\u03b1 \u03b2} : IsEmpty (\u03b1 \u2295 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_sum]\n  simp only [not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 IsEmpty (\u03b1 \u2295 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 \u00acNonempty (\u03b1 \u2295 \u03b2) \u2194 \u00acNonempty \u03b1 \u2227 \u00acNonempty \u03b2"}, {"line": "simp only [nonempty_sum]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\n\u22a2 \u00ac(Nonempty \u03b1 \u2228 Nonempty \u03b2) \u2194 \u00acNonempty \u03b1 \u2227 \u00acNonempty \u03b2"}, {"line": "simp only [not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_psum {\u03b1 \u03b2} : IsEmpty (\u03b1 \u2295' \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_psum]\n  simp only [not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u22a2 IsEmpty (\u03b1 \u2295' \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u22a2 \u00acNonempty (\u03b1 \u2295' \u03b2) \u2194 \u00acNonempty \u03b1 \u2227 \u00acNonempty \u03b2"}, {"line": "simp only [nonempty_psum]", "tactic_state": "\u03b1 : Sort u_4\n\u03b2 : Sort u_5\n\u22a2 \u00ac(Nonempty \u03b1 \u2228 Nonempty \u03b2) \u2194 \u00acNonempty \u03b1 \u2227 \u00acNonempty \u03b2"}, {"line": "simp only [not_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_ulift {\u03b1} : IsEmpty (ULift \u03b1) \u2194 IsEmpty \u03b1 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_ulift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u22a2 IsEmpty (ULift.{u_5, u_4} \u03b1) \u2194 IsEmpty \u03b1"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u_4\n\u22a2 \u00acNonempty (ULift.{u_5, u_4} \u03b1) \u2194 \u00acNonempty \u03b1"}, {"line": "simp only [nonempty_ulift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEmpty_plift {\u03b1} : IsEmpty (PLift \u03b1) \u2194 IsEmpty \u03b1 := by\n  simp only [\u2190 not_nonempty_iff]\n  simp only [nonempty_plift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/IsEmpty.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*}", "[IsEmpty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_4\n\u22a2 IsEmpty (PLift \u03b1) \u2194 IsEmpty \u03b1"}, {"line": "simp only [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Sort u_4\n\u22a2 \u00acNonempty (PLift \u03b1) \u2194 \u00acNonempty \u03b1"}, {"line": "simp only [nonempty_plift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_assoc {a b c : Prop} : ((a \u2194 b) \u2194 c) \u2194 (a \u2194 (b \u2194 c)) := by tauto", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 ((a \u2194 b) \u2194 c) \u2194 (a \u2194 (b \u2194 c))"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_left_comm {a b c : Prop} : (a \u2194 (b \u2194 c)) \u2194 (b \u2194 (a \u2194 c)) := by tauto", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 (a \u2194 (b \u2194 c)) \u2194 (b \u2194 (a \u2194 c))"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iff_right_comm {a b c : Prop} : ((a \u2194 b) \u2194 c) \u2194 ((a \u2194 c) \u2194 b) := by tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : Prop\n\u22a2 ((a \u2194 b) \u2194 c) \u2194 ((a \u2194 c) \u2194 b)"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_dite_distrib_left {a : p \u2192 \u03b1} {b : \u00acp \u2192 q \u2192 \u03b1} {c : \u00acp \u2192 \u00acq \u2192 \u03b1} :\n    (dite p a fun hp \u21a6 dite q (b hp) (c hp)) =\n      dite q (fun hq \u21a6 (dite p a) fun hp \u21a6 b hp hq) fun hq \u21a6 (dite p a) fun hp \u21a6 c hp hq := by\n  split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort*} {p q : Prop} [Decidable p] [Decidable q] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\na : p \u2192 \u03b1\nb : \u00acp \u2192 q \u2192 \u03b1\nc : \u00acp \u2192 \u00acq \u2192 \u03b1\n\u22a2 (dite p a fun hp => dite q (b hp) (c hp)) = if hq : q then dite p a fun hp => b hp hq else dite p a fun hp => c hp hq"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_dite_distrib_right {a : p \u2192 q \u2192 \u03b1} {b : p \u2192 \u00acq \u2192 \u03b1} {c : \u00acp \u2192 \u03b1} :\n    dite p (fun hp \u21a6 dite q (a hp) (b hp)) c =\n      dite q (fun hq \u21a6 dite p (fun hp \u21a6 a hp hq) c) fun hq \u21a6 dite p (fun hp \u21a6 b hp hq) c := by\n  split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort*} {p q : Prop} [Decidable p] [Decidable q] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\np q : Prop\ninst\u271d\u00b9 : Decidable p\ninst\u271d : Decidable q\na : p \u2192 q \u2192 \u03b1\nb : p \u2192 \u00acq \u2192 \u03b1\nc : \u00acp \u2192 \u03b1\n\u22a2 dite p (fun hp => dite q (a hp) (b hp)) c =\n    if hq : q then dite p (fun hp => a hp hq) c else dite p (fun hp => b hp hq) c"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Unique.bijective {A B} [Unique A] [Unique B] {f : A \u2192 B} : Function.Bijective f := by\n  rw [Function.bijective_iff_has_inverse]\n  refine \u27e8default, ?_, ?_\u27e9 <;> intro x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Unique.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort*} [Unique \u03b1]", "{\u03b1 : Sort*}", "{\u03b1 : Sort*}", "{\u03b2 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 : Sort*} {\u03b1 : \u03b9 \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Sort u_7\nB : Sort u_8\ninst\u271d\u00b9 : Unique A\ninst\u271d : Unique B\nf : A \u2192 B\n\u22a2 Bijective f"}, {"line": "rw [Function.bijective_iff_has_inverse]", "tactic_state": "A : Sort u_7\nB : Sort u_8\ninst\u271d\u00b9 : Unique A\ninst\u271d : Unique B\nf : A \u2192 B\n\u22a2 \u2203 g, LeftInverse g f \u2227 RightInverse g f"}, {"line": "refine \u27e8default, ?_, ?_\u27e9 <;> intro x <;> simp", "tactic_state": "case refine_1\nA : Sort u_7\nB : Sort u_8\ninst\u271d\u00b9 : Unique A\ninst\u271d : Unique B\nf : A \u2192 B\nx : A\n\u22a2 sorry () (f x) = x\n---\ncase refine_2\nA : Sort u_7\nB : Sort u_8\ninst\u271d\u00b9 : Unique A\ninst\u271d : Unique B\nf : A \u2192 B\nx : B\n\u22a2 f (sorry () x) = x"}]}
{"declaration": "theorem xor_not_not : Xor' (\u00aca) (\u00acb) \u2194 Xor' a b := by simp [Xor', or_comm, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Prop\n\u22a2 Xor' (\u00aca) \u00acb \u2194 Xor' a b"}, {"line": "simp [Xor', or_comm, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_symm_right {\u03b1 : Sort*} (a b : \u03b1) (p : Prop) : p \u2227 a = b \u2194 p \u2227 b = a := by simp [eq_comm]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_2\na b : \u03b1\np : Prop\n\u22a2 p \u2227 a = b \u2194 p \u2227 b = a"}, {"line": "simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem and_symm_left {\u03b1 : Sort*} (a b : \u03b1) (p : Prop) : a = b \u2227 p \u2194 b = a \u2227 p := by simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_2\na b : \u03b1\np : Prop\n\u22a2 a = b \u2227 p \u2194 b = a \u2227 p"}, {"line": "simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem imp_and_neg_imp_iff (p q : Prop) : (p \u2192 q) \u2227 (\u00acp \u2192 q) \u2194 q := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : Prop\n\u22a2 (p \u2192 q) \u2227 (\u00acp \u2192 q) \u2194 q"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xor_iff_iff_not : Xor' a b \u2194 (a \u2194 \u00acb) := by simp only [\u2190 @xor_not_right a, not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Prop\n\u22a2 Xor' a b \u2194 (a \u2194 \u00acb)"}, {"line": "simp only [\u2190 @xor_not_right a, not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xor_iff_not_iff' : Xor' a b \u2194 (\u00aca \u2194 b) := by simp only [\u2190 @xor_not_left _ b, not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Prop\n\u22a2 Xor' a b \u2194 (\u00aca \u2194 b)"}, {"line": "simp only [\u2190 @xor_not_left _ b, not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem xor_iff_or_and_not_and (a b : Prop) : Xor' a b \u2194 (a \u2228 b) \u2227 (\u00ac (a \u2227 b)) := by\n  rw [Xor']\n  rw [or_and_right]\n  rw [not_and_or]\n  rw [and_or_left]\n  rw [and_not_self_iff]\n  rw [false_or]\n  rw [and_or_left]\n  rw [and_not_self_iff]\n  rw [or_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : Prop\n\u22a2 Xor' a b \u2194 (a \u2228 b) \u2227 \u00ac(a \u2227 b)"}, {"line": "rw [Xor']", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 (a \u2228 b) \u2227 \u00ac(a \u2227 b)"}, {"line": "rw [or_and_right]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 a \u2227 \u00ac(a \u2227 b) \u2228 b \u2227 \u00ac(a \u2227 b)"}, {"line": "rw [not_and_or]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 a \u2227 (\u00aca \u2228 \u00acb) \u2228 b \u2227 (\u00aca \u2228 \u00acb)"}, {"line": "rw [and_or_left]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 (a \u2227 \u00aca \u2228 a \u2227 \u00acb) \u2228 b \u2227 (\u00aca \u2228 \u00acb)"}, {"line": "rw [and_not_self_iff]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 (False \u2228 a \u2227 \u00acb) \u2228 b \u2227 (\u00aca \u2228 \u00acb)"}, {"line": "rw [false_or]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 a \u2227 \u00acb \u2228 b \u2227 (\u00aca \u2228 \u00acb)"}, {"line": "rw [and_or_left]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2228 b \u2227 \u00acb"}, {"line": "rw [and_not_self_iff]", "tactic_state": "a b : Prop\n\u22a2 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2194 a \u2227 \u00acb \u2228 b \u2227 \u00aca \u2228 False"}, {"line": "rw [or_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_dite {a : \u03b1} {s : p \u2192 \u03b2} {t : \u00acp \u2192 \u03b2} :\n    (a \u2208 if h : p then s h else t h) \u2194 (\u2200 h, a \u2208 s h) \u2227 (\u2200 h, a \u2208 t h) := by\n  by_cases h : p <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Membership \u03b1 \u03b2\np : Prop\ninst\u271d : Decidable p\na : \u03b1\ns : p \u2192 \u03b2\nt : \u00acp \u2192 \u03b2\n\u22a2 (a \u2208 if h : p then s h else t h) \u2194 (\u2200 (h : p), a \u2208 s h) \u2227 \u2200 (h : \u00acp), a \u2208 t h"}, {"line": "by_cases h : p <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_mem {a : p \u2192 \u03b1} {b : \u00acp \u2192 \u03b1} {s : \u03b2} :\n    (if h : p then a h else b h) \u2208 s \u2194 (\u2200 h, a h \u2208 s) \u2227 (\u2200 h, b h \u2208 s) := by\n  by_cases h : p <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9 : Membership \u03b1 \u03b2\np : Prop\ninst\u271d : Decidable p\na : p \u2192 \u03b1\nb : \u00acp \u2192 \u03b1\ns : \u03b2\n\u22a2 (if h : p then a h else b h) \u2208 s \u2194 (\u2200 (h : p), a h \u2208 s) \u2227 \u2200 (h : \u00acp), b h \u2208 s"}, {"line": "by_cases h : p <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma imp_forall_iff_forall (A : Prop) (B : A \u2192 Prop) :\n  (A \u2192 \u2200 h : A, B h) \u2194 \u2200 h : A, B h := by by_cases h : A <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Prop\nB : A \u2192 Prop\n\u22a2 (A \u2192 \u2200 (h : A), B h) \u2194 \u2200 (h : A), B h"}, {"line": "by_cases h : A <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall\u2082_true_iff {\u03b2 : \u03b1 \u2192 Sort*} : (\u2200 a, \u03b2 a \u2192 True) \u2194 True := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_7\n\u03b2 : \u03b1 \u2192 Sort u_9\n\u22a2 (\u2200 (a : \u03b1), \u03b2 a \u2192 True) \u2194 True"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall\u2083_true_iff {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*} :\n    (\u2200 (a) (b : \u03b2 a), \u03b3 a b \u2192 True) \u2194 True := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_7\n\u03b2 : \u03b1 \u2192 Sort u_9\n\u03b3 : (a : \u03b1) \u2192 \u03b2 a \u2192 Sort u_10\n\u22a2 (\u2200 (a : \u03b1) (b : \u03b2 a), \u03b3 a b \u2192 True) \u2194 True"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_apply_eq_imp_iff' {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 a b, f a = b \u2192 p b) \u2194 \u2200 a, p (f a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_7\n\u03b2 : Sort u_8\nf : \u03b1 \u2192 \u03b2\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 (a : \u03b1) (b : \u03b2), f a = b \u2192 p b) \u2194 \u2200 (a : \u03b1), p (f a)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_eq_apply_imp_iff' {f : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} :\n    (\u2200 a b, b = f a \u2192 p b) \u2194 \u2200 a, p (f a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_7\n\u03b2 : Sort u_8\nf : \u03b1 \u2192 \u03b2\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 (a : \u03b1) (b : \u03b2), b = f a \u2192 p b) \u2194 \u2200 (a : \u03b1), p (f a)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists\u2082_comm\n    {\u03b9\u2081 \u03b9\u2082 : Sort*} {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort*} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort*} {p : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Prop} :\n    (\u2203 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082 := by\n  simp only [@exists_comm (\u03ba\u2081 _)]\n  simp only [@exists_comm \u03b9\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u2081 : Sort u_9\n\u03b9\u2082 : Sort u_10\n\u03ba\u2081 : \u03b9\u2081 \u2192 Sort u_11\n\u03ba\u2082 : \u03b9\u2082 \u2192 Sort u_12\np : (i\u2081 : \u03b9\u2081) \u2192 \u03ba\u2081 i\u2081 \u2192 (i\u2082 : \u03b9\u2082) \u2192 \u03ba\u2082 i\u2082 \u2192 Prop\n\u22a2 (\u2203 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082"}, {"line": "simp only [@exists_comm (\u03ba\u2081 _)]", "tactic_state": "\u03b9\u2081 : Sort u_9\n\u03b9\u2082 : Sort u_10\n\u03ba\u2081 : \u03b9\u2081 \u2192 Sort u_11\n\u03ba\u2082 : \u03b9\u2082 \u2192 Sort u_12\np : (i\u2081 : \u03b9\u2081) \u2192 \u03ba\u2081 i\u2081 \u2192 (i\u2082 : \u03b9\u2082) \u2192 \u03ba\u2082 i\u2082 \u2192 Prop\n\u22a2 (\u2203 i\u2081 b b_1 a, p i\u2081 a b b_1) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082"}, {"line": "simp only [@exists_comm \u03b9\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Decidable.forall_or_right {q} {p : \u03b1 \u2192 Prop} [Decidable q] :\n    (\u2200 x, p x \u2228 q) \u2194 (\u2200 x, p x) \u2228 q := by simp [or_comm, Decidable.forall_or_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_7\nq : Prop\np : \u03b1 \u2192 Prop\ninst\u271d : Decidable q\n\u22a2 (\u2200 (x : \u03b1), p x \u2228 q) \u2194 (\u2200 (x : \u03b1), p x) \u2228 q"}, {"line": "simp [or_comm, Decidable.forall_or_left]", "tactic_state": "\u03b1 : Sort u_7\nq : Prop\np : \u03b1 \u2192 Prop\ninst\u271d : Decidable q\n\u22a2 (\u2200 (x : \u03b1), q \u2228 p x) \u2194 q \u2228 \u2200 (x : \u03b1), p x"}]}
{"declaration": "theorem exists_mem_or_left :\n    (\u2203 (x : _) (_ : p x \u2228 q x), r x) \u2194 (\u2203 (x : _) (_ : p x), r x) \u2228 \u2203 (x : _) (_ : q x), r x := by\n  simp only [exists_prop]\n  exact Iff.trans (exists_congr fun x \u21a6 or_and_right) exists_or\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_10\nr p q : \u03b1 \u2192 Prop\n\u22a2 (\u2203 x, \u2203 (_ : p x \u2228 q x), r x) \u2194 (\u2203 x, \u2203 (_ : p x), r x) \u2228 \u2203 x, \u2203 (_ : q x), r x"}, {"line": "simp only [exists_prop]", "tactic_state": "\u03b1 : Sort u_10\nr p q : \u03b1 \u2192 Prop\n\u22a2 (\u2203 x, (p x \u2228 q x) \u2227 r x) \u2194 (\u2203 x, p x \u2227 r x) \u2228 \u2203 x, q x \u2227 r x"}, {"line": "exact Iff.trans (exists_congr fun x \u21a6 or_and_right) exists_or", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_eq_iff : dite P A B = c \u2194 (\u2203 h, A h = c) \u2228 \u2203 h, B h = c := by\n  by_cases P <;> simp [*, exists_prop_of_true, exists_prop_of_false]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\ninst\u271d : Decidable P\n\u03b1\u271d : Sort u_13\nA : P \u2192 \u03b1\u271d\nB : \u00acP \u2192 \u03b1\u271d\nc : \u03b1\u271d\n\u22a2 dite P A B = c \u2194 (\u2203 (h : P), A h = c) \u2228 \u2203 (h : \u00acP), B h = c"}, {"line": "by_cases P <;> simp [*, exists_prop_of_true, exists_prop_of_false]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_ne_left_iff : dite P (fun _ \u21a6 a) B \u2260 a \u2194 \u2203 h, a \u2260 B h := by\n  rw [Ne]\n  rw [dite_eq_left_iff]\n  rw [not_forall]\n  exact exists_congr fun h \u21a6 by rw [ne_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP : Prop\ninst\u271d : Decidable P\nB : \u00acP \u2192 \u03b1\n\u22a2 dite P (fun x => a) B \u2260 a \u2194 \u2203 (h : \u00acP), a \u2260 B h"}, {"line": "rw [Ne]", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP : Prop\ninst\u271d : Decidable P\nB : \u00acP \u2192 \u03b1\n\u22a2 \u00acdite P (fun x => a) B = a \u2194 \u2203 (h : \u00acP), a \u2260 B h"}, {"line": "rw [dite_eq_left_iff]", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP : Prop\ninst\u271d : Decidable P\nB : \u00acP \u2192 \u03b1\n\u22a2 (\u00ac\u2200 (h : \u00acP), B h = a) \u2194 \u2203 (h : \u00acP), a \u2260 B h"}, {"line": "rw [not_forall]", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP : Prop\ninst\u271d : Decidable P\nB : \u00acP \u2192 \u03b1\n\u22a2 (\u2203 (x : \u00acP), \u00acB x = a) \u2194 \u2203 (h : \u00acP), a \u2260 B h"}, {"line": "exact exists_congr fun h \u21a6 by rw [ne_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_ne_right_iff : (dite P A fun _ \u21a6 b) \u2260 b \u2194 \u2203 h, A h \u2260 b := by\n  simp only [Ne]\n  simp only [dite_eq_right_iff]\n  simp only [not_forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Sort u\nb : \u03b2\nP : Prop\ninst\u271d : Decidable P\nA : P \u2192 \u03b2\n\u22a2 (dite P A fun x => b) \u2260 b \u2194 \u2203 (h : P), A h \u2260 b"}, {"line": "simp only [Ne]", "tactic_state": "\u03b2 : Sort u\nb : \u03b2\nP : Prop\ninst\u271d : Decidable P\nA : P \u2192 \u03b2\n\u22a2 \u00ac(dite P A fun x => b) = b \u2194 \u2203 (h : P), \u00acA \u22ef = b"}, {"line": "simp only [dite_eq_right_iff]", "tactic_state": "\u03b2 : Sort u\nb : \u03b2\nP : Prop\ninst\u271d : Decidable P\nA : P \u2192 \u03b2\n\u22a2 (\u00ac\u2200 (h : P), A h = b) \u2194 \u2203 (h : P), \u00acA \u22ef = b"}, {"line": "simp only [not_forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_dite\u2082 {\u03b1 \u03b2 \u03b3 : Sort*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (P : Prop) [Decidable P]\n    (a : P \u2192 \u03b1) (b : \u00acP \u2192 \u03b1) (c : P \u2192 \u03b2) (d : \u00acP \u2192 \u03b2) :\n    f (dite P a b) (dite P c d) = dite P (fun h \u21a6 f (a h) (c h)) fun h \u21a6 f (b h) (d h) := by\n  by_cases h : P <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_13\n\u03b2 : Sort u_14\n\u03b3 : Sort u_15\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nP : Prop\ninst\u271d : Decidable P\na : P \u2192 \u03b1\nb : \u00acP \u2192 \u03b1\nc : P \u2192 \u03b2\nd : \u00acP \u2192 \u03b2\n\u22a2 f (dite P a b) (dite P c d) = if h : P then f (a h) (c h) else f (b h) (d h)"}, {"line": "by_cases h : P <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_apply (f : P \u2192 \u2200 a, \u03c3 a) (g : \u00acP \u2192 \u2200 a, \u03c3 a) (a : \u03b1) :\n    (dite P f g) a = dite P (fun h \u21a6 f h a) fun h \u21a6 g h a := by by_cases h : P <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_11\n\u03c3 : \u03b1 \u2192 Sort u_12\nP : Prop\ninst\u271d : Decidable P\nf : P \u2192 (a : \u03b1) \u2192 \u03c3 a\ng : \u00acP \u2192 (a : \u03b1) \u2192 \u03c3 a\na : \u03b1\n\u22a2 dite P f g a = if h : P then f h a else g h a"}, {"line": "by_cases h : P <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_and : ite (P \u2227 Q) a b = ite P (ite Q a b) b := by\n  by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP Q : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\n\u22a2 (if P \u2227 Q then a else sorry) = if P then if Q then a else sorry else sorry"}, {"line": "by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_or : ite (P \u2228 Q) a b = ite P a (ite Q a b) := by\n  by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\na : \u03b1\nP Q : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\n\u22a2 (if P \u2228 Q then a else sorry) = if P then a else if Q then a else sorry"}, {"line": "by_cases hp : P <;> by_cases hq : Q <;> simp [hp, hq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_prop_iff_or : (if P then Q else R) \u2194 (P \u2227 Q \u2228 \u00ac P \u2227 R) := by\n  by_cases p : P <;> simp [p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]", "{P Q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\n\u22a2 (if P then Q else R) \u2194 P \u2227 Q \u2228 \u00acP \u2227 R"}, {"line": "by_cases p : P <;> simp [p]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_prop_iff_or {Q : P \u2192 Prop} {R : \u00acP \u2192 Prop} :\n    dite P Q R \u2194 (\u2203 p, Q p) \u2228 (\u2203 p, R p) := by\n  by_cases h : P <;> simp [h, exists_prop_of_false, exists_prop_of_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]", "{P Q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\ninst\u271d : Decidable P\nQ : P \u2192 Prop\nR : \u00acP \u2192 Prop\n\u22a2 dite P Q R \u2194 (\u2203 (p : P), Q p) \u2228 \u2203 (p : \u00acP), R p"}, {"line": "by_cases h : P <;> simp [h, exists_prop_of_false, exists_prop_of_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_prop_iff_and : (if P then Q else R) \u2194 ((P \u2192 Q) \u2227 (\u00ac P \u2192 R)) := by\n  by_cases p : P <;> simp [p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]", "{P Q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P Q R : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Decidable Q\n\u22a2 (if P then Q else R) \u2194 (P \u2192 Q) \u2227 (\u00acP \u2192 R)"}, {"line": "by_cases p : P <;> simp [p]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dite_prop_iff_and {Q : P \u2192 Prop} {R : \u00acP \u2192 Prop} :\n    dite P Q R \u2194 (\u2200 h, Q h) \u2227 (\u2200 h, R h) := by\n  by_cases h : P <;> simp [h, forall_prop_of_false, forall_prop_of_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]", "{P Q}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Prop\ninst\u271d : Decidable P\nQ : P \u2192 Prop\nR : \u00acP \u2192 Prop\n\u22a2 dite P Q R \u2194 (\u2200 (h : P), Q h) \u2227 \u2200 (h : \u00acP), R h"}, {"line": "by_cases h : P <;> simp [h, forall_prop_of_false, forall_prop_of_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem beq_ext {\u03b1 : Type*} (inst1 : BEq \u03b1) (inst2 : BEq \u03b1)\n    (h : \u2200 x y, @BEq.beq _ inst1 x y = @BEq.beq _ inst2 x y) :\n    inst1 = inst2 := by\n  have \u27e8beq1\u27e9 := inst1\n  have \u27e8beq2\u27e9 := inst2\n  congr\n  funext x y\n  exact h x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Basic.lean", "context": {"open": ["Function", "Function"], "variables": ["{\u03b1 : Sort*}", "{a b : Prop}", "{\u03b1 \u03b2 : Type*} [Membership \u03b1 \u03b2] {p : Prop} [Decidable p]", "{\u03b1 \u03b2 : Sort u} {e : \u03b2 = \u03b1} {a : \u03b1} {b : \u03b2}", "{\u03b1 : Sort*} {\u03b2 : \u03b1 \u2192 Sort*} {\u03b3 : \u2200 a, \u03b2 a \u2192 Sort*}", "{\u03b1 \u03b2 : Sort*} {p : \u03b1 \u2192 Prop}", "{\u03b1 : Sort*}", "{\u03b1 : Sort*} {r p q : \u03b1 \u2192 Prop} {P Q : \u2200 x, p x \u2192 Prop}", "{\u03b1 : Sort*} {\u03c3 : \u03b1 \u2192 Sort*} {P Q R : Prop} [Decidable P]", "(P Q a b)", "[Decidable Q]", "{P Q}", "[Decidable Q] {x y u v : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\ninst1 inst2 : BEq \u03b1\nh : \u2200 (x y : \u03b1), (x == y) = (x == y)\n\u22a2 inst1 = inst2"}, {"line": "have \u27e8beq1\u27e9 := inst1", "tactic_state": "\u03b1 : Type u_13\ninst1 inst2 : BEq \u03b1\nbeq1 : \u03b1 \u2192 \u03b1 \u2192 Bool\nh : \u2200 (x y : \u03b1), (x == y) = (x == y)\n\u22a2 { beq := beq1 } = inst2"}, {"line": "have \u27e8beq2\u27e9 := inst2", "tactic_state": "\u03b1 : Type u_13\ninst1 inst2 : BEq \u03b1\nbeq1 beq2 : \u03b1 \u2192 \u03b1 \u2192 Bool\nh : \u2200 (x y : \u03b1), (x == y) = (x == y)\n\u22a2 { beq := beq1 } = { beq := beq2 }"}, {"line": "congr", "tactic_state": "case e_beq\n\u03b1 : Type u_13\ninst1 inst2 : BEq \u03b1\nbeq1 beq2 : \u03b1 \u2192 \u03b1 \u2192 Bool\nh : \u2200 (x y : \u03b1), (x == y) = (x == y)\n\u22a2 beq1 = beq2"}, {"line": "funext x y", "tactic_state": "case e_beq.h.h\n\u03b1 : Type u_13\ninst1 inst2 : BEq \u03b1\nbeq1 beq2 : \u03b1 \u2192 \u03b1 \u2192 Bool\nh : \u2200 (x y : \u03b1), (x == y) = (x == y)\nx y : \u03b1\n\u22a2 beq1 x y = beq2 x y"}, {"line": "exact h x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_ofNat_val (n : \u2115) :\n    ofNat (\u03b1 \u00d7 \u03b2) n = (ofNat \u03b1 (unpair n).1, ofNat \u03b2 (unpair n).2) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Denumerable.lean", "context": {"open": ["Finset Nat", "Encodable"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Denumerable \u03b1] [Denumerable \u03b2]", "{\u03b3 : \u03b1 \u2192 Type*} [\u2200 a, Denumerable (\u03b3 a)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nofNat : x\u271d\nn : \u2115\n\u22a2 sorry = (sorry, sorry)"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_4\nofNat : x\u271d\nn : \u2115\n\u22a2 sorry () = (sorry (), sorry ())"}]}
{"declaration": "lemma cutExpand_add_right {s' s} (t) : CutExpand r (s' + t) (s + t) \u2194 CutExpand r s' s := by\n  convert cutExpand_add_left t using 2 <;> apply add_comm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Hydra.lean", "context": {"open": ["Multiset Prod"], "variables": ["{\u03b1 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nCutExpand : x\u271d\ns' : ?m.857\ns : ?m.858\nt : ?m.859\n\u22a2 sorry \u2194 sorry"}, {"line": "convert cutExpand_add_left t using 2 <;> apply add_comm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Reflexive.rel_of_ne_imp (h : Reflexive r) {x y : \u03b1} (hr : x \u2260 y \u2192 r x y) : r x y := by\n  by_cases hxy : x = y\n  \u00b7 exact hxy \u25b8 h x\n  \u00b7 exact hr hxy\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\n\u22a2 r x y"}, {"line": "by_cases hxy : x = y", "tactic_state": "case pos\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : x = y\n\u22a2 r x y\n---\ncase neg\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : \u00acx = y\n\u22a2 r x y"}, {"line": "\u00b7 exact hxy \u25b8 h x", "tactic_state": "case neg\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : Reflexive r\nx y : \u03b1\nhr : x \u2260 y \u2192 r x y\nhxy : \u00acx = y\n\u22a2 r x y"}, {"line": "\u00b7 exact hr hxy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_apply_apply (hf : Injective f) (hg : Injective g) (r : \u03b1 \u2192 \u03b2 \u2192 Prop) (a : \u03b1) (b : \u03b2) :\n    Relation.Map r f g (f a) (g b) \u2194 r a b := by simp [Relation.Map, hf.eq_iff, hg.eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\nhf : Injective f\nhg : Injective g\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\n\u22a2 Relation.Map r f g (f a) (g b) \u2194 r a b"}, {"line": "simp [Relation.Map, hf.eq_iff, hg.eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_reflexive {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r) {f : \u03b1 \u2192 \u03b2} (hf : f.Surjective) :\n    Reflexive (Relation.Map r f f) := by\n  intro x\n  obtain \u27e8y, rfl\u27e9 := hf x\n  exact \u27e8y, y, hr y, rfl, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Reflexive r\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 Reflexive (Relation.Map r f f)"}, {"line": "intro x", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Reflexive r\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\nx : \u03b2\n\u22a2 Relation.Map r f f x x"}, {"line": "obtain \u27e8y, rfl\u27e9 := hf x", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Reflexive r\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ny : \u03b1\n\u22a2 Relation.Map r f f (f y) (f y)"}, {"line": "exact \u27e8y, y, hr y, rfl, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_transitive {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Transitive r) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 x y, f x = f y \u2192 r x y) :\n    Transitive (Relation.Map r f f) := by\n  rintro _ _ _ \u27e8x, y, hxy, rfl, rfl\u27e9 \u27e8y', z, hyz, hy, rfl\u27e9\n  exact \u27e8x, z, hr hxy <| hr (hf _ _ hy.symm) hyz, rfl, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Transitive r\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y \u2192 r x y\n\u22a2 Transitive (Relation.Map r f f)"}, {"line": "rintro _ _ _ \u27e8x, y, hxy, rfl, rfl\u27e9 \u27e8y', z, hyz, hy, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Transitive r\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y \u2192 r x y\nx y : \u03b1\nhxy : r x y\ny' z : \u03b1\nhyz : r y' z\nhy : f y' = f y\n\u22a2 Relation.Map r f f (f x) (f z)"}, {"line": "exact \u27e8x, z, hr hxy <| hr (hf _ _ hy.symm) hyz, rfl, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cases_head_iff : ReflTransGen r a b \u2194 a = b \u2228 \u2203 c, r a c \u2227 ReflTransGen r c b := by\n  use cases_head\n  rintro (rfl | \u27e8c, hac, hcb\u27e9)\n  \u00b7 rfl\n  \u00b7 exact head hac hcb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nx\u271d : Sort u_7\nReflTransGen : x\u271d\n\u22a2 sorry \u2194 a = b \u2228 \u2203 c, r a c \u2227 sorry"}, {"line": "use cases_head", "tactic_state": "case mpr\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nx\u271d : Sort u_7\nReflTransGen : x\u271d\n\u22a2 (a = b \u2228 \u2203 c, r a c \u2227 sorry) \u2192 sorry"}, {"line": "rintro (rfl | \u27e8c, hac, hcb\u27e9)", "tactic_state": "case mpr.inl\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na : \u03b1\nx\u271d : Sort u_7\nReflTransGen : x\u271d\n\u22a2 sorry\n---\ncase mpr.inr.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nx\u271d : Sort u_7\nReflTransGen : x\u271d\nc : \u03b1\nhac : r a c\nhcb : sorry\n\u22a2 sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case mpr.inr.intro.intro\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nx\u271d : Sort u_7\nReflTransGen : x\u271d\nc : \u03b1\nhac : r a c\nhcb : sorry\n\u22a2 sorry"}, {"line": "\u00b7 exact head hac hcb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma reflGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Reflexive r') (h : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1}\n    (hxy : ReflGen r x y) : r' x y := by\n  simpa [reflGen_eq_self hr'] using ReflGen.mono h hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_7\nReflGen : x\u271d\nr' : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr' : Reflexive r'\nh : \u2200 (x y : \u03b1), r x y \u2192 r' x y\nx y : \u03b1\nhxy : sorry\n\u22a2 r' x y"}, {"line": "simpa [reflGen_eq_self hr'] using ReflGen.mono h hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TransGen.lift' {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b, r a b \u2192 TransGen p (f a) (f b)) (hab : TransGen r a b) :\n    TransGen p (f a) (f b) := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_7\nTransGen : x\u271d\np : \u03b2 \u2192 \u03b2 \u2192 Prop\na b : \u03b1\nf : \u03b1 \u2192 \u03b2\nh : (a b : \u03b1) \u2192 r a b \u2192 sorry\nhab : sorry\n\u22a2 sorry"}]}
{"declaration": "lemma transGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr' : Transitive r') (h : \u2200 x y, r x y \u2192 r' x y)\n    {x y : \u03b1} (hxy : TransGen r x y) : r' x y := by\n  simpa [transGen_eq_self hr'] using TransGen.mono h hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_7\nTransGen : x\u271d\nr' : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr' : Transitive r'\nh : \u2200 (x y : \u03b1), r x y \u2192 r' x y\nx y : \u03b1\nhxy : sorry\n\u22a2 r' x y"}, {"line": "simpa [transGen_eq_self hr'] using TransGen.mono h hxy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma reflTransGen_minimal {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr\u2081 : Reflexive r') (hr\u2082 : Transitive r')\n    (h : \u2200 x y, r x y \u2192 r' x y) {x y : \u03b1} (hxy : ReflTransGen r x y) : r' x y := by\n  simpa [reflTransGen_eq_self hr\u2081 hr\u2082] using ReflTransGen.mono h hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function", "ReflTransGen"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_7\nReflTransGen : x\u271d\nr' : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr\u2081 : Reflexive r'\nhr\u2082 : Transitive r'\nh : \u2200 (x y : \u03b1), r x y \u2192 r' x y\nx y : \u03b1\nhxy : sorry\n\u22a2 r' x y"}, {"line": "simpa [reflTransGen_eq_self hr\u2081 hr\u2082] using ReflTransGen.mono h hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ReflTransGen.lift' {p : \u03b2 \u2192 \u03b2 \u2192 Prop} {a b : \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (h : \u2200 a b, r a b \u2192 ReflTransGen p (f a) (f b))\n    (hab : ReflTransGen r a b) : ReflTransGen p (f a) (f b) := by\n  simpa [reflTransGen_idem] using hab.lift f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Relation.lean", "context": {"open": ["Function", "ReflTransGen"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 \u03b6 : Type*}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{r : \u03b2 \u2192 \u03b2 \u2192 Prop}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b2 \u2192 \u03b3 \u2192 Prop} {q : \u03b3 \u2192 \u03b4 \u2192 Prop}", "(r\u03b1 : \u03b1 \u2192 \u03b1 \u2192 Prop) (r\u03b2 : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2)", "{r\u03b1 r\u03b2}", "{r : \u03b1 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {c : \u03b3} {d : \u03b4}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a b c : \u03b1}", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nx\u271d : Sort u_7\nReflTransGen : x\u271d\np : \u03b2 \u2192 \u03b2 \u2192 Prop\na b : \u03b1\nf : \u03b1 \u2192 \u03b2\nh : (a b : \u03b1) \u2192 r a b \u2192 sorry\nhab : sorry\n\u22a2 sorry"}, {"line": "simpa [reflTransGen_idem] using hab.lift f h", "tactic_state": "No Goals!"}]}
{"declaration": "example : \u00ac UnivLE.{u+1, u} := by\n  simp only [univLE_iff]\n  simp only [small_iff]\n  simp only [not_forall]\n  simp only [not_exists]\n  simp only [not_nonempty_iff]\n  exact \u27e8Type u, fun \u03b1 => \u27e8fun f => Function.not_surjective_Type.{u, u} f.symm f.symm.surjective\u27e9\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/UnivLE.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acUnivLE.{u + 1, u}"}, {"line": "simp only [univLE_iff]", "tactic_state": "\u22a2 \u00ac\u2200 (\u03b1 : Type (u + 1)), Small.{u, u + 1} \u03b1"}, {"line": "simp only [small_iff]", "tactic_state": "\u22a2 \u00ac\u2200 (\u03b1 : Type (u + 1)), \u2203 S, Nonempty (\u03b1 \u2243 S)"}, {"line": "simp only [not_forall]", "tactic_state": "\u22a2 \u2203 x, \u00ac\u2203 S, Nonempty (x \u2243 S)"}, {"line": "simp only [not_exists]", "tactic_state": "\u22a2 \u2203 x, \u2200 (x_1 : Type u), \u00acNonempty (x \u2243 x_1)"}, {"line": "simp only [not_nonempty_iff]", "tactic_state": "\u22a2 \u2203 x, \u2200 (x_1 : Type u), IsEmpty (x \u2243 x_1)"}, {"line": "exact \u27e8Type u, fun \u03b1 => \u27e8fun f => Function.not_surjective_Type.{u, u} f.symm f.symm.surjective\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equiv_toEmbedding_trans_symm_toEmbedding {\u03b1 \u03b2 : Sort*} (e : \u03b1 \u2243 \u03b2) :\n    e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\n\u22a2 e.toEmbedding.trans e.symm.toEmbedding = sorry"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b1\n\u22a2 (e.toEmbedding.trans e.symm.toEmbedding) x\u271d = sorry x\u271d"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b1\n\u22a2 x\u271d = (sorry ()) x\u271d"}]}
{"declaration": "theorem equiv_symm_toEmbedding_trans_toEmbedding {\u03b1 \u03b2 : Sort*} (e : \u03b1 \u2243 \u03b2) :\n    e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\n\u22a2 e.symm.toEmbedding.trans e.toEmbedding = sorry"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b2\n\u22a2 (e.symm.toEmbedding.trans e.toEmbedding) x\u271d = sorry x\u271d"}, {"line": "simp", "tactic_state": "case h\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ne : \u03b1 \u2243 \u03b2\nx\u271d : \u03b2\n\u22a2 x\u271d = (sorry ()) x\u271d"}]}
{"declaration": "theorem setValue_eq {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (b : \u03b2) [\u2200 a', Decidable (a' = a)]\n    [\u2200 a', Decidable (f a' = b)] : setValue f a b a = b := by\n  simp [setValue]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = b)\n\u22a2 sorry = b"}, {"line": "simp [setValue]", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nb : \u03b2\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = b)\n\u22a2 sorry () = b"}]}
{"declaration": "lemma setValue_eq_of_ne {\u03b1 \u03b2} {f : \u03b1 \u21aa \u03b2} {a : \u03b1} {b : \u03b2} {c : \u03b1} [\u2200 a', Decidable (a' = a)]\n    [\u2200 a', Decidable (f a' = b)] (hc : c \u2260 a) (hb : f c \u2260 b) : setValue f a b c = f c := by\n  simp [setValue, hc, hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = b)\nhc : c \u2260 a\nhb : f c \u2260 b\n\u22a2 sorry = f c"}, {"line": "simp [setValue, hc, hb]", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na : \u03b1\nb : \u03b2\nc : \u03b1\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = b)\nhc : c \u2260 a\nhb : f c \u2260 b\n\u22a2 sorry () = f c"}]}
{"declaration": "lemma setValue_right_apply_eq {\u03b1 \u03b2} (f : \u03b1 \u21aa \u03b2) (a c : \u03b1) [\u2200 a', Decidable (a' = a)]\n    [\u2200 a', Decidable (f a' = f c)] : setValue f a (f c) c = f a := by\n  simp [setValue]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na c : \u03b1\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = f c)\n\u22a2 sorry = f a"}, {"line": "simp [setValue]", "tactic_state": "x\u271d : Sort u_1\nsetValue : x\u271d\n\u03b1 : Sort u_2\n\u03b2 : Sort u_3\nf : \u03b1 \u21aa \u03b2\na c : \u03b1\ninst\u271d\u00b9 : (a' : \u03b1) \u2192 Decidable (a' = a)\ninst\u271d : (a' : \u03b1) \u2192 Decidable (f a' = f c)\n\u22a2 sorry () = f a"}]}
{"declaration": "theorem embeddingCongr_apply_trans {\u03b1\u2081 \u03b2\u2081 \u03b3\u2081 \u03b1\u2082 \u03b2\u2082 \u03b3\u2082 : Sort*} (ea : \u03b1\u2081 \u2243 \u03b1\u2082) (eb : \u03b2\u2081 \u2243 \u03b2\u2082)\n    (ec : \u03b3\u2081 \u2243 \u03b3\u2082) (f : \u03b1\u2081 \u21aa \u03b2\u2081) (g : \u03b2\u2081 \u21aa \u03b3\u2081) :\n    Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Embedding/Basic.lean", "context": {"open": ["Sum", "Set", "Function Embedding"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} (f : \u03b1 \u2243 \u03b2)", "{\u03b1 \u03b1' : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b2' : \u03b1' \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Sort u_5\n\u03b2\u2081 : Sort u_6\n\u03b3\u2081 : Sort u_7\n\u03b1\u2082 : Sort u_8\n\u03b2\u2082 : Sort u_9\n\u03b3\u2082 : Sort u_10\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u21aa \u03b2\u2081\ng : \u03b2\u2081 \u21aa \u03b3\u2081\n\u22a2 (ea.embeddingCongr ec) (f.trans g) = ((ea.embeddingCongr eb) f).trans ((eb.embeddingCongr ec) g)"}, {"line": "ext", "tactic_state": "case h\n\u03b1\u2081 : Sort u_5\n\u03b2\u2081 : Sort u_6\n\u03b3\u2081 : Sort u_7\n\u03b1\u2082 : Sort u_8\n\u03b2\u2082 : Sort u_9\n\u03b3\u2082 : Sort u_10\nea : \u03b1\u2081 \u2243 \u03b1\u2082\neb : \u03b2\u2081 \u2243 \u03b2\u2082\nec : \u03b3\u2081 \u2243 \u03b3\u2082\nf : \u03b1\u2081 \u21aa \u03b2\u2081\ng : \u03b2\u2081 \u21aa \u03b3\u2081\nx\u271d : \u03b1\u2082\n\u22a2 ((ea.embeddingCongr ec) (f.trans g)) x\u271d = (((ea.embeddingCongr eb) f).trans ((eb.embeddingCongr ec) g)) x\u271d"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem decode\u2082_encode [Encodable \u03b1] (a : \u03b1) : decode\u2082 \u03b1 (encode a) = some a := by\n  ext\n  simp [mem_decode\u2082, eq_comm, decode\u2082_eq_some]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Encodable/Basic.lean", "context": {"open": ["Option List Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_3\ndecode\u2082 : x\u271d\ninst\u271d : Encodable \u03b1\na : \u03b1\n\u22a2 sorry = some a"}, {"line": "ext", "tactic_state": "case a\n\u03b1 : Type u_1\nx\u271d : Sort u_3\ndecode\u2082 : x\u271d\ninst\u271d : Encodable \u03b1\na a\u271d : \u03b1\n\u22a2 a\u271d \u2208 sorry \u2194 a\u271d \u2208 some a"}, {"line": "simp [mem_decode\u2082, eq_comm, decode\u2082_eq_some]", "tactic_state": "case a\n\u03b1 : Type u_1\nx\u271d : Sort u_3\ndecode\u2082 : x\u271d\ninst\u271d : Encodable \u03b1\na a\u271d : \u03b1\n\u22a2 some a\u271d = sorry () \u2194 a = a\u271d"}]}
{"declaration": "theorem up_down {a : \u03b1} : (down a).up = a := by\n  simp [up, down,Equiv.left_inv _ _, Equiv.symm_apply_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Encodable/Basic.lean", "context": {"open": ["Option List Nat Function", "Subtype Decidable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[Encodable \u03b1] [Encodable \u03b2]", "{\u03b3 : \u03b1 \u2192 Type*} [Encodable \u03b1] [\u2200 a, Encodable (\u03b3 a)]", "[Encodable \u03b1] [Encodable \u03b2]", "{P : \u03b1 \u2192 Prop} [encA : Encodable \u03b1] [decP : DecidablePred P]", "(\u03b1 : Type*) [Encodable \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Encodable \u03b1\nx\u271d : Sort u_5\ndown : x\u271d\na : \u03b1\n\u22a2 sorry = a"}, {"line": "simp [up, down,Equiv.left_inv _ _, Equiv.symm_apply_apply]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : Encodable \u03b1\nx\u271d : Sort u_5\ndown : x\u271d\na : \u03b1\n\u22a2 sorry () = a"}]}
{"declaration": "theorem sequence_mono_nat {r : \u03b2 \u2192 \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Directed r f) (n : \u2115) :\n    r (f (hf.sequence f n)) (f (hf.sequence f (n + 1))) := by\n  dsimp [Directed.sequence]\n  generalize hf.sequence f n = p\n  rcases (decode n : Option \u03b1) with - | a\n  \u00b7 exact (Classical.choose_spec (hf p p)).1\n  \u00b7 exact (Classical.choose_spec (hf p a)).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Encodable/Basic.lean", "context": {"open": ["Option List Nat Function", "Subtype Decidable", "Encodable", "Encodable"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[Encodable \u03b1] [Encodable \u03b2]", "{\u03b3 : \u03b1 \u2192 Type*} [Encodable \u03b1] [\u2200 a, Encodable (\u03b3 a)]", "[Encodable \u03b1] [Encodable \u03b2]", "{P : \u03b1 \u2192 Prop} [encA : Encodable \u03b1] [decP : DecidablePred P]", "(\u03b1 : Type*) [Encodable \u03b1]", "{\u03b1}", "{\u03b1 : Type*} (p : \u03b1 \u2192 Prop) [Encodable \u03b1] [DecidablePred p]", "{p}", "{\u03b1 : Type*} {\u03b2 : Type*} [Encodable \u03b1] [Inhabited \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\n\u22a2 r (f (Directed.sequence f hf n)) (f (Directed.sequence f hf (n + 1)))"}, {"line": "dsimp [Directed.sequence]", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\n\u22a2 r (f (Directed.sequence f hf n))\n    (f\n      (match decode n with\n      | none => Classical.choose \u22ef\n      | some a => Classical.choose \u22ef))"}, {"line": "generalize hf.sequence f n = p", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\np : ?m.3983\n\u22a2 r (f (Directed.sequence f hf n))\n    (f\n      (match decode n with\n      | none => Classical.choose \u22ef\n      | some a => Classical.choose \u22ef))"}, {"line": "rcases (decode n : Option \u03b1) with - | a", "tactic_state": "case none\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\np : ?m.3983\n\u22a2 r (f (Directed.sequence f hf n))\n    (f\n      (match decode n with\n      | none => Classical.choose \u22ef\n      | some a => Classical.choose \u22ef))\n---\ncase some\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\np : ?m.3983\na : \u03b1\n\u22a2 r (f (Directed.sequence f hf n))\n    (f\n      (match decode n with\n      | none => Classical.choose \u22ef\n      | some a => Classical.choose \u22ef))"}, {"line": "\u00b7 exact (Classical.choose_spec (hf p p)).1", "tactic_state": "case some\n\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b9 : Encodable \u03b1\ninst\u271d : Inhabited \u03b1\nr : \u03b2 \u2192 \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nhf : Directed r f\nn : \u2115\np a : \u03b1\n\u22a2 r (f (Directed.sequence f hf n))\n    (f\n      (match decode n with\n      | none => Classical.choose \u22ef\n      | some a => Classical.choose \u22ef))"}, {"line": "\u00b7 exact (Classical.choose_spec (hf p a)).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mapEquiv_refl_refl : mapEquiv F (Equiv.refl \u03b1) (Equiv.refl \u03b1') = Equiv.refl (F \u03b1 \u03b1') := by\n  ext x\n  simp [id_bimap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Functor.lean", "context": {"open": ["Equiv"], "variables": ["{\u03b1 \u03b2 : Type u}", "(f : Type u \u2192 Type v) [Functor f] [LawfulFunctor f]", "{\u03b1' \u03b2' : Type v} (F : Type u \u2192 Type v \u2192 Type w) [Bifunctor F] [LawfulBifunctor F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b1' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nmapEquiv : x\u271d\n\u22a2 sorry = Equiv.refl (F \u03b1 \u03b1')"}, {"line": "ext x", "tactic_state": "case H\n\u03b1 : Type u\n\u03b1' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nmapEquiv : x\u271d\nx : F \u03b1 \u03b1'\n\u22a2 sorry x = (Equiv.refl (F \u03b1 \u03b1')) x"}, {"line": "simp [id_bimap]", "tactic_state": "case H\n\u03b1 : Type u\n\u03b1' : Type v\nF : Type u \u2192 Type v \u2192 Type w\ninst\u271d\u00b9 : Bifunctor F\ninst\u271d : LawfulBifunctor F\nx\u271d : Sort u_1\nmapEquiv : x\u271d\nx : F \u03b1 \u03b1'\n\u22a2 (sorry ()) x = x"}]}
{"declaration": "theorem Perm.subtypeCongr.apply (a : \u03b5) : ep.subtypeCongr en a =\n    if h : p a then (ep \u27e8a, h\u27e9 : \u03b5) else en \u27e8a, h\u27e9 := by\n  by_cases h : p a <;> simp [Perm.subtypeCongr, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np\u271d : \u03b5\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b5\n\u22a2 sorry = if h : p a then sorry else sorry"}, {"line": "by_cases h : p a <;> simp [Perm.subtypeCongr, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Perm.subtypeCongr.left_apply {a : \u03b5} (h : p a) : ep.subtypeCongr en a = ep \u27e8a, h\u27e9 := by\n  simp [Perm.subtypeCongr.apply, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np\u271d : \u03b5\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b5\nh : p a\n\u22a2 sorry = sorry"}, {"line": "simp [Perm.subtypeCongr.apply, h]", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np\u271d : \u03b5\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b5\nh : p a\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Perm.subtypeCongr.right_apply {a : \u03b5} (h : \u00acp a) : ep.subtypeCongr en a = en \u27e8a, h\u27e9 := by\n  simp [Perm.subtypeCongr.apply, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np\u271d : \u03b5\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b5\nh : \u00acp a\n\u22a2 sorry = sorry"}, {"line": "simp [Perm.subtypeCongr.apply, h]", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np\u271d : \u03b5\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\np : \u03b5 \u2192 Prop\ninst\u271d : DecidablePred p\na : \u03b5\nh : \u00acp a\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Perm.subtypeCongr.refl :\n    Perm.subtypeCongr (Equiv.refl { a // p a }) (Equiv.refl { a // \u00acp a }) = Equiv.refl \u03b5 := by\n  ext x\n  by_cases h : p x <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np : \u03b5\u271d \u2192 Prop\ninst\u271d : DecidablePred p\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\n\u22a2 sorry = Equiv.refl \u03b5"}, {"line": "ext x", "tactic_state": "case H\nPerm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np : \u03b5\u271d \u2192 Prop\ninst\u271d : DecidablePred p\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\nx : \u03b5\n\u22a2 sorry x = (Equiv.refl \u03b5) x"}, {"line": "by_cases h : p x <;> simp [h]", "tactic_state": "case pos\nPerm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np : \u03b5\u271d \u2192 Prop\ninst\u271d : DecidablePred p\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\nx : \u03b5\nh : p sorry\n\u22a2 (sorry ()) x = x\n---\ncase neg\nPerm : ?m.1786\n\u03b1 : Sort u_1\n\u03b1\u2081 : Sort u_2\n\u03b1\u2082 : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081 : Sort u_5\n\u03b2\u2082 : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5\u271d : Type u_9\np : \u03b5\u271d \u2192 Prop\ninst\u271d : DecidablePred p\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\n\u03b5 : Type u_9\nx : \u03b5\nh : \u00acp sorry\n\u22a2 (sorry ()) x = x"}]}
{"declaration": "theorem subtypeEquiv_refl {p : \u03b1 \u2192 Prop} (h : \u2200 a, p a \u2194 p (Equiv.refl _ a) := fun _ => Iff.rfl) :\n    (Equiv.refl \u03b1).subtypeEquiv h = Equiv.refl { a : \u03b1 // p a } := by\n  ext\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.5330\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\n\u03b1 : Sort u_1\np : \u03b1 \u2192 Prop\nh : optParam (\u2200 (a : \u03b1), p a \u2194 p ((Equiv.refl \u03b1) a)) \u22ef\n\u22a2 (Equiv.refl \u03b1).subtypeEquiv h = Equiv.refl { a // p a }"}, {"line": "ext", "tactic_state": "case H.a\nPerm : ?m.5330\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\n\u03b1 : Sort u_1\np : \u03b1 \u2192 Prop\nh : optParam (\u2200 (a : \u03b1), p a \u2194 p ((Equiv.refl \u03b1) a)) \u22ef\nx\u271d : { a // p a }\n\u22a2 \u2191(((Equiv.refl \u03b1).subtypeEquiv h) x\u271d) = \u2191((Equiv.refl { a // p a }) x\u271d)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Perm.extendDomain_apply_image (a : \u03b1') : e.extendDomain f (f a) = f (e a) := by\n  simp [Perm.extendDomain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1'\u271d : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1'\u271d \u2243 Subtype p\u271d\n\u03b1' : Type u_16\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\na : \u03b1'\n\u22a2 sorry = f sorry"}, {"line": "simp [Perm.extendDomain]", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1'\u271d : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1'\u271d \u2243 Subtype p\u271d\n\u03b1' : Type u_16\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\na : \u03b1'\n\u22a2 sorry () = f (sorry ())"}]}
{"declaration": "theorem Perm.extendDomain_apply_subtype {b : \u03b2'} (h : p b) :\n    e.extendDomain f b = f (e (f.symm \u27e8b, h\u27e9)) := by\n  simp [Perm.extendDomain, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1'\u271d : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1'\u271d \u2243 Subtype p\u271d\n\u03b1' : Type u_16\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\nb : \u03b2'\nh : p b\n\u22a2 sorry = f sorry"}, {"line": "simp [Perm.extendDomain, h]", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1'\u271d : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf\u271d : \u03b1'\u271d \u2243 Subtype p\u271d\n\u03b1' : Type u_16\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\nb : \u03b2'\nh : p b\n\u22a2 sorry () = f (sorry ())"}]}
{"declaration": "theorem Perm.extendDomain_apply_not_subtype {b : \u03b2'} (h : \u00acp b) : e.extendDomain f b = b := by\n  simp [Perm.extendDomain, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf : \u03b1' \u2243 Subtype p\u271d\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nb : \u03b2'\nh : \u00acp b\n\u22a2 sorry = b"}, {"line": "simp [Perm.extendDomain, h]", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b2 : \u03b5 \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\u00b2\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d\u00b9 : \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nx\u2080 : { a // p\u271d\u00b9 a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b2 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2'\u271d : Type u_17\ne : sorry\np\u271d : \u03b2'\u271d \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\nf : \u03b1' \u2243 Subtype p\u271d\n\u03b2' : Type u_17\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nb : \u03b2'\nh : \u00acp b\n\u22a2 sorry () = b"}]}
{"declaration": "theorem Perm.extendDomain_refl : Perm.extendDomain (Equiv.refl _) f = Equiv.refl _ := by\n  simp [Perm.extendDomain]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b9 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\n\u22a2 sorry = Equiv.refl ?m.11232"}, {"line": "simp [Perm.extendDomain]", "tactic_state": "Perm : ?m.9014\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u00b3 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1 \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b9 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1' \u2243 Subtype p\n\u22a2 sorry () = Equiv.refl ?m.11232"}]}
{"declaration": "theorem setValue_eq (f : \u03b1 \u2243 \u03b2) (a : \u03b1) (b : \u03b2) : setValue f a b a = b := by\n  simp [setValue, swap_apply_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2075 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b3 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_18\nsetValue : x\u271d\nf : \u03b1 \u2243 \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 sorry = b"}, {"line": "simp [setValue, swap_apply_left]", "tactic_state": "Perm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2075 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b3 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_18\nsetValue : x\u271d\nf : \u03b1 \u2243 \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 sorry () = b"}]}
{"declaration": "theorem Function.Injective.map_swap [DecidableEq \u03b1] [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (x y z : \u03b1) :\n    f (Equiv.swap x y z) = Equiv.swap (f x) (f y) (f z) := by\n  conv_rhs => rw [Equiv.swap_apply_def]\n  split_ifs with h\u2081 h\u2082\n  \u00b7 rw [hf h\u2081, Equiv.swap_apply_left]\n  \u00b7 rw [hf h\u2082, Equiv.swap_apply_right]\n  \u00b7 rw [Equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h\u2081) (mt (congr_arg f) h\u2082)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\n\u22a2 f ((Equiv.swap x y) z) = (Equiv.swap (f x) (f y)) (f z)"}, {"line": "conv_rhs => rw [Equiv.swap_apply_def]", "tactic_state": "Perm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\n\u22a2 f ((Equiv.swap x y) z) = if f z = f x then f y else if f z = f y then f x else f z"}, {"line": "split_ifs with h\u2081 h\u2082", "tactic_state": "case pos\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : f z = f x\n\u22a2 f ((Equiv.swap x y) z) = f y\n---\ncase pos\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : \u00acf z = f x\nh\u2082 : f z = f y\n\u22a2 f ((Equiv.swap x y) z) = f x\n---\ncase neg\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : \u00acf z = f x\nh\u2082 : \u00acf z = f y\n\u22a2 f ((Equiv.swap x y) z) = f z"}, {"line": "\u00b7 rw [hf h\u2081, Equiv.swap_apply_left]", "tactic_state": "case pos\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : \u00acf z = f x\nh\u2082 : f z = f y\n\u22a2 f ((Equiv.swap x y) z) = f x\n---\ncase neg\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : \u00acf z = f x\nh\u2082 : \u00acf z = f y\n\u22a2 f ((Equiv.swap x y) z) = f z"}, {"line": "\u00b7 rw [hf h\u2082, Equiv.swap_apply_right]", "tactic_state": "case neg\nPerm : ?m.11278\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y z : \u03b1\nh\u2081 : \u00acf z = f x\nh\u2082 : \u00acf z = f y\n\u22a2 f ((Equiv.swap x y) z) = f z"}, {"line": "\u00b7 rw [Equiv.swap_apply_of_ne_of_ne (mt (congr_arg f) h\u2081) (mt (congr_arg f) h\u2082)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piCongr'_symm_apply_symm_apply (f : \u2200 b, Z b) (b : \u03b2) :\n    (h\u2081.piCongr' h\u2082).symm f (h\u2081.symm b) = (h\u2082 b).symm (f b) := by\n  simp [piCongr', piCongr_apply_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype", "Sum"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)", "[DecidableEq \u03b1]", "(P : \u03b2 \u2192 Sort w) (e : \u03b1 \u2243 \u03b2)", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 a : \u03b1, W a \u2243 Z (h\u2081 a))", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 b : \u03b2, W (h\u2081.symm b) \u2243 Z b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.18365\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2075 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081 : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081 : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d\u00b9 : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u00b3 : DecidableEq X\nx : X\n\u03b1' : Type u_16\n\u03b2' : Type u_17\ne\u271d : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u00b2 : DecidablePred p\nf\u271d : \u03b1' \u2243 Subtype p\ninst\u271d\u00b9 : DecidableEq \u03b1\u271d\nP : \u03b2\u271d \u2192 Sort w\ne : \u03b1\u271d \u2243 \u03b2\u271d\nW\u271d\u00b9 : \u03b1\u271d \u2192 Sort w\nZ\u271d\u00b9 : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d\u00b9 : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d\u00b9 : (a : \u03b1\u271d) \u2192 W\u271d\u00b9 a \u2243 Z\u271d\u00b9 (h\u2081\u271d\u00b9 a)\nW\u271d : \u03b1\u271d \u2192 Sort w\nZ\u271d : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d : (b : \u03b2\u271d) \u2192 W\u271d (h\u2081\u271d.symm b) \u2243 Z\u271d b\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d : DecidableEq \u03b1\nW : \u03b1 \u2192 Sort w\nZ : \u03b2 \u2192 Sort z\nh\u2081 : \u03b1 \u2243 \u03b2\nh\u2082 : (b : \u03b2) \u2192 W (h\u2081.symm b) \u2243 Z b\nf : (b : \u03b2) \u2192 Z b\nb : \u03b2\n\u22a2 (h\u2081.piCongr' h\u2082).symm f (h\u2081.symm b) = (h\u2082 b).symm (f b)"}, {"line": "simp [piCongr', piCongr_apply_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piCongrLeft'_update [DecidableEq \u03b1] [DecidableEq \u03b2] (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2)\n    (f : \u2200 a, P a) (b : \u03b2) (x : P (e.symm b)) :\n    e.piCongrLeft' P (update f (e.symm b) x) = update (e.piCongrLeft' P f) b x := by\n  ext b'\n  rcases eq_or_ne b' b with (rfl | h) <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype", "Sum"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)", "[DecidableEq \u03b1]", "(P : \u03b2 \u2192 Sort w) (e : \u03b1 \u2243 \u03b2)", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 a : \u03b1, W a \u2243 Z (h\u2081 a))", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 b : \u03b2, W (h\u2081.symm b) \u2243 Z b)", "{\u03b1\u2081 \u03b2\u2081 : Type*} (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081)", "{\u03b1' : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.23312\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d\u00b9 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d\u00b9 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081\u271d : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081\u271d : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d\u00b3 : \u03b1\u2081\u271d \u2192 \u03b2\u2081\u271d \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1'\u271d : Type u_16\n\u03b2' : Type u_17\ne\u271d\u00b2 : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d\u00b9 : \u03b1'\u271d \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\nP\u271d : \u03b2\u271d \u2192 Sort w\ne\u271d\u00b9 : \u03b1\u271d \u2243 \u03b2\u271d\nW\u271d : \u03b1\u271d \u2192 Sort w\nZ\u271d : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d : (a : \u03b1\u271d) \u2192 W\u271d a \u2243 Z\u271d (h\u2081\u271d a)\nW : \u03b1\u271d \u2192 Sort w\nZ : \u03b2\u271d \u2192 Sort z\nh\u2081 : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082 : (b : \u03b2\u271d) \u2192 W (h\u2081.symm b) \u2243 Z b\n\u03b1\u2081 : Type u_18\n\u03b2\u2081 : Type u_19\ne\u271d : \u03b1\u2081 \u2243 \u03b2\u2081\nf\u271d : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081\n\u03b1' : Sort u_20\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nP : \u03b1 \u2192 Sort u_21\ne : \u03b1 \u2243 \u03b2\nf : (a : \u03b1) \u2192 P a\nb : \u03b2\nx : P (e.symm b)\n\u22a2 (Equiv.piCongrLeft' P e) (update f (e.symm b) x) = update ((Equiv.piCongrLeft' P e) f) b x"}, {"line": "ext b'", "tactic_state": "case h\nPerm : ?m.23312\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d\u00b9 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d\u00b9 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081\u271d : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081\u271d : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d\u00b3 : \u03b1\u2081\u271d \u2192 \u03b2\u2081\u271d \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1'\u271d : Type u_16\n\u03b2' : Type u_17\ne\u271d\u00b2 : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d\u00b9 : \u03b1'\u271d \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\nP\u271d : \u03b2\u271d \u2192 Sort w\ne\u271d\u00b9 : \u03b1\u271d \u2243 \u03b2\u271d\nW\u271d : \u03b1\u271d \u2192 Sort w\nZ\u271d : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d : (a : \u03b1\u271d) \u2192 W\u271d a \u2243 Z\u271d (h\u2081\u271d a)\nW : \u03b1\u271d \u2192 Sort w\nZ : \u03b2\u271d \u2192 Sort z\nh\u2081 : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082 : (b : \u03b2\u271d) \u2192 W (h\u2081.symm b) \u2243 Z b\n\u03b1\u2081 : Type u_18\n\u03b2\u2081 : Type u_19\ne\u271d : \u03b1\u2081 \u2243 \u03b2\u2081\nf\u271d : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081\n\u03b1' : Sort u_20\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nP : \u03b1 \u2192 Sort u_21\ne : \u03b1 \u2243 \u03b2\nf : (a : \u03b1) \u2192 P a\nb : \u03b2\nx : P (e.symm b)\nb' : \u03b2\n\u22a2 (Equiv.piCongrLeft' P e) (update f (e.symm b) x) b' = update ((Equiv.piCongrLeft' P e) f) b x b'"}, {"line": "rcases eq_or_ne b' b with (rfl | h) <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piCongrLeft'_symm_update [DecidableEq \u03b1] [DecidableEq \u03b2] (P : \u03b1 \u2192 Sort*) (e : \u03b1 \u2243 \u03b2)\n    (f : \u2200 b, P (e.symm b)) (b : \u03b2) (x : P (e.symm b)) :\n    (e.piCongrLeft' P).symm (update f b x) = update ((e.piCongrLeft' P).symm f) (e.symm b) x := by\n  simp [(e.piCongrLeft' P).symm_apply_eq, piCongrLeft'_update]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Basic.lean", "context": {"open": ["Function", "Sum", "Sum Nat", "Subtype", "Sum"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b5 : Type*} {p : \u03b5 \u2192 Prop} [DecidablePred p]", "(ep ep' : Perm { a // p a }) (en en' : Perm { a // \u00acp a })", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (x\u2080 : { a // p a } \u2192 \u03b2)", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{X Y : Sort*} [DecidableEq X] {x : X}", "{\u03b1' \u03b2' : Type*} (e : Perm \u03b1') {p : \u03b2' \u2192 Prop} [DecidablePred p] (f : \u03b1' \u2243 Subtype p)", "[DecidableEq \u03b1]", "(P : \u03b2 \u2192 Sort w) (e : \u03b1 \u2243 \u03b2)", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 a : \u03b1, W a \u2243 Z (h\u2081 a))", "{W : \u03b1 \u2192 Sort w} {Z : \u03b2 \u2192 Sort z} (h\u2081 : \u03b1 \u2243 \u03b2) (h\u2082 : \u2200 b : \u03b2, W (h\u2081.symm b) \u2243 Z b)", "{\u03b1\u2081 \u03b2\u2081 : Type*} (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081)", "{\u03b1' : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.23312\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d\u00b9 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d\u00b9 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081\u271d : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081\u271d : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d\u00b3 : \u03b1\u2081\u271d \u2192 \u03b2\u2081\u271d \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1'\u271d : Type u_16\n\u03b2' : Type u_17\ne\u271d\u00b2 : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d\u00b9 : \u03b1'\u271d \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\nP\u271d : \u03b2\u271d \u2192 Sort w\ne\u271d\u00b9 : \u03b1\u271d \u2243 \u03b2\u271d\nW\u271d : \u03b1\u271d \u2192 Sort w\nZ\u271d : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d : (a : \u03b1\u271d) \u2192 W\u271d a \u2243 Z\u271d (h\u2081\u271d a)\nW : \u03b1\u271d \u2192 Sort w\nZ : \u03b2\u271d \u2192 Sort z\nh\u2081 : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082 : (b : \u03b2\u271d) \u2192 W (h\u2081.symm b) \u2243 Z b\n\u03b1\u2081 : Type u_18\n\u03b2\u2081 : Type u_19\ne\u271d : \u03b1\u2081 \u2243 \u03b2\u2081\nf\u271d : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081\n\u03b1' : Sort u_20\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nP : \u03b1 \u2192 Sort u_21\ne : \u03b1 \u2243 \u03b2\nf : (b : \u03b2) \u2192 P (e.symm b)\nb : \u03b2\nx : P (e.symm b)\n\u22a2 (Equiv.piCongrLeft' P e).symm (update f b x) = update ((Equiv.piCongrLeft' P e).symm f) (e.symm b) x"}, {"line": "simp [(e.piCongrLeft' P).symm_apply_eq, piCongrLeft'_update]", "tactic_state": "Perm : ?m.23312\n\u03b1\u271d : Sort u_1\n\u03b1\u2081\u271d\u00b9 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2\u271d : Sort u_4\n\u03b2\u2081\u271d\u00b9 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b5 : Type u_9\np\u271d\u00b9 : \u03b5 \u2192 Prop\ninst\u271d\u2077 : DecidablePred p\u271d\u00b9\nep : sorry\nep' : sorry\nen : sorry\nen' : sorry\np\u271d : \u03b1\u271d \u2192 Prop\ninst\u271d\u2076 : DecidablePred p\u271d\nx\u2080 : { a // p\u271d a } \u2192 \u03b2\u271d\n\u03b1\u2081\u271d : Type u_10\n\u03b1\u2082 : Type u_11\n\u03b2\u2081\u271d : Type u_12\n\u03b2\u2082 : Type u_13\ne\u271d\u00b3 : \u03b1\u2081\u271d \u2192 \u03b2\u2081\u271d \u2243 \u03b2\u2082\nX : Sort u_14\nY : Sort u_15\ninst\u271d\u2075 : DecidableEq X\nx\u271d : X\n\u03b1'\u271d : Type u_16\n\u03b2' : Type u_17\ne\u271d\u00b2 : sorry\np : \u03b2' \u2192 Prop\ninst\u271d\u2074 : DecidablePred p\nf\u271d\u00b9 : \u03b1'\u271d \u2243 Subtype p\ninst\u271d\u00b3 : DecidableEq \u03b1\u271d\nP\u271d : \u03b2\u271d \u2192 Sort w\ne\u271d\u00b9 : \u03b1\u271d \u2243 \u03b2\u271d\nW\u271d : \u03b1\u271d \u2192 Sort w\nZ\u271d : \u03b2\u271d \u2192 Sort z\nh\u2081\u271d : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082\u271d : (a : \u03b1\u271d) \u2192 W\u271d a \u2243 Z\u271d (h\u2081\u271d a)\nW : \u03b1\u271d \u2192 Sort w\nZ : \u03b2\u271d \u2192 Sort z\nh\u2081 : \u03b1\u271d \u2243 \u03b2\u271d\nh\u2082 : (b : \u03b2\u271d) \u2192 W (h\u2081.symm b) \u2243 Z b\n\u03b1\u2081 : Type u_18\n\u03b2\u2081 : Type u_19\ne\u271d : \u03b1\u2081 \u2243 \u03b2\u2081\nf\u271d : \u03b1\u2081 \u2192 \u03b1\u2081 \u2192 \u03b1\u2081\n\u03b1' : Sort u_20\n\u03b1 : Sort u_1\n\u03b2 : Sort u_4\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nP : \u03b1 \u2192 Sort u_21\ne : \u03b1 \u2243 \u03b2\nf : (b : \u03b2) \u2192 P (e.symm b)\nb : \u03b2\nx : P (e.symm b)\n\u22a2 update f b x = (Equiv.piCongrLeft' P e) (update ((Equiv.piCongrLeft' P e).symm f) (e.symm b) x)"}]}
{"declaration": "theorem conj_comp (e : \u03b1 \u2243 \u03b2) (f\u2081 f\u2082 : \u03b1 \u2192 \u03b1) : e.conj (f\u2081 \u2218 f\u2082) = e.conj f\u2081 \u2218 e.conj f\u2082 := by\n  apply arrowCongr_comp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Defs.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}", "{\u03b1' \u03b2' : Type*} (e : \u03b1' \u2243 \u03b2')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\n\u03b2 : Sort v\ne : \u03b1 \u2243 \u03b2\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b1\n\u22a2 e.conj (f\u2081 \u2218 f\u2082) = e.conj f\u2081 \u2218 e.conj f\u2082"}, {"line": "apply arrowCongr_comp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Embedding.toEquivRange_symm_apply_self (a : \u03b1) :\n    f.toEquivRange.symm \u27e8f a, Set.mem_range_self a\u27e9 = a := by simp [Equiv.symm_apply_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\na : \u03b1\n\u22a2 f.toEquivRange.symm \u27e8f a, \u22ef\u27e9 = a"}, {"line": "simp [Equiv.symm_apply_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Embedding.toEquivRange_eq_ofInjective :\n    f.toEquivRange = Equiv.ofInjective f f.injective := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\n\u22a2 f.toEquivRange = Equiv.ofInjective \u21d1f \u22ef"}, {"line": "ext", "tactic_state": "case H.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u21aa \u03b2\nx\u271d : \u03b1\n\u22a2 \u2191(f.toEquivRange x\u271d) = \u2191((Equiv.ofInjective \u21d1f \u22ef) x\u271d)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.viaFintypeEmbedding_apply_image (a : \u03b1) :\n    e.viaFintypeEmbedding f (f a) = f (e a) := by\n  rw [Equiv.Perm.viaFintypeEmbedding]\n  convert Equiv.Perm.extendDomain_apply_image e (Function.Embedding.toEquivRange f) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\na : \u03b1\n\u22a2 (e.viaFintypeEmbedding f) (f a) = f (e a)"}, {"line": "rw [Equiv.Perm.viaFintypeEmbedding]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\na : \u03b1\n\u22a2 (e.extendDomain f.toEquivRange) (f a) = f (e a)"}, {"line": "convert Equiv.Perm.extendDomain_apply_image e (Function.Embedding.toEquivRange f) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.viaFintypeEmbedding_apply_mem_range {b : \u03b2} (h : b \u2208 Set.range f) :\n    e.viaFintypeEmbedding f b = f (e (f.invOfMemRange \u27e8b, h\u27e9)) := by\n  simp only [viaFintypeEmbedding]\n  simp only [Function.Embedding.invOfMemRange]\n  rw [Equiv.Perm.extendDomain_apply_subtype]\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 (e.viaFintypeEmbedding f) b = f (e (f.invOfMemRange \u27e8b, h\u27e9))"}, {"line": "simp only [viaFintypeEmbedding]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 (e.extendDomain f.toEquivRange) b = f (e (f.invOfMemRange \u27e8b, h\u27e9))"}, {"line": "simp only [Function.Embedding.invOfMemRange]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 (e.extendDomain f.toEquivRange) b = f (e (\u22ef.invOfMemRange \u27e8b, h\u27e9))"}, {"line": "rw [Equiv.Perm.extendDomain_apply_subtype]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 \u2191(f.toEquivRange (e (f.toEquivRange.symm \u27e8b, ?h\u27e9))) = f (e (\u22ef.invOfMemRange \u27e8b, h\u27e9))\n---\ncase h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2208 Set.range \u21d1f\n\u22a2 b \u2208 Set.range \u21d1f"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.viaFintypeEmbedding_apply_not_mem_range {b : \u03b2} (h : b \u2209 Set.range f) :\n    e.viaFintypeEmbedding f b = b := by\n  rwa [Equiv.Perm.viaFintypeEmbedding, Equiv.Perm.extendDomain_apply_not_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [Fintype \u03b1] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\nb : \u03b2\nh : b \u2209 Set.range \u21d1f\n\u22a2 (e.viaFintypeEmbedding f) b = b"}, {"line": "rwa [Equiv.Perm.viaFintypeEmbedding, Equiv.Perm.extendDomain_apply_not_subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem removeNone_aux_some {x : \u03b1} (h : \u2203 x', e (some x) = some x') :\n    some (removeNone_aux e x) = e (some x) := by\n  simp [removeNone_aux, Option.isSome_iff_exists.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Option.lean", "context": {"open": ["Option"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(e : Option \u03b1 \u2243 Option \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : Option \u03b1 \u2243 Option \u03b2\nx\u271d : Sort u_4\nremoveNone_aux : x\u271d\nx : \u03b1\nh : \u2203 x', e (some x) = some x'\n\u22a2 some sorry = e (some x)"}, {"line": "simp [removeNone_aux, Option.isSome_iff_exists.mpr h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : Option \u03b1 \u2243 Option \u03b2\nx\u271d : Sort u_4\nremoveNone_aux : x\u271d\nx : \u03b1\nh : \u2203 x', e (some x) = some x'\n\u22a2 some (sorry ()) = e (some x)"}]}
{"declaration": "theorem removeNone_aux_none {x : \u03b1} (h : e (some x) = none) :\n    some (removeNone_aux e x) = e none := by\n  simp [removeNone_aux, Option.not_isSome_iff_eq_none.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Option.lean", "context": {"open": ["Option"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "(e : Option \u03b1 \u2243 Option \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : Option \u03b1 \u2243 Option \u03b2\nx\u271d : Sort u_4\nremoveNone_aux : x\u271d\nx : \u03b1\nh : e (some x) = none\n\u22a2 some sorry = e none"}, {"line": "simp [removeNone_aux, Option.not_isSome_iff_eq_none.mpr h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : Option \u03b1 \u2243 Option \u03b2\nx\u271d : Sort u_4\nremoveNone_aux : x\u271d\nx : \u03b1\nh : e (some x) = none\n\u22a2 some (sorry ()) = e none"}]}
{"declaration": "theorem copy_eq (e : PartialEquiv \u03b1 \u03b2) (f : \u03b1 \u2192 \u03b2) (hf : \u21d1e = f) (g : \u03b2 \u2192 \u03b1) (hg : \u21d1e.symm = g)\n    (s : Set \u03b1) (hs : e.source = s) (t : Set \u03b2) (ht : e.target = t) :\n    e.copy f hf g hg s hs t ht = e := by\n  substs f g s t\n  cases e\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2191e = f\ng : \u03b2 \u2192 \u03b1\nhg : \u2191e.symm = g\ns : Set \u03b1\nhs : e.source = s\nt : Set \u03b2\nht : e.target = t\n\u22a2 e.copy f hf g hg s hs t ht = e"}, {"line": "substs f g s t", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\n\u22a2 e.copy \u2191e \u22ef \u2191e.symm \u22ef e.source \u22ef e.target \u22ef = e"}, {"line": "cases e", "tactic_state": "case mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ntoFun\u271d : \u03b1 \u2192 \u03b2\ninvFun\u271d : \u03b2 \u2192 \u03b1\nsource\u271d : Set \u03b1\ntarget\u271d : Set \u03b2\nmap_source'\u271d : \u2200 \u2983x : \u03b1\u2984, x \u2208 source\u271d \u2192 toFun\u271d x \u2208 target\u271d\nmap_target'\u271d : \u2200 \u2983x : \u03b2\u2984, x \u2208 target\u271d \u2192 invFun\u271d x \u2208 source\u271d\nleft_inv'\u271d : \u2200 \u2983x : \u03b1\u2984, x \u2208 source\u271d \u2192 invFun\u271d (toFun\u271d x) = x\nright_inv'\u271d : \u2200 \u2983x : \u03b2\u2984, x \u2208 target\u271d \u2192 toFun\u271d (invFun\u271d x) = x\n\u22a2 { toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n          map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }.copy\n      \u2191{ toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n          map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }\n      \u22ef\n      \u2191{ toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n            map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }.symm\n      \u22ef\n      { toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n          map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }.source\n      \u22ef\n      { toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n          map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }.target\n      \u22ef =\n    { toFun := toFun\u271d, invFun := invFun\u271d, source := source\u271d, target := target\u271d, map_source' := map_source'\u271d,\n      map_target' := map_target'\u271d, left_inv' := left_inv'\u271d, right_inv' := right_inv'\u271d }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftInvOn_piecewise {e' : PartialEquiv \u03b1 \u03b2} [\u2200 i, Decidable (i \u2208 s)]\n    [\u2200 i, Decidable (i \u2208 t)] (h : e.IsImage s t) (h' : e'.IsImage s t) :\n    LeftInvOn (t.piecewise e.symm e'.symm) (s.piecewise e e') (s.ite e.source e'.source) := by\n  rintro x (\u27e8he, hs\u27e9 | \u27e8he, hs : x \u2209 s\u27e9)\n  \u00b7 rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he]\n  \u00b7 rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs),\n      e'.left_inv he]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\ne' : PartialEquiv \u03b1 \u03b2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 Decidable (i \u2208 s)\ninst\u271d : (i : \u03b2) \u2192 Decidable (i \u2208 t)\nh : e.IsImage s t\nh' : e'.IsImage s t\n\u22a2 LeftInvOn (t.piecewise \u2191e.symm \u2191e'.symm) (s.piecewise \u2191e \u2191e') (s.ite e.source e'.source)"}, {"line": "rintro x (\u27e8he, hs\u27e9 | \u27e8he, hs : x \u2209 s\u27e9)", "tactic_state": "case inl.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\ne' : PartialEquiv \u03b1 \u03b2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 Decidable (i \u2208 s)\ninst\u271d : (i : \u03b2) \u2192 Decidable (i \u2208 t)\nh : e.IsImage s t\nh' : e'.IsImage s t\nx : \u03b1\nhe : x \u2208 e.source\nhs : x \u2208 s\n\u22a2 t.piecewise (\u2191e.symm) (\u2191e'.symm) (s.piecewise (\u2191e) (\u2191e') x) = x\n---\ncase inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\ne' : PartialEquiv \u03b1 \u03b2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 Decidable (i \u2208 s)\ninst\u271d : (i : \u03b2) \u2192 Decidable (i \u2208 t)\nh : e.IsImage s t\nh' : e'.IsImage s t\nx : \u03b1\nhe : x \u2208 e'.source\nhs : x \u2209 s\n\u22a2 t.piecewise (\u2191e.symm) (\u2191e'.symm) (s.piecewise (\u2191e) (\u2191e') x) = x"}, {"line": "\u00b7 rw [piecewise_eq_of_mem _ _ _ hs, piecewise_eq_of_mem _ _ _ ((h he).2 hs), e.left_inv he]", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\ne' : PartialEquiv \u03b1 \u03b2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 Decidable (i \u2208 s)\ninst\u271d : (i : \u03b2) \u2192 Decidable (i \u2208 t)\nh : e.IsImage s t\nh' : e'.IsImage s t\nx : \u03b1\nhe : x \u2208 e'.source\nhs : x \u2209 s\n\u22a2 t.piecewise (\u2191e.symm) (\u2191e'.symm) (s.piecewise (\u2191e) (\u2191e') x) = x"}, {"line": "\u00b7 rw [piecewise_eq_of_not_mem _ _ _ hs, piecewise_eq_of_not_mem _ _ _ ((h'.compl he).2 hs),\n      e'.left_inv he]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inter_eq_of_inter_eq_of_eqOn {e' : PartialEquiv \u03b1 \u03b2} (h : e.IsImage s t)\n    (h' : e'.IsImage s t) (hs : e.source \u2229 s = e'.source \u2229 s) (heq : EqOn e e' (e.source \u2229 s)) :\n    e.target \u2229 t = e'.target \u2229 t := by rw [\u2190 h.image_eq, \u2190 h'.image_eq, \u2190 hs, heq.image_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nt : Set \u03b2\ne' : PartialEquiv \u03b1 \u03b2\nh : e.IsImage s t\nh' : e'.IsImage s t\nhs : e.source \u2229 s = e'.source \u2229 s\nheq : EqOn (\u2191e) (\u2191e') (e.source \u2229 s)\n\u22a2 e.target \u2229 t = e'.target \u2229 t"}, {"line": "rw [\u2190 h.image_eq, \u2190 h'.image_eq, \u2190 hs, heq.image_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_eq_target_inter_inv_preimage {s : Set \u03b1} (h : s \u2286 e.source) :\n    e '' s = e.target \u2229 e.symm \u207b\u00b9' s := by\n  rw [\u2190 e.image_source_inter_eq']\n  rw [inter_eq_self_of_subset_right h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nh : s \u2286 e.source\n\u22a2 \u2191e '' s = e.target \u2229 \u2191e.symm \u207b\u00b9' s"}, {"line": "rw [\u2190 e.image_source_inter_eq']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : PartialEquiv \u03b1 \u03b2\ns : Set \u03b1\nh : s \u2286 e.source\n\u22a2 \u2191e '' s = \u2191e '' (e.source \u2229 s)"}, {"line": "rw [inter_eq_self_of_subset_right h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem refl_restr_source (s : Set \u03b1) : ((PartialEquiv.refl \u03b1).restr s).source = s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 ((PartialEquiv.refl \u03b1).restr s).source = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem refl_restr_target (s : Set \u03b1) : ((PartialEquiv.refl \u03b1).restr s).target = s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 ((PartialEquiv.refl \u03b1).restr s).target = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trans_source' : (e.trans e').source = e.source \u2229 e \u207b\u00b9' (e.target \u2229 e'.source) := by\n  mfld_set_tac\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b2 \u03b3\n\u22a2 (e.trans e').source = e.source \u2229 \u2191e \u207b\u00b9' (e.target \u2229 e'.source)"}, {"line": "mfld_set_tac", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trans_source'' : (e.trans e').source = e.symm '' (e.target \u2229 e'.source) := by\n  rw [e.trans_source']\n  rw [e.symm_image_target_inter_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b2 \u03b3\n\u22a2 (e.trans e').source = \u2191e.symm '' (e.target \u2229 e'.source)"}, {"line": "rw [e.trans_source']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b2 \u03b3\n\u22a2 e.source \u2229 \u2191e \u207b\u00b9' (e.target \u2229 e'.source) = \u2191e.symm '' (e.target \u2229 e'.source)"}, {"line": "rw [e.symm_image_target_inter_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_eqOnSource_univ (e e' : PartialEquiv \u03b1 \u03b2) (h : e \u2248 e') (s : e.source = univ)\n    (t : e.target = univ) : e = e' := by\n  refine PartialEquiv.ext (fun x => ?_) (fun x => ?_) h.1\n  \u00b7 apply h.2\n    rw [s]\n    exact mem_univ _\n  \u00b7 apply h.symm'.2\n    rw [symm_source]\n    rw [t]\n    exact mem_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne e' : PartialEquiv \u03b1 \u03b2\nh : e \u2248 e'\ns : e.source = univ\nt : e.target = univ\n\u22a2 e = e'"}, {"line": "refine PartialEquiv.ext (fun x => ?_) (fun x => ?_) h.1", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne e' : PartialEquiv \u03b1 \u03b2\nh : e \u2248 e'\ns : e.source = univ\nt : e.target = univ\nx : \u03b1\n\u22a2 \u2191e x = \u2191e' x\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne e' : PartialEquiv \u03b1 \u03b2\nh : e \u2248 e'\ns : e.source = univ\nt : e.target = univ\nx : \u03b2\n\u22a2 \u2191e.symm x = \u2191e'.symm x"}, {"line": "\u00b7 apply h.2\n    rw [s]\n    exact mem_univ _", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ne e' : PartialEquiv \u03b1 \u03b2\nh : e \u2248 e'\ns : e.source = univ\nt : e.target = univ\nx : \u03b2\n\u22a2 \u2191e.symm x = \u2191e'.symm x"}, {"line": "\u00b7 apply h.symm'.2\n    rw [symm_source]\n    rw [t]\n    exact mem_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_symm (e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b3 \u03b4) :\n    (e.prod e').symm = e.symm.prod e'.symm := by\n  ext x <;> simp [prod_coe_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ne : PartialEquiv \u03b1 \u03b2\ne' : PartialEquiv \u03b3 \u03b4\n\u22a2 (e.prod e').symm = e.symm.prod e'.symm"}, {"line": "ext x <;> simp [prod_coe_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem refl_prod_refl :\n    (PartialEquiv.refl \u03b1).prod (PartialEquiv.refl \u03b2) = PartialEquiv.refl (\u03b1 \u00d7 \u03b2) := by\n  ext \u27e8x, y\u27e9 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 (PartialEquiv.refl \u03b1).prod (PartialEquiv.refl \u03b2) = PartialEquiv.refl (\u03b1 \u00d7 \u03b2)"}, {"line": "ext \u27e8x, y\u27e9 <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_refl : (PartialEquiv.pi fun i \u21a6 PartialEquiv.refl (\u03b1i i)) = .refl (\u2200 i, \u03b1i i) := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/PartialEquiv.lean", "context": {"open": ["Lean Meta Elab Tactic", "Function Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "(e : PartialEquiv \u03b1 \u03b2) (e' : PartialEquiv \u03b2 \u03b3)", "{e} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}", "{\u03b9 : Type*} {\u03b1i \u03b2i \u03b3i : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03b1i : \u03b9 \u2192 Type u_6\n\u22a2 (PartialEquiv.pi fun i => PartialEquiv.refl (\u03b1i i)) = PartialEquiv.refl ((i : \u03b9) \u2192 \u03b1i i)"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_prodExtendRight_ne {e : Perm \u03b2\u2081} {a a' : \u03b1\u2081} {b : \u03b2\u2081}\n    (h : prodExtendRight a e (a', b) \u2260 (a', b)) : a' = a := by\n  contrapose! h\n  exact prodExtendRight_apply_ne _ h _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}", "{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} (e : \u03b1\u2081 \u2192 \u03b2\u2081 \u2243 \u03b2\u2082)", "{\u03b1\u2081 \u03b2\u2081 : Type*} [DecidableEq \u03b1\u2081] (a : \u03b1\u2081) (e : Perm \u03b2\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Perm : ?m.616\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d\u00b2 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d\u00b2 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b1\u2081\u271d\u00b9 : Type u_9\n\u03b1\u2082 : Type u_10\n\u03b2\u2081\u271d\u00b9 : Type u_11\n\u03b2\u2082 : Type u_12\ne\u271d\u00b9 : \u03b1\u2081\u271d\u00b9 \u2192 \u03b2\u2081\u271d\u00b9 \u2243 \u03b2\u2082\n\u03b1\u2081\u271d : Type u_13\n\u03b2\u2081\u271d : Type u_14\ninst\u271d\u00b9 : DecidableEq \u03b1\u2081\u271d\na\u271d : \u03b1\u2081\u271d\ne\u271d : sorry\n\u03b1\u2081 : Type u_13\n\u03b2\u2081 : Type u_14\ninst\u271d : DecidableEq \u03b1\u2081\nx\u271d : Sort u_15\nprodExtendRight : x\u271d\ne : sorry\na a' : \u03b1\u2081\nb : \u03b2\u2081\nh : sorry \u2260 (a', b)\n\u22a2 a' = a"}, {"line": "contrapose! h", "tactic_state": "Perm : ?m.616\n\u03b1 : Sort u_1\n\u03b1\u2081\u271d\u00b2 : Sort u_2\n\u03b1\u2082\u271d : Sort u_3\n\u03b2 : Sort u_4\n\u03b2\u2081\u271d\u00b2 : Sort u_5\n\u03b2\u2082\u271d : Sort u_6\n\u03b3 : Sort u_7\n\u03b4 : Sort u_8\n\u03b1\u2081\u271d\u00b9 : Type u_9\n\u03b1\u2082 : Type u_10\n\u03b2\u2081\u271d\u00b9 : Type u_11\n\u03b2\u2082 : Type u_12\ne\u271d\u00b9 : \u03b1\u2081\u271d\u00b9 \u2192 \u03b2\u2081\u271d\u00b9 \u2243 \u03b2\u2082\n\u03b1\u2081\u271d : Type u_13\n\u03b2\u2081\u271d : Type u_14\ninst\u271d\u00b9 : DecidableEq \u03b1\u2081\u271d\na\u271d : \u03b1\u2081\u271d\ne\u271d : sorry\n\u03b1\u2081 : Type u_13\n\u03b2\u2081 : Type u_14\ninst\u271d : DecidableEq \u03b1\u2081\nx\u271d : Sort u_15\nprodExtendRight : x\u271d\ne : sorry\na a' : \u03b1\u2081\nb : \u03b2\u2081\nh : a' \u2260 a\n\u22a2 sorry = (a', b)"}, {"line": "exact prodExtendRight_apply_ne _ h _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma setOf_apply_symm_eq_image_setOf {\u03b1 \u03b2} (e : \u03b1 \u2243 \u03b2) (p : \u03b1 \u2192 Prop) :\n    {b | p (e.symm b)} = e '' {a | p a} := by\n  rw [Equiv.image_eq_preimage]\n  rw [preimage_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : \u03b1 \u2243 \u03b2\np : \u03b1 \u2192 Prop\n\u22a2 {b | p (e.symm b)} = \u21d1e '' {a | p a}"}, {"line": "rw [Equiv.image_eq_preimage]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ne : \u03b1 \u2243 \u03b2\np : \u03b1 \u2192 Prop\n\u22a2 {b | p (e.symm b)} = \u21d1e.symm \u207b\u00b9' {a | p a}"}, {"line": "rw [preimage_setOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc_preimage {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    Equiv.prodAssoc \u03b1 \u03b2 \u03b3 \u207b\u00b9' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u := by\n  ext\n  simp [and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3) \u207b\u00b9' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\nx\u271d : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3\n\u22a2 x\u271d \u2208 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3) \u207b\u00b9' s \u00d7\u02e2 t \u00d7\u02e2 u \u2194 x\u271d \u2208 (s \u00d7\u02e2 t) \u00d7\u02e2 u"}, {"line": "simp [and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc_symm_preimage {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm \u207b\u00b9' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u := by\n  ext\n  simp [and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm \u207b\u00b9' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\nx\u271d : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\n\u22a2 x\u271d \u2208 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm \u207b\u00b9' (s \u00d7\u02e2 t) \u00d7\u02e2 u \u2194 x\u271d \u2208 s \u00d7\u02e2 t \u00d7\u02e2 u"}, {"line": "simp [and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc_image {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    Equiv.prodAssoc \u03b1 \u03b2 \u03b3 '' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_symm_preimage\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3) '' (s \u00d7\u02e2 t) \u00d7\u02e2 u = s \u00d7\u02e2 t \u00d7\u02e2 u"}, {"line": "simpa only [Equiv.image_eq_preimage] using prod_assoc_symm_preimage", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_assoc_symm_image {\u03b1 \u03b2 \u03b3} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3} :\n    (Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm '' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_preimage\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nu : Set \u03b3\n\u22a2 \u21d1(Equiv.prodAssoc \u03b1 \u03b2 \u03b3).symm '' s \u00d7\u02e2 t \u00d7\u02e2 u = (s \u00d7\u02e2 t) \u00d7\u02e2 u"}, {"line": "simpa only [Equiv.image_eq_preimage] using prod_assoc_preimage", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sumCompl_symm_apply_of_mem {\u03b1 : Type u} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {x : \u03b1}\n    (hx : x \u2208 s) : (Equiv.Set.sumCompl s).symm x = Sum.inl \u27e8x, hx\u27e9 := by\n  simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_left, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (Equiv.Set.sumCompl s).symm x = Sum.inl \u27e8x, hx\u27e9"}, {"line": "simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_left, hx]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (Equiv.Set.union \u22ef) \u27e8x, \u22ef\u27e9 = Sum.inl \u27e8x, hx\u27e9"}]}
{"declaration": "theorem sumCompl_symm_apply_of_not_mem {\u03b1 : Type u} {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] {x : \u03b1}\n    (hx : x \u2209 s) : (Equiv.Set.sumCompl s).symm x = Sum.inr \u27e8x, hx\u27e9 := by\n  simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_right, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nx : \u03b1\nhx : x \u2209 s\n\u22a2 (Equiv.Set.sumCompl s).symm x = Sum.inr \u27e8x, hx\u27e9"}, {"line": "simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_right, hx]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nx : \u03b1\nhx : x \u2209 s\n\u22a2 (Equiv.Set.union \u22ef) \u27e8x, \u22ef\u27e9 = Sum.inr \u27e8x, hx\u27e9"}]}
{"declaration": "theorem image_symm_preimage {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (u s : Set \u03b1) :\n    (fun x => (Set.image f s hf).symm x : f '' s \u2192 \u03b1) \u207b\u00b9' u = Subtype.val \u207b\u00b9' (f '' u) := by\n  ext \u27e8b, a, has, rfl\u27e9\n  simp [hf.eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nu s : Set \u03b1\n\u22a2 (fun x => sorry) \u207b\u00b9' u = Subtype.val \u207b\u00b9' (f '' u)"}, {"line": "ext \u27e8b, a, has, rfl\u27e9", "tactic_state": "case h.mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nu s : Set \u03b1\na : \u03b1\nhas : a \u2208 s\n\u22a2 \u27e8f a, \u22ef\u27e9 \u2208 (fun x => sorry) \u207b\u00b9' u \u2194 \u27e8f a, \u22ef\u27e9 \u2208 Subtype.val \u207b\u00b9' (f '' u)"}, {"line": "simp [hf.eq_iff]", "tactic_state": "case h.mk.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nu s : Set \u03b1\na : \u03b1\nhas : a \u2208 s\n\u22a2 sorry () \u2208 u \u2194 a \u2208 u"}]}
{"declaration": "theorem coe_ofInjective_symm {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    ((ofInjective f hf).symm : range f \u2192 \u03b1) = rangeSplitting f := by\n  ext \u27e8y, x, rfl\u27e9\n  apply hf\n  simp [apply_rangeSplitting f]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofInjective : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 sorry = rangeSplitting f"}, {"line": "ext \u27e8y, x, rfl\u27e9", "tactic_state": "case h.mk.intro\nx\u271d : Sort u_1\nofInjective : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx : \u03b1\n\u22a2 sorry \u27e8f x, \u22ef\u27e9 = rangeSplitting f \u27e8f x, \u22ef\u27e9"}, {"line": "apply hf", "tactic_state": "case h.mk.intro.a\nx\u271d : Sort u_1\nofInjective : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx : \u03b1\n\u22a2 f (sorry \u27e8f x, \u22ef\u27e9) = f (rangeSplitting f \u27e8f x, \u22ef\u27e9)"}, {"line": "simp [apply_rangeSplitting f]", "tactic_state": "case h.mk.intro.a\nx\u271d : Sort u_1\nofInjective : x\u271d\n\u03b1 : Type u_2\n\u03b2 : Type u_3\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx : \u03b1\n\u22a2 f (sorry () \u27e8f x, \u22ef\u27e9) = f x"}]}
{"declaration": "theorem Equiv.swap_bijOn_exchange (ha : a \u2208 s) (hb : b \u2209 s) :\n    BijOn (Equiv.swap a b) s (insert b (s \\ {a})) := by\n  refine \u27e8fun x hx \u21a6 ?_, (Equiv.injective _).injOn, fun x hx \u21a6 ?_\u27e9\n  \u00b7 obtain (rfl | hxa) := eq_or_ne x a\n    \u00b7 simp [swap_apply_left]\n    rw [swap_apply_of_ne_of_ne hxa (by rintro rfl; contradiction)]\n    exact .inr \u27e8hx, hxa\u27e9\n  obtain (rfl | hxb) := eq_or_ne x b\n  \u00b7 exact \u27e8a, ha, by simp\u27e9\n  simp only [mem_insert_iff] at hx\n  simp only [mem_diff] at hx\n  simp only [mem_singleton_iff] at hx\n  simp only [or_iff_right hxb] at hx\n  exact \u27e8x, hx.1, swap_apply_of_ne_of_ne hx.2 hxb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Set.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w}", "{\u03b1 : Type*} [DecidableEq \u03b1] {a b : \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\n\u22a2 BijOn (\u21d1(swap a b)) s (insert b (s \\ {a}))"}, {"line": "refine \u27e8fun x hx \u21a6 ?_, (Equiv.injective _).injOn, fun x hx \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (swap a b) x \u2208 insert b (s \\ {a})\n---\ncase refine_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhx : x \u2208 insert b (s \\ {a})\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "\u00b7 obtain (rfl | hxa) := eq_or_ne x a\n    \u00b7 simp [swap_apply_left]\n    rw [swap_apply_of_ne_of_ne hxa (by rintro rfl; contradiction)]\n    exact .inr \u27e8hx, hxa\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhx : x \u2208 insert b (s \\ {a})\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "obtain (rfl | hxb) := eq_or_ne x b", "tactic_state": "case refine_2.inl\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nx : \u03b1\nhb : x \u2209 s\nhx : x \u2208 insert x (s \\ {a})\n\u22a2 x \u2208 \u21d1(swap a x) '' s\n---\ncase refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhx : x \u2208 insert b (s \\ {a})\nhxb : x \u2260 b\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "\u00b7 exact \u27e8a, ha, by simp\u27e9", "tactic_state": "case refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhx : x \u2208 insert b (s \\ {a})\nhxb : x \u2260 b\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "simp only [mem_insert_iff] at hx", "tactic_state": "case refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhxb : x \u2260 b\nhx : x = b \u2228 x \u2208 s \\ {a}\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "simp only [mem_diff] at hx", "tactic_state": "case refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhxb : x \u2260 b\nhx : x = b \u2228 x \u2208 s \u2227 x \u2209 {a}\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "simp only [mem_singleton_iff] at hx", "tactic_state": "case refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhxb : x \u2260 b\nhx : x = b \u2228 x \u2208 s \u2227 \u00acx = a\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "simp only [or_iff_right hxb] at hx", "tactic_state": "case refine_2.inr\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\ns : Set \u03b1\nha : a \u2208 s\nhb : b \u2209 s\nx : \u03b1\nhxb : x \u2260 b\nhx : x \u2208 s \u2227 \u00acx = a\n\u22a2 x \u2208 \u21d1(swap a b) '' s"}, {"line": "exact \u27e8x, hx.1, swap_apply_of_ne_of_ne hx.2 hxb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sumCongr_trans {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 \u03b3\u2081 \u03b3\u2082} (e : \u03b1\u2081 \u2243 \u03b2\u2081) (f : \u03b1\u2082 \u2243 \u03b2\u2082) (g : \u03b2\u2081 \u2243 \u03b3\u2081) (h : \u03b2\u2082 \u2243 \u03b3\u2082) :\n    (Equiv.sumCongr e f).trans (Equiv.sumCongr g h) = Equiv.sumCongr (e.trans g) (f.trans h) := by\n  ext i\n  cases i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Sum.lean", "context": {"open": ["Function", "Sum"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Type u_9\n\u03b1\u2082 : Type u_10\n\u03b2\u2081 : Type u_11\n\u03b2\u2082 : Type u_12\n\u03b3\u2081 : Type u_13\n\u03b3\u2082 : Type u_14\ne : \u03b1\u2081 \u2243 \u03b2\u2081\nf : \u03b1\u2082 \u2243 \u03b2\u2082\ng : \u03b2\u2081 \u2243 \u03b3\u2081\nh : \u03b2\u2082 \u2243 \u03b3\u2082\n\u22a2 (e.sumCongr f).trans (g.sumCongr h) = (e.trans g).sumCongr (f.trans h)"}, {"line": "ext i", "tactic_state": "case H\n\u03b1\u2081 : Type u_9\n\u03b1\u2082 : Type u_10\n\u03b2\u2081 : Type u_11\n\u03b2\u2082 : Type u_12\n\u03b3\u2081 : Type u_13\n\u03b3\u2082 : Type u_14\ne : \u03b1\u2081 \u2243 \u03b2\u2081\nf : \u03b1\u2082 \u2243 \u03b2\u2082\ng : \u03b2\u2081 \u2243 \u03b3\u2081\nh : \u03b2\u2082 \u2243 \u03b3\u2082\ni : \u03b1\u2081 \u2295 \u03b1\u2082\n\u22a2 ((e.sumCongr f).trans (g.sumCongr h)) i = ((e.trans g).sumCongr (f.trans h)) i"}, {"line": "cases i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sumCongr_refl {\u03b1 \u03b2} :\n    Equiv.sumCongr (Equiv.refl \u03b1) (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u2295 \u03b2) := by\n  ext i\n  cases i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Sum.lean", "context": {"open": ["Function", "Sum"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 \u03b2 \u03b2\u2081 \u03b2\u2082 \u03b3 \u03b4 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\n\u22a2 (Equiv.refl \u03b1).sumCongr (Equiv.refl \u03b2) = Equiv.refl (\u03b1 \u2295 \u03b2)"}, {"line": "ext i", "tactic_state": "case H\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ni : \u03b1 \u2295 \u03b2\n\u22a2 ((Equiv.refl \u03b1).sumCongr (Equiv.refl \u03b2)) i = (Equiv.refl (\u03b1 \u2295 \u03b2)) i"}, {"line": "cases i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finRotate_of_lt {k : \u2115} (h : k < n) :\n    finRotate (n + 1) \u27e8k, h.trans_le n.le_succ\u27e9 = \u27e8k + 1, Nat.succ_lt_succ h\u27e9 := by\n  ext\n  dsimp [finRotate_succ]\n  simp [finAddFlip_apply_mk_left h, Nat.add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nh : k < n\n\u22a2 (finRotate (n + 1)) \u27e8k, \u22ef\u27e9 = \u27e8k + 1, \u22ef\u27e9"}, {"line": "ext", "tactic_state": "case h\nn k : \u2115\nh : k < n\n\u22a2 \u2191((finRotate (n + 1)) \u27e8k, \u22ef\u27e9) = \u2191\u27e8k + 1, \u22ef\u27e9"}, {"line": "dsimp [finRotate_succ]", "tactic_state": "case h\nn k : \u2115\nh : k < n\n\u22a2 \u2191(finAddFlip \u27e8k, \u22ef\u27e9) = k + 1"}, {"line": "simp [finAddFlip_apply_mk_left h, Nat.add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finRotate_apply_zero : finRotate n.succ 0 = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (finRotate n.succ) 0 = 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_finRotate_of_ne_last {i : Fin n.succ} (h : i \u2260 Fin.last n) :\n    (finRotate (n + 1) i : \u2115) = i + 1 := by\n  rw [finRotate_succ_apply]\n  have : (i : \u2115) < n := Fin.val_lt_last h\n  exact Fin.val_add_one_of_lt this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\n\u22a2 \u2191((finRotate (n + 1)) i) = \u2191i + 1"}, {"line": "rw [finRotate_succ_apply]", "tactic_state": "n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\n\u22a2 \u2191(i + 1) = \u2191i + 1"}, {"line": "have : (i : \u2115) < n := Fin.val_lt_last h", "tactic_state": "n : \u2115\ni : Fin n.succ\nh : i \u2260 Fin.last n\nthis : \u2191i < n\n\u22a2 \u2191(i + 1) = \u2191i + 1"}, {"line": "exact Fin.val_add_one_of_lt this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_finRotate (i : Fin n.succ) :\n    (finRotate n.succ i : \u2115) = if i = Fin.last n then (0 : \u2115) else i + 1 := by\n  rw [finRotate_succ_apply]\n  rw [Fin.val_add_one i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n.succ\n\u22a2 \u2191((finRotate n.succ) i) = if i = Fin.last n then 0 else \u2191i + 1"}, {"line": "rw [finRotate_succ_apply]", "tactic_state": "n : \u2115\ni : Fin n.succ\n\u22a2 \u2191(i + 1) = if i = Fin.last n then 0 else \u2191i + 1"}, {"line": "rw [Fin.val_add_one i]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_finRotate_iff_ne_last (i : Fin (n + 1)) :\n    i < finRotate _ i \u2194 i \u2260 Fin.last n := by\n  refine \u27e8fun hi hc \u21a6 ?_, fun hi \u21a6 ?_\u27e9\n  \u00b7 simp only [hc, finRotate_succ_apply, Fin.last_add_one, Fin.not_lt_zero] at hi\n  \u00b7 rw [Fin.lt_iff_val_lt_val, coe_finRotate_of_ne_last hi, Nat.lt_add_one_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 i < (finRotate (n + 1)) i \u2194 i \u2260 Fin.last n"}, {"line": "refine \u27e8fun hi hc \u21a6 ?_, fun hi \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nn : \u2115\ni : Fin (n + 1)\nhi : i < (finRotate (n + 1)) i\nhc : i = Fin.last n\n\u22a2 False\n---\ncase refine_2\nn : \u2115\ni : Fin (n + 1)\nhi : i \u2260 Fin.last n\n\u22a2 i < (finRotate (n + 1)) i"}, {"line": "\u00b7 simp only [hc, finRotate_succ_apply, Fin.last_add_one, Fin.not_lt_zero] at hi", "tactic_state": "case refine_2\nn : \u2115\ni : Fin (n + 1)\nhi : i \u2260 Fin.last n\n\u22a2 i < (finRotate (n + 1)) i"}, {"line": "\u00b7 rw [Fin.lt_iff_val_lt_val, coe_finRotate_of_ne_last hi, Nat.lt_add_one_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_finRotate_iff_ne_neg_one [NeZero n] (i : Fin n) :\n    i < finRotate _ i \u2194 i \u2260 -1 := by\n  obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero (NeZero.ne n)\n  rw [lt_finRotate_iff_ne_last]\n  rw [ne_eq]\n  rw [not_iff_not]\n  rw [\u2190Fin.neg_last]\n  rw [neg_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\n\u22a2 i < (finRotate n) i \u2194 i \u2260 -1"}, {"line": "obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero (NeZero.ne n)", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\n\u22a2 i < (finRotate n.succ) i \u2194 i \u2260 -1"}, {"line": "rw [lt_finRotate_iff_ne_last]", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\n\u22a2 i \u2260 Fin.last n \u2194 i \u2260 -1"}, {"line": "rw [ne_eq]", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\n\u22a2 \u00aci = Fin.last n \u2194 i \u2260 -1"}, {"line": "rw [not_iff_not]", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\n\u22a2 i = Fin.last n \u2194 i = -1"}, {"line": "rw [\u2190Fin.neg_last]", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\n\u22a2 i = Fin.last n \u2194 i = - -Fin.last n"}, {"line": "rw [neg_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_finRotate_symm_of_ne_zero [NeZero n] {i : Fin n} (hi : i \u2260 0) :\n    ((finRotate _).symm i : \u2115) = i - 1 := by\n  obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero (NeZero.ne n)\n  rwa [finRotate_succ_symm_apply, Fin.val_sub_one_of_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Rotate.lean", "context": {"open": ["Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\ni : Fin n\nhi : i \u2260 0\n\u22a2 \u2191((Equiv.symm (finRotate n)) i) = \u2191i - 1"}, {"line": "obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero (NeZero.ne n)", "tactic_state": "case intro\nn : \u2115\ninst\u271d : NeZero n.succ\ni : Fin n.succ\nhi : i \u2260 0\n\u22a2 \u2191((Equiv.symm (finRotate n.succ)) i) = \u2191i - 1"}, {"line": "rwa [finRotate_succ_symm_apply, Fin.val_sub_one_of_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n    (fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) := by\n  ext f\n  simp [Fin.forall_fin_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Fin 2 \u2192 Type u\ns : Set (\u03b1 0)\nt : Set (\u03b1 1)\n\u22a2 (fun f => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t = Set.univ.pi (cons s (cons t finZeroElim))"}, {"line": "ext f", "tactic_state": "case h\n\u03b1 : Fin 2 \u2192 Type u\ns : Set (\u03b1 0)\nt : Set (\u03b1 1)\nf : (i : Fin 2) \u2192 \u03b1 i\n\u22a2 f \u2208 (fun f => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t \u2194 f \u2208 Set.univ.pi (cons s (cons t finZeroElim))"}, {"line": "simp [Fin.forall_fin_two]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none := by\n  simp [finSuccEquiv']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\n\u22a2 (finSuccEquiv' i) i = none"}, {"line": "simp [finSuccEquiv']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m := by\n  rw [\u2190 Fin.succAbove_of_castSucc_lt _ _ h]\n  rw [finSuccEquiv'_succAbove]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : m.castSucc < i\n\u22a2 (finSuccEquiv' i) m.castSucc = some m"}, {"line": "rw [\u2190 Fin.succAbove_of_castSucc_lt _ _ h]", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : m.castSucc < i\n\u22a2 (finSuccEquiv' i) (i.succAbove m) = some m"}, {"line": "rw [finSuccEquiv'_succAbove]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i \u2264 Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m := by\n  rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h]\n  rw [finSuccEquiv'_succAbove]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : i \u2264 m.castSucc\n\u22a2 (finSuccEquiv' i) m.succ = some m"}, {"line": "rw [\u2190 Fin.succAbove_of_le_castSucc _ _ h]", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nm : Fin n\nh : i \u2264 m.castSucc\n\u22a2 (finSuccEquiv' i) (i.succAbove m) = some m"}, {"line": "rw [finSuccEquiv'_succAbove]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i := by\n  rw [\u2190 Fin.succAbove_last]\n  rw [finSuccEquiv'_succAbove]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 (finSuccEquiv' (Fin.last n)) i.castSucc = some i"}, {"line": "rw [\u2190 Fin.succAbove_last]", "tactic_state": "n : \u2115\ni : Fin n\n\u22a2 (finSuccEquiv' (Fin.last n)) ((Fin.last n).succAbove i) = some i"}, {"line": "rw [finSuccEquiv'_succAbove]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i \u2260 Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h) := by\n  rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9\n  rw [finSuccEquiv'_last_apply_castSucc]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nh : i \u2260 Fin.last n\n\u22a2 (finSuccEquiv' (Fin.last n)) i = some (i.castLT \u22ef)"}, {"line": "rcases Fin.exists_castSucc_eq.2 h with \u27e8i, rfl\u27e9", "tactic_state": "case intro\nn : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 (finSuccEquiv' (Fin.last n)) i.castSucc = some (i.castSucc.castLT \u22ef)"}, {"line": "rw [finSuccEquiv'_last_apply_castSucc]", "tactic_state": "case intro\nn : \u2115\ni : Fin n\nh : i.castSucc \u2260 Fin.last n\n\u22a2 some i = some (i.castSucc.castLT \u22ef)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i \u2260 Fin.last n) (hj : j \u2260 i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j := by\n  rcases Fin.exists_succAbove_eq hj with \u27e8j, rfl\u27e9\n  rcases Fin.exists_castSucc_eq.2 hi with \u27e8i, rfl\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni j : Fin (n + 1)\nhi : i \u2260 Fin.last n\nhj : j \u2260 i\n\u22a2 (finSuccEquiv' i) j = some ((i.castLT \u22ef).predAbove j)"}, {"line": "rcases Fin.exists_succAbove_eq hj with \u27e8j, rfl\u27e9", "tactic_state": "case intro\nn : \u2115\ni : Fin (n + 1)\nhi : i \u2260 Fin.last n\nj : Fin n\nhj : i.succAbove j \u2260 i\n\u22a2 (finSuccEquiv' i) (i.succAbove j) = some ((i.castLT \u22ef).predAbove (i.succAbove j))"}, {"line": "rcases Fin.exists_castSucc_eq.2 hi with \u27e8i, rfl\u27e9", "tactic_state": "case intro.intro\nn : \u2115\nj i : Fin n\nhi : i.castSucc \u2260 Fin.last n\nhj : i.castSucc.succAbove j \u2260 i.castSucc\n\u22a2 (finSuccEquiv' i.castSucc) (i.castSucc.succAbove j) = some ((i.castSucc.castLT \u22ef).predAbove (i.castSucc.succAbove j))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x \u2260 Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [\u2190 Option.some_inj]\n  simp [finSuccAboveEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : { x // x \u2260 Fin.last n }\n\u22a2 (finSuccAboveEquiv (Fin.last n)).symm x = (\u2191x).castLT \u22ef"}, {"line": "rw [\u2190 Option.some_inj]", "tactic_state": "n : \u2115\nx : { x // x \u2260 Fin.last n }\n\u22a2 some ((finSuccAboveEquiv (Fin.last n)).symm x) = some ((\u2191x).castLT \u22ef)"}, {"line": "simp [finSuccAboveEquiv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p \u2260 Fin.last n)\n    (x : { x : Fin (n + 1) // x \u2260 p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [\u2190 Option.some_inj]\n  simpa [finSuccAboveEquiv] using finSuccEquiv'_ne_last_apply h x.property\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\nh : p \u2260 Fin.last n\nx : { x // x \u2260 p }\n\u22a2 (finSuccAboveEquiv p).symm x = (p.castLT \u22ef).predAbove \u2191x"}, {"line": "rw [\u2190 Option.some_inj]", "tactic_state": "n : \u2115\np : Fin (n + 1)\nh : p \u2260 Fin.last n\nx : { x // x \u2260 p }\n\u22a2 some ((finSuccAboveEquiv p).symm x) = some ((p.castLT \u22ef).predAbove \u2191x)"}, {"line": "simpa [finSuccAboveEquiv] using finSuccEquiv'_ne_last_apply h x.property", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none := by\n  simp [finSuccEquivLast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 finSuccEquivLast (Fin.last n) = none"}, {"line": "simp [finSuccEquivLast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finAddFlip_apply_castAdd (k : Fin m) (n : \u2115) :\n    finAddFlip (Fin.castAdd n k) = Fin.natAdd n k := by simp [finAddFlip]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nk : Fin m\nn : \u2115\n\u22a2 finAddFlip (Fin.castAdd n k) = Fin.natAdd n k"}, {"line": "simp [finAddFlip]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finAddFlip_apply_natAdd (k : Fin n) (m : \u2115) :\n    finAddFlip (Fin.natAdd m k) = Fin.castAdd m k := by simp [finAddFlip]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nk : Fin n\nm : \u2115\n\u22a2 finAddFlip (Fin.natAdd m k) = Fin.castAdd m k"}, {"line": "simp [finAddFlip]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finAddFlip_apply_mk_left {k : \u2115} (h : k < m) (hk : k < m + n := Nat.lt_add_right n h)\n    (hnk : n + k < n + m := Nat.add_lt_add_left h n) :\n    finAddFlip (\u27e8k, hk\u27e9 : Fin (m + n)) = \u27e8n + k, hnk\u27e9 := by\n  convert finAddFlip_apply_castAdd \u27e8k, h\u27e9 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\nh : k < m\nhk : optParam (k < m + n) \u22ef\nhnk : optParam (n + k < n + m) \u22ef\n\u22a2 finAddFlip \u27e8k, hk\u27e9 = \u27e8n + k, hnk\u27e9"}, {"line": "convert finAddFlip_apply_castAdd \u27e8k, h\u27e9 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finAddFlip_apply_mk_right {k : \u2115} (h\u2081 : m \u2264 k) (h\u2082 : k < m + n) :\n    finAddFlip (\u27e8k, h\u2082\u27e9 : Fin (m + n)) = \u27e8k - m, by omega\u27e9 := by\n  convert @finAddFlip_apply_natAdd n \u27e8k - m, by omega\u27e9 m\n  simp [Nat.add_sub_cancel' h\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Equiv/Fin/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\nh\u2081 : m \u2264 k\nh\u2082 : k < m + n\n\u22a2 finAddFlip \u27e8k, h\u2082\u27e9 = \u27e8k - m, \u22ef\u27e9"}, {"line": "convert @finAddFlip_apply_natAdd n \u27e8k - m, by omega\u27e9 m", "tactic_state": "case h.e'_2.h.e'_6.h.e'_2\nm n k : \u2115\nh\u2081 : m \u2264 k\nh\u2082 : k < m + n\n\u22a2 k = \u2191(Fin.natAdd m \u27e8k - m, \u22ef\u27e9)"}, {"line": "simp [Nat.add_sub_cancel' h\u2081]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N P : Type*}\n    {\u03c6 : M \u2192 N} {\u03c8 : N \u2192 P} {\u03c7 : M \u2192 P} (h : CompTriple \u03c6 \u03c8 \u03c7) (x : M) :\n    \u03c8 (\u03c6 x) = \u03c7 x := by\n  rw [\u2190 h.comp_eq]\n  rw [Function.comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/CompTypeclasses.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nN : Type u_2\nP : Type u_3\n\u03c6 : M \u2192 N\n\u03c8 : N \u2192 P\n\u03c7 : M \u2192 P\nh : CompTriple \u03c6 \u03c8 \u03c7\nx : M\n\u22a2 \u03c8 (\u03c6 x) = \u03c7 x"}, {"line": "rw [\u2190 h.comp_eq]", "tactic_state": "M : Type u_1\nN : Type u_2\nP : Type u_3\n\u03c6 : M \u2192 N\n\u03c8 : N \u2192 P\n\u03c7 : M \u2192 P\nh : CompTriple \u03c6 \u03c8 \u03c7\nx : M\n\u22a2 \u03c8 (\u03c6 x) = (\u03c8 \u2218 \u03c6) x"}, {"line": "rw [Function.comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dependsOn_const (b : \u03b2) : DependsOn (fun _ : \u03a0 i, \u03b1 i \u21a6 b) \u2205 := by simp [DependsOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/DependsOn.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {\u03b2 : Type*}", "{f : (\u03a0 i, \u03b1 i) \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_2\n\u03b2 : Type u_3\nb : \u03b2\n\u22a2 DependsOn (fun x => b) \u2205"}, {"line": "simp [DependsOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iterate_cancel (hf : Injective f) (ha : f^[m] a = f^[n] a) : f^[m - n] a = a := by\n  obtain h | h := Nat.le_total m n\n  { simp [Nat.sub_eq_zero_of_le h] }\n  { exact iterate_cancel_of_add hf (by rwa [Nat.sub_add_cancel h]) }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Iterate.lean", "context": {"open": ["Function (Commute)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "(f : \u03b1 \u2192 \u03b1)", "{f}", "{g : \u03b1 \u2192 \u03b1}", "(f)", "(f)", "{f} {m n : \u2115} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\nm n : \u2115\na : \u03b1\nx\u271d : Sort u_1\nInjective : x\u271d\nhf : sorry\nha : f^[m] a = f^[n] a\n\u22a2 f^[m - n] a = a"}, {"line": "obtain h | h := Nat.le_total m n", "tactic_state": "case inl\n\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\nm n : \u2115\na : \u03b1\nx\u271d : Sort u_1\nInjective : x\u271d\nhf : sorry\nha : f^[m] a = f^[n] a\nh : m \u2264 n\n\u22a2 f^[m - n] a = a\n---\ncase inr\n\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\nm n : \u2115\na : \u03b1\nx\u271d : Sort u_1\nInjective : x\u271d\nhf : sorry\nha : f^[m] a = f^[n] a\nh : n \u2264 m\n\u22a2 f^[m - n] a = a"}, {"line": "{ simp [Nat.sub_eq_zero_of_le h] }", "tactic_state": "case inr\n\u03b1 : Type u\nf : \u03b1 \u2192 \u03b1\nm n : \u2115\na : \u03b1\nx\u271d : Sort u_1\nInjective : x\u271d\nhf : sorry\nha : f^[m] a = f^[n] a\nh : n \u2264 m\n\u22a2 f^[m - n] a = a"}, {"line": "{ exact iterate_cancel_of_add hf (by rwa [Nat.sub_add_cancel h]) }", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hfunext {\u03b1 \u03b1' : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b2' : \u03b1' \u2192 Sort v} {f : \u2200a, \u03b2 a} {f' : \u2200a, \u03b2' a}\n    (h\u03b1 : \u03b1 = \u03b1') (h : \u2200a a', HEq a a' \u2192 HEq (f a) (f' a')) : HEq f f' := by\n  subst h\u03b1\n  have : \u2200a, HEq (f a) (f' a) := fun a \u21a6 h a a (HEq.refl a)\n  have : \u03b2 = \u03b2' := by funext a; exact type_eq_of_heq (this a)\n  subst this\n  apply heq_of_eq\n  funext a\n  exact eq_of_heq (this a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b1' : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\n\u03b2' : \u03b1' \u2192 Sort v\nf : (a : \u03b1) \u2192 \u03b2 a\nf' : (a : \u03b1') \u2192 \u03b2' a\nh\u03b1 : \u03b1 = \u03b1'\nh : \u2200 (a : \u03b1) (a' : \u03b1'), HEq a a' \u2192 HEq (f a) (f' a')\n\u22a2 HEq f f'"}, {"line": "subst h\u03b1", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf : (a : \u03b1) \u2192 \u03b2 a\n\u03b2' : \u03b1 \u2192 Sort v\nf' : (a : \u03b1) \u2192 \u03b2' a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\n\u22a2 HEq f f'"}, {"line": "have : \u2200a, HEq (f a) (f' a) := fun a \u21a6 h a a (HEq.refl a)", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf : (a : \u03b1) \u2192 \u03b2 a\n\u03b2' : \u03b1 \u2192 Sort v\nf' : (a : \u03b1) \u2192 \u03b2' a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\nthis : \u2200 (a : \u03b1), HEq (f a) (f' a)\n\u22a2 HEq f f'"}, {"line": "have : \u03b2 = \u03b2' := by funext a; exact type_eq_of_heq (this a)", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf : (a : \u03b1) \u2192 \u03b2 a\n\u03b2' : \u03b1 \u2192 Sort v\nf' : (a : \u03b1) \u2192 \u03b2' a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\nthis\u271d : \u2200 (a : \u03b1), HEq (f a) (f' a)\nthis : \u03b2 = \u03b2'\n\u22a2 HEq f f'"}, {"line": "subst this", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf f' : (a : \u03b1) \u2192 \u03b2 a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\nthis : \u2200 (a : \u03b1), HEq (f a) (f' a)\n\u22a2 HEq f f'"}, {"line": "apply heq_of_eq", "tactic_state": "case h\n\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf f' : (a : \u03b1) \u2192 \u03b2 a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\nthis : \u2200 (a : \u03b1), HEq (f a) (f' a)\n\u22a2 f = f'"}, {"line": "funext a", "tactic_state": "case h.h\n\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\nf f' : (a : \u03b1) \u2192 \u03b2 a\nh : \u2200 (a a' : \u03b1), HEq a a' \u2192 HEq (f a) (f' a')\nthis : \u2200 (a : \u03b1), HEq (f a) (f' a)\na : \u03b1\n\u22a2 f a = f' a"}, {"line": "exact eq_of_heq (this a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma funext_iff_of_subsingleton [Subsingleton \u03b1] {g : \u03b1 \u2192 \u03b2} (x y : \u03b1) :\n    f x = g y \u2194 f = g := by\n  refine \u27e8fun h \u21a6 funext fun z \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rwa [Subsingleton.elim x z, Subsingleton.elim y z] at h\n  \u00b7 rw [h, Subsingleton.elim x y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Subsingleton \u03b1\ng : \u03b1 \u2192 \u03b2\nx y : \u03b1\n\u22a2 f x = g y \u2194 f = g"}, {"line": "refine \u27e8fun h \u21a6 funext fun z \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Subsingleton \u03b1\ng : \u03b1 \u2192 \u03b2\nx y : \u03b1\nh : f x = g y\nz : \u03b1\n\u22a2 f z = g z\n---\ncase refine_2\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Subsingleton \u03b1\ng : \u03b1 \u2192 \u03b2\nx y : \u03b1\nh : f = g\n\u22a2 f x = g y"}, {"line": "\u00b7 rwa [Subsingleton.elim x z, Subsingleton.elim y z] at h", "tactic_state": "case refine_2\n\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\ninst\u271d : Subsingleton \u03b1\ng : \u03b1 \u2192 \u03b2\nx y : \u03b1\nh : f = g\n\u22a2 f x = g y"}, {"line": "\u00b7 rw [h, Subsingleton.elim x y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_injective_iff : \u00ac Injective f \u2194 \u2203 a b, f a = f b \u2227 a \u2260 b := by\n  simp only [Injective]\n  simp only [not_forall]\n  simp only [exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acInjective f \u2194 \u2203 a b, f a = f b \u2227 a \u2260 b"}, {"line": "simp only [Injective]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u00ac\u2200 \u2983a\u2081 a\u2082 : \u03b1\u2984, f a\u2081 = f a\u2082 \u2192 a\u2081 = a\u2082) \u2194 \u2203 a b, f a = f b \u2227 a \u2260 b"}, {"line": "simp only [not_forall]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2203 x x_1, \u2203 (_ : f x = f x_1), \u00acx = x_1) \u2194 \u2203 a b, f a = f b \u2227 a \u2260 b"}, {"line": "simp only [exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invFun_eq (h : \u2203 a, f a = b) : f (invFun f b) = b := by\n  simp only [invFun]\n  simp only [dif_pos h]\n  simp only [h.choose_spec]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nh : \u2203 a, f a = b\n\u22a2 f (invFun f b) = b"}, {"line": "simp only [invFun]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nh : \u2203 a, f a = b\n\u22a2 f (if h : \u2203 x, f x = b then h.choose else Classical.arbitrary \u03b1) = b"}, {"line": "simp only [dif_pos h]", "tactic_state": "\u03b1 : Sort u_1\n\u03b2 : Sort u_2\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nh : \u2203 a, f a = b\n\u22a2 f h.choose = b"}, {"line": "simp only [h.choose_spec]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjective_comp_left_iff [Nonempty \u03b1] {g : \u03b2 \u2192 \u03b3} :\n    Surjective (g \u2218 \u00b7 : (\u03b1 \u2192 \u03b2) \u2192 \u03b1 \u2192 \u03b3) \u2194 Surjective g := by\n  refine \u27e8fun h c \u21a6 Nonempty.elim \u2039_\u203a fun a \u21a6 ?_, (\u00b7.comp_left)\u27e9\n  have \u27e8f, hf\u27e9 := h fun _ \u21a6 c\n  exact \u27e8f a, congr_fun hf _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ninst\u271d : Nonempty \u03b1\ng : \u03b2 \u2192 \u03b3\n\u22a2 (Surjective fun x => g \u2218 x) \u2194 Surjective g"}, {"line": "refine \u27e8fun h c \u21a6 Nonempty.elim \u2039_\u203a fun a \u21a6 ?_, (\u00b7.comp_left)\u27e9", "tactic_state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ninst\u271d : Nonempty \u03b1\ng : \u03b2 \u2192 \u03b3\nh : Surjective fun x => g \u2218 x\nc : \u03b3\na : \u03b1\n\u22a2 \u2203 a, g a = c"}, {"line": "have \u27e8f, hf\u27e9 := h fun _ \u21a6 c", "tactic_state": "\u03b1 : Sort u\n\u03b2 : Sort v\n\u03b3 : Sort w\ninst\u271d : Nonempty \u03b1\ng : \u03b2 \u2192 \u03b3\nh : Surjective fun x => g \u2218 x\nc : \u03b3\na : \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : (fun x => g \u2218 x) f = fun x => c\n\u22a2 \u2203 a, g a = c"}, {"line": "exact \u27e8f a, congr_fun hf _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_update_iff (f : \u2200a, \u03b2 a) {a : \u03b1} {b : \u03b2 a} (p : \u2200a, \u03b2 a \u2192 Prop) :\n    (\u2200 x, p x (update f a b x)) \u2194 p a b \u2227 \u2200 x, x \u2260 a \u2192 p x (f x) := by\n  rw [\u2190 and_forall_ne a]\n  rw [update_self]\n  simp +contextual\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\ninst\u271d : DecidableEq \u03b1\nf : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nb : \u03b2 a\np : (a : \u03b1) \u2192 \u03b2 a \u2192 Prop\n\u22a2 (\u2200 (x : \u03b1), p x (update f a b x)) \u2194 p a b \u2227 \u2200 (x : \u03b1), x \u2260 a \u2192 p x (f x)"}, {"line": "rw [\u2190 and_forall_ne a]", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\ninst\u271d : DecidableEq \u03b1\nf : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nb : \u03b2 a\np : (a : \u03b1) \u2192 \u03b2 a \u2192 Prop\n\u22a2 (p a (update f a b a) \u2227 \u2200 (b_1 : \u03b1), b_1 \u2260 a \u2192 p b_1 (update f a b b_1)) \u2194 p a b \u2227 \u2200 (x : \u03b1), x \u2260 a \u2192 p x (f x)"}, {"line": "rw [update_self]", "tactic_state": "\u03b1 : Sort u\n\u03b2 : \u03b1 \u2192 Sort v\ninst\u271d : DecidableEq \u03b1\nf : (a : \u03b1) \u2192 \u03b2 a\na : \u03b1\nb : \u03b2 a\np : (a : \u03b1) \u2192 \u03b2 a \u2192 Prop\n\u22a2 (p a b \u2227 \u2200 (b_1 : \u03b1), b_1 \u2260 a \u2192 p b_1 (update f a b b_1)) \u2194 p a b \u2227 \u2200 (x : \u03b1), x \u2260 a \u2192 p x (f x)"}, {"line": "simp +contextual", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_update {\u03b9 : Sort*} [DecidableEq \u03b9] {\u03b1 \u03b2 : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b1 i \u2192 \u03b2 i)\n    (g : \u2200 i, \u03b1 i) (i : \u03b9) (v : \u03b1 i) (j : \u03b9) :\n    f j (update g i v j) = update (fun k \u21a6 f k (g k)) i (f i v) j := by\n  by_cases h : j = i\n  \u00b7 subst j\n    simp\n  \u00b7 simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ng : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nv : \u03b1 i\nj : \u03b9\n\u22a2 f j (update g i v j) = update (fun k => f k (g k)) i (f i v) j"}, {"line": "by_cases h : j = i", "tactic_state": "case pos\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ng : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nv : \u03b1 i\nj : \u03b9\nh : j = i\n\u22a2 f j (update g i v j) = update (fun k => f k (g k)) i (f i v) j\n---\ncase neg\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ng : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nv : \u03b1 i\nj : \u03b9\nh : \u00acj = i\n\u22a2 f j (update g i v j) = update (fun k => f k (g k)) i (f i v) j"}, {"line": "\u00b7 subst j\n    simp", "tactic_state": "case neg\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\ng : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\nv : \u03b1 i\nj : \u03b9\nh : \u00acj = i\n\u22a2 f j (update g i v j) = update (fun k => f k (g k)) i (f i v) j"}, {"line": "\u00b7 simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_update\u2082 {\u03b9 : Sort*} [DecidableEq \u03b9] {\u03b1 \u03b2 \u03b3 : \u03b9 \u2192 Sort*} (f : \u2200 i, \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i)\n    (g : \u2200 i, \u03b1 i) (h : \u2200 i, \u03b2 i) (i : \u03b9) (v : \u03b1 i) (w : \u03b2 i) (j : \u03b9) :\n    f j (update g i v j) (update h i w j) = update (fun k \u21a6 f k (g k) (h k)) i (f i v w) j := by\n  by_cases h : j = i\n  \u00b7 subst j\n    simp\n  \u00b7 simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\n\u03b3 : \u03b9 \u2192 Sort u_6\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i\ng : (i : \u03b9) \u2192 \u03b1 i\nh : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\nv : \u03b1 i\nw : \u03b2 i\nj : \u03b9\n\u22a2 f j (update g i v j) (update h i w j) = update (fun k => f k (g k) (h k)) i (f i v w) j"}, {"line": "by_cases h : j = i", "tactic_state": "case pos\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\n\u03b3 : \u03b9 \u2192 Sort u_6\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i\ng : (i : \u03b9) \u2192 \u03b1 i\nh\u271d : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\nv : \u03b1 i\nw : \u03b2 i\nj : \u03b9\nh : j = i\n\u22a2 f j (update g i v j) (update h\u271d i w j) = update (fun k => f k (g k) (h\u271d k)) i (f i v w) j\n---\ncase neg\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\n\u03b3 : \u03b9 \u2192 Sort u_6\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i\ng : (i : \u03b9) \u2192 \u03b1 i\nh\u271d : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\nv : \u03b1 i\nw : \u03b2 i\nj : \u03b9\nh : \u00acj = i\n\u22a2 f j (update g i v j) (update h\u271d i w j) = update (fun k => f k (g k) (h\u271d k)) i (f i v w) j"}, {"line": "\u00b7 subst j\n    simp", "tactic_state": "case neg\n\u03b9 : Sort u_3\ninst\u271d : DecidableEq \u03b9\n\u03b1 : \u03b9 \u2192 Sort u_4\n\u03b2 : \u03b9 \u2192 Sort u_5\n\u03b3 : \u03b9 \u2192 Sort u_6\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i \u2192 \u03b3 i\ng : (i : \u03b9) \u2192 \u03b1 i\nh\u271d : (i : \u03b9) \u2192 \u03b2 i\ni : \u03b9\nv : \u03b1 i\nw : \u03b2 i\nj : \u03b9\nh : \u00acj = i\n\u22a2 f j (update g i v j) (update h\u271d i w j) = update (fun k => f k (g k) (h\u271d k)) i (f i v w) j"}, {"line": "\u00b7 simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_idem {\u03b1} [DecidableEq \u03b1] {\u03b2 : \u03b1 \u2192 Sort*} {a : \u03b1} (v w : \u03b2 a) (f : \u2200 a, \u03b2 a) :\n    update (update f a v) a w = update f a w := by\n  funext b\n  by_cases h : b = a <;> simp [update, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_4\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Sort u_3\na : \u03b1\nv w : \u03b2 a\nf : (a : \u03b1) \u2192 \u03b2 a\n\u22a2 update (update f a v) a w = update f a w"}, {"line": "funext b", "tactic_state": "case h\n\u03b1 : Sort u_4\ninst\u271d : DecidableEq \u03b1\n\u03b2 : \u03b1 \u2192 Sort u_3\na : \u03b1\nv w : \u03b2 a\nf : (a : \u03b1) \u2192 \u03b2 a\nb : \u03b1\n\u22a2 update (update f a v) a w b = update f a w b"}, {"line": "by_cases h : b = a <;> simp [update, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extend_def (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b3) (e' : \u03b2 \u2192 \u03b3) (b : \u03b2) [Decidable (\u2203 a, f a = b)] :\n    extend f g e' b = if h : \u2203 a, f a = b then g (Classical.choose h) else e' b := by\n  unfold extend\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne' : \u03b2 \u2192 \u03b3\nb : \u03b2\ninst\u271d : Decidable (\u2203 a, f a = b)\n\u22a2 extend f g e' b = if h : \u2203 a, f a = b then g (Classical.choose h) else e' b"}, {"line": "unfold extend", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ne' : \u03b2 \u2192 \u03b3\nb : \u03b2\ninst\u271d : Decidable (\u2203 a, f a = b)\n\u22a2 (if h : \u2203 a, f a = b then g (Classical.choose h) else e' b) =\n    if h : \u2203 a, f a = b then g (Classical.choose h) else e' b"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extend_injective (hf : Injective f) (e' : \u03b2 \u2192 \u03b3) : Injective fun g \u21a6 extend f g e' := by\n  intro g\u2081 g\u2082 hg\n  refine funext fun x \u21a6 ?_\n  have H := congr_fun hg (f x)\n  simp only [hf.extend_apply] at H\n  exact H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ne' : \u03b2 \u2192 \u03b3\n\u22a2 Injective fun g => extend f g e'"}, {"line": "intro g\u2081 g\u2082 hg", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ne' : \u03b2 \u2192 \u03b3\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\nhg : (fun g => extend f g e') g\u2081 = (fun g => extend f g e') g\u2082\n\u22a2 g\u2081 = g\u2082"}, {"line": "refine funext fun x \u21a6 ?_", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ne' : \u03b2 \u2192 \u03b3\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\nhg : (fun g => extend f g e') g\u2081 = (fun g => extend f g e') g\u2082\nx : \u03b1\n\u22a2 g\u2081 x = g\u2082 x"}, {"line": "have H := congr_fun hg (f x)", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ne' : \u03b2 \u2192 \u03b3\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\nhg : (fun g => extend f g e') g\u2081 = (fun g => extend f g e') g\u2082\nx : \u03b1\nH : (fun g => extend f g e') g\u2081 (f x) = (fun g => extend f g e') g\u2082 (f x)\n\u22a2 g\u2081 x = g\u2082 x"}, {"line": "simp only [hf.extend_apply] at H", "tactic_state": "\u03b1 : Sort u_3\n\u03b2 : Sort u_4\n\u03b3 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ne' : \u03b2 \u2192 \u03b3\ng\u2081 g\u2082 : \u03b1 \u2192 \u03b3\nhg : (fun g => extend f g e') g\u2081 = (fun g => extend f g e') g\u2082\nx : \u03b1\nH : g\u2081 x = g\u2082 x\n\u22a2 g\u2081 x = g\u2082 x"}, {"line": "exact H", "tactic_state": "No Goals!"}]}
{"declaration": "lemma symmetric_apply_eq_iff {\u03b1 : Sort*} {f : \u03b1 \u2192 \u03b1} : Symmetric (f \u00b7 = \u00b7) \u2194 Involutive f := by\n  simp [Symmetric, Involutive]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_15\nf : \u03b1 \u2192 \u03b1\n\u22a2 (Symmetric fun x1 x2 => f x1 = x2) \u2194 Involutive f"}, {"line": "simp [Symmetric, Involutive]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sometimes_spec {p : Prop} {\u03b1} [Nonempty \u03b1] (P : \u03b1 \u2192 Prop) (f : p \u2192 \u03b1) (a : p)\n    (h : P (f a)) : P (sometimes f) := by\n  rwa [sometimes_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\n\u03b1 : Sort u_18\ninst\u271d : Nonempty \u03b1\nP : \u03b1 \u2192 Prop\nf : p \u2192 \u03b1\na : p\nh : P (f a)\n\u22a2 P (sometimes f)"}, {"line": "rwa [sometimes_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_existsUnique_iff' {r : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    (\u2200 a, \u2203! b, r a b) \u2194 \u2203 f : \u03b1 \u2192 \u03b2, r = (f \u00b7 = \u00b7) := by\n  simp [forall_existsUnique_iff, funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_18\n\u03b2 : Sort u_19\nr : \u03b1 \u2192 \u03b2 \u2192 Prop\n\u22a2 (\u2200 (a : \u03b1), \u2203! b, r a b) \u2194 \u2203 f, r = fun x1 x2 => f x1 = x2"}, {"line": "simp [forall_existsUnique_iff, funext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Symmetric.forall_existsUnique_iff' {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Symmetric r) :\n    (\u2200 a, \u2203! b, r a b) \u2194 \u2203 f : \u03b1 \u2192 \u03b1, Involutive f \u2227 r = (f \u00b7 = \u00b7) := by\n  refine \u27e8fun h \u21a6 ?_, fun \u27e8f, _, hf\u27e9 \u21a6 forall_existsUnique_iff'.2 \u27e8f, hf\u27e9\u27e9\n  rcases forall_existsUnique_iff'.1 h with \u27e8f, rfl : r = _\u27e9\n  exact \u27e8f, symmetric_apply_eq_iff.1 hr, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_18\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Symmetric r\n\u22a2 (\u2200 (a : \u03b1), \u2203! b, r a b) \u2194 \u2203 f, Involutive f \u2227 r = fun x1 x2 => f x1 = x2"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun \u27e8f, _, hf\u27e9 \u21a6 forall_existsUnique_iff'.2 \u27e8f, hf\u27e9\u27e9", "tactic_state": "\u03b1 : Sort u_18\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Symmetric r\nh : \u2200 (a : \u03b1), \u2203! b, r a b\n\u22a2 \u2203 f, Involutive f \u2227 r = fun x1 x2 => f x1 = x2"}, {"line": "rcases forall_existsUnique_iff'.1 h with \u27e8f, rfl : r = _\u27e9", "tactic_state": "case intro\n\u03b1 : Sort u_18\nf : \u03b1 \u2192 \u03b1\nhr : Symmetric fun x1 x2 => f x1 = x2\nh : \u2200 (a : \u03b1), \u2203! b, (fun x1 x2 => f x1 = x2) a b\n\u22a2 \u2203 f_1, Involutive f_1 \u2227 (fun x1 x2 => f x1 = x2) = fun x1 x2 => f_1 x1 = x2"}, {"line": "exact \u27e8f, symmetric_apply_eq_iff.1 hr, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Symmetric.forall_existsUnique_iff {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Symmetric r) :\n    (\u2200 a, \u2203! b, r a b) \u2194 \u2203 f : \u03b1 \u2192 \u03b1, Involutive f \u2227 \u2200 {a b}, r a b \u2194 f a = b := by\n  simp [hr.forall_existsUnique_iff', funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_18\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Symmetric r\n\u22a2 (\u2200 (a : \u03b1), \u2203! b, r a b) \u2194 \u2203 f, Involutive f \u2227 \u2200 {a b : \u03b1}, r a b \u2194 f a = b"}, {"line": "simp [hr.forall_existsUnique_iff', funext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_mp_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (Eq.mp h) := by\n  -- TODO: mathlib3 uses `eq_rec_on_bijective`, difference in elaboration here\n  -- due to `@[macro_inline]` possibly?\n  cases h\n  exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Sort u_20\nh : \u03b1 = \u03b2\n\u22a2 Bijective h.mp"}, {"line": "cases h", "tactic_state": "case refl\n\u03b1 : Sort u_20\n\u22a2 Bijective \u22ef.mp"}, {"line": "exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_mpr_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (Eq.mpr h) := by\n  cases h\n  exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Sort u_20\nh : \u03b1 = \u03b2\n\u22a2 Bijective h.mpr"}, {"line": "cases h", "tactic_state": "case refl\n\u03b1 : Sort u_20\n\u22a2 Bijective \u22ef.mpr"}, {"line": "exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_bijective {\u03b1 \u03b2 : Sort _} (h : \u03b1 = \u03b2) : Function.Bijective (cast h) := by\n  cases h\n  exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 \u03b2 : Sort u_20\nh : \u03b1 = \u03b2\n\u22a2 Bijective (cast h)"}, {"line": "cases h", "tactic_state": "case refl\n\u03b1 : Sort u_20\n\u22a2 Bijective (cast \u22ef)"}, {"line": "exact \u27e8fun _ _ \u21a6 id, fun x \u21a6 \u27e8x, rfl\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.LeftInverse.cast_eq {\u03b3 : \u03b2 \u2192 Sort v} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse g f) (C : \u2200 a : \u03b1, \u03b3 (f a)) (a : \u03b1) :\n    cast (congr_arg (fun a \u21a6 \u03b3 (f a)) (h a)) (C (g (f a))) = C a := by\n  rw [cast_eq_iff_heq]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Function/Basic.lean", "context": {"open": ["Function", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Sort*} [Nonempty \u03b1] {f : \u03b1 \u2192 \u03b2} {b : \u03b2}", "{\u03b1 : Sort u} {\u03b2 : Sort v} {\u03b3 : Sort w} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 : Sort u} {\u03b2 : \u03b1 \u2192 Sort v} {\u03b1' : Sort w} [DecidableEq \u03b1]", "[DecidableEq \u03b1']", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{\u03b1 : Sort u} {f : \u03b1 \u2192 \u03b1} (h : Involutive f)", "{\u03b1 \u03b2 \u03b3 : Sort*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{\u03b1 \u03b2 : Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_18\n\u03b2 : Sort u_19\n\u03b3 : \u03b2 \u2192 Sort v\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nh : LeftInverse g f\nC : (a : \u03b1) \u2192 \u03b3 (f a)\na : \u03b1\n\u22a2 cast \u22ef (C (g (f a))) = C a"}, {"line": "rw [cast_eq_iff_heq]", "tactic_state": "\u03b1 : Sort u_18\n\u03b2 : Sort u_19\n\u03b3 : \u03b2 \u2192 Sort v\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nh : LeftInverse g f\nC : (a : \u03b1) \u2192 \u03b3 (f a)\na : \u03b1\n\u22a2 HEq (C (g (f a))) (C a)"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma beta_unbeta_coe (l : List \u2115) (i : Fin l.length) : beta (unbeta l) i = l[i] := by\n  simpa [beta, unbeta, coprimes] using mod_eq_of_modEq\n    ((chineseRemainderOfFinset (l[\u00b7]) (coprimes (l[\u00b7])) Finset.univ\n      (by simp [coprimes])\n      (by simpa using Set.pairwise_univ.mpr (pairwise_coprime_coprimes _))).prop i (by simp))\n    (coprimes_lt _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Godel/GodelBetaFunction.lean", "context": {"open": ["scoped Function in -- required for scoped `on` notation"], "variables": ["{m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbeta : x\u271d\nl : List \u2115\ni : Fin l.length\n\u22a2 sorry = l[i]"}, {"line": "simpa [beta, unbeta, coprimes] using mod_eq_of_modEq\n    ((chineseRemainderOfFinset (l[\u00b7]) (coprimes (l[\u00b7])) Finset.univ\n      (by simp [coprimes])\n      (by simpa using Set.pairwise_univ.mpr (pairwise_coprime_coprimes _))).prop i (by simp))\n    (coprimes_lt _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subtype.nontrivial_iff_exists_ne (p : \u03b1 \u2192 Prop) (x : Subtype p) :\n    Nontrivial (Subtype p) \u2194 \u2203 (y : \u03b1) (_ : p y), y \u2260 x := by\n  simp only [_root_.nontrivial_iff_exists_ne x]\n  simp only [Subtype.exists]\n  simp only [Ne]\n  simp only [Subtype.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Nontrivial/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nx : Subtype p\n\u22a2 Nontrivial (Subtype p) \u2194 \u2203 y, \u2203 (_ : p y), y \u2260 \u2191x"}, {"line": "simp only [_root_.nontrivial_iff_exists_ne x]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nx : Subtype p\n\u22a2 (\u2203 y, y \u2260 x) \u2194 \u2203 y, \u2203 (_ : p y), y \u2260 \u2191x"}, {"line": "simp only [Subtype.exists]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nx : Subtype p\n\u22a2 (\u2203 a, \u2203 (b : p a), \u27e8a, b\u27e9 \u2260 x) \u2194 \u2203 y, \u2203 (_ : p y), y \u2260 \u2191x"}, {"line": "simp only [Ne]", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nx : Subtype p\n\u22a2 (\u2203 a, \u2203 (h : p a), \u00ac\u27e8a, \u22ef\u27e9 = x) \u2194 \u2203 y, \u2203 (_ : p y), \u00acy = \u2191x"}, {"line": "simp only [Subtype.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_at (i' : I) [inst : \u2200 i, Nonempty (f i)] [Nontrivial (f i')] :\n    Nontrivial (\u2200 i : I, f i) := by\n  letI := Classical.decEq (\u2200 i : I, f i)\n  exact (Function.update_injective (fun i \u21a6 Classical.choice (inst i)) i').nontrivial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Nontrivial/Basic.lean", "context": {"open": ["Classical in", "Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "{I : Type*} {f : I \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u_1\nf : I \u2192 Type u_2\ni' : I\ninst : \u2200 (i : I), Nonempty (f i)\ninst\u271d : Nontrivial (f i')\n\u22a2 Nontrivial ((i : I) \u2192 f i)"}, {"line": "letI := Classical.decEq (\u2200 i : I, f i)", "tactic_state": "I : Type u_1\nf : I \u2192 Type u_2\ni' : I\ninst : \u2200 (i : I), Nonempty (f i)\ninst\u271d : Nontrivial (f i')\nthis : DecidableEq ((i : I) \u2192 f i) := Classical.decEq ((i : I) \u2192 f i)\n\u22a2 Nontrivial ((i : I) \u2192 f i)"}, {"line": "exact (Function.update_injective (fun i \u21a6 Classical.choice (inst i)) i').nontrivial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_nontrivial_iff_subsingleton : \u00acNontrivial \u03b1 \u2194 Subsingleton \u03b1 := by\n  simp only [nontrivial_iff]\n  simp only [subsingleton_iff]\n  simp only [not_exists]\n  simp only [Classical.not_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Nontrivial/Defs.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acNontrivial \u03b1 \u2194 Subsingleton \u03b1"}, {"line": "simp only [nontrivial_iff]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 Subsingleton \u03b1"}, {"line": "simp only [subsingleton_iff]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (\u00ac\u2203 x y, x \u2260 y) \u2194 \u2200 (x y : \u03b1), x = y"}, {"line": "simp only [not_exists]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (\u2200 (x x_1 : \u03b1), \u00acx \u2260 x_1) \u2194 \u2200 (x y : \u03b1), x = y"}, {"line": "simp only [Classical.not_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_or_nontrivial (\u03b1 : Type*) : Subsingleton \u03b1 \u2228 Nontrivial \u03b1 := by\n  rw [\u2190 not_nontrivial_iff_subsingleton]\n  rw [or_comm]\n  exact Classical.em _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Nontrivial/Defs.lean", "context": {"open": ["Classical in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Subsingleton \u03b1 \u2228 Nontrivial \u03b1"}, {"line": "rw [\u2190 not_nontrivial_iff_subsingleton]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acNontrivial \u03b1 \u2228 Nontrivial \u03b1"}, {"line": "rw [or_comm]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 Nontrivial \u03b1 \u2228 \u00acNontrivial \u03b1"}, {"line": "exact Classical.em _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Shrink.ext {\u03b1 : Type v} [Small.{w} \u03b1] {x y : Shrink \u03b1}\n    (w : (equivShrink _).symm x = (equivShrink _).symm y) : x = y := by\n  simpa using w\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Logic/Small/Defs.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\ninst\u271d : Small.{w, v} \u03b1\nx y : Shrink.{w, v} \u03b1\nw : (equivShrink \u03b1).symm x = (equivShrink \u03b1).symm y\n\u22a2 x = y"}, {"line": "simpa using w", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPiSystem.singleton (S : Set \u03b1) : IsPiSystem ({S} : Set (Set \u03b1)) := by\n  intro s h_s t h_t _\n  rw [Set.mem_singleton_iff.1 h_s]\n  rw [Set.mem_singleton_iff.1 h_t]\n  rw [Set.inter_self]\n  rw [Set.mem_singleton_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set \u03b1\n\u22a2 IsPiSystem {S}"}, {"line": "intro s h_s t h_t _", "tactic_state": "\u03b1 : Type u_1\nS s : Set \u03b1\nh_s : s \u2208 {S}\nt : Set \u03b1\nh_t : t \u2208 {S}\na\u271d : (s \u2229 t).Nonempty\n\u22a2 s \u2229 t \u2208 {S}"}, {"line": "rw [Set.mem_singleton_iff.1 h_s]", "tactic_state": "\u03b1 : Type u_1\nS s : Set \u03b1\nh_s : s \u2208 {S}\nt : Set \u03b1\nh_t : t \u2208 {S}\na\u271d : (s \u2229 t).Nonempty\n\u22a2 S \u2229 t \u2208 {S}"}, {"line": "rw [Set.mem_singleton_iff.1 h_t]", "tactic_state": "\u03b1 : Type u_1\nS s : Set \u03b1\nh_s : s \u2208 {S}\nt : Set \u03b1\nh_t : t \u2208 {S}\na\u271d : (s \u2229 t).Nonempty\n\u22a2 S \u2229 S \u2208 {S}"}, {"line": "rw [Set.inter_self]", "tactic_state": "\u03b1 : Type u_1\nS s : Set \u03b1\nh_s : s \u2208 {S}\nt : Set \u03b1\nh_t : t \u2208 {S}\na\u271d : (s \u2229 t).Nonempty\n\u22a2 S \u2208 {S}"}, {"line": "rw [Set.mem_singleton_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPiSystem.comap {\u03b1 \u03b2} {S : Set (Set \u03b2)} (h_pi : IsPiSystem S) (f : \u03b1 \u2192 \u03b2) :\n    IsPiSystem { s : Set \u03b1 | \u2203 t \u2208 S, f \u207b\u00b9' t = s } := by\n  rintro _ \u27e8s, hs_mem, rfl\u27e9 _ \u27e8t, ht_mem, rfl\u27e9 hst\n  rw [\u2190 Set.preimage_inter] at hst \u22a2\n  exact \u27e8s \u2229 t, h_pi s hs_mem t ht_mem (nonempty_of_nonempty_preimage hst), rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nS : Set (Set \u03b2)\nh_pi : IsPiSystem S\nf : \u03b1 \u2192 \u03b2\n\u22a2 IsPiSystem {s | \u2203 t \u2208 S, f \u207b\u00b9' t = s}"}, {"line": "rintro _ \u27e8s, hs_mem, rfl\u27e9 _ \u27e8t, ht_mem, rfl\u27e9 hst", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nS : Set (Set \u03b2)\nh_pi : IsPiSystem S\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhs_mem : s \u2208 S\nt : Set \u03b2\nht_mem : t \u2208 S\nhst : (f \u207b\u00b9' s \u2229 f \u207b\u00b9' t).Nonempty\n\u22a2 f \u207b\u00b9' s \u2229 f \u207b\u00b9' t \u2208 {s | \u2203 t \u2208 S, f \u207b\u00b9' t = s}"}, {"line": "rw [\u2190 Set.preimage_inter] at hst \u22a2", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nS : Set (Set \u03b2)\nh_pi : IsPiSystem S\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhs_mem : s \u2208 S\nt : Set \u03b2\nht_mem : t \u2208 S\nhst : (f \u207b\u00b9' (s \u2229 t)).Nonempty\n\u22a2 f \u207b\u00b9' (s \u2229 t) \u2208 {s | \u2203 t \u2208 S, f \u207b\u00b9' t = s}"}, {"line": "exact \u27e8s \u2229 t, h_pi s hs_mem t ht_mem (nonempty_of_nonempty_preimage hst), rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPiSystem_iUnion_of_directed_le {\u03b1 \u03b9} (p : \u03b9 \u2192 Set (Set \u03b1))\n    (hp_pi : \u2200 n, IsPiSystem (p n)) (hp_directed : Directed (\u00b7 \u2264 \u00b7) p) :\n    IsPiSystem (\u22c3 n, p n) := by\n  intro t1 ht1 t2 ht2 h\n  rw [Set.mem_iUnion] at ht1 ht2 \u22a2\n  obtain \u27e8n, ht1\u27e9 := ht1\n  obtain \u27e8m, ht2\u27e9 := ht2\n  obtain \u27e8k, hpnk, hpmk\u27e9 : \u2203 k, p n \u2264 p k \u2227 p m \u2264 p k := hp_directed n m\n  exact \u27e8k, hp_pi k t1 (hpnk ht1) t2 (hpmk ht2) h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\n\u22a2 IsPiSystem (\u22c3 n, p n)"}, {"line": "intro t1 ht1 t2 ht2 h", "tactic_state": "\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\nt1 : Set \u03b1\nht1 : t1 \u2208 \u22c3 n, p n\nt2 : Set \u03b1\nht2 : t2 \u2208 \u22c3 n, p n\nh : (t1 \u2229 t2).Nonempty\n\u22a2 t1 \u2229 t2 \u2208 \u22c3 n, p n"}, {"line": "rw [Set.mem_iUnion] at ht1 ht2 \u22a2", "tactic_state": "\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\nt1 : Set \u03b1\nht1 : \u2203 i, t1 \u2208 p i\nt2 : Set \u03b1\nht2 : \u2203 i, t2 \u2208 p i\nh : (t1 \u2229 t2).Nonempty\n\u22a2 \u2203 i, t1 \u2229 t2 \u2208 p i"}, {"line": "obtain \u27e8n, ht1\u27e9 := ht1", "tactic_state": "case intro\n\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\nt1 t2 : Set \u03b1\nht2 : \u2203 i, t2 \u2208 p i\nh : (t1 \u2229 t2).Nonempty\nn : \u03b9\nht1 : t1 \u2208 p n\n\u22a2 \u2203 i, t1 \u2229 t2 \u2208 p i"}, {"line": "obtain \u27e8m, ht2\u27e9 := ht2", "tactic_state": "case intro.intro\n\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\nt1 t2 : Set \u03b1\nh : (t1 \u2229 t2).Nonempty\nn : \u03b9\nht1 : t1 \u2208 p n\nm : \u03b9\nht2 : t2 \u2208 p m\n\u22a2 \u2203 i, t1 \u2229 t2 \u2208 p i"}, {"line": "obtain \u27e8k, hpnk, hpmk\u27e9 : \u2203 k, p n \u2264 p k \u2227 p m \u2264 p k := hp_directed n m", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_3\n\u03b9 : Sort u_4\np : \u03b9 \u2192 Set (Set \u03b1)\nhp_pi : \u2200 (n : \u03b9), IsPiSystem (p n)\nhp_directed : Directed (fun x1 x2 => x1 \u2264 x2) p\nt1 t2 : Set \u03b1\nh : (t1 \u2229 t2).Nonempty\nn : \u03b9\nht1 : t1 \u2208 p n\nm : \u03b9\nht2 : t2 \u2208 p m\nk : \u03b9\nhpnk : p n \u2264 p k\nhpmk : p m \u2264 p k\n\u22a2 \u2203 i, t1 \u2229 t2 \u2208 p i"}, {"line": "exact \u27e8k, hp_pi k t1 (hpnk ht1) t2 (hpmk ht2) h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPiSystem_Ixx {Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1} {p : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    (Hne : \u2200 {a b}, (Ixx a b).Nonempty \u2192 p a b)\n    (Hi : \u2200 {a\u2081 b\u2081 a\u2082 b\u2082}, Ixx a\u2081 b\u2081 \u2229 Ixx a\u2082 b\u2082 = Ixx (max a\u2081 a\u2082) (min b\u2081 b\u2082)) (f : \u03b9 \u2192 \u03b1)\n    (g : \u03b9' \u2192 \u03b1) : @IsPiSystem \u03b1 { S | \u2203 i j, p (f i) (g j) \u2227 Ixx (f i) (g j) = S } := by\n  simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_3\n\u03b9' : Sort u_4\ninst\u271d : LinearOrder \u03b1\nIxx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1\np : \u03b1 \u2192 \u03b1 \u2192 Prop\nHne : \u2200 {a b : \u03b1}, (Ixx a b).Nonempty \u2192 p a b\nHi : \u2200 {a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1}, Ixx a\u2081 b\u2081 \u2229 Ixx a\u2082 b\u2082 = Ixx (max a\u2081 a\u2082) (min b\u2081 b\u2082)\nf : \u03b9 \u2192 \u03b1\ng : \u03b9' \u2192 \u03b1\n\u22a2 IsPiSystem {S | \u2203 i j, p (f i) (g j) \u2227 Ixx (f i) (g j) = S}"}, {"line": "simpa only [exists_range_iff] using isPiSystem_Ixx_mem (@Hne) (@Hi) (range f) (range g)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem generateFrom_generatePiSystem_eq {g : Set (Set \u03b1)} :\n    generateFrom (generatePiSystem g) = generateFrom g := by\n  apply le_antisymm <;> apply generateFrom_le\n  \u00b7 exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t\n  \u00b7 exact fun t h_t => measurableSet_generateFrom (generatePiSystem.base h_t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ng : Set (Set \u03b1)\n\u22a2 generateFrom (generatePiSystem g) = generateFrom g"}, {"line": "apply le_antisymm <;> apply generateFrom_le", "tactic_state": "case a.h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 generatePiSystem g, MeasurableSet t\n---\ncase a.h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 g, MeasurableSet t"}, {"line": "\u00b7 exact fun t h_t => generateFrom_measurableSet_of_generatePiSystem t h_t", "tactic_state": "case a.h\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ng : Set (Set \u03b1)\n\u22a2 \u2200 t \u2208 g, MeasurableSet t"}, {"line": "\u00b7 exact fun t h_t => measurableSet_generateFrom (generatePiSystem.base h_t)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piiUnionInter_singleton_left (s : \u03b9 \u2192 Set \u03b1) (S : Set \u03b9) :\n    piiUnionInter (fun i => ({s i} : Set (Set \u03b1))) S =\n      { s' : Set \u03b1 | \u2203 (t : Finset \u03b9) (_ : \u2191t \u2286 S), s' = \u22c2 i \u2208 t, s i } := by\n  ext1 s'\n  simp_rw [piiUnionInter, Set.mem_singleton_iff, exists_prop, Set.mem_setOf_eq]\n  refine \u27e8fun h => ?_, fun \u27e8t, htS, h_eq\u27e9 => \u27e8t, htS, s, fun _ _ => rfl, h_eq\u27e9\u27e9\n  obtain \u27e8t, htS, f, hft_eq, rfl\u27e9 := h\n  refine \u27e8t, htS, ?_\u27e9\n  congr! 3\n  apply hft_eq\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\n\u22a2 piiUnionInter (fun i => {s i}) S = {s' | \u2203 t, \u2203 (_ : \u2191t \u2286 S), s' = \u22c2 i \u2208 t, s i}"}, {"line": "ext1 s'", "tactic_state": "case h\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\ns' : Set \u03b1\n\u22a2 s' \u2208 piiUnionInter (fun i => {s i}) S \u2194 s' \u2208 {s' | \u2203 t, \u2203 (_ : \u2191t \u2286 S), s' = \u22c2 i \u2208 t, s i}"}, {"line": "simp_rw [piiUnionInter, Set.mem_singleton_iff, exists_prop, Set.mem_setOf_eq]", "tactic_state": "case h\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\ns' : Set \u03b1\n\u22a2 (\u2203 t, \u2191t \u2286 S \u2227 \u2203 f, (\u2200 x \u2208 t, f x = s x) \u2227 s' = \u22c2 x \u2208 t, f x) \u2194 \u2203 t, \u2191t \u2286 S \u2227 s' = \u22c2 i \u2208 t, s i"}, {"line": "refine \u27e8fun h => ?_, fun \u27e8t, htS, h_eq\u27e9 => \u27e8t, htS, s, fun _ _ => rfl, h_eq\u27e9\u27e9", "tactic_state": "case h\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\ns' : Set \u03b1\nh : \u2203 t, \u2191t \u2286 S \u2227 \u2203 f, (\u2200 x \u2208 t, f x = s x) \u2227 s' = \u22c2 x \u2208 t, f x\n\u22a2 \u2203 t, \u2191t \u2286 S \u2227 s' = \u22c2 i \u2208 t, s i"}, {"line": "obtain \u27e8t, htS, f, hft_eq, rfl\u27e9 := h", "tactic_state": "case h.intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\nt : Finset \u03b9\nhtS : \u2191t \u2286 S\nf : \u03b9 \u2192 Set \u03b1\nhft_eq : \u2200 x \u2208 t, f x = s x\n\u22a2 \u2203 t_1, \u2191t_1 \u2286 S \u2227 \u22c2 x \u2208 t, f x = \u22c2 i \u2208 t_1, s i"}, {"line": "refine \u27e8t, htS, ?_\u27e9", "tactic_state": "case h.intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\nt : Finset \u03b9\nhtS : \u2191t \u2286 S\nf : \u03b9 \u2192 Set \u03b1\nhft_eq : \u2200 x \u2208 t, f x = s x\n\u22a2 \u22c2 x \u2208 t, f x = \u22c2 i \u2208 t, s i"}, {"line": "congr! 3", "tactic_state": "case h.intro.intro.intro.intro.h.e'_3.h.f\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\nt : Finset \u03b9\nhtS : \u2191t \u2286 S\nf : \u03b9 \u2192 Set \u03b1\nhft_eq : \u2200 x \u2208 t, f x = s x\nx\u271d\u00b9 : \u03b9\nx\u271d : x\u271d\u00b9 \u2208 t\n\u22a2 f x\u271d\u00b9 = s x\u271d\u00b9"}, {"line": "apply hft_eq", "tactic_state": "case h.intro.intro.intro.intro.h.e'_3.h.f.a\n\u03b1 : Type u_5\n\u03b9 : Type u_6\ns : \u03b9 \u2192 Set \u03b1\nS : Set \u03b9\nt : Finset \u03b9\nhtS : \u2191t \u2286 S\nf : \u03b9 \u2192 Set \u03b1\nhft_eq : \u2200 x \u2208 t, f x = s x\nx\u271d\u00b9 : \u03b9\nx\u271d : x\u271d\u00b9 \u2208 t\n\u22a2 x\u271d\u00b9 \u2208 t"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem generateFrom_piiUnionInter_le {m : MeasurableSpace \u03b1} (\u03c0 : \u03b9 \u2192 Set (Set \u03b1))\n    (h : \u2200 n, generateFrom (\u03c0 n) \u2264 m) (S : Set \u03b9) : generateFrom (piiUnionInter \u03c0 S) \u2264 m := by\n  refine generateFrom_le ?_\n  rintro t \u27e8ht_p, _, ft, hft_mem_pi, rfl\u27e9\n  refine Finset.measurableSet_biInter _ fun x hx_mem => (h x) _ ?_\n  exact measurableSet_generateFrom (hft_mem_pi x hx_mem)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : MeasurableSpace \u03b1\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nh : \u2200 (n : \u03b9), generateFrom (\u03c0 n) \u2264 m\nS : Set \u03b9\n\u22a2 generateFrom (piiUnionInter \u03c0 S) \u2264 m"}, {"line": "refine generateFrom_le ?_", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : MeasurableSpace \u03b1\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nh : \u2200 (n : \u03b9), generateFrom (\u03c0 n) \u2264 m\nS : Set \u03b9\n\u22a2 \u2200 t \u2208 piiUnionInter \u03c0 S, MeasurableSet t"}, {"line": "rintro t \u27e8ht_p, _, ft, hft_mem_pi, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : MeasurableSpace \u03b1\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nh : \u2200 (n : \u03b9), generateFrom (\u03c0 n) \u2264 m\nS : Set \u03b9\nht_p : Finset \u03b9\nw\u271d : \u2191ht_p \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nhft_mem_pi : \u2200 x \u2208 ht_p, ft x \u2208 \u03c0 x\n\u22a2 MeasurableSet (\u22c2 x \u2208 ht_p, ft x)"}, {"line": "refine Finset.measurableSet_biInter _ fun x hx_mem => (h x) _ ?_", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : MeasurableSpace \u03b1\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nh : \u2200 (n : \u03b9), generateFrom (\u03c0 n) \u2264 m\nS : Set \u03b9\nht_p : Finset \u03b9\nw\u271d : \u2191ht_p \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nhft_mem_pi : \u2200 x \u2208 ht_p, ft x \u2208 \u03c0 x\nx : \u03b9\nhx_mem : x \u2208 ht_p\n\u22a2 MeasurableSet (ft x)"}, {"line": "exact measurableSet_generateFrom (hft_mem_pi x hx_mem)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_piiUnionInter {\u03c0 : \u03b9 \u2192 Set (Set \u03b1)} {S : Set \u03b9} {i : \u03b9} (his : i \u2208 S) :\n    \u03c0 i \u2286 piiUnionInter \u03c0 S := by\n  have h_ss : {i} \u2286 S := by\n    intro j hj\n    rw [mem_singleton_iff] at hj\n    rwa [hj]\n  refine Subset.trans ?_ (piiUnionInter_mono_right h_ss)\n  rw [piiUnionInter_singleton]\n  exact subset_union_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 S"}, {"line": "have h_ss : {i} \u2286 S := sorry", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 S"}, {"line": "refine Subset.trans ?_ (piiUnionInter_mono_right h_ss)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 piiUnionInter \u03c0 {i}"}, {"line": "rw [piiUnionInter_singleton]", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\n\u03c0 : \u03b9 \u2192 Set (Set \u03b1)\nS : Set \u03b9\ni : \u03b9\nhis : i \u2208 S\nh_ss : {i} \u2286 S\n\u22a2 \u03c0 i \u2286 \u03c0 i \u222a {univ}"}, {"line": "exact subset_union_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurableSet_iSup_of_mem_piiUnionInter (m : \u03b9 \u2192 MeasurableSpace \u03b1) (S : Set \u03b9) (t : Set \u03b1)\n    (ht : t \u2208 piiUnionInter (fun n => { s | MeasurableSet[m n] s }) S) :\n    MeasurableSet[\u2a06 i \u2208 S, m i] t := by\n  rcases ht with \u27e8pt, hpt, ft, ht_m, rfl\u27e9\n  refine pt.measurableSet_biInter fun i hi => ?_\n  suffices h_le : m i \u2264 \u2a06 i \u2208 S, m i from h_le (ft i) (ht_m i hi)\n  have hi' : i \u2208 S := hpt hi\n  exact le_iSup\u2082 (f := fun i (_ : i \u2208 S) => m i) i hi'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : \u03b9 \u2192 MeasurableSpace \u03b1\nS : Set \u03b9\nt : Set \u03b1\nht : t \u2208 piiUnionInter (fun n => {s | MeasurableSet s}) S\n\u22a2 MeasurableSet t"}, {"line": "rcases ht with \u27e8pt, hpt, ft, ht_m, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : \u03b9 \u2192 MeasurableSpace \u03b1\nS : Set \u03b9\npt : Finset \u03b9\nhpt : \u2191pt \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nht_m : \u2200 x \u2208 pt, ft x \u2208 (fun n => {s | MeasurableSet s}) x\n\u22a2 MeasurableSet (\u22c2 x \u2208 pt, ft x)"}, {"line": "refine pt.measurableSet_biInter fun i hi => ?_", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : \u03b9 \u2192 MeasurableSpace \u03b1\nS : Set \u03b9\npt : Finset \u03b9\nhpt : \u2191pt \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nht_m : \u2200 x \u2208 pt, ft x \u2208 (fun n => {s | MeasurableSet s}) x\ni : \u03b9\nhi : i \u2208 pt\n\u22a2 MeasurableSet (ft i)"}, {"line": "suffices h_le : m i \u2264 \u2a06 i \u2208 S, m i from h_le (ft i) (ht_m i hi)", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : \u03b9 \u2192 MeasurableSpace \u03b1\nS : Set \u03b9\npt : Finset \u03b9\nhpt : \u2191pt \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nht_m : \u2200 x \u2208 pt, ft x \u2208 (fun n => {s | MeasurableSet s}) x\ni : \u03b9\nhi : i \u2208 pt\n\u22a2 m i \u2264 \u2a06 i \u2208 S, m i"}, {"line": "have hi' : i \u2208 S := hpt hi", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_5\n\u03b9 : Type u_6\nm : \u03b9 \u2192 MeasurableSpace \u03b1\nS : Set \u03b9\npt : Finset \u03b9\nhpt : \u2191pt \u2286 S\nft : \u03b9 \u2192 Set \u03b1\nht_m : \u2200 x \u2208 pt, ft x \u2208 (fun n => {s | MeasurableSet s}) x\ni : \u03b9\nhi : i \u2208 pt\nhi' : i \u2208 S\n\u22a2 m i \u2264 \u2a06 i \u2208 S, m i"}, {"line": "exact le_iSup\u2082 (f := fun i (_ : i \u2208 S) => m i) i hi'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem has_univ : d.Has univ := by simpa using d.has_compl d.has_empty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}", "{\u03b1 : Type*}", "(d : DynkinSystem \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\n\u22a2 d.Has univ"}, {"line": "simpa using d.has_compl d.has_empty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem has_union {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : d.Has s\u2081) (h\u2082 : d.Has s\u2082) (h : Disjoint s\u2081 s\u2082) :\n    d.Has (s\u2081 \u222a s\u2082) := by\n  rw [union_eq_iUnion]\n  exact d.has_iUnion (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}", "{\u03b1 : Type*}", "(d : DynkinSystem \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : Disjoint s\u2081 s\u2082\n\u22a2 d.Has (s\u2081 \u222a s\u2082)"}, {"line": "rw [union_eq_iUnion]", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : Disjoint s\u2081 s\u2082\n\u22a2 d.Has (\u22c3 b, bif b then s\u2081 else s\u2082)"}, {"line": "exact d.has_iUnion (pairwise_disjoint_on_bool.2 h) (Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem has_diff {s\u2081 s\u2082 : Set \u03b1} (h\u2081 : d.Has s\u2081) (h\u2082 : d.Has s\u2082) (h : s\u2082 \u2286 s\u2081) :\n    d.Has (s\u2081 \\ s\u2082) := by\n  apply d.has_compl_iff.1\n  simp only [diff_eq]\n  simp only [compl_inter]\n  simp only [compl_compl]\n  exact d.has_union (d.has_compl h\u2081) h\u2082 (disjoint_compl_left.mono_right h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/PiSystem.lean", "context": {"open": ["MeasurableSpace Set", "MeasureTheory", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 : Type*}", "{\u03b9 \u03b9' : Sort*} [LinearOrder \u03b1]", "{\u03b1 \u03b9 : Type*}", "{\u03b1 : Type*}", "(d : DynkinSystem \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : s\u2082 \u2286 s\u2081\n\u22a2 d.Has (s\u2081 \\ s\u2082)"}, {"line": "apply d.has_compl_iff.1", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : s\u2082 \u2286 s\u2081\n\u22a2 d.Has (s\u2081 \\ s\u2082)\u1d9c"}, {"line": "simp only [diff_eq]", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : s\u2082 \u2286 s\u2081\n\u22a2 d.Has (s\u2081 \u2229 s\u2082\u1d9c)\u1d9c"}, {"line": "simp only [compl_inter]", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : s\u2082 \u2286 s\u2081\n\u22a2 d.Has (s\u2081\u1d9c \u222a s\u2082\u1d9c\u1d9c)"}, {"line": "simp only [compl_compl]", "tactic_state": "\u03b1 : Type u_7\nd : DynkinSystem \u03b1\ns\u2081 s\u2082 : Set \u03b1\nh\u2081 : d.Has s\u2081\nh\u2082 : d.Has s\u2082\nh : s\u2082 \u2286 s\u2081\n\u22a2 d.Has (s\u2081\u1d9c \u222a s\u2082)"}, {"line": "exact d.has_union (d.has_compl h\u2081) h\u2082 (disjoint_compl_left.mono_right h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_of_mem_disjointOfDiffUnion (hC : IsSetSemiring C) {I : Finset (Set \u03b1)}\n    (hs : s \u2208 C) (hI : \u2191I \u2286 C) (t : Set \u03b1)\n    (ht : t \u2208 (hC.disjointOfDiffUnion hs hI : Set (Set \u03b1))) :\n    t \u2286 s := by\n  apply le_trans <| hC.subset_of_diffUnion_disjointOfDiffUnion hs hI t ht\n  exact sdiff_le (a := s) (b := \u22c3\u2080 I)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/SetSemiring.lean", "context": {"open": ["Finset Set", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 : Type*} {C : Set (Set \u03b1)} {s t : Set \u03b1}", "{I : Finset (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_1\nIsSetSemiring : x\u271d\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nI : Finset (Set \u03b1)\nhs : s \u2208 C\nhI : I \u2286 C\nt : Set \u03b1\nht : t \u2208 sorry\n\u22a2 t \u2286 s"}, {"line": "apply le_trans <| hC.subset_of_diffUnion_disjointOfDiffUnion hs hI t ht", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_1\nIsSetSemiring : x\u271d\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nI : Finset (Set \u03b1)\nhs : s \u2208 C\nhI : I \u2286 C\nt : Set \u03b1\nht : t \u2208 sorry\n\u22a2 ?m.1520 \u2264 s\n---\n\u03b1 : Type u_2\nx\u271d : Sort u_1\nIsSetSemiring : x\u271d\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nI : Finset (Set \u03b1)\nhs : s \u2208 C\nhI : I \u2286 C\nt : Set \u03b1\nht : t \u2208 sorry\n\u22a2 Set \u03b1"}, {"line": "exact sdiff_le (a := s) (b := \u22c3\u2080 I)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pairwiseDisjoint_union_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s \u2208 C)\n    (hI : \u2191I \u2286 C) (h_dis : PairwiseDisjoint (I : Set (Set \u03b1)) id) :\n    PairwiseDisjoint (I \u222a hC.disjointOfDiffUnion hs hI : Set (Set \u03b1)) id := by\n  rw [pairwiseDisjoint_union]\n  refine \u27e8h_dis, hC.pairwiseDisjoint_disjointOfDiffUnion hs hI, fun u hu v hv _ \u21a6 ?_\u27e9\n  simp_rw [id]\n  exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)\n    (hC.disjoint_sUnion_disjointOfDiffUnion hs hI)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/SetSemiring.lean", "context": {"open": ["Finset Set", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 : Type*} {C : Set (Set \u03b1)} {s t : Set \u03b1}", "{I : Finset (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nI : Finset (Set \u03b1)\nx\u271d : Sort u_1\nIsSetSemiring : x\u271d\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nhs : s \u2208 C\nhI : I \u2286 C\nh_dis : (\u2191I).PairwiseDisjoint id\n\u22a2 (\u2191I \u222a sorry).PairwiseDisjoint id"}, {"line": "rw [pairwiseDisjoint_union]", "tactic_state": "\u03b1 : Type u_2\nI : Finset (Set \u03b1)\nx\u271d : Sort u_1\nIsSetSemiring : x\u271d\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nhs : s \u2208 C\nhI : I \u2286 C\nh_dis : (\u2191I).PairwiseDisjoint id\n\u22a2 (\u2191I).PairwiseDisjoint id \u2227\n    sorry.PairwiseDisjoint id \u2227 \u2200 \u2983i : Set \u03b1\u2984, i \u2208 \u2191I \u2192 \u2200 \u2983j : Set \u03b1\u2984, j \u2208 sorry \u2192 i \u2260 j \u2192 Disjoint (id i) (id j)"}, {"line": "refine \u27e8h_dis, hC.pairwiseDisjoint_disjointOfDiffUnion hs hI, fun u hu v hv _ \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_2\nI : Finset (Set \u03b1)\nx\u271d\u00b9 : Sort u_1\nIsSetSemiring : x\u271d\u00b9\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nhs : s \u2208 C\nhI : I \u2286 C\nh_dis : (\u2191I).PairwiseDisjoint id\nu : Set \u03b1\nhu : u \u2208 \u2191I\nv : Set \u03b1\nhv : v \u2208 sorry\nx\u271d : u \u2260 v\n\u22a2 Disjoint (id u) (id v)"}, {"line": "simp_rw [id]", "tactic_state": "\u03b1 : Type u_2\nI : Finset (Set \u03b1)\nx\u271d\u00b9 : Sort u_1\nIsSetSemiring : x\u271d\u00b9\nC : Finset (Set \u03b1)\ns : Set \u03b1\nhC : sorry\nhs : s \u2208 C\nhI : I \u2286 C\nh_dis : (\u2191I).PairwiseDisjoint id\nu : Set \u03b1\nhu : u \u2208 \u2191I\nv : Set \u03b1\nhv : v \u2208 sorry\nx\u271d : u \u2260 v\n\u22a2 Disjoint u v"}, {"line": "exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)\n    (hC.disjoint_sUnion_disjointOfDiffUnion hs hI)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma partialSups_mem {\u03b9 : Type*} [Preorder \u03b9] [LocallyFiniteOrderBot \u03b9]\n    (hC : IsSetRing C) {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 n, s n \u2208 C) (n : \u03b9) :\n    partialSups s n \u2208 C := by\n  simpa only [partialSups_apply,sup'_eq_sup] using hC.finsetSup_mem (fun i hi \u21a6 hs i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/SetSemiring.lean", "context": {"open": ["Finset Set", "scoped Classical in", "scoped Classical in", "Set MeasureTheory Order"], "variables": ["{\u03b1 : Type*} {C : Set (Set \u03b1)} {s t : Set \u03b1}", "{I : Finset (Set \u03b1)}", "{j : Set \u03b1} {J : Finset (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nC : Set (Set \u03b1)\nx\u271d : Sort u_3\nIsSetRing : x\u271d\n\u03b9 : Type u_2\ninst\u271d\u00b9 : Preorder \u03b9\ninst\u271d : LocallyFiniteOrderBot \u03b9\nhC : sorry\ns : \u03b9 \u2192 Set \u03b1\nhs : \u2200 (n : \u03b9), s n \u2208 C\nn : \u03b9\n\u22a2 (partialSups s) n \u2208 C"}, {"line": "simpa only [partialSups_apply,sup'_eq_sup] using hC.finsetSup_mem (fun i hi \u21a6 hs i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSphere_real_apply_univ : \u03bc.toSphere.real univ = dim E * \u03bc.real (ball 0 1) := by\n  simp [measureReal_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/HaarToSphere.lean", "context": {"open": ["Set Function Metric MeasurableSpace intervalIntegral", "scoped Pointwise ENNReal NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc : Measure E)", "[BorelSpace E]", "[FiniteDimensional \u211d E] [\u03bc.IsAddHaarMeasure]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2905\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : sorry\nx\u271d : Sort u_2\ndim : x\u271d\n\u22a2 sorry = sorry * sorry"}, {"line": "simp [measureReal_def]", "tactic_state": "Measure : ?m.2905\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : sorry\nx\u271d : Sort u_2\ndim : x\u271d\n\u22a2 sorry () = sorry () * sorry ()"}]}
{"declaration": "theorem tendsto_measure_cthickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (cthickening r s)) (\ud835\udcdd 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_cthickening hs\n  exact h's.closure_eq.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Metric.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Metric", "EMetric", "Metric EMetric"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "[PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d}", "[SecondCountableTopology \u03b1]", "[PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 Tendsto (fun r => \u03bc (cthickening r s)) (nhds 0) (nhds (\u03bc s))"}, {"line": "convert tendsto_measure_cthickening hs", "tactic_state": "case h.e'_5.h.e'_3.h.e'_6\n\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 s = closure s\n---\n\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 OpensMeasurableSpace \u03b1"}, {"line": "exact h's.closure_eq.symm", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (cthickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 OpensMeasurableSpace \u03b1"}]}
{"declaration": "theorem tendsto_measure_thickening_of_isClosed {\u03bc : Measure \u03b1} {s : Set \u03b1}\n    (hs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u221e) (h's : IsClosed s) :\n    Tendsto (fun r => \u03bc (thickening r s)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03bc s)) := by\n  convert tendsto_measure_thickening hs\n  exact h's.closure_eq.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Metric.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Metric", "EMetric", "Metric EMetric"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "[PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d}", "[SecondCountableTopology \u03b1]", "[PseudoEMetricSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[MeasurableSpace \u03b2] {x : \u03b1} {\u03b5 : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 Tendsto (fun r => \u03bc (thickening r s)) (nhdsWithin 0 (Ioi 0)) (nhds (\u03bc s))"}, {"line": "convert tendsto_measure_thickening hs", "tactic_state": "case h.e'_5.h.e'_3.h.e'_6\n\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 s = closure s\n---\n\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 OpensMeasurableSpace \u03b1"}, {"line": "exact h's.closure_eq.symm", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : PseudoMetricSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhs : \u2203 R > 0, \u03bc (thickening R s) \u2260 \u22a4\nh's : IsClosed s\n\u22a2 OpensMeasurableSpace \u03b1"}]}
{"declaration": "lemma opensMeasurableSpace_iff_forall_measurableSet\n    [TopologicalSpace \u03b1] [MeasurableSpace \u03b1] :\n    OpensMeasurableSpace \u03b1 \u2194  (\u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s) := by\n  refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9\n  exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "context": {"open": ["Filter MeasureTheory Set Topology", "scoped NNReal ENNReal MeasureTheory", "MeasurableSpace TopologicalSpace", "Lean Elab Term Tactic Meta"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b3\u2082 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MeasurableSpace \u03b1\n\u22a2 OpensMeasurableSpace \u03b1 \u2194 \u2200 (s : Set \u03b1), IsOpen s \u2192 MeasurableSet s"}, {"line": "refine \u27e8fun h s hs \u21a6 ?_, fun h \u21a6 \u27e8generateFrom_le h\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MeasurableSpace \u03b1\nh : OpensMeasurableSpace \u03b1\ns : Set \u03b1\nhs : IsOpen s\n\u22a2 MeasurableSet s"}, {"line": "exact OpensMeasurableSpace.borel_le _ <| GenerateMeasurable.basic _ hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem borel_eq_top_of_countable {\u03b1 : Type*} [TopologicalSpace \u03b1] [T0Space \u03b1] [Countable \u03b1] :\n    borel \u03b1 = \u22a4 := by\n  refine top_unique fun s _ \u21a6 ?_\n  borelize \u03b1\n  exact .of_discrete\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Basic.lean", "context": {"open": ["Filter MeasureTheory Set Topology", "scoped NNReal ENNReal MeasureTheory", "MeasurableSpace TopologicalSpace", "Lean Elab Term Tactic Meta", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b3\u2082 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "[TopologicalSpace \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1] [TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : T0Space \u03b1\ninst\u271d : Countable \u03b1\n\u22a2 borel \u03b1 = \u22a4"}, {"line": "refine top_unique fun s _ \u21a6 ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : T0Space \u03b1\ninst\u271d : Countable \u03b1\ns : Set \u03b1\nx\u271d : MeasurableSet s\n\u22a2 MeasurableSet s"}, {"line": "borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : T0Space \u03b1\ninst\u271d : Countable \u03b1\ns : Set \u03b1\nx\u271d : MeasurableSet s\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := sorry\nthis\u271d : sorry\n\u22a2 MeasurableSet s"}, {"line": "exact .of_discrete", "tactic_state": "No Goals!"}]}
{"declaration": "theorem generateFrom_Ico_mem_le_borel {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderClosedTopology \u03b1] (s t : Set \u03b1) :\n    MeasurableSpace.generateFrom { S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S }\n      \u2264 borel \u03b1 := by\n  apply generateFrom_le\n  borelize \u03b1\n  rintro _ \u27e8a, -, b, -, -, rfl\u27e9\n  exact measurableSet_Ico\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns t : Set \u03b1\n\u22a2 MeasurableSpace.generateFrom {S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S} \u2264 borel \u03b1"}, {"line": "apply generateFrom_le", "tactic_state": "case h\n\u03b1 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns t : Set \u03b1\n\u22a2 \u2200 t_1 \u2208 {S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S}, MeasurableSet t_1"}, {"line": "borelize \u03b1", "tactic_state": "case h\n\u03b1 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns t : Set \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := sorry\nthis\u271d : sorry\n\u22a2 \u2200 t_1 \u2208 {S | \u2203 l \u2208 s, \u2203 u \u2208 t, l < u \u2227 Ico l u = S}, MeasurableSet t_1"}, {"line": "rintro _ \u27e8a, -, b, -, -, rfl\u27e9", "tactic_state": "case h.intro.intro.intro.intro.intro\n\u03b1 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderClosedTopology \u03b1\ns t : Set \u03b1\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := sorry\nthis\u271d : sorry\na b : \u03b1\n\u22a2 MeasurableSet (Ico a b)"}, {"line": "exact measurableSet_Ico", "tactic_state": "No Goals!"}]}
{"declaration": "theorem borel_eq_generateFrom_Ico (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 (l u : \u03b1), l < u \u2227 Ico l u = S } := by\n  simpa only [exists_prop,mem_univ,true_and] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\n\u22a2 borel \u03b1 = MeasurableSpace.generateFrom {S | \u2203 l u, l < u \u2227 Ico l u = S}"}, {"line": "simpa only [exists_prop,mem_univ,true_and] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ico_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem borel_eq_generateFrom_Ioc (\u03b1 : Type*) [TopologicalSpace \u03b1] [SecondCountableTopology \u03b1]\n    [LinearOrder \u03b1] [OrderTopology \u03b1] :\n    borel \u03b1 = .generateFrom { S : Set \u03b1 | \u2203 l u, l < u \u2227 Ioc l u = S } := by\n  simpa only [exists_prop,mem_univ,true_and] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderTopology \u03b1\n\u22a2 borel \u03b1 = MeasurableSpace.generateFrom {S | \u2203 l u, l < u \u2227 Ioc l u = S}"}, {"line": "simpa only [exists_prop,mem_univ,true_and] using\n    (@dense_univ \u03b1 _).borel_eq_generateFrom_Ioc_mem_aux (fun _ _ => mem_univ _) fun _ _ _ _ =>\n      mem_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1]", "[TopologicalSpace \u03b3] {m\u03b3 : MeasurableSpace \u03b3} [BorelSpace \u03b3]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [BorelSpace \u03b1]", "[TopologicalSpace \u03b2] {m\u03b2 : MeasurableSpace \u03b2} [BorelSpace \u03b2]", "{m\u03b4 : MeasurableSpace \u03b4}", "[LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iio x)\n\u22a2 Measurable f"}, {"line": "convert measurable_generateFrom (\u03b1 := \u03b4) _", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iio x)\n\u22a2 m\u03b1 = MeasurableSpace.generateFrom ?convert_3\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iio x)\n\u22a2 Set (Set \u03b1)\n---\ncase convert_5\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iio x)\n\u22a2 \u2200 t \u2208 ?convert_3, MeasurableSet (f \u207b\u00b9' t)"}, {"line": "\u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Iio _)", "tactic_state": "case convert_5\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Iio x)\n\u22a2 \u2200 t \u2208 range Iio, MeasurableSet (f \u207b\u00b9' t)"}, {"line": "\u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measurable_of_Ioi {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Ioi x)) : Measurable f := by\n  convert measurable_generateFrom (\u03b1 := \u03b4) _\n  \u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)\n  \u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1]", "[TopologicalSpace \u03b3] {m\u03b3 : MeasurableSpace \u03b3} [BorelSpace \u03b3]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [BorelSpace \u03b1]", "[TopologicalSpace \u03b2] {m\u03b2 : MeasurableSpace \u03b2} [BorelSpace \u03b2]", "{m\u03b4 : MeasurableSpace \u03b4}", "[LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ioi x)\n\u22a2 Measurable f"}, {"line": "convert measurable_generateFrom (\u03b1 := \u03b4) _", "tactic_state": "case h.e'_4\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ioi x)\n\u22a2 m\u03b1 = MeasurableSpace.generateFrom ?convert_3\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ioi x)\n\u22a2 Set (Set \u03b1)\n---\ncase convert_5\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ioi x)\n\u22a2 \u2200 t \u2208 ?convert_3, MeasurableSet (f \u207b\u00b9' t)"}, {"line": "\u00b7 exact BorelSpace.measurable_eq.trans (borel_eq_generateFrom_Ioi _)", "tactic_state": "case convert_5\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : OrderTopology \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Preorder \u03b1\ninst\u271d\u00b9\u00b9 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : OrderClosedTopology \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nf : \u03b4 \u2192 \u03b1\nhf : \u2200 (x : \u03b1), MeasurableSet (f \u207b\u00b9' Ioi x)\n\u22a2 \u2200 t \u2208 range Ioi, MeasurableSet (f \u207b\u00b9' t)"}, {"line": "\u00b7 rintro _ \u27e8x, rfl\u27e9; exact hf x", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem AEMeasurable.iSup {\u03b9} {\u03bc : Measure \u03b4} [Countable \u03b9] {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1}\n    (hf : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun b => \u2a06 i, f i b) \u03bc := by\n  refine \u27e8fun b \u21a6 \u2a06 i, (hf i).mk (f i) b, .iSup (fun i \u21a6 (hf i).measurable_mk), ?_\u27e9\n  filter_upwards [ae_all_iff.2 (fun i \u21a6 (hf i).ae_eq_mk)] with b hb using by simp [hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1]", "[TopologicalSpace \u03b3] {m\u03b3 : MeasurableSpace \u03b3} [BorelSpace \u03b3]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [BorelSpace \u03b1]", "[TopologicalSpace \u03b2] {m\u03b2 : MeasurableSpace \u03b2} [BorelSpace \u03b2]", "{m\u03b4 : MeasurableSpace \u03b4}", "[LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]", "[ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b1\ninst\u271d\u00b9\u2078 : OrderTopology \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderClosedTopology \u03b1\ninst\u271d\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2077 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_5\n\u03bc : Measure \u03b4\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 AEMeasurable (fun b => \u2a06 i, f i b) \u03bc"}, {"line": "refine \u27e8fun b \u21a6 \u2a06 i, (hf i).mk (f i) b, .iSup (fun i \u21a6 (hf i).measurable_mk), ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b2\u2070 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2079 : LinearOrder \u03b1\ninst\u271d\u00b9\u2078 : OrderTopology \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : Preorder \u03b1\ninst\u271d\u00b9\u2075 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u2074 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b3 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : OrderClosedTopology \u03b1\ninst\u271d\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u2078 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2077 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : OrderTopology \u03b1\ninst\u271d\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b3 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\ninst\u271d\u00b9 : SecondCountableTopology \u03b1\n\u03b9 : Sort u_5\n\u03bc : Measure \u03b4\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhf : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 (fun b => \u2a06 i, f i b) =\u1da0[ae \u03bc] fun b => sorry"}, {"line": "filter_upwards [ae_all_iff.2 (fun i \u21a6 (hf i).ae_eq_mk)] with b hb using by simp [hb]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Measurable.sSup {\u03b9} {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} {s : Set \u03b9} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) :\n    Measurable fun x => sSup ((fun i => f i x) '' s) := by\n  simp_rw [image_eq_range]\n  have : Countable s := hs.to_subtype\n  exact .iSup fun i \u21a6 hf i i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1]", "[TopologicalSpace \u03b3] {m\u03b3 : MeasurableSpace \u03b3} [BorelSpace \u03b3]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [BorelSpace \u03b1]", "[TopologicalSpace \u03b2] {m\u03b2 : MeasurableSpace \u03b2} [BorelSpace \u03b2]", "{m\u03b4 : MeasurableSpace \u03b4}", "[LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]", "[ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\ns : Set \u03b9\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\n\u22a2 Measurable fun x => sSup ((fun i => f i x) '' s)"}, {"line": "simp_rw [image_eq_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\ns : Set \u03b9\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\n\u22a2 Measurable fun x => sSup (range fun x_1 => f (\u2191x_1) x)"}, {"line": "have : Countable s := hs.to_subtype", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\ns : Set \u03b9\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\nthis : Countable \u2191s\n\u22a2 Measurable fun x => sSup (range fun x_1 => f (\u2191x_1) x)"}, {"line": "exact .iSup fun i \u21a6 hf i i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Measurable.biSup {\u03b9} (s : Set \u03b9) {f : \u03b9 \u2192 \u03b4 \u2192 \u03b1} (hs : s.Countable)\n    (hf : \u2200 i \u2208 s, Measurable (f i)) : Measurable fun b => \u2a06 i \u2208 s, f i b := by\n  haveI : Encodable s := hs.toEncodable\n  by_cases H : \u2200 i, i \u2208 s\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = \u2a06 (i : s), f i b :=\n      fun b \u21a6 cbiSup_eq_of_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    exact .iSup (fun (i : s) \u21a6 hf i i.2)\n  \u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = (\u2a06 (i : s), f i b) \u2294 sSup \u2205 :=\n      fun b \u21a6 cbiSup_eq_of_not_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact .iSup (fun (i : s) \u21a6 hf i i.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Order.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace TopologicalSpace", "scoped Topology NNReal ENNReal MeasureTheory", "Interval"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "(\u03b1)", "[TopologicalSpace \u03b1] [SecondCountableTopology \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [OpensMeasurableSpace \u03b1]", "{m\u03b4 : MeasurableSpace \u03b4}", "[Preorder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[PartialOrder \u03b1] [OrderClosedTopology \u03b1] [SecondCountableTopology \u03b1] {a b : \u03b1}", "[LinearOrder \u03b1] [OrderClosedTopology \u03b1] {a b x : \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1]", "[TopologicalSpace \u03b3] {m\u03b3 : MeasurableSpace \u03b3} [BorelSpace \u03b3]", "[TopologicalSpace \u03b1] {m\u03b1 : MeasurableSpace \u03b1} [BorelSpace \u03b1]", "[TopologicalSpace \u03b2] {m\u03b2 : MeasurableSpace \u03b2} [BorelSpace \u03b2]", "{m\u03b4 : MeasurableSpace \u03b4}", "[LinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]", "[ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] [SecondCountableTopology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\n\u22a2 Measurable fun b => \u2a06 i \u2208 s, f i b"}, {"line": "haveI : Encodable s := hs.toEncodable", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\nthis : Encodable \u2191s\n\u22a2 Measurable fun b => \u2a06 i \u2208 s, f i b"}, {"line": "by_cases H : \u2200 i, i \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\nthis : Encodable \u2191s\nH : \u2200 (i : \u03b9), i \u2208 s\n\u22a2 Measurable fun b => \u2a06 i \u2208 s, f i b\n---\ncase neg\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\nthis : Encodable \u2191s\nH : \u00ac\u2200 (i : \u03b9), i \u2208 s\n\u22a2 Measurable fun b => \u2a06 i \u2208 s, f i b"}, {"line": "\u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = \u2a06 (i : s), f i b :=\n      fun b \u21a6 cbiSup_eq_of_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    exact .iSup (fun (i : s) \u21a6 hf i i.2)", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b4 : Type u_4\ninst\u271d\u00b2\u2070 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2079 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : OrderTopology \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : Preorder \u03b1\ninst\u271d\u00b9\u2074 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : OrderClosedTopology \u03b1\ninst\u271d\u00b9\u00b9 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u2070 : LinearOrder \u03b1\ninst\u271d\u2079 : OrderClosedTopology \u03b1\ninst\u271d\u2078 : SecondCountableTopology \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\nm\u03b1 : MeasurableSpace \u03b1\ninst\u271d\u2076 : BorelSpace \u03b1\nm\u03b4 : MeasurableSpace \u03b4\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : OrderTopology \u03b1\ninst\u271d\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder \u03b1\ninst\u271d\u00b9 : OrderTopology \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u03b9 : Type u_5\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b4 \u2192 \u03b1\nhs : s.Countable\nhf : \u2200 i \u2208 s, Measurable (f i)\nthis : Encodable \u2191s\nH : \u00ac\u2200 (i : \u03b9), i \u2208 s\n\u22a2 Measurable fun b => \u2a06 i \u2208 s, f i b"}, {"line": "\u00b7 have : \u2200 b, \u2a06 i \u2208 s, f i b = (\u2a06 (i : s), f i b) \u2294 sSup \u2205 :=\n      fun b \u21a6 cbiSup_eq_of_not_forall (f := fun i \u21a6 f i b) H\n    simp only [this]\n    apply Measurable.sup _ measurable_const\n    exact .iSup (fun (i : s) \u21a6 hf i i.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPiSystem_Ioo_rat :\n    IsPiSystem (\u22c3 (a : \u211a) (b : \u211a) (_ : a < b), {Ioo (a : \u211d) (b : \u211d)}) := by\n  convert isPiSystem_Ioo ((\u2191) : \u211a \u2192 \u211d) ((\u2191) : \u211a \u2192 \u211d)\n  ext x\n  simp [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 IsPiSystem (\u22c3 a, \u22c3 b, \u22c3 (_ : a < b), {Ioo \u2191a \u2191b})"}, {"line": "convert isPiSystem_Ioo ((\u2191) : \u211a \u2192 \u211d) ((\u2191) : \u211a \u2192 \u211d)", "tactic_state": "case h.e'_2\n\u22a2 \u22c3 a, \u22c3 b, \u22c3 (_ : a < b), {Ioo \u2191a \u2191b} = {S | \u2203 l u, \u2191l < \u2191u \u2227 Ioo \u2191l \u2191u = S}"}, {"line": "ext x", "tactic_state": "case h.e'_2.h\nx : Set \u211d\n\u22a2 x \u2208 \u22c3 a, \u22c3 b, \u22c3 (_ : a < b), {Ioo \u2191a \u2191b} \u2194 x \u2208 {S | \u2203 l u, \u2191l < \u2191u \u2227 Ioo \u2191l \u2191u = S}"}, {"line": "simp [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Measurable.ennreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, Measurable (f i)) :\n    Measurable fun x => \u2211' i, f i x := by\n  simp_rw [ENNReal.tsum_eq_iSup_sum]\n  exact .iSup fun s \u21a6 s.measurable_sum fun i _ => h i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Measurable fun x => \u2211' (i : \u03b9), f i x"}, {"line": "simp_rw [ENNReal.tsum_eq_iSup_sum]", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Measurable fun x => \u2a06 s, \u2211 i \u2208 s, f i x"}, {"line": "exact .iSup fun s \u21a6 s.measurable_sum fun i _ => h i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Measurable.ennreal_tsum' {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 i, Measurable (f i)) :\n    Measurable (\u2211' i, f i) := by\n  convert Measurable.ennreal_tsum h with x\n  exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Measurable (\u2211' (i : \u03b9), f i)"}, {"line": "convert Measurable.ennreal_tsum h with x", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\nx : \u03b1\n\u22a2 (\u2211' (i : \u03b9), f i) x = \u2211' (i : \u03b9), f i x\n---\n\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Countable \u03b9"}, {"line": "exact tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Countable \u03b9"}]}
{"declaration": "theorem Measurable.nnreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650} (h : \u2200 i, Measurable (f i)) :\n    Measurable fun x => \u2211' i, f i x := by\n  simp_rw [NNReal.tsum_eq_toNNReal_tsum]\n  exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 NNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Measurable fun x => \u2211' (i : \u03b9), f i x"}, {"line": "simp_rw [NNReal.tsum_eq_toNNReal_tsum]", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 NNReal\nh : \u2200 (i : \u03b9), Measurable (f i)\n\u22a2 Measurable fun x => (\u2211' (b : \u03b9), \u2191(f b x)).toNNReal"}, {"line": "exact (Measurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AEMeasurable.ennreal_tsum {\u03b9} [Countable \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {\u03bc : Measure \u03b1}\n    (h : \u2200 i, AEMeasurable (f i) \u03bc) : AEMeasurable (fun x => \u2211' i, f i x) \u03bc := by\n  simp_rw [ENNReal.tsum_eq_iSup_sum]\n  exact .iSup fun s \u21a6 Finset.aemeasurable_sum s fun i _ => h i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\n\u03bc : Measure \u03b1\nh : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 AEMeasurable (fun x => \u2211' (i : \u03b9), f i x) \u03bc"}, {"line": "simp_rw [ENNReal.tsum_eq_iSup_sum]", "tactic_state": "\u03b1 : Type u_1\nm\u03b1 : MeasurableSpace \u03b1\n\u03b9 : Type u_5\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\n\u03bc : Measure \u03b1\nh : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 AEMeasurable (fun x => \u2a06 s, \u2211 i \u2208 s, f i x) \u03bc"}, {"line": "exact .iSup fun s \u21a6 Finset.aemeasurable_sum s fun i _ => h i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AEMeasurable.nnreal_tsum {\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {\u03b9 : Type*} [Countable \u03b9]\n    {f : \u03b9 \u2192 \u03b1 \u2192 NNReal} {\u03bc : Measure \u03b1} (h : \u2200 i : \u03b9, AEMeasurable (f i) \u03bc) :\n    AEMeasurable (fun x : \u03b1 => \u2211' i : \u03b9, f i x) \u03bc := by\n  simp_rw [NNReal.tsum_eq_toNNReal_tsum]\n  exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nx\u271d : MeasurableSpace \u03b1\n\u03b9 : Type u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 NNReal\n\u03bc : Measure \u03b1\nh : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 AEMeasurable (fun x => \u2211' (i : \u03b9), f i x) \u03bc"}, {"line": "simp_rw [NNReal.tsum_eq_toNNReal_tsum]", "tactic_state": "\u03b1 : Type u_5\nx\u271d : MeasurableSpace \u03b1\n\u03b9 : Type u_6\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 NNReal\n\u03bc : Measure \u03b1\nh : \u2200 (i : \u03b9), AEMeasurable (f i) \u03bc\n\u22a2 AEMeasurable (fun x => (\u2211' (b : \u03b9), \u2191(f b x)).toNNReal) \u03bc"}, {"line": "exact (AEMeasurable.ennreal_tsum fun i => (h i).coe_nnreal_ennreal).ennreal_toNNReal", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_measure_Icc_nhdsWithin_right' (b : \u211d) :\n    Tendsto (fun \u03b4 \u21a6 \u03bc (Icc (b - \u03b4) (b + \u03b4))) (\ud835\udcdd[>] (0 : \u211d)) (\ud835\udcdd (\u03bc {b})) := by\n  rw [Real.singleton_eq_inter_Icc]\n  apply tendsto_measure_biInter_gt (fun r hr \u21a6 nullMeasurableSet_Icc)\n  \u00b7 intro r s _rpos hrs\n    exact Icc_subset_Icc (by linarith) (by linarith)\n  \u00b7 exact \u27e81, zero_lt_one, isCompact_Icc.measure_ne_top\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/BorelSpace/Real.lean", "context": {"open": ["Set Filter MeasureTheory MeasurableSpace", "scoped Topology NNReal ENNReal", "Function (uncurry)"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort y} {s t u : Set \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1}", "{\u03b1 \u03b2 \u03b3 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {m\u03b2 : MeasurableSpace \u03b2} {m\u03b3 : MeasurableSpace \u03b3}", "(\u03bc : Measure \u211d) [IsFiniteMeasureOnCompacts \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb : \u211d\n\u22a2 Tendsto (fun \u03b4 => \u03bc (Icc (b - \u03b4) (b + \u03b4))) (nhdsWithin 0 (Ioi 0)) (nhds (\u03bc {b}))"}, {"line": "rw [Real.singleton_eq_inter_Icc]", "tactic_state": "\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb : \u211d\n\u22a2 Tendsto (fun \u03b4 => \u03bc (Icc (b - \u03b4) (b + \u03b4))) (nhdsWithin 0 (Ioi 0)) (nhds (\u03bc (\u22c2 r, \u22c2 (_ : r > 0), Icc (b - r) (b + r))))"}, {"line": "apply tendsto_measure_biInter_gt (fun r hr \u21a6 nullMeasurableSet_Icc)", "tactic_state": "case hm\n\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb : \u211d\n\u22a2 \u2200 (i j : \u211d), 0 < i \u2192 i \u2264 j \u2192 Icc (b - i) (b + i) \u2286 Icc (b - j) (b + j)\n---\ncase hf\n\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb : \u211d\n\u22a2 \u2203 r > 0, \u03bc (Icc (b - r) (b + r)) \u2260 \u22a4"}, {"line": "\u00b7 intro r s _rpos hrs\n    exact Icc_subset_Icc (by linarith) (by linarith)", "tactic_state": "case hf\n\u03bc : Measure \u211d\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nb : \u211d\n\u22a2 \u2203 r > 0, \u03bc (Icc (b - r) (b + r)) \u2260 \u22a4"}, {"line": "\u00b7 exact \u27e81, zero_lt_one, isCompact_Icc.measure_ne_top\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticSet_empty : AnalyticSet (\u2205 : Set \u03b1) := by\n  rw [AnalyticSet]\n  exact Or.inl rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 AnalyticSet \u2205"}, {"line": "rw [AnalyticSet]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 \u2205 = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = \u2205"}, {"line": "exact Or.inl rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsOpen.analyticSet_image {\u03b2 : Type*} [TopologicalSpace \u03b2] [PolishSpace \u03b2]\n    {s : Set \u03b2} (hs : IsOpen s) {f : \u03b2 \u2192 \u03b1} (f_cont : Continuous f) : AnalyticSet (f '' s) := by\n  rw [image_eq_range]\n  haveI : PolishSpace s := hs.polishSpace\n  exact analyticSet_range_of_polishSpace (f_cont.comp continuous_subtype_val)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\n\u22a2 AnalyticSet (f '' s)"}, {"line": "rw [image_eq_range]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\n\u22a2 AnalyticSet (range fun x => f \u2191x)"}, {"line": "haveI : PolishSpace s := hs.polishSpace", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_4\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PolishSpace \u03b2\ns : Set \u03b2\nhs : IsOpen s\nf : \u03b2 \u2192 \u03b1\nf_cont : Continuous f\nthis : sorry\n\u22a2 AnalyticSet (range fun x => f \u2191x)"}, {"line": "exact analyticSet_range_of_polishSpace (f_cont.comp continuous_subtype_val)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsClosed.analyticSet [PolishSpace \u03b1] {s : Set \u03b1} (hs : IsClosed s) :\n    AnalyticSet s := by\n  haveI : PolishSpace s := hs.polishSpace\n  rw [\u2190 @Subtype.range_val \u03b1 s]\n  exact analyticSet_range_of_polishSpace continuous_subtype_val\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\n\u22a2 AnalyticSet s"}, {"line": "haveI : PolishSpace s := hs.polishSpace", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : sorry\n\u22a2 AnalyticSet s"}, {"line": "rw [\u2190 @Subtype.range_val \u03b1 s]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : PolishSpace \u03b1\ns : Set \u03b1\nhs : IsClosed s\nthis : sorry\n\u22a2 AnalyticSet (range Subtype.val)"}, {"line": "exact analyticSet_range_of_polishSpace continuous_subtype_val", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticSet.measurablySeparable [T2Space \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]\n    {s t : Set \u03b1} (hs : AnalyticSet s) (ht : AnalyticSet t) (h : Disjoint s t) :\n    MeasurablySeparable s t := by\n  rw [AnalyticSet] at hs ht\n  rcases hs with (rfl | \u27e8f, f_cont, rfl\u27e9)\n  \u00b7 refine \u27e8\u2205, Subset.refl _, by simp, MeasurableSet.empty\u27e9\n  rcases ht with (rfl | \u27e8g, g_cont, rfl\u27e9)\n  \u00b7 exact \u27e8univ, subset_univ _, by simp, MeasurableSet.univ\u27e9\n  exact measurablySeparable_range_of_disjoint f_cont g_cont h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\ns t : Set \u03b1\nhs : AnalyticSet s\nht : AnalyticSet t\nh : Disjoint s t\n\u22a2 MeasurablySeparable s t"}, {"line": "rw [AnalyticSet] at hs ht", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\ns t : Set \u03b1\nhs : s = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = s\nht : t = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = t\nh : Disjoint s t\n\u22a2 MeasurablySeparable s t"}, {"line": "rcases hs with (rfl | \u27e8f, f_cont, rfl\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nt : Set \u03b1\nht : t = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = t\nh : Disjoint \u2205 t\n\u22a2 MeasurablySeparable \u2205 t\n---\ncase inr.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nt : Set \u03b1\nht : t = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = t\nf : (\u2115 \u2192 \u2115) \u2192 \u03b1\nf_cont : Continuous f\nh : Disjoint (range f) t\n\u22a2 MeasurablySeparable (range f) t"}, {"line": "\u00b7 refine \u27e8\u2205, Subset.refl _, by simp, MeasurableSet.empty\u27e9", "tactic_state": "case inr.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nt : Set \u03b1\nht : t = \u2205 \u2228 \u2203 f, Continuous f \u2227 range f = t\nf : (\u2115 \u2192 \u2115) \u2192 \u03b1\nf_cont : Continuous f\nh : Disjoint (range f) t\n\u22a2 MeasurablySeparable (range f) t"}, {"line": "rcases ht with (rfl | \u27e8g, g_cont, rfl\u27e9)", "tactic_state": "case inr.intro.intro.inl\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nf : (\u2115 \u2192 \u2115) \u2192 \u03b1\nf_cont : Continuous f\nh : Disjoint (range f) \u2205\n\u22a2 MeasurablySeparable (range f) \u2205\n---\ncase inr.intro.intro.inr.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nf : (\u2115 \u2192 \u2115) \u2192 \u03b1\nf_cont : Continuous f\ng : (\u2115 \u2192 \u2115) \u2192 \u03b1\ng_cont : Continuous g\nh : Disjoint (range f) (range g)\n\u22a2 MeasurablySeparable (range f) (range g)"}, {"line": "\u00b7 exact \u27e8univ, subset_univ _, by simp, MeasurableSet.univ\u27e9", "tactic_state": "case inr.intro.intro.inr.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : T2Space \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nf : (\u2115 \u2192 \u2115) \u2192 \u03b1\nf_cont : Continuous f\ng : (\u2115 \u2192 \u2115) \u2192 \u03b1\ng_cont : Continuous g\nh : Disjoint (range f) (range g)\n\u22a2 MeasurablySeparable (range f) (range g)"}, {"line": "exact measurablySeparable_range_of_disjoint f_cont g_cont h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.map_borel_eq {X Y : Type*} [TopologicalSpace X] [PolishSpace X]\n    [TopologicalSpace Y] [T0Space Y] [SecondCountableTopology Y] {f : X \u2192 Y} (hf : Continuous f)\n    (hsurj : Surjective f) : MeasurableSpace.map f (borel X) = borel Y := by\n  borelize X\n  exact hf.map_eq_borel hsurj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory", "MeasurableSpace"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]", "{X Y Z \u03b2 : Type*} [MeasurableSpace X] [StandardBorelSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_8\nY : Type u_9\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : PolishSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : T0Space Y\ninst\u271d : SecondCountableTopology Y\nf : X \u2192 Y\nhf : Continuous f\nhsurj : Surjective f\n\u22a2 MeasurableSpace.map f (borel X) = borel Y"}, {"line": "borelize X", "tactic_state": "X : Type u_8\nY : Type u_9\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : PolishSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : T0Space Y\ninst\u271d : SecondCountableTopology Y\nf : X \u2192 Y\nhf : Continuous f\nhsurj : Surjective f\nthis\u271d\u00b9 : MeasurableSpace X := sorry\nthis\u271d : sorry\n\u22a2 MeasurableSpace.map f (borel X) = borel Y"}, {"line": "exact hf.map_eq_borel hsurj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.MeasurableSet.image_of_continuousOn_injOn [OpensMeasurableSpace \u03b2]\n    [t\u03b3 : TopologicalSpace \u03b3] [PolishSpace \u03b3] [MeasurableSpace \u03b3] [BorelSpace \u03b3]\n    (hs : MeasurableSet s)\n    (f_cont : ContinuousOn f s) (f_inj : InjOn f s) : MeasurableSet (f '' s) := by\n  obtain \u27e8t', t't, t'_polish, s_closed, _\u27e9 :\n      \u2203 t' : TopologicalSpace \u03b3, t' \u2264 t\u03b3 \u2227 @PolishSpace \u03b3 t' \u2227 IsClosed[t'] s \u2227 IsOpen[t'] s :=\n    hs.isClopenable\n  exact\n    @IsClosed.measurableSet_image_of_continuousOn_injOn \u03b3 t' t'_polish \u03b2 _ _ _ _ s s_closed f\n      (f_cont.mono_dom t't) f_inj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Constructions/Polish/Basic.lean", "context": {"open": ["Set Function PolishSpace PiNat TopologicalSpace Bornology Metric Filter Topology MeasureTheory", "MeasurableSpace"], "variables": ["(\u03b1 : Type*)", "{\u03b1}", "[MeasurableSpace \u03b1]", "{\u03b2 : Type*} [MeasurableSpace \u03b2]", "{\u03b9 : Type*}", "[TopologicalSpace \u03b1]", "{X Y Z \u03b2 : Type*} [MeasurableSpace X] [StandardBorelSpace X]", "{\u03b3 : Type*}", "{\u03b1 \u03b2 : Type*} [MeasurableSpace \u03b2]", "[t\u03b2 : TopologicalSpace \u03b2] [T2Space \u03b2] [MeasurableSpace \u03b1] {s : Set \u03b3} {f : \u03b3 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_8\n\u03b2 : Type u_10\ninst\u271d\u2075 : MeasurableSpace \u03b2\nt\u03b2 : TopologicalSpace \u03b2\ninst\u271d\u2074 : T2Space \u03b2\ns : Set \u03b3\nf : \u03b3 \u2192 \u03b2\ninst\u271d\u00b3 : OpensMeasurableSpace \u03b2\nt\u03b3 : TopologicalSpace \u03b3\ninst\u271d\u00b2 : PolishSpace \u03b3\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : BorelSpace \u03b3\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : InjOn f s\n\u22a2 MeasurableSet (f '' s)"}, {"line": "obtain \u27e8t', t't, t'_polish, s_closed, _\u27e9 :\n      \u2203 t' : TopologicalSpace \u03b3, t' \u2264 t\u03b3 \u2227 @PolishSpace \u03b3 t' \u2227 IsClosed[t'] s \u2227 IsOpen[t'] s :=\n    hs.isClopenable", "tactic_state": "case intro.intro.intro.intro\n\u03b3 : Type u_8\n\u03b2 : Type u_10\ninst\u271d\u2075 : MeasurableSpace \u03b2\nt\u03b2 : TopologicalSpace \u03b2\ninst\u271d\u2074 : T2Space \u03b2\ns : Set \u03b3\nf : \u03b3 \u2192 \u03b2\ninst\u271d\u00b3 : OpensMeasurableSpace \u03b2\nt\u03b3 : TopologicalSpace \u03b3\ninst\u271d\u00b2 : PolishSpace \u03b3\ninst\u271d\u00b9 : MeasurableSpace \u03b3\ninst\u271d : BorelSpace \u03b3\nhs : MeasurableSet s\nf_cont : ContinuousOn f s\nf_inj : InjOn f s\nt' : TopologicalSpace \u03b3\nt't : t' \u2264 t\u03b3\nt'_polish : PolishSpace \u03b3\ns_closed : sorry\nright\u271d : sorry\n\u22a2 MeasurableSet (f '' s)"}, {"line": "exact\n    @IsClosed.measurableSet_image_of_continuousOn_injOn \u03b3 t' t'_polish \u03b2 _ _ _ _ s s_closed f\n      (f_cont.mono_dom t't) f_inj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hlast' (i : Fin N.succ) (h : 1 \u2264 \u03c4) : a.r (last N) \u2264 \u03c4 * a.r i := by\n  rcases lt_or_le i (last N) with (H | H)\n  \u00b7 exact (a.hlast i H).2\n  \u00b7 have : i = last N := top_le_iff.1 H\n    rw [this]\n    exact le_mul_of_one_le_left (a.rpos _).le h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Besicovitch.lean", "context": {"open": ["Metric Set Filter Fin MeasureTheory TopologicalSpace", "scoped Topology ENNReal MeasureTheory NNReal", "Lean Meta Qq"], "variables": ["{\u03b1 : Type*} [MetricSpace \u03b1] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig \u03b1 N \u03c4)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.445\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na : sorry\nN : \u2115\n\u03c4 : \u211d\ni : Fin N.succ\nh : 1 \u2264 \u03c4\n\u22a2 sorry \u2264 \u03c4 * sorry"}, {"line": "rcases lt_or_le i (last N) with (H | H)", "tactic_state": "case inl\nSatelliteConfig : ?m.445\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na : sorry\nN : \u2115\n\u03c4 : \u211d\ni : Fin N.succ\nh : 1 \u2264 \u03c4\nH : i < last N\n\u22a2 sorry \u2264 \u03c4 * sorry\n---\ncase inr\nSatelliteConfig : ?m.445\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na : sorry\nN : \u2115\n\u03c4 : \u211d\ni : Fin N.succ\nh : 1 \u2264 \u03c4\nH : last N \u2264 i\n\u22a2 sorry \u2264 \u03c4 * sorry"}, {"line": "\u00b7 exact (a.hlast i H).2", "tactic_state": "case inr\nSatelliteConfig : ?m.445\n\u03b1 : Type u_1\ninst\u271d : MetricSpace \u03b1\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na : sorry\nN : \u2115\n\u03c4 : \u211d\ni : Fin N.succ\nh : 1 \u2264 \u03c4\nH : last N \u2264 i\n\u22a2 sorry \u2264 \u03c4 * sorry"}, {"line": "\u00b7 have : i = last N := top_le_iff.1 H\n    rw [this]\n    exact le_mul_of_one_le_left (a.rpos _).le h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_tendsto_rnDeriv (\u03c1 \u03bc : Measure \u03b2) [IsLocallyFiniteMeasure \u03bc] [IsLocallyFiniteMeasure \u03c1] :\n    \u2200\u1d50 x \u2202\u03bc,\n      Tendsto (fun r => \u03c1 (closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u03c1.rnDeriv \u03bc x)) := by\n  filter_upwards [VitaliFamily.ae_tendsto_rnDeriv (Besicovitch.vitaliFamily \u03bc) \u03c1] with x hx\n  exact hx.comp (tendsto_filterAt \u03bc x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Besicovitch.lean", "context": {"open": ["Metric Set Filter Fin MeasureTheory TopologicalSpace", "scoped Topology ENNReal MeasureTheory NNReal", "Lean Meta Qq", "TauPackage", "scoped NNReal"], "variables": ["{\u03b1 : Type*} [MetricSpace \u03b1] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig \u03b1 N \u03c4)", "{\u03b1 : Type*} [MetricSpace \u03b1] {\u03b2 : Type u}", "[Nonempty \u03b2] (p : TauPackage \u03b2 \u03b1)", "[SecondCountableTopology \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[HasBesicovitchCovering \u03b1]", "[MetricSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2] [SecondCountableTopology \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2077 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2075 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : HasBesicovitchCovering \u03b1\ninst\u271d\u00b9\u2070 : MetricSpace \u03b2\u271d\ninst\u271d\u2079 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2078 : BorelSpace \u03b2\u271d\ninst\u271d\u2077 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2076 : Nonempty \u03b2\ninst\u271d\u2075 : MetricSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : BorelSpace \u03b2\ninst\u271d\u00b2 : SecondCountableTopology \u03b2\n\u03c1 \u03bc : Measure \u03b2\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03c1\n\u22a2 \u2200\u1d50 (x : \u03b2) \u2202\u03bc,\n    Tendsto (fun r => \u03c1 (closedBall x r) / \u03bc (closedBall x r)) (nhdsWithin 0 (Ioi 0)) (nhds (\u03c1.rnDeriv \u03bc x))"}, {"line": "filter_upwards [VitaliFamily.ae_tendsto_rnDeriv (Besicovitch.vitaliFamily \u03bc) \u03c1] with x hx", "tactic_state": "case h\nSatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2077 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2075 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u2074 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : HasBesicovitchCovering \u03b1\ninst\u271d\u00b9\u2070 : MetricSpace \u03b2\u271d\ninst\u271d\u2079 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2078 : BorelSpace \u03b2\u271d\ninst\u271d\u2077 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2076 : Nonempty \u03b2\ninst\u271d\u2075 : MetricSpace \u03b2\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : BorelSpace \u03b2\ninst\u271d\u00b2 : SecondCountableTopology \u03b2\n\u03c1 \u03bc : Measure \u03b2\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : IsLocallyFiniteMeasure \u03c1\nx : \u03b2\nhx : Tendsto (fun a => \u03c1 a / \u03bc a) (sorry.filterAt x) (nhds (\u03c1.rnDeriv \u03bc x))\n\u22a2 Tendsto (fun r => \u03c1 (closedBall x r) / \u03bc (closedBall x r)) (nhdsWithin 0 (Ioi 0)) (nhds (\u03c1.rnDeriv \u03bc x))"}, {"line": "exact hx.comp (tendsto_filterAt \u03bc x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_tendsto_measure_inter_div_of_measurableSet (\u03bc : Measure \u03b2) [IsLocallyFiniteMeasure \u03bc]\n    {s : Set \u03b2} (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202\u03bc,\n      Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0)\n        (\ud835\udcdd (s.indicator 1 x)) := by\n  filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet\n      (Besicovitch.vitaliFamily \u03bc) hs]\n  intro x hx\n  exact hx.comp (tendsto_filterAt \u03bc x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Besicovitch.lean", "context": {"open": ["Metric Set Filter Fin MeasureTheory TopologicalSpace", "scoped Topology ENNReal MeasureTheory NNReal", "Lean Meta Qq", "TauPackage", "scoped NNReal"], "variables": ["{\u03b1 : Type*} [MetricSpace \u03b1] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig \u03b1 N \u03c4)", "{\u03b1 : Type*} [MetricSpace \u03b1] {\u03b2 : Type u}", "[Nonempty \u03b2] (p : TauPackage \u03b2 \u03b1)", "[SecondCountableTopology \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[HasBesicovitchCovering \u03b1]", "[MetricSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2] [SecondCountableTopology \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2074 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : HasBesicovitchCovering \u03b1\ninst\u271d\u2079 : MetricSpace \u03b2\u271d\ninst\u271d\u2078 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2077 : BorelSpace \u03b2\u271d\ninst\u271d\u2076 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2075 : Nonempty \u03b2\ninst\u271d\u2074 : MetricSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : SecondCountableTopology \u03b2\n\u03bc : Measure \u03b2\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u03b2) \u2202\u03bc,\n    Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (nhdsWithin 0 (Ioi 0)) (nhds (s.indicator 1 x))"}, {"line": "filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet\n      (Besicovitch.vitaliFamily \u03bc) hs]", "tactic_state": "case h\nSatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2074 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : HasBesicovitchCovering \u03b1\ninst\u271d\u2079 : MetricSpace \u03b2\u271d\ninst\u271d\u2078 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2077 : BorelSpace \u03b2\u271d\ninst\u271d\u2076 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2075 : Nonempty \u03b2\ninst\u271d\u2074 : MetricSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : SecondCountableTopology \u03b2\n\u03bc : Measure \u03b2\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b2\nhs : MeasurableSet s\n\u22a2 \u2200 (a : \u03b2),\n    Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) (sorry.filterAt a) (nhds (s.indicator 1 a)) \u2192\n      Tendsto (fun r => \u03bc (s \u2229 closedBall a r) / \u03bc (closedBall a r)) (nhdsWithin 0 (Ioi 0)) (nhds (s.indicator 1 a))"}, {"line": "intro x hx", "tactic_state": "case h\nSatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2074 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : HasBesicovitchCovering \u03b1\ninst\u271d\u2079 : MetricSpace \u03b2\u271d\ninst\u271d\u2078 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2077 : BorelSpace \u03b2\u271d\ninst\u271d\u2076 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2075 : Nonempty \u03b2\ninst\u271d\u2074 : MetricSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : SecondCountableTopology \u03b2\n\u03bc : Measure \u03b2\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b2\nhs : MeasurableSet s\nx : \u03b2\nhx : Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) (sorry.filterAt x) (nhds (s.indicator 1 x))\n\u22a2 Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (nhdsWithin 0 (Ioi 0)) (nhds (s.indicator 1 x))"}, {"line": "exact hx.comp (tendsto_filterAt \u03bc x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_tendsto_measure_inter_div (\u03bc : Measure \u03b2) [IsLocallyFiniteMeasure \u03bc] (s : Set \u03b2) :\n    \u2200\u1d50 x \u2202\u03bc.restrict s,\n      Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0) (\ud835\udcdd 1) := by\n  filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div (Besicovitch.vitaliFamily \u03bc) s] with x\n    hx using hx.comp (tendsto_filterAt \u03bc x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Besicovitch.lean", "context": {"open": ["Metric Set Filter Fin MeasureTheory TopologicalSpace", "scoped Topology ENNReal MeasureTheory NNReal", "Lean Meta Qq", "TauPackage", "scoped NNReal"], "variables": ["{\u03b1 : Type*} [MetricSpace \u03b1] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig \u03b1 N \u03c4)", "{\u03b1 : Type*} [MetricSpace \u03b1] {\u03b2 : Type u}", "[Nonempty \u03b2] (p : TauPackage \u03b2 \u03b1)", "[SecondCountableTopology \u03b1] [MeasurableSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[HasBesicovitchCovering \u03b1]", "[MetricSpace \u03b2] [MeasurableSpace \u03b2] [BorelSpace \u03b2] [SecondCountableTopology \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.6585\nTauPackage : ?m.6613\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9\u2076 : MetricSpace \u03b1\u271d\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u03b1 : Type u_2\ninst\u271d\u00b9\u2075 : MetricSpace \u03b1\n\u03b2\u271d : Type u\ninst\u271d\u00b9\u2074 : Nonempty \u03b2\u271d\np : sorry\ninst\u271d\u00b9\u00b3 : SecondCountableTopology \u03b1\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9\u2070 : HasBesicovitchCovering \u03b1\ninst\u271d\u2079 : MetricSpace \u03b2\u271d\ninst\u271d\u2078 : MeasurableSpace \u03b2\u271d\ninst\u271d\u2077 : BorelSpace \u03b2\u271d\ninst\u271d\u2076 : SecondCountableTopology \u03b2\u271d\n\u03b2 : Type u\ninst\u271d\u2075 : Nonempty \u03b2\ninst\u271d\u2074 : MetricSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b2 : BorelSpace \u03b2\ninst\u271d\u00b9 : SecondCountableTopology \u03b2\n\u03bc : Measure \u03b2\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b2\n\u22a2 \u2200\u1d50 (x : \u03b2) \u2202\u03bc.restrict s,\n    Tendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (nhdsWithin 0 (Ioi 0)) (nhds 1)"}, {"line": "filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div (Besicovitch.vitaliFamily \u03bc) s] with x\n    hx using hx.comp (tendsto_filterAt \u03bc x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem centerAndRescale_center : a.centerAndRescale.c (last N) = 0 := by\n  simp [SatelliteConfig.centerAndRescale]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean", "context": {"open": ["Metric Set Module MeasureTheory Filter Fin", "scoped ENNReal Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig E N \u03c4)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.719\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u22a2 sorry = 0"}, {"line": "simp [SatelliteConfig.centerAndRescale]", "tactic_state": "SatelliteConfig : ?m.719\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem centerAndRescale_radius {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig E N \u03c4) :\n    a.centerAndRescale.r (last N) = 1 := by\n  simp [SatelliteConfig.centerAndRescale, inv_mul_cancel\u2080 (a.rpos _).ne']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/BesicovitchVectorSpace.lean", "context": {"open": ["Metric Set Module MeasureTheory Filter Fin", "scoped ENNReal Topology"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "[NormedSpace \u211d E] {N : \u2115} {\u03c4 : \u211d} (a : SatelliteConfig E N \u03c4)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "SatelliteConfig : ?m.719\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na\u271d : sorry\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u22a2 sorry = 1"}, {"line": "simp [SatelliteConfig.centerAndRescale, inv_mul_cancel\u2080 (a.rpos _).ne']", "tactic_state": "SatelliteConfig : ?m.719\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nN\u271d : \u2115\n\u03c4\u271d : \u211d\na\u271d : sorry\nN : \u2115\n\u03c4 : \u211d\na : sorry\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem ae_tendsto_measure_inter_div (S : Set \u03b1) (K : \u211d) : \u2200\u1d50 x \u2202\u03bc.restrict S,\n    \u2200 {\u03b9 : Type*} {l : Filter \u03b9} (w : \u03b9 \u2192 \u03b1) (\u03b4 : \u03b9 \u2192 \u211d) (_ : Tendsto \u03b4 l (\ud835\udcdd[>] 0))\n      (_ : \u2200\u1da0 j in l, x \u2208 closedBall (w j) (K * \u03b4 j)),\n      Tendsto (fun j => \u03bc (S \u2229 closedBall (w j) (\u03b4 j)) / \u03bc (closedBall (w j) (\u03b4 j))) l (\ud835\udcdd 1) := by\n  filter_upwards [(vitaliFamily \u03bc K).ae_tendsto_measure_inter_div S] with x hx \u03b9 l w \u03b4 \u03b4lim\n    xmem using hx.comp (tendsto_closedBall_filterAt \u03bc _ _ \u03b4lim xmem)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/DensityTheorem.lean", "context": {"open": ["Set Filter Metric MeasureTheory TopologicalSpace", "scoped NNReal Topology", "scoped Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)", "[SecondCountableTopology \u03b1] [BorelSpace \u03b1] [IsLocallyFiniteMeasure \u03bc]", "[SecondCountableTopology \u03b1] [BorelSpace \u03b1] [IsLocallyFiniteMeasure \u03bc] {E : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : PseudoMetricSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : BorelSpace \u03b1\ninst\u271d\u00b3 : IsLocallyFiniteMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nS : Set \u03b1\nK : \u211d\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict S,\n    \u2200 {\u03b9 : Type u_3} {l : Filter \u03b9} (w : \u03b9 \u2192 \u03b1) (\u03b4 : \u03b9 \u2192 \u211d),\n      Tendsto \u03b4 l (nhdsWithin 0 (Ioi 0)) \u2192\n        (\u2200\u1da0 (j : \u03b9) in l, x \u2208 closedBall (w j) (K * \u03b4 j)) \u2192\n          Tendsto (fun j => \u03bc (S \u2229 closedBall (w j) (\u03b4 j)) / \u03bc (closedBall (w j) (\u03b4 j))) l (nhds 1)"}, {"line": "filter_upwards [(vitaliFamily \u03bc K).ae_tendsto_measure_inter_div S] with x hx \u03b9 l w \u03b4 \u03b4lim\n    xmem using hx.comp (tendsto_closedBall_filterAt \u03bc _ _ \u03b4lim xmem)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_tendsto_average_norm_sub {f : \u03b1 \u2192 E} (hf : LocallyIntegrable f \u03bc) (K : \u211d) : \u2200\u1d50 x \u2202\u03bc,\n    \u2200 {\u03b9 : Type*} {l : Filter \u03b9} (w : \u03b9 \u2192 \u03b1) (\u03b4 : \u03b9 \u2192 \u211d) (_ : Tendsto \u03b4 l (\ud835\udcdd[>] 0))\n      (_ : \u2200\u1da0 j in l, x \u2208 closedBall (w j) (K * \u03b4 j)),\n      Tendsto (fun j => \u2a0d y in closedBall (w j) (\u03b4 j), \u2016f y - f x\u2016 \u2202\u03bc) l (\ud835\udcdd 0) := by\n  filter_upwards [(vitaliFamily \u03bc K).ae_tendsto_average_norm_sub hf] with x hx \u03b9 l w \u03b4 \u03b4lim\n    xmem using hx.comp (tendsto_closedBall_filterAt \u03bc _ _ \u03b4lim xmem)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/DensityTheorem.lean", "context": {"open": ["Set Filter Metric MeasureTheory TopologicalSpace", "scoped NNReal Topology", "scoped Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1)", "[SecondCountableTopology \u03b1] [BorelSpace \u03b1] [IsLocallyFiniteMeasure \u03bc]", "[SecondCountableTopology \u03b1] [BorelSpace \u03b1] [IsLocallyFiniteMeasure \u03bc] {E : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : PseudoMetricSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u2075 : SecondCountableTopology \u03b1\ninst\u271d\u2074 : BorelSpace \u03b1\ninst\u271d\u00b3 : IsLocallyFiniteMeasure \u03bc\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nE : Type u_2\nf : \u03b1 \u2192 E\nhf : sorry\nK : \u211d\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc,\n    \u2200 {\u03b9 : Type u_3} {l : Filter \u03b9} (w : \u03b9 \u2192 \u03b1) (\u03b4 : \u03b9 \u2192 \u211d) (x_1 : Tendsto \u03b4 l (nhdsWithin 0 (Ioi 0)))\n      (x_2 : \u2200\u1da0 (j : \u03b9) in l, x \u2208 closedBall (w j) (K * \u03b4 j)),\n      Tendsto (fun j => \u2a0d (y : \u03b1) in closedBall (w j) (\u03b4 j), \u2016sorry\u2016 \u2202\u03bc) l (nhds 0)"}, {"line": "filter_upwards [(vitaliFamily \u03bc K).ae_tendsto_average_norm_sub hf] with x hx \u03b9 l w \u03b4 \u03b4lim\n    xmem using hx.comp (tendsto_closedBall_filterAt \u03bc _ _ \u03b4lim xmem)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_eventually_measure_pos [SecondCountableTopology \u03b1] :\n    \u2200\u1d50 x \u2202\u03bc, \u2200\u1da0 a in v.filterAt x, 0 < \u03bc a := by\n  set s := {x | \u00ac\u2200\u1da0 a in v.filterAt x, 0 < \u03bc a} with hs\n  simp -zeta only [not_lt, not_eventually, nonpos_iff_eq_zero] at hs\n  change \u03bc s = 0\n  let f : \u03b1 \u2192 Set (Set \u03b1) := fun _ => {a | \u03bc a = 0}\n  have h : v.FineSubfamilyOn f s := by\n    intro x hx \u03b5 \u03b5pos\n    rw [hs] at hx\n    simp only [frequently_filterAt_iff] at hx\n    simp only [exists_prop] at hx\n    simp only [gt_iff_lt] at hx\n    simp only [mem_setOf_eq] at hx\n    rcases hx \u03b5 \u03b5pos with \u27e8a, a_sets, ax, \u03bca\u27e9\n    exact \u27e8a, \u27e8a_sets, \u03bca\u27e9, ax\u27e9\n  refine le_antisymm ?_ bot_le\n  calc\n    \u03bc s \u2264 \u2211' x : h.index, \u03bc (h.covering x) := h.measure_le_tsum\n    _ = \u2211' x : h.index, 0 := by congr; ext1 x; exact h.covering_mem x.2\n    _ = 0 := by simp only [tsum_zero, add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Differentiation.lean", "context": {"open": ["MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure", "scoped Filter ENNReal MeasureTheory NNReal Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a"}, {"line": "set s := {x | \u00ac\u2200\u1da0 a in v.filterAt x, 0 < \u03bc a} with hs", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set ?m.845 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a"}, {"line": "simp -zeta only [not_lt, not_eventually, nonpos_iff_eq_zero] at hs", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set ?m.845 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a"}, {"line": "change \u03bc s = 0", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set \u03b1 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}\n\u22a2 \u03bc s = 0"}, {"line": "let f : \u03b1 \u2192 Set (Set \u03b1) := fun _ => {a | \u03bc a = 0}", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set \u03b1 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03bc a = 0}\n\u22a2 \u03bc s = 0"}, {"line": "have h : v.FineSubfamilyOn f s := sorry", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set \u03b1 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03bc a = 0}\nh : sorry\n\u22a2 \u03bc s = 0"}, {"line": "refine le_antisymm ?_ bot_le", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : SecondCountableTopology \u03b1\ns : Set \u03b1 := {x | \u00ac\u2200\u1da0 (a : Set \u03b1) in sorry, 0 < \u03bc a}\nhs : s = {x | \u2203\u1da0 (x : Set \u03b1) in sorry, \u03bc x = 0}\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03bc a = 0}\nh : sorry\n\u22a2 \u03bc s \u2264 0"}, {"line": "calc\n    \u03bc s \u2264 \u2211' x : h.index, \u03bc (h.covering x) := h.measure_le_tsum\n    _ = \u2211' x : h.index, 0 := by congr; ext1 x; exact h.covering_mem x.2\n    _ = 0 := by simp only [tsum_zero, add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_le_of_frequently_le [SecondCountableTopology \u03b1] [BorelSpace \u03b1] {\u03c1 : Measure \u03b1}\n    (\u03bd : Measure \u03b1) [IsLocallyFiniteMeasure \u03bd] (h\u03c1 : \u03c1 \u226a \u03bc) (s : Set \u03b1)\n    (hs : \u2200 x \u2208 s, \u2203\u1da0 a in v.filterAt x, \u03c1 a \u2264 \u03bd a) : \u03c1 s \u2264 \u03bd s := by\n  -- this follows from a covering argument using the sets satisfying `\u03c1 a \u2264 \u03bd a`.\n  apply ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b5pos _ => ?_\n  obtain \u27e8U, sU, U_open, \u03bdU\u27e9 : \u2203 (U : Set \u03b1), s \u2286 U \u2227 IsOpen U \u2227 \u03bd U \u2264 \u03bd s + \u03b5 :=\n    exists_isOpen_le_add s \u03bd (ENNReal.coe_pos.2 \u03b5pos).ne'\n  let f : \u03b1 \u2192 Set (Set \u03b1) := fun _ => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}\n  have h : v.FineSubfamilyOn f s := by\n    apply v.fineSubfamilyOn_of_frequently f s fun x hx => ?_\n    have :=\n      (hs x hx).and_eventually\n        ((v.eventually_filterAt_mem_setsAt x).and\n          (v.eventually_filterAt_subset_of_nhds (U_open.mem_nhds (sU hx))))\n    apply Frequently.mono this\n    rintro a \u27e8\u03c1a, _, aU\u27e9\n    exact \u27e8\u03c1a, aU\u27e9\n  haveI : Encodable h.index := h.index_countable.toEncodable\n  calc\n    \u03c1 s \u2264 \u2211' x : h.index, \u03c1 (h.covering x) := h.measure_le_tsum_of_absolutelyContinuous h\u03c1\n    _ \u2264 \u2211' x : h.index, \u03bd (h.covering x) := ENNReal.tsum_le_tsum fun x => (h.covering_mem x.2).1\n    _ = \u03bd (\u22c3 x : h.index, h.covering x) := by\n      rw [measure_iUnion h.covering_disjoint_subtype fun i => h.measurableSet_u i.2]\n    _ \u2264 \u03bd U := (measure_mono (iUnion_subset fun i => (h.covering_mem i.2).2))\n    _ \u2264 \u03bd s + \u03b5 := \u03bdU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Differentiation.lean", "context": {"open": ["MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure", "scoped Filter ENNReal MeasureTheory NNReal Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u22a2 \u03c1 s \u2264 \u03bd s"}, {"line": "apply ENNReal.le_of_forall_pos_le_add fun \u03b5 \u03b5pos _ => ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nx\u271d : \u03bd s < \u22a4\n\u22a2 \u03c1 s \u2264 \u03bd s + \u2191\u03b5"}, {"line": "obtain \u27e8U, sU, U_open, \u03bdU\u27e9 : \u2203 (U : Set \u03b1), s \u2286 U \u2227 IsOpen U \u2227 \u03bd U \u2264 \u03bd s + \u03b5 :=\n    exists_isOpen_le_add s \u03bd (ENNReal.coe_pos.2 \u03b5pos).ne'", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nx\u271d : \u03bd s < \u22a4\nU : Set \u03b1\nsU : s \u2286 U\nU_open : sorry\n\u03bdU : \u03bd U \u2264 \u03bd s + \u2191\u03b5\n\u22a2 \u03c1 s \u2264 \u03bd s + \u2191\u03b5"}, {"line": "let f : \u03b1 \u2192 Set (Set \u03b1) := fun _ => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nx\u271d : \u03bd s < \u22a4\nU : Set \u03b1\nsU : s \u2286 U\nU_open : sorry\n\u03bdU : \u03bd U \u2264 \u03bd s + \u2191\u03b5\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}\n\u22a2 \u03c1 s \u2264 \u03bd s + \u2191\u03b5"}, {"line": "have h : v.FineSubfamilyOn f s := sorry", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nx\u271d : \u03bd s < \u22a4\nU : Set \u03b1\nsU : s \u2286 U\nU_open : sorry\n\u03bdU : \u03bd U \u2264 \u03bd s + \u2191\u03b5\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}\nh : sorry\n\u22a2 \u03c1 s \u2264 \u03bd s + \u2191\u03b5"}, {"line": "haveI : Encodable h.index := h.index_countable.toEncodable", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\n\u03c1 \u03bd : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bd\nh\u03c1 : \u03c1.AbsolutelyContinuous \u03bc\ns : Set \u03b1\nhs : \u2200 x \u2208 s, \u2203\u1da0 (a : Set \u03b1) in sorry, \u03c1 a \u2264 \u03bd a\n\u03b5 : NNReal\n\u03b5pos : 0 < \u03b5\nx\u271d : \u03bd s < \u22a4\nU : Set \u03b1\nsU : s \u2286 U\nU_open : sorry\n\u03bdU : \u03bd U \u2264 \u03bd s + \u2191\u03b5\nf : \u03b1 \u2192 Set (Set \u03b1) := fun x => {a | \u03c1 a \u2264 \u03bd a \u2227 a \u2286 U}\nh : sorry\nthis : Encodable sorry\n\u22a2 \u03c1 s \u2264 \u03bd s + \u2191\u03b5"}, {"line": "calc\n    \u03c1 s \u2264 \u2211' x : h.index, \u03c1 (h.covering x) := h.measure_le_tsum_of_absolutelyContinuous h\u03c1\n    _ \u2264 \u2211' x : h.index, \u03bd (h.covering x) := ENNReal.tsum_le_tsum fun x => (h.covering_mem x.2).1\n    _ = \u03bd (\u22c3 x : h.index, h.covering x) := by\n      rw [measure_iUnion h.covering_disjoint_subtype fun i => h.measurableSet_u i.2]\n    _ \u2264 \u03bd U := (measure_mono (iUnion_subset fun i => (h.covering_mem i.2).2))\n    _ \u2264 \u03bd s + \u03b5 := \u03bdU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_tendsto_measure_inter_div_of_measurableSet {s : Set \u03b1} (hs : MeasurableSet s) :\n    \u2200\u1d50 x \u2202\u03bc, Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) (v.filterAt x) (\ud835\udcdd (s.indicator 1 x)) := by\n  haveI : IsLocallyFiniteMeasure (\u03bc.restrict s) :=\n    isLocallyFiniteMeasure_of_le restrict_le_self\n  filter_upwards [ae_tendsto_rnDeriv v (\u03bc.restrict s), rnDeriv_restrict_self \u03bc hs]\n  intro x hx h'x\n  simpa only [h'x,restrict_apply' hs,inter_comm] using hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Covering/Differentiation.lean", "context": {"open": ["MeasureTheory Metric Set Filter TopologicalSpace MeasureTheory.Measure", "scoped Filter ENNReal MeasureTheory NNReal Topology"], "variables": ["{\u03b1 : Type*} [PseudoMetricSpace \u03b1] {m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "[SecondCountableTopology \u03b1] [BorelSpace \u03b1] [IsLocallyFiniteMeasure \u03bc] {\u03c1 : Measure \u03b1}", "(h\u03c1 : \u03c1 \u226a \u03bc)", "(\u03c1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) sorry (nhds (s.indicator 1 x))"}, {"line": "haveI : IsLocallyFiniteMeasure (\u03bc.restrict s) :=\n    isLocallyFiniteMeasure_of_le restrict_le_self", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nthis : sorry\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) sorry (nhds (s.indicator 1 x))"}, {"line": "filter_upwards [ae_tendsto_rnDeriv v (\u03bc.restrict s), rnDeriv_restrict_self \u03bc hs]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nthis : sorry\n\u22a2 \u2200 a \u2208 ?m.6876,\n    (\u03bc.restrict s).rnDeriv \u03bc a = s.indicator 1 a \u2192 Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) sorry (nhds (s.indicator 1 a))"}, {"line": "intro x hx h'x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : PseudoMetricSpace \u03b1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : SecondCountableTopology \u03b1\ninst\u271d\u00b9 : BorelSpace \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nthis : sorry\nx : \u03b1\nhx : x \u2208 ?m.6876\nh'x : (\u03bc.restrict s).rnDeriv \u03bc x = s.indicator 1 x\n\u22a2 Tendsto (fun a => \u03bc (s \u2229 a) / \u03bc a) sorry (nhds (s.indicator 1 x))"}, {"line": "simpa only [h'x,restrict_apply' hs,inter_comm] using hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeFn_le (f g : Lp E p \u03bc) : f \u2264\u1d50[\u03bc] g \u2194 f \u2264 g := by\n  rw [\u2190 Subtype.coe_le_coe]\n  rw [\u2190 AEEqFun.coeFn_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpOrder.lean", "context": {"open": ["TopologicalSpace MeasureTheory", "scoped ENNReal"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {p : \u211d\u22650\u221e}", "[NormedAddCommGroup E]", "[PartialOrder E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : PartialOrder E\nf g : \u21a5(Lp E p \u03bc)\n\u22a2 \u2191\u2191f \u2264\u1da0[ae \u03bc] \u2191\u2191g \u2194 f \u2264 g"}, {"line": "rw [\u2190 Subtype.coe_le_coe]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : PartialOrder E\nf g : \u21a5(Lp E p \u03bc)\n\u22a2 \u2191\u2191f \u2264\u1da0[ae \u03bc] \u2191\u2191g \u2194 \u2191f \u2264 \u2191g"}, {"line": "rw [\u2190 AEEqFun.coeFn_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_approxOn_y\u2080_le [OpensMeasurableSpace E] {f : \u03b2 \u2192 E} (hf : Measurable f) {s : Set E}\n    {y\u2080 : E} (h\u2080 : y\u2080 \u2208 s) [SeparableSpace s] (x : \u03b2) (n : \u2115) :\n    \u2016approxOn f hf s y\u2080 h\u2080 n x - y\u2080\u2016 \u2264 \u2016f x - y\u2080\u2016 + \u2016f x - y\u2080\u2016 := by\n  simpa [enorm, edist_eq_enorm_sub, \u2190 ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h\u2080 x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean", "context": {"open": ["Set Function Filter TopologicalSpace ENNReal EMetric Finset", "scoped Topology ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b9 E F \ud835\udd5c : Type*}", "[MeasurableSpace \u03b2] [MeasurableSpace E] [NormedAddCommGroup E] [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b2\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : NormedAddCommGroup E\nx\u271d : Sort u_7\napproxOn : x\u271d\ninst\u271d\u00b9 : OpensMeasurableSpace E\nf : \u03b2 \u2192 E\nhf : Measurable f\ns : Set E\ny\u2080 : E\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nx : \u03b2\nn : \u2115\n\u22a2 \u2016sorry - y\u2080\u2016 \u2264 \u2016f x - y\u2080\u2016 + \u2016f x - y\u2080\u2016"}, {"line": "simpa [enorm, edist_eq_enorm_sub, \u2190 ENNReal.coe_add, norm_sub_rev]\n    using edist_approxOn_y0_le hf h\u2080 x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_pair {f : \u03b1 \u2192\u209b E} {g : \u03b1 \u2192\u209b F} :\n    Integrable f \u03bc \u2192 Integrable g \u03bc \u2192 Integrable (pair f g) \u03bc := by\n  simpa only [integrable_iff_finMeasSupp] using FinMeasSupp.pair\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean", "context": {"open": ["Set Function Filter TopologicalSpace ENNReal EMetric Finset", "scoped Topology ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b9 E F \ud835\udd5c : Type*}", "[MeasurableSpace \u03b2] [MeasurableSpace E] [NormedAddCommGroup E] [NormedAddCommGroup F]", "[MeasurableSpace \u03b2]", "[MeasurableSpace E] [NormedAddCommGroup E]", "[MeasurableSpace \u03b1]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "{\u03bc : Measure \u03b1} {p : \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.723\n\u03b1\u271d : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nE : Type u_4\nF : Type u_5\n\ud835\udd5c : Type u_6\ninst\u271d\u00b9\u2070 : MeasurableSpace \u03b2\ninst\u271d\u2079 : MeasurableSpace E\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedAddCommGroup F\ninst\u271d\u2076 : MeasurableSpace \u03b2\ninst\u271d\u2075 : MeasurableSpace E\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup F\n\u03bc : sorry\np : ENNReal\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_7\nIntegrable : x\u271d\nf : \u03b1 \u2192 sorry\ng : \u03b1 \u2192 sorry\n\u22a2 sorry \u2192 sorry \u2192 sorry"}, {"line": "simpa only [integrable_iff_finMeasSupp] using FinMeasSupp.pair", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_toSimpleFunc [Fact (1 \u2264 p)] (f : Lp.simpleFunc E p \u03bc) :\n    \u2016f\u2016 = ENNReal.toReal (eLpNorm (toSimpleFunc f) p \u03bc) := by\n  simpa [toLp_toSimpleFunc] using norm_toLp (toSimpleFunc f) (simpleFunc.memLp f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFuncDenseLp.lean", "context": {"open": ["Set Function Filter TopologicalSpace ENNReal EMetric Finset", "scoped Topology ENNReal MeasureTheory", "AEEqFun"], "variables": ["{\u03b1 \u03b2 \u03b9 E F \ud835\udd5c : Type*}", "[MeasurableSpace \u03b2] [MeasurableSpace E] [NormedAddCommGroup E] [NormedAddCommGroup F]", "[MeasurableSpace \u03b2]", "[MeasurableSpace E] [NormedAddCommGroup E]", "[MeasurableSpace \u03b1]", "[NormedAddCommGroup E] [NormedAddCommGroup F]", "{\u03bc : Measure \u03b1} {p : \u211d\u22650\u221e}", "[MeasurableSpace \u03b1] [NormedAddCommGroup E] [NormedAddCommGroup F] (p : \u211d\u22650\u221e)", "(E)", "{E p \u03bc}", "[NormedRing \ud835\udd5c] [Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedRing \ud835\udd5c] [Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "(E \u03bc)", "{E \u03bc}", "[NormedRing \ud835\udd5c] [Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.14988\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nE : Type u_4\nF : Type u_5\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b2\u00b9 : MeasurableSpace E\ninst\u271d\u00b2\u2070 : NormedAddCommGroup E\ninst\u271d\u00b9\u2079 : NormedAddCommGroup F\ninst\u271d\u00b9\u2078 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2077 : MeasurableSpace E\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b3 : NormedAddCommGroup F\n\u03bc : sorry\np\u271d\u00b9 : ENNReal\ninst\u271d\u00b9\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9\u00b9 : NormedAddCommGroup E\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\np\u271d : ENNReal\ninst\u271d\u2079 : NormedRing \ud835\udd5c\ninst\u271d\u2078 : Module \ud835\udd5c E\ninst\u271d\u2077 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2076 : NormedRing \ud835\udd5c\ninst\u271d\u2075 : Module \ud835\udd5c E\ninst\u271d\u2074 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u00b3 : NormedRing \ud835\udd5c\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : IsBoundedSMul \ud835\udd5c E\np : ENNReal\nx\u271d : Sort u_7\neLpNorm : x\u271d\ninst\u271d : Fact (1 \u2264 p)\nf : sorry\n\u22a2 sorry = sorry.toReal"}, {"line": "simpa [toLp_toSimpleFunc] using norm_toLp (toSimpleFunc f) (simpleFunc.memLp f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_ae_unique {\u03b9 : Type*} [T2Space \u03b2]\n    {g h : \u03b1 \u2192 \u03b2} {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {l : Filter \u03b9} [l.NeBot]\n    (hg : \u2200\u1d50 \u03c9 \u2202\u03bc, Tendsto (fun i => f i \u03c9) l (\ud835\udcdd (g \u03c9)))\n    (hh : \u2200\u1d50 \u03c9 \u2202\u03bc, Tendsto (fun i => f i \u03c9) l (\ud835\udcdd (h \u03c9))) : g =\u1d50[\u03bc] h := by\n  filter_upwards [hg, hh] with \u03c9 hg1 hh1 using tendsto_nhds_unique hg1 hh1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/AEEqFun.lean", "context": {"open": ["Topology Set Filter TopologicalSpace ENNReal EMetric MeasureTheory Function", "scoped Classical in", "MeasureTheory.Measure (QuasiMeasurePreserving)", "ENNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [MeasurableSpace \u03b1] {\u03bc \u03bd : Measure \u03b1}", "[TopologicalSpace \u03b2]", "(\u03b2)", "(\u03b1)", "{\u03b1 \u03b2}", "[TopologicalSpace \u03b4]", "[TopologicalSpace \u03b2]", "[TopologicalSpace \u03b3] [MeasurableSpace \u03b2] {\u03bd : MeasureTheory.Measure \u03b2} {f : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b3] [MeasurableSpace \u03b2] {\u03bd : MeasureTheory.Measure \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3]", "[MeasurableSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2] [MeasurableSpace \u03b3]", "[MeasurableSpace \u03b2] [PseudoMetrizableSpace \u03b2] [BorelSpace \u03b2]", "[SemilatticeSup \u03b2] [ContinuousSup \u03b2]", "[SemilatticeInf \u03b2] [ContinuousInf \u03b2]", "(\u03b1)", "{\u03b1}", "{\ud835\udd5c \ud835\udd5c' : Type*}", "[SMul \ud835\udd5c \u03b3] [ContinuousConstSMul \ud835\udd5c \u03b3]", "[SMul \ud835\udd5c' \u03b3] [ContinuousConstSMul \ud835\udd5c' \u03b3]", "[Mul \u03b3] [ContinuousMul \u03b3]", "[Monoid \u03b3] [ContinuousMul \u03b3]", "[Group \u03b3] [IsTopologicalGroup \u03b3]", "{\ud835\udd5c : Type*}", "[LinearOrder \u03b3] [OrderClosedTopology \u03b3] [Zero \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2077 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9\u00b9 : MeasurableSpace \u03b2\ninst\u271d\u00b9\u2070 : PseudoMetrizableSpace \u03b2\ninst\u271d\u2079 : BorelSpace \u03b2\ninst\u271d\u2078 : MeasurableSpace \u03b2\ninst\u271d\u2077 : PseudoMetrizableSpace \u03b2\ninst\u271d\u2076 : BorelSpace \u03b2\ninst\u271d\u2075 : SemilatticeSup \u03b2\ninst\u271d\u2074 : ContinuousSup \u03b2\ninst\u271d\u00b3 : SemilatticeInf \u03b2\ninst\u271d\u00b2 : ContinuousInf \u03b2\n\u03b9 : Type u_8\ninst\u271d\u00b9 : T2Space \u03b2\ng h : \u03b1 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1 \u2192 \u03b2\nl : Filter \u03b9\ninst\u271d : l.NeBot\nhg : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, Tendsto (fun i => f i \u03c9) l (nhds (g \u03c9))\nhh : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, Tendsto (fun i => f i \u03c9) l (nhds (h \u03c9))\n\u22a2 g =\u1da0[ae \u03bc] h"}, {"line": "filter_upwards [hg, hh] with \u03c9 hg1 hh1 using tendsto_nhds_unique hg1 hh1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter {f : \u03b1 \u2192 \u211d} {t : Set \u03b1}\n    (hf : IntegrableOn f t \u03bc)\n    (hf_zero : \u2200 s, MeasurableSet s \u2192 \u03bc (s \u2229 t) < \u221e \u2192 0 \u2264 \u222b x in s \u2229 t, f x \u2202\u03bc) :\n    0 \u2264\u1d50[\u03bc.restrict t] f := by\n  refine ae_nonneg_of_forall_setIntegral_nonneg hf fun s hs h's => ?_\n  simp_rw [Measure.restrict_restrict hs]\n  apply hf_zero s hs\n  rwa [Measure.restrict_apply hs] at h's\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean", "context": {"open": ["MeasureTheory TopologicalSpace NormedSpace Filter", "scoped ENNReal NNReal MeasureTheory Topology"], "variables": ["{\u03b1 E \ud835\udd5c : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [RCLike \ud835\udd5c]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\u03b1 E : Type*} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "{f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nt : Set \u03b1\nhf : IntegrableOn f t \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc (s \u2229 t) < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc\n\u22a2 0 \u2264\u1da0[ae (\u03bc.restrict t)] f"}, {"line": "refine ae_nonneg_of_forall_setIntegral_nonneg hf fun s hs h's => ?_", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nt : Set \u03b1\nhf : IntegrableOn f t \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc (s \u2229 t) < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nh's : (\u03bc.restrict t) s < \u22a4\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s, f x \u2202\u03bc.restrict t"}, {"line": "simp_rw [Measure.restrict_restrict hs]", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nt : Set \u03b1\nhf : IntegrableOn f t \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc (s \u2229 t) < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nh's : (\u03bc.restrict t) s < \u22a4\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc"}, {"line": "apply hf_zero s hs", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nt : Set \u03b1\nhf : IntegrableOn f t \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc (s \u2229 t) < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc\ns : Set \u03b1\nhs : MeasurableSet s\nh's : (\u03bc.restrict t) s < \u22a4\n\u22a2 \u03bc (s \u2229 t) < \u22a4"}, {"line": "rwa [Measure.restrict_apply hs] at h's", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_nonneg_restrict_of_forall_setIntegral_nonneg {f : \u03b1 \u2192 \u211d}\n    (hf_int_finite : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 IntegrableOn f s \u03bc)\n    (hf_zero : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 0 \u2264 \u222b x in s, f x \u2202\u03bc) {t : Set \u03b1}\n    (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) : 0 \u2264\u1d50[\u03bc.restrict t] f := by\n  refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter\n      (hf_int_finite t ht (lt_top_iff_ne_top.mpr h\u03bct)) fun s hs _ => ?_\n  refine hf_zero (s \u2229 t) (hs.inter ht) ?_\n  exact (measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr h\u03bct)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean", "context": {"open": ["MeasureTheory TopologicalSpace NormedSpace Filter", "scoped ENNReal NNReal MeasureTheory Topology"], "variables": ["{\u03b1 E \ud835\udd5c : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [RCLike \ud835\udd5c]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\u03b1 E : Type*} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "{f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s, f x \u2202\u03bc\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 0 \u2264\u1da0[ae (\u03bc.restrict t)] f"}, {"line": "refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter\n      (hf_int_finite t ht (lt_top_iff_ne_top.mpr h\u03bct)) fun s hs _ => ?_", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s, f x \u2202\u03bc\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nx\u271d : \u03bc (s \u2229 t) < \u22a4\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s \u2229 t, f x \u2202\u03bc"}, {"line": "refine hf_zero (s \u2229 t) (hs.inter ht) ?_", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 0 \u2264 \u222b (x : \u03b1) in s, f x \u2202\u03bc\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nx\u271d : \u03bc (s \u2229 t) < \u22a4\n\u22a2 \u03bc (s \u2229 t) < \u22a4"}, {"line": "exact (measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr h\u03bct)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_eq_zero_restrict_of_forall_setIntegral_eq_zero_real {f : \u03b1 \u2192 \u211d}\n    (hf_int_finite : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 IntegrableOn f s \u03bc)\n    (hf_zero : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 \u222b x in s, f x \u2202\u03bc = 0) {t : Set \u03b1}\n    (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) : f =\u1d50[\u03bc.restrict t] 0 := by\n  suffices h_and : f \u2264\u1d50[\u03bc.restrict t] 0 \u2227 0 \u2264\u1d50[\u03bc.restrict t] f from\n    h_and.1.mp (h_and.2.mono fun x hx1 hx2 => le_antisymm hx2 hx1)\n  refine\n    \u27e8?_,\n      ae_nonneg_restrict_of_forall_setIntegral_nonneg hf_int_finite\n        (fun s hs h\u03bcs => (hf_zero s hs h\u03bcs).symm.le) ht h\u03bct\u27e9\n  suffices h_neg : 0 \u2264\u1d50[\u03bc.restrict t] -f by\n    refine h_neg.mono fun x hx => ?_\n    rw [Pi.neg_apply] at hx\n    simpa using hx\n  refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg (fun s hs h\u03bcs => (hf_int_finite s hs h\u03bcs).neg)\n      (fun s hs h\u03bcs => ?_) ht h\u03bct\n  simp_rw [Pi.neg_apply]\n  rw [integral_neg]\n  rw [neg_nonneg]\n  exact (hf_zero s hs h\u03bcs).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/AEEqOfIntegral.lean", "context": {"open": ["MeasureTheory TopologicalSpace NormedSpace Filter", "scoped ENNReal NNReal MeasureTheory Topology"], "variables": ["{\u03b1 E \ud835\udd5c : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [RCLike \ud835\udd5c]", "(\ud835\udd5c)", "{\ud835\udd5c}", "{\u03b1 E : Type*} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "{f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 f =\u1da0[ae (\u03bc.restrict t)] 0"}, {"line": "suffices h_and : f \u2264\u1d50[\u03bc.restrict t] 0 \u2227 0 \u2264\u1d50[\u03bc.restrict t] f from\n    h_and.1.mp (h_and.2.mono fun x hx1 hx2 => le_antisymm hx2 hx1)", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 f \u2264\u1da0[ae (\u03bc.restrict t)] 0 \u2227 0 \u2264\u1da0[ae (\u03bc.restrict t)] f"}, {"line": "refine\n    \u27e8?_,\n      ae_nonneg_restrict_of_forall_setIntegral_nonneg hf_int_finite\n        (fun s hs h\u03bcs => (hf_zero s hs h\u03bcs).symm.le) ht h\u03bct\u27e9", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 f \u2264\u1da0[ae (\u03bc.restrict t)] 0"}, {"line": "suffices h_neg : 0 \u2264\u1d50[\u03bc.restrict t] -f by\n    refine h_neg.mono fun x hx => ?_\n    rw [Pi.neg_apply] at hx\n    simpa using hx", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 0 \u2264\u1da0[ae (\u03bc.restrict t)] -f"}, {"line": "refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg (fun s hs h\u03bcs => (hf_int_finite s hs h\u03bcs).neg)\n      (fun s hs h\u03bcs => ?_) ht h\u03bct", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s < \u22a4\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s, (-f) x \u2202\u03bc"}, {"line": "simp_rw [Pi.neg_apply]", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s < \u22a4\n\u22a2 0 \u2264 \u222b (x : \u03b1) in s, -f x \u2202\u03bc"}, {"line": "rw [integral_neg]", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s < \u22a4\n\u22a2 0 \u2264 -\u222b (a : \u03b1) in s, f a \u2202\u03bc"}, {"line": "rw [neg_nonneg]", "tactic_state": "\u03b1 : Type u_4\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf_int_finite : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 IntegrableOn f s \u03bc\nhf_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 \u03bc s < \u22a4 \u2192 \u222b (x : \u03b1) in s, f x \u2202\u03bc = 0\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s < \u22a4\n\u22a2 \u222b (a : \u03b1) in s, f a \u2202\u03bc \u2264 0"}, {"line": "exact (hf_zero s hs h\u03bcs).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seqTendstoAeSeq_spec (hfg : TendstoInMeasure \u03bc f atTop g) (n k : \u2115)\n    (hn : seqTendstoAeSeq hfg n \u2264 k) :\n    \u03bc { x | (2 : \u211d)\u207b\u00b9 ^ n \u2264 dist (f k x) (g x) } \u2264 (2 : \u211d\u22650\u221e)\u207b\u00b9 ^ n := by\n  cases n\n  \u00b7 exact Classical.choose_spec (exists_nat_measure_lt_two_inv hfg 0) k hn\n  \u00b7 exact Classical.choose_spec\n      (exists_nat_measure_lt_two_inv hfg _) _ (le_trans (le_max_left _ _) hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 \u03b9 \u03ba E : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "[Dist E] {l : Filter \u03b9} {f f' : \u03b9 \u2192 \u03b1 \u2192 E} {g g' : \u03b1 \u2192 E}", "[MetricSpace E]", "{f : \u2115 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.1917\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03ba : Type u_3\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : sorry\ninst\u271d\u00b9 : Dist E\nl : Filter \u03b9\nf\u271d f' : \u03b9 \u2192 \u03b1 \u2192 E\ng\u271d g' : \u03b1 \u2192 E\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nx\u271d\u00b9 : Sort u_5\nTendstoInMeasure : x\u271d\u00b9\nx\u271d : Sort u_6\nseqTendstoAeSeq : x\u271d\nhfg : sorry\nn k : \u2115\nhn : sorry \u2264 k\n\u22a2 sorry \u2264 2\u207b\u00b9 ^ n"}, {"line": "cases n", "tactic_state": "case zero\nMeasure : ?m.1917\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03ba : Type u_3\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : sorry\ninst\u271d\u00b9 : Dist E\nl : Filter \u03b9\nf\u271d f' : \u03b9 \u2192 \u03b1 \u2192 E\ng\u271d g' : \u03b1 \u2192 E\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nx\u271d\u00b9 : Sort u_5\nTendstoInMeasure : x\u271d\u00b9\nx\u271d : Sort u_6\nseqTendstoAeSeq : x\u271d\nhfg : sorry\nk : \u2115\nhn : sorry \u2264 k\n\u22a2 sorry \u2264 2\u207b\u00b9 ^ 0\n---\ncase succ\nMeasure : ?m.1917\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03ba : Type u_3\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : sorry\ninst\u271d\u00b9 : Dist E\nl : Filter \u03b9\nf\u271d f' : \u03b9 \u2192 \u03b1 \u2192 E\ng\u271d g' : \u03b1 \u2192 E\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nx\u271d\u00b9 : Sort u_5\nTendstoInMeasure : x\u271d\u00b9\nx\u271d : Sort u_6\nseqTendstoAeSeq : x\u271d\nhfg : sorry\nk : \u2115\nhn : sorry \u2264 k\nn\u271d : \u2115\n\u22a2 sorry \u2264 2\u207b\u00b9 ^ (n\u271d + 1)"}, {"line": "\u00b7 exact Classical.choose_spec (exists_nat_measure_lt_two_inv hfg 0) k hn", "tactic_state": "case succ\nMeasure : ?m.1917\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03ba : Type u_3\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : sorry\ninst\u271d\u00b9 : Dist E\nl : Filter \u03b9\nf\u271d f' : \u03b9 \u2192 \u03b1 \u2192 E\ng\u271d g' : \u03b1 \u2192 E\ninst\u271d : MetricSpace E\nf : \u2115 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nx\u271d\u00b9 : Sort u_5\nTendstoInMeasure : x\u271d\u00b9\nx\u271d : Sort u_6\nseqTendstoAeSeq : x\u271d\nhfg : sorry\nk : \u2115\nhn : sorry \u2264 k\nn\u271d : \u2115\n\u22a2 sorry \u2264 2\u207b\u00b9 ^ (n\u271d + 1)"}, {"line": "\u00b7 exact Classical.choose_spec\n      (exists_nat_measure_lt_two_inv hfg _) _ (le_trans (le_max_left _ _) hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TendstoInMeasure.exists_seq_tendstoInMeasure_atTop {u : Filter \u03b9} [NeBot u]\n    [IsCountablyGenerated u] {f : \u03b9 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E} (hfg : TendstoInMeasure \u03bc f u g) :\n    \u2203 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop u \u2227 TendstoInMeasure \u03bc (fun n => f (ns n)) atTop g := by\n  obtain \u27e8ns, h_tendsto_ns\u27e9 : \u2203 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop u := exists_seq_tendsto u\n  exact \u27e8ns, h_tendsto_ns, fun \u03b5 h\u03b5 => (hfg \u03b5 h\u03b5).comp h_tendsto_ns\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/ConvergenceInMeasure.lean", "context": {"open": ["TopologicalSpace Filter", "scoped NNReal ENNReal MeasureTheory Topology"], "variables": ["{\u03b1 \u03b9 \u03ba E : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "[Dist E] {l : Filter \u03b9} {f f' : \u03b9 \u2192 \u03b1 \u2192 E} {g g' : \u03b1 \u2192 E}", "[MetricSpace E]", "{f : \u2115 \u2192 \u03b1 \u2192 E} {g : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.1917\n\u03b1\u271d : Type u_1\n\u03b9\u271d : Type u_2\n\u03ba : Type u_3\nE\u271d : Type u_4\nm : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\ninst\u271d\u2075 : Dist E\u271d\nl : Filter \u03b9\u271d\nf\u271d\u00b9 f' : \u03b9\u271d \u2192 \u03b1\u271d \u2192 E\u271d\ng\u271d\u00b9 g' : \u03b1\u271d \u2192 E\u271d\ninst\u271d\u2074 : MetricSpace E\u271d\nf\u271d : \u2115 \u2192 \u03b1\u271d \u2192 E\u271d\ng\u271d : \u03b1\u271d \u2192 E\u271d\n\u03b1 : Type u_1\n\u03b9 : Type u_2\nE : Type u_4\ninst\u271d\u00b3 : Dist E\ninst\u271d\u00b2 : MetricSpace E\nx\u271d : Sort u_5\nTendstoInMeasure : x\u271d\nu : Filter \u03b9\ninst\u271d\u00b9 : u.NeBot\ninst\u271d : u.IsCountablyGenerated\nf : \u03b9 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nhfg : sorry\n\u22a2 \u2203 ns, Tendsto ns atTop u \u2227 sorry"}, {"line": "obtain \u27e8ns, h_tendsto_ns\u27e9 : \u2203 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop u := exists_seq_tendsto u", "tactic_state": "case intro\nMeasure : ?m.1917\n\u03b1\u271d : Type u_1\n\u03b9\u271d : Type u_2\n\u03ba : Type u_3\nE\u271d : Type u_4\nm : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\ninst\u271d\u2075 : Dist E\u271d\nl : Filter \u03b9\u271d\nf\u271d\u00b9 f' : \u03b9\u271d \u2192 \u03b1\u271d \u2192 E\u271d\ng\u271d\u00b9 g' : \u03b1\u271d \u2192 E\u271d\ninst\u271d\u2074 : MetricSpace E\u271d\nf\u271d : \u2115 \u2192 \u03b1\u271d \u2192 E\u271d\ng\u271d : \u03b1\u271d \u2192 E\u271d\n\u03b1 : Type u_1\n\u03b9 : Type u_2\nE : Type u_4\ninst\u271d\u00b3 : Dist E\ninst\u271d\u00b2 : MetricSpace E\nx\u271d : Sort u_5\nTendstoInMeasure : x\u271d\nu : Filter \u03b9\ninst\u271d\u00b9 : u.NeBot\ninst\u271d : u.IsCountablyGenerated\nf : \u03b9 \u2192 \u03b1 \u2192 E\ng : \u03b1 \u2192 E\nhfg : sorry\nns : \u2115 \u2192 \u03b9\nh_tendsto_ns : Tendsto ns atTop u\n\u22a2 \u2203 ns, Tendsto ns atTop u \u2227 sorry"}, {"line": "exact \u27e8ns, h_tendsto_ns, fun \u03b5 h\u03b5 => (hfg \u03b5 h\u03b5).comp h_tendsto_ns\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma essSup_smul_measure (hc : c \u2260 0) (f : \u03b1 \u2192 \u03b2) : essSup f (c \u2022 \u03bc) = essSup f \u03bc := by\n  simp_rw [essSup, Measure.ae_smul_measure_eq hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/EssSup.lean", "context": {"open": ["Filter MeasureTheory ProbabilityTheory Set TopologicalSpace", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ConditionallyCompleteLattice \u03b2\nc : \u2115\nhc : c \u2260 0\nf : \u03b1 \u2192 \u03b2\n\u22a2 essSup f (c \u2022 \u03bc) = essSup f \u03bc"}, {"line": "simp_rw [essSup, Measure.ae_smul_measure_eq hc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem essSup_liminf_le {\u03b9} [Countable \u03b9] [Preorder \u03b9] (f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) :\n    essSup (fun x => atTop.liminf fun n => f n x) \u03bc \u2264\n      atTop.liminf fun n => essSup (fun x => f n x) \u03bc := by\n  simp_rw [essSup]\n  exact ENNReal.limsup_liminf_le_liminf_limsup fun a b => f b a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/EssSup.lean", "context": {"open": ["Filter MeasureTheory ProbabilityTheory Set TopologicalSpace", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "[Nonempty \u03b1]", "[MeasurableSingletonClass \u03b1]", "[ConditionallyCompleteLinearOrder \u03b2] {x : \u03b2} {f : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [FirstCountableTopology \u03b2] [OrderTopology \u03b2]", "[CompleteLattice \u03b2]", "{\u03b3 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b2}", "[MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2]", "{f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : Nonempty \u03b1\ninst\u271d\u00b2 : MeasurableSingletonClass \u03b1\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Countable \u03b9\ninst\u271d : Preorder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\n\u22a2 essSup (fun x => liminf (fun n => f n x) atTop) \u03bc \u2264 liminf (fun n => essSup (fun x => f n x) \u03bc) atTop"}, {"line": "simp_rw [essSup]", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : Nonempty \u03b1\ninst\u271d\u00b2 : MeasurableSingletonClass \u03b1\n\u03b9 : Type u_5\ninst\u271d\u00b9 : Countable \u03b9\ninst\u271d : Preorder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 ENNReal\n\u22a2 limsup (fun x => liminf (fun n => f n x) atTop) (ae \u03bc) \u2264 liminf (fun n => limsup (fun x => f n x) (ae \u03bc)) atTop"}, {"line": "exact ENNReal.limsup_liminf_le_liminf_limsup fun a b => f b a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma essSup_restrict_eq_of_support_subset {s : Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hsf : f.support \u2286 s) :\n    essSup f (\u03bc.restrict s) = essSup f \u03bc := by\n  apply le_antisymm (essSup_mono_measure' Measure.restrict_le_self)\n  apply le_of_forall_lt (fun c hc \u21a6 ?_)\n  obtain \u27e8d, cd, hd\u27e9 : \u2203 d, c < d \u2227 d < essSup f \u03bc := exists_between hc\n  let t := {x | d < f x}\n  have A : 0 < (\u03bc.restrict t) t := by\n    simp only [Measure.restrict_apply_self]\n    rw [essSup_eq_sInf] at hd\n    have : d \u2209 {a | \u03bc {x | a < f x} = 0} := not_mem_of_lt_csInf hd (OrderBot.bddBelow _)\n    exact bot_lt_iff_ne_bot.2 this\n  have B : 0 < (\u03bc.restrict s) t := by\n    have : \u03bc.restrict t \u2264 \u03bc.restrict s := by\n      apply Measure.restrict_mono _ le_rfl\n      apply subset_trans _ hsf\n      intro x (hx : d < f x)\n      exact (lt_of_le_of_lt bot_le hx).ne'\n    exact lt_of_lt_of_le A (this _)\n  apply cd.trans_le\n  rw [essSup_eq_sInf]\n  apply le_sInf (fun b hb \u21a6 ?_)\n  contrapose! hb\n  exact ne_of_gt (B.trans_le (measure_mono (fun x hx \u21a6 hb.trans hx)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/EssSup.lean", "context": {"open": ["Filter MeasureTheory ProbabilityTheory Set TopologicalSpace", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[ConditionallyCompleteLattice \u03b2] {f : \u03b1 \u2192 \u03b2}", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "[Nonempty \u03b1]", "[MeasurableSingletonClass \u03b1]", "[ConditionallyCompleteLinearOrder \u03b2] {x : \u03b2} {f : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [FirstCountableTopology \u03b2] [OrderTopology \u03b2]", "[CompleteLattice \u03b2]", "{\u03b3 : Type*} {m\u03b3 : MeasurableSpace \u03b3} {f : \u03b1 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b2}", "[MeasurableSpace \u03b2] [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2]", "{f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\n\u22a2 essSup f (\u03bc.restrict s) = essSup f \u03bc"}, {"line": "apply le_antisymm (essSup_mono_measure' Measure.restrict_le_self)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\n\u22a2 essSup f \u03bc \u2264 essSup f (\u03bc.restrict s)"}, {"line": "apply le_of_forall_lt (fun c hc \u21a6 ?_)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\n\u22a2 c < essSup f (\u03bc.restrict s)"}, {"line": "obtain \u27e8d, cd, hd\u27e9 : \u2203 d, c < d \u2227 d < essSup f \u03bc := exists_between hc", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\n\u22a2 c < essSup f (\u03bc.restrict s)"}, {"line": "let t := {x | d < f x}", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\n\u22a2 c < essSup f (\u03bc.restrict s)"}, {"line": "have A : 0 < (\u03bc.restrict t) t := sorry", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\n\u22a2 c < essSup f (\u03bc.restrict s)"}, {"line": "have B : 0 < (\u03bc.restrict s) t := sorry", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\nB : 0 < (\u03bc.restrict s) t\n\u22a2 c < essSup f (\u03bc.restrict s)"}, {"line": "apply cd.trans_le", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\nB : 0 < (\u03bc.restrict s) t\n\u22a2 d \u2264 essSup f (\u03bc.restrict s)"}, {"line": "rw [essSup_eq_sInf]", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\nB : 0 < (\u03bc.restrict s) t\n\u22a2 d \u2264 sInf {a | (\u03bc.restrict s) {x | a < f x} = 0}"}, {"line": "apply le_sInf (fun b hb \u21a6 ?_)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\nB : 0 < (\u03bc.restrict s) t\nb : ENNReal\nhb : b \u2208 {a | (\u03bc.restrict s) {x | a < f x} = 0}\n\u22a2 d \u2264 b"}, {"line": "contrapose! hb", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 ENNReal\nhsf : Function.support f \u2286 s\nc : ENNReal\nhc : c < essSup f \u03bc\nd : ENNReal\ncd : c < d\nhd : d < essSup f \u03bc\nt : Set \u03b1 := {x | d < f x}\nA : 0 < (\u03bc.restrict t) t\nB : 0 < (\u03bc.restrict s) t\nb : ENNReal\nhb : b < d\n\u22a2 b \u2209 {a | (\u03bc.restrict s) {x | a < f x} = 0}"}, {"line": "exact ne_of_gt (B.trans_le (measure_mono (fun x hx \u21a6 hb.trans hx)))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul\n    {f : \u211d \u2192 \u211d} (hf : MeasurableEmbedding f) {s : Set \u211d} (hs : MeasurableSet s)\n    {g : \u211d \u2192 \u211d} (hg : \u2200\u1d50 x, x \u2208 f '' s \u2192 0 \u2264 g x) (hg_int : IntegrableOn g (f '' s))\n    {f' : \u211d \u2192 \u211d} (hf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) :\n    (volume.withDensity (fun x \u21a6 ENNReal.ofReal (g x))).comap f s\n      = ENNReal.ofReal (\u222b x in s, |f' x| * g (f x)) := by\n  rw [hf.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul volume hs     hg hg_int hf']\n  simp only [det_one_smulRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/Jacobian.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Metric Filter Set Module Asymptotics", "scoped NNReal ENNReal Topology Pointwise", "scoped Function -- required for scoped `on` notation", "ContinuousLinearMap (det_one_smulRight)"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]", "[MeasurableSpace E] [BorelSpace E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nhf : MeasurableEmbedding f\ns : Set \u211d\nhs : MeasurableSet s\ng : \u211d \u2192 \u211d\nhg : \u2200\u1d50 (x : \u211d), x \u2208 f '' s \u2192 0 \u2264 g x\nhg_int : IntegrableOn g (f '' s) volume\nf' : \u211d \u2192 \u211d\nhf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\n\u22a2 (Measure.comap f (volume.withDensity fun x => ENNReal.ofReal (g x))) s =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "rw [hf.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul volume hs     hg hg_int hf']", "tactic_state": "f : \u211d \u2192 \u211d\nhf : MeasurableEmbedding f\ns : Set \u211d\nhs : MeasurableSet s\ng : \u211d \u2192 \u211d\nhg : \u2200\u1d50 (x : \u211d), x \u2208 f '' s \u2192 0 \u2264 g x\nhg_int : IntegrableOn g (f '' s) volume\nf' : \u211d \u2192 \u211d\nhf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x\n\u22a2 ENNReal.ofReal (\u222b (x : \u211d) in s, |(ContinuousLinearMap.smulRight 1 (f' x)).det| * g (f x)) =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "simp only [det_one_smulRight]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul\n    (f : \u211d \u2243\u1d50 \u211d) {s : Set \u211d} (hs : MeasurableSet s)\n    {g : \u211d \u2192 \u211d} (hg : \u2200\u1d50 x, x \u2208 f '' s \u2192 0 \u2264 g x) (hg_int : IntegrableOn g (f '' s))\n    {f' : \u211d \u2192 \u211d} (hf' : \u2200 x \u2208 s, HasDerivWithinAt f (f' x) s x) :\n    (volume.withDensity (fun x \u21a6 ENNReal.ofReal (g x))).map f.symm s\n      = ENNReal.ofReal (\u222b x in s, |f' x| * g (f x)) := by\n  rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs       f hg hg_int hf']\n  simp only [det_one_smulRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/Jacobian.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Metric Filter Set Module Asymptotics", "scoped NNReal ENNReal Topology Pointwise", "scoped Function -- required for scoped `on` notation", "ContinuousLinearMap (det_one_smulRight)"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]", "[MeasurableSpace E] [BorelSpace E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2243\u1d50 \u211d\ns : Set \u211d\nhs : MeasurableSet s\ng : \u211d \u2192 \u211d\nhg : \u2200\u1d50 (x : \u211d), x \u2208 \u21d1f '' s \u2192 0 \u2264 g x\nhg_int : IntegrableOn g (\u21d1f '' s) volume\nf' : \u211d \u2192 \u211d\nhf' : \u2200 x \u2208 s, HasDerivWithinAt (\u21d1f) (f' x) s x\n\u22a2 (Measure.map (\u21d1f.symm) (volume.withDensity fun x => ENNReal.ofReal (g x))) s =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs       f hg hg_int hf']", "tactic_state": "f : \u211d \u2243\u1d50 \u211d\ns : Set \u211d\nhs : MeasurableSet s\ng : \u211d \u2192 \u211d\nhg : \u2200\u1d50 (x : \u211d), x \u2208 \u21d1f '' s \u2192 0 \u2264 g x\nhg_int : IntegrableOn g (\u21d1f '' s) volume\nf' : \u211d \u2192 \u211d\nhf' : \u2200 x \u2208 s, HasDerivWithinAt (\u21d1f) (f' x) s x\n\u22a2 ENNReal.ofReal (\u222b (x : \u211d) in s, |(ContinuousLinearMap.smulRight 1 (f' x)).det| * g (f x)) =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "simp only [det_one_smulRight]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul'\n    (f : \u211d \u2243\u1d50 \u211d) {s : Set \u211d} (hs : MeasurableSet s)\n    {f' : \u211d \u2192 \u211d} (hf' : \u2200 x, HasDerivAt f (f' x) x)\n    {g : \u211d \u2192 \u211d} (hg : 0 \u2264\u1d50[volume] g) (hg_int : Integrable g) :\n    (volume.withDensity (fun x \u21a6 ENNReal.ofReal (g x))).map f.symm s\n      = ENNReal.ofReal (\u222b x in s, |f' x| * g (f x)) := by\n  rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs       f (by filter_upwards [hg] with x hx using fun _ \u21a6 hx) hg_int.integrableOn\n      (fun x _ => (hf' x).hasDerivWithinAt)]\n  simp only [det_one_smulRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/Jacobian.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Metric Filter Set Module Asymptotics", "scoped NNReal ENNReal Topology Pointwise", "scoped Function -- required for scoped `on` notation", "ContinuousLinearMap (det_one_smulRight)"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [FiniteDimensional \u211d E]", "[MeasurableSpace E] [BorelSpace E] (\u03bc : Measure E) [IsAddHaarMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2243\u1d50 \u211d\ns : Set \u211d\nhs : MeasurableSet s\nf' : \u211d \u2192 \u211d\nhf' : \u2200 (x : \u211d), HasDerivAt (\u21d1f) (f' x) x\ng : \u211d \u2192 \u211d\nhg : 0 \u2264\u1da0[ae volume] g\nhg_int : Integrable g volume\n\u22a2 (Measure.map (\u21d1f.symm) (volume.withDensity fun x => ENNReal.ofReal (g x))) s =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs       f (by filter_upwards [hg] with x hx using fun _ \u21a6 hx) hg_int.integrableOn\n      (fun x _ => (hf' x).hasDerivWithinAt)]", "tactic_state": "f : \u211d \u2243\u1d50 \u211d\ns : Set \u211d\nhs : MeasurableSet s\nf' : \u211d \u2192 \u211d\nhf' : \u2200 (x : \u211d), HasDerivAt (\u21d1f) (f' x) x\ng : \u211d \u2192 \u211d\nhg : 0 \u2264\u1da0[ae volume] g\nhg_int : Integrable g volume\n\u22a2 ENNReal.ofReal (\u222b (x : \u211d) in s, |(ContinuousLinearMap.smulRight 1 (f' x)).det| * g (f x)) =\n    ENNReal.ofReal (\u222b (x : \u211d) in s, |f' x| * g (f x))"}, {"line": "simp only [det_one_smulRight]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MemLp.integrable_sq {f : \u03b1 \u2192 \u211d} (h : MemLp f 2 \u03bc) : Integrable (fun x => f x ^ 2) \u03bc := by\n  simpa [\u2190 memLp_one_iff_integrable] using h.norm_rpow two_ne_zero ENNReal.ofNat_ne_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L2Space.lean", "context": {"open": ["TopologicalSpace MeasureTheory MeasureTheory.Lp Filter", "scoped NNReal ENNReal MeasureTheory"], "variables": ["{\u03b1 F : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nh : MemLp f 2 \u03bc\n\u22a2 Integrable (fun x => f x ^ 2) \u03bc"}, {"line": "simpa [\u2190 memLp_one_iff_integrable] using h.norm_rpow two_ne_zero ENNReal.ofNat_ne_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memLp_two_iff_integrable_sq_norm {f : \u03b1 \u2192 F} (hf : AEStronglyMeasurable f \u03bc) :\n    MemLp f 2 \u03bc \u2194 Integrable (fun x => \u2016f x\u2016 ^ 2) \u03bc := by\n  rw [\u2190 memLp_one_iff_integrable]\n  convert (memLp_norm_rpow_iff hf two_ne_zero ENNReal.ofNat_ne_top).symm\n  \u00b7 simp\n  \u00b7 rw [div_eq_mul_inv, ENNReal.mul_inv_cancel two_ne_zero ENNReal.ofNat_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L2Space.lean", "context": {"open": ["TopologicalSpace MeasureTheory MeasureTheory.Lp Filter", "scoped NNReal ENNReal MeasureTheory"], "variables": ["{\u03b1 F : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nF : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup F\nf : \u03b1 \u2192 F\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 MemLp f 2 \u03bc \u2194 Integrable (fun x => \u2016f x\u2016 ^ 2) \u03bc"}, {"line": "rw [\u2190 memLp_one_iff_integrable]", "tactic_state": "\u03b1 : Type u_1\nF : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup F\nf : \u03b1 \u2192 F\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 MemLp f 2 \u03bc \u2194 MemLp (fun x => \u2016f x\u2016 ^ 2) 1 \u03bc"}, {"line": "convert (memLp_norm_rpow_iff hf two_ne_zero ENNReal.ofNat_ne_top).symm", "tactic_state": "case h.e'_2.h.e'_6.h\n\u03b1 : Type u_1\nF : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup F\nf : \u03b1 \u2192 F\nhf : AEStronglyMeasurable f \u03bc\nx\u271d : \u03b1\n\u22a2 \u2016f x\u271d\u2016 ^ 2 = \u2016f x\u271d\u2016 ^ ENNReal.toReal 2\n---\ncase h.e'_2.h.e'_7\n\u03b1 : Type u_1\nF : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup F\nf : \u03b1 \u2192 F\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 1 = 2 / 2"}, {"line": "\u00b7 simp", "tactic_state": "case h.e'_2.h.e'_7\n\u03b1 : Type u_1\nF : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup F\nf : \u03b1 \u2192 F\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 1 = 2 / 2"}, {"line": "\u00b7 rw [div_eq_mul_inv, ENNReal.mul_inv_cancel two_ne_zero ENNReal.ofNat_ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memLp_two_iff_integrable_sq {f : \u03b1 \u2192 \u211d} (hf : AEStronglyMeasurable f \u03bc) :\n    MemLp f 2 \u03bc \u2194 Integrable (fun x => f x ^ 2) \u03bc := by\n  convert memLp_two_iff_integrable_sq_norm hf using 3\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L2Space.lean", "context": {"open": ["TopologicalSpace MeasureTheory MeasureTheory.Lp Filter", "scoped NNReal ENNReal MeasureTheory"], "variables": ["{\u03b1 F : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 MemLp f 2 \u03bc \u2194 Integrable (fun x => f x ^ 2) \u03bc"}, {"line": "convert memLp_two_iff_integrable_sq_norm hf using 3", "tactic_state": "case h.e'_2.h.e'_6.h\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhf : AEStronglyMeasurable f \u03bc\nx\u271d : \u03b1\n\u22a2 f x\u271d ^ 2 = \u2016f x\u271d\u2016 ^ 2"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyIntegrableOn.mono (hf : LocallyIntegrableOn f s \u03bc) {g : X \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016) :\n    LocallyIntegrableOn g s \u03bc := by\n  intro x hx\n  rcases hf x hx with \u27e8t, t_mem, ht\u27e9\n  exact \u27e8t, t_mem, Integrable.mono ht hg.restrict (ae_restrict_of_ae h)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\nhf : LocallyIntegrableOn f s \u03bc\ng : X \u2192 F\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : X) \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016\n\u22a2 LocallyIntegrableOn g s \u03bc"}, {"line": "intro x hx", "tactic_state": "X : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\nhf : LocallyIntegrableOn f s \u03bc\ng : X \u2192 F\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : X) \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016\nx : X\nhx : x \u2208 s\n\u22a2 IntegrableAtFilter g (nhdsWithin x s) \u03bc"}, {"line": "rcases hf x hx with \u27e8t, t_mem, ht\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\nhf : LocallyIntegrableOn f s \u03bc\ng : X \u2192 F\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : X) \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016\nx : X\nhx : x \u2208 s\nt : Set X\nt_mem : t \u2208 nhdsWithin x s\nht : IntegrableOn f t \u03bc\n\u22a2 IntegrableAtFilter g (nhdsWithin x s) \u03bc"}, {"line": "exact \u27e8t, t_mem, Integrable.mono ht hg.restrict (ae_restrict_of_ae h)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyIntegrable_comap (hs : MeasurableSet s) :\n    LocallyIntegrable (fun x : s \u21a6 f x) (\u03bc.comap Subtype.val) \u2194 LocallyIntegrableOn f s \u03bc := by\n  simp_rw [LocallyIntegrableOn, Subtype.forall', \u2190 map_nhds_subtype_val]\n  exact forall_congr' fun _ \u21a6 (MeasurableEmbedding.subtype_coe hs).integrableAtFilter_iff_comap.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\nhs : MeasurableSet s\n\u22a2 LocallyIntegrable (fun x => f \u2191x) (comap Subtype.val \u03bc) \u2194 LocallyIntegrableOn f s \u03bc"}, {"line": "simp_rw [LocallyIntegrableOn, Subtype.forall', \u2190 map_nhds_subtype_val]", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\nhs : MeasurableSet s\n\u22a2 LocallyIntegrable (fun x => f \u2191x) (comap Subtype.val \u03bc) \u2194\n    \u2200 (x : { a // a \u2208 s }), IntegrableAtFilter f (Filter.map Subtype.val (nhds x)) \u03bc"}, {"line": "exact forall_congr' fun _ \u21a6 (MeasurableEmbedding.subtype_coe hs).integrableAtFilter_iff_comap.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyIntegrable.mono (hf : LocallyIntegrable f \u03bc) {g : X \u2192 F}\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016) :\n    LocallyIntegrable g \u03bc := by\n  rw [\u2190 locallyIntegrableOn_univ] at hf \u22a2\n  exact hf.mono hg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : X \u2192 E\n\u03bc : Measure X\nhf : LocallyIntegrable f \u03bc\ng : X \u2192 F\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : X) \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016\n\u22a2 LocallyIntegrable g \u03bc"}, {"line": "rw [\u2190 locallyIntegrableOn_univ] at hf \u22a2", "tactic_state": "X : Type u_1\nE : Type u_3\nF : Type u_4\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedAddCommGroup F\nf : X \u2192 E\n\u03bc : Measure X\nhf : LocallyIntegrableOn f univ \u03bc\ng : X \u2192 F\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : X) \u2202\u03bc, \u2016g x\u2016 \u2264 \u2016f x\u2016\n\u22a2 LocallyIntegrableOn g univ \u03bc"}, {"line": "exact hf.mono hg h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyIntegrableOn_of_locallyIntegrable_restrict [OpensMeasurableSpace X]\n    (hf : LocallyIntegrable f (\u03bc.restrict s)) : LocallyIntegrableOn f s \u03bc := by\n  intro x _\n  obtain \u27e8t, ht_mem, ht_int\u27e9 := hf x\n  obtain \u27e8u, hu_sub, hu_o, hu_mem\u27e9 := mem_nhds_iff.mp ht_mem\n  refine \u27e8_, inter_mem_nhdsWithin s (hu_o.mem_nhds hu_mem), ?_\u27e9\n  simpa only [IntegrableOn,Measure.restrict_restrict hu_o.measurableSet,inter_comm] using\n    ht_int.mono_set hu_sub\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d : OpensMeasurableSpace X\nhf : LocallyIntegrable f (\u03bc.restrict s)\n\u22a2 LocallyIntegrableOn f s \u03bc"}, {"line": "intro x _", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d : OpensMeasurableSpace X\nhf : LocallyIntegrable f (\u03bc.restrict s)\nx : X\na\u271d : x \u2208 s\n\u22a2 IntegrableAtFilter f (nhdsWithin x s) \u03bc"}, {"line": "obtain \u27e8t, ht_mem, ht_int\u27e9 := hf x", "tactic_state": "case intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d : OpensMeasurableSpace X\nhf : LocallyIntegrable f (\u03bc.restrict s)\nx : X\na\u271d : x \u2208 s\nt : Set X\nht_mem : t \u2208 nhds x\nht_int : IntegrableOn f t (\u03bc.restrict s)\n\u22a2 IntegrableAtFilter f (nhdsWithin x s) \u03bc"}, {"line": "obtain \u27e8u, hu_sub, hu_o, hu_mem\u27e9 := mem_nhds_iff.mp ht_mem", "tactic_state": "case intro.intro.intro.intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d : OpensMeasurableSpace X\nhf : LocallyIntegrable f (\u03bc.restrict s)\nx : X\na\u271d : x \u2208 s\nt : Set X\nht_mem : t \u2208 nhds x\nht_int : IntegrableOn f t (\u03bc.restrict s)\nu : Set X\nhu_sub : u \u2286 t\nhu_o : IsOpen u\nhu_mem : x \u2208 u\n\u22a2 IntegrableAtFilter f (nhdsWithin x s) \u03bc"}, {"line": "refine \u27e8_, inter_mem_nhdsWithin s (hu_o.mem_nhds hu_mem), ?_\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d : OpensMeasurableSpace X\nhf : LocallyIntegrable f (\u03bc.restrict s)\nx : X\na\u271d : x \u2208 s\nt : Set X\nht_mem : t \u2208 nhds x\nht_int : IntegrableOn f t (\u03bc.restrict s)\nu : Set X\nhu_sub : u \u2286 t\nhu_o : IsOpen u\nhu_mem : x \u2208 u\n\u22a2 IntegrableOn f (s \u2229 u) \u03bc"}, {"line": "simpa only [IntegrableOn,Measure.restrict_restrict hu_o.measurableSet,inter_comm] using\n    ht_int.mono_set hu_sub", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyIntegrable.aestronglyMeasurable [SecondCountableTopology X]\n    (hf : LocallyIntegrable f \u03bc) : AEStronglyMeasurable f \u03bc := by\n  simpa only [restrict_univ] using (locallyIntegrableOn_univ.mpr hf).aestronglyMeasurable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d : SecondCountableTopology X\nhf : LocallyIntegrable f \u03bc\n\u22a2 AEStronglyMeasurable f \u03bc"}, {"line": "simpa only [restrict_univ] using (locallyIntegrableOn_univ.mpr hf).aestronglyMeasurable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyIntegrable.indicator (hf : LocallyIntegrable f \u03bc) {s : Set X}\n    (hs : MeasurableSet s) : LocallyIntegrable (s.indicator f) \u03bc := by\n  intro x\n  rcases hf x with \u27e8U, hU, h'U\u27e9\n  exact \u27e8U, hU, h'U.indicator hs\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nhf : LocallyIntegrable f \u03bc\ns : Set X\nhs : MeasurableSet s\n\u22a2 LocallyIntegrable (s.indicator f) \u03bc"}, {"line": "intro x", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nhf : LocallyIntegrable f \u03bc\ns : Set X\nhs : MeasurableSet s\nx : X\n\u22a2 IntegrableAtFilter (s.indicator f) (nhds x) \u03bc"}, {"line": "rcases hf x with \u27e8U, hU, h'U\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nhf : LocallyIntegrable f \u03bc\ns : Set X\nhs : MeasurableSet s\nx : X\nU : Set X\nhU : U \u2208 nhds x\nh'U : IntegrableOn f U \u03bc\n\u22a2 IntegrableAtFilter (s.indicator f) (nhds x) \u03bc"}, {"line": "exact \u27e8U, hU, h'U.indicator hs\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyIntegrable_finset_sum {\u03b9} (s : Finset \u03b9) {f : \u03b9 \u2192 X \u2192 E}\n    (hf : \u2200 i \u2208 s, LocallyIntegrable (f i) \u03bc) : LocallyIntegrable (fun a \u21a6 \u2211 i \u2208 s, f i a) \u03bc := by\n  simpa only [\u2190 Finset.sum_apply] using locallyIntegrable_finset_sum' s hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure X\n\u03b9 : Type u_6\ns : Finset \u03b9\nf : \u03b9 \u2192 X \u2192 E\nhf : \u2200 i \u2208 s, LocallyIntegrable (f i) \u03bc\n\u22a2 LocallyIntegrable (fun a => \u2211 i \u2208 s, f i a) \u03bc"}, {"line": "simpa only [\u2190 Finset.sum_apply] using locallyIntegrable_finset_sum' s hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_iff_integrableAtFilter_cocompact :\n    Integrable f \u03bc \u2194 (IntegrableAtFilter f (cocompact X) \u03bc \u2227 LocallyIntegrable f \u03bc) := by\n  refine \u27e8fun hf \u21a6 \u27e8hf.integrableAtFilter _, hf.locallyIntegrable\u27e9, fun \u27e8\u27e8s, hsc, hs\u27e9, hloc\u27e9 \u21a6 ?_\u27e9\n  obtain \u27e8t, htc, ht\u27e9 := mem_cocompact'.mp hsc\n  rewrite [\u2190 integrableOn_univ, \u2190 compl_union_self s, integrableOn_union]\n  exact \u27e8(hloc.integrableOn_isCompact htc).mono ht le_rfl, hs\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal", "Filter"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\n\u22a2 Integrable f \u03bc \u2194 IntegrableAtFilter f (cocompact X) \u03bc \u2227 LocallyIntegrable f \u03bc"}, {"line": "refine \u27e8fun hf \u21a6 \u27e8hf.integrableAtFilter _, hf.locallyIntegrable\u27e9, fun \u27e8\u27e8s, hsc, hs\u27e9, hloc\u27e9 \u21a6 ?_\u27e9", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nx\u271d : IntegrableAtFilter f (cocompact X) \u03bc \u2227 LocallyIntegrable f \u03bc\ns : Set X\nhsc : s \u2208 cocompact X\nhs : IntegrableOn f s \u03bc\nhloc : LocallyIntegrable f \u03bc\n\u22a2 Integrable f \u03bc"}, {"line": "obtain \u27e8t, htc, ht\u27e9 := mem_cocompact'.mp hsc", "tactic_state": "case intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nx\u271d : IntegrableAtFilter f (cocompact X) \u03bc \u2227 LocallyIntegrable f \u03bc\ns : Set X\nhsc : s \u2208 cocompact X\nhs : IntegrableOn f s \u03bc\nhloc : LocallyIntegrable f \u03bc\nt : Set X\nhtc : IsCompact t\nht : s\u1d9c \u2286 t\n\u22a2 Integrable f \u03bc"}, {"line": "rewrite [\u2190 integrableOn_univ, \u2190 compl_union_self s, integrableOn_union]", "tactic_state": "case intro.intro\nX : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\nx\u271d : IntegrableAtFilter f (cocompact X) \u03bc \u2227 LocallyIntegrable f \u03bc\ns : Set X\nhsc : s \u2208 cocompact X\nhs : IntegrableOn f s \u03bc\nhloc : LocallyIntegrable f \u03bc\nt : Set X\nhtc : IsCompact t\nht : s\u1d9c \u2286 t\n\u22a2 IntegrableOn f s\u1d9c \u03bc \u2227 IntegrableOn f s \u03bc"}, {"line": "exact \u27e8(hloc.integrableOn_isCompact htc).mono ht le_rfl, hs\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_iff_integrableAtFilter_atBot_atTop [LinearOrder X] [CompactIccSpace X] :\n    Integrable f \u03bc \u2194\n    (IntegrableAtFilter f atBot \u03bc \u2227 IntegrableAtFilter f atTop \u03bc) \u2227 LocallyIntegrable f \u03bc := by\n  constructor\n  \u00b7 exact fun hf \u21a6 \u27e8\u27e8hf.integrableAtFilter _, hf.integrableAtFilter _\u27e9, hf.locallyIntegrable\u27e9\n  \u00b7 refine fun h \u21a6 integrable_iff_integrableAtFilter_cocompact.mpr \u27e8?_, h.2\u27e9\n    exact (IntegrableAtFilter.sup_iff.mpr h.1).filter_mono cocompact_le_atBot_atTop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal", "Filter"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u2074 : MeasurableSpace X\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : CompactIccSpace X\n\u22a2 Integrable f \u03bc \u2194 (IntegrableAtFilter f atBot \u03bc \u2227 IntegrableAtFilter f atTop \u03bc) \u2227 LocallyIntegrable f \u03bc"}, {"line": "constructor", "tactic_state": "case mp\nX : Type u_1\nE : Type u_3\ninst\u271d\u2074 : MeasurableSpace X\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : CompactIccSpace X\n\u22a2 Integrable f \u03bc \u2192 (IntegrableAtFilter f atBot \u03bc \u2227 IntegrableAtFilter f atTop \u03bc) \u2227 LocallyIntegrable f \u03bc\n---\ncase mpr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2074 : MeasurableSpace X\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : CompactIccSpace X\n\u22a2 (IntegrableAtFilter f atBot \u03bc \u2227 IntegrableAtFilter f atTop \u03bc) \u2227 LocallyIntegrable f \u03bc \u2192 Integrable f \u03bc"}, {"line": "\u00b7 exact fun hf \u21a6 \u27e8\u27e8hf.integrableAtFilter _, hf.integrableAtFilter _\u27e9, hf.locallyIntegrable\u27e9", "tactic_state": "case mpr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2074 : MeasurableSpace X\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b9 : LinearOrder X\ninst\u271d : CompactIccSpace X\n\u22a2 (IntegrableAtFilter f atBot \u03bc \u2227 IntegrableAtFilter f atTop \u03bc) \u2227 LocallyIntegrable f \u03bc \u2192 Integrable f \u03bc"}, {"line": "\u00b7 refine fun h \u21a6 integrable_iff_integrableAtFilter_cocompact.mpr \u27e8?_, h.2\u27e9\n    exact (IntegrableAtFilter.sup_iff.mpr h.1).filter_mono cocompact_le_atBot_atTop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_iff_integrableAtFilter_atBot [LinearOrder X] [OrderTop X] [CompactIccSpace X] :\n    Integrable f \u03bc \u2194 IntegrableAtFilter f atBot \u03bc \u2227 LocallyIntegrable f \u03bc := by\n  constructor\n  \u00b7 exact fun hf \u21a6 \u27e8hf.integrableAtFilter _, hf.locallyIntegrable\u27e9\n  \u00b7 refine fun h \u21a6 integrable_iff_integrableAtFilter_cocompact.mpr \u27e8?_, h.2\u27e9\n    exact h.1.filter_mono cocompact_le_atBot\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal", "Filter"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace X\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : OrderTop X\ninst\u271d : CompactIccSpace X\n\u22a2 Integrable f \u03bc \u2194 IntegrableAtFilter f atBot \u03bc \u2227 LocallyIntegrable f \u03bc"}, {"line": "constructor", "tactic_state": "case mp\nX : Type u_1\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace X\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : OrderTop X\ninst\u271d : CompactIccSpace X\n\u22a2 Integrable f \u03bc \u2192 IntegrableAtFilter f atBot \u03bc \u2227 LocallyIntegrable f \u03bc\n---\ncase mpr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace X\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : OrderTop X\ninst\u271d : CompactIccSpace X\n\u22a2 IntegrableAtFilter f atBot \u03bc \u2227 LocallyIntegrable f \u03bc \u2192 Integrable f \u03bc"}, {"line": "\u00b7 exact fun hf \u21a6 \u27e8hf.integrableAtFilter _, hf.locallyIntegrable\u27e9", "tactic_state": "case mpr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace X\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u00b2 : LinearOrder X\ninst\u271d\u00b9 : OrderTop X\ninst\u271d : CompactIccSpace X\n\u22a2 IntegrableAtFilter f atBot \u03bc \u2227 LocallyIntegrable f \u03bc \u2192 Integrable f \u03bc"}, {"line": "\u00b7 refine fun h \u21a6 integrable_iff_integrableAtFilter_cocompact.mpr \u27e8?_, h.2\u27e9\n    exact h.1.filter_mono cocompact_le_atBot", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.memLp_isCompact [IsFiniteMeasureOnCompacts \u03bc] (hs : IsCompact s)\n    (hmono : MonotoneOn f s) : MemLp f p (\u03bc.restrict s) := by\n  obtain rfl | h := s.eq_empty_or_nonempty\n  \u00b7 simp\n  \u00b7 exact hmono.memLp_of_measure_ne_top (hs.isLeast_sInf h) (hs.isGreatest_sSup h)\n      hs.measure_lt_top.ne hs.measurableSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LocallyIntegrable.lean", "context": {"open": ["MeasureTheory MeasureTheory.Measure Set Function TopologicalSpace Bornology", "scoped Topology Interval ENNReal", "Filter", "MeasureTheory", "scoped Interval in", "scoped ENNReal"], "variables": ["{X Y E F R : Type*} [MeasurableSpace X] [TopologicalSpace X]", "[MeasurableSpace Y] [TopologicalSpace Y]", "[NormedAddCommGroup E] [NormedAddCommGroup F] {f g : X \u2192 E} {\u03bc : Measure X} {s : Set X}", "{a : X}", "[OpensMeasurableSpace X]", "{K : Set X} {a b : X}", "[IsFiniteMeasureOnCompacts \u03bc]", "[BorelSpace X] [ConditionallyCompleteLinearOrder X] [ConditionallyCompleteLinearOrder E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d\u2078 : MeasurableSpace X\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d\u2075 : OpensMeasurableSpace X\ninst\u271d\u2074 : IsFiniteMeasureOnCompacts \u03bc\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder X\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\np : ENNReal\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nhs : IsCompact s\nhmono : MonotoneOn f s\n\u22a2 MemLp f p (\u03bc.restrict s)"}, {"line": "obtain rfl | h := s.eq_empty_or_nonempty", "tactic_state": "case inl\nX : Type u_1\nE : Type u_3\ninst\u271d\u2078 : MeasurableSpace X\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ninst\u271d\u2075 : OpensMeasurableSpace X\ninst\u271d\u2074 : IsFiniteMeasureOnCompacts \u03bc\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder X\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\np : ENNReal\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nhs : IsCompact \u2205\nhmono : MonotoneOn f \u2205\n\u22a2 MemLp f p (\u03bc.restrict \u2205)\n---\ncase inr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2078 : MeasurableSpace X\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d\u2075 : OpensMeasurableSpace X\ninst\u271d\u2074 : IsFiniteMeasureOnCompacts \u03bc\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder X\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\np : ENNReal\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nhs : IsCompact s\nhmono : MonotoneOn f s\nh : s.Nonempty\n\u22a2 MemLp f p (\u03bc.restrict s)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nX : Type u_1\nE : Type u_3\ninst\u271d\u2078 : MeasurableSpace X\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : NormedAddCommGroup E\nf : X \u2192 E\n\u03bc : Measure X\ns : Set X\ninst\u271d\u2075 : OpensMeasurableSpace X\ninst\u271d\u2074 : IsFiniteMeasureOnCompacts \u03bc\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : ConditionallyCompleteLinearOrder X\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\np : ENNReal\ninst\u271d : IsFiniteMeasureOnCompacts \u03bc\nhs : IsCompact s\nhmono : MonotoneOn f s\nh : s.Nonempty\n\u22a2 MemLp f p (\u03bc.restrict s)"}, {"line": "\u00b7 exact hmono.memLp_of_measure_ne_top (hs.isLeast_sInf h) (hs.isGreatest_sSup h)\n      hs.measure_lt_top.ne hs.measurableSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem simpleFunc_bot {\u03b1} (f : @SimpleFunc \u03b1 \u22a5 \u03b2) [Nonempty \u03b2] : \u2203 c, \u2200 x, f x = c := by\n  have hf_meas := @SimpleFunc.measurableSet_fiber \u03b1 _ \u22a5 f\n  simp_rw [MeasurableSpace.measurableSet_bot_iff] at hf_meas\n  exact (exists_eq_const_of_preimage_singleton hf_meas).imp fun c hc \u21a6 congr_fun hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_5\nf : SimpleFunc \u03b1 \u03b2\ninst\u271d : Nonempty \u03b2\n\u22a2 \u2203 c, \u2200 (x : \u03b1), f x = c"}, {"line": "have hf_meas := @SimpleFunc.measurableSet_fiber \u03b1 _ \u22a5 f", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_5\nf : SimpleFunc \u03b1 \u03b2\ninst\u271d : Nonempty \u03b2\nhf_meas : \u2200 (x : \u03b2), MeasurableSet (\u21d1f \u207b\u00b9' {x})\n\u22a2 \u2203 c, \u2200 (x : \u03b1), f x = c"}, {"line": "simp_rw [MeasurableSpace.measurableSet_bot_iff] at hf_meas", "tactic_state": "\u03b2 : Type u_2\n\u03b1 : Type u_5\nf : SimpleFunc \u03b1 \u03b2\ninst\u271d : Nonempty \u03b2\nhf_meas : \u2200 (x : \u03b2), \u21d1f \u207b\u00b9' {x} = \u2205 \u2228 \u21d1f \u207b\u00b9' {x} = univ\n\u22a2 \u2203 c, \u2200 (x : \u03b1), f x = c"}, {"line": "exact (exists_eq_const_of_preimage_singleton hf_meas).imp fun c hc \u21a6 congr_fun hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_preimage_singleton (f : \u03b1 \u2192\u209b \u03b2) (g : \u03b1 \u2192\u209b \u03b3) (b : \u03b2) (c : \u03b3) :\n    pair f g \u207b\u00b9' {(b, c)} = f \u207b\u00b9' {b} \u2229 g \u207b\u00b9' {c} := by\n  rw [\u2190 singleton_prod_singleton]\n  exact pair_preimage _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : MeasurableSpace \u03b1\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nx\u271d : Sort u_3\npair : x\u271d\nf : \u03b1 \u2192 sorry\ng : \u03b1 \u2192 sorry\nb : \u03b2\nc : \u03b3\n\u22a2 sorry \u207b\u00b9' {(b, c)} = f \u207b\u00b9' sorry \u2229 g \u207b\u00b9' sorry"}, {"line": "rw [\u2190 singleton_prod_singleton]", "tactic_state": "\u03b1 : Type u_6\ninst\u271d : MeasurableSpace \u03b1\n\u03b2 : Type u_1\n\u03b3 : Type u_2\nx\u271d : Sort u_3\npair : x\u271d\nf : \u03b1 \u2192 sorry\ng : \u03b1 \u2192 sorry\nb : \u03b2\nc : \u03b3\n\u22a2 sorry \u207b\u00b9' {b} \u00d7\u02e2 {c} = f \u207b\u00b9' sorry \u2229 g \u207b\u00b9' sorry"}, {"line": "exact pair_preimage _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrict_univ (f : \u03b1 \u2192\u209b \u03b2) : restrict f univ = f := by simp [restrict]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]", "{K : Type*}", "[Preorder \u03b2] {s : Set \u03b1} {f f\u2081 f\u2082 g g\u2081 g\u2082 : \u03b1 \u2192\u209b \u03b2} {hs : MeasurableSet s}", "[Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\n\u22a2 sorry = f"}, {"line": "simp [restrict]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\n\u22a2 sorry () = f"}]}
{"declaration": "theorem restrict_empty (f : \u03b1 \u2192\u209b \u03b2) : restrict f \u2205 = 0 := by simp [restrict]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]", "{K : Type*}", "[Preorder \u03b2] {s : Set \u03b1} {f f\u2081 f\u2082 g g\u2081 g\u2082 : \u03b1 \u2192\u209b \u03b2} {hs : MeasurableSet s}", "[Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\n\u22a2 sorry = 0"}, {"line": "simp [restrict]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem restrict_preimage (f : \u03b1 \u2192\u209b \u03b2) {s : Set \u03b1} (hs : MeasurableSet s) {t : Set \u03b2}\n    (ht : (0 : \u03b2) \u2209 t) : restrict f s \u207b\u00b9' t = s \u2229 f \u207b\u00b9' t := by\n  simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]", "{K : Type*}", "[Preorder \u03b2] {s : Set \u03b1} {f f\u2081 f\u2082 g g\u2081 g\u2082 : \u03b1 \u2192\u209b \u03b2} {hs : MeasurableSet s}", "[Zero \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Zero \u03b2\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\ns : Set \u03b1\nhs : MeasurableSet s\nt : Set \u03b2\nht : 0 \u2209 t\n\u22a2 sorry \u207b\u00b9' t = s \u2229 f \u207b\u00b9' sorry"}, {"line": "simp [hs, indicator_preimage_of_not_mem _ _ ht, inter_comm]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b2\ninst\u271d : Zero \u03b2\nx\u271d : Sort u_2\nrestrict : x\u271d\nf : \u03b1 \u2192 sorry\ns : Set \u03b1\nhs : MeasurableSet s\nt : Set \u03b2\nht : 0 \u2209 t\n\u22a2 sorry () \u207b\u00b9' t = s \u2229 f \u207b\u00b9' sorry ()"}]}
{"declaration": "theorem Measurable.ennreal_induction {motive : (\u03b1 \u2192 \u211d\u22650\u221e) \u2192 Prop}\n    (indicator : \u2200 (c : \u211d\u22650\u221e) \u2983s\u2984, MeasurableSet s \u2192 motive (Set.indicator s fun _ => c))\n    (add : \u2200 \u2983f g : \u03b1 \u2192 \u211d\u22650\u221e\u2984, Disjoint (support f) (support g) \u2192\n      Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g))\n    (iSup : \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 \u211d\u22650\u221e\u2984, (\u2200 n, Measurable (f n)) \u2192 Monotone f \u2192\n      (\u2200 n, motive (f n)) \u2192 motive fun x => \u2a06 n, f n x)\n    \u2983f : \u03b1 \u2192 \u211d\u22650\u221e\u2984 (hf : Measurable f) : motive f := by\n  convert iSup (fun n => (eapprox f n).measurable) (monotone_eapprox f) _ using 2\n  \u00b7 rw [iSup_eapprox_apply hf]\n  \u00b7 exact fun n =>\n      SimpleFunc.induction (fun c s hs => indicator c hs)\n        (fun f g hfg hf hg => add hfg f.measurable g.measurable hf hg) (eapprox f n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFunc.lean", "context": {"open": ["Set hiding restrict restrict_apply", "Filter ENNReal", "Function (support)", "Topology NNReal ENNReal MeasureTheory", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Finset Function", "scoped Classical in", "MeasureTheory MeasureTheory.SimpleFunc"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[MeasurableSpace \u03b1]", "{K : Type*}", "[Preorder \u03b2] {s : Set \u03b1} {f f\u2081 f\u2082 g g\u2081 g\u2082 : \u03b1 \u2192\u209b \u03b2} {hs : MeasurableSet s}", "[Zero \u03b2]", "[SemilatticeSup \u03b2] [OrderBot \u03b2] [Zero \u03b2]", "{f : \u03b1 \u2192 \u211d\u22650\u221e}", "{m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{m : MeasurableSpace \u03b1} [Zero \u03b2] [Zero \u03b3] {\u03bc : Measure \u03b1} {f : \u03b1 \u2192\u209b \u03b2}", "{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 motive f"}, {"line": "convert iSup (fun n => (eapprox f n).measurable) (monotone_eapprox f) _ using 2", "tactic_state": "case h.e'_1.h\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\nx\u271d : \u03b1\n\u22a2 f x\u271d = \u2a06 n, ?convert_1 n x\u271d\n---\ncase convert_1\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 \u2115 \u2192 \u03b1 \u2192 ENNReal\n---\ncase convert_2\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 \u2200 (n : \u2115), motive (?convert_1 n)"}, {"line": "\u00b7 rw [iSup_eapprox_apply hf]", "tactic_state": "case convert_1\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 \u2115 \u2192 \u03b1 \u2192 ENNReal\n---\ncase convert_2\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 \u2200 (n : \u2115), motive (?convert_1 n)"}, {"line": "\u00b7 exact fun n =>\n      SimpleFunc.induction (fun c s hs => indicator c hs)\n        (fun f g hfg hf hg => add hfg f.measurable g.measurable hf hg) (eapprox f n)", "tactic_state": "case convert_2\n\u03b1 : Type u_6\nm\u03b1 : MeasurableSpace \u03b1\nmotive : (\u03b1 \u2192 ENNReal) \u2192 Prop\nindicator : \u2200 (c : ENNReal) \u2983s : Set \u03b1\u2984, MeasurableSet s \u2192 motive (s.indicator fun x => c)\nadd :\n  \u2200 \u2983f g : \u03b1 \u2192 ENNReal\u2984,\n    Disjoint (support f) (support g) \u2192 Measurable f \u2192 Measurable g \u2192 motive f \u2192 motive g \u2192 motive (f + g)\niSup :\n  \u2200 \u2983f : \u2115 \u2192 \u03b1 \u2192 ENNReal\u2984,\n    (\u2200 (n : \u2115), Measurable (f n)) \u2192 Monotone f \u2192 (\u2200 (n : \u2115), motive (f n)) \u2192 motive fun x => \u2a06 n, f n x\nf : \u03b1 \u2192 ENNReal\nhf : Measurable f\n\u22a2 \u2115 \u2192 motive sorry"}]}
{"declaration": "theorem approxOn_mem {f : \u03b2 \u2192 \u03b1} (hf : Measurable f) {s : Set \u03b1} {y\u2080 : \u03b1} (h\u2080 : y\u2080 \u2208 s)\n    [SeparableSpace s] (n : \u2115) (x : \u03b2) : approxOn f hf s y\u2080 h\u2080 n x \u2208 s := by\n  haveI : Nonempty s := \u27e8\u27e8y\u2080, h\u2080\u27e9\u27e9\n  suffices \u2200 n, (Nat.casesOn n y\u2080 ((\u2191) \u2218 denseSeq s) : \u03b1) \u2208 s by apply this\n  rintro (_ | n)\n  exacts [h\u2080, Subtype.mem _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SimpleFuncDense.lean", "context": {"open": ["Set Function Filter TopologicalSpace ENNReal EMetric Finset", "Topology ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b9 E F \ud835\udd5c : Type*}", "[MeasurableSpace \u03b1] [PseudoEMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\nx\u271d : Sort u_7\napproxOn : x\u271d\nf : \u03b2 \u2192 \u03b1\nhf : Measurable f\ns : Set \u03b1\ny\u2080 : \u03b1\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nn : \u2115\nx : \u03b2\n\u22a2 sorry \u2208 s"}, {"line": "haveI : Nonempty s := \u27e8\u27e8y\u2080, h\u2080\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\nx\u271d : Sort u_7\napproxOn : x\u271d\nf : \u03b2 \u2192 \u03b1\nhf : Measurable f\ns : Set \u03b1\ny\u2080 : \u03b1\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nn : \u2115\nx : \u03b2\nthis : Nonempty \u2191s\n\u22a2 sorry \u2208 s"}, {"line": "suffices \u2200 n, (Nat.casesOn n y\u2080 ((\u2191) \u2218 denseSeq s) : \u03b1) \u2208 s by apply this", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\nx\u271d : Sort u_7\napproxOn : x\u271d\nf : \u03b2 \u2192 \u03b1\nhf : Measurable f\ns : Set \u03b1\ny\u2080 : \u03b1\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nn : \u2115\nx : \u03b2\nthis : Nonempty \u2191s\n\u22a2 \u2200 (n : \u2115), Nat.casesOn n y\u2080 (Subtype.val \u2218 sorry) \u2208 s"}, {"line": "rintro (_ | n)", "tactic_state": "case zero\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\nx\u271d : Sort u_7\napproxOn : x\u271d\nf : \u03b2 \u2192 \u03b1\nhf : Measurable f\ns : Set \u03b1\ny\u2080 : \u03b1\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nn : \u2115\nx : \u03b2\nthis : Nonempty \u2191s\n\u22a2 Nat.casesOn 0 y\u2080 (Subtype.val \u2218 sorry) \u2208 s\n---\ncase succ\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\nx\u271d : Sort u_7\napproxOn : x\u271d\nf : \u03b2 \u2192 \u03b1\nhf : Measurable f\ns : Set \u03b1\ny\u2080 : \u03b1\nh\u2080 : y\u2080 \u2208 s\ninst\u271d : SeparableSpace \u2191s\nn\u271d : \u2115\nx : \u03b2\nthis : Nonempty \u2191s\nn : \u2115\n\u22a2 Nat.casesOn (n + 1) y\u2080 (Subtype.val \u2218 sorry) \u2208 s"}, {"line": "exacts [h\u2080, Subtype.mem _]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem condExp_bot_ae_eq (f : \u03b1 \u2192 E) :\n    \u03bc[f|\u22a5] =\u1d50[\u03bc] fun _ => (\u03bc.real Set.univ)\u207b\u00b9 \u2022 \u222b x, f x \u2202\u03bc := by\n  rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc\n  \u00b7 rw [ae_zero]; exact eventually_bot\n  \u00b7 exact Eventually.of_forall <| congr_fun (condExp_bot' f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory.Lp Filter", "scoped ENNReal Topology MeasureTheory", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 E \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 E}", "[NormedAddCommGroup E] [NormedSpace \u211d E] [CompleteSpace E]", "(m) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : MeasureTheory.Measure \u03b1\nf : \u03b1 \u2192 E\n\u22a2 \u03bc[f|\u22a5] =\u1d50[\u03bc] fun x => (\u03bc.real Set.univ)\u207b\u00b9 \u2022 \u222b (x : \u03b1), f x \u2202\u03bc"}, {"line": "rcases eq_zero_or_neZero \u03bc with rfl | h\u03bc", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 E\n\u22a2 0[f|\u22a5] =\u1d50[0] fun x => (MeasureTheory.Measure.real 0 Set.univ)\u207b\u00b9 \u2022 \u222b (x : \u03b1), f x \u22020\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : MeasureTheory.Measure \u03b1\nf : \u03b1 \u2192 E\nh\u03bc : NeZero \u03bc\n\u22a2 \u03bc[f|\u22a5] =\u1d50[\u03bc] fun x => (\u03bc.real Set.univ)\u207b\u00b9 \u2022 \u222b (x : \u03b1), f x \u2202\u03bc"}, {"line": "\u00b7 rw [ae_zero]; exact eventually_bot", "tactic_state": "case inr\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : MeasureTheory.Measure \u03b1\nf : \u03b1 \u2192 E\nh\u03bc : NeZero \u03bc\n\u22a2 \u03bc[f|\u22a5] =\u1d50[\u03bc] fun x => (\u03bc.real Set.univ)\u207b\u00b9 \u2022 \u222b (x : \u03b1), f x \u2202\u03bc"}, {"line": "\u00b7 exact Eventually.of_forall <| congr_fun (condExp_bot' f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma condExp_ofNat (n : \u2115) [n.AtLeastTwo] (f : \u03b1 \u2192 R) :\n    \u03bc[ofNat(n) * f|m] =\u1d50[\u03bc] ofNat(n) * \u03bc[f|m] := by\n  simpa [Nat.cast_smul_eq_nsmul] using condExp_smul (\u03bc := \u03bc) (m := m) (n : \u211d) f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/ConditionalExpectation/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory.Lp Filter", "scoped ENNReal Topology MeasureTheory", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 E \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 E}", "[NormedAddCommGroup E] [NormedSpace \u211d E] [CompleteSpace E]", "(m) in", "[InnerProductSpace \ud835\udd5c E]", "[InnerProductSpace \u211d E]", "{R : Type*} [NormedRing R] [NormedSpace \u211d R] [CompleteSpace R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : NormedRing R\ninst\u271d\u00b3 : NormedSpace \u211d R\ninst\u271d\u00b2 : CompleteSpace R\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : MeasureTheory.Measure \u03b1\nm : MeasurableSpace \u03b1\nn : \u2115\ninst\u271d : n.AtLeastTwo\nf : \u03b1 \u2192 R\n\u22a2 \u03bc[OfNat.ofNat n * f|m] =\u1d50[\u03bc] OfNat.ofNat n * \u03bc[f|m]"}, {"line": "simpa [Nat.cast_smul_eq_nsmul] using condExp_smul (\u03bc := \u03bc) (m := m) (n : \u211d) f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_coeFn (f : \u03b1 \u2192\u2081[\u03bc] \u03b2) : Integrable f \u03bc := by\n  rw [\u2190 memLp_one_iff_integrable]\n  exact Lp.memLp f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/AEEqFun.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2]", "{\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [IsBoundedSMul \ud835\udd5c \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u21a5(Lp \u03b2 1 \u03bc)\n\u22a2 Integrable (\u2191\u2191f) \u03bc"}, {"line": "rw [\u2190 memLp_one_iff_integrable]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u21a5(Lp \u03b2 1 \u03bc)\n\u22a2 MemLp (\u2191\u2191f) 1 \u03bc"}, {"line": "exact Lp.memLp f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_def (f : \u03b1 \u2192\u2081[\u03bc] \u03b2) : \u2016f\u2016 = (\u222b\u207b a, \u2016f a\u2016\u2091 \u2202\u03bc).toReal := by\n  simp [Lp.norm_def, eLpNorm, eLpNorm'_eq_lintegral_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/AEEqFun.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2]", "{\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [IsBoundedSMul \ud835\udd5c \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u21a5(Lp \u03b2 1 \u03bc)\n\u22a2 \u2016f\u2016 = (\u222b\u207b (a : \u03b1), \u2016\u2191\u2191f a\u2016\u2091 \u2202\u03bc).toReal"}, {"line": "simp [Lp.norm_def, eLpNorm, eLpNorm'_eq_lintegral_enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toL1_coeFn (f : \u03b1 \u2192\u2081[\u03bc] \u03b2) (hf : Integrable f \u03bc) : hf.toL1 f = f := by\n  simp [Integrable.toL1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/AEEqFun.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2]", "{\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [IsBoundedSMul \ud835\udd5c \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u21a5(Lp \u03b2 1 \u03bc)\nhf : Integrable (\u2191\u2191f) \u03bc\n\u22a2 Integrable.toL1 (\u2191\u2191f) hf = f"}, {"line": "simp [Integrable.toL1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_toL1 {f : \u03b1 \u2192 \u03b2} (hf : Integrable f \u03bc) : \u2016hf.toL1 f\u2016\u2091 = \u222b\u207b a, \u2016f a\u2016\u2091 \u2202\u03bc := by\n  simpa [Integrable.toL1, eLpNorm, eLpNorm', enorm] using ENNReal.coe_toNNReal hf.2.ne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/AEEqFun.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2]", "{\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [IsBoundedSMul \ud835\udd5c \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Integrable f \u03bc\n\u22a2 \u2016Integrable.toL1 f hf\u2016\u2091 = \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc"}, {"line": "simpa [Integrable.toL1, eLpNorm, eLpNorm', enorm] using ENNReal.coe_toNNReal hf.2.ne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_enorm_zero : \u222b\u207b _ : \u03b1, \u2016(0 : \u03b2)\u2016\u2091 \u2202\u03bc = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\n\u22a2 \u222b\u207b (x : \u03b1), \u20160\u2016\u2091 \u2202\u03bc = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFiniteIntegral_iff_ofNNReal {f : \u03b1 \u2192 \u211d\u22650} :\n    HasFiniteIntegral (fun x => (f x : \u211d)) \u03bc \u2194 (\u222b\u207b a, f a \u2202\u03bc) < \u221e := by\n  simp [hasFiniteIntegral_iff_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 NNReal\n\u22a2 HasFiniteIntegral (fun x => \u2191(f x)) \u03bc \u2194 \u222b\u207b (a : \u03b1), \u2191(f a) \u2202\u03bc < \u22a4"}, {"line": "simp [hasFiniteIntegral_iff_norm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFiniteIntegral_const_iff_enorm {c : \u03b5} (hc : \u2016c\u2016\u2091 \u2260 \u221e) :\n    HasFiniteIntegral (fun _ : \u03b1 \u21a6 c) \u03bc \u2194 \u2016c\u2016\u2091 = 0 \u2228 IsFiniteMeasure \u03bc := by\n  simpa [hasFiniteIntegral_iff_enorm, lt_top_iff_ne_top, ENNReal.mul_eq_top,\n    or_iff_not_imp_left, isFiniteMeasure_iff] using fun h h' \u21a6 (hc h').elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nc : \u03b5\nhc : \u2016c\u2016\u2091 \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun x => c) \u03bc \u2194 \u2016c\u2016\u2091 = 0 \u2228 IsFiniteMeasure \u03bc"}, {"line": "simpa [hasFiniteIntegral_iff_enorm, lt_top_iff_ne_top, ENNReal.mul_eq_top,\n    or_iff_not_imp_left, isFiniteMeasure_iff] using fun h h' \u21a6 (hc h').elim", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasFiniteIntegral_const_iff_isFiniteMeasure_enorm {c : \u03b5} (hc : \u2016c\u2016\u2091 \u2260 0) (hc' : \u2016c\u2016\u2091 \u2260 \u221e) :\n    HasFiniteIntegral (fun _ \u21a6 c) \u03bc \u2194 IsFiniteMeasure \u03bc := by\n  simp [hasFiniteIntegral_const_iff_enorm hc', hc, isFiniteMeasure_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nc : \u03b5\nhc : \u2016c\u2016\u2091 \u2260 0\nhc' : \u2016c\u2016\u2091 \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun x => c) \u03bc \u2194 IsFiniteMeasure \u03bc"}, {"line": "simp [hasFiniteIntegral_const_iff_enorm hc', hc, isFiniteMeasure_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nc : \u03b5\nhc : \u2016c\u2016\u2091 \u2260 0\nhc' : \u2016c\u2016\u2091 \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun x => c) \u03bc \u2194 \u03bc univ < \u22a4"}]}
{"declaration": "theorem HasFiniteIntegral.of_mem_Icc [IsFiniteMeasure \u03bc] (a b : \u211d) {X : \u03b1 \u2192 \u211d}\n    (h : \u2200\u1d50 \u03c9 \u2202\u03bc, X \u03c9 \u2208 Set.Icc a b) :\n    HasFiniteIntegral X \u03bc := by\n  apply (hasFiniteIntegral_const (max \u2016a\u2016 \u2016b\u2016)).mono'\n  filter_upwards [h.mono fun \u03c9 h \u21a6 h.1, h.mono fun \u03c9 h \u21a6 h.2] with \u03c9 using abs_le_max_abs_abs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\na b : \u211d\nX : \u03b1 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, X \u03c9 \u2208 Icc a b\n\u22a2 HasFiniteIntegral X \u03bc"}, {"line": "apply (hasFiniteIntegral_const (max \u2016a\u2016 \u2016b\u2016)).mono'", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\na b : \u211d\nX : \u03b1 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, X \u03c9 \u2208 Icc a b\n\u22a2 \u2200\u1d50 (a_1 : \u03b1) \u2202\u03bc, \u2016X a_1\u2016 \u2264 max \u2016a\u2016 \u2016b\u2016\n---\n\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\na b : \u211d\nX : \u03b1 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, X \u03c9 \u2208 Icc a b\n\u22a2 IsFiniteMeasure \u03bc"}, {"line": "filter_upwards [h.mono fun \u03c9 h \u21a6 h.1, h.mono fun \u03c9 h \u21a6 h.2] with \u03c9 using abs_le_max_abs_abs", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\na b : \u211d\nX : \u03b1 \u2192 \u211d\nh : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, X \u03c9 \u2208 Icc a b\n\u22a2 IsFiniteMeasure \u03bc"}]}
{"declaration": "theorem HasFiniteIntegral.add_measure {f : \u03b1 \u2192 \u03b5} (h\u03bc : HasFiniteIntegral f \u03bc)\n    (h\u03bd : HasFiniteIntegral f \u03bd) : HasFiniteIntegral f (\u03bc + \u03bd) := by\n  simp only [HasFiniteIntegral] at *\n  simp only [lintegral_add_measure] at *\n  exact add_lt_top.2 \u27e8h\u03bc, h\u03bd\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh\u03bc : HasFiniteIntegral f \u03bc\nh\u03bd : HasFiniteIntegral f \u03bd\n\u22a2 HasFiniteIntegral f (\u03bc + \u03bd)"}, {"line": "simp only [HasFiniteIntegral] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh\u03bc : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc < \u22a4\nh\u03bd : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bd < \u22a4\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202(\u03bc + \u03bd) < \u22a4"}, {"line": "simp only [lintegral_add_measure] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh\u03bc : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc < \u22a4\nh\u03bd : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bd < \u22a4\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc + \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bd < \u22a4"}, {"line": "exact add_lt_top.2 \u27e8h\u03bc, h\u03bd\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFiniteIntegral.smul_measure {f : \u03b1 \u2192 \u03b5} (h : HasFiniteIntegral f \u03bc) {c : \u211d\u22650\u221e}\n    (hc : c \u2260 \u221e) : HasFiniteIntegral f (c \u2022 \u03bc) := by\n  simp only [HasFiniteIntegral] at *\n  simp only [lintegral_smul_measure] at *\n  exact mul_lt_top hc.lt_top h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh : HasFiniteIntegral f \u03bc\nc : ENNReal\nhc : c \u2260 \u22a4\n\u22a2 HasFiniteIntegral f (c \u2022 \u03bc)"}, {"line": "simp only [HasFiniteIntegral] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc < \u22a4\nc : ENNReal\nhc : c \u2260 \u22a4\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202c \u2022 \u03bc < \u22a4"}, {"line": "simp only [lintegral_smul_measure] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nh : \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc < \u22a4\nc : ENNReal\nhc : c \u2260 \u22a4\n\u22a2 c \u2022 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc < \u22a4"}, {"line": "exact mul_lt_top hc.lt_top h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFiniteIntegral_zero_measure {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192 \u03b5) :\n    HasFiniteIntegral f (0 : Measure \u03b1) := by\n  simp only [HasFiniteIntegral]\n  simp only [lintegral_zero_measure]\n  simp only [zero_lt_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\ninst\u271d : ENorm \u03b5\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 HasFiniteIntegral f 0"}, {"line": "simp only [HasFiniteIntegral]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\ninst\u271d : ENorm \u03b5\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u22020 < \u22a4"}, {"line": "simp only [lintegral_zero_measure]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\ninst\u271d : ENorm \u03b5\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 0 < \u22a4"}, {"line": "simp only [zero_lt_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFiniteIntegral_zero {\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5] :\n    HasFiniteIntegral (fun _ : \u03b1 => (0 : \u03b5)) \u03bc := by\n  simp [hasFiniteIntegral_iff_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']", "(\u03b1 \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b5 : Type u_6\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\n\u22a2 HasFiniteIntegral (fun x => 0) \u03bc"}, {"line": "simp [hasFiniteIntegral_iff_enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFiniteIntegral.enorm {f : \u03b1 \u2192 \u03b5} (hfi : HasFiniteIntegral f \u03bc) :\n    HasFiniteIntegral (\u2016f \u00b7\u2016\u2091) \u03bc := by simpa [hasFiniteIntegral_iff_enorm] using hfi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']", "(\u03b1 \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : ENorm \u03b5\nf : \u03b1 \u2192 \u03b5\nhfi : HasFiniteIntegral f \u03bc\n\u22a2 HasFiniteIntegral (fun x => \u2016f x\u2016\u2091) \u03bc"}, {"line": "simpa [hasFiniteIntegral_iff_enorm] using hfi", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasFiniteIntegral_toReal_iff {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200\u1d50 x \u2202\u03bc, f x \u2260 \u221e) :\n    HasFiniteIntegral (fun x \u21a6 (f x).toReal) \u03bc \u2194 \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e := by\n  have : \u2200\u1d50 x \u2202\u03bc, .ofReal (f x).toReal = f x := by filter_upwards [hf] with x hx; simp [hx]\n  simp [hasFiniteIntegral_iff_enorm, Real.enorm_of_nonneg ENNReal.toReal_nonneg,\n    lintegral_congr_ae this, lt_top_iff_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']", "(\u03b1 \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x \u2260 \u22a4\n\u22a2 HasFiniteIntegral (fun x => (f x).toReal) \u03bc \u2194 \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4"}, {"line": "have : \u2200\u1d50 x \u2202\u03bc, .ofReal (f x).toReal = f x := by filter_upwards [hf] with x hx; simp [hx]", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x \u2260 \u22a4\nthis : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, ENNReal.ofReal (f x).toReal = f x\n\u22a2 HasFiniteIntegral (fun x => (f x).toReal) \u03bc \u2194 \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4"}, {"line": "simp [hasFiniteIntegral_iff_enorm, Real.enorm_of_nonneg ENNReal.toReal_nonneg,\n    lintegral_congr_ae this, lt_top_iff_ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isFiniteMeasure_withDensity_ofReal {f : \u03b1 \u2192 \u211d} (hfi : HasFiniteIntegral f \u03bc) :\n    IsFiniteMeasure (\u03bc.withDensity fun x => ENNReal.ofReal <| f x) := by\n  refine isFiniteMeasure_withDensity ((lintegral_mono fun x => ?_).trans_lt hfi).ne\n  exact Real.ofReal_le_enorm (f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']", "(\u03b1 \u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhfi : HasFiniteIntegral f \u03bc\n\u22a2 IsFiniteMeasure (\u03bc.withDensity fun x => ENNReal.ofReal (f x))"}, {"line": "refine isFiniteMeasure_withDensity ((lintegral_mono fun x => ?_).trans_lt hfi).ne", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\nhfi : HasFiniteIntegral f \u03bc\nx : \u03b1\n\u22a2 ENNReal.ofReal (f x) \u2264 \u2016f x\u2016\u2091"}, {"line": "exact Real.ofReal_le_enorm (f x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma HasFiniteIntegral.restrict (h : HasFiniteIntegral f \u03bc) {s : Set \u03b1} :\n    HasFiniteIntegral f (\u03bc.restrict s) := by\n  refine lt_of_le_of_lt ?_ h\n  simpa [Measure.restrict_univ] using lintegral_mono_set (subset_univ s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/HasFiniteIntegral.lean", "context": {"open": ["Topology ENNReal MeasureTheory NNReal", "Set Filter TopologicalSpace ENNReal EMetric MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5] [ENorm \u03b5']", "(\u03b1 \u03bc) in", "{F : \u2115 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {bound : \u03b1 \u2192 \u211d}", "{\ud835\udd5c : Type*}", "[MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 \u03b2}", "{E : Type*} [NormedAddCommGroup E] {f : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nE : Type u_7\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\nh : HasFiniteIntegral f \u03bc\ns : Set \u03b1\n\u22a2 HasFiniteIntegral f (\u03bc.restrict s)"}, {"line": "refine lt_of_le_of_lt ?_ h", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nE : Type u_7\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\nh : HasFiniteIntegral f \u03bc\ns : Set \u03b1\n\u22a2 \u222b\u207b (a : \u03b1) in s, \u2016f a\u2016\u2091 \u2202\u03bc \u2264 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc"}, {"line": "simpa [Measure.restrict_univ] using lintegral_mono_set (subset_univ s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memLp_one_iff_integrable {f : \u03b1 \u2192 \u03b2} : MemLp f 1 \u03bc \u2194 Integrable f \u03bc := by\n  simp_rw [Integrable, hasFiniteIntegral_iff_enorm, MemLp, eLpNorm_one_eq_lintegral_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 MemLp f 1 \u03bc \u2194 Integrable f \u03bc"}, {"line": "simp_rw [Integrable, hasFiniteIntegral_iff_enorm, MemLp, eLpNorm_one_eq_lintegral_enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integrable_const_iff_isFiniteMeasure {c : \u03b2} (hc : c \u2260 0) :\n    Integrable (fun _ \u21a6 c) \u03bc \u2194 IsFiniteMeasure \u03bc := by\n  simp [integrable_const_iff, hc, isFiniteMeasure_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nc : \u03b2\nhc : c \u2260 0\n\u22a2 Integrable (fun x => c) \u03bc \u2194 IsFiniteMeasure \u03bc"}, {"line": "simp [integrable_const_iff, hc, isFiniteMeasure_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MemLp.integrable_norm_rpow {f : \u03b1 \u2192 \u03b2} {p : \u211d\u22650\u221e} (hf : MemLp f p \u03bc) (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) : Integrable (fun x : \u03b1 => \u2016f x\u2016 ^ p.toReal) \u03bc := by\n  rw [\u2190 memLp_one_iff_integrable]\n  exact hf.norm_rpow hp_ne_zero hp_ne_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\np : ENNReal\nhf : MemLp f p \u03bc\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\n\u22a2 Integrable (fun x => \u2016f x\u2016 ^ p.toReal) \u03bc"}, {"line": "rw [\u2190 memLp_one_iff_integrable]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\np : ENNReal\nhf : MemLp f p \u03bc\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\n\u22a2 MemLp (fun x => \u2016f x\u2016 ^ p.toReal) 1 \u03bc"}, {"line": "exact hf.norm_rpow hp_ne_zero hp_ne_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MemLp.integrable_norm_pow {f : \u03b1 \u2192 \u03b2} {p : \u2115} (hf : MemLp f p \u03bc) (hp : p \u2260 0) :\n    Integrable (fun x : \u03b1 => \u2016f x\u2016 ^ p) \u03bc := by\n  simpa using hf.integrable_norm_rpow (mod_cast hp) (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\np : \u2115\nhf : MemLp f (\u2191p) \u03bc\nhp : p \u2260 0\n\u22a2 Integrable (fun x => \u2016f x\u2016 ^ p) \u03bc"}, {"line": "simpa using hf.integrable_norm_rpow (mod_cast hp) (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MemLp.integrable_norm_pow' [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 \u03b2} {p : \u2115} (hf : MemLp f p \u03bc) :\n    Integrable (fun x : \u03b1 => \u2016f x\u2016 ^ p) \u03bc := by simpa using hf.integrable_norm_rpow'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 \u03b2\np : \u2115\nhf : MemLp f (\u2191p) \u03bc\n\u22a2 Integrable (fun x => \u2016f x\u2016 ^ p) \u03bc"}, {"line": "simpa using hf.integrable_norm_rpow'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.of_measure_le_smul {\u03bc' : Measure \u03b1} {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) (h\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc)\n    {f : \u03b1 \u2192 \u03b2} (hf : Integrable f \u03bc) : Integrable f \u03bc' := by\n  rw [\u2190 memLp_one_iff_integrable] at hf \u22a2\n  exact hf.of_measure_le_smul hc h\u03bc'_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\n\u03bc' : Measure \u03b1\nc : ENNReal\nhc : c \u2260 \u22a4\nh\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc\nf : \u03b1 \u2192 \u03b2\nhf : Integrable f \u03bc\n\u22a2 Integrable f \u03bc'"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\n\u03bc' : Measure \u03b1\nc : ENNReal\nhc : c \u2260 \u22a4\nh\u03bc'_le : \u03bc' \u2264 c \u2022 \u03bc\nf : \u03b1 \u2192 \u03b2\nhf : MemLp f 1 \u03bc\n\u22a2 MemLp f 1 \u03bc'"}, {"line": "exact hf.of_measure_le_smul hc h\u03bc'_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.add_measure {f : \u03b1 \u2192 \u03b2} (h\u03bc : Integrable f \u03bc) (h\u03bd : Integrable f \u03bd) :\n    Integrable f (\u03bc + \u03bd) := by\n  simp_rw [\u2190 memLp_one_iff_integrable] at h\u03bc h\u03bd \u22a2\n  refine \u27e8h\u03bc.aestronglyMeasurable.add_measure h\u03bd.aestronglyMeasurable, ?_\u27e9\n  rw [eLpNorm_one_add_measure]\n  rw [ENNReal.add_lt_top]\n  exact \u27e8h\u03bc.eLpNorm_lt_top, h\u03bd.eLpNorm_lt_top\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u03bc : Integrable f \u03bc\nh\u03bd : Integrable f \u03bd\n\u22a2 Integrable f (\u03bc + \u03bd)"}, {"line": "simp_rw [\u2190 memLp_one_iff_integrable] at h\u03bc h\u03bd \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u03bc : MemLp f 1 \u03bc\nh\u03bd : MemLp f 1 \u03bd\n\u22a2 MemLp f 1 (\u03bc + \u03bd)"}, {"line": "refine \u27e8h\u03bc.aestronglyMeasurable.add_measure h\u03bd.aestronglyMeasurable, ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u03bc : MemLp f 1 \u03bc\nh\u03bd : MemLp f 1 \u03bd\n\u22a2 eLpNorm f 1 (\u03bc + \u03bd) < \u22a4"}, {"line": "rw [eLpNorm_one_add_measure]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u03bc : MemLp f 1 \u03bc\nh\u03bd : MemLp f 1 \u03bd\n\u22a2 eLpNorm f 1 \u03bc + eLpNorm f 1 \u03bd < \u22a4"}, {"line": "rw [ENNReal.add_lt_top]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh\u03bc : MemLp f 1 \u03bc\nh\u03bd : MemLp f 1 \u03bd\n\u22a2 eLpNorm f 1 \u03bc < \u22a4 \u2227 eLpNorm f 1 \u03bd < \u22a4"}, {"line": "exact \u27e8h\u03bc.eLpNorm_lt_top, h\u03bd.eLpNorm_lt_top\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.left_of_add_measure {f : \u03b1 \u2192 \u03b2} (h : Integrable f (\u03bc + \u03bd)) : Integrable f \u03bc := by\n  rw [\u2190 memLp_one_iff_integrable] at h \u22a2\n  exact h.left_of_add_measure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f (\u03bc + \u03bd)\n\u22a2 Integrable f \u03bc"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : MemLp f 1 (\u03bc + \u03bd)\n\u22a2 MemLp f 1 \u03bc"}, {"line": "exact h.left_of_add_measure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.right_of_add_measure {f : \u03b1 \u2192 \u03b2} (h : Integrable f (\u03bc + \u03bd)) :\n    Integrable f \u03bd := by\n  rw [\u2190 memLp_one_iff_integrable] at h \u22a2\n  exact h.right_of_add_measure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f (\u03bc + \u03bd)\n\u22a2 Integrable f \u03bd"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc \u03bd : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : MemLp f 1 (\u03bc + \u03bd)\n\u22a2 MemLp f 1 \u03bd"}, {"line": "exact h.right_of_add_measure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.smul_measure {f : \u03b1 \u2192 \u03b2} (h : Integrable f \u03bc) {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) :\n    Integrable f (c \u2022 \u03bc) := by\n  rw [\u2190 memLp_one_iff_integrable] at h \u22a2\n  exact h.smul_measure hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f \u03bc\nc : ENNReal\nhc : c \u2260 \u22a4\n\u22a2 Integrable f (c \u2022 \u03bc)"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : MemLp f 1 \u03bc\nc : ENNReal\nhc : c \u2260 \u22a4\n\u22a2 MemLp f 1 (c \u2022 \u03bc)"}, {"line": "exact h.smul_measure hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Integrable.to_average {f : \u03b1 \u2192 \u03b2} (h : Integrable f \u03bc) : Integrable f ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc) := by\n  rcases eq_or_ne \u03bc 0 with (rfl | hne)\n  \u00b7 rwa [smul_zero]\n  \u00b7 apply h.smul_measure\n    simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f \u03bc\n\u22a2 Integrable f ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)"}, {"line": "rcases eq_or_ne \u03bc 0 with (rfl | hne)", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f 0\n\u22a2 Integrable f ((0 univ)\u207b\u00b9 \u2022 0)\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f \u03bc\nhne : \u03bc \u2260 0\n\u22a2 Integrable f ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)"}, {"line": "\u00b7 rwa [smul_zero]", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Integrable f \u03bc\nhne : \u03bc \u2260 0\n\u22a2 Integrable f ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)"}, {"line": "\u00b7 apply h.smul_measure\n    simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_zero : Integrable (fun _ => (0 : \u03b2)) \u03bc := by\n  simp [Integrable, aestronglyMeasurable_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]", "(\u03b1 \u03b2 \u03bc)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "simp [Integrable, aestronglyMeasurable_const]", "tactic_state": "\u22a2 sorry ()"}]}
{"declaration": "theorem LipschitzWith.integrable_comp_iff_of_antilipschitz {K K'} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}\n    (hg : LipschitzWith K g) (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) :\n    Integrable (g \u2218 f) \u03bc \u2194 Integrable f \u03bc := by\n  simp [\u2190 memLp_one_iff_integrable, hg.memLp_comp_iff_of_antilipschitz hg' g0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]", "(\u03b1 \u03b2 \u03bc)", "{\u03b1 \u03b2 \u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_1\ninst\u271d : NormedAddCommGroup \u03b3\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03bc : Measure \u03b1\nK K' : NNReal\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nhg : sorry\nhg' : sorry\ng0 : g sorry = 0\n\u22a2 Integrable (g \u2218 f) \u03bc \u2194 sorry"}, {"line": "simp [\u2190 memLp_one_iff_integrable, hg.memLp_comp_iff_of_antilipschitz hg' g0]", "tactic_state": "\u03b3 : Type u_1\ninst\u271d : NormedAddCommGroup \u03b3\n\u03b1 : Type u_3\n\u03b2 : Type u_2\n\u03bc : Measure \u03b1\nK K' : NNReal\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nhg : sorry\nhg' : sorry\ng0 : g sorry = 0\n\u22a2 Integrable (g \u2218 f) \u03bc \u2194 sorry ()"}]}
{"declaration": "theorem Integrable.trim (hm : m \u2264 m0) (hf_int : Integrable f \u03bc') (hf : StronglyMeasurable[m] f) :\n    Integrable f (\u03bc'.trim hm) := by\n  refine \u27e8hf.aestronglyMeasurable, ?_\u27e9\n  rw [HasFiniteIntegral]\n  rw [lintegral_trim hm _]\n  \u00b7 exact hf_int.2\n  \u00b7 exact @StronglyMeasurable.enorm _ m _ _ f hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/L1Space/Integrable.lean", "context": {"open": ["EMetric ENNReal Filter MeasureTheory NNReal Set", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 \u03b5 : Type*} {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} [MeasurableSpace \u03b4]", "[NormedAddCommGroup \u03b2] [NormedAddCommGroup \u03b3] [ENorm \u03b5]", "[TopologicalSpace \u03b5]", "(\u03b1 \u03b2 \u03bc)", "{\u03b1 \u03b2 \u03bc}", "[MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 \u03b2}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc)", "{\ud835\udd5c : Type*}", "[NormedRing \ud835\udd5c] [Module \ud835\udd5c \u03b2] [IsBoundedSMul \ud835\udd5c \u03b2]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c}", "{\ud835\udd5c : Type*} [RCLike \ud835\udd5c] {f : \u03b1 \u2192 \ud835\udd5c}", "{H : Type*} [NormedAddCommGroup H] {m0 : MeasurableSpace \u03b1} {\u03bc' : Measure \u03b1} {f : \u03b1 \u2192 H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 Integrable f (\u03bc'.trim hm)"}, {"line": "refine \u27e8hf.aestronglyMeasurable, ?_\u27e9", "tactic_state": "\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 HasFiniteIntegral f (\u03bc'.trim hm)"}, {"line": "rw [HasFiniteIntegral]", "tactic_state": "\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc'.trim hm < \u22a4"}, {"line": "rw [lintegral_trim hm _]", "tactic_state": "\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 \u2202\u03bc' < \u22a4\n---\n\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 Measurable fun a => \u2016f a\u2016\u2091"}, {"line": "\u00b7 exact hf_int.2", "tactic_state": "\u03b1 : Type u_10\nH : Type u_9\ninst\u271d : NormedAddCommGroup H\nm0 : MeasurableSpace \u03b1\n\u03bc' : Measure \u03b1\nf : \u03b1 \u2192 H\nm : MeasurableSpace \u03b1\nhm : m \u2264 m0\nhf_int : Integrable f \u03bc'\nhf : StronglyMeasurable f\n\u22a2 Measurable fun a => \u2016f a\u2016\u2091"}, {"line": "\u00b7 exact @StronglyMeasurable.enorm _ m _ _ f hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_exponent_zero {f : \u03b1 \u2192 \u03b5} : eLpNorm f 0 \u03bc = 0 := by simp [eLpNorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\nf : \u03b1 \u2192 \u03b5\n\u22a2 sorry = 0"}, {"line": "simp [eLpNorm]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\nf : \u03b1 \u2192 \u03b5\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem memLp_zero_iff_aestronglyMeasurable [TopologicalSpace \u03b5] {f : \u03b1 \u2192 \u03b5} :\n    MemLp f 0 \u03bc \u2194 AEStronglyMeasurable f \u03bc := by simp [MemLp, eLpNorm_exponent_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : TopologicalSpace \u03b5\nf : \u03b1 \u2192 \u03b5\n\u22a2 sorry \u2194 AEStronglyMeasurable f \u03bc"}, {"line": "simp [MemLp, eLpNorm_exponent_zero]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : TopologicalSpace \u03b5\nf : \u03b1 \u2192 \u03b5\n\u22a2 sorry () \u2194 AEStronglyMeasurable f \u03bc"}]}
{"declaration": "theorem eLpNorm'_zero (hp0_lt : 0 < q) : eLpNorm' (0 : \u03b1 \u2192 \u03b5) q \u03bc = 0 := by\n  simp [eLpNorm'_eq_lintegral_enorm, hp0_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nhp0_lt : 0 < q\n\u22a2 eLpNorm' 0 q \u03bc = 0"}, {"line": "simp [eLpNorm'_eq_lintegral_enorm, hp0_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_zero' (hq0_ne : q \u2260 0) (h\u03bc : \u03bc \u2260 0) : eLpNorm' (0 : \u03b1 \u2192 \u03b5) q \u03bc = 0 := by\n  rcases le_or_lt 0 q with hq0 | hq_neg\n  \u00b7 exact eLpNorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)\n  \u00b7 simp [eLpNorm'_eq_lintegral_enorm, ENNReal.rpow_eq_zero_iff, h\u03bc, hq_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nhq0_ne : q \u2260 0\nh\u03bc : \u03bc \u2260 0\n\u22a2 eLpNorm' 0 q \u03bc = 0"}, {"line": "rcases le_or_lt 0 q with hq0 | hq_neg", "tactic_state": "case inl\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nhq0_ne : q \u2260 0\nh\u03bc : \u03bc \u2260 0\nhq0 : 0 \u2264 q\n\u22a2 eLpNorm' 0 q \u03bc = 0\n---\ncase inr\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nhq0_ne : q \u2260 0\nh\u03bc : \u03bc \u2260 0\nhq_neg : q < 0\n\u22a2 eLpNorm' 0 q \u03bc = 0"}, {"line": "\u00b7 exact eLpNorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)", "tactic_state": "case inr\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nhq0_ne : q \u2260 0\nh\u03bc : \u03bc \u2260 0\nhq_neg : q < 0\n\u22a2 eLpNorm' 0 q \u03bc = 0"}, {"line": "\u00b7 simp [eLpNorm'_eq_lintegral_enorm, ENNReal.rpow_eq_zero_iff, h\u03bc, hq_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNormEssSup_zero : eLpNormEssSup (0 : \u03b1 \u2192 \u03b5) \u03bc = 0 := by\n  simp [eLpNormEssSup, \u2190 bot_eq_zero', essSup_const_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\n\u22a2 eLpNormEssSup 0 \u03bc = 0"}, {"line": "simp [eLpNormEssSup, \u2190 bot_eq_zero', essSup_const_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_measure_zero_of_pos {f : \u03b1 \u2192 \u03b5} (hq_pos : 0 < q) :\n    eLpNorm' f q (0 : Measure \u03b1) = 0 := by simp [eLpNorm', hq_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nq : \u211d\n\u03b5 : Type u_7\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\nhq_pos : 0 < q\n\u22a2 eLpNorm' f q 0 = 0"}, {"line": "simp [eLpNorm', hq_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_measure_zero_of_exponent_zero {f : \u03b1 \u2192 \u03b5} : eLpNorm' f 0 (0 : Measure \u03b1) = 1 := by\n  simp [eLpNorm']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_7\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 eLpNorm' f 0 0 = 1"}, {"line": "simp [eLpNorm']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_measure_zero_of_neg {f : \u03b1 \u2192 \u03b5} (hq_neg : q < 0) :\n    eLpNorm' f q (0 : Measure \u03b1) = \u221e := by simp [eLpNorm', hq_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nq : \u211d\n\u03b5 : Type u_7\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\nhq_neg : q < 0\n\u22a2 eLpNorm' f q 0 = \u22a4"}, {"line": "simp [eLpNorm', hq_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNormEssSup_measure_zero {f : \u03b1 \u2192 \u03b5} : eLpNormEssSup f (0 : Measure \u03b1) = 0 := by\n  simp [eLpNormEssSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_7\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 eLpNormEssSup f 0 = 0"}, {"line": "simp [eLpNormEssSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNormEssSup_const (c : \u03b5) (h\u03bc : \u03bc \u2260 0) : eLpNormEssSup (fun _ : \u03b1 => c) \u03bc = \u2016c\u2016\u2091 := by\n  rw [eLpNormEssSup_eq_essSup_enorm]\n  rw [essSup_const _ h\u03bc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ContinuousENorm \u03b5\nc : \u03b5\nh\u03bc : \u03bc \u2260 0\n\u22a2 eLpNormEssSup (fun x => c) \u03bc = \u2016c\u2016\u2091"}, {"line": "rw [eLpNormEssSup_eq_essSup_enorm]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ContinuousENorm \u03b5\nc : \u03b5\nh\u03bc : \u03bc \u2260 0\n\u22a2 essSup (fun x => \u2016c\u2016\u2091) \u03bc = \u2016c\u2016\u2091"}, {"line": "rw [essSup_const _ h\u03bc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_const' (c : \u03b5) (h0 : p \u2260 0) (h_top : p \u2260 \u221e) :\n    eLpNorm (fun _ : \u03b1 => c) p \u03bc = \u2016c\u2016\u2091 * \u03bc Set.univ ^ (1 / ENNReal.toReal p) := by\n  simp [eLpNorm_eq_eLpNorm' h0 h_top, eLpNorm'_const, ENNReal.toReal_pos h0 h_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ContinuousENorm \u03b5\nc : \u03b5\nh0 : p \u2260 0\nh_top : p \u2260 \u22a4\n\u22a2 eLpNorm (fun x => c) p \u03bc = \u2016c\u2016\u2091 * \u03bc Set.univ ^ (1 / p.toReal)"}, {"line": "simp [eLpNorm_eq_eLpNorm' h0 h_top, eLpNorm'_const, ENNReal.toReal_pos h0 h_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem memLp_const_iff_enorm\n    {p : \u211d\u22650\u221e} {c : \u03b5''} (hc : \u2016c\u2016\u2091 \u2260 \u22a4) (hp_ne_zero : p \u2260 0) (hp_ne_top : p \u2260 \u221e) :\n    MemLp (fun _ : \u03b1 \u21a6 c) p \u03bc \u2194 c = 0 \u2228 \u03bc Set.univ < \u221e := by\n  simp_all [MemLp, aestronglyMeasurable_const,\n    eLpNorm_const_lt_top_iff_enorm hc hp_ne_zero hp_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b1\n\u03b5'' : Type u_10\np : ENNReal\nc : \u03b5''\nhc : sorry \u2260 \u22a4\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\n\u22a2 sorry \u2194 c = 0 \u2228 \u03bc Set.univ < \u22a4"}, {"line": "simp_all [MemLp, aestronglyMeasurable_const,\n    eLpNorm_const_lt_top_iff_enorm hc hp_ne_zero hp_ne_top]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b1\n\u03b5'' : Type u_10\np : ENNReal\nc : \u03b5''\nhc : sorry \u2260 \u22a4\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\n\u22a2 sorry () \u2194 c = 0 \u2228 \u03bc Set.univ < \u22a4"}]}
{"declaration": "lemma eLpNorm'_mono_enorm_ae {f : \u03b1 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b5'} (hq : 0 \u2264 q) (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091) :\n    eLpNorm' f q \u03bc \u2264 eLpNorm' g q \u03bc := by\n  simp only [eLpNorm'_eq_lintegral_enorm]\n  gcongr ?_ ^ (1/q)\n  refine lintegral_mono_ae (h.mono fun x hx => ?_)\n  gcongr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 eLpNorm' f q \u03bc \u2264 eLpNorm' g q \u03bc"}, {"line": "simp only [eLpNorm'_eq_lintegral_enorm]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 (\u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bc) ^ (1 / q) \u2264 (\u222b\u207b (a : \u03b1), \u2016g a\u2016\u2091 ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "gcongr ?_ ^ (1/q)", "tactic_state": "case h\u2081\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bc \u2264 \u222b\u207b (a : \u03b1), \u2016g a\u2016\u2091 ^ q \u2202\u03bc"}, {"line": "refine lintegral_mono_ae (h.mono fun x hx => ?_)", "tactic_state": "case h\u2081\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nq : \u211d\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nhq : 0 \u2264 q\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nx : \u03b1\nhx : \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 \u2016f x\u2016\u2091 ^ q \u2264 \u2016g x\u2016\u2091 ^ q"}, {"line": "gcongr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_mono_enorm_ae {f : \u03b1 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b5'} (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091) :\n    eLpNorm f p \u03bc \u2264 eLpNorm g p \u03bc := by\n  simp only [eLpNorm]\n  split_ifs\n  \u00b7 exact le_rfl\n  \u00b7 exact essSup_mono_ae h\n  \u00b7 exact eLpNorm'_mono_enorm_ae ENNReal.toReal_nonneg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 eLpNorm f p \u03bc \u2264 eLpNorm g p \u03bc"}, {"line": "simp only [eLpNorm]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\n\u22a2 (if p = 0 then 0 else if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    if p = 0 then 0 else if p = \u22a4 then eLpNormEssSup g \u03bc else eLpNorm' g p.toReal \u03bc"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d : p = 0\n\u22a2 0 \u2264 0\n---\ncase pos\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d\u00b9 : \u00acp = 0\nh\u271d : p = \u22a4\n\u22a2 eLpNormEssSup f \u03bc \u2264 eLpNormEssSup g \u03bc\n---\ncase neg\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d\u00b9 : \u00acp = 0\nh\u271d : \u00acp = \u22a4\n\u22a2 eLpNorm' f p.toReal \u03bc \u2264 eLpNorm' g p.toReal \u03bc"}, {"line": "\u00b7 exact le_rfl", "tactic_state": "case pos\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d\u00b9 : \u00acp = 0\nh\u271d : p = \u22a4\n\u22a2 eLpNormEssSup f \u03bc \u2264 eLpNormEssSup g \u03bc\n---\ncase neg\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d\u00b9 : \u00acp = 0\nh\u271d : \u00acp = \u22a4\n\u22a2 eLpNorm' f p.toReal \u03bc \u2264 eLpNorm' g p.toReal \u03bc"}, {"line": "\u00b7 exact essSup_mono_ae h", "tactic_state": "case neg\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b1\n\u03b5 : Type u_8\ninst\u271d\u00b3 : TopologicalSpace \u03b5\ninst\u271d\u00b2 : ContinuousENorm \u03b5\n\u03b5' : Type u_9\ninst\u271d\u00b9 : TopologicalSpace \u03b5'\ninst\u271d : ContinuousENorm \u03b5'\nf : \u03b1 \u2192 \u03b5\ng : \u03b1 \u2192 \u03b5'\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 \u2016g x\u2016\u2091\nh\u271d\u00b9 : \u00acp = 0\nh\u271d : \u00acp = \u22a4\n\u22a2 eLpNorm' f p.toReal \u03bc \u2264 eLpNorm' g p.toReal \u03bc"}, {"line": "\u00b7 exact eLpNorm'_mono_enorm_ae ENNReal.toReal_nonneg h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_norm {f : \u03b1 \u2192 F} : eLpNorm' (fun a => \u2016f a\u2016) q \u03bc = eLpNorm' f q \u03bc := by\n  simp [eLpNorm'_eq_lintegral_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nF : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nq : \u211d\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 F\n\u22a2 eLpNorm' (fun a => sorry) q \u03bc = sorry"}, {"line": "simp [eLpNorm'_eq_lintegral_enorm]", "tactic_state": "\u03b1 : Type u_5\nF : Type u_6\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nq : \u211d\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 F\n\u22a2 (\u2016sorry ()\u2016\u2091 ^ q * \u03bc Set.univ) ^ q\u207b\u00b9 = sorry ()"}]}
{"declaration": "theorem eLpNorm'_enorm {f : \u03b1 \u2192 \u03b5} : eLpNorm' (fun a => \u2016f a\u2016\u2091) q \u03bc = eLpNorm' f q \u03bc := by\n  simp [eLpNorm'_eq_lintegral_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\nq : \u211d\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 eLpNorm' (fun a => \u2016f a\u2016\u2091) q \u03bc = eLpNorm' f q \u03bc"}, {"line": "simp [eLpNorm'_eq_lintegral_enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_mono_measure (f : \u03b1 \u2192 \u03b5) (h\u03bc\u03bd : \u03bd \u2264 \u03bc) (hq : 0 \u2264 q) :\n    eLpNorm' f q \u03bd \u2264 eLpNorm' f q \u03bc := by\n  simp_rw [eLpNorm']\n  gcongr\n  exact lintegral_mono' h\u03bc\u03bd le_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bd \u03bc : Measure \u03b1\nq : \u211d\nf : \u03b1 \u2192 \u03b5\nh\u03bc\u03bd : \u03bd \u2264 \u03bc\nhq : 0 \u2264 q\n\u22a2 eLpNorm' f q \u03bd \u2264 eLpNorm' f q \u03bc"}, {"line": "simp_rw [eLpNorm']", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bd \u03bc : Measure \u03b1\nq : \u211d\nf : \u03b1 \u2192 \u03b5\nh\u03bc\u03bd : \u03bd \u2264 \u03bc\nhq : 0 \u2264 q\n\u22a2 (\u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bd) ^ (1 / q) \u2264 (\u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "gcongr", "tactic_state": "case h\u2081\n\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bd \u03bc : Measure \u03b1\nq : \u211d\nf : \u03b1 \u2192 \u03b5\nh\u03bc\u03bd : \u03bd \u2264 \u03bc\nhq : 0 \u2264 q\n\u22a2 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bd \u2264 \u222b\u207b (a : \u03b1), \u2016f a\u2016\u2091 ^ q \u2202\u03bc"}, {"line": "exact lintegral_mono' h\u03bc\u03bd le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNormEssSup_mono_measure (f : \u03b1 \u2192 \u03b5) (h\u03bc\u03bd : \u03bd \u226a \u03bc) :\n    eLpNormEssSup f \u03bd \u2264 eLpNormEssSup f \u03bc := by\n  simp_rw [eLpNormEssSup]\n  exact essSup_mono_measure h\u03bc\u03bd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bd \u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nh\u03bc\u03bd : \u03bd.AbsolutelyContinuous \u03bc\n\u22a2 eLpNormEssSup f \u03bd \u2264 eLpNormEssSup f \u03bc"}, {"line": "simp_rw [eLpNormEssSup]", "tactic_state": "\u03b1 : Type u_5\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ContinuousENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bd \u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nh\u03bc\u03bd : \u03bd.AbsolutelyContinuous \u03bc\n\u22a2 essSup (fun x => \u2016f x\u2016\u2091) \u03bd \u2264 essSup (fun x => \u2016f x\u2016\u2091) \u03bc"}, {"line": "exact essSup_mono_measure h\u03bc\u03bd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eLpNormEssSup_indicator_le (s : Set \u03b1) (f : \u03b1 \u2192 \u03b5) :\n    eLpNormEssSup (s.indicator f) \u03bc \u2264 eLpNormEssSup f \u03bc := by\n  refine essSup_mono_ae (Eventually.of_forall fun x => ?_)\n  simp_rw [enorm_indicator_eq_indicator_enorm]\n  exact Set.indicator_le_self s _ x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 eLpNormEssSup (s.indicator f) \u03bc \u2264 eLpNormEssSup f \u03bc"}, {"line": "refine essSup_mono_ae (Eventually.of_forall fun x => ?_)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b5\nx : \u03b1\n\u22a2 (fun x => \u2016s.indicator f x\u2016\u2091) x \u2264 (fun x => \u2016f x\u2016\u2091) x"}, {"line": "simp_rw [enorm_indicator_eq_indicator_enorm]", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b5\nx : \u03b1\n\u22a2 s.indicator (fun a => \u2016f a\u2016\u2091) x \u2264 \u2016f x\u2016\u2091"}, {"line": "exact Set.indicator_le_self s _ x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma memLp_indicator_iff_restrict {f : \u03b1 \u2192 \u03b5} (hs : MeasurableSet s) :\n    MemLp (s.indicator f) p \u03bc \u2194 MemLp f p (\u03bc.restrict s) := by\n  simp [MemLp, aestronglyMeasurable_indicator_iff hs, eLpNorm_indicator_eq_eLpNorm_restrict hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ns : Set \u03b1\np : ENNReal\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nhs : MeasurableSet s\n\u22a2 MemLp (s.indicator f) p \u03bc \u2194 MemLp f p (\u03bc.restrict s)"}, {"line": "simp [MemLp, aestronglyMeasurable_indicator_iff hs, eLpNorm_indicator_eq_eLpNorm_restrict hs]", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ns : Set \u03b1\np : ENNReal\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nhs : MeasurableSet s\n\u22a2 AEStronglyMeasurable (s.indicator f) \u03bc \u2227 eLpNorm (s.indicator f) p \u03bc < \u22a4 \u2194\n    AEStronglyMeasurable f (\u03bc.restrict s) \u2227 eLpNorm f p (\u03bc.restrict s) < \u22a4"}]}
{"declaration": "theorem eLpNorm'_smul_measure {p : \u211d} (hp : 0 \u2264 p) {f : \u03b1 \u2192 \u03b5} (c : \u211d\u22650\u221e) :\n    eLpNorm' f p (c \u2022 \u03bc) = c ^ (1 / p) * eLpNorm' f p \u03bc := by\n  simp [eLpNorm', ENNReal.mul_rpow_of_nonneg, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp : 0 \u2264 p\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 eLpNorm' f p (c \u2022 \u03bc) = c ^ (1 / p) * eLpNorm' f p \u03bc"}, {"line": "simp [eLpNorm', ENNReal.mul_rpow_of_nonneg, hp]", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem eLpNorm_smul_measure_of_ne_zero_of_ne_top {p : \u211d\u22650\u221e} (hp_ne_zero : p \u2260 0)\n    (hp_ne_top : p \u2260 \u221e) {f : \u03b1 \u2192 \u03b5} (c : \u211d\u22650\u221e) :\n    eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc := by\n  simp_rw [eLpNorm_eq_eLpNorm' hp_ne_zero hp_ne_top]\n  rw [eLpNorm'_smul_measure ENNReal.toReal_nonneg]\n  congr\n  simp_rw [one_div]\n  rw [ENNReal.toReal_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc"}, {"line": "simp_rw [eLpNorm_eq_eLpNorm' hp_ne_zero hp_ne_top]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 eLpNorm' f p.toReal (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm' f p.toReal \u03bc"}, {"line": "rw [eLpNorm'_smul_measure ENNReal.toReal_nonneg]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 c ^ (1 / p.toReal) * eLpNorm' f p.toReal \u03bc = c ^ (1 / p).toReal \u2022 eLpNorm' f p.toReal \u03bc"}, {"line": "congr", "tactic_state": "case e_a.e_a\n\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 1 / p.toReal = (1 / p).toReal"}, {"line": "simp_rw [one_div]", "tactic_state": "case e_a.e_a\n\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_zero : p \u2260 0\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 p.toReal\u207b\u00b9 = p\u207b\u00b9.toReal"}, {"line": "rw [ENNReal.toReal_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_smul_measure_of_ne_top {p : \u211d\u22650\u221e} (hp_ne_top : p \u2260 \u221e) (f : \u03b1 \u2192 \u03b5) (c : \u211d\u22650\u221e) :\n    eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc := by\n  by_cases hp0 : p = 0\n  \u00b7 simp [hp0]\n  \u00b7 exact eLpNorm_smul_measure_of_ne_zero_of_ne_top hp0 hp_ne_top c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc"}, {"line": "by_cases hp0 : p = 0", "tactic_state": "case pos\n\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\nhp0 : p = 0\n\u22a2 eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc\n---\ncase neg\n\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\nhp0 : \u00acp = 0\n\u22a2 eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc"}, {"line": "\u00b7 simp [hp0]", "tactic_state": "case neg\n\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : ENNReal\nhp_ne_top : p \u2260 \u22a4\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\nhp0 : \u00acp = 0\n\u22a2 eLpNorm f p (c \u2022 \u03bc) = c ^ (1 / p).toReal \u2022 eLpNorm f p \u03bc"}, {"line": "\u00b7 exact eLpNorm_smul_measure_of_ne_zero_of_ne_top hp0 hp_ne_top c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_one_smul_measure {f : \u03b1 \u2192 \u03b5} (c : \u211d\u22650\u221e) :\n    eLpNorm f 1 (c \u2022 \u03bc) = c * eLpNorm f 1 \u03bc := by\n  rw [eLpNorm_smul_measure_of_ne_top] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u00b3 : MeasurableSpace \u03b1\n\u03b5 : Type u_5\ninst\u271d\u00b2 : TopologicalSpace \u03b5\ninst\u271d\u00b9 : ENormedAddMonoid \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\n\u22a2 eLpNorm f 1 (c \u2022 \u03bc) = c * eLpNorm f 1 \u03bc"}, {"line": "rw [eLpNorm_smul_measure_of_ne_top] <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_one_add_measure (f : \u03b1 \u2192 \u03b5) (\u03bc \u03bd : Measure \u03b1) :\n    eLpNorm f 1 (\u03bc + \u03bd) = eLpNorm f 1 \u03bc + eLpNorm f 1 \u03bd := by\n  simp_rw [eLpNorm_one_eq_lintegral_enorm]\n  rw [lintegral_add_measure _ \u03bc \u03bd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nf : \u03b1 \u2192 \u03b5\n\u03bc \u03bd : Measure \u03b1\n\u22a2 eLpNorm f 1 (\u03bc + \u03bd) = eLpNorm f 1 \u03bc + eLpNorm f 1 \u03bd"}, {"line": "simp_rw [eLpNorm_one_eq_lintegral_enorm]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_7\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\nf : \u03b1 \u2192 \u03b5\n\u03bc \u03bd : Measure \u03b1\n\u22a2 \u222b\u207b (x : \u03b1), \u2016f x\u2016\u2091 \u2202(\u03bc + \u03bd) = \u222b\u207b (x : \u03b1), \u2016f x\u2016\u2091 \u2202\u03bc + \u222b\u207b (x : \u03b1), \u2016f x\u2016\u2091 \u2202\u03bd"}, {"line": "rw [lintegral_add_measure _ \u03bc \u03bd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNormEssSup_eq_zero_iff {f : \u03b1 \u2192 \u03b5} : eLpNormEssSup f \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0 := by\n  simp [EventuallyEq, eLpNormEssSup_eq_essSup_enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [ENorm \u03b5] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_10\ninst\u271d\u00b9 : ENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 eLpNormEssSup f \u03bc = 0 \u2194 f =\u1da0[ae \u03bc] sorry"}, {"line": "simp [EventuallyEq, eLpNormEssSup_eq_essSup_enorm]", "tactic_state": "\u03b1 : Type u_11\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03b5 : Type u_10\ninst\u271d\u00b9 : ENorm \u03b5\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\n\u22a2 (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 = 0) \u2194 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x = sorry () x"}]}
{"declaration": "theorem memLp_map_measure_iff (hg : AEStronglyMeasurable g (Measure.map f \u03bc))\n    (hf : AEMeasurable f \u03bc) : MemLp g p (Measure.map f \u03bc) \u2194 MemLp (g \u2218 f) p \u03bc := by\n  simp [MemLp, eLpNorm_map_measure hg hf, hg.comp_aemeasurable hf, hg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [ENorm \u03b5] in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\nF : Type u_12\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 F\n\u03b5\u271d : Type u_10\ng : F \u2192 \u03b5\u271d\n\u03bc : Measure \u03b1\np : ENNReal\nhg : sorry\nhf : sorry\n\u22a2 MemLp g p sorry \u2194 MemLp (g \u2218 f) p \u03bc"}, {"line": "simp [MemLp, eLpNorm_map_measure hg hf, hg.comp_aemeasurable hf, hg]", "tactic_state": "\u03b1 : Type u_11\nF : Type u_12\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 F\n\u03b5\u271d : Type u_10\ng : F \u2192 \u03b5\u271d\n\u03bc : Measure \u03b1\np : ENNReal\nhg : sorry\nhf : sorry\n\u22a2 AEStronglyMeasurable g (sorry ()) \u2227 eLpNorm g p (sorry ()) < \u22a4 \u2194\n    AEStronglyMeasurable (g \u2218 f) \u03bc \u2227 eLpNorm (g \u2218 f) p \u03bc < \u22a4"}]}
{"declaration": "theorem eLpNorm_le_mul_eLpNorm_of_ae_le_mul'' {f : \u03b1 \u2192 \u03b5} {c : \u211d\u22650\u221e} {g : \u03b1 \u2192 \u03b5''} (p : \u211d\u22650\u221e)\n    (hg : AEStronglyMeasurable g \u03bc) (h : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091) :\n    eLpNorm f p \u03bc \u2264 c * eLpNorm g p \u03bc := by\n  by_cases h\u2080 : p = 0\n  \u00b7 simp [h\u2080]\n  simp only [eLpNorm]\n  simp only [h\u2080]\n  simp only [\u2193reduceIte]\n  simp only [mul_ite]\n  by_cases hp' : p = \u22a4\n  \u00b7 simpa [hp'] using eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul' h\n  \u00b7 simpa [hp'] using eLpNorm'_le_mul_eLpNorm'_of_ae_le_mul hg h (ENNReal.toReal_pos h\u2080 hp')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/Basic.lean", "context": {"open": ["TopologicalSpace MeasureTheory Filter", "scoped NNReal ENNReal Topology ComplexConjugate", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b5 \u03b5' E F G : Type*} {m m0 : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {q : \u211d} {\u03bc \u03bd : Measure \u03b1}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "[MeasurableSpace \u03b1]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5' \u03b5'' : Type*} [TopologicalSpace \u03b5'] [ContinuousENorm \u03b5']", "{f : \u03b1 \u2192 F}", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "(c) in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{R : Type*} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ContinuousENorm \u03b5]", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5 : Type*} [ENorm \u03b5] in", "{\u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5]", "{\u03b5'' : Type*} [TopologicalSpace \u03b5''] [ContinuousENorm \u03b5''] in", "{\u03b5'' : Type*} [TopologicalSpace \u03b5''] [ContinuousENorm \u03b5''] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\n\u22a2 eLpNorm f p \u03bc \u2264 c * eLpNorm g p \u03bc"}, {"line": "by_cases h\u2080 : p = 0", "tactic_state": "case pos\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : p = 0\n\u22a2 eLpNorm f p \u03bc \u2264 c * eLpNorm g p \u03bc\n---\ncase neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 eLpNorm f p \u03bc \u2264 c * eLpNorm g p \u03bc"}, {"line": "\u00b7 simp [h\u2080]", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 eLpNorm f p \u03bc \u2264 c * eLpNorm g p \u03bc"}, {"line": "simp only [eLpNorm]", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 (if p = 0 then 0 else if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    c * if p = 0 then 0 else if p = \u22a4 then eLpNormEssSup g \u03bc else eLpNorm' g p.toReal \u03bc"}, {"line": "simp only [h\u2080]", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 (if False then 0 else if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    c * if False then 0 else if p = \u22a4 then eLpNormEssSup g \u03bc else eLpNorm' g p.toReal \u03bc"}, {"line": "simp only [\u2193reduceIte]", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 (if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    c * if p = \u22a4 then eLpNormEssSup g \u03bc else eLpNorm' g p.toReal \u03bc"}, {"line": "simp only [mul_ite]", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\n\u22a2 (if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    if p = \u22a4 then c * eLpNormEssSup g \u03bc else c * eLpNorm' g p.toReal \u03bc"}, {"line": "by_cases hp' : p = \u22a4", "tactic_state": "case pos\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\nhp' : p = \u22a4\n\u22a2 (if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    if p = \u22a4 then c * eLpNormEssSup g \u03bc else c * eLpNorm' g p.toReal \u03bc\n---\ncase neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\nhp' : \u00acp = \u22a4\n\u22a2 (if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    if p = \u22a4 then c * eLpNormEssSup g \u03bc else c * eLpNorm' g p.toReal \u03bc"}, {"line": "\u00b7 simpa [hp'] using eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul' h", "tactic_state": "case neg\n\u03b1 : Type u_12\ninst\u271d\u2075 : MeasurableSpace \u03b1\n\u03b5 : Type u_9\ninst\u271d\u2074 : TopologicalSpace \u03b5\ninst\u271d\u00b3 : ENormedAddMonoid \u03b5\n\u03b5'' : Type u_11\ninst\u271d\u00b2 : TopologicalSpace \u03b5''\ninst\u271d\u00b9 : ContinuousENorm \u03b5''\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u03b5\nc : ENNReal\ng : \u03b1 \u2192 \u03b5''\np : ENNReal\nhg : AEStronglyMeasurable g \u03bc\nh : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016\u2091 \u2264 c * \u2016g x\u2016\u2091\nh\u2080 : \u00acp = 0\nhp' : \u00acp = \u22a4\n\u22a2 (if p = \u22a4 then eLpNormEssSup f \u03bc else eLpNorm' f p.toReal \u03bc) \u2264\n    if p = \u22a4 then c * eLpNormEssSup g \u03bc else c * eLpNorm' g p.toReal \u03bc"}, {"line": "\u00b7 simpa [hp'] using eLpNorm'_le_mul_eLpNorm'_of_ae_le_mul hg h (ENNReal.toReal_pos h\u2080 hp')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_le_eLpNorm'_mul_eLpNorm' {p q r : \u211d} (hf : AEStronglyMeasurable f \u03bc)\n    (hg : AEStronglyMeasurable g \u03bc) (b : E \u2192 F \u2192 G) (c : \u211d\u22650)\n    (h : \u2200\u1d50 x \u2202\u03bc, \u2016b (f x) (g x)\u2016\u208a \u2264 c * \u2016f x\u2016\u208a * \u2016g x\u2016\u208a) (hro_lt : 0 < r) (hrp : r < p)\n    (hpqr : 1 / r = 1 / p + 1 / q) :\n    eLpNorm' (fun x => b (f x) (g x)) r \u03bc \u2264 c * eLpNorm' f p \u03bc * eLpNorm' g q \u03bc := by\n  calc\n    eLpNorm' (fun x => b (f x) (g x)) r \u03bc\n      \u2264 eLpNorm' (fun x \u21a6 (c : \u211d) \u2022 \u2016f x\u2016 * \u2016g x\u2016) r \u03bc := by\n      simp only [eLpNorm']\n      refine (ENNReal.rpow_le_rpow_iff <| one_div_pos.mpr hro_lt).mpr <|\n        lintegral_mono_ae <| h.mono fun a ha \u21a6 (ENNReal.rpow_le_rpow_iff hro_lt).mpr <| ?_\n      simp only [enorm_eq_nnnorm]\n      simp only [ENNReal.coe_le_coe]\n      simp only [\u2190 NNReal.coe_le_coe]\n      simpa [Real.nnnorm_of_nonneg (by positivity)] using ha\n    _ \u2264 c * eLpNorm' f p \u03bc * eLpNorm' g q \u03bc := by\n      simp only [smul_mul_assoc]\n      simp only [\u2190 Pi.smul_def]\n      simp only [eLpNorm'_const_smul _ hro_lt]\n      rw [Real.enorm_eq_ofReal c.coe_nonneg]\n      rw [ENNReal.ofReal_coe_nnreal]\n      rw [mul_assoc]\n      gcongr\n      simpa only [eLpNorm',enorm_mul,enorm_norm] using\n        ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hro_lt hrp hpqr \u03bc hf.enorm hg.enorm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/CompareExp.lean", "context": {"open": ["Filter ENNReal", "scoped Topology", "NNReal"], "variables": ["{\u03b1 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b5}", "{\u03b1 E F G : Type*} {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.918\n\u03b1\u271d\u00b9 : Type u_1\n\u03b5 : Type u_2\n\u03b5' : Type u_3\nm\u271d : MeasurableSpace \u03b1\u271d\u00b9\n\u03bc : sorry\nf : \u03b1\u271d\u00b9 \u2192 \u03b5\n\u03b1\u271d : Type u_4\nE\u271d : Type u_5\nF\u271d : Type u_6\nG\u271d : Type u_7\nm : MeasurableSpace \u03b1\u271d\n\u03b1 : Type u_1\nE : Type u_5\nF : Type u_6\nG : Type u_7\nx\u271d\u00b2 : Sort u_8\nAEStronglyMeasurable : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_9\ng : x\u271d\u00b9\nx\u271d : Sort u_10\neLpNorm' : x\u271d\np q r : \u211d\nhf : sorry\nhg : sorry\nb : E \u2192 F \u2192 G\nc : NNReal\nh : \u2200\u1da0 (x : \u03b1) in sorry, sorry \u2264 c * sorry * \u2016?m.7329\u2016\u208a\nhro_lt : 0 < r\nhrp : r < p\nhpqr : 1 / r = 1 / p + 1 / q\n\u22a2 sorry \u2264 c * sorry * sorry"}, {"line": "calc\n    eLpNorm' (fun x => b (f x) (g x)) r \u03bc\n      \u2264 eLpNorm' (fun x \u21a6 (c : \u211d) \u2022 \u2016f x\u2016 * \u2016g x\u2016) r \u03bc := by\n      simp only [eLpNorm']\n      refine (ENNReal.rpow_le_rpow_iff <| one_div_pos.mpr hro_lt).mpr <|\n        lintegral_mono_ae <| h.mono fun a ha \u21a6 (ENNReal.rpow_le_rpow_iff hro_lt).mpr <| ?_\n      simp only [enorm_eq_nnnorm]\n      simp only [ENNReal.coe_le_coe]\n      simp only [\u2190 NNReal.coe_le_coe]\n      simpa [Real.nnnorm_of_nonneg (by positivity)] using ha\n    _ \u2264 c * eLpNorm' f p \u03bc * eLpNorm' g q \u03bc := by\n      simp only [smul_mul_assoc]\n      simp only [\u2190 Pi.smul_def]\n      simp only [eLpNorm'_const_smul _ hro_lt]\n      rw [Real.enorm_eq_ofReal c.coe_nonneg]\n      rw [ENNReal.ofReal_coe_nnreal]\n      rw [mul_assoc]\n      gcongr\n      simpa only [eLpNorm',enorm_mul,enorm_norm] using\n        ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr hro_lt hrp hpqr \u03bc hf.enorm hg.enorm", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma MemLp.prod' (hf : \u2200 i \u2208 s, MemLp (f i) (p i) \u03bc) :\n    MemLp (fun \u03c9 \u21a6 \u220f i \u2208 s, f i \u03c9) (\u2211 i \u2208 s, (p i)\u207b\u00b9)\u207b\u00b9 \u03bc := by\n  simpa [Finset.prod_fn] using MemLp.prod hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/CompareExp.lean", "context": {"open": ["Filter ENNReal", "scoped Topology", "NNReal", "NNReal in", "Finset in"], "variables": ["{\u03b1 \u03b5 \u03b5' : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b5}", "{\u03b1 E F G : Type*} {m : MeasurableSpace \u03b1}", "{\ud835\udd5c \u03b1 E F : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} [NormedRing \ud835\udd5c]", "{\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {\ud835\udd5c : Type*} [NormedRing \ud835\udd5c] {\u03bc : Measure \u03b1}", "{\u03b9 \u03b1 \ud835\udd5c : Type*} {_ : MeasurableSpace \u03b1} [NormedCommRing \ud835\udd5c] {\u03bc : Measure \u03b1} {f : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.2462\n\u03b1\u271d\u00b2 : Type u_1\nE\u271d : Type u_2\nF\u271d : Type u_3\nG : Type u_4\nm\u271d : MeasurableSpace \u03b1\u271d\u00b2\n\ud835\udd5c\u271d\u00b9 : Type u_5\n\u03b1\u271d\u00b9 : Type u_6\nE : Type u_7\nF : Type u_8\nm : MeasurableSpace \u03b1\u271d\u00b9\n\u03bc\u271d\u00b9 : sorry\ninst\u271d\u00b2 : NormedRing \ud835\udd5c\u271d\u00b9\n\u03b1\u271d : Type u_9\nx\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\ud835\udd5c\u271d : Type u_10\ninst\u271d\u00b9 : NormedRing \ud835\udd5c\u271d\n\u03bc\u271d : sorry\n\u03b9 : Type u_11\n\u03b1 : Type u_12\n\ud835\udd5c : Type u_13\nx\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedCommRing \ud835\udd5c\n\u03bc : sorry\nf : \u03b9 \u2192 \u03b1 \u2192 \ud835\udd5c\n\u03b3\u271d : Type u_14\ns : \u03b3\u271d\nx\u271d : Sort u_15\nMemLp : x\u271d\nhf : (i : ?m.5839) \u2192 i \u2208 s \u2192 sorry\n\u22a2 sorry"}, {"line": "simpa [Finset.prod_fn] using MemLp.prod hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm_add_lt_top {f g : \u03b1 \u2192 E} (hf : MemLp f p \u03bc) (hg : MemLp g p \u03bc) :\n    eLpNorm (f + g) p \u03bc < \u221e :=\n  calc\n    eLpNorm (f + g) p \u03bc \u2264 LpAddConst p * (eLpNorm f p \u03bc + eLpNorm g p \u03bc) :=\n      eLpNorm_add_le' hf.aestronglyMeasurable hg.aestronglyMeasurable p\n    _ < \u221e := by\n      apply ENNReal.mul_lt_top (LpAddConst_lt_top p)\n      exact ENNReal.add_lt_top.2 \u27e8hf.2, hg.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSeminorm/TriangleInequality.lean", "context": {"open": ["Filter", "scoped ENNReal Topology"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} [NormedAddCommGroup E]", "(\u03bc E)", "{\u03bc E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d : NormedAddCommGroup E\nx\u271d\u00b9 : Sort u_3\nMemLp : x\u271d\u00b9\nx\u271d : Sort u_4\neLpNorm : x\u271d\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\n\u22a2 sorry * (sorry + sorry) < \u22a4"}, {"line": "apply ENNReal.mul_lt_top (LpAddConst_lt_top p)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d : NormedAddCommGroup E\nx\u271d\u00b9 : Sort u_3\nMemLp : x\u271d\u00b9\nx\u271d : Sort u_4\neLpNorm : x\u271d\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\n\u22a2 sorry + sorry < \u22a4"}, {"line": "exact ENNReal.add_lt_top.2 \u27e8hf.2, hg.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eLpNorm'_lim_eq_lintegral_liminf {\u03b9} [Nonempty \u03b9] [LinearOrder \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 E} {p : \u211d}\n    {f_lim : \u03b1 \u2192 E} (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    eLpNorm' f_lim p \u03bc = (\u222b\u207b a, atTop.liminf (\u2016f \u00b7 a\u2016\u2091 ^ p) \u2202\u03bc) ^ (1 / p) := by\n  suffices h_no_pow : (\u222b\u207b a, \u2016f_lim a\u2016\u2091 ^ p \u2202\u03bc) = \u222b\u207b a, atTop.liminf fun m => \u2016f m a\u2016\u2091 ^ p \u2202\u03bc by\n    rw [eLpNorm'_eq_lintegral_enorm]\n    rw [h_no_pow]\n  refine lintegral_congr_ae (h_lim.mono fun a ha => ?_)\n  dsimp only\n  rw [Tendsto.liminf_eq]\n  refine (ENNReal.continuous_rpow_const.tendsto \u2016f_lim a\u2016\u208a).comp ?_\n  exact (continuous_enorm.tendsto (f_lim a)).comp ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Complete.lean", "context": {"open": ["MeasureTheory Filter", "scoped ENNReal Topology"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 eLpNorm' f_lim p \u03bc = (\u222b\u207b (a : \u03b1), liminf (fun x => \u2016f x a\u2016\u2091 ^ p) atTop \u2202\u03bc) ^ (1 / p)"}, {"line": "suffices h_no_pow : (\u222b\u207b a, \u2016f_lim a\u2016\u2091 ^ p \u2202\u03bc) = \u222b\u207b a, atTop.liminf fun m => \u2016f m a\u2016\u2091 ^ p \u2202\u03bc by\n    rw [eLpNorm'_eq_lintegral_enorm]\n    rw [h_no_pow]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u222b\u207b (a : \u03b1), sorry ^ p \u2202\u03bc = \u222b\u207b (a : \u03b1), liminf (fun m => sorry ^ p) atTop \u2202\u03bc\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}, {"line": "refine lintegral_congr_ae (h_lim.mono fun a ha => ?_)", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 (fun a => sorry ^ p) a = (fun a => liminf (fun m => sorry ^ p) atTop) a\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}, {"line": "dsimp only", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 sorry ^ p = liminf (fun m => sorry ^ p) atTop\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}, {"line": "rw [Tendsto.liminf_eq]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 Tendsto (fun m => sorry ^ p) atTop (nhds (sorry ^ p))\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9\n---\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 atTop.NeBot\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}, {"line": "refine (ENNReal.continuous_rpow_const.tendsto \u2016f_lim a\u2016\u208a).comp ?_", "tactic_state": "case refine_2\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 Tendsto (fun m => sorry) atTop (nhds sorry)\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9\n---\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 atTop.NeBot\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}, {"line": "exact (continuous_enorm.tendsto (f_lim a)).comp ha", "tactic_state": "case refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9\n---\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\na : \u03b1\nha : Tendsto (fun n => f n a) atTop (nhds (f_lim a))\n\u22a2 atTop.NeBot\n---\ncase refine_1\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\np : \u211d\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u03b1 \u2192 Preorder \u03b9"}]}
{"declaration": "theorem eLpNorm_exponent_top_lim_eq_essSup_liminf {\u03b9} [Nonempty \u03b9] [LinearOrder \u03b9] {f : \u03b9 \u2192 \u03b1 \u2192 E}\n    {f_lim : \u03b1 \u2192 E} (h_lim : \u2200\u1d50 x : \u03b1 \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (f_lim x))) :\n    eLpNorm f_lim \u221e \u03bc = essSup (fun x => atTop.liminf fun m => \u2016f m x\u2016\u2091) \u03bc := by\n  rw [eLpNorm_exponent_top]\n  rw [eLpNormEssSup_eq_essSup_enorm]\n  refine essSup_congr_ae (h_lim.mono fun x hx => ?_)\n  dsimp only\n  apply (Tendsto.liminf_eq ..).symm\n  exact (continuous_enorm.tendsto (f_lim x)).comp hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Complete.lean", "context": {"open": ["MeasureTheory Filter", "scoped ENNReal Topology"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 eLpNorm f_lim \u22a4 \u03bc = essSup (fun x => liminf (fun m => \u2016f m x\u2016\u2091) atTop) \u03bc"}, {"line": "rw [eLpNorm_exponent_top]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 eLpNormEssSup f_lim \u03bc = essSup (fun x => liminf (fun m => \u2016f m x\u2016\u2091) atTop) \u03bc"}, {"line": "rw [eLpNormEssSup_eq_essSup_enorm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 essSup (fun x => \u2016f_lim x\u2016\u2091) \u03bc = essSup (fun x => liminf (fun m => \u2016f m x\u2016\u2091) atTop) \u03bc"}, {"line": "refine essSup_congr_ae (h_lim.mono fun x hx => ?_)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\nx : \u03b1\nhx : Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 (fun x => \u2016f_lim x\u2016\u2091) x = (fun x => liminf (fun m => \u2016f m x\u2016\u2091) atTop) x"}, {"line": "dsimp only", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\nx : \u03b1\nhx : Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 \u2016f_lim x\u2016\u2091 = liminf (fun m => \u2016f m x\u2016\u2091) atTop"}, {"line": "apply (Tendsto.liminf_eq ..).symm", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\nx : \u03b1\nhx : Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 atTop.NeBot\n---\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\nx : \u03b1\nhx : Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 Tendsto (fun m => \u2016f m x\u2016\u2091) atTop (nhds \u2016f_lim x\u2016\u2091)"}, {"line": "exact (continuous_enorm.tendsto (f_lim x)).comp hx", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 \u03b1 \u2192 E\nf_lim : \u03b1 \u2192 E\nh_lim : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => f n x) atTop (nhds (f_lim x))\nx : \u03b1\nhx : Tendsto (fun n => f n x) atTop (nhds (f_lim x))\n\u22a2 Tendsto (fun m => \u2016f m x\u2016\u2091) atTop (nhds \u2016f_lim x\u2016\u2091)"}]}
{"declaration": "theorem MemLp.eLpNorm_mk_lt_top {\u03b1 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}\n    [NormedAddCommGroup E] {p : \u211d\u22650\u221e} {f : \u03b1 \u2192 E} (hfp : MemLp f p \u03bc) :\n    eLpNorm (AEEqFun.mk f hfp.1) p \u03bc < \u221e := by simp [hfp.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Basic.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal"], "variables": ["{\u03b1 \ud835\udd5c \ud835\udd5c' E F : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\nE : Type u_7\ninst\u271d\u00b9 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\np : ENNReal\nf : \u03b1 \u2192 E\nhfp : MemLp f p \u03bc\n\u22a2 eLpNorm (\u2191(AEEqFun.mk f \u22ef)) p \u03bc < \u22a4"}, {"line": "simp [hfp.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toLp_congr {f g : \u03b1 \u2192 E} (hf : MemLp f p \u03bc) (hg : MemLp g p \u03bc) (hfg : f =\u1d50[\u03bc] g) :\n    hf.toLp f = hg.toLp g := by simp [toLp, hfg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Basic.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal"], "variables": ["{\u03b1 \ud835\udd5c \ud835\udd5c' E F : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\nhfg : f =\u1da0[ae \u03bc] g\n\u22a2 sorry = sorry"}, {"line": "simp [toLp, hfg]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\nhfg : f =\u1da0[ae \u03bc] g\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem toLp_eq_toLp_iff {f g : \u03b1 \u2192 E} (hf : MemLp f p \u03bc) (hg : MemLp g p \u03bc) :\n    hf.toLp f = hg.toLp g \u2194 f =\u1d50[\u03bc] g := by simp [toLp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Basic.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal"], "variables": ["{\u03b1 \ud835\udd5c \ud835\udd5c' E F : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\n\u22a2 sorry = sorry \u2194 f =\u1da0[ae \u03bc] g"}, {"line": "simp [toLp]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 E\nhf : sorry\nhg : sorry\n\u22a2 sorry () = sorry () \u2194 f =\u1da0[ae \u03bc] g"}]}
{"declaration": "theorem edist_toLp_zero (f : \u03b1 \u2192 E) (hf : MemLp f p \u03bc) : edist (hf.toLp f) 0 = eLpNorm f p \u03bc := by\n  simpa using edist_toLp_toLp f 0 hf MemLp.zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Basic.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal"], "variables": ["{\u03b1 \ud835\udd5c \ud835\udd5c' E F : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1}", "(E p \u03bc)", "{E p \u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\nf : \u03b1 \u2192 E\nhf : sorry\n\u22a2 edist sorry 0 = sorry"}, {"line": "simpa using edist_toLp_toLp f 0 hf MemLp.zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem indicatorConstLp_sub {c' : E} :\n    indicatorConstLp p hs h\u03bcs c - indicatorConstLp p hs h\u03bcs c' =\n    indicatorConstLp p hs h\u03bcs (c - c') := by\n  simp_rw [indicatorConstLp, \u2190 MemLp.toLp_sub, indicator_sub]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc c' : E\n\u22a2 indicatorConstLp p hs h\u03bcs c - indicatorConstLp p hs h\u03bcs c' = indicatorConstLp p hs h\u03bcs (c - c')"}, {"line": "simp_rw [indicatorConstLp, \u2190 MemLp.toLp_sub, indicator_sub]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc c' : E\n\u22a2 MemLp.toLp ((s.indicator fun x => c) - s.indicator fun x => c') \u22ef =\n    MemLp.toLp (fun a => s.indicator (fun x => c) a - s.indicator (fun x => c') a) \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_indicatorConstLp_le :\n    \u2016indicatorConstLp p hs h\u03bcs c\u2016\u2091 \u2264 \u2016c\u2016\u2091 * \u03bc s ^ (1 / p.toReal) := by\n  simpa [ENNReal.coe_rpow_of_nonneg, ENNReal.coe_toNNReal h\u03bcs, Lp.enorm_def, \u2190 enorm_eq_nnnorm]\n    using ENNReal.coe_le_coe.2 <| nnnorm_indicatorConstLp_le (c := c) (h\u03bcs := h\u03bcs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\n\u22a2 \u2016indicatorConstLp p hs h\u03bcs c\u2016\u2091 \u2264 \u2016c\u2016\u2091 * \u03bc s ^ (1 / p.toReal)"}, {"line": "simpa [ENNReal.coe_rpow_of_nonneg, ENNReal.coe_toNNReal h\u03bcs, Lp.enorm_def, \u2190 enorm_eq_nnnorm]\n    using ENNReal.coe_le_coe.2 <| nnnorm_indicatorConstLp_le (c := c) (h\u03bcs := h\u03bcs)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_indicatorConstLp_eq_enorm {t : Set \u03b1} {ht : MeasurableSet t} {h\u03bct : \u03bc t \u2260 \u221e} :\n    edist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) =\n      \u2016indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top h\u03bcs h\u03bct) c\u2016\u2091 := by\n  unfold indicatorConstLp\n  rw [Lp.edist_toLp_toLp]\n  rw [eLpNorm_indicator_sub_indicator]\n  rw [Lp.enorm_toLp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 edist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) = \u2016indicatorConstLp p \u22ef \u22ef c\u2016\u2091"}, {"line": "unfold indicatorConstLp", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 edist (MemLp.toLp (s.indicator fun x => c) \u22ef) (MemLp.toLp (t.indicator fun x => c) \u22ef) =\n    \u2016MemLp.toLp ((symmDiff s t).indicator fun x => c) \u22ef\u2016\u2091"}, {"line": "rw [Lp.edist_toLp_toLp]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 eLpNorm ((s.indicator fun x => c) - t.indicator fun x => c) p \u03bc =\n    \u2016MemLp.toLp ((symmDiff s t).indicator fun x => c) \u22ef\u2016\u2091"}, {"line": "rw [eLpNorm_indicator_sub_indicator]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 eLpNorm ((symmDiff s t).indicator fun x => c) p \u03bc = \u2016MemLp.toLp ((symmDiff s t).indicator fun x => c) \u22ef\u2016\u2091"}, {"line": "rw [Lp.enorm_toLp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_indicatorConstLp_eq_norm {t : Set \u03b1} {ht : MeasurableSet t} {h\u03bct : \u03bc t \u2260 \u221e} :\n    dist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) =\n      \u2016indicatorConstLp p (hs.symmDiff ht) (measure_symmDiff_ne_top h\u03bcs h\u03bct) c\u2016 := by\n  -- Squeezed for performance reasons\n  simp only [Lp.dist_edist]\n  simp only [edist_indicatorConstLp_eq_enorm]\n  simp only [enorm]\n  simp only [ENNReal.coe_toReal]\n  simp only [Lp.coe_nnnorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 dist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c) = \u2016indicatorConstLp p \u22ef \u22ef c\u2016"}, {"line": "simp only [Lp.dist_edist]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 (edist (indicatorConstLp p hs h\u03bcs c) (indicatorConstLp p ht h\u03bct c)).toReal = \u2016indicatorConstLp p \u22ef \u22ef c\u2016"}, {"line": "simp only [edist_indicatorConstLp_eq_enorm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 \u2016indicatorConstLp p \u22ef \u22ef c\u2016\u2091.toReal = \u2016indicatorConstLp p \u22ef \u22ef c\u2016"}, {"line": "simp only [enorm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 (\u2191\u2016indicatorConstLp p \u22ef \u22ef c\u2016\u208a).toReal = \u2016indicatorConstLp p \u22ef \u22ef c\u2016"}, {"line": "simp only [ENNReal.coe_toReal]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nt : Set \u03b1\nht : MeasurableSet t\nh\u03bct : \u03bc t \u2260 \u22a4\n\u22a2 \u2191\u2016indicatorConstLp p \u22ef \u22ef c\u2016\u208a = \u2016indicatorConstLp p \u22ef \u22ef c\u2016"}, {"line": "simp only [Lp.coe_nnnorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_indicatorConstLp_set [hp\u2081 : Fact (1 \u2264 p)] {\u03b2 : Type*} {l : Filter \u03b2} {t : \u03b2 \u2192 Set \u03b1}\n    {ht : \u2200 b, MeasurableSet (t b)} {h\u03bct : \u2200 b, \u03bc (t b) \u2260 \u221e} (hp : p \u2260 \u221e)\n    (h : Tendsto (fun b \u21a6 \u03bc (t b \u2206 s)) l (\ud835\udcdd 0)) :\n    Tendsto (fun b \u21a6 indicatorConstLp p (ht b) (h\u03bct b) c) l (\ud835\udcdd (indicatorConstLp p hs h\u03bcs c)) := by\n  rw [tendsto_iff_dist_tendsto_zero]\n  have hp\u2080 : p \u2260 0 := (one_pos.trans_le hp\u2081.out).ne'\n  simp only [dist_indicatorConstLp_eq_norm]\n  simp only [norm_indicatorConstLp hp\u2080 hp]\n  convert tendsto_const_nhds.mul\n    (((ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp h).rpow_const _)\n  \u00b7 simp [Real.rpow_eq_zero_iff_of_nonneg, ENNReal.toReal_eq_zero_iff, hp, hp\u2080]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\n\u22a2 Tendsto (fun b => indicatorConstLp p \u22ef \u22ef c) l (nhds (indicatorConstLp p hs h\u03bcs c))"}, {"line": "rw [tendsto_iff_dist_tendsto_zero]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\n\u22a2 Tendsto (fun b => dist (indicatorConstLp p \u22ef \u22ef c) (indicatorConstLp p hs h\u03bcs c)) l (nhds 0)"}, {"line": "have hp\u2080 : p \u2260 0 := (one_pos.trans_le hp\u2081.out).ne'", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 Tendsto (fun b => dist (indicatorConstLp p \u22ef \u22ef c) (indicatorConstLp p hs h\u03bcs c)) l (nhds 0)"}, {"line": "simp only [dist_indicatorConstLp_eq_norm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 Tendsto (fun b => \u2016indicatorConstLp p \u22ef \u22ef c\u2016) l (nhds 0)"}, {"line": "simp only [norm_indicatorConstLp hp\u2080 hp]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 Tendsto (fun b => \u2016c\u2016 * \u03bc.real (symmDiff (t b) s) ^ (1 / p.toReal)) l (nhds 0)"}, {"line": "convert tendsto_const_nhds.mul\n    (((ENNReal.tendsto_toReal ENNReal.zero_ne_top).comp h).rpow_const _)", "tactic_state": "case h.e'_5.h.e'_3\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 0 = \u2016c\u2016 * ENNReal.toReal 0 ^ (1 / p.toReal)\n---\ncase convert_3\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 ENNReal.toReal 0 \u2260 0 \u2228 0 \u2264 1 / p.toReal"}, {"line": "\u00b7 simp [Real.rpow_eq_zero_iff_of_nonneg, ENNReal.toReal_eq_zero_iff, hp, hp\u2080]", "tactic_state": "case convert_3\n\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\ns : Set \u03b1\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nc : E\nhp\u2081 : Fact (1 \u2264 p)\n\u03b2 : Type u_4\nl : Filter \u03b2\nt : \u03b2 \u2192 Set \u03b1\nht : \u2200 (b : \u03b2), MeasurableSet (t b)\nh\u03bct : \u2200 (b : \u03b2), \u03bc (t b) \u2260 \u22a4\nhp : p \u2260 \u22a4\nh : Tendsto (fun b => \u03bc (symmDiff (t b) s)) l (nhds 0)\nhp\u2080 : p \u2260 0\n\u22a2 ENNReal.toReal 0 \u2260 0 \u2228 0 \u2264 1 / p.toReal"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem indicatorConstLp_empty :\n    indicatorConstLp p MeasurableSet.empty (by simp : \u03bc \u2205 \u2260 \u221e) c = 0 := by\n  simp only [indicatorConstLp]\n  simp only [Set.indicator_empty']\n  simp only [MemLp.toLp_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\nc : E\n\u22a2 indicatorConstLp p \u22ef \u22ef c = 0"}, {"line": "simp only [indicatorConstLp]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\nc : E\n\u22a2 MemLp.toLp (\u2205.indicator fun x => c) \u22ef = 0"}, {"line": "simp only [Set.indicator_empty']", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d : NormedAddCommGroup E\nc : E\n\u22a2 MemLp.toLp 0 \u22ef = 0"}, {"line": "simp only [MemLp.toLp_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp.norm_const [NeZero \u03bc] (hp_zero : p \u2260 0) :\n    \u2016Lp.const p \u03bc c\u2016 = \u2016c\u2016 * \u03bc.real Set.univ ^ (1 / p.toReal) := by\n  have := NeZero.ne \u03bc\n  rw [\u2190 MemLp.toLp_const] <;> try assumption\n  rw [Lp.norm_toLp] <;> try assumption\n  rw [eLpNorm_const] <;> try assumption\n  rw [measureReal_def]\n  rw [ENNReal.toReal_mul]\n  rw [toReal_enorm]\n  rw [\u2190 ENNReal.toReal_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}", "(\u03bc p)", "[IsFiniteMeasure \u03bc] (c : E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\n\u22a2 \u2016(Lp.const p \u03bc) c\u2016 = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "have := NeZero.ne \u03bc", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 \u2016(Lp.const p \u03bc) c\u2016 = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [\u2190 MemLp.toLp_const] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 \u2016MemLp.toLp (fun x => c) \u22ef\u2016 = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [Lp.norm_toLp] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 (eLpNorm (fun x => c) p \u03bc).toReal = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [eLpNorm_const] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 (\u2016c\u2016\u2091 * \u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [measureReal_def]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 (\u2016c\u2016\u2091 * \u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [ENNReal.toReal_mul]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 \u2016c\u2016\u2091.toReal * (\u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [toReal_enorm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\nc : E\ninst\u271d : NeZero \u03bc\nhp_zero : p \u2260 0\nthis : \u03bc \u2260 0\n\u22a2 \u2016c\u2016 * (\u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [\u2190 ENNReal.toReal_rpow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp.norm_const' (hp_zero : p \u2260 0) (hp_top : p \u2260 \u221e) :\n    \u2016Lp.const p \u03bc c\u2016 = \u2016c\u2016 * \u03bc.real Set.univ ^ (1 / p.toReal) := by\n  rw [\u2190 MemLp.toLp_const] <;> try assumption\n  rw [Lp.norm_toLp] <;> try assumption\n  rw [eLpNorm_const'] <;> try assumption\n  rw [measureReal_def]\n  rw [ENNReal.toReal_mul]\n  rw [toReal_enorm]\n  rw [\u2190 ENNReal.toReal_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}", "(\u03bc p)", "[IsFiniteMeasure \u03bc] (c : E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 \u2016(Lp.const p \u03bc) c\u2016 = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [\u2190 MemLp.toLp_const] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 \u2016MemLp.toLp (fun x => c) \u22ef\u2016 = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [Lp.norm_toLp] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 (eLpNorm (fun x => c) p \u03bc).toReal = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [eLpNorm_const'] <;> try assumption", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 (\u2016c\u2016\u2091 * \u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [measureReal_def]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 (\u2016c\u2016\u2091 * \u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [ENNReal.toReal_mul]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 \u2016c\u2016\u2091.toReal * (\u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [toReal_enorm]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\nhp_zero : p \u2260 0\nhp_top : p \u2260 \u22a4\n\u22a2 \u2016c\u2016 * (\u03bc univ ^ (1 / p.toReal)).toReal = \u2016c\u2016 * (\u03bc univ).toReal ^ (1 / p.toReal)"}, {"line": "rw [\u2190 ENNReal.toReal_rpow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Lp.norm_const_le : \u2016Lp.const p \u03bc c\u2016 \u2264 \u2016c\u2016 * \u03bc.real Set.univ ^ (1 / p.toReal) := by\n  rw [\u2190 indicatorConstLp_univ]\n  exact norm_indicatorConstLp_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/LpSpace/Indicator.lean", "context": {"open": ["MeasureTheory Filter", "scoped NNReal ENNReal Topology symmDiff", "Set Function"], "variables": ["{\u03b1 E : Type*} {m : MeasurableSpace \u03b1} {p : \u211d\u22650\u221e} {\u03bc : Measure \u03b1} [NormedAddCommGroup E]", "{X : Type*} [TopologicalSpace X] [MeasurableSpace X]", "{s : Set \u03b1} {hs : MeasurableSet s} {h\u03bcs : \u03bc s \u2260 \u221e} {c : E}", "(\u03bc p)", "[IsFiniteMeasure \u03bc] (c : E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\n\u22a2 \u2016(Lp.const p \u03bc) c\u2016 \u2264 \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "rw [\u2190 indicatorConstLp_univ]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm : MeasurableSpace \u03b1\np : ENNReal\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : IsFiniteMeasure \u03bc\nc : E\n\u22a2 \u2016indicatorConstLp p \u22ef \u22ef c\u2016 \u2264 \u2016c\u2016 * \u03bc.real univ ^ (1 / p.toReal)"}, {"line": "exact norm_indicatorConstLp_le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma aemeasurable_of_aemeasurable_exp_mul {t : \u211d}\n    (ht : t \u2260 0) (hf : AEMeasurable (fun x \u21a6 exp (t * f x)) \u03bc) :\n    AEMeasurable f \u03bc := by\n  simpa only [mul_div_cancel_left\u2080 _ ht]\n    using (aemeasurable_of_aemeasurable_exp hf).div (aemeasurable_const (b := t))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SpecialFunctions/Basic.lean", "context": {"open": ["NNReal ENNReal MeasureTheory"], "variables": ["{\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u211d} {\u03bc : MeasureTheory.Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\n\u03bc : Measure \u03b1\nx\u271d : Sort u_2\nexp : x\u271d\nt : \u211d\nht : t \u2260 0\nhf : AEMeasurable (fun x => ?m.191) \u03bc\n\u22a2 AEMeasurable f \u03bc"}, {"line": "simpa only [mul_div_cancel_left\u2080 _ ht]\n    using (aemeasurable_of_aemeasurable_exp hf).div (aemeasurable_const (b := t))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aemeasurable_of_re_im (hre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc)\n    (him : AEMeasurable (fun x => RCLike.im (f x)) \u03bc) : AEMeasurable f \u03bc := by\n  convert AEMeasurable.add (M := \ud835\udd5c) (RCLike.measurable_ofReal.comp_aemeasurable hre)\n      ((RCLike.measurable_ofReal.comp_aemeasurable him).mul_const RCLike.I)\n  exact (RCLike.re_add_im _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/SpecialFunctions/RCLike.lean", "context": {"open": ["NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "{\u03b1 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] {m : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \ud835\udd5c}", "{\u03b1 \ud835\udd5c : Type*} [RCLike \ud835\udd5c] [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \ud835\udd5c} {\u03bc : MeasureTheory.Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 AEMeasurable f \u03bc"}, {"line": "convert AEMeasurable.add (M := \ud835\udd5c) (RCLike.measurable_ofReal.comp_aemeasurable hre)\n      ((RCLike.measurable_ofReal.comp_aemeasurable him).mul_const RCLike.I)", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\nx\u271d : \u03b1\n\u22a2 f x\u271d = (RCLike.ofReal \u2218 fun x => RCLike.re (f x)) x\u271d + (RCLike.ofReal \u2218 fun x => RCLike.im (f x)) x\u271d * RCLike.I\n---\ncase convert_1\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 Add \ud835\udd5c\n---\ncase convert_2\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 MeasurableAdd\u2082 \ud835\udd5c\n---\ncase convert_4\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 Mul \ud835\udd5c\n---\ncase convert_5\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 MeasurableMul \ud835\udd5c\n---\ncase convert_6\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 RCLike \ud835\udd5c"}, {"line": "exact (RCLike.re_add_im _).symm", "tactic_state": "case convert_2\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 MeasurableAdd\u2082 \ud835\udd5c\n---\ncase convert_5\n\u03b1 : Type u_4\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : RCLike \ud835\udd5c\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \ud835\udd5c\n\u03bc : MeasureTheory.Measure \u03b1\nhre : AEMeasurable (fun x => RCLike.re (f x)) \u03bc\nhim : AEMeasurable (fun x => RCLike.im (f x)) \u03bc\n\u22a2 MeasurableMul \ud835\udd5c"}]}
{"declaration": "lemma ENNReal.aefinStronglyMeasurable_of_aemeasurable (hf : \u222b\u207b x, f x \u2202\u03bc \u2260 \u221e)\n    (hf_meas : AEMeasurable f \u03bc) :\n    AEFinStronglyMeasurable f \u03bc := by\n  refine \u27e8hf_meas.mk f, ENNReal.finStronglyMeasurable_of_measurable ?_ hf_meas.measurable_mk,\n    hf_meas.ae_eq_mk\u27e9\n  rwa [lintegral_congr_ae hf_meas.ae_eq_mk.symm]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/ENNReal.lean", "context": {"open": ["MeasureTheory", "scoped ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\nhf_meas : AEMeasurable f \u03bc\n\u22a2 AEFinStronglyMeasurable f \u03bc"}, {"line": "refine \u27e8hf_meas.mk f, ENNReal.finStronglyMeasurable_of_measurable ?_ hf_meas.measurable_mk,\n    hf_meas.ae_eq_mk\u27e9", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\nhf : \u222b\u207b (x : \u03b1), f x \u2202\u03bc \u2260 \u22a4\nhf_meas : AEMeasurable f \u03bc\n\u22a2 \u222b\u207b (x : \u03b1), AEMeasurable.mk f hf_meas x \u2202\u03bc \u2260 \u22a4"}, {"line": "rwa [lintegral_congr_ae hf_meas.ae_eq_mk.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aestronglyMeasurable_zero_measure (f : \u03b1 \u2192 \u03b2) :\n    AEStronglyMeasurable[m] f (0 : Measure[m\u2080] \u03b1) := by\n  nontriviality \u03b1\n  inhabit \u03b1\n  exact \u27e8fun _ => f default, stronglyMeasurable_const, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : TopologicalSpace \u03b2\nm m\u2080 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 AEStronglyMeasurable f 0"}, {"line": "nontriviality \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : TopologicalSpace \u03b2\nm m\u2080 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\na\u271d : Nontrivial \u03b1\n\u22a2 AEStronglyMeasurable f 0"}, {"line": "inhabit \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : TopologicalSpace \u03b2\nm m\u2080 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\na\u271d : Nontrivial \u03b1\ninhabited_h : Inhabited \u03b1\n\u22a2 AEStronglyMeasurable f 0"}, {"line": "exact \u27e8fun _ => f default, stronglyMeasurable_const, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of_measurableSpace_le_on {m' m\u2080 : MeasurableSpace \u03b1} {\u03bc : Measure[m\u2080] \u03b1} [Zero \u03b2]\n    (hm : m \u2264 m\u2080) {s : Set \u03b1} (hs_m : MeasurableSet[m] s)\n    (hs : \u2200 t, MeasurableSet[m] (s \u2229 t) \u2192 MeasurableSet[m'] (s \u2229 t))\n    (hf : AEStronglyMeasurable[m] f \u03bc) (hf_zero : f =\u1d50[\u03bc.restrict s\u1d9c] 0) :\n    AEStronglyMeasurable[m'] f \u03bc := by\n  have h_ind_eq : s.indicator (hf.mk f) =\u1d50[\u03bc] f := by\n    refine Filter.EventuallyEq.trans ?_ <|\n      indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero\n    filter_upwards [hf.ae_eq_mk] with x hx\n    by_cases hxs : x \u2208 s\n    \u00b7 simp [hxs, hx]\n    \u00b7 simp [hxs]\n  suffices StronglyMeasurable[m'] (s.indicator (hf.mk f)) from\n    this.aestronglyMeasurable.congr h_ind_eq\n  exact (hf.stronglyMeasurable_mk.indicator hs_m).stronglyMeasurable_of_measurableSpace_le_on hs_m\n    hs fun x hxs => Set.indicator_of_not_mem hxs _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm m' m\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Zero \u03b2\nhm : m \u2264 m\u2080\ns : Set \u03b1\nhs_m : MeasurableSet s\nhs : \u2200 (t : Set \u03b1), MeasurableSet (s \u2229 t) \u2192 MeasurableSet (s \u2229 t)\nhf : AEStronglyMeasurable f \u03bc\nhf_zero : f =\u1da0[ae (\u03bc.restrict s\u1d9c)] 0\n\u22a2 AEStronglyMeasurable f \u03bc"}, {"line": "have h_ind_eq : s.indicator (hf.mk f) =\u1d50[\u03bc] f := by\n    refine Filter.EventuallyEq.trans ?_ <|\n      indicator_ae_eq_of_restrict_compl_ae_eq_zero (hm _ hs_m) hf_zero\n    filter_upwards [hf.ae_eq_mk] with x hx\n    by_cases hxs : x \u2208 s\n    \u00b7 simp [hxs, hx]\n    \u00b7 simp [hxs]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm m' m\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Zero \u03b2\nhm : m \u2264 m\u2080\ns : Set \u03b1\nhs_m : MeasurableSet s\nhs : \u2200 (t : Set \u03b1), MeasurableSet (s \u2229 t) \u2192 MeasurableSet (s \u2229 t)\nhf : AEStronglyMeasurable f \u03bc\nhf_zero : f =\u1da0[ae (\u03bc.restrict s\u1d9c)] 0\nh_ind_eq : sorry =\u1da0[ae \u03bc] f\n\u22a2 AEStronglyMeasurable f \u03bc"}, {"line": "suffices StronglyMeasurable[m'] (s.indicator (hf.mk f)) from\n    this.aestronglyMeasurable.congr h_ind_eq", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm m' m\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : Zero \u03b2\nhm : m \u2264 m\u2080\ns : Set \u03b1\nhs_m : MeasurableSet s\nhs : \u2200 (t : Set \u03b1), MeasurableSet (s \u2229 t) \u2192 MeasurableSet (s \u2229 t)\nhf : AEStronglyMeasurable f \u03bc\nhf_zero : f =\u1da0[ae (\u03bc.restrict s\u1d9c)] 0\nh_ind_eq : sorry =\u1da0[ae \u03bc] f\n\u22a2 sorry"}, {"line": "exact (hf.stronglyMeasurable_mk.indicator hs_m).stronglyMeasurable_of_measurableSpace_le_on hs_m\n    hs fun x hxs => Set.indicator_of_not_mem hxs _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.List.aestronglyMeasurable_prod\n    (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc := by\n  simpa only [\u2190 Pi.list_prod_apply] using l.aestronglyMeasurable_prod' hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nM : Type u_5\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc\n\u22a2 AEStronglyMeasurable (fun x => (List.map (fun f => f x) l).prod) \u03bc"}, {"line": "simpa only [\u2190 Pi.list_prod_apply] using l.aestronglyMeasurable_prod' hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Multiset.aestronglyMeasurable_prod' (l : Multiset (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc) : AEStronglyMeasurable l.prod \u03bc := by\n  rcases l with \u27e8l\u27e9\n  simpa using l.aestronglyMeasurable_prod' (by simpa using hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nM : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nl : Multiset (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, AEStronglyMeasurable f \u03bc\n\u22a2 AEStronglyMeasurable l.prod \u03bc"}, {"line": "rcases l with \u27e8l\u27e9", "tactic_state": "case mk\n\u03b1 : Type u_1\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nM : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nl\u271d : Multiset (\u03b1 \u2192 M)\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 Quot.mk (\u21d1(List.isSetoid (\u03b1 \u2192 M))) l, AEStronglyMeasurable f \u03bc\n\u22a2 AEStronglyMeasurable (Multiset.prod (Quot.mk (\u21d1(List.isSetoid (\u03b1 \u2192 M))) l)) \u03bc"}, {"line": "simpa using l.aestronglyMeasurable_prod' (by simpa using hl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Multiset.aestronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n    (hs : \u2200 f \u2208 s, AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod) \u03bc := by\n  simpa only [\u2190 Pi.multiset_prod_apply] using s.aestronglyMeasurable_prod' hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nM : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\ns : Multiset (\u03b1 \u2192 M)\nhs : \u2200 f \u2208 s, AEStronglyMeasurable f \u03bc\n\u22a2 AEStronglyMeasurable (fun x => (Multiset.map (fun f => f x) s).prod) \u03bc"}, {"line": "simpa only [\u2190 Pi.multiset_prod_apply] using s.aestronglyMeasurable_prod' hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Finset.aestronglyMeasurable_prod {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, AEStronglyMeasurable (f i) \u03bc) :\n    AEStronglyMeasurable (fun a => \u220f i \u2208 s, f i a) \u03bc := by\n  simpa only [\u2190 Finset.prod_apply] using s.aestronglyMeasurable_prod' hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nM : Type u_6\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\n\u03b9 : Type u_7\nf : \u03b9 \u2192 \u03b1 \u2192 M\ns : Finset \u03b9\nhf : \u2200 i \u2208 s, AEStronglyMeasurable (f i) \u03bc\n\u22a2 AEStronglyMeasurable (fun a => \u220f i \u2208 s, f i a) \u03bc"}, {"line": "simpa only [\u2190 Finset.prod_apply] using s.aestronglyMeasurable_prod' hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparable_ae_range (hf : AEStronglyMeasurable f \u03bc) :\n    \u2203 t : Set \u03b2, IsSeparable t \u2227 \u2200\u1d50 x \u2202\u03bc, f x \u2208 t := by\n  refine \u27e8range (hf.mk f), hf.stronglyMeasurable_mk.isSeparable_range, ?_\u27e9\n  filter_upwards [hf.ae_eq_mk] with x hx\n  simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]", "[MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b2\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 \u2203 t, TopologicalSpace.IsSeparable t \u2227 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x \u2208 t"}, {"line": "refine \u27e8range (hf.mk f), hf.stronglyMeasurable_mk.isSeparable_range, ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b2\nhf : AEStronglyMeasurable f \u03bc\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, f x \u2208 range sorry"}, {"line": "filter_upwards [hf.ae_eq_mk] with x hx", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b2\nhf : AEStronglyMeasurable f \u03bc\nx : \u03b1\nhx : f x = AEStronglyMeasurable.mk f hf x\n\u22a2 f x \u2208 range sorry"}, {"line": "simp [hx]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : MeasurableSpace \u03b2\nhf : AEStronglyMeasurable f \u03bc\nx : \u03b1\nhx : f x = AEStronglyMeasurable.mk f hf x\n\u22a2 \u2203 y, sorry () y = AEStronglyMeasurable.mk f hf x"}]}
{"declaration": "theorem _root_.aestronglyMeasurable_add_measure_iff [PseudoMetrizableSpace \u03b2] {\u03bd : Measure \u03b1} :\n    AEStronglyMeasurable f (\u03bc + \u03bd) \u2194 AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd := by\n  rw [\u2190 sum_cond]\n  rw [aestronglyMeasurable_sum_measure_iff]\n  rw [Bool.forall_bool]\n  rw [and_comm]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]", "[MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 AEStronglyMeasurable f (\u03bc + \u03bd) \u2194 AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd"}, {"line": "rw [\u2190 sum_cond]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 AEStronglyMeasurable f (sum fun b => bif b then \u03bc else \u03bd) \u2194 AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd"}, {"line": "rw [aestronglyMeasurable_sum_measure_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 (\u2200 (i : Bool), AEStronglyMeasurable f (bif i then \u03bc else \u03bd)) \u2194 AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 PseudoMetrizableSpace \u03b2"}, {"line": "rw [Bool.forall_bool]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 AEStronglyMeasurable f (bif false then \u03bc else \u03bd) \u2227 AEStronglyMeasurable f (bif true then \u03bc else \u03bd) \u2194\n    AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 PseudoMetrizableSpace \u03b2"}, {"line": "rw [and_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 AEStronglyMeasurable f (bif true then \u03bc else \u03bd) \u2227 AEStronglyMeasurable f (bif false then \u03bc else \u03bd) \u2194\n    AEStronglyMeasurable f \u03bc \u2227 AEStronglyMeasurable f \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 PseudoMetrizableSpace \u03b2"}, {"line": "rfl", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b9 : MeasurableSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\n\u03bd : Measure \u03b1\n\u22a2 PseudoMetrizableSpace \u03b2"}]}
{"declaration": "theorem aestronglyMeasurable_uIoc_iff [LinearOrder \u03b1] [PseudoMetrizableSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {a b : \u03b1} :\n    AEStronglyMeasurable f (\u03bc.restrict <| uIoc a b) \u2194\n      AEStronglyMeasurable f (\u03bc.restrict <| Ioc a b) \u2227\n        AEStronglyMeasurable f (\u03bc.restrict <| Ioc b a) := by\n  rw [uIoc_eq_union]\n  rw [aestronglyMeasurable_union_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/AEStronglyMeasurable.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] {m m\u2080 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure[m\u2080] \u03b1}", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M]", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M]", "[MeasurableSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 AEStronglyMeasurable f (\u03bc.restrict (uIoc a b)) \u2194\n    AEStronglyMeasurable f (\u03bc.restrict (Ioc a b)) \u2227 AEStronglyMeasurable f (\u03bc.restrict (Ioc b a))"}, {"line": "rw [uIoc_eq_union]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 AEStronglyMeasurable f (\u03bc.restrict (Ioc a b \u222a Ioc b a)) \u2194\n    AEStronglyMeasurable f (\u03bc.restrict (Ioc a b)) \u2227 AEStronglyMeasurable f (\u03bc.restrict (Ioc b a))"}, {"line": "rw [aestronglyMeasurable_union_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace \u03b2\nm\u2080 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : MeasurableSpace \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 PseudoMetrizableSpace \u03b2"}]}
{"declaration": "theorem stronglyMeasurable_const' (hf : \u2200 x y, f x = f y) : StronglyMeasurable f := by\n  nontriviality \u03b1\n  inhabit \u03b1\n  convert stronglyMeasurable_const (\u03b2 := \u03b2) using 1\n  exact funext fun x => hf x default\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nx\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : TopologicalSpace \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y\n\u22a2 StronglyMeasurable f"}, {"line": "nontriviality \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nx\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : TopologicalSpace \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y\na\u271d : Nontrivial \u03b1\n\u22a2 StronglyMeasurable f"}, {"line": "inhabit \u03b1", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nx\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : TopologicalSpace \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y\na\u271d : Nontrivial \u03b1\ninhabited_h : Inhabited \u03b1\n\u22a2 StronglyMeasurable f"}, {"line": "convert stronglyMeasurable_const (\u03b2 := \u03b2) using 1", "tactic_state": "case h.e'_5\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nx\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : TopologicalSpace \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y\na\u271d : Nontrivial \u03b1\ninhabited_h : Inhabited \u03b1\n\u22a2 f = fun x => ?convert_4\n---\ncase convert_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nx\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d : TopologicalSpace \u03b2\nhf : \u2200 (x y : \u03b1), f x = f y\na\u271d : Nontrivial \u03b1\ninhabited_h : Inhabited \u03b1\n\u22a2 \u03b2"}, {"line": "exact funext fun x => hf x default", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_approxBounded_ae {\u03b2} {f : \u03b1 \u2192 \u03b2} [NormedAddCommGroup \u03b2] [NormedSpace \u211d \u03b2]\n    {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} (hf : StronglyMeasurable[m] f) {c : \u211d}\n    (hf_bound : \u2200\u1d50 x \u2202\u03bc, \u2016f x\u2016 \u2264 c) :\n    \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => hf.approxBounded c n x) atTop (\ud835\udcdd (f x)) := by\n  filter_upwards [hf_bound] with x hfx using tendsto_approxBounded_of_norm_le hf hfx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_5\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : NormedAddCommGroup \u03b2\ninst\u271d : NormedSpace \u211d \u03b2\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nhf : StronglyMeasurable f\nc : \u211d\nhf_bound : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2016f x\u2016 \u2264 c\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, Tendsto (fun n => (hf.approxBounded c n) x) atTop (nhds (f x))"}, {"line": "filter_upwards [hf_bound] with x hfx using tendsto_approxBounded_of_norm_le hf hfx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.List.stronglyMeasurable_prod (l : List (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod := by\n  simpa only [\u2190 Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]", "{m\u03b1 : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]", "{M G G\u2080 : Type*}", "[TopologicalSpace \u03b2]", "[Monoid M] [MulAction M \u03b2] [ContinuousConstSMul M \u03b2]", "[Group G] [MulAction G \u03b2] [ContinuousConstSMul G \u03b2]", "[GroupWithZero G\u2080] [MulAction G\u2080 \u03b2] [ContinuousConstSMul G\u2080 \u03b2]", "[MeasurableSpace \u03b1] [TopologicalSpace \u03b2]", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\nM : Type u_8\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nm : MeasurableSpace \u03b1\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, StronglyMeasurable f\n\u22a2 StronglyMeasurable fun x => (List.map (fun f => f x) l).prod"}, {"line": "simpa only [\u2190 Pi.list_prod_apply] using l.stronglyMeasurable_prod' hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Multiset.stronglyMeasurable_prod' (l : Multiset (\u03b1 \u2192 M))\n    (hl : \u2200 f \u2208 l, StronglyMeasurable f) : StronglyMeasurable l.prod := by\n  rcases l with \u27e8l\u27e9\n  simpa using l.stronglyMeasurable_prod' (by simpa using hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]", "{m\u03b1 : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]", "{M G G\u2080 : Type*}", "[TopologicalSpace \u03b2]", "[Monoid M] [MulAction M \u03b2] [ContinuousConstSMul M \u03b2]", "[Group G] [MulAction G \u03b2] [ContinuousConstSMul G \u03b2]", "[GroupWithZero G\u2080] [MulAction G\u2080 \u03b2] [ContinuousConstSMul G\u2080 \u03b2]", "[MeasurableSpace \u03b1] [TopologicalSpace \u03b2]", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\nM : Type u_9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nm : MeasurableSpace \u03b1\nl : Multiset (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, StronglyMeasurable f\n\u22a2 StronglyMeasurable l.prod"}, {"line": "rcases l with \u27e8l\u27e9", "tactic_state": "case mk\n\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\nM : Type u_9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nm : MeasurableSpace \u03b1\nl\u271d : Multiset (\u03b1 \u2192 M)\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 Quot.mk (\u21d1(List.isSetoid (\u03b1 \u2192 M))) l, StronglyMeasurable f\n\u22a2 StronglyMeasurable (Multiset.prod (Quot.mk (\u21d1(List.isSetoid (\u03b1 \u2192 M))) l))"}, {"line": "simpa using l.stronglyMeasurable_prod' (by simpa using hl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n    (hs : \u2200 f \u2208 s, StronglyMeasurable f) :\n    StronglyMeasurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod := by\n  simpa only [\u2190 Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]", "{m\u03b1 : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]", "{M G G\u2080 : Type*}", "[TopologicalSpace \u03b2]", "[Monoid M] [MulAction M \u03b2] [ContinuousConstSMul M \u03b2]", "[Group G] [MulAction G \u03b2] [ContinuousConstSMul G \u03b2]", "[GroupWithZero G\u2080] [MulAction G\u2080 \u03b2] [ContinuousConstSMul G\u2080 \u03b2]", "[MeasurableSpace \u03b1] [TopologicalSpace \u03b2]", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\nM : Type u_9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nm : MeasurableSpace \u03b1\ns : Multiset (\u03b1 \u2192 M)\nhs : \u2200 f \u2208 s, StronglyMeasurable f\n\u22a2 StronglyMeasurable fun x => (Multiset.map (fun f => f x) s).prod"}, {"line": "simpa only [\u2190 Pi.multiset_prod_apply] using s.stronglyMeasurable_prod' hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Finset.stronglyMeasurable_prod {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 M} (s : Finset \u03b9)\n    (hf : \u2200 i \u2208 s, StronglyMeasurable (f i)) : StronglyMeasurable fun a => \u220f i \u2208 s, f i a := by\n  simpa only [\u2190 Finset.prod_apply] using s.stronglyMeasurable_prod' hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory", "Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]", "{m\u03b1 : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]", "{M G G\u2080 : Type*}", "[TopologicalSpace \u03b2]", "[Monoid M] [MulAction M \u03b2] [ContinuousConstSMul M \u03b2]", "[Group G] [MulAction G \u03b2] [ContinuousConstSMul G \u03b2]", "[GroupWithZero G\u2080] [MulAction G\u2080 \u03b2] [ContinuousConstSMul G\u2080 \u03b2]", "[MeasurableSpace \u03b1] [TopologicalSpace \u03b2]", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MeasurableSpace \u03b1\nM : Type u_9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nm : MeasurableSpace \u03b1\n\u03b9 : Type u_10\nf : \u03b9 \u2192 \u03b1 \u2192 M\ns : Finset \u03b9\nhf : \u2200 i \u2208 s, StronglyMeasurable (f i)\n\u22a2 StronglyMeasurable fun a => \u220f i \u2208 s, f i a"}, {"line": "simpa only [\u2190 Finset.prod_apply] using s.stronglyMeasurable_prod' hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma measurableSet_eq_fun (hf : StronglyMeasurable[m] f) (hg : StronglyMeasurable[m] g) :\n    MeasurableSet[m] {a | f a = g a} := by\n  borelize (E \u00d7 E)\n  exact (hf.prodMk hg).measurable isClosed_diagonal.measurableSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Function/StronglyMeasurable/Basic.lean", "context": {"open": ["MeasureTheory Filter TopologicalSpace Function Set MeasureTheory.Measure", "ENNReal Topology MeasureTheory NNReal", "MeasureTheory", "Filter", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 : Type*} [Countable \u03b9]", "[TopologicalSpace \u03b2]", "{_ : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u2115 \u2192 \u03b1} {m : \u2115}", "[TopologicalSpace \u03b2]", "[MeasurableSingletonClass \u03b1]", "{f g : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b2]", "{m\u03b1 : MeasurableSpace \u03b1} [TopologicalSpace \u03b2]", "{M G G\u2080 : Type*}", "[TopologicalSpace \u03b2]", "[Monoid M] [MulAction M \u03b2] [ContinuousConstSMul M \u03b2]", "[Group G] [MulAction G \u03b2] [ContinuousConstSMul G \u03b2]", "[GroupWithZero G\u2080] [MulAction G\u2080 \u03b2] [ContinuousConstSMul G\u2080 \u03b2]", "[MeasurableSpace \u03b1] [TopologicalSpace \u03b2]", "{M : Type*} [Monoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}", "{M : Type*} [CommMonoid M] [TopologicalSpace M] [ContinuousMul M] {m : MeasurableSpace \u03b1}", "{m\u03b1 : MeasurableSpace \u03b1} [MeasurableSpace \u03b2]", "{E : Type*} {m m\u2080 : MeasurableSpace \u03b1} {\u03bc : Measure[m\u2080] \u03b1} {f g : \u03b1 \u2192 E}", "{E : Type*} {m m\u2080 : MeasurableSpace \u03b1} {\u03bc : Measure[m\u2080] \u03b1} {f g : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : MeasurableSpace \u03b1\nE : Type u_7\nm : MeasurableSpace \u03b1\nf g : \u03b1 \u2192 E\nhf : StronglyMeasurable f\nhg : StronglyMeasurable g\n\u22a2 MeasurableSet {a | f a = g a}"}, {"line": "borelize (E \u00d7 E)", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : MeasurableSpace \u03b1\nE : Type u_7\nm : MeasurableSpace \u03b1\nf g : \u03b1 \u2192 E\nhf : StronglyMeasurable f\nhg : StronglyMeasurable g\nthis\u271d\u00b9 : MeasurableSpace (E \u00d7 E) := sorry\nthis\u271d : sorry\n\u22a2 MeasurableSet {a | f a = g a}"}, {"line": "exact (hf.prodMk hg).measurable isClosed_diagonal.measurableSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NullMeasurableSet.smul {s} (hs : NullMeasurableSet s \u03bc) (c : G) :\n    NullMeasurableSet (c \u2022 s) \u03bc := by\n  simpa only [\u2190 preimage_smul_inv] using\n    hs.preimage (measurePreserving_smul _ _).quasiMeasurePreserving\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Action.lean", "context": {"open": ["scoped ENNReal NNReal Pointwise Topology", "MeasureTheory.Measure Set Function Filter"], "variables": ["{G : Type u} {M : Type v} {\u03b1 : Type w}", "[SMul M \u03b1] {m : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{m : MeasurableSpace \u03b1} [SMul G \u03b1]", "{\u03bc}", "{m : MeasurableSpace \u03b1} [Group G] [MulAction G \u03b1]", "{\u03bc}", "{m : MeasurableSpace \u03b1} [MeasurableSpace M] [SMul M \u03b1] [MeasurableSMul M \u03b1] (c : M)", "{M : Type uM} {N : Type uN} {\u03b1 : Type u\u03b1} {\u03b2 : Type u\u03b2}", "(G) {m : MeasurableSpace \u03b1} [Group G] [MulAction G \u03b1] (\u03bc : Measure \u03b1)", "[MeasurableSpace G] [MeasurableSMul G \u03b1] in", "{G}", "[SMulInvariantMeasure G \u03b1 \u03bc]", "{\u03bc}", "[MeasurableSpace G] [MeasurableSMul G \u03b1] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.23408\nG\u271d : Type u\nM\u271d : Type v\n\u03b1\u271d : Type w\ninst\u271d\u00b9\u00b3 : SMul M\u271d \u03b1\u271d\nm\u271d\u00b3 : MeasurableSpace \u03b1\u271d\n\u03bc\u271d : sorry\n\u03bd : sorry\nm\u271d\u00b2 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u00b2 : SMul G\u271d \u03b1\u271d\nm\u271d\u00b9 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b9\u00b9 : Group G\u271d\ninst\u271d\u00b9\u2070 : MulAction G\u271d \u03b1\u271d\nm\u271d : MeasurableSpace \u03b1\u271d\ninst\u271d\u2079 : MeasurableSpace M\u271d\ninst\u271d\u2078 : SMul M\u271d \u03b1\u271d\ninst\u271d\u2077 : MeasurableSMul M\u271d \u03b1\u271d\nc\u271d : M\u271d\nM : Type uM\nN : Type uN\n\u03b1 : Type u\u03b1\n\u03b2 : Type u\u03b2\nm : MeasurableSpace \u03b1\ninst\u271d\u2076 : Group G\u271d\ninst\u271d\u2075 : MulAction G\u271d \u03b1\n\u03bc : sorry\ninst\u271d\u2074 : MeasurableSpace G\u271d\ninst\u271d\u00b3 : MeasurableSMul G\u271d \u03b1\nG : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : MeasurableSpace G\nx\u271d : Sort u_1\nNullMeasurableSet : x\u271d\ns : ?m.28353 G\nhs : sorry\nc : G\n\u22a2 sorry"}, {"line": "simpa only [\u2190 preimage_smul_inv] using\n    hs.preimage (measurePreserving_smul _ _).quasiMeasurePreserving", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.comp_inv_Iic {c : G} {f : G \u2192 F} (hf : IntegrableOn f (Set.Ici c\u207b\u00b9) \u03bc) :\n    IntegrableOn (fun x => f x\u207b\u00b9) (Set.Iic c) \u03bc := by\n  simpa using hf.comp_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Integral.lean", "context": {"open": ["Measure TopologicalSpace", "scoped ENNReal"], "variables": ["{\ud835\udd5c M \u03b1 G E F : Type*} [MeasurableSpace G]", "[NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\u03bc : Measure G} {f : G \u2192 E} {g : G}", "[Group G] [MeasurableInv G]", "[PartialOrder G] [CommGroup G] [IsOrderedMonoid G] [MeasurableInv G]", "[IsInvInvariant \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4636\n\ud835\udd5c : Type u_1\nM : Type u_2\n\u03b1 : Type u_3\nG\u271d : Type u_4\nE : Type u_5\nF\u271d : Type u_6\ninst\u271d\u00b9\u2077 : MeasurableSpace G\u271d\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : NormedAddCommGroup F\u271d\n\u03bc : sorry\nf\u271d : G\u271d \u2192 E\ng : G\u271d\ninst\u271d\u00b9\u00b3 : Group G\u271d\ninst\u271d\u00b9\u00b2 : MeasurableInv G\u271d\ninst\u271d\u00b9\u00b9 : PartialOrder G\u271d\ninst\u271d\u00b9\u2070 : CommGroup G\u271d\ninst\u271d\u2079 : IsOrderedMonoid G\u271d\ninst\u271d\u2078 : MeasurableInv G\u271d\nG : Type u_4\nF : Type u_6\ninst\u271d\u2077 : MeasurableSpace G\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : PartialOrder G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MeasurableInv G\nx\u271d : Sort u_7\nIntegrableOn : x\u271d\nc : G\nf : G \u2192 F\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.comp_inv_Ici {c : G} {f : G \u2192 F} (hf : IntegrableOn f (Set.Iic c\u207b\u00b9) \u03bc) :\n    IntegrableOn (fun x => f x\u207b\u00b9) (Set.Ici c) \u03bc := by\n  simpa using hf.comp_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Integral.lean", "context": {"open": ["Measure TopologicalSpace", "scoped ENNReal"], "variables": ["{\ud835\udd5c M \u03b1 G E F : Type*} [MeasurableSpace G]", "[NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\u03bc : Measure G} {f : G \u2192 E} {g : G}", "[Group G] [MeasurableInv G]", "[PartialOrder G] [CommGroup G] [IsOrderedMonoid G] [MeasurableInv G]", "[IsInvInvariant \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4636\n\ud835\udd5c : Type u_1\nM : Type u_2\n\u03b1 : Type u_3\nG\u271d : Type u_4\nE : Type u_5\nF\u271d : Type u_6\ninst\u271d\u00b9\u2077 : MeasurableSpace G\u271d\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : NormedAddCommGroup F\u271d\n\u03bc : sorry\nf\u271d : G\u271d \u2192 E\ng : G\u271d\ninst\u271d\u00b9\u00b3 : Group G\u271d\ninst\u271d\u00b9\u00b2 : MeasurableInv G\u271d\ninst\u271d\u00b9\u00b9 : PartialOrder G\u271d\ninst\u271d\u00b9\u2070 : CommGroup G\u271d\ninst\u271d\u2079 : IsOrderedMonoid G\u271d\ninst\u271d\u2078 : MeasurableInv G\u271d\nG : Type u_4\nF : Type u_6\ninst\u271d\u2077 : MeasurableSpace G\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : PartialOrder G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MeasurableInv G\nx\u271d : Sort u_7\nIntegrableOn : x\u271d\nc : G\nf : G \u2192 F\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.comp_inv_Iio {c : G} {f : G \u2192 F} (hf : IntegrableOn f (Set.Ioi c\u207b\u00b9) \u03bc) :\n    IntegrableOn (fun x => f x\u207b\u00b9) (Set.Iio c) \u03bc := by\n  simpa using hf.comp_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Integral.lean", "context": {"open": ["Measure TopologicalSpace", "scoped ENNReal"], "variables": ["{\ud835\udd5c M \u03b1 G E F : Type*} [MeasurableSpace G]", "[NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\u03bc : Measure G} {f : G \u2192 E} {g : G}", "[Group G] [MeasurableInv G]", "[PartialOrder G] [CommGroup G] [IsOrderedMonoid G] [MeasurableInv G]", "[IsInvInvariant \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4636\n\ud835\udd5c : Type u_1\nM : Type u_2\n\u03b1 : Type u_3\nG\u271d : Type u_4\nE : Type u_5\nF\u271d : Type u_6\ninst\u271d\u00b9\u2077 : MeasurableSpace G\u271d\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : NormedAddCommGroup F\u271d\n\u03bc : sorry\nf\u271d : G\u271d \u2192 E\ng : G\u271d\ninst\u271d\u00b9\u00b3 : Group G\u271d\ninst\u271d\u00b9\u00b2 : MeasurableInv G\u271d\ninst\u271d\u00b9\u00b9 : PartialOrder G\u271d\ninst\u271d\u00b9\u2070 : CommGroup G\u271d\ninst\u271d\u2079 : IsOrderedMonoid G\u271d\ninst\u271d\u2078 : MeasurableInv G\u271d\nG : Type u_4\nF : Type u_6\ninst\u271d\u2077 : MeasurableSpace G\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : PartialOrder G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MeasurableInv G\nx\u271d : Sort u_7\nIntegrableOn : x\u271d\nc : G\nf : G \u2192 F\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.comp_inv_Ioi {c : G} {f : G \u2192 F} (hf : IntegrableOn f (Set.Iio c\u207b\u00b9) \u03bc) :\n    IntegrableOn (fun x => f x\u207b\u00b9) (Set.Ioi c) \u03bc := by\n  simpa using hf.comp_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Integral.lean", "context": {"open": ["Measure TopologicalSpace", "scoped ENNReal"], "variables": ["{\ud835\udd5c M \u03b1 G E F : Type*} [MeasurableSpace G]", "[NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]", "{\u03bc : Measure G} {f : G \u2192 E} {g : G}", "[Group G] [MeasurableInv G]", "[PartialOrder G] [CommGroup G] [IsOrderedMonoid G] [MeasurableInv G]", "[IsInvInvariant \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.4636\n\ud835\udd5c : Type u_1\nM : Type u_2\n\u03b1 : Type u_3\nG\u271d : Type u_4\nE : Type u_5\nF\u271d : Type u_6\ninst\u271d\u00b9\u2077 : MeasurableSpace G\u271d\ninst\u271d\u00b9\u2076 : NormedAddCommGroup E\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\ninst\u271d\u00b9\u2074 : NormedAddCommGroup F\u271d\n\u03bc : sorry\nf\u271d : G\u271d \u2192 E\ng : G\u271d\ninst\u271d\u00b9\u00b3 : Group G\u271d\ninst\u271d\u00b9\u00b2 : MeasurableInv G\u271d\ninst\u271d\u00b9\u00b9 : PartialOrder G\u271d\ninst\u271d\u00b9\u2070 : CommGroup G\u271d\ninst\u271d\u2079 : IsOrderedMonoid G\u271d\ninst\u271d\u2078 : MeasurableInv G\u271d\nG : Type u_4\nF : Type u_6\ninst\u271d\u2077 : MeasurableSpace G\ninst\u271d\u2076 : NormedAddCommGroup F\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : PartialOrder G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MeasurableInv G\nx\u271d : Sort u_7\nIntegrableOn : x\u271d\nc : G\nf : G \u2192 F\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa using hf.comp_inv", "tactic_state": "No Goals!"}]}
{"declaration": "lemma modularCharacterFun_map_one : modularCharacterFun (1 : G) = 1 := by\n  simp [modularCharacterFun, haarScalarFactor_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/ModularCharacter.lean", "context": {"open": ["MeasureTheory", "scoped NNReal"], "variables": ["{G : Type*} [TopologicalSpace G] [Group G] [IsTopologicalGroup G] [LocallyCompactSpace G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmodularCharacterFun : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [modularCharacterFun, haarScalarFactor_self]", "tactic_state": "x\u271d : Sort u_2\nmodularCharacterFun : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem MeasurableSet.const_smul {G \u03b1 : Type*} [Group G] [MulAction G \u03b1] [MeasurableSpace G]\n    [MeasurableSpace \u03b1] [MeasurableSMul G \u03b1] {s : Set \u03b1} (hs : MeasurableSet s) (a : G) :\n    MeasurableSet (a \u2022 s) := by\n  rw [\u2190 preimage_smul_inv]\n  exact measurable_const_smul _ hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Pointwise.lean", "context": {"open": ["Pointwise", "Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G \u03b1\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSMul G \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\na : G\n\u22a2 MeasurableSet (a \u2022 s)"}, {"line": "rw [\u2190 preimage_smul_inv]", "tactic_state": "G : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G \u03b1\ninst\u271d\u00b2 : MeasurableSpace G\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSMul G \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\na : G\n\u22a2 MeasurableSet ((fun x => a\u207b\u00b9 \u2022 x) \u207b\u00b9' s)"}, {"line": "exact measurable_const_smul _ hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MeasurableSet.const_smul\u2080 {G\u2080 \u03b1 : Type*} [GroupWithZero G\u2080] [Zero \u03b1]\n    [MulActionWithZero G\u2080 \u03b1] [MeasurableSpace G\u2080] [MeasurableSpace \u03b1] [MeasurableSMul G\u2080 \u03b1]\n    [MeasurableSingletonClass \u03b1] {s : Set \u03b1} (hs : MeasurableSet s) (a : G\u2080) :\n    MeasurableSet (a \u2022 s) := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  exacts [(subsingleton_zero_smul_set s).measurableSet, hs.const_smul_of_ne_zero ha]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Pointwise.lean", "context": {"open": ["Pointwise", "Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : GroupWithZero G\u2080\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : MulActionWithZero G\u2080 \u03b1\ninst\u271d\u00b3 : MeasurableSpace G\u2080\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSMul G\u2080 \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\na : G\u2080\n\u22a2 MeasurableSet (a \u2022 s)"}, {"line": "rcases eq_or_ne a 0 with (rfl | ha)", "tactic_state": "case inl\nG\u2080 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : GroupWithZero G\u2080\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : MulActionWithZero G\u2080 \u03b1\ninst\u271d\u00b3 : MeasurableSpace G\u2080\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSMul G\u2080 \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\n\u22a2 MeasurableSet (sorry \u2022 s)\n---\ncase inr\nG\u2080 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : GroupWithZero G\u2080\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : MulActionWithZero G\u2080 \u03b1\ninst\u271d\u00b3 : MeasurableSpace G\u2080\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : MeasurableSMul G\u2080 \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\ns : Set \u03b1\nhs : MeasurableSet s\na : G\u2080\nha : a \u2260 sorry\n\u22a2 MeasurableSet (a \u2022 s)"}, {"line": "exacts [(subsingleton_zero_smul_set s).measurableSet, hs.const_smul_of_ne_zero ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma measurableSet_eq_fun' {\u03b2 : Type*} [AddCommMonoid \u03b2] [PartialOrder \u03b2]\n    [CanonicallyOrderedAdd \u03b2] [Sub \u03b2] [OrderedSub \u03b2]\n    {_ : MeasurableSpace \u03b2} [MeasurableSub\u2082 \u03b2] [MeasurableSingletonClass \u03b2]\n    {f g : \u03b1 \u2192 \u03b2} (hf : Measurable f) (hg : Measurable g) :\n    MeasurableSet {x | f x = g x} := by\n  have : {a | f a = g a} = {a | (f - g) a = 0} \u2229 {a | (g - f) a = 0} := by\n    ext\n    simp only [Set.mem_setOf_eq]\n    simp only [Pi.sub_apply]\n    simp only [tsub_eq_zero_iff_le]\n    simp only [Set.mem_inter_iff]\n    exact \u27e8fun h \u21a6 \u27e8h.le, h.symm.le\u27e9, fun h \u21a6 le_antisymm h.1 h.2\u27e9\n  rw [this]\n  exact ((hf.sub hg) (measurableSet_singleton 0)).inter ((hg.sub hf) (measurableSet_singleton 0))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Arithmetic.lean", "context": {"open": ["MeasureTheory", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "{M \u03b1 \u03b2 : Type*} [MeasurableSpace M] [Mul M] {m : MeasurableSpace \u03b1}", "{\u03b2 \u03b3 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] [MeasurablePow \u03b2 \u03b3]", "{G \u03b1 \u03b2 : Type*} [MeasurableSpace G] [Div G] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\nm : MeasurableSpace \u03b1\n\u03b2 : Type u_11\ninst\u271d\u2076 : AddCommMonoid \u03b2\ninst\u271d\u2075 : PartialOrder \u03b2\ninst\u271d\u2074 : CanonicallyOrderedAdd \u03b2\ninst\u271d\u00b3 : Sub \u03b2\ninst\u271d\u00b2 : OrderedSub \u03b2\nx\u271d : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSub\u2082 \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\nf g : \u03b1 \u2192 \u03b2\nhf : Measurable f\nhg : Measurable g\n\u22a2 MeasurableSet {x | f x = g x}"}, {"line": "have : {a | f a = g a} = {a | (f - g) a = 0} \u2229 {a | (g - f) a = 0} := by\n    ext\n    simp only [Set.mem_setOf_eq]\n    simp only [Pi.sub_apply]\n    simp only [tsub_eq_zero_iff_le]\n    simp only [Set.mem_inter_iff]\n    exact \u27e8fun h \u21a6 \u27e8h.le, h.symm.le\u27e9, fun h \u21a6 le_antisymm h.1 h.2\u27e9", "tactic_state": "\u03b1 : Type u_9\nm : MeasurableSpace \u03b1\n\u03b2 : Type u_11\ninst\u271d\u2076 : AddCommMonoid \u03b2\ninst\u271d\u2075 : PartialOrder \u03b2\ninst\u271d\u2074 : CanonicallyOrderedAdd \u03b2\ninst\u271d\u00b3 : Sub \u03b2\ninst\u271d\u00b2 : OrderedSub \u03b2\nx\u271d : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSub\u2082 \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\nf g : \u03b1 \u2192 \u03b2\nhf : Measurable f\nhg : Measurable g\nthis : {a | f a = g a} = {a | sorry = 0} \u2229 {a | sorry = 0}\n\u22a2 MeasurableSet {x | f x = g x}"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_9\nm : MeasurableSpace \u03b1\n\u03b2 : Type u_11\ninst\u271d\u2076 : AddCommMonoid \u03b2\ninst\u271d\u2075 : PartialOrder \u03b2\ninst\u271d\u2074 : CanonicallyOrderedAdd \u03b2\ninst\u271d\u00b3 : Sub \u03b2\ninst\u271d\u00b2 : OrderedSub \u03b2\nx\u271d : MeasurableSpace \u03b2\ninst\u271d\u00b9 : MeasurableSub\u2082 \u03b2\ninst\u271d : MeasurableSingletonClass \u03b2\nf g : \u03b1 \u2192 \u03b2\nhf : Measurable f\nhg : Measurable g\nthis : {a | f a = g a} = {a | sorry = 0} \u2229 {a | sorry = 0}\n\u22a2 MeasurableSet ({a | sorry = 0} \u2229 {a | sorry = 0})"}, {"line": "exact ((hf.sub hg) (measurableSet_singleton 0)).inter ((hg.sub hf) (measurableSet_singleton 0))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_eq_trim_of_measurable {\u03b1 E} {m m0 : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}\n    [MeasurableSpace E] [AddGroup E] [MeasurableSingletonClass E] [MeasurableSub\u2082 E]\n    (hm : m \u2264 m0) {f g : \u03b1 \u2192 E} (hf : Measurable[m] f) (hg : Measurable[m] g) (hfg : f =\u1d50[\u03bc] g) :\n    f =\u1d50[\u03bc.trim hm] g := by\n  rwa [Filter.EventuallyEq, ae_iff, trim_measurableSet_eq hm _]\n  exact @MeasurableSet.compl \u03b1 _ m (@measurableSet_eq_fun \u03b1 m E _ _ _ _ _ _ hf hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Arithmetic.lean", "context": {"open": ["MeasureTheory", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "{M \u03b1 \u03b2 : Type*} [MeasurableSpace M] [Mul M] {m : MeasurableSpace \u03b1}", "{\u03b2 \u03b3 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] [MeasurablePow \u03b2 \u03b3]", "{G \u03b1 \u03b2 : Type*} [MeasurableSpace G] [Div G] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\nE : Type u_12\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : AddGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass E\ninst\u271d : MeasurableSub\u2082 E\nhm : m \u2264 m0\nf g : \u03b1 \u2192 E\nhf : Measurable f\nhg : Measurable g\nhfg : f =\u1da0[ae \u03bc] g\n\u22a2 f =\u1da0[ae (\u03bc.trim hm)] g"}, {"line": "rwa [Filter.EventuallyEq, ae_iff, trim_measurableSet_eq hm _]", "tactic_state": "\u03b1 : Type u_11\nE : Type u_12\nm m0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d\u00b3 : MeasurableSpace E\ninst\u271d\u00b2 : AddGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass E\ninst\u271d : MeasurableSub\u2082 E\nhm : m \u2264 m0\nf g : \u03b1 \u2192 E\nhf : Measurable f\nhg : Measurable g\nhfg : f =\u1da0[ae \u03bc] g\n\u22a2 MeasurableSet {a | \u00acf a = g a}"}, {"line": "exact @MeasurableSet.compl \u03b1 _ m (@measurableSet_eq_fun \u03b1 m E _ _ _ _ _ _ hf hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem List.measurable_prod (l : List (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, Measurable f) :\n    Measurable fun x => (l.map fun f : \u03b1 \u2192 M => f x).prod := by\n  simpa only [\u2190 Pi.list_prod_apply] using l.measurable_prod' hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Arithmetic.lean", "context": {"open": ["MeasureTheory", "scoped Pointwise", "MulOpposite"], "variables": ["{\u03b1 : Type*}", "{M \u03b1 \u03b2 : Type*} [MeasurableSpace M] [Mul M] {m : MeasurableSpace \u03b1}", "{\u03b2 \u03b3 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] [MeasurablePow \u03b2 \u03b3]", "{G \u03b1 \u03b2 : Type*} [MeasurableSpace G] [Div G] {m : MeasurableSpace \u03b1}", "{G \u03b1 : Type*} [Inv G] [MeasurableSpace G] [MeasurableInv G] {m : MeasurableSpace \u03b1}", "{M X \u03b1 \u03b2 : Type*} [MeasurableSpace X] [SMul M X]", "[MeasurableConstSMul M X]", "[MeasurableSpace M]", "[MeasurableSMul M X]", "{\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u03b1}", "{G G\u2080 M \u03b2 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1}", "{G : Type*} [Group G] [MulAction G \u03b2] [MeasurableConstSMul G \u03b2]", "[Monoid M] [MulAction M \u03b2]", "[MeasurableConstSMul M \u03b2]", "[MeasurableSpace M] [MeasurableSMul M \u03b2]", "[GroupWithZero G\u2080] [MeasurableSpace G\u2080] [MulAction G\u2080 \u03b2] [MeasurableSMul G\u2080 \u03b2]", "{M \u03b1 : Type*} [Monoid M] [MeasurableSpace M] [MeasurableMul\u2082 M] {m : MeasurableSpace \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_24\n\u03b1 : Type u_25\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : MeasurableSpace M\ninst\u271d : MeasurableMul\u2082 M\nm : MeasurableSpace \u03b1\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, Measurable f\n\u22a2 Measurable fun x => (map (fun f => f x) l).prod"}, {"line": "simpa only [\u2190 Pi.list_prod_apply] using l.measurable_prod' hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.measurable_prod' (l : Multiset (\u03b1 \u2192 M)) (hl : \u2200 f \u2208 l, Measurable f) :\n    Measurable l.prod := by\n  rcases l with \u27e8l\u27e9\n  simpa using l.measurable_prod' (by simpa using hl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Arithmetic.lean", "context": {"open": ["MeasureTheory", "scoped Pointwise", "MulOpposite"], "variables": ["{\u03b1 : Type*}", "{M \u03b1 \u03b2 : Type*} [MeasurableSpace M] [Mul M] {m : MeasurableSpace \u03b1}", "{\u03b2 \u03b3 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] [MeasurablePow \u03b2 \u03b3]", "{G \u03b1 \u03b2 : Type*} [MeasurableSpace G] [Div G] {m : MeasurableSpace \u03b1}", "{G \u03b1 : Type*} [Inv G] [MeasurableSpace G] [MeasurableInv G] {m : MeasurableSpace \u03b1}", "{M X \u03b1 \u03b2 : Type*} [MeasurableSpace X] [SMul M X]", "[MeasurableConstSMul M X]", "[MeasurableSpace M]", "[MeasurableSMul M X]", "{\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u03b1}", "{G G\u2080 M \u03b2 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1}", "{G : Type*} [Group G] [MulAction G \u03b2] [MeasurableConstSMul G \u03b2]", "[Monoid M] [MulAction M \u03b2]", "[MeasurableConstSMul M \u03b2]", "[MeasurableSpace M] [MeasurableSMul M \u03b2]", "[GroupWithZero G\u2080] [MeasurableSpace G\u2080] [MulAction G\u2080 \u03b2] [MeasurableSMul G\u2080 \u03b2]", "{M \u03b1 : Type*} [Monoid M] [MeasurableSpace M] [MeasurableMul\u2082 M] {m : MeasurableSpace \u03b1}", "{M \u03b9 \u03b1 \u03b2 : Type*} [CommMonoid M] [MeasurableSpace M] [MeasurableMul\u2082 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_26\n\u03b1 : Type u_28\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : MeasurableSpace M\ninst\u271d : MeasurableMul\u2082 M\nl : Multiset (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 l, sorry\n\u22a2 sorry"}, {"line": "rcases l with \u27e8l\u27e9", "tactic_state": "case mk\nM : Type u_26\n\u03b1 : Type u_28\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : MeasurableSpace M\ninst\u271d : MeasurableMul\u2082 M\nl\u271d : Multiset (\u03b1 \u2192 M)\nl : List (\u03b1 \u2192 M)\nhl : \u2200 f \u2208 Quot.mk (\u21d1(List.isSetoid (\u03b1 \u2192 M))) l, sorry\n\u22a2 sorry"}, {"line": "simpa using l.measurable_prod' (by simpa using hl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.measurable_prod (s : Multiset (\u03b1 \u2192 M)) (hs : \u2200 f \u2208 s, Measurable f) :\n    Measurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod := by\n  simpa only [\u2190 Pi.multiset_prod_apply] using s.measurable_prod' hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Arithmetic.lean", "context": {"open": ["MeasureTheory", "scoped Pointwise", "MulOpposite"], "variables": ["{\u03b1 : Type*}", "{M \u03b1 \u03b2 : Type*} [MeasurableSpace M] [Mul M] {m : MeasurableSpace \u03b1}", "{\u03b2 \u03b3 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b3] [Pow \u03b2 \u03b3] [MeasurablePow \u03b2 \u03b3]", "{G \u03b1 \u03b2 : Type*} [MeasurableSpace G] [Div G] {m : MeasurableSpace \u03b1}", "{G \u03b1 : Type*} [Inv G] [MeasurableSpace G] [MeasurableInv G] {m : MeasurableSpace \u03b1}", "{M X \u03b1 \u03b2 : Type*} [MeasurableSpace X] [SMul M X]", "[MeasurableConstSMul M X]", "[MeasurableSpace M]", "[MeasurableSMul M X]", "{\u03b1 : Type*} {_ : MeasurableSpace \u03b1} {f : \u03b1 \u2192 \u03b1}", "{G G\u2080 M \u03b2 \u03b1 : Type*} [MeasurableSpace \u03b2] [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1}", "{G : Type*} [Group G] [MulAction G \u03b2] [MeasurableConstSMul G \u03b2]", "[Monoid M] [MulAction M \u03b2]", "[MeasurableConstSMul M \u03b2]", "[MeasurableSpace M] [MeasurableSMul M \u03b2]", "[GroupWithZero G\u2080] [MeasurableSpace G\u2080] [MulAction G\u2080 \u03b2] [MeasurableSMul G\u2080 \u03b2]", "{M \u03b1 : Type*} [Monoid M] [MeasurableSpace M] [MeasurableMul\u2082 M] {m : MeasurableSpace \u03b1}", "{M \u03b9 \u03b1 \u03b2 : Type*} [CommMonoid M] [MeasurableSpace M] [MeasurableMul\u2082 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_26\n\u03b1 : Type u_28\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : MeasurableSpace M\ninst\u271d : MeasurableMul\u2082 M\ns : Multiset (\u03b1 \u2192 M)\nhs : \u2200 f \u2208 s, sorry\n\u22a2 sorry"}, {"line": "simpa only [\u2190 Pi.multiset_prod_apply] using s.measurable_prod' hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pair_mem_lattice_not_disjoint_vadd [AddGroup L] [Countable L] [AddAction L E]\n    [MeasurableSpace L] [MeasurableVAdd L E] [VAddInvariantMeasure L E \u03bc]\n    (fund : IsAddFundamentalDomain L F \u03bc) (hS : NullMeasurableSet s \u03bc) (h : \u03bc F < \u03bc s) :\n    \u2203 x y : L, x \u2260 y \u2227 \u00acDisjoint (x +\u1d65 s) (y +\u1d65 s) := by\n  contrapose! h\n  exact ((fund.measure_eq_tsum _).trans (measure_iUnion\u2080\n    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)\n      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le\n      (measure_mono <| Set.iUnion_subset fun _ => Set.inter_subset_right)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/GeometryOfNumbers.lean", "context": {"open": ["ENNReal Module MeasureTheory MeasureTheory.Measure Set Filter", "scoped Pointwise NNReal"], "variables": ["{E L : Type*} [MeasurableSpace E] {\u03bc : Measure E} {F s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nL : Type u_2\ninst\u271d\u2076 : MeasurableSpace E\n\u03bc : Measure E\nF s : Set E\ninst\u271d\u2075 : AddGroup L\ninst\u271d\u2074 : Countable L\ninst\u271d\u00b3 : AddAction L E\ninst\u271d\u00b2 : MeasurableSpace L\ninst\u271d\u00b9 : MeasurableVAdd L E\ninst\u271d : VAddInvariantMeasure L E \u03bc\nfund : IsAddFundamentalDomain L F \u03bc\nhS : NullMeasurableSet s \u03bc\nh : \u03bc F < \u03bc s\n\u22a2 \u2203 x y, x \u2260 y \u2227 \u00acDisjoint (x +\u1d65 s) (y +\u1d65 s)"}, {"line": "contrapose! h", "tactic_state": "E : Type u_1\nL : Type u_2\ninst\u271d\u2076 : MeasurableSpace E\n\u03bc : Measure E\nF s : Set E\ninst\u271d\u2075 : AddGroup L\ninst\u271d\u2074 : Countable L\ninst\u271d\u00b3 : AddAction L E\ninst\u271d\u00b2 : MeasurableSpace L\ninst\u271d\u00b9 : MeasurableVAdd L E\ninst\u271d : VAddInvariantMeasure L E \u03bc\nfund : IsAddFundamentalDomain L F \u03bc\nhS : NullMeasurableSet s \u03bc\nh : \u2200 (x y : L), x \u2260 y \u2192 Disjoint (x +\u1d65 s) (y +\u1d65 s)\n\u22a2 \u03bc s \u2264 \u03bc F"}, {"line": "exact ((fund.measure_eq_tsum _).trans (measure_iUnion\u2080\n    (Pairwise.mono h fun i j hij => (hij.mono inf_le_left inf_le_left).aedisjoint)\n      fun _ => (hS.vadd _).inter fund.nullMeasurableSet).symm).trans_le\n      (measure_mono <| Set.iUnion_subset fun _ => Set.inter_subset_right)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quasiMeasurePreserving_div_left [IsMulLeftInvariant \u03bc] (g : G) :\n    QuasiMeasurePreserving (fun h : G => g / h) \u03bc \u03bc := by\n  simp_rw [div_eq_mul_inv]\n  exact\n    (measurePreserving_mul_left \u03bc g).quasiMeasurePreserving.comp (quasiMeasurePreserving_inv \u03bc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Group/Prod.lean", "context": {"open": ["Set hiding prod_eq", "Function MeasureTheory", "Filter hiding map", "scoped ENNReal Pointwise MeasureTheory", "Measure"], "variables": ["(G : Type*) [MeasurableSpace G]", "[Group G] [MeasurableMul\u2082 G]", "(\u03bc \u03bd : Measure G) [SFinite \u03bd] [SFinite \u03bc] {s : Set G}", "{G}", "[MeasurableInv G]", "[IsMulLeftInvariant \u03bc]", "(\u03bc' \u03bd' : Measure G) [SigmaFinite \u03bc'] [SigmaFinite \u03bd'] [IsMulLeftInvariant \u03bc']", "[MeasurableInv G]", "[MeasurableInv G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : Group G\ninst\u271d\u2076 : MeasurableMul\u2082 G\n\u03bc : Measure G\ninst\u271d\u2075 : SFinite \u03bc\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : \u03bc.IsMulLeftInvariant\ninst\u271d\u00b2 inst\u271d\u00b9 : MeasurableInv G\ninst\u271d : \u03bc.IsMulLeftInvariant\ng : G\n\u22a2 QuasiMeasurePreserving (fun h => g / h) \u03bc \u03bc"}, {"line": "simp_rw [div_eq_mul_inv]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : MeasurableSpace G\ninst\u271d\u2077 : Group G\ninst\u271d\u2076 : MeasurableMul\u2082 G\n\u03bc : Measure G\ninst\u271d\u2075 : SFinite \u03bc\ninst\u271d\u2074 : MeasurableInv G\ninst\u271d\u00b3 : \u03bc.IsMulLeftInvariant\ninst\u271d\u00b2 inst\u271d\u00b9 : MeasurableInv G\ninst\u271d : \u03bc.IsMulLeftInvariant\ng : G\n\u22a2 QuasiMeasurePreserving (fun h => g * h\u207b\u00b9) \u03bc \u03bc"}, {"line": "exact\n    (measurePreserving_mul_left \u03bc g).quasiMeasurePreserving.comp (quasiMeasurePreserving_inv \u03bc)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsBigO.integrable (hfm : AEStronglyMeasurable f \u03bc)\n    (hf : f =O[\u22a4] g) (hg : Integrable g \u03bc) : Integrable f \u03bc := by\n  rewrite [\u2190 integrableAtFilter_top] at *\n  exact hf.integrableAtFilter \u27e8univ, univ_mem, hfm.restrict\u27e9 hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Asymptotics.lean", "context": {"open": ["Asymptotics MeasureTheory Set Filter"], "variables": ["{\u03b1 E F : Type*} [NormedAddCommGroup E] {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {a : \u03b1} {l : Filter \u03b1}", "[MeasurableSpace \u03b1] [NormedAddCommGroup F] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup F\n\u03bc : Measure \u03b1\nhfm : AEStronglyMeasurable f \u03bc\nhf : f =O[\u22a4] g\nhg : Integrable g \u03bc\n\u22a2 Integrable f \u03bc"}, {"line": "rewrite [\u2190 integrableAtFilter_top] at *", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ng : \u03b1 \u2192 F\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup F\n\u03bc : Measure \u03b1\nhfm : AEStronglyMeasurable f \u03bc\nhf : f =O[\u22a4] g\nhg : IntegrableAtFilter g \u22a4 \u03bc\n\u22a2 IntegrableAtFilter f \u22a4 \u03bc"}, {"line": "exact hf.integrableAtFilter \u27e8univ, univ_mem, hfm.restrict\u27e9 hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_of_nnreal [OpensMeasurableSpace X] (f : X \u2192\u1d47 \u211d\u22650) :\n    Integrable (((\u2191) : \u211d\u22650 \u2192 \u211d) \u2218 \u21d1f) \u03bc := by\n  refine \u27e8(NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable, ?_\u27e9\n  simp only [hasFiniteIntegral_iff_enorm]\n  simp only [Function.comp_apply]\n  simp only [NNReal.enorm_eq]\n  exact lintegral_lt_top_of_nnreal _ f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "context": {"open": ["MeasureTheory Filter", "scoped ENNReal NNReal BoundedContinuousFunction Topology"], "variables": ["{X : Type*} [MeasurableSpace X] [TopologicalSpace X]", "(\u03bc : Measure X) [IsFiniteMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\n\u22a2 Integrable (NNReal.toReal \u2218 \u21d1f) \u03bc"}, {"line": "refine \u27e8(NNReal.continuous_coe.comp f.continuous).measurable.aestronglyMeasurable, ?_\u27e9", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\n\u22a2 HasFiniteIntegral (NNReal.toReal \u2218 \u21d1f) \u03bc"}, {"line": "simp only [hasFiniteIntegral_iff_enorm]", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\n\u22a2 \u222b\u207b (a : X), \u2016(NNReal.toReal \u2218 \u21d1f) a\u2016\u2091 \u2202\u03bc < \u22a4"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\n\u22a2 \u222b\u207b (a : X), \u2016\u2191(f a)\u2016\u2091 \u2202\u03bc < \u22a4"}, {"line": "simp only [NNReal.enorm_eq]", "tactic_state": "X : Type u_1\ninst\u271d\u00b3 : MeasurableSpace X\ninst\u271d\u00b2 : TopologicalSpace X\n\u03bc : Measure X\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : OpensMeasurableSpace X\nf : BoundedContinuousFunction X NNReal\n\u22a2 \u222b\u207b (a : X), \u2191(f a) \u2202\u03bc < \u22a4"}, {"line": "exact lintegral_lt_top_of_nnreal _ f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_add_const (f : X \u2192\u1d47 \u211d) (c : \u211d) :\n    \u222b x, (f + const X c) x \u2202\u03bc = \u222b x, f x \u2202\u03bc + \u03bc.real Set.univ \u2022 c := by\n  simp [integral_add (f.integrable _) (integrable_const c)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "context": {"open": ["MeasureTheory Filter", "scoped ENNReal NNReal BoundedContinuousFunction Topology"], "variables": ["{X : Type*} [MeasurableSpace X] [TopologicalSpace X]", "(\u03bc : Measure X) [IsFiniteMeasure \u03bc]", "{X : Type*} [MeasurableSpace X] [TopologicalSpace X]", "(\u03bc : Measure X)", "{E : Type*} [NormedAddCommGroup E]", "[OpensMeasurableSpace X] [SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E]", "[NormedSpace \u211d E]", "{X : Type*} [TopologicalSpace X]", "[MeasurableSpace X] [OpensMeasurableSpace X] {\u03bc : Measure X} [IsFiniteMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\n\u03bc : Measure X\ninst\u271d : IsFiniteMeasure \u03bc\nx\u271d : Sort u_5\nconst : x\u271d\nf : BoundedContinuousFunction X \u211d\nc : \u211d\n\u22a2 \u222b (x : X), (f + sorry) x \u2202\u03bc = \u222b (x : X), f x \u2202\u03bc + \u03bc.real Set.univ \u2022 c"}, {"line": "simp [integral_add (f.integrable _) (integrable_const c)]", "tactic_state": "X : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\n\u03bc : Measure X\ninst\u271d : IsFiniteMeasure \u03bc\nx\u271d : Sort u_5\nconst : x\u271d\nf : BoundedContinuousFunction X \u211d\nc : \u211d\n\u22a2 \u222b (x : X), f x + (sorry ()) x \u2202\u03bc = \u222b (x : X), f x \u2202\u03bc + \u03bc.real Set.univ * c"}]}
{"declaration": "lemma integral_const_sub (f : X \u2192\u1d47 \u211d) (c : \u211d) :\n    \u222b x, (const X c - f) x \u2202\u03bc = \u03bc.real Set.univ \u2022 c - \u222b x, f x \u2202\u03bc := by\n  simp [integral_sub (integrable_const c) (f.integrable _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/BoundedContinuousFunction.lean", "context": {"open": ["MeasureTheory Filter", "scoped ENNReal NNReal BoundedContinuousFunction Topology"], "variables": ["{X : Type*} [MeasurableSpace X] [TopologicalSpace X]", "(\u03bc : Measure X) [IsFiniteMeasure \u03bc]", "{X : Type*} [MeasurableSpace X] [TopologicalSpace X]", "(\u03bc : Measure X)", "{E : Type*} [NormedAddCommGroup E]", "[OpensMeasurableSpace X] [SecondCountableTopology E] [MeasurableSpace E] [BorelSpace E]", "[NormedSpace \u211d E]", "{X : Type*} [TopologicalSpace X]", "[MeasurableSpace X] [OpensMeasurableSpace X] {\u03bc : Measure X} [IsFiniteMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\n\u03bc : Measure X\ninst\u271d : IsFiniteMeasure \u03bc\nx\u271d : Sort u_5\nconst : x\u271d\nf : BoundedContinuousFunction X \u211d\nc : \u211d\n\u22a2 \u222b (x : X), (sorry - f) x \u2202\u03bc = \u03bc.real Set.univ \u2022 c - \u222b (x : X), f x \u2202\u03bc"}, {"line": "simp [integral_sub (integrable_const c) (f.integrable _)]", "tactic_state": "X : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : MeasurableSpace X\ninst\u271d\u00b9 : OpensMeasurableSpace X\n\u03bc : Measure X\ninst\u271d : IsFiniteMeasure \u03bc\nx\u271d : Sort u_5\nconst : x\u271d\nf : BoundedContinuousFunction X \u211d\nc : \u211d\n\u22a2 \u222b (x : X), (sorry ()) x - f x \u2202\u03bc = \u03bc.real Set.univ * c - \u222b (x : X), f x \u2202\u03bc"}]}
{"declaration": "theorem integral_rpow_mul_exp_neg_rpow {p q : \u211d} (hp : 0 < p) (hq : -1 < q) :\n    \u222b x in Ioi (0 : \u211d), x ^ q * exp (- x ^ p) = (1 / p) * Gamma ((q + 1) / p) := by\n  calc\n    _ = \u222b (x : \u211d) in Ioi 0, (1 / p * x ^ (1 / p - 1)) \u2022 ((x ^ (1 / p)) ^ q * exp (-x)) := by\n      rw [\u2190 integral_comp_rpow_Ioi _ (one_div_ne_zero (ne_of_gt hp))]\n      rw [abs_eq_self.mpr (le_of_lt (one_div_pos.mpr hp))]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [\u2190 rpow_mul (le_of_lt hx) _ p]\n      rw [one_div_mul_cancel (ne_of_gt hp)]\n      rw [rpow_one]\n    _ = \u222b (x : \u211d) in Ioi 0, 1 / p * exp (-x) * x ^ (1 / p - 1 + q / p) := by\n      simp_rw [smul_eq_mul, mul_assoc]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [\u2190 rpow_mul (le_of_lt hx)]\n      rw [div_mul_eq_mul_div]\n      rw [one_mul]\n      rw [rpow_add hx]\n      ring_nf\n    _ = (1 / p) * Gamma ((q + 1) / p) := by\n      rw [Gamma_eq_integral (div_pos (neg_lt_iff_pos_add.mp hq) hp)]\n      simp_rw [show 1 / p - 1 + q / p = (q + 1) / p - 1 by field_simp; ring, \u2190 integral_const_mul,\n        \u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nhp : 0 < p\nhq : -1 < q\n\u22a2 \u222b (x : \u211d) in Ioi 0, x ^ q * exp (-x ^ p) = 1 / p * Gamma ((q + 1) / p)"}, {"line": "calc\n    _ = \u222b (x : \u211d) in Ioi 0, (1 / p * x ^ (1 / p - 1)) \u2022 ((x ^ (1 / p)) ^ q * exp (-x)) := by\n      rw [\u2190 integral_comp_rpow_Ioi _ (one_div_ne_zero (ne_of_gt hp))]\n      rw [abs_eq_self.mpr (le_of_lt (one_div_pos.mpr hp))]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [\u2190 rpow_mul (le_of_lt hx) _ p]\n      rw [one_div_mul_cancel (ne_of_gt hp)]\n      rw [rpow_one]\n    _ = \u222b (x : \u211d) in Ioi 0, 1 / p * exp (-x) * x ^ (1 / p - 1 + q / p) := by\n      simp_rw [smul_eq_mul, mul_assoc]\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [\u2190 rpow_mul (le_of_lt hx)]\n      rw [div_mul_eq_mul_div]\n      rw [one_mul]\n      rw [rpow_add hx]\n      ring_nf\n    _ = (1 / p) * Gamma ((q + 1) / p) := by\n      rw [Gamma_eq_integral (div_pos (neg_lt_iff_pos_add.mp hq) hp)]\n      simp_rw [show 1 / p - 1 + q / p = (q + 1) / p - 1 by field_simp; ring, \u2190 integral_const_mul,\n        \u2190 mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_rpow_mul_exp_neg_mul_rpow {p q b : \u211d} (hp : 0 < p) (hq : -1 < q) (hb : 0 < b) :\n    \u222b x in Ioi (0 : \u211d), x ^ q * exp (- b * x ^ p) =\n      b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p) := by\n  calc\n    _ = \u222b x in Ioi (0 : \u211d), b ^ (-p\u207b\u00b9 * q) * ((b ^ p\u207b\u00b9 * x) ^ q * rexp (-(b ^ p\u207b\u00b9 * x) ^ p)) := by\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [mul_rpow _ (le_of_lt hx)]\n      rw [mul_rpow _ (le_of_lt hx)]\n      rw [\u2190 rpow_mul]\n      rw [\u2190 rpow_mul]\n      rw [inv_mul_cancel\u2080]\n      rw [rpow_one]\n      rw [mul_assoc]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 rpow_add]\n      rw [neg_mul p\u207b\u00b9]\n      rw [neg_add_cancel]\n      rw [rpow_zero]\n      rw [one_mul]\n      rw [neg_mul]\n      all_goals positivity\n    _ = (b ^ p\u207b\u00b9)\u207b\u00b9 * \u222b x in Ioi (0 : \u211d), b ^ (-p\u207b\u00b9 * q) * (x ^ q * rexp (-x ^ p)) := by\n      rw [integral_comp_mul_left_Ioi (fun x => b ^ (-p\u207b\u00b9 * q) * (x ^ q * exp (- x ^ p))) 0]\n      rw [mul_zero]\n      rw [smul_eq_mul]\n      all_goals positivity\n    _ = b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p) := by\n      rw [integral_const_mul]\n      rw [integral_rpow_mul_exp_neg_rpow _ hq]\n      rw [mul_assoc]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 rpow_neg_one]\n      rw [\u2190 rpow_mul]\n      rw [\u2190 rpow_add]\n      \u00b7 congr; ring\n      all_goals positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q b : \u211d\nhp : 0 < p\nhq : -1 < q\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in Ioi 0, x ^ q * exp (-b * x ^ p) = b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p)"}, {"line": "calc\n    _ = \u222b x in Ioi (0 : \u211d), b ^ (-p\u207b\u00b9 * q) * ((b ^ p\u207b\u00b9 * x) ^ q * rexp (-(b ^ p\u207b\u00b9 * x) ^ p)) := by\n      refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n      rw [mul_rpow _ (le_of_lt hx)]\n      rw [mul_rpow _ (le_of_lt hx)]\n      rw [\u2190 rpow_mul]\n      rw [\u2190 rpow_mul]\n      rw [inv_mul_cancel\u2080]\n      rw [rpow_one]\n      rw [mul_assoc]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 rpow_add]\n      rw [neg_mul p\u207b\u00b9]\n      rw [neg_add_cancel]\n      rw [rpow_zero]\n      rw [one_mul]\n      rw [neg_mul]\n      all_goals positivity\n    _ = (b ^ p\u207b\u00b9)\u207b\u00b9 * \u222b x in Ioi (0 : \u211d), b ^ (-p\u207b\u00b9 * q) * (x ^ q * rexp (-x ^ p)) := by\n      rw [integral_comp_mul_left_Ioi (fun x => b ^ (-p\u207b\u00b9 * q) * (x ^ q * exp (- x ^ p))) 0]\n      rw [mul_zero]\n      rw [smul_eq_mul]\n      all_goals positivity\n    _ = b ^ (-(q + 1) / p) * (1 / p) * Gamma ((q + 1) / p) := by\n      rw [integral_const_mul]\n      rw [integral_rpow_mul_exp_neg_rpow _ hq]\n      rw [mul_assoc]\n      rw [\u2190 mul_assoc]\n      rw [\u2190 rpow_neg_one]\n      rw [\u2190 rpow_mul]\n      rw [\u2190 rpow_add]\n      \u00b7 congr; ring\n      all_goals positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_neg_rpow {p : \u211d} (hp : 0 < p) :\n    \u222b x in Ioi (0 : \u211d), exp (- x ^ p) = Gamma (1 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_rpow hp neg_one_lt_zero) using 1\n  \u00b7 simp_rw [rpow_zero, one_mul]\n  \u00b7 rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nhp : 0 < p\n\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-x ^ p) = Gamma (1 / p + 1)"}, {"line": "convert (integral_rpow_mul_exp_neg_rpow hp neg_one_lt_zero) using 1", "tactic_state": "case h.e'_2\np : \u211d\nhp : 0 < p\n\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-x ^ p) = \u222b (x : \u211d) in Ioi 0, x ^ 0 * exp (-x ^ p)\n---\ncase h.e'_3\np : \u211d\nhp : 0 < p\n\u22a2 Gamma (1 / p + 1) = 1 / p * Gamma ((0 + 1) / p)"}, {"line": "\u00b7 simp_rw [rpow_zero, one_mul]", "tactic_state": "case h.e'_3\np : \u211d\nhp : 0 < p\n\u22a2 Gamma (1 / p + 1) = 1 / p * Gamma ((0 + 1) / p)"}, {"line": "\u00b7 rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_neg_mul_rpow {p b : \u211d} (hp : 0 < p) (hb : 0 < b) :\n    \u222b x in Ioi (0 : \u211d), exp (- b * x ^ p) = b ^ (- 1 / p) * Gamma (1 / p + 1) := by\n  convert (integral_rpow_mul_exp_neg_mul_rpow hp neg_one_lt_zero hb) using 1\n  \u00b7 simp_rw [rpow_zero, one_mul]\n  \u00b7 rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp)), mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p b : \u211d\nhp : 0 < p\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-b * x ^ p) = b ^ (-1 / p) * Gamma (1 / p + 1)"}, {"line": "convert (integral_rpow_mul_exp_neg_mul_rpow hp neg_one_lt_zero hb) using 1", "tactic_state": "case h.e'_2\np b : \u211d\nhp : 0 < p\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-b * x ^ p) = \u222b (x : \u211d) in Ioi 0, x ^ 0 * exp (-b * x ^ p)\n---\ncase h.e'_3\np b : \u211d\nhp : 0 < p\nhb : 0 < b\n\u22a2 b ^ (-1 / p) * Gamma (1 / p + 1) = b ^ (-(0 + 1) / p) * (1 / p) * Gamma ((0 + 1) / p)"}, {"line": "\u00b7 simp_rw [rpow_zero, one_mul]", "tactic_state": "case h.e'_3\np b : \u211d\nhp : 0 < p\nhb : 0 < b\n\u22a2 b ^ (-1 / p) * Gamma (1 / p + 1) = b ^ (-(0 + 1) / p) * (1 / p) * Gamma ((0 + 1) / p)"}, {"line": "\u00b7 rw [zero_add, Gamma_add_one (one_div_ne_zero (ne_of_gt hp)), mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.integral_rpow_mul_exp_neg_rpow {p q : \u211d} (hp : 1 \u2264 p) (hq : -2 < q) :\n    \u222b x : \u2102, \u2016x\u2016 ^ q * rexp (- \u2016x\u2016 ^ p) = (2 * \u03c0 / p) * Real.Gamma ((q + 2) / p) := by\n  calc\n    _ = \u222b x in Ioi (0 : \u211d) \u00d7\u02e2 Ioo (-\u03c0) \u03c0, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) := by\n      rw [\u2190 Complex.integral_comp_polarCoord_symm]\n      rw [polarCoord_target]\n      simp_rw [Complex.norm_polarCoord_symm, smul_eq_mul]\n    _ = (\u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (-|x| ^ p)) * \u222b _ in Ioo (-\u03c0) \u03c0, 1 := by\n      rw [\u2190 setIntegral_prod_mul]\n      rw [volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (-|x| ^ p) := by\n      simp_rw [integral_const, measureReal_restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_real_Ioo_of_le (a := -\u03c0) (b := \u03c0) (by linarith [pi_nonneg]),\n        sub_neg_eq_add, \u2190 two_mul, smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x ^ (q + 1) * rexp (-x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le]\n      rw [rpow_add hx]\n      rw [rpow_one]\n      ring\n    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith)]\n      rw [add_assoc]\n      rw [one_add_one_eq_two]\n      ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nhp : 1 \u2264 p\nhq : -2 < q\n\u22a2 \u222b (x : \u2102), \u2016x\u2016 ^ q * Real.exp (-\u2016x\u2016 ^ p) = 2 * Real.pi / p * Real.Gamma ((q + 2) / p)"}, {"line": "calc\n    _ = \u222b x in Ioi (0 : \u211d) \u00d7\u02e2 Ioo (-\u03c0) \u03c0, x.1 * (|x.1| ^ q * rexp (-|x.1| ^ p)) := by\n      rw [\u2190 Complex.integral_comp_polarCoord_symm]\n      rw [polarCoord_target]\n      simp_rw [Complex.norm_polarCoord_symm, smul_eq_mul]\n    _ = (\u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (-|x| ^ p)) * \u222b _ in Ioo (-\u03c0) \u03c0, 1 := by\n      rw [\u2190 setIntegral_prod_mul]\n      rw [volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (-|x| ^ p) := by\n      simp_rw [integral_const, measureReal_restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_real_Ioo_of_le (a := -\u03c0) (b := \u03c0) (by linarith [pi_nonneg]),\n        sub_neg_eq_add, \u2190 two_mul, smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x ^ (q + 1) * rexp (-x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le]\n      rw [rpow_add hx]\n      rw [rpow_one]\n      ring\n    _ = (2 * Real.pi / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_rpow (by linarith) (by linarith)]\n      rw [add_assoc]\n      rw [one_add_one_eq_two]\n      ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.integral_rpow_mul_exp_neg_mul_rpow {p q b : \u211d} (hp : 1 \u2264 p) (hq : -2 < q)\n    (hb : 0 < b) :\n    \u222b x : \u2102, \u2016x\u2016 ^ q * rexp (- b * \u2016x\u2016 ^ p) = (2 * \u03c0 / p) *\n      b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) := by\n  calc\n    _ = \u222b x in Ioi (0 : \u211d) \u00d7\u02e2 Ioo (-\u03c0) \u03c0, x.1 * (|x.1| ^ q * rexp (- b * |x.1| ^ p)) := by\n      rw [\u2190 Complex.integral_comp_polarCoord_symm]\n      rw [polarCoord_target]\n      simp_rw [Complex.norm_polarCoord_symm, smul_eq_mul]\n    _ = (\u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (- b * |x| ^ p)) * \u222b _ in Ioo (-\u03c0) \u03c0, 1 := by\n      rw [\u2190 setIntegral_prod_mul]\n      rw [volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (- b * |x| ^ p) := by\n      simp_rw [integral_const, measureReal_restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_real_Ioo_of_le (a := -\u03c0) (b := \u03c0) (by linarith [pi_nonneg]),\n        sub_neg_eq_add, \u2190 two_mul, smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x ^ (q + 1) * rexp (-b * x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le]\n      rw [rpow_add hx]\n      rw [rpow_one]\n      ring\n    _ = (2 * \u03c0 / p) * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_mul_rpow (by linarith) (by linarith) hb]\n      rw [add_assoc]\n      rw [one_add_one_eq_two]\n      ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Gamma.lean", "context": {"open": ["Real Set MeasureTheory MeasureTheory.Measure"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q b : \u211d\nhp : 1 \u2264 p\nhq : -2 < q\nhb : 0 < b\n\u22a2 \u222b (x : \u2102), \u2016x\u2016 ^ q * Real.exp (-b * \u2016x\u2016 ^ p) = 2 * Real.pi / p * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p)"}, {"line": "calc\n    _ = \u222b x in Ioi (0 : \u211d) \u00d7\u02e2 Ioo (-\u03c0) \u03c0, x.1 * (|x.1| ^ q * rexp (- b * |x.1| ^ p)) := by\n      rw [\u2190 Complex.integral_comp_polarCoord_symm]\n      rw [polarCoord_target]\n      simp_rw [Complex.norm_polarCoord_symm, smul_eq_mul]\n    _ = (\u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (- b * |x| ^ p)) * \u222b _ in Ioo (-\u03c0) \u03c0, 1 := by\n      rw [\u2190 setIntegral_prod_mul]\n      rw [volume_eq_prod]\n      simp_rw [mul_one]\n      congr! 2; ring\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x * |x| ^ q * rexp (- b * |x| ^ p) := by\n      simp_rw [integral_const, measureReal_restrict_apply MeasurableSet.univ, Set.univ_inter,\n        volume_real_Ioo_of_le (a := -\u03c0) (b := \u03c0) (by linarith [pi_nonneg]),\n        sub_neg_eq_add, \u2190 two_mul, smul_eq_mul, mul_one, mul_comm]\n    _ = 2 * \u03c0 * \u222b x in Ioi (0 : \u211d), x ^ (q + 1) * rexp (-b * x ^ p) := by\n      congr 1\n      refine setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)\n      rw [mem_Ioi] at hx\n      rw [abs_eq_self.mpr hx.le]\n      rw [rpow_add hx]\n      rw [rpow_one]\n      ring\n    _ = (2 * \u03c0 / p) * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) := by\n      rw [_root_.integral_rpow_mul_exp_neg_mul_rpow (by linarith) (by linarith) hb]\n      rw [add_assoc]\n      rw [one_add_one_eq_two]\n      ring", "tactic_state": "case calc.step\np q b : \u211d\nhp : 1 \u2264 p\nhq : -2 < q\nhb : 0 < b\n\u22a2 2 * sorry / p * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p) =\n    2 * Real.pi / p * b ^ (-(q + 2) / p) * Real.Gamma ((q + 2) / p)"}]}
{"declaration": "theorem laverage_zero_measure (f : \u03b1 \u2192 \u211d\u22650\u221e) : \u2a0d\u207b x, f x \u2202(0 : Measure \u03b1) = 0 := by simp [laverage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 ENNReal\n\u22a2 \u2a0d\u207b (x : \u03b1), f x \u22020 = 0"}, {"line": "simp [laverage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem laverage_union (hd : AEDisjoint \u03bc s t) (ht : NullMeasurableSet t \u03bc) :\n    \u2a0d\u207b x in s \u222a t, f x \u2202\u03bc =\n      \u03bc s / (\u03bc s + \u03bc t) * \u2a0d\u207b x in s, f x \u2202\u03bc + \u03bc t / (\u03bc s + \u03bc t) * \u2a0d\u207b x in t, f x \u2202\u03bc := by\n  rw [restrict_union\u2080 hd ht]\n  rw [laverage_add_measure]\n  rw [restrict_apply_univ]\n  rw [restrict_apply_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\n\u22a2 \u2a0d\u207b (x : \u03b1) in s \u222a t, f x \u2202\u03bc =\n    \u03bc s / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc + \u03bc t / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc"}, {"line": "rw [restrict_union\u2080 hd ht]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\n\u22a2 \u2a0d\u207b (x : \u03b1), f x \u2202(\u03bc.restrict s + \u03bc.restrict t) =\n    \u03bc s / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc + \u03bc t / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc"}, {"line": "rw [laverage_add_measure]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\n\u22a2 (\u03bc.restrict s) univ / ((\u03bc.restrict s) univ + (\u03bc.restrict t) univ) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc +\n      (\u03bc.restrict t) univ / ((\u03bc.restrict s) univ + (\u03bc.restrict t) univ) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc =\n    \u03bc s / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc + \u03bc t / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc"}, {"line": "rw [restrict_apply_univ]", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\n\u22a2 \u03bc s / (\u03bc s + (\u03bc.restrict t) univ) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc +\n      (\u03bc.restrict t) univ / (\u03bc s + (\u03bc.restrict t) univ) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc =\n    \u03bc s / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc + \u03bc t / (\u03bc s + \u03bc t) * \u2a0d\u207b (x : \u03b1) in t, f x \u2202\u03bc"}, {"line": "rw [restrict_apply_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem laverage_mem_openSegment_compl_self [IsFiniteMeasure \u03bc] (hs : NullMeasurableSet s \u03bc)\n    (hs\u2080 : \u03bc s \u2260 0) (hsc\u2080 : \u03bc s\u1d9c \u2260 0) :\n    \u2a0d\u207b x, f x \u2202\u03bc \u2208 openSegment \u211d\u22650\u221e (\u2a0d\u207b x in s, f x \u2202\u03bc) (\u2a0d\u207b x in s\u1d9c, f x \u2202\u03bc) := by\n  simpa only [union_compl_self,restrict_univ] using\n    laverage_union_mem_openSegment aedisjoint_compl_right hs.compl hs\u2080 hsc\u2080 (measure_ne_top _ _)\n      (measure_ne_top _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 ENNReal\ns : Set \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nhs : NullMeasurableSet s \u03bc\nhs\u2080 : \u03bc s \u2260 0\nhsc\u2080 : \u03bc s\u1d9c \u2260 0\n\u22a2 \u2a0d\u207b (x : \u03b1), f x \u2202\u03bc \u2208 openSegment ENNReal (\u2a0d\u207b (x : \u03b1) in s, f x \u2202\u03bc) (\u2a0d\u207b (x : \u03b1) in s\u1d9c, f x \u2202\u03bc)"}, {"line": "simpa only [union_compl_self,restrict_univ] using\n    laverage_union_mem_openSegment aedisjoint_compl_right hs.compl hs\u2080 hsc\u2080 (measure_ne_top _ _)\n      (measure_ne_top _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem laverage_mul_measure_univ (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    (\u2a0d\u207b (a : \u03b1), f a \u2202\u03bc) * \u03bc univ = \u222b\u207b x, f x \u2202\u03bc := by\n  obtain rfl | h\u03bc := eq_or_ne \u03bc 0\n  \u00b7 simp\n  \u00b7 rw [laverage_eq, ENNReal.div_mul_cancel (measure_univ_ne_zero.2 h\u03bc) (measure_ne_top _ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 ENNReal\n\u22a2 (\u2a0d\u207b (a : \u03b1), f a \u2202\u03bc) * \u03bc univ = \u222b\u207b (x : \u03b1), f x \u2202\u03bc"}, {"line": "obtain rfl | h\u03bc := eq_or_ne \u03bc 0", "tactic_state": "case inl\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\nf : \u03b1 \u2192 ENNReal\ninst\u271d : IsFiniteMeasure 0\n\u22a2 (\u2a0d\u207b (a : \u03b1), f a \u22020) * 0 univ = \u222b\u207b (x : \u03b1), f x \u22020\n---\ncase inr\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 ENNReal\nh\u03bc : \u03bc \u2260 0\n\u22a2 (\u2a0d\u207b (a : \u03b1), f a \u2202\u03bc) * \u03bc univ = \u222b\u207b (x : \u03b1), f x \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 ENNReal\nh\u03bc : \u03bc \u2260 0\n\u22a2 (\u2a0d\u207b (a : \u03b1), f a \u2202\u03bc) * \u03bc univ = \u222b\u207b (x : \u03b1), f x \u2202\u03bc"}, {"line": "\u00b7 rw [laverage_eq, ENNReal.div_mul_cancel (measure_univ_ne_zero.2 h\u03bc) (measure_ne_top _ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_laverage (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b _x, \u2a0d\u207b a, f a \u2202\u03bc \u2202\u03bc = \u222b\u207b x, f x \u2202\u03bc := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 ENNReal\n\u22a2 \u222b\u207b (_x : \u03b1), \u2a0d\u207b (a : \u03b1), f a \u2202\u03bc \u2202\u03bc = \u222b\u207b (x : \u03b1), f x \u2202\u03bc"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 ENNReal\n\u22a2 (\u2a0d\u207b (a : \u03b1), f a \u2202\u03bc) * \u03bc univ = \u222b\u207b (a : \u03b1), f a \u2202\u03bc"}]}
{"declaration": "theorem average_zero : \u2a0d _, (0 : E) \u2202\u03bc = 0 := by rw [average, integral_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure ?m.1527\n\u22a2 \u2a0d (x : ?m.1527), 0 \u2202\u03bc = 0"}, {"line": "rw [average, integral_zero]", "tactic_state": "\u22a2 {E : Type u_2} \u2192 [inst : NormedAddCommGroup E] \u2192 [inst : NormedSpace \u211d E] \u2192 MeasurableSpace ?m.2451"}]}
{"declaration": "theorem average_zero_measure (f : \u03b1 \u2192 E) : \u2a0d x, f x \u2202(0 : Measure \u03b1) = 0 := by\n  rw [average]\n  rw [smul_zero]\n  rw [integral_zero_measure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u03b1 \u2192 E\n\u22a2 \u2a0d (x : \u03b1), f x \u22020 = 0"}, {"line": "rw [average]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u03b1 \u2192 E\n\u22a2 \u222b (x : \u03b1), f x \u2202(0 univ)\u207b\u00b9 \u2022 0 = 0"}, {"line": "rw [smul_zero]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u03b1 \u2192 E\n\u22a2 \u222b (x : \u03b1), f x \u22020 = 0"}, {"line": "rw [integral_zero_measure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem average_union_mem_openSegment {f : \u03b1 \u2192 E} {s t : Set \u03b1} (hd : AEDisjoint \u03bc s t)\n    (ht : NullMeasurableSet t \u03bc) (hs\u2080 : \u03bc s \u2260 0) (ht\u2080 : \u03bc t \u2260 0) (hs\u03bc : \u03bc s \u2260 \u221e) (ht\u03bc : \u03bc t \u2260 \u221e)\n    (hfs : IntegrableOn f s \u03bc) (hft : IntegrableOn f t \u03bc) :\n    \u2a0d x in s \u222a t, f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d x in s, f x \u2202\u03bc) (\u2a0d x in t, f x \u2202\u03bc) := by\n  replace hs\u2080 : 0 < \u03bc.real s := ENNReal.toReal_pos hs\u2080 hs\u03bc\n  replace ht\u2080 : 0 < \u03bc.real t := ENNReal.toReal_pos ht\u2080 ht\u03bc\n  exact mem_openSegment_iff_div.mpr\n    \u27e8\u03bc.real s, \u03bc.real t, hs\u2080, ht\u2080, (average_union hd ht hs\u03bc ht\u03bc hfs hft).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\nhs\u2080 : \u03bc s \u2260 0\nht\u2080 : \u03bc t \u2260 0\nhs\u03bc : \u03bc s \u2260 \u22a4\nht\u03bc : \u03bc t \u2260 \u22a4\nhfs : IntegrableOn f s \u03bc\nhft : IntegrableOn f t \u03bc\n\u22a2 \u2a0d (x : \u03b1) in s \u222a t, f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d (x : \u03b1) in s, f x \u2202\u03bc) (\u2a0d (x : \u03b1) in t, f x \u2202\u03bc)"}, {"line": "replace hs\u2080 : 0 < \u03bc.real s := ENNReal.toReal_pos hs\u2080 hs\u03bc", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\nht\u2080 : \u03bc t \u2260 0\nhs\u03bc : \u03bc s \u2260 \u22a4\nht\u03bc : \u03bc t \u2260 \u22a4\nhfs : IntegrableOn f s \u03bc\nhft : IntegrableOn f t \u03bc\nhs\u2080 : 0 < \u03bc.real s\n\u22a2 \u2a0d (x : \u03b1) in s \u222a t, f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d (x : \u03b1) in s, f x \u2202\u03bc) (\u2a0d (x : \u03b1) in t, f x \u2202\u03bc)"}, {"line": "replace ht\u2080 : 0 < \u03bc.real t := ENNReal.toReal_pos ht\u2080 ht\u03bc", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhd : AEDisjoint \u03bc s t\nht : NullMeasurableSet t \u03bc\nhs\u03bc : \u03bc s \u2260 \u22a4\nht\u03bc : \u03bc t \u2260 \u22a4\nhfs : IntegrableOn f s \u03bc\nhft : IntegrableOn f t \u03bc\nhs\u2080 : 0 < \u03bc.real s\nht\u2080 : 0 < \u03bc.real t\n\u22a2 \u2a0d (x : \u03b1) in s \u222a t, f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d (x : \u03b1) in s, f x \u2202\u03bc) (\u2a0d (x : \u03b1) in t, f x \u2202\u03bc)"}, {"line": "exact mem_openSegment_iff_div.mpr\n    \u27e8\u03bc.real s, \u03bc.real t, hs\u2080, ht\u2080, (average_union hd ht hs\u03bc ht\u03bc hfs hft).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem average_mem_openSegment_compl_self [IsFiniteMeasure \u03bc] {f : \u03b1 \u2192 E} {s : Set \u03b1}\n    (hs : NullMeasurableSet s \u03bc) (hs\u2080 : \u03bc s \u2260 0) (hsc\u2080 : \u03bc s\u1d9c \u2260 0) (hfi : Integrable f \u03bc) :\n    \u2a0d x, f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d x in s, f x \u2202\u03bc) (\u2a0d x in s\u1d9c, f x \u2202\u03bc) := by\n  simpa only [union_compl_self,restrict_univ] using\n    average_union_mem_openSegment aedisjoint_compl_right hs.compl hs\u2080 hsc\u2080 (measure_ne_top _ _)\n      (measure_ne_top _ _) hfi.integrableOn hfi.integrableOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}", "{\u03bc}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nf : \u03b1 \u2192 E\ns : Set \u03b1\nhs : NullMeasurableSet s \u03bc\nhs\u2080 : \u03bc s \u2260 0\nhsc\u2080 : \u03bc s\u1d9c \u2260 0\nhfi : Integrable f \u03bc\n\u22a2 \u2a0d (x : \u03b1), f x \u2202\u03bc \u2208 openSegment \u211d (\u2a0d (x : \u03b1) in s, f x \u2202\u03bc) (\u2a0d (x : \u03b1) in s\u1d9c, f x \u2202\u03bc)"}, {"line": "simpa only [union_compl_self,restrict_univ] using\n    average_union_mem_openSegment aedisjoint_compl_right hs.compl hs\u2080 hsc\u2080 (measure_ne_top _ _)\n      (measure_ne_top _ _) hfi.integrableOn hfi.integrableOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem average_const (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] [h : NeZero \u03bc] (c : E) :\n    \u2a0d _x, c \u2202\u03bc = c := by\n  rw [average]\n  rw [integral_const]\n  rw [measureReal_def]\n  rw [measure_univ]\n  rw [ENNReal.toReal_one]\n  rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}", "{\u03bc}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 \u2a0d (_x : \u03b1), c \u2202\u03bc = c"}, {"line": "rw [average]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 \u222b (x : \u03b1), c \u2202(\u03bc univ)\u207b\u00b9 \u2022 \u03bc = c"}, {"line": "rw [integral_const]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc).real univ \u2022 c = c\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 CompleteSpace E"}, {"line": "rw [measureReal_def]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 (((\u03bc univ)\u207b\u00b9 \u2022 \u03bc) univ).toReal \u2022 c = c\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 CompleteSpace E"}, {"line": "rw [measure_univ]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 ENNReal.toReal 1 \u2022 c = c\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 IsProbabilityMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 CompleteSpace E"}, {"line": "rw [ENNReal.toReal_one]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 1 \u2022 c = c\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 IsProbabilityMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 CompleteSpace E"}, {"line": "rw [one_smul]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 IsProbabilityMeasure ((\u03bc univ)\u207b\u00b9 \u2022 \u03bc)\n---\n\u03b1 : Type u_1\nE : Type u_2\nm0 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\nh : NeZero \u03bc\nc : E\n\u22a2 CompleteSpace E"}]}
{"declaration": "theorem ofReal_setAverage {f : \u03b1 \u2192 \u211d} (hf : IntegrableOn f s \u03bc) (hf\u2080 : 0 \u2264\u1d50[\u03bc.restrict s] f) :\n    ENNReal.ofReal (\u2a0d x in s, f x \u2202\u03bc) = (\u222b\u207b x in s, ENNReal.ofReal (f x) \u2202\u03bc) / \u03bc s := by\n  simpa using ofReal_average hf hf\u2080\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}", "{\u03bc}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u211d\nhf : IntegrableOn f s \u03bc\nhf\u2080 : 0 \u2264\u1da0[ae (\u03bc.restrict s)] f\n\u22a2 ENNReal.ofReal (\u2a0d (x : \u03b1) in s, f x \u2202\u03bc) = (\u222b\u207b (x : \u03b1) in s, ENNReal.ofReal (f x) \u2202\u03bc) / \u03bc s"}, {"line": "simpa using ofReal_average hf hf\u2080", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_setAverage_le_pos (h\u03bc : \u03bc s \u2260 0) (h\u03bc\u2081 : \u03bc s \u2260 \u221e) (hf : IntegrableOn f s \u03bc) :\n    0 < \u03bc ({x \u2208 s | \u2a0d a in s, f a \u2202\u03bc \u2264 f x}) := by\n  simpa [integral_neg, neg_div] using measure_le_setAverage_pos h\u03bc h\u03bc\u2081 hf.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Average.lean", "context": {"open": ["ENNReal MeasureTheory MeasureTheory.Measure Metric Set Filter TopologicalSpace Function", "scoped Topology ENNReal Convex"], "variables": ["{\u03b1 E F : Type*} {m0 : MeasurableSpace \u03b1} [NormedAddCommGroup E] [NormedSpace \u211d E]", "(\u03bc) {f g : \u03b1 \u2192 \u211d\u22650\u221e}", "{\u03bc}", "(\u03bc)", "{f g : \u03b1 \u2192 E}", "{\u03bc}", "[CompleteSpace E]", "{N : Set \u03b1} {f : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm0 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh\u03bc : \u03bc s \u2260 0\nh\u03bc\u2081 : \u03bc s \u2260 \u22a4\nhf : IntegrableOn f s \u03bc\n\u22a2 0 < \u03bc {x | x \u2208 s \u2227 \u2a0d (a : \u03b1) in s, f a \u2202\u03bc \u2264 f x}"}, {"line": "simpa [integral_neg, neg_div] using measure_le_setAverage_pos h\u03bc h\u03bc\u2081 hf.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_circleMap_Ioc (c : \u2102) (R : \u211d) : circleMap c R '' Ioc 0 (2 * \u03c0) = sphere c |R| := by\n  rw [\u2190 range_circleMap]\n  rw [\u2190 (periodic_circleMap c R).image_Ioc Real.two_pi_pos 0]\n  rw [zero_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 circleMap c R '' Ioc 0 (2 * Real.pi) = sphere c |R|"}, {"line": "rw [\u2190 range_circleMap]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 circleMap c R '' Ioc 0 (2 * Real.pi) = range (circleMap c R)"}, {"line": "rw [\u2190 (periodic_circleMap c R).image_Ioc Real.two_pi_pos 0]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 circleMap c R '' Ioc 0 (2 * Real.pi) = circleMap c R '' Ioc 0 (0 + 2 * Real.pi)"}, {"line": "rw [zero_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_circleMap (c : \u2102) (R : \u211d) (\u03b8 : \u211d) :\n    HasDerivAt (circleMap c R) (circleMap 0 R \u03b8 * I) \u03b8 := by\n  simpa only [mul_assoc,one_mul,ofRealCLM_apply,circleMap,ofReal_one,zero_add]\n    using (((ofRealCLM.hasDerivAt (x := \u03b8)).mul_const I).cexp.const_mul (R : \u2102)).const_add c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 HasDerivAt (circleMap c R) (circleMap 0 R \u03b8 * I) \u03b8"}, {"line": "simpa only [mul_assoc,one_mul,ofRealCLM_apply,circleMap,ofReal_one,zero_add]\n    using (((ofRealCLM.hasDerivAt (x := \u03b8)).mul_const I).cexp.const_mul (R : \u2102)).const_add c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticOnNhd_circleMap (c : \u2102) (R : \u211d) :\n    AnalyticOnNhd \u211d (circleMap c R) Set.univ := by\n  intro z hz\n  apply analyticAt_const.add\n  apply analyticAt_const.mul\n  rw [\u2190 Function.comp_def]\n  apply analyticAt_cexp.restrictScalars.comp ((ofRealCLM.analyticAt z).mul (by fun_prop))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 AnalyticOnNhd \u211d (circleMap c R) univ"}, {"line": "intro z hz", "tactic_state": "c : \u2102\nR z : \u211d\nhz : z \u2208 univ\n\u22a2 AnalyticAt \u211d (circleMap c R) z"}, {"line": "apply analyticAt_const.add", "tactic_state": "c : \u2102\nR z : \u211d\nhz : z \u2208 univ\n\u22a2 AnalyticAt \u211d (fun \u03b8 => \u2191R * exp (\u2191\u03b8 * I)) z"}, {"line": "apply analyticAt_const.mul", "tactic_state": "c : \u2102\nR z : \u211d\nhz : z \u2208 univ\n\u22a2 AnalyticAt \u211d (fun \u03b8 => exp (\u2191\u03b8 * I)) z"}, {"line": "rw [\u2190 Function.comp_def]", "tactic_state": "c : \u2102\nR z : \u211d\nhz : z \u2208 univ\n\u22a2 AnalyticAt \u211d (exp \u2218 fun \u03b8 => \u2191\u03b8 * I) z"}, {"line": "apply analyticAt_cexp.restrictScalars.comp ((ofRealCLM.analyticAt z).mul (by fun_prop))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_circleMap_eq_zero_iff {c : \u2102} {R : \u211d} {\u03b8 : \u211d} :\n    deriv (circleMap c R) \u03b8 = 0 \u2194 R = 0 := by simp [I_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 deriv (circleMap c R) \u03b8 = 0 \u2194 R = 0"}, {"line": "simp [I_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleIntegrable_zero_radius {f : \u2102 \u2192 E} {c : \u2102} : CircleIntegrable f c 0 := by\n  simp [CircleIntegrable]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nf : \u2102 \u2192 E\nc : \u2102\n\u22a2 CircleIntegrable f c 0"}, {"line": "simp [CircleIntegrable]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem CircleIntegrable.congr_codiscreteWithin {c : \u2102} {R : \u211d} {f\u2081 f\u2082 : \u2102 \u2192 \u2102}\n    (hf : f\u2081 =\u1da0[codiscreteWithin (Metric.sphere c |R|)] f\u2082) (hf\u2081 : CircleIntegrable f\u2081 c R) :\n    CircleIntegrable f\u2082 c R := by\n  by_cases hR : R = 0\n  \u00b7 simp [hR]\n  apply (intervalIntegrable_congr_codiscreteWithin _).1 hf\u2081\n  rw [eventuallyEq_iff_exists_mem]\n  exact \u27e8(circleMap c R)\u207b\u00b9' {z | f\u2081 z = f\u2082 z},\n    codiscreteWithin.mono (by simp only [Set.subset_univ]) (circleMap_preimage_codiscrete hR hf),\n    by tauto\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\n\u22a2 CircleIntegrable f\u2082 c R"}, {"line": "by_cases hR : R = 0", "tactic_state": "case pos\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\nhR : R = 0\n\u22a2 CircleIntegrable f\u2082 c R\n---\ncase neg\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\nhR : \u00acR = 0\n\u22a2 CircleIntegrable f\u2082 c R"}, {"line": "\u00b7 simp [hR]", "tactic_state": "case neg\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\nhR : \u00acR = 0\n\u22a2 CircleIntegrable f\u2082 c R"}, {"line": "apply (intervalIntegrable_congr_codiscreteWithin _).1 hf\u2081", "tactic_state": "c : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\nhR : \u00acR = 0\n\u22a2 (fun \u03b8 => f\u2081 (circleMap c R \u03b8)) =\u1da0[codiscreteWithin (uIoc 0 (2 * Real.pi))] fun \u03b8 => f\u2082 (circleMap c R \u03b8)"}, {"line": "rw [eventuallyEq_iff_exists_mem]", "tactic_state": "c : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhf\u2081 : CircleIntegrable f\u2081 c R\nhR : \u00acR = 0\n\u22a2 \u2203 s \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi)), EqOn (fun \u03b8 => f\u2081 (circleMap c R \u03b8)) (fun \u03b8 => f\u2082 (circleMap c R \u03b8)) s"}, {"line": "exact \u27e8(circleMap c R)\u207b\u00b9' {z | f\u2081 z = f\u2082 z},\n    codiscreteWithin.mono (by simp only [Set.subset_univ]) (circleMap_preimage_codiscrete hR hf),\n    by tauto\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleIntegral_def_Icc (f : \u2102 \u2192 E) (c : \u2102) (R : \u211d) :\n    (\u222e z in C(c, R), f z) = \u222b \u03b8 in Icc 0 (2 * \u03c0),\n    deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8) := by\n  rw [circleIntegral]\n  rw [intervalIntegral.integral_of_le Real.two_pi_pos.le]\n  rw [Measure.restrict_congr_set Ioc_ae_eq_Icc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\n\u22a2 (\u222e (z : \u2102) in C(c, R), f z) = \u222b (\u03b8 : \u211d) in Icc 0 (2 * Real.pi), deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8)"}, {"line": "rw [circleIntegral]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\n\u22a2 \u222b (\u03b8 : \u211d) in 0 ..2 * Real.pi, deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8) =\n    \u222b (\u03b8 : \u211d) in Icc 0 (2 * Real.pi), deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8)"}, {"line": "rw [intervalIntegral.integral_of_le Real.two_pi_pos.le]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\n\u22a2 \u222b (x : \u211d) in Ioc 0 (2 * Real.pi), deriv (circleMap c R) x \u2022 f (circleMap c R x) \u2202volume =\n    \u222b (\u03b8 : \u211d) in Icc 0 (2 * Real.pi), deriv (circleMap c R) \u03b8 \u2022 f (circleMap c R \u03b8)"}, {"line": "rw [Measure.restrict_congr_set Ioc_ae_eq_Icc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_radius_zero (f : \u2102 \u2192 E) (c : \u2102) : (\u222e z in C(c, 0), f z) = 0 := by\n  simp +unfoldPartialApp [circleIntegral, const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\n\u22a2 (\u222e (z : \u2102) in C(c, 0), f z) = 0"}, {"line": "simp +unfoldPartialApp [circleIntegral, const]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\n\u22a2 0 \u2022 \u222b (x : \u211d) in 0 ..2 * Real.pi, f c = 0"}]}
{"declaration": "theorem circleIntegral_congr_codiscreteWithin {c : \u2102} {R : \u211d} {f\u2081 f\u2082 : \u2102 \u2192 \u2102}\n    (hf : f\u2081 =\u1da0[codiscreteWithin (Metric.sphere c |R|)] f\u2082) (hR : R \u2260 0) :\n    (\u222e z in C(c, R), f\u2081 z) = (\u222e z in C(c, R), f\u2082 z) := by\n  apply intervalIntegral.integral_congr_ae_restrict\n  apply ae_restrict_le_codiscreteWithin measurableSet_uIoc\n  simp only [deriv_circleMap]\n  simp only [smul_eq_mul]\n  simp only [mul_eq_mul_left_iff]\n  simp only [mul_eq_zero]\n  simp only [circleMap_eq_center_iff]\n  simp only [hR]\n  simp only [Complex.I_ne_zero]\n  simp only [or_self]\n  simp only [or_false]\n  exact codiscreteWithin.mono (by tauto) (circleMap_preimage_codiscrete hR hf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 (\u222e (z : \u2102) in C(c, R), f\u2081 z) = \u222e (z : \u2102) in C(c, R), f\u2082 z"}, {"line": "apply intervalIntegral.integral_congr_ae_restrict", "tactic_state": "case h\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 (fun x => deriv (circleMap c R) x \u2022 (fun z => f\u2081 z) (circleMap c R x)) =\u1da0[ae (volume.restrict (uIoc 0 (2 * Real.pi)))]\n    fun x => deriv (circleMap c R) x \u2022 (fun z => f\u2082 z) (circleMap c R x)"}, {"line": "apply ae_restrict_le_codiscreteWithin measurableSet_uIoc", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x |\n      (fun x =>\n          (fun x => deriv (circleMap c R) x \u2022 (fun z => f\u2081 z) (circleMap c R x)) x =\n            (fun x => deriv (circleMap c R) x \u2022 (fun z => f\u2082 z) (circleMap c R x)) x)\n        x} \u2208\n    codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [deriv_circleMap]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | (circleMap 0 R x * I) \u2022 f\u2081 (circleMap c R x) = (circleMap 0 R x * I) \u2022 f\u2082 (circleMap c R x)} \u2208\n    codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [smul_eq_mul]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | circleMap 0 R x * I * f\u2081 (circleMap c R x) = circleMap 0 R x * I * f\u2082 (circleMap c R x)} \u2208\n    codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [mul_eq_mul_left_iff]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 circleMap 0 R x * I = 0} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [mul_eq_zero]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 circleMap 0 R x = 0 \u2228 I = 0} \u2208\n    codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [circleMap_eq_center_iff]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 R = 0 \u2228 I = 0} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [hR]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 False \u2228 I = 0} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [Complex.I_ne_zero]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 False \u2228 False} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [or_self]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x) \u2228 False} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "simp only [or_false]", "tactic_state": "case h.a\nc : \u2102\nR : \u211d\nf\u2081 f\u2082 : \u2102 \u2192 \u2102\nhf : f\u2081 =\u1da0[codiscreteWithin (sphere c |R|)] f\u2082\nhR : R \u2260 0\n\u22a2 {x | f\u2081 (circleMap c R x) = f\u2082 (circleMap c R x)} \u2208 codiscreteWithin (uIoc 0 (2 * Real.pi))"}, {"line": "exact codiscreteWithin.mono (by tauto) (circleMap_preimage_codiscrete hR hf)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_integral_le_of_norm_le_const {f : \u2102 \u2192 E} {c : \u2102} {R C : \u211d} (hR : 0 \u2264 R)\n    (hf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C) : \u2016\u222e z in C(c, R), f z\u2016 \u2264 2 * \u03c0 * R * C :=\n  have : |R| = R := abs_of_nonneg hR\n  calc\n    \u2016\u222e z in C(c, R), f z\u2016 \u2264 2 * \u03c0 * |R| * C := norm_integral_le_of_norm_le_const' <| by rwa [this]\n    _ = 2 * \u03c0 * R * C := by rw [this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR C : \u211d\nhR : 0 \u2264 R\nhf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C\nthis : |R| = R\n\u22a2 2 * Real.pi * |R| * C = 2 * Real.pi * R * C"}, {"line": "rw [this]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sub_center_inv (c : \u2102) {R : \u211d} (hR : R \u2260 0) :\n    (\u222e z in C(c, R), (z - c)\u207b\u00b9) = 2 * \u03c0 * I := by\n  simp [circleIntegral, \u2190 div_eq_mul_inv, mul_div_cancel_left\u2080 _ (circleMap_ne_center hR)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\nhR : R \u2260 0\n\u22a2 (\u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9) = 2 * \u2191Real.pi * I"}, {"line": "simp [circleIntegral, \u2190 div_eq_mul_inv, mul_div_cancel_left\u2080 _ (circleMap_ne_center hR)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cauchyPowerSeries_apply (f : \u2102 \u2192 E) (c : \u2102) (R : \u211d) (n : \u2115) (w : \u2102) :\n    (cauchyPowerSeries f c R n fun _ => w) =\n      (2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z := by\n  simp only [cauchyPowerSeries]\n  simp only [ContinuousMultilinearMap.mkPiRing_apply]\n  simp only [Fin.prod_const]\n  simp only [div_eq_mul_inv]\n  simp only [mul_pow]\n  simp only [mul_smul]\n  simp only [circleIntegral.integral_smul]\n  rw [\u2190 smul_comm (w ^ n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 ((cauchyPowerSeries f c R n) fun x => w) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [cauchyPowerSeries]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 ((ContinuousMultilinearMap.mkPiRing \u2102 (Fin n)\n        ((2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z))\n      fun x => w) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [ContinuousMultilinearMap.mkPiRing_apply]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 ((\u220f x, w) \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [Fin.prod_const]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 (w ^ n \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 (w ^ n \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w * (z - c)\u207b\u00b9) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [mul_pow]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 (w ^ n \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w ^ n * (z - c)\u207b\u00b9 ^ n) \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [mul_smul]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 (w ^ n \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), w ^ n \u2022 (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "simp only [circleIntegral.integral_smul]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nn : \u2115\nw : \u2102\n\u22a2 (w ^ n \u2022 (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z) =\n    (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 w ^ n \u2022 \u222e (z : \u2102) in C(c, R), (z - c)\u207b\u00b9 ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z"}, {"line": "rw [\u2190 smul_comm (w ^ n)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_cauchyPowerSeries_integral {f : \u2102 \u2192 E} {c : \u2102} {R : \u211d} {w : \u2102}\n    (hf : CircleIntegrable f c R) (hw : \u2016w\u2016 < R) :\n    HasSum (fun n => cauchyPowerSeries f c R n fun _ => w)\n      ((2 * \u03c0 * I : \u2102)\u207b\u00b9 \u2022 \u222e z in C(c, R), (z - (c + w))\u207b\u00b9 \u2022 f z) := by\n  simp only [cauchyPowerSeries_apply]\n  exact (hasSum_two_pi_I_cauchyPowerSeries_integral hf hw).const_smul _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/CircleIntegral.lean", "context": {"open": ["scoped Real NNReal Interval Pointwise Topology", "Complex MeasureTheory TopologicalSpace Metric Function Set Filter Asymptotics"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "{f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d}", "[NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nw : \u2102\nhf : CircleIntegrable f c R\nhw : \u2016w\u2016 < R\n\u22a2 HasSum (fun n => (cauchyPowerSeries f c R n) fun x => w)\n    ((2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - (c + w))\u207b\u00b9 \u2022 f z)"}, {"line": "simp only [cauchyPowerSeries_apply]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf : \u2102 \u2192 E\nc : \u2102\nR : \u211d\nw : \u2102\nhf : CircleIntegrable f c R\nhw : \u2016w\u2016 < R\n\u22a2 HasSum (fun n => (2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (w / (z - c)) ^ n \u2022 (z - c)\u207b\u00b9 \u2022 f z)\n    ((2 * \u2191Real.pi * I)\u207b\u00b9 \u2022 \u222e (z : \u2102) in C(c, R), (z - (c + w))\u207b\u00b9 \u2022 f z)"}, {"line": "exact (hasSum_two_pi_I_cauchyPowerSeries_integral hf hw).const_smul _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setToSimpleFunc_zero {m : MeasurableSpace \u03b1} (f : \u03b1 \u2192\u209b F) :\n    setToSimpleFunc (0 : Set \u03b1 \u2192 F \u2192L[\u211d] F') f = 0 := by simp [setToSimpleFunc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/FinMeasAdditive.lean", "context": {"open": ["Set Filter ENNReal Finset"], "variables": ["{\u03b1 E F F' G \ud835\udd5c : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{\u03b2 : Type*} [AddCommMonoid \u03b2] {T T' : Set \u03b1 \u2192 \u03b2}", "{\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {T T' : Set \u03b1 \u2192 \u03b2} {C C' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_9\nsetToSimpleFunc : x\u271d\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 sorry\n\u22a2 sorry = 0"}, {"line": "simp [setToSimpleFunc]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_9\nsetToSimpleFunc : x\u271d\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 sorry\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem setToSimpleFunc_zero_apply {m : MeasurableSpace \u03b1} (T : Set \u03b1 \u2192 F \u2192L[\u211d] F') :\n    setToSimpleFunc T (0 : \u03b1 \u2192\u209b F) = 0 := by\n  cases isEmpty_or_nonempty \u03b1 <;> simp [setToSimpleFunc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/FinMeasAdditive.lean", "context": {"open": ["Set Filter ENNReal Finset"], "variables": ["{\u03b1 E F F' G \ud835\udd5c : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{\u03b2 : Type*} [AddCommMonoid \u03b2] {T T' : Set \u03b1 \u2192 \u03b2}", "{\u03b2 : Type*} [SeminormedAddCommGroup \u03b2] {T T' : Set \u03b1 \u2192 \u03b2} {C C' : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_9\nsetToSimpleFunc : x\u271d\nm : MeasurableSpace \u03b1\nT : Set \u03b1 \u2192 sorry\n\u22a2 sorry = 0"}, {"line": "cases isEmpty_or_nonempty \u03b1 <;> simp [setToSimpleFunc]", "tactic_state": "case inl\n\u03b1 : Type u_1\nx\u271d : Sort u_9\nsetToSimpleFunc : x\u271d\nm : MeasurableSpace \u03b1\nT : Set \u03b1 \u2192 sorry\nh\u271d : IsEmpty \u03b1\n\u22a2 sorry () = 0\n---\ncase inr\n\u03b1 : Type u_1\nx\u271d : Sort u_9\nsetToSimpleFunc : x\u271d\nm : MeasurableSpace \u03b1\nT : Set \u03b1 \u2192 sorry\nh\u271d : Nonempty \u03b1\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem integrableOn_empty : IntegrableOn f \u2205 \u03bc := by simp [IntegrableOn, integrable_zero_measure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\n\u22a2 IntegrableOn f \u2205 \u03bc"}, {"line": "simp [IntegrableOn, integrable_zero_measure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_univ : IntegrableOn f univ \u03bc \u2194 Integrable f \u03bc := by\n  rw [IntegrableOn]\n  rw [Measure.restrict_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\n\u22a2 IntegrableOn f univ \u03bc \u2194 Integrable f \u03bc"}, {"line": "rw [IntegrableOn]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\n\u22a2 Integrable f (\u03bc.restrict univ) \u2194 Integrable f \u03bc"}, {"line": "rw [Measure.restrict_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.restrict (h : IntegrableOn f s \u03bc) : IntegrableOn f s (\u03bc.restrict t) := by\n  dsimp only [IntegrableOn] at h \u22a2\n  exact h.mono_measure <| Measure.restrict_mono_measure Measure.restrict_le_self _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\n\u03bc : Measure \u03b1\nh : IntegrableOn f s \u03bc\n\u22a2 IntegrableOn f s (\u03bc.restrict t)"}, {"line": "dsimp only [IntegrableOn] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\n\u03bc : Measure \u03b1\nh : Integrable f (\u03bc.restrict s)\n\u22a2 Integrable f ((\u03bc.restrict t).restrict s)"}, {"line": "exact h.mono_measure <| Measure.restrict_mono_measure Measure.restrict_le_self _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableOn.inter_of_restrict (h : IntegrableOn f s (\u03bc.restrict t)) :\n    IntegrableOn f (s \u2229 t) \u03bc := by\n  have := h.mono_set (inter_subset_left (t := t))\n  rwa [IntegrableOn, \u03bc.restrict_restrict_of_subset inter_subset_right] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\n\u03bc : Measure \u03b1\nh : IntegrableOn f s (\u03bc.restrict t)\n\u22a2 IntegrableOn f (s \u2229 t) \u03bc"}, {"line": "have := h.mono_set (inter_subset_left (t := t))", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\n\u03bc : Measure \u03b1\nh : IntegrableOn f s (\u03bc.restrict t)\nthis : IntegrableOn f (s \u2229 t) (\u03bc.restrict t)\n\u22a2 IntegrableOn f (s \u2229 t) \u03bc"}, {"line": "rwa [IntegrableOn, \u03bc.restrict_restrict_of_subset inter_subset_right] at this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Integrable.piecewise [DecidablePred (\u00b7 \u2208 s)]\n    (hs : MeasurableSet s) (hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s\u1d9c \u03bc) :\n    Integrable (s.piecewise f g) \u03bc := by\n  rw [IntegrableOn] at hf hg\n  rw [\u2190 memLp_one_iff_integrable] at hf hg \u22a2\n  exact MemLp.piecewise hs hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\nf g : \u03b1 \u2192 E\ns : Set \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : IntegrableOn f s \u03bc\nhg : IntegrableOn g s\u1d9c \u03bc\n\u22a2 Integrable (s.piecewise f g) \u03bc"}, {"line": "rw [IntegrableOn] at hf hg", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\nf g : \u03b1 \u2192 E\ns : Set \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : Integrable f (\u03bc.restrict s)\nhg : Integrable g (\u03bc.restrict s\u1d9c)\n\u22a2 Integrable (s.piecewise f g) \u03bc"}, {"line": "rw [\u2190 memLp_one_iff_integrable] at hf hg \u22a2", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b2 : MeasurableSpace \u03b1\ninst\u271d\u00b9 : NormedAddCommGroup E\nf g : \u03b1 \u2192 E\ns : Set \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\nhs : MeasurableSet s\nhf : MemLp f 1 (\u03bc.restrict s)\nhg : MemLp g 1 (\u03bc.restrict s\u1d9c)\n\u22a2 MemLp (s.piecewise f g) 1 \u03bc"}, {"line": "exact MemLp.piecewise hs hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IntegrableOn.finset [MeasurableSingletonClass \u03b1] {\u03bc : Measure \u03b1} [IsFiniteMeasure \u03bc]\n    {s : Finset \u03b1} {f : \u03b1 \u2192 E} : IntegrableOn f s \u03bc := by\n  rw [\u2190 s.toSet.biUnion_of_singleton]\n  simp [integrableOn_finset_iUnion, measure_lt_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\ns : Finset \u03b1\nf : \u03b1 \u2192 E\n\u22a2 IntegrableOn f (\u2191s) \u03bc"}, {"line": "rw [\u2190 s.toSet.biUnion_of_singleton]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\ns : Finset \u03b1\nf : \u03b1 \u2192 E\n\u22a2 IntegrableOn f (\u22c3 x \u2208 \u2191s, {x}) \u03bc"}, {"line": "simp [integrableOn_finset_iUnion, measure_lt_top]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\ns : Finset \u03b1\nf : \u03b1 \u2192 E\n\u22a2 \u2200 i \u2208 s, IntegrableOn f {i} \u03bc"}]}
{"declaration": "lemma IntegrableOn.of_finite [MeasurableSingletonClass \u03b1] {\u03bc : Measure \u03b1} [IsFiniteMeasure \u03bc]\n    {s : Set \u03b1} (hs : s.Finite) {f : \u03b1 \u2192 E} : IntegrableOn f s \u03bc := by\n  simpa using IntegrableOn.finset (s := hs.toFinset)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b3 : MeasurableSpace \u03b1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsFiniteMeasure \u03bc\ns : Set \u03b1\nhs : s.Finite\nf : \u03b1 \u2192 E\n\u22a2 IntegrableOn f s \u03bc"}, {"line": "simpa using IntegrableOn.finset (s := hs.toFinset)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableAtFilter_atBot_iff [Preorder \u03b1] [IsDirected \u03b1 fun (x1 x2 : \u03b1) => x1 \u2265 x2]\n    [Nonempty \u03b1] :\n    IntegrableAtFilter f atBot \u03bc \u2194 \u2203 a, IntegrableOn f (Iic a) \u03bc := by\n  refine \u27e8fun \u27e8s, hs, hi\u27e9 \u21a6 ?_, fun \u27e8a, ha\u27e9 \u21a6 \u27e8Iic a, Iic_mem_atBot a, ha\u27e9\u27e9\n  obtain \u27e8t, ht\u27e9 := mem_atBot_sets.mp hs\n  exact \u27e8t, hi.mono_set fun _ hx \u21a6 ht _ hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d : Nonempty \u03b1\n\u22a2 IntegrableAtFilter f atBot \u03bc \u2194 \u2203 a, IntegrableOn f (Iic a) \u03bc"}, {"line": "refine \u27e8fun \u27e8s, hs, hi\u27e9 \u21a6 ?_, fun \u27e8a, ha\u27e9 \u21a6 \u27e8Iic a, Iic_mem_atBot a, ha\u27e9\u27e9", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d : Nonempty \u03b1\nx\u271d : IntegrableAtFilter f atBot \u03bc\ns : Set \u03b1\nhs : s \u2208 atBot\nhi : IntegrableOn f s \u03bc\n\u22a2 \u2203 a, IntegrableOn f (Iic a) \u03bc"}, {"line": "obtain \u27e8t, ht\u27e9 := mem_atBot_sets.mp hs", "tactic_state": "case intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d : Nonempty \u03b1\nx\u271d : IntegrableAtFilter f atBot \u03bc\ns : Set \u03b1\nhs : s \u2208 atBot\nhi : IntegrableOn f s \u03bc\nt : \u03b1\nht : \u2200 b \u2264 t, b \u2208 s\n\u22a2 \u2203 a, IntegrableOn f (Iic a) \u03bc"}, {"line": "exact \u27e8t, hi.mono_set fun _ hx \u21a6 ht _ hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IntegrableAtFilter.add {f g : \u03b1 \u2192 E}\n    (hf : IntegrableAtFilter f l \u03bc) (hg : IntegrableAtFilter g l \u03bc) :\n    IntegrableAtFilter (f + g) l \u03bc := by\n  rcases hf with \u27e8s, sl, hs\u27e9\n  rcases hg with \u27e8t, tl, ht\u27e9\n  refine \u27e8s \u2229 t, inter_mem sl tl, ?_\u27e9\n  exact (hs.mono_set inter_subset_left).add (ht.mono_set inter_subset_right)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf g : \u03b1 \u2192 E\nhf : IntegrableAtFilter f l \u03bc\nhg : IntegrableAtFilter g l \u03bc\n\u22a2 IntegrableAtFilter (f + g) l \u03bc"}, {"line": "rcases hf with \u27e8s, sl, hs\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf g : \u03b1 \u2192 E\nhg : IntegrableAtFilter g l \u03bc\ns : Set \u03b1\nsl : s \u2208 l\nhs : IntegrableOn f s \u03bc\n\u22a2 IntegrableAtFilter (f + g) l \u03bc"}, {"line": "rcases hg with \u27e8t, tl, ht\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf g : \u03b1 \u2192 E\ns : Set \u03b1\nsl : s \u2208 l\nhs : IntegrableOn f s \u03bc\nt : Set \u03b1\ntl : t \u2208 l\nht : IntegrableOn g t \u03bc\n\u22a2 IntegrableAtFilter (f + g) l \u03bc"}, {"line": "refine \u27e8s \u2229 t, inter_mem sl tl, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf g : \u03b1 \u2192 E\ns : Set \u03b1\nsl : s \u2208 l\nhs : IntegrableOn f s \u03bc\nt : Set \u03b1\ntl : t \u2208 l\nht : IntegrableOn g t \u03bc\n\u22a2 IntegrableOn (f + g) (s \u2229 t) \u03bc"}, {"line": "exact (hs.mono_set inter_subset_left).add (ht.mono_set inter_subset_right)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IntegrableAtFilter.neg {f : \u03b1 \u2192 E} (hf : IntegrableAtFilter f l \u03bc) :\n    IntegrableAtFilter (-f) l \u03bc := by\n  rcases hf with \u27e8s, sl, hs\u27e9\n  exact \u27e8s, sl, hs.neg\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf : \u03b1 \u2192 E\nhf : IntegrableAtFilter f l \u03bc\n\u22a2 IntegrableAtFilter (-f) l \u03bc"}, {"line": "rcases hf with \u27e8s, sl, hs\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\nf : \u03b1 \u2192 E\ns : Set \u03b1\nsl : s \u2208 l\nhs : IntegrableOn f s \u03bc\n\u22a2 IntegrableAtFilter (-f) l \u03bc"}, {"line": "exact \u27e8s, sl, hs.neg\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IntegrableAtFilter.smul {\ud835\udd5c : Type*} [NormedAddCommGroup \ud835\udd5c] [SMulZeroClass \ud835\udd5c E]\n    [IsBoundedSMul \ud835\udd5c E] {f : \u03b1 \u2192 E} (hf : IntegrableAtFilter f l \u03bc) (c : \ud835\udd5c) :\n    IntegrableAtFilter (c \u2022 f) l \u03bc := by\n  rcases hf with \u27e8s, sl, hs\u27e9\n  exact \u27e8s, sl, hs.smul c\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d : IsBoundedSMul \ud835\udd5c E\nf : \u03b1 \u2192 E\nhf : IntegrableAtFilter f l \u03bc\nc : \ud835\udd5c\n\u22a2 IntegrableAtFilter (c \u2022 f) l \u03bc"}, {"line": "rcases hf with \u27e8s, sl, hs\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : NormedAddCommGroup E\n\u03bc : Measure \u03b1\nl : Filter \u03b1\n\ud835\udd5c : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d : IsBoundedSMul \ud835\udd5c E\nf : \u03b1 \u2192 E\nc : \ud835\udd5c\ns : Set \u03b1\nsl : s \u2208 l\nhs : IntegrableOn f s \u03bc\n\u22a2 IntegrableAtFilter (c \u2022 f) l \u03bc"}, {"line": "exact \u27e8s, sl, hs.smul c\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableAtFilter_top : IntegrableAtFilter f \u22a4 \u03bc \u2194 Integrable f \u03bc := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.integrableAtFilter \u22a4\u27e9\n  obtain \u27e8s, hsf, hs\u27e9 := h\n  exact (integrableOn_iff_integrable_of_support_subset fun _ _ \u21a6 hsf _).mp hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\n\u22a2 IntegrableAtFilter f \u22a4 \u03bc \u2194 Integrable f \u03bc"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.integrableAtFilter \u22a4\u27e9", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nh : IntegrableAtFilter f \u22a4 \u03bc\n\u22a2 Integrable f \u03bc"}, {"line": "obtain \u27e8s, hsf, hs\u27e9 := h", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\ns : Set \u03b1\nhsf : s \u2208 \u22a4\nhs : IntegrableOn f s \u03bc\n\u22a2 Integrable f \u03bc"}, {"line": "exact (integrableOn_iff_integrable_of_support_subset fun _ _ \u21a6 hsf _).mp hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntegrableAtFilter.sup_iff {l l' : Filter \u03b1} :\n    IntegrableAtFilter f (l \u2294 l') \u03bc \u2194 IntegrableAtFilter f l \u03bc \u2227 IntegrableAtFilter f l' \u03bc := by\n  constructor\n  \u00b7 exact fun h => \u27e8h.filter_mono le_sup_left, h.filter_mono le_sup_right\u27e9\n  \u00b7 exact fun \u27e8\u27e8s, hsl, hs\u27e9, \u27e8t, htl, ht\u27e9\u27e9 \u21a6 \u27e8s \u222a t, union_mem_sup hsl htl, hs.union ht\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nl l' : Filter \u03b1\n\u22a2 IntegrableAtFilter f (l \u2294 l') \u03bc \u2194 IntegrableAtFilter f l \u03bc \u2227 IntegrableAtFilter f l' \u03bc"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nl l' : Filter \u03b1\n\u22a2 IntegrableAtFilter f (l \u2294 l') \u03bc \u2192 IntegrableAtFilter f l \u03bc \u2227 IntegrableAtFilter f l' \u03bc\n---\ncase mpr\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nl l' : Filter \u03b1\n\u22a2 IntegrableAtFilter f l \u03bc \u2227 IntegrableAtFilter f l' \u03bc \u2192 IntegrableAtFilter f (l \u2294 l') \u03bc"}, {"line": "\u00b7 exact fun h => \u27e8h.filter_mono le_sup_left, h.filter_mono le_sup_right\u27e9", "tactic_state": "case mpr\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : NormedAddCommGroup E\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nl l' : Filter \u03b1\n\u22a2 IntegrableAtFilter f l \u03bc \u2227 IntegrableAtFilter f l' \u03bc \u2192 IntegrableAtFilter f (l \u2294 l') \u03bc"}, {"line": "\u00b7 exact fun \u27e8\u27e8s, hsl, hs\u27e9, \u27e8t, htl, ht\u27e9\u27e9 \u21a6 \u27e8s \u222a t, union_mem_sup hsl htl, hs.union ht\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousOn.aestronglyMeasurable_of_isCompact [TopologicalSpace \u03b1] [OpensMeasurableSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoMetrizableSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {\u03bc : Measure \u03b1}\n    (hf : ContinuousOn f s) (hs : IsCompact s) (h's : MeasurableSet s) :\n    AEStronglyMeasurable f (\u03bc.restrict s) := by\n  letI := pseudoMetrizableSpacePseudoMetric \u03b2\n  borelize \u03b2\n  rw [aestronglyMeasurable_iff_aemeasurable_separable]\n  refine \u27e8hf.aemeasurable h's, f '' s, ?_, ?_\u27e9\n  \u00b7 exact (hs.image_of_continuousOn hf).isSeparable\n  \u00b7 exact mem_of_superset (self_mem_ae_restrict h's) (subset_preimage_image _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\n\u22a2 AEStronglyMeasurable f (\u03bc.restrict s)"}, {"line": "letI := pseudoMetrizableSpacePseudoMetric \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\n\u22a2 AEStronglyMeasurable f (\u03bc.restrict s)"}, {"line": "borelize \u03b2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 AEStronglyMeasurable f (\u03bc.restrict s)"}, {"line": "rw [aestronglyMeasurable_iff_aemeasurable_separable]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 AEMeasurable f (\u03bc.restrict s) \u2227 \u2203 t, TopologicalSpace.IsSeparable t \u2227 \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict s, f x \u2208 t\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 PseudoMetrizableSpace \u03b2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 BorelSpace \u03b2"}, {"line": "refine \u27e8hf.aemeasurable h's, f '' s, ?_, ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 TopologicalSpace.IsSeparable (f '' s)\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict s, f x \u2208 f '' s\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 PseudoMetrizableSpace \u03b2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 BorelSpace \u03b2"}, {"line": "\u00b7 exact (hs.image_of_continuousOn hf).isSeparable", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc.restrict s, f x \u2208 f '' s\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 PseudoMetrizableSpace \u03b2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 BorelSpace \u03b2"}, {"line": "\u00b7 exact mem_of_superset (self_mem_ae_restrict h's) (subset_preimage_image _ _)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 PseudoMetrizableSpace \u03b2\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OpensMeasurableSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoMetrizableSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : ContinuousOn f s\nhs : IsCompact s\nh's : MeasurableSet s\nthis : PseudoMetricSpace \u03b2 := sorry\nthis\u271d\u00b9 : MeasurableSpace \u03b2 := borel \u03b2\nthis\u271d : BorelSpace \u03b2\n\u22a2 BorelSpace \u03b2"}]}
{"declaration": "theorem Continuous.integrableAt_nhds [TopologicalSpace \u03b1] [SecondCountableTopologyEither \u03b1 E]\n    [OpensMeasurableSpace \u03b1] {\u03bc : Measure \u03b1} [IsLocallyFiniteMeasure \u03bc] {f : \u03b1 \u2192 E}\n    (hf : Continuous f) (a : \u03b1) : IntegrableAtFilter f (\ud835\udcdd a) \u03bc := by\n  rw [\u2190 nhdsWithin_univ]\n  exact hf.continuousOn.integrableAt_nhdsWithin MeasurableSet.univ (mem_univ a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : SecondCountableTopologyEither \u03b1 E\ninst\u271d\u00b9 : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : \u03b1 \u2192 E\nhf : Continuous f\na : \u03b1\n\u22a2 IntegrableAtFilter f (nhds a) \u03bc"}, {"line": "rw [\u2190 nhdsWithin_univ]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : SecondCountableTopologyEither \u03b1 E\ninst\u271d\u00b9 : OpensMeasurableSpace \u03b1\n\u03bc : Measure \u03b1\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : \u03b1 \u2192 E\nhf : Continuous f\na : \u03b1\n\u22a2 IntegrableAtFilter f (nhdsWithin a univ) \u03bc"}, {"line": "exact hf.continuousOn.integrableAt_nhdsWithin MeasurableSet.univ (mem_univ a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ico_iff_integrableOn_Ioo' (ha : \u03bc {a} \u2260 \u221e) :\n    IntegrableOn f (Ico a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc := by\n  by_cases hab : a < b\n  \u00b7 rw [\u2190 Ioo_union_left hab, integrableOn_union,\n      eq_true (integrableOn_singleton_iff.mpr <| Or.inr ha.lt_top), and_true]\n  \u00b7 rw [Ioo_eq_empty hab, Ico_eq_empty hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]", "[PartialOrder \u03b1] [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 E} {\u03bc : Measure \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nha : \u03bc {a} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ico a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "by_cases hab : a < b", "tactic_state": "case pos\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nha : \u03bc {a} \u2260 \u22a4\nhab : sorry\n\u22a2 IntegrableOn f (Ico a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc\n---\ncase neg\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nha : \u03bc {a} \u2260 \u22a4\nhab : \u00acsorry\n\u22a2 IntegrableOn f (Ico a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "\u00b7 rw [\u2190 Ioo_union_left hab, integrableOn_union,\n      eq_true (integrableOn_singleton_iff.mpr <| Or.inr ha.lt_top), and_true]", "tactic_state": "case neg\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nha : \u03bc {a} \u2260 \u22a4\nhab : \u00acsorry\n\u22a2 IntegrableOn f (Ico a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "\u00b7 rw [Ioo_eq_empty hab, Ico_eq_empty hab]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioc_iff_integrableOn_Ioo' (hb : \u03bc {b} \u2260 \u221e) :\n    IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc := by\n  by_cases hab : a < b\n  \u00b7 rw [\u2190 Ioo_union_right hab, integrableOn_union,\n      eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top), and_true]\n  \u00b7 rw [Ioo_eq_empty hab, Ioc_eq_empty hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]", "[PartialOrder \u03b1] [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 E} {\u03bc : Measure \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "by_cases hab : a < b", "tactic_state": "case pos\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\nhab : sorry\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc\n---\ncase neg\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\nhab : \u00acsorry\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "\u00b7 rw [\u2190 Ioo_union_right hab, integrableOn_union,\n      eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top), and_true]", "tactic_state": "case neg\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\nhab : \u00acsorry\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "\u00b7 rw [Ioo_eq_empty hab, Ioc_eq_empty hab]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ici_iff_integrableOn_Ioi' (hb : \u03bc {b} \u2260 \u221e) :\n    IntegrableOn f (Ici b) \u03bc \u2194 IntegrableOn f (Ioi b) \u03bc := by\n  rw [\u2190 Ioi_union_left]\n  rw [integrableOn_union]\n  rw [eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top)]\n  rw [and_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]", "[PartialOrder \u03b1] [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 E} {\u03bc : Measure \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ici b) \u03bc \u2194 IntegrableOn f (Ioi b) \u03bc"}, {"line": "rw [\u2190 Ioi_union_left]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ioi b \u222a {b}) \u03bc \u2194 IntegrableOn f (Ioi b) \u03bc"}, {"line": "rw [integrableOn_union]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ioi b) \u03bc \u2227 IntegrableOn f {b} \u03bc \u2194 IntegrableOn f (Ioi b) \u03bc"}, {"line": "rw [eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top)]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Ioi b) \u03bc \u2227 True \u2194 IntegrableOn f (Ioi b) \u03bc\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "rw [and_true]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 MeasurableSingletonClass \u03b1"}]}
{"declaration": "theorem integrableOn_Iic_iff_integrableOn_Iio' (hb : \u03bc {b} \u2260 \u221e) :\n    IntegrableOn f (Iic b) \u03bc \u2194 IntegrableOn f (Iio b) \u03bc := by\n  rw [\u2190 Iio_union_right]\n  rw [integrableOn_union]\n  rw [eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top)]\n  rw [and_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]", "[PartialOrder \u03b1] [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 E} {\u03bc : Measure \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Iic b) \u03bc \u2194 IntegrableOn f (Iio b) \u03bc"}, {"line": "rw [\u2190 Iio_union_right]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Iio b \u222a {b}) \u03bc \u2194 IntegrableOn f (Iio b) \u03bc"}, {"line": "rw [integrableOn_union]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Iio b) \u03bc \u2227 IntegrableOn f {b} \u03bc \u2194 IntegrableOn f (Iio b) \u03bc"}, {"line": "rw [eq_true (integrableOn_singleton_iff.mpr <| Or.inr hb.lt_top)]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 IntegrableOn f (Iio b) \u03bc \u2227 True \u2194 IntegrableOn f (Iio b) \u03bc\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 MeasurableSingletonClass \u03b1"}, {"line": "rw [and_true]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\nb : \u03b1\nhb : \u03bc {b} \u2260 \u22a4\n\u22a2 MeasurableSingletonClass \u03b1"}]}
{"declaration": "theorem integrableOn_Icc_iff_integrableOn_Ioo :\n    IntegrableOn f (Icc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc := by\n  rw [integrableOn_Icc_iff_integrableOn_Ioc]\n  rw [integrableOn_Ioc_iff_integrableOn_Ioo]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegrableOn.lean", "context": {"open": ["Set Filter TopologicalSpace MeasureTheory Function", "scoped Topology Interval Filter ENNReal MeasureTheory", "MeasureTheory"], "variables": ["{\u03b1 \u03b2 \u03b5 E F : Type*} [MeasurableSpace \u03b1] [ENorm \u03b5] [TopologicalSpace \u03b5]", "[TopologicalSpace \u03b2] {l l' : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} {\u03bc \u03bd : Measure \u03b1}", "[NormedAddCommGroup E] {f g : \u03b1 \u2192 E} {s t : Set \u03b1} {\u03bc \u03bd : Measure \u03b1}", "{l l' : Filter \u03b1}", "[NormedAddCommGroup E]", "[PartialOrder \u03b1] [MeasurableSingletonClass \u03b1] {f : \u03b1 \u2192 E} {\u03bc : Measure \u03b1} {a b : \u03b1}", "[NoAtoms \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (Icc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc"}, {"line": "rw [integrableOn_Icc_iff_integrableOn_Ioc]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Ioo a b) \u03bc\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 NoAtoms \u03bc"}, {"line": "rw [integrableOn_Ioc_iff_integrableOn_Ioo]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 NoAtoms \u03bc\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 MeasurableSingletonClass \u03b1\n---\n\u03b1 : Type u_1\nE : Type u_4\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\n\u03bc : Measure \u03b1\na b : \u03b1\ninst\u271d : NoAtoms \u03bc\n\u22a2 NoAtoms \u03bc"}]}
{"declaration": "theorem aecover_ball {x : \u03b1} {r : \u03b9 \u2192 \u211d} (hr : Tendsto r l atTop) :\n    AECover \u03bc l (fun i \u21a6 Metric.ball x (r i)) where\n  measurableSet _ := Metric.isOpen_ball.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ioi_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nl : Filter \u03b9\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nx : \u03b1\nr : \u03b9 \u2192 \u211d\nhr : Tendsto r l atTop\n\u22a2 \u2200\u1d50 (x_1 : \u03b1) \u2202\u03bc, \u2200\u1da0 (i : \u03b9) in l, x_1 \u2208 Metric.ball x (r i)"}, {"line": "filter_upwards with y", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nl : Filter \u03b9\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nx : \u03b1\nr : \u03b9 \u2192 \u211d\nhr : Tendsto r l atTop\ny : \u03b1\n\u22a2 \u2200\u1da0 (i : \u03b9) in l, y \u2208 Metric.ball x (r i)"}, {"line": "filter_upwards [hr (Ioi_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aecover_closedBall {x : \u03b1} {r : \u03b9 \u2192 \u211d} (hr : Tendsto r l atTop) :\n    AECover \u03bc l (fun i \u21a6 Metric.closedBall x (r i)) where\n  measurableSet _ := Metric.isClosed_closedBall.measurableSet\n  ae_eventually_mem := by\n    filter_upwards with y\n    filter_upwards [hr (Ici_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nl : Filter \u03b9\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nx : \u03b1\nr : \u03b9 \u2192 \u211d\nhr : Tendsto r l atTop\n\u22a2 \u2200\u1d50 (x_1 : \u03b1) \u2202\u03bc, \u2200\u1da0 (i : \u03b9) in l, x_1 \u2208 Metric.closedBall x (r i)"}, {"line": "filter_upwards with y", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b2 : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\nl : Filter \u03b9\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : OpensMeasurableSpace \u03b1\nx : \u03b1\nr : \u03b9 \u2192 \u211d\nhr : Tendsto r l atTop\ny : \u03b1\n\u22a2 \u2200\u1da0 (i : \u03b9) in l, y \u2208 Metric.closedBall x (r i)"}, {"line": "filter_upwards [hr (Ici_mem_atTop (dist x y))] with a ha using by simpa [dist_comm] using ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_deriv_of_nonneg (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x) (g'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x)\n    (hg : Tendsto g atTop (\ud835\udcdd l)) : IntegrableOn g' (Ioi a) := by\n  have hcont : ContinuousOn g (Ici a) := by\n    intro x hx\n    rcases hx.out.eq_or_lt with rfl|hx\n    \u00b7 exact hcont\n    \u00b7 exact (hderiv x hx).continuousAt.continuousWithinAt\n  refine integrableOn_Ioi_of_intervalIntegral_norm_tendsto (l - g a) a (fun x => ?_) tendsto_id ?_\n  \u00b7 exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n      (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n  apply Tendsto.congr' _ (hg.sub_const _)\n  filter_upwards [Ioi_mem_atTop a] with x hx\n  have h'x : a \u2264 id x := le_of_lt hx\n  calc\n    g x - g a = \u222b y in a..id x, g' y := by\n      symm\n      apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x\n        (hcont.mono Icc_subset_Ici_self) fun y hy => hderiv y hy.1\n      rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n      exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n        (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n    _ = \u222b y in a..id x, \u2016g' y\u2016 := by\n      simp_rw [intervalIntegral.integral_of_le h'x]\n      refine setIntegral_congr_fun measurableSet_Ioc fun y hy => ?_\n      dsimp\n      rw [abs_of_nonneg]\n      exact g'pos _ hy.1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhcont : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\n\u22a2 IntegrableOn g' (Ioi a) volume"}, {"line": "have hcont : ContinuousOn g (Ici a) := sorry", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\n\u22a2 IntegrableOn g' (Ioi a) volume"}, {"line": "refine integrableOn_Ioi_of_intervalIntegral_norm_tendsto (l - g a) a (fun x => ?_) tendsto_id ?_", "tactic_state": "case refine_1\ng g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\nx : \u211d\n\u22a2 IntegrableOn g' (Ioc a (id x)) volume\n---\ncase refine_2\ng g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\n\u22a2 Tendsto (fun i => \u222b (x : \u211d) in a..id i, \u2016g' x\u2016) atTop (nhds (l - g a))"}, {"line": "\u00b7 exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n      (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1", "tactic_state": "case refine_2\ng g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\n\u22a2 Tendsto (fun i => \u222b (x : \u211d) in a..id i, \u2016g' x\u2016) atTop (nhds (l - g a))"}, {"line": "apply Tendsto.congr' _ (hg.sub_const _)", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\n\u22a2 (fun x => g x - g a) =\u1da0[atTop] fun i => \u222b (x : \u211d) in a..id i, \u2016g' x\u2016"}, {"line": "filter_upwards [Ioi_mem_atTop a] with x hx", "tactic_state": "case h\ng g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\nx : \u211d\nhx : x \u2208 Ioi a\n\u22a2 g x - g a = \u222b (x : \u211d) in a..id x, \u2016g' x\u2016"}, {"line": "have h'x : a \u2264 id x := le_of_lt hx", "tactic_state": "case h\ng g' : \u211d \u2192 \u211d\na l : \u211d\nhcont\u271d : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\nhcont : ContinuousOn g (Ici a)\nx : \u211d\nhx : x \u2208 Ioi a\nh'x : a \u2264 id x\n\u22a2 g x - g a = \u222b (x : \u211d) in a..id x, \u2016g' x\u2016"}, {"line": "calc\n    g x - g a = \u222b y in a..id x, g' y := by\n      symm\n      apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le h'x\n        (hcont.mono Icc_subset_Ici_self) fun y hy => hderiv y hy.1\n      rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x]\n      exact intervalIntegral.integrableOn_deriv_of_nonneg (hcont.mono Icc_subset_Ici_self)\n        (fun y hy => hderiv y hy.1) fun y hy => g'pos y hy.1\n    _ = \u222b y in a..id x, \u2016g' y\u2016 := by\n      simp_rw [intervalIntegral.integral_of_le h'x]\n      refine setIntegral_congr_fun measurableSet_Ioc fun y hy => ?_\n      dsimp\n      rw [abs_of_nonneg]\n      exact g'pos _ hy.1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_deriv_of_nonneg' (hderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x)\n    (g'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x) (hg : Tendsto g atTop (\ud835\udcdd l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonneg ?_ (fun x hx => hderiv x hx.out.le) g'pos hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\n\u22a2 IntegrableOn g' (Ioi a) volume"}, {"line": "refine integrableOn_Ioi_deriv_of_nonneg ?_ (fun x hx => hderiv x hx.out.le) g'pos hg", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x\ng'pos : \u2200 x \u2208 Ioi a, 0 \u2264 g' x\nhg : Tendsto g atTop (nhds l)\n\u22a2 ContinuousWithinAt g (Ici a) a"}, {"line": "exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_deriv_of_nonpos (hcont : ContinuousWithinAt g (Ici a) a)\n    (hderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x) (g'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0)\n    (hg : Tendsto g atTop (\ud835\udcdd l)) : IntegrableOn g' (Ioi a) := by\n  apply integrable_neg_iff.1\n  exact integrableOn_Ioi_deriv_of_nonneg hcont.neg (fun x hx => (hderiv x hx).neg)\n    (fun x hx => neg_nonneg_of_nonpos (g'neg x hx)) hg.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhcont : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0\nhg : Tendsto g atTop (nhds l)\n\u22a2 IntegrableOn g' (Ioi a) volume"}, {"line": "apply integrable_neg_iff.1", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhcont : ContinuousWithinAt g (Ici a) a\nhderiv : \u2200 x \u2208 Ioi a, HasDerivAt g (g' x) x\ng'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0\nhg : Tendsto g atTop (nhds l)\n\u22a2 Integrable (-g') (volume.restrict (Ioi a))"}, {"line": "exact integrableOn_Ioi_deriv_of_nonneg hcont.neg (fun x hx => (hderiv x hx).neg)\n    (fun x hx => neg_nonneg_of_nonpos (g'neg x hx)) hg.neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_deriv_of_nonpos' (hderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x)\n    (g'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0) (hg : Tendsto g atTop (\ud835\udcdd l)) : IntegrableOn g' (Ioi a) := by\n  refine integrableOn_Ioi_deriv_of_nonpos ?_ (fun x hx \u21a6 hderiv x hx.out.le) g'neg hg\n  exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x\ng'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0\nhg : Tendsto g atTop (nhds l)\n\u22a2 IntegrableOn g' (Ioi a) volume"}, {"line": "refine integrableOn_Ioi_deriv_of_nonpos ?_ (fun x hx \u21a6 hderiv x hx.out.le) g'neg hg", "tactic_state": "g g' : \u211d \u2192 \u211d\na l : \u211d\nhderiv : \u2200 x \u2208 Ici a, HasDerivAt g (g' x) x\ng'neg : \u2200 x \u2208 Ioi a, g' x \u2264 0\nhg : Tendsto g atTop (nhds l)\n\u22a2 ContinuousWithinAt g (Ici a) a"}, {"line": "exact (hderiv a left_mem_Ici).continuousAt.continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_mul_deriv_Ioi {f f' : \u211d \u2192 \u211d} {g : \u211d \u2192 \u211d} {a : \u211d}\n    (hf : ContinuousOn f <| Ici a) (hft : Tendsto f atTop atTop)\n    (hff' : \u2200 x \u2208 Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hg_cont : ContinuousOn g <| f '' Ioi a) (hg1 : IntegrableOn g <| f '' Ici a)\n    (hg2 : IntegrableOn (fun x => (g \u2218 f) x * f' x) (Ici a)) :\n    (\u222b x in Ioi a, (g \u2218 f) x * f' x) = \u222b u in Ioi (f a), g u := by\n  have hg2' : IntegrableOn (fun x => f' x \u2022 (g \u2218 f) x) (Ici a) := by simpa [mul_comm] using hg2\n  simpa [mul_comm] using integral_comp_smul_deriv_Ioi hf hft hff' hg_cont hg1 hg2'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f f' g : \u211d \u2192 \u211d\na : \u211d\nhf : ContinuousOn f (Ici a)\nhft : Tendsto f atTop atTop\nhff' : \u2200 x \u2208 Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x\nhg_cont : ContinuousOn g (f '' Ioi a)\nhg1 : IntegrableOn g (f '' Ici a) volume\nhg2 : IntegrableOn (fun x => (g \u2218 f) x * f' x) (Ici a) volume\n\u22a2 \u222b (x : \u211d) in Ioi a, (g \u2218 f) x * f' x = \u222b (u : \u211d) in Ioi (f a), g u"}, {"line": "have hg2' : IntegrableOn (fun x => f' x \u2022 (g \u2218 f) x) (Ici a) := by simpa [mul_comm] using hg2", "tactic_state": "f f' g : \u211d \u2192 \u211d\na : \u211d\nhf : ContinuousOn f (Ici a)\nhft : Tendsto f atTop atTop\nhff' : \u2200 x \u2208 Ioi a, HasDerivWithinAt f (f' x) (Ioi x) x\nhg_cont : ContinuousOn g (f '' Ioi a)\nhg1 : IntegrableOn g (f '' Ici a) volume\nhg2 : IntegrableOn (fun x => (g \u2218 f) x * f' x) (Ici a) volume\nhg2' : IntegrableOn (fun x => f' x \u2022 (g \u2218 f) x) (Ici a) volume\n\u22a2 \u222b (x : \u211d) in Ioi a, (g \u2218 f) x * f' x = \u222b (u : \u211d) in Ioi (f a), g u"}, {"line": "simpa [mul_comm] using integral_comp_smul_deriv_Ioi hf hft hff' hg_cont hg1 hg2'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_rpow_Ioi_of_pos {g : \u211d \u2192 E} {p : \u211d} (hp : 0 < p) :\n    (\u222b x in Ioi 0, (p * x ^ (p - 1)) \u2022 g (x ^ p)) = \u222b y in Ioi 0, g y := by\n  convert integral_comp_rpow_Ioi g hp.ne'\n  rw [abs_of_nonneg hp.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\np : \u211d\nhp : 0 < p\n\u22a2 \u222b (x : \u211d) in Ioi 0, (p * x ^ (p - 1)) \u2022 g (x ^ p) = \u222b (y : \u211d) in Ioi 0, g y"}, {"line": "convert integral_comp_rpow_Ioi g hp.ne'", "tactic_state": "case h.e'_2.h.e'_7.h.h.e'_5.h.e'_5\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\np : \u211d\nhp : 0 < p\nx\u271d : \u211d\n\u22a2 p = |p|"}, {"line": "rw [abs_of_nonneg hp.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_mul_left_Ioi (g : \u211d \u2192 E) (a : \u211d) {b : \u211d} (hb : 0 < b) :\n    (\u222b x in Ioi a, g (b * x)) = b\u207b\u00b9 \u2022 \u222b x in Ioi (b * a), g x := by\n  have : \u2200 c : \u211d, MeasurableSet (Ioi c) := fun c => measurableSet_Ioi\n  rw [\u2190 integral_indicator (this a)]\n  rw [\u2190 integral_indicator (this (b * a))]\n  rw [\u2190 abs_of_pos (inv_pos.mpr hb)]\n  rw [\u2190 Measure.integral_comp_mul_left]\n  congr\n  ext1 x\n  rw [\u2190 indicator_comp_right]\n  rw [preimage_const_mul_Ioi _ hb]\n  rw [mul_div_cancel_left\u2080 _ hb.ne']\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in Ioi a, g (b * x) = b\u207b\u00b9 \u2022 \u222b (x : \u211d) in Ioi (b * a), g x"}, {"line": "have : \u2200 c : \u211d, MeasurableSet (Ioi c) := fun c => measurableSet_Ioi", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 \u222b (x : \u211d) in Ioi a, g (b * x) = b\u207b\u00b9 \u2022 \u222b (x : \u211d) in Ioi (b * a), g x"}, {"line": "rw [\u2190 integral_indicator (this a)]", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 \u222b (x : \u211d), (Ioi a).indicator (fun x => g (b * x)) x \u2202volume = b\u207b\u00b9 \u2022 \u222b (x : \u211d) in Ioi (b * a), g x"}, {"line": "rw [\u2190 integral_indicator (this (b * a))]", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 \u222b (x : \u211d), (Ioi a).indicator (fun x => g (b * x)) x \u2202volume = b\u207b\u00b9 \u2022 \u222b (x : \u211d), (Ioi (b * a)).indicator g x \u2202volume"}, {"line": "rw [\u2190 abs_of_pos (inv_pos.mpr hb)]", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 \u222b (x : \u211d), (Ioi a).indicator (fun x => g (b * x)) x \u2202volume = |b\u207b\u00b9| \u2022 \u222b (x : \u211d), (Ioi (b * a)).indicator g x \u2202volume"}, {"line": "rw [\u2190 Measure.integral_comp_mul_left]", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 \u222b (x : \u211d), (Ioi a).indicator (fun x => g (b * x)) x \u2202volume = \u222b (x : \u211d), (Ioi (b * a)).indicator g (b * x)"}, {"line": "congr", "tactic_state": "case e_f\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\n\u22a2 (fun x => (Ioi a).indicator (fun x => g (b * x)) x) = fun x => (Ioi (b * a)).indicator g (b * x)"}, {"line": "ext1 x", "tactic_state": "case e_f.h\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\nx : \u211d\n\u22a2 (Ioi a).indicator (fun x => g (b * x)) x = (Ioi (b * a)).indicator g (b * x)"}, {"line": "rw [\u2190 indicator_comp_right]", "tactic_state": "case e_f.h\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\nx : \u211d\n\u22a2 (Ioi a).indicator (fun x => g (b * x)) x = (HMul.hMul b \u207b\u00b9' Ioi (b * a)).indicator (g \u2218 HMul.hMul b) x"}, {"line": "rw [preimage_const_mul_Ioi _ hb]", "tactic_state": "case e_f.h\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\nx : \u211d\n\u22a2 (Ioi a).indicator (fun x => g (b * x)) x = (Ioi (b * a / b)).indicator (g \u2218 HMul.hMul b) x"}, {"line": "rw [mul_div_cancel_left\u2080 _ hb.ne']", "tactic_state": "case e_f.h\nE : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\nthis : \u2200 (c : \u211d), MeasurableSet (Ioi c)\nx : \u211d\n\u22a2 (Ioi a).indicator (fun x => g (b * x)) x = (Ioi a).indicator (g \u2218 HMul.hMul b) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_mul_right_Ioi (g : \u211d \u2192 E) (a : \u211d) {b : \u211d} (hb : 0 < b) :\n    (\u222b x in Ioi a, g (x * b)) = b\u207b\u00b9 \u2022 \u222b x in Ioi (a * b), g x := by\n  simpa only [mul_comm] using integral_comp_mul_left_Ioi g a hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_20\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ng : \u211d \u2192 E\na b : \u211d\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in Ioi a, g (x * b) = b\u207b\u00b9 \u2022 \u222b (x : \u211d) in Ioi (a * b), g x"}, {"line": "simpa only [mul_comm] using integral_comp_mul_left_Ioi g a hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_comp_mul_left_iff (f : \u211d \u2192 E) (c : \u211d) {a : \u211d} (ha : 0 < a) :\n    IntegrableOn (fun x => f (a * x)) (Ioi c) \u2194 IntegrableOn f (Ioi <| a * c) := by\n  rw [\u2190 integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi c)]\n  rw [\u2190 integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi <| a * c)]\n  convert integrable_comp_mul_left_iff ((Ioi (a * c)).indicator f) ha.ne' using 2\n  ext1 x\n  rw [\u2190 indicator_comp_right]\n  rw [preimage_const_mul_Ioi _ ha]\n  rw [mul_comm a c]\n  rw [mul_div_cancel_right\u2080 _ ha.ne']\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\n\u22a2 IntegrableOn (fun x => f (a * x)) (Ioi c) volume \u2194 IntegrableOn f (Ioi (a * c)) volume"}, {"line": "rw [\u2190 integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi c)]", "tactic_state": "E : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\n\u22a2 Integrable ((Ioi c).indicator fun x => f (a * x)) volume \u2194 IntegrableOn f (Ioi (a * c)) volume"}, {"line": "rw [\u2190 integrable_indicator_iff (measurableSet_Ioi : MeasurableSet <| Ioi <| a * c)]", "tactic_state": "E : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\n\u22a2 Integrable ((Ioi c).indicator fun x => f (a * x)) volume \u2194 Integrable ((Ioi (a * c)).indicator f) volume"}, {"line": "convert integrable_comp_mul_left_iff ((Ioi (a * c)).indicator f) ha.ne' using 2", "tactic_state": "case h.e'_1.h.e'_6\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\n\u22a2 ((Ioi c).indicator fun x => f (a * x)) = fun x => (Ioi (a * c)).indicator f (a * x)"}, {"line": "ext1 x", "tactic_state": "case h.e'_1.h.e'_6.h\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\nx : \u211d\n\u22a2 (Ioi c).indicator (fun x => f (a * x)) x = (Ioi (a * c)).indicator f (a * x)"}, {"line": "rw [\u2190 indicator_comp_right]", "tactic_state": "case h.e'_1.h.e'_6.h\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\nx : \u211d\n\u22a2 (Ioi c).indicator (fun x => f (a * x)) x = (HMul.hMul a \u207b\u00b9' Ioi (a * c)).indicator (f \u2218 HMul.hMul a) x"}, {"line": "rw [preimage_const_mul_Ioi _ ha]", "tactic_state": "case h.e'_1.h.e'_6.h\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\nx : \u211d\n\u22a2 (Ioi c).indicator (fun x => f (a * x)) x = (Ioi (a * c / a)).indicator (f \u2218 HMul.hMul a) x"}, {"line": "rw [mul_comm a c]", "tactic_state": "case h.e'_1.h.e'_6.h\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\nx : \u211d\n\u22a2 (Ioi c).indicator (fun x => f (a * x)) x = (Ioi (c * a / a)).indicator (f \u2218 HMul.hMul a) x"}, {"line": "rw [mul_div_cancel_right\u2080 _ ha.ne']", "tactic_state": "case h.e'_1.h.e'_6.h\nE : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\nx : \u211d\n\u22a2 (Ioi c).indicator (fun x => f (a * x)) x = (Ioi c).indicator (f \u2218 HMul.hMul a) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_comp_mul_right_iff (f : \u211d \u2192 E) (c : \u211d) {a : \u211d} (ha : 0 < a) :\n    IntegrableOn (fun x => f (x * a)) (Ioi c) \u2194 IntegrableOn f (Ioi <| c * a) := by\n  simpa only [mul_comm,mul_zero] using integrableOn_Ioi_comp_mul_left_iff f c ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntegralEqImproper.lean", "context": {"open": ["MeasureTheory Filter Set TopologicalSpace Topology", "scoped ENNReal NNReal", "Real", "scoped Interval", "UniformSpace in", "UniformSpace in", "UniformSpace in", "Real", "scoped Interval", "Real", "scoped Interval"], "variables": ["{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) (l : Filter \u03b9)", "{\u03bc} {l}", "[PseudoMetricSpace \u03b1] [OpensMeasurableSpace \u03b1]", "[Preorder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderClosedTopology \u03b1] [OpensMeasurableSpace \u03b1]", "[NoAtoms \u03bc]", "{\u03b1 \u03b9 : Type*} [Countable \u03b9] [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "{\u03b1 \u03b9 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9}", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b1 \u03b9 E : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1} {l : Filter \u03b9} [NormedAddCommGroup E]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [Filter.NeBot l] [IsCountablyGenerated l]", "{\u03b9 E : Type*} {\u03bc : Measure \u211d} {l : Filter \u03b9} [IsCountablyGenerated l]", "{E : Type*} {f f' : \u211d \u2192 E} {g g' : \u211d \u2192 \u211d} {a l : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {a : \u211d} {m : E} [NormedAddCommGroup E]", "[CompleteSpace E]", "{E : Type*} {f f' : \u211d \u2192 E} {m n : E} [NormedAddCommGroup E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_21\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\nc a : \u211d\nha : 0 < a\n\u22a2 IntegrableOn (fun x => f (x * a)) (Ioi c) volume \u2194 IntegrableOn f (Ioi (c * a)) volume"}, {"line": "simpa only [mul_comm,mul_zero] using integrableOn_Ioi_comp_mul_left_iff f c ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interval_average_symm (f : \u211d \u2192 E) (a b : \u211d) : (\u2a0d x in a..b, f x) = \u2a0d x in b..a, f x := by\n  rw [setAverage_eq]\n  rw [setAverage_eq]\n  rw [uIoc_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "context": {"open": ["MeasureTheory Set TopologicalSpace", "scoped Interval"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = \u2a0d (x : \u211d) in b..a, f x"}, {"line": "rw [setAverage_eq]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u22a2 (volume.real (uIoc a b))\u207b\u00b9 \u2022 \u222b (x : \u211d) in uIoc a b, f x = \u2a0d (x : \u211d) in b..a, f x"}, {"line": "rw [setAverage_eq]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u22a2 (volume.real (uIoc a b))\u207b\u00b9 \u2022 \u222b (x : \u211d) in uIoc a b, f x = (volume.real (uIoc b a))\u207b\u00b9 \u2022 \u222b (x : \u211d) in uIoc b a, f x"}, {"line": "rw [uIoc_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interval_average_eq (f : \u211d \u2192 E) (a b : \u211d) :\n    (\u2a0d x in a..b, f x) = (b - a)\u207b\u00b9 \u2022 \u222b x in a..b, f x := by\n  rcases le_or_lt a b with h | h\n  \u00b7 rw [setAverage_eq, uIoc_of_le h, Real.volume_real_Ioc_of_le h,\n      intervalIntegral.integral_of_le h]\n  \u00b7 rw [setAverage_eq, uIoc_of_ge h.le, Real.volume_real_Ioc_of_le h.le,\n      intervalIntegral.integral_of_ge h.le, smul_neg, \u2190 neg_smul, \u2190 inv_neg, neg_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "context": {"open": ["MeasureTheory Set TopologicalSpace", "scoped Interval"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f x"}, {"line": "rcases le_or_lt a b with h | h", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nh : a \u2264 b\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f x\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nh : b < a\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f x"}, {"line": "\u00b7 rw [setAverage_eq, uIoc_of_le h, Real.volume_real_Ioc_of_le h,\n      intervalIntegral.integral_of_le h]", "tactic_state": "case inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nh : b < a\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f x"}, {"line": "\u00b7 rw [setAverage_eq, uIoc_of_ge h.le, Real.volume_real_Ioc_of_le h.le,\n      intervalIntegral.integral_of_ge h.le, smul_neg, \u2190 neg_smul, \u2190 inv_neg, neg_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interval_average_eq_div (f : \u211d \u2192 \u211d) (a b : \u211d) :\n    (\u2a0d x in a..b, f x) = (\u222b x in a..b, f x) / (b - a) := by\n  rw [interval_average_eq]\n  rw [smul_eq_mul]\n  rw [div_eq_inv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "context": {"open": ["MeasureTheory Set TopologicalSpace", "scoped Interval"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\n\u22a2 \u2a0d (x : \u211d) in a..b, f x = (\u222b (x : \u211d) in a..b, f x) / (b - a)"}, {"line": "rw [interval_average_eq]", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\n\u22a2 (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f x = (\u222b (x : \u211d) in a..b, f x) / (b - a)"}, {"line": "rw [smul_eq_mul]", "tactic_state": "f : \u211d \u2192 \u211d\na b : \u211d\n\u22a2 (b - a)\u207b\u00b9 * \u222b (x : \u211d) in a..b, f x = (\u222b (x : \u211d) in a..b, f x) / (b - a)"}, {"line": "rw [div_eq_inv_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalAverage_congr_codiscreteWithin {a b : \u211d} {f\u2081 f\u2082 : \u211d \u2192 \u211d}\n    (hf : f\u2081 =\u1da0[Filter.codiscreteWithin (\u0399 a b)] f\u2082) :\n    \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x := by\n  rw [interval_average_eq]\n  rw [intervalIntegral.integral_congr_codiscreteWithin hf]\n  rw [\u2190 interval_average_eq]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalAverage.lean", "context": {"open": ["MeasureTheory Set TopologicalSpace", "scoped Interval"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf\u2081 f\u2082 : \u211d \u2192 \u211d\nhf : f\u2081 =\u1da0[Filter.codiscreteWithin (uIoc a b)] f\u2082\n\u22a2 \u2a0d (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x"}, {"line": "rw [interval_average_eq]", "tactic_state": "a b : \u211d\nf\u2081 f\u2082 : \u211d \u2192 \u211d\nhf : f\u2081 =\u1da0[Filter.codiscreteWithin (uIoc a b)] f\u2082\n\u22a2 (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f\u2081 x = \u2a0d (x : \u211d) in a..b, f\u2082 x"}, {"line": "rw [intervalIntegral.integral_congr_codiscreteWithin hf]", "tactic_state": "a b : \u211d\nf\u2081 f\u2082 : \u211d \u2192 \u211d\nhf : f\u2081 =\u1da0[Filter.codiscreteWithin (uIoc a b)] f\u2082\n\u22a2 (b - a)\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f\u2082 x = \u2a0d (x : \u211d) in a..b, f\u2082 x"}, {"line": "rw [\u2190 interval_average_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_comp_eq_lintegral_meas_le_mul (\u03bc : Measure \u03b1) (f_nn : 0 \u2264\u1d50[\u03bc] f)\n    (f_mble : AEMeasurable f \u03bc) (g_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : \u2200\u1d50 t \u2202volume.restrict (Ioi 0), 0 \u2264 g t) :\n    \u222b\u207b \u03c9, ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) \u2202\u03bc =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t) := by\n  obtain \u27e8G, G_mble, G_nn, g_eq_G\u27e9 : \u2203 G : \u211d \u2192 \u211d, Measurable G \u2227 0 \u2264 G\n      \u2227 g =\u1d50[volume.restrict (Ioi 0)] G := by\n    refine AEMeasurable.exists_measurable_nonneg ?_ g_nn\n    exact aemeasurable_Ioi_of_forall_Ioc fun t ht => (g_intble t ht).1.1.aemeasurable\n  have g_eq_G_on : \u2200 t, g =\u1d50[volume.restrict (Ioc 0 t)] G := fun t =>\n    ae_mono (Measure.restrict_mono Ioc_subset_Ioi_self le_rfl) g_eq_G\n  have G_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t := by\n    refine fun t t_pos => \u27e8(g_intble t t_pos).1.congr_fun_ae (g_eq_G_on t), ?_\u27e9\n    rw [Ioc_eq_empty_of_le t_pos.lt.le]\n    exact integrableOn_empty\n  obtain \u27e8F, F_mble, F_nn, f_eq_F\u27e9 : \u2203 F : \u03b1 \u2192 \u211d, Measurable F \u2227 0 \u2264 F \u2227 f =\u1d50[\u03bc] F := by\n    refine \u27e8fun \u03c9 \u21a6 max (f_mble.mk f \u03c9) 0, f_mble.measurable_mk.max measurable_const,\n        fun \u03c9 \u21a6 le_max_right _ _, ?_\u27e9\n    filter_upwards [f_mble.ae_eq_mk, f_nn] with \u03c9 h\u03c9 h'\u03c9\n    rw [\u2190 h\u03c9]\n    exact (max_eq_left h'\u03c9).symm\n  have eq\u2081 :\n    \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 F a} * ENNReal.ofReal (G t) := by\n    apply lintegral_congr_ae\n    filter_upwards [g_eq_G] with t ht\n    rw [ht]\n    congr 1\n    apply measure_congr\n    filter_upwards [f_eq_F] with a ha using by simp [setOf, ha]\n  have eq\u2082 : \u2200\u1d50 \u03c9 \u2202\u03bc,\n      ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) = ENNReal.ofReal (\u222b t in (0)..F \u03c9, G t) := by\n    filter_upwards [f_eq_F] with \u03c9 f\u03c9_nn\n    rw [f\u03c9_nn]\n    congr 1\n    refine intervalIntegral.integral_congr_ae ?_\n    have f\u03c9_nn : 0 \u2264 F \u03c9 := F_nn \u03c9\n    rw [uIoc_of_le f\u03c9_nn]\n    rw [\u2190       ae_restrict_iff' (measurableSet_Ioc : MeasurableSet (Ioc (0 : \u211d) (F \u03c9)))]\n    exact g_eq_G_on (F \u03c9)\n  simp_rw [lintegral_congr_ae eq\u2082, eq\u2081]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable \u03bc F_nn F_mble\n          G_intble G_mble (fun t _ => G_nn t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Layercake.lean", "context": {"open": ["scoped ENNReal MeasureTheory Topology", "Set MeasureTheory Filter Measure"], "variables": ["{\u03b1 R : Type*} [MeasurableSpace \u03b1] (\u03bc : Measure \u03b1) [LinearOrder R]", "{\u03b1 : Type*} [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u211d} {g : \u211d \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "obtain \u27e8G, G_mble, G_nn, g_eq_G\u27e9 : \u2203 G : \u211d \u2192 \u211d, Measurable G \u2227 0 \u2264 G\n      \u2227 g =\u1d50[volume.restrict (Ioi 0)] G := by\n    refine AEMeasurable.exists_measurable_nonneg ?_ g_nn\n    exact aemeasurable_Ioi_of_forall_Ioc fun t ht => (g_intble t ht).1.1.aemeasurable", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "have g_eq_G_on : \u2200 t, g =\u1d50[volume.restrict (Ioc 0 t)] G := fun t =>\n    ae_mono (Measure.restrict_mono Ioc_subset_Ioi_self le_rfl) g_eq_G", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "have G_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t := sorry", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\nG_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "obtain \u27e8F, F_mble, F_nn, f_eq_F\u27e9 : \u2203 F : \u03b1 \u2192 \u211d, Measurable F \u2227 0 \u2264 F \u2227 f =\u1d50[\u03bc] F := by\n    refine \u27e8fun \u03c9 \u21a6 max (f_mble.mk f \u03c9) 0, f_mble.measurable_mk.max measurable_const,\n        fun \u03c9 \u21a6 le_max_right _ _, ?_\u27e9\n    filter_upwards [f_mble.ae_eq_mk, f_nn] with \u03c9 h\u03c9 h'\u03c9\n    rw [\u2190 h\u03c9]\n    exact (max_eq_left h'\u03c9).symm", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\nG_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t\nF : \u03b1 \u2192 \u211d\nF_mble : sorry\nF_nn : 0 \u2264 F\nf_eq_F : f =\u1da0[ae \u03bc] F\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "have eq\u2081 :\n    \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 f a} * ENNReal.ofReal (g t) =\n      \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t \u2264 F a} * ENNReal.ofReal (G t) := by\n    apply lintegral_congr_ae\n    filter_upwards [g_eq_G] with t ht\n    rw [ht]\n    congr 1\n    apply measure_congr\n    filter_upwards [f_eq_F] with a ha using by simp [setOf, ha]", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\nG_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t\nF : \u03b1 \u2192 \u211d\nF_mble : sorry\nF_nn : 0 \u2264 F\nf_eq_F : f =\u1da0[ae \u03bc] F\neq\u2081 :\n  \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t) =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 F a} * ENNReal.ofReal (G t)\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "have eq\u2082 : \u2200\u1d50 \u03c9 \u2202\u03bc,\n      ENNReal.ofReal (\u222b t in (0)..f \u03c9, g t) = ENNReal.ofReal (\u222b t in (0)..F \u03c9, G t) := by\n    filter_upwards [f_eq_F] with \u03c9 f\u03c9_nn\n    rw [f\u03c9_nn]\n    congr 1\n    refine intervalIntegral.integral_congr_ae ?_\n    have f\u03c9_nn : 0 \u2264 F \u03c9 := F_nn \u03c9\n    rw [uIoc_of_le f\u03c9_nn]\n    rw [\u2190       ae_restrict_iff' (measurableSet_Ioc : MeasurableSet (Ioc (0 : \u211d) (F \u03c9)))]\n    exact g_eq_G_on (F \u03c9)", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\nG_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t\nF : \u03b1 \u2192 \u211d\nF_mble : sorry\nF_nn : 0 \u2264 F\nf_eq_F : f =\u1da0[ae \u03bc] F\neq\u2081 :\n  \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t) =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 F a} * ENNReal.ofReal (G t)\neq\u2082 : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) = ENNReal.ofReal (\u222b (t : \u211d) in 0 ..F \u03c9, G t)\n\u22a2 \u222b\u207b (\u03c9 : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t)"}, {"line": "simp_rw [lintegral_congr_ae eq\u2082, eq\u2081]", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_3\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u211d\ng : \u211d \u2192 \u211d\n\u03bc : Measure \u03b1\nf_nn : 0 \u2264\u1da0[ae \u03bc] f\nf_mble : AEMeasurable f \u03bc\ng_intble : \u2200 t > 0, IntervalIntegrable g volume 0 t\ng_nn : \u2200\u1d50 (t : \u211d) \u2202volume.restrict (Ioi 0), 0 \u2264 g t\nG : \u211d \u2192 \u211d\nG_mble : Measurable G\nG_nn : 0 \u2264 G\ng_eq_G : g =\u1da0[ae (volume.restrict (Ioi 0))] G\ng_eq_G_on : \u2200 (t : \u211d), g =\u1da0[ae (volume.restrict (Ioc 0 t))] G\nG_intble : \u2200 t > 0, IntervalIntegrable G volume 0 t\nF : \u03b1 \u2192 \u211d\nF_mble : sorry\nF_nn : 0 \u2264 F\nf_eq_F : f =\u1da0[ae \u03bc] F\neq\u2081 :\n  \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 f a} * ENNReal.ofReal (g t) =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 F a} * ENNReal.ofReal (G t)\neq\u2082 : \u2200\u1d50 (\u03c9 : \u03b1) \u2202\u03bc, ENNReal.ofReal (\u222b (t : \u211d) in 0 ..f \u03c9, g t) = ENNReal.ofReal (\u222b (t : \u211d) in 0 ..F \u03c9, G t)\n\u22a2 \u222b\u207b (a : \u03b1), ENNReal.ofReal (\u222b (t : \u211d) in 0 ..F a, G t) \u2202\u03bc =\n    \u222b\u207b (t : \u211d) in Ioi 0, \u03bc {a | t \u2264 F a} * ENNReal.ofReal (G t)"}, {"line": "exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable \u03bc F_nn F_mble\n          G_intble G_mble (fun t _ => G_nn t)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_mul_le_one_of_lintegral_rpow_eq_one {p q : \u211d} (hpq : p.HolderConjugate q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc) (hf_norm : \u222b\u207b a, f a ^ p \u2202\u03bc = 1)\n    (hg_norm : \u222b\u207b a, g a ^ q \u2202\u03bc = 1) : (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 1 := by\n  calc\n    (\u222b\u207b a : \u03b1, (f * g) a \u2202\u03bc) \u2264\n        \u222b\u207b a : \u03b1, f a ^ p / ENNReal.ofReal p + g a ^ q / ENNReal.ofReal q \u2202\u03bc :=\n      lintegral_mono fun a => young_inequality (f a) (g a) hpq\n    _ = 1 := by\n      simp only [div_eq_mul_inv]\n      rw [lintegral_add_left']\n      \u00b7 rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const', hf_norm, hg_norm,\n          one_mul, one_mul, hpq.inv_add_inv_ennreal]\n        simp [hpq.symm.pos]\n      \u00b7 exact (hf.pow_const _).mul_const _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.HolderConjugate q\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_norm : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 1\nhg_norm : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc = 1\n\u22a2 \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc \u2264 1"}, {"line": "calc\n    (\u222b\u207b a : \u03b1, (f * g) a \u2202\u03bc) \u2264\n        \u222b\u207b a : \u03b1, f a ^ p / ENNReal.ofReal p + g a ^ q / ENNReal.ofReal q \u2202\u03bc :=\n      lintegral_mono fun a => young_inequality (f a) (g a) hpq\n    _ = 1 := by\n      simp only [div_eq_mul_inv]\n      rw [lintegral_add_left']\n      \u00b7 rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const', hf_norm, hg_norm,\n          one_mul, one_mul, hpq.inv_add_inv_ennreal]\n        simp [hpq.symm.pos]\n      \u00b7 exact (hf.pow_const _).mul_const _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fun_eq_funMulInvSnorm_mul_eLpNorm {p : \u211d} (f : \u03b1 \u2192 \u211d\u22650\u221e)\n    (hf_nonzero : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 0) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) {a : \u03b1} :\n    f a = funMulInvSnorm f p \u03bc a * (\u222b\u207b c, f c ^ p \u2202\u03bc) ^ (1 / p) := by\n  simp [funMulInvSnorm, mul_assoc, ENNReal.inv_mul_cancel, hf_nonzero, hf_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\na : \u03b1\n\u22a2 f a = funMulInvSnorm f p \u03bc a * (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc) ^ (1 / p)"}, {"line": "simp [funMulInvSnorm, mul_assoc, ENNReal.inv_mul_cancel, hf_nonzero, hf_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_rpow_funMulInvSnorm_eq_one {p : \u211d} (hp0_lt : 0 < p) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf_nonzero : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 0) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    \u222b\u207b c, funMulInvSnorm f p \u03bc c ^ p \u2202\u03bc = 1 := by\n  simp_rw [funMulInvSnorm_rpow hp0_lt]\n  rw [lintegral_mul_const']\n  rw [ENNReal.mul_inv_cancel hf_nonzero hf_top]\n  rwa [inv_ne_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0_lt : 0 < p\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 \u222b\u207b (c : \u03b1), funMulInvSnorm f p \u03bc c ^ p \u2202\u03bc = 1"}, {"line": "simp_rw [funMulInvSnorm_rpow hp0_lt]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0_lt : 0 < p\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 \u222b\u207b (c : \u03b1), f c ^ p * (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc)\u207b\u00b9 \u2202\u03bc = 1"}, {"line": "rw [lintegral_mul_const']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0_lt : 0 < p\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 (\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) * (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc)\u207b\u00b9 = 1\n---\ncase hr\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0_lt : 0 < p\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc)\u207b\u00b9 \u2260 \u22a4"}, {"line": "rw [ENNReal.mul_inv_cancel hf_nonzero hf_top]", "tactic_state": "case hr\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0_lt : 0 < p\nf : \u03b1 \u2192 ENNReal\nhf_nonzero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 0\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 (\u222b\u207b (c : \u03b1), f c ^ p \u2202\u03bc)\u207b\u00b9 \u2260 \u22a4"}, {"line": "rwa [inv_ne_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_eq_zero_of_lintegral_rpow_eq_zero {p : \u211d} (hp0 : 0 \u2264 p) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_zero : \u222b\u207b a, f a ^ p \u2202\u03bc = 0) : f =\u1d50[\u03bc] 0 := by\n  rw [lintegral_eq_zero_iff' (hf.pow_const p)] at hf_zero\n  filter_upwards [hf_zero] with x\n  rw [Pi.zero_apply]\n  rw [\u2190 not_imp_not]\n  exact fun hx => (rpow_pos_of_nonneg (pos_iff_ne_zero.2 hx) hp0).ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\n\u22a2 f =\u1da0[ae \u03bc] 0"}, {"line": "rw [lintegral_eq_zero_iff' (hf.pow_const p)] at hf_zero", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : (fun x => f x ^ p) =\u1da0[ae \u03bc] 0\n\u22a2 f =\u1da0[ae \u03bc] 0"}, {"line": "filter_upwards [hf_zero] with x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : (fun x => f x ^ p) =\u1da0[ae \u03bc] 0\nx : \u03b1\n\u22a2 f x ^ p = 0 x \u2192 f x = 0 x"}, {"line": "rw [Pi.zero_apply]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : (fun x => f x ^ p) =\u1da0[ae \u03bc] 0\nx : \u03b1\n\u22a2 f x ^ p = 0 \u2192 f x = 0"}, {"line": "rw [\u2190 not_imp_not]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : (fun x => f x ^ p) =\u1da0[ae \u03bc] 0\nx : \u03b1\n\u22a2 \u00acf x = 0 \u2192 \u00acf x ^ p = 0"}, {"line": "exact fun hx => (rpow_pos_of_nonneg (pos_iff_ne_zero.2 hx) hp0).ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero {p : \u211d} (hp0 : 0 \u2264 p) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hf_zero : \u222b\u207b a, f a ^ p \u2202\u03bc = 0) : (\u222b\u207b a, (f * g) a \u2202\u03bc) = 0 := by\n  rw [\u2190 @lintegral_zero_fun \u03b1 _ \u03bc]\n  refine lintegral_congr_ae ?_\n  suffices h_mul_zero : f * g =\u1d50[\u03bc] 0 * g by rwa [zero_mul] at h_mul_zero\n  have hf_eq_zero : f =\u1d50[\u03bc] 0 := ae_eq_zero_of_lintegral_rpow_eq_zero hp0 hf hf_zero\n  exact hf_eq_zero.mul (ae_eq_refl g)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\n\u22a2 \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc = 0"}, {"line": "rw [\u2190 @lintegral_zero_fun \u03b1 _ \u03bc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\n\u22a2 \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc = lintegral \u03bc 0"}, {"line": "refine lintegral_congr_ae ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\n\u22a2 f * g =\u1da0[ae \u03bc] 0"}, {"line": "suffices h_mul_zero : f * g =\u1d50[\u03bc] 0 * g by rwa [zero_mul] at h_mul_zero", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\n\u22a2 f * g =\u1da0[ae \u03bc] 0 * g"}, {"line": "have hf_eq_zero : f =\u1d50[\u03bc] 0 := ae_eq_zero_of_lintegral_rpow_eq_zero hp0 hf hf_zero", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np : \u211d\nhp0 : 0 \u2264 p\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_zero : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = 0\nhf_eq_zero : f =\u1da0[ae \u03bc] 0\n\u22a2 f * g =\u1da0[ae \u03bc] 0 * g"}, {"line": "exact hf_eq_zero.mul (ae_eq_refl g)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top {p q : \u211d} (hp0_lt : 0 < p) (hq0 : 0 \u2264 q)\n    {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf_top : \u222b\u207b a, f a ^ p \u2202\u03bc = \u22a4) (hg_nonzero : (\u222b\u207b a, g a ^ q \u2202\u03bc) \u2260 0) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264 (\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, g a ^ q \u2202\u03bc) ^ (1 / q) := by\n  refine le_trans le_top (le_of_eq ?_)\n  have hp0_inv_lt : 0 < 1 / p := by simp [hp0_lt]\n  rw [hf_top]\n  rw [ENNReal.top_rpow_of_pos hp0_inv_lt]\n  simp [hq0, hg_nonzero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhp0_lt : 0 < p\nhq0 : 0 \u2264 q\nf g : \u03b1 \u2192 ENNReal\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\n\u22a2 \u222b\u207b (a : \u03b1), (f * g) a \u2202\u03bc \u2264 (\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "refine le_trans le_top (le_of_eq ?_)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhp0_lt : 0 < p\nhq0 : 0 \u2264 q\nf g : \u03b1 \u2192 ENNReal\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\n\u22a2 \u22a4 = (\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "have hp0_inv_lt : 0 < 1 / p := sorry", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhp0_lt : 0 < p\nhq0 : 0 \u2264 q\nf g : \u03b1 \u2192 ENNReal\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\nhp0_inv_lt : 0 < 1 / p\n\u22a2 \u22a4 = (\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "rw [hf_top]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhp0_lt : 0 < p\nhq0 : 0 \u2264 q\nf g : \u03b1 \u2192 ENNReal\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\nhp0_inv_lt : 0 < 1 / p\n\u22a2 \u22a4 = \u22a4 ^ (1 / p) * (\u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "rw [ENNReal.top_rpow_of_pos hp0_inv_lt]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhp0_lt : 0 < p\nhq0 : 0 \u2264 q\nf g : \u03b1 \u2192 ENNReal\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc = \u22a4\nhg_nonzero : \u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc \u2260 0\nhp0_inv_lt : 0 < 1 / p\n\u22a2 \u22a4 = \u22a4 * (\u222b\u207b (a : \u03b1), g a ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "simp [hq0, hg_nonzero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_Lp_mul_le_Lq_mul_Lr {\u03b1} [MeasurableSpace \u03b1] {p q r : \u211d} (hp0_lt : 0 < p)\n    (hpq : p < q) (hpqr : 1 / p = 1 / q + 1 / r) (\u03bc : Measure \u03b1) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    (\u222b\u207b a, (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n      (\u222b\u207b a, f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b a, g a ^ r \u2202\u03bc) ^ (1 / r) := by\n  have hp0_ne : p \u2260 0 := (ne_of_lt hp0_lt).symm\n  have hp0 : 0 \u2264 p := le_of_lt hp0_lt\n  have hq0_lt : 0 < q := lt_of_le_of_lt hp0 hpq\n  have hq0_ne : q \u2260 0 := (ne_of_lt hq0_lt).symm\n  have h_one_div_r : 1 / r = 1 / p - 1 / q := by rw [hpqr]; simp\n  let p2 := q / p\n  let q2 := p2.conjExponent\n  have hp2q2 : p2.HolderConjugate q2 :=\n    .conjExponent (by simp [p2, q2, _root_.lt_div_iff\u2080, hpq, hp0_lt])\n  calc\n    (\u222b\u207b a : \u03b1, (f * g) a ^ p \u2202\u03bc) ^ (1 / p) = (\u222b\u207b a : \u03b1, f a ^ p * g a ^ p \u2202\u03bc) ^ (1 / p) := by\n      simp_rw [Pi.mul_apply, ENNReal.mul_rpow_of_nonneg _ _ hp0]\n    _ \u2264 ((\u222b\u207b a, f a ^ (p * p2) \u2202\u03bc) ^ (1 / p2) *\n        (\u222b\u207b a, g a ^ (p * q2) \u2202\u03bc) ^ (1 / q2)) ^ (1 / p) := by\n      gcongr\n      simp_rw [ENNReal.rpow_mul]\n      exact ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hp2q2 (hf.pow_const _) (hg.pow_const _)\n    _ = (\u222b\u207b a : \u03b1, f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b a : \u03b1, g a ^ r \u2202\u03bc) ^ (1 / r) := by\n      rw [@ENNReal.mul_rpow_of_nonneg _ _ (1 / p) (by simp [hp0]), \u2190 ENNReal.rpow_mul, \u2190\n        ENNReal.rpow_mul]\n      have hpp2 : p * p2 = q := by\n        symm\n        rw [mul_comm]\n        rw [\u2190 div_eq_iff hp0_ne]\n      have hpq2 : p * q2 = r := by\n        rw [\u2190 inv_inv r]\n        rw [\u2190 one_div]\n        rw [\u2190 one_div]\n        rw [h_one_div_r]\n        field_simp [p2, q2, Real.conjExponent, hp0_ne, hq0_ne]\n      simp_rw [div_mul_div_comm, mul_one, mul_comm p2, mul_comm q2, hpp2, hpq2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have hp0_ne : p \u2260 0 := (ne_of_lt hp0_lt).symm", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have hp0 : 0 \u2264 p := le_of_lt hp0_lt", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have hq0_lt : 0 < q := lt_of_le_of_lt hp0 hpq", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have hq0_ne : q \u2260 0 := (ne_of_lt hq0_lt).symm", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\nhq0_ne : q \u2260 0\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have h_one_div_r : 1 / r = 1 / p - 1 / q := by rw [hpqr]; simp", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\nhq0_ne : q \u2260 0\nh_one_div_r : 1 / r = 1 / p - 1 / q\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "let p2 := q / p", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\nhq0_ne : q \u2260 0\nh_one_div_r : 1 / r = 1 / p - 1 / q\np2 : \u211d := q / p\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "let q2 := p2.conjExponent", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\nhq0_ne : q \u2260 0\nh_one_div_r : 1 / r = 1 / p - 1 / q\np2 : \u211d := q / p\nq2 : \u211d := p2.conjExponent\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "have hp2q2 : p2.HolderConjugate q2 :=\n    .conjExponent (by simp [p2, q2, _root_.lt_div_iff\u2080, hpq, hp0_lt])", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : MeasurableSpace \u03b1\np q r : \u211d\nhp0_lt : 0 < p\nhpq : p < q\nhpqr : 1 / p = 1 / q + 1 / r\n\u03bc : Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\nhp0_ne : p \u2260 0\nhp0 : 0 \u2264 p\nhq0_lt : 0 < q\nhq0_ne : q \u2260 0\nh_one_div_r : 1 / r = 1 / p - 1 / q\np2 : \u211d := q / p\nq2 : \u211d := p2.conjExponent\nhp2q2 : p2.HolderConjugate q2\n\u22a2 (\u222b\u207b (a : \u03b1), (f * g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264 (\u222b\u207b (a : \u03b1), f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b (a : \u03b1), g a ^ r \u2202\u03bc) ^ (1 / r)"}, {"line": "calc\n    (\u222b\u207b a : \u03b1, (f * g) a ^ p \u2202\u03bc) ^ (1 / p) = (\u222b\u207b a : \u03b1, f a ^ p * g a ^ p \u2202\u03bc) ^ (1 / p) := by\n      simp_rw [Pi.mul_apply, ENNReal.mul_rpow_of_nonneg _ _ hp0]\n    _ \u2264 ((\u222b\u207b a, f a ^ (p * p2) \u2202\u03bc) ^ (1 / p2) *\n        (\u222b\u207b a, g a ^ (p * q2) \u2202\u03bc) ^ (1 / q2)) ^ (1 / p) := by\n      gcongr\n      simp_rw [ENNReal.rpow_mul]\n      exact ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hp2q2 (hf.pow_const _) (hg.pow_const _)\n    _ = (\u222b\u207b a : \u03b1, f a ^ q \u2202\u03bc) ^ (1 / q) * (\u222b\u207b a : \u03b1, g a ^ r \u2202\u03bc) ^ (1 / r) := by\n      rw [@ENNReal.mul_rpow_of_nonneg _ _ (1 / p) (by simp [hp0]), \u2190 ENNReal.rpow_mul, \u2190\n        ENNReal.rpow_mul]\n      have hpp2 : p * p2 = q := by\n        symm\n        rw [mul_comm]\n        rw [\u2190 div_eq_iff hp0_ne]\n      have hpq2 : p * q2 = r := by\n        rw [\u2190 inv_inv r]\n        rw [\u2190 one_div]\n        rw [\u2190 one_div]\n        rw [h_one_div_r]\n        field_simp [p2, q2, Real.conjExponent, hp0_ne, hq0_ne]\n      simp_rw [div_mul_div_comm, mul_one, mul_comm p2, mul_comm q2, hpp2, hpq2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_rpow_add_le_add_eLpNorm_mul_lintegral_rpow_add {p q : \u211d}\n    (hpq : p.HolderConjugate q) {f g : \u03b1 \u2192 \u211d\u22650\u221e} (hf : AEMeasurable f \u03bc)\n    (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc) (hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) :\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2264\n      ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)) *\n        (\u222b\u207b a, (f a + g a) ^ p \u2202\u03bc) ^ (1 / q) := by\n  calc\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2264 \u222b\u207b a, (f + g) a * (f + g) a ^ (p - 1) \u2202\u03bc := by\n      gcongr with a\n      by_cases h_zero : (f + g) a = 0\n      \u00b7 rw [h_zero, ENNReal.zero_rpow_of_pos hpq.pos]\n        exact zero_le _\n      by_cases h_top : (f + g) a = \u22a4\n      \u00b7 rw [h_top, ENNReal.top_rpow_of_pos hpq.sub_one_pos, ENNReal.top_mul_top]\n        exact le_top\n      refine le_of_eq ?_\n      nth_rw 2 [\u2190 ENNReal.rpow_one ((f + g) a)]\n      rw [\u2190 ENNReal.rpow_add _ _ h_zero h_top]\n      rw [add_sub_cancel]\n    _ = (\u222b\u207b a : \u03b1, f a * (f + g) a ^ (p - 1) \u2202\u03bc) + \u222b\u207b a : \u03b1, g a * (f + g) a ^ (p - 1) \u2202\u03bc := by\n      have h_add_m : AEMeasurable (fun a : \u03b1 => (f + g) a ^ (p - 1 : \u211d)) \u03bc :=\n        (hf.add hg).pow_const _\n      have h_add_apply :\n        (\u222b\u207b a : \u03b1, (f + g) a * (f + g) a ^ (p - 1) \u2202\u03bc) =\n          \u222b\u207b a : \u03b1, (f a + g a) * (f + g) a ^ (p - 1) \u2202\u03bc :=\n        rfl\n      simp_rw [h_add_apply, add_mul]\n      rw [lintegral_add_left' (hf.mul h_add_m)]\n    _ \u2264\n        ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)) *\n          (\u222b\u207b a, (f a + g a) ^ p \u2202\u03bc) ^ (1 / q) := by\n      rw [add_mul]\n      gcongr\n      \u00b7 exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top\n      \u00b7 exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.HolderConjugate q\nf g : \u03b1 \u2192 ENNReal\nhf : AEMeasurable f \u03bc\nhf_top : \u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc \u2260 \u22a4\nhg : AEMeasurable g \u03bc\nhg_top : \u222b\u207b (a : \u03b1), g a ^ p \u2202\u03bc \u2260 \u22a4\n\u22a2 \u222b\u207b (a : \u03b1), (f + g) a ^ p \u2202\u03bc \u2264\n    ((\u222b\u207b (a : \u03b1), f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b (a : \u03b1), g a ^ p \u2202\u03bc) ^ (1 / p)) *\n      (\u222b\u207b (a : \u03b1), (f a + g a) ^ p \u2202\u03bc) ^ (1 / q)"}, {"line": "calc\n    (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2264 \u222b\u207b a, (f + g) a * (f + g) a ^ (p - 1) \u2202\u03bc := by\n      gcongr with a\n      by_cases h_zero : (f + g) a = 0\n      \u00b7 rw [h_zero, ENNReal.zero_rpow_of_pos hpq.pos]\n        exact zero_le _\n      by_cases h_top : (f + g) a = \u22a4\n      \u00b7 rw [h_top, ENNReal.top_rpow_of_pos hpq.sub_one_pos, ENNReal.top_mul_top]\n        exact le_top\n      refine le_of_eq ?_\n      nth_rw 2 [\u2190 ENNReal.rpow_one ((f + g) a)]\n      rw [\u2190 ENNReal.rpow_add _ _ h_zero h_top]\n      rw [add_sub_cancel]\n    _ = (\u222b\u207b a : \u03b1, f a * (f + g) a ^ (p - 1) \u2202\u03bc) + \u222b\u207b a : \u03b1, g a * (f + g) a ^ (p - 1) \u2202\u03bc := by\n      have h_add_m : AEMeasurable (fun a : \u03b1 => (f + g) a ^ (p - 1 : \u211d)) \u03bc :=\n        (hf.add hg).pow_const _\n      have h_add_apply :\n        (\u222b\u207b a : \u03b1, (f + g) a * (f + g) a ^ (p - 1) \u2202\u03bc) =\n          \u222b\u207b a : \u03b1, (f a + g a) * (f + g) a ^ (p - 1) \u2202\u03bc :=\n        rfl\n      simp_rw [h_add_apply, add_mul]\n      rw [lintegral_add_left' (hf.mul h_add_m)]\n    _ \u2264\n        ((\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p)) *\n          (\u222b\u207b a, (f a + g a) ^ p \u2202\u03bc) ^ (1 / q) := by\n      rw [add_mul]\n      gcongr\n      \u00b7 exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top\n      \u00b7 exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NNReal.lintegral_mul_le_Lp_mul_Lq {p q : \u211d} (hpq : p.HolderConjugate q) {f g : \u03b1 \u2192 \u211d\u22650}\n    (hf : AEMeasurable f \u03bc) (hg : AEMeasurable g \u03bc) :\n    (\u222b\u207b a, (f * g) a \u2202\u03bc) \u2264\n      (\u222b\u207b a, (f a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b a, (g a : \u211d\u22650\u221e) ^ q \u2202\u03bc) ^ (1 / q) := by\n  simp_rw [Pi.mul_apply, ENNReal.coe_mul]\n  exact ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hpq hf.coe_nnreal_ennreal hg.coe_nnreal_ennreal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/MeanInequalities.lean", "context": {"open": ["NNReal ENNReal MeasureTheory Finset"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.HolderConjugate q\nf g : \u03b1 \u2192 NNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\n\u22a2 \u222b\u207b (a : \u03b1), \u2191((f * g) a) \u2202\u03bc \u2264 (\u222b\u207b (a : \u03b1), \u2191(f a) ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (a : \u03b1), \u2191(g a) ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "simp_rw [Pi.mul_apply, ENNReal.coe_mul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : Measure \u03b1\np q : \u211d\nhpq : p.HolderConjugate q\nf g : \u03b1 \u2192 NNReal\nhf : AEMeasurable f \u03bc\nhg : AEMeasurable g \u03bc\n\u22a2 \u222b\u207b (a : \u03b1), \u2191(f a) * \u2191(g a) \u2202\u03bc \u2264 (\u222b\u207b (a : \u03b1), \u2191(f a) ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (a : \u03b1), \u2191(g a) ^ q \u2202\u03bc) ^ (1 / q)"}, {"line": "exact ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hpq hf.coe_nnreal_ennreal hg.coe_nnreal_ennreal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MeasureTheory.AEStronglyMeasurable.prodMk_left {\u03b3 : Type*} [SFinite \u03bd] [TopologicalSpace \u03b3]\n    {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (hf : AEStronglyMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 x \u2202\u03bc, AEStronglyMeasurable (fun y => f (x, y)) \u03bd := by\n  filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx\n  exact \u27e8fun y \u21a6 hf.mk f (x, y),\n    hf.stronglyMeasurable_mk.comp_measurable measurable_prodMk_left, hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u00b2 : SFinite \u03bd\n\u03b3 : Type u_4\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : TopologicalSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nhf : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, AEStronglyMeasurable (fun y => f (x, y)) \u03bd"}, {"line": "filter_upwards [ae_ae_of_ae_prod hf.ae_eq_mk] with x hx", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : MeasurableSpace \u03b1\ninst\u271d\u00b3 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u00b2 : SFinite \u03bd\n\u03b3 : Type u_4\ninst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : TopologicalSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nhf : AEStronglyMeasurable f (\u03bc.prod \u03bd)\nx : \u03b1\nhx : \u2200\u1d50 (y : \u03b2) \u2202\u03bd, f (x, y) = AEStronglyMeasurable.mk f hf (x, y)\n\u22a2 AEStronglyMeasurable (fun y => f (x, y)) \u03bd"}, {"line": "exact \u27e8fun y \u21a6 hf.mk f (x, y),\n    hf.stronglyMeasurable_mk.comp_measurable measurable_prodMk_left, hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_prod_iff \u2983f : \u03b1 \u00d7 \u03b2 \u2192 E\u2984 (h1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)) :\n    Integrable f (\u03bc.prod \u03bd) \u2194\n      (\u2200\u1d50 x \u2202\u03bc, Integrable (fun y => f (x, y)) \u03bd) \u2227 Integrable (fun x => \u222b y, \u2016f (x, y)\u2016 \u2202\u03bd) \u03bc := by\n  simp [Integrable, h1f, hasFiniteIntegral_prod_iff', h1f.norm.integral_prod_right',\n    h1f.prodMk_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]", "[SFinite \u03bd]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 inst\u271d : SFinite \u03bd\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 Integrable f (\u03bc.prod \u03bd) \u2194\n    (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, Integrable (fun y => f (x, y)) \u03bd) \u2227 Integrable (fun x => \u222b (y : \u03b2), \u2016f (x, y)\u2016 \u2202\u03bd) \u03bc"}, {"line": "simp [Integrable, h1f, hasFiniteIntegral_prod_iff', h1f.norm.integral_prod_right',\n    h1f.prodMk_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2075 : MeasurableSpace \u03b1\ninst\u271d\u2074 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 inst\u271d : SFinite \u03bd\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 HasFiniteIntegral f (\u03bc.prod \u03bd) \u2194\n    ((\u2200\u1d50 (x : \u03b1) \u2202\u03bc, AEStronglyMeasurable (fun y => f (x, y)) \u03bd) \u2227\n        \u2200\u1d50 (x : \u03b1) \u2202\u03bc, HasFiniteIntegral (fun y => f (x, y)) \u03bd) \u2227\n      AEStronglyMeasurable (fun x => \u222b (y : \u03b2), \u2016f (x, y)\u2016 \u2202\u03bd) \u03bc \u2227\n        HasFiniteIntegral (fun x => \u222b (y : \u03b2), \u2016f (x, y)\u2016 \u2202\u03bd) \u03bc"}]}
{"declaration": "theorem integrable_prod_iff' [SFinite \u03bc] \u2983f : \u03b1 \u00d7 \u03b2 \u2192 E\u2984\n    (h1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)) :\n    Integrable f (\u03bc.prod \u03bd) \u2194\n      (\u2200\u1d50 y \u2202\u03bd, Integrable (fun x => f (x, y)) \u03bc) \u2227 Integrable (fun y => \u222b x, \u2016f (x, y)\u2016 \u2202\u03bc) \u03bd := by\n  convert integrable_prod_iff h1f.prod_swap using 1\n  rw [funext fun _ => Function.comp_apply.symm]\n  rw [integrable_swap_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]", "[SFinite \u03bd]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 Integrable f (\u03bc.prod \u03bd) \u2194\n    (\u2200\u1d50 (y : \u03b2) \u2202\u03bd, Integrable (fun x => f (x, y)) \u03bc) \u2227 Integrable (fun y => \u222b (x : \u03b1), \u2016f (x, y)\u2016 \u2202\u03bc) \u03bd"}, {"line": "convert integrable_prod_iff h1f.prod_swap using 1", "tactic_state": "case h.e'_1.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 Integrable f (\u03bc.prod \u03bd) \u2194 Integrable (fun z => f z.swap) (\u03bd.prod \u03bc)\n---\ncase convert_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc\n---\ncase convert_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bd\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc"}, {"line": "rw [funext fun _ => Function.comp_apply.symm]", "tactic_state": "case h.e'_1.a\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 Integrable f (\u03bc.prod \u03bd) \u2194 Integrable (fun x => (f \u2218 Prod.swap) x) (\u03bd.prod \u03bc)\n---\ncase convert_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc\n---\ncase convert_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bd\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc"}, {"line": "rw [integrable_swap_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc\n---\ncase convert_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc\n---\ncase convert_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bd\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\nh1f : AEStronglyMeasurable f (\u03bc.prod \u03bd)\n\u22a2 SFinite \u03bc"}]}
{"declaration": "theorem IntegrableOn.swap [SFinite \u03bc] {f : \u03b1 \u00d7 \u03b2 \u2192 E} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : IntegrableOn f (s \u00d7\u02e2 t) (\u03bc.prod \u03bd)) :\n    IntegrableOn (f \u2218 Prod.swap) (t \u00d7\u02e2 s) (\u03bd.prod \u03bc) := by\n  rw [IntegrableOn] at hf \u22a2\n  rw [\u2190 Measure.prod_restrict] at hf \u22a2\n  exact hf.swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]", "[SFinite \u03bd]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : IntegrableOn f (s \u00d7\u02e2 t) (\u03bc.prod \u03bd)\n\u22a2 IntegrableOn (f \u2218 Prod.swap) (t \u00d7\u02e2 s) (\u03bd.prod \u03bc)"}, {"line": "rw [IntegrableOn] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 t))\n\u22a2 Integrable (f \u2218 Prod.swap) ((\u03bd.prod \u03bc).restrict (t \u00d7\u02e2 s))"}, {"line": "rw [\u2190 Measure.prod_restrict] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.restrict s).prod (\u03bd.restrict t))\n\u22a2 Integrable (f \u2218 Prod.swap) ((\u03bd.restrict t).prod (\u03bc.restrict s))\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.restrict s).prod (\u03bd.restrict t))\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.restrict s).prod (\u03bd.restrict t))\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 t))\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 t))\n\u22a2 SFinite \u03bc"}, {"line": "exact hf.swap", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.restrict s).prod (\u03bd.restrict t))\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.restrict s).prod (\u03bd.restrict t))\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 t))\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2076 : MeasurableSpace \u03b1\ninst\u271d\u2075 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 inst\u271d\u00b9 : SFinite \u03bd\ninst\u271d : SFinite \u03bc\nf : \u03b1 \u00d7 \u03b2 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\nhf : Integrable f ((\u03bc.prod \u03bd).restrict (s \u00d7\u02e2 t))\n\u22a2 SFinite \u03bc"}]}
{"declaration": "theorem setIntegral_prod_swap (s : Set \u03b1) (t : Set \u03b2) (f : \u03b1 \u00d7 \u03b2 \u2192 E) :\n    \u222b (z : \u03b2 \u00d7 \u03b1) in t \u00d7\u02e2 s, f z.swap \u2202\u03bd.prod \u03bc = \u222b (z : \u03b1 \u00d7 \u03b2) in s \u00d7\u02e2 t, f z \u2202\u03bc.prod \u03bd := by\n  rw [\u2190 Measure.prod_restrict]\n  rw [\u2190 Measure.prod_restrict]\n  rw [integral_prod_swap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]", "[SFinite \u03bd]", "[NormedSpace \u211d E]", "[SFinite \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 \u222b (z : \u03b2 \u00d7 \u03b1) in t \u00d7\u02e2 s, f z.swap \u2202\u03bd.prod \u03bc = \u222b (z : \u03b1 \u00d7 \u03b2) in s \u00d7\u02e2 t, f z \u2202\u03bc.prod \u03bd"}, {"line": "rw [\u2190 Measure.prod_restrict]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 \u222b (z : \u03b2 \u00d7 \u03b1), f z.swap \u2202(\u03bd.restrict t).prod (\u03bc.restrict s) = \u222b (z : \u03b1 \u00d7 \u03b2) in s \u00d7\u02e2 t, f z \u2202\u03bc.prod \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bd"}, {"line": "rw [\u2190 Measure.prod_restrict]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 \u222b (z : \u03b2 \u00d7 \u03b1), f z.swap \u2202(\u03bd.restrict t).prod (\u03bc.restrict s) = \u222b (z : \u03b1 \u00d7 \u03b2), f z \u2202(\u03bc.restrict s).prod (\u03bd.restrict t)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bd"}, {"line": "rw [integral_prod_swap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite (\u03bd.restrict t)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite (\u03bc.restrict s)\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bd\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bc\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u00d7 \u03b2 \u2192 E\n\u22a2 SFinite \u03bd"}]}
{"declaration": "theorem integral_fun_snd (f : \u03b2 \u2192 E) : \u222b z, f z.2 \u2202\u03bc.prod \u03bd = \u03bc.real univ \u2022 \u222b y, f y \u2202\u03bd := by\n  simpa using integral_prod_smul (1 : \u03b1 \u2192 \u211d) f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Prod.lean", "context": {"open": ["scoped Topology ENNReal MeasureTheory", "Set Function Real ENNReal", "MeasureTheory MeasurableSpace MeasureTheory.Measure", "TopologicalSpace", "Filter hiding prod_eq map", "Measure", "MeasureTheory.Measure"], "variables": ["{\u03b1 \u03b2 E : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2}", "[NormedAddCommGroup E]", "[NormedSpace \u211d E]", "[SFinite \u03bd]", "[SFinite \u03bd]", "[NormedSpace \u211d E]", "[SFinite \u03bc]", "{E' : Type*} [NormedAddCommGroup E'] [NormedSpace \u211d E']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nE : Type u_3\ninst\u271d\u2077 : MeasurableSpace \u03b1\ninst\u271d\u2076 : MeasurableSpace \u03b2\n\u03bc : Measure \u03b1\n\u03bd : Measure \u03b2\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 inst\u271d\u00b2 : SFinite \u03bd\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : SFinite \u03bc\nf : \u03b2 \u2192 E\n\u22a2 \u222b (z : \u03b1 \u00d7 \u03b2), f z.2 \u2202\u03bc.prod \u03bd = \u03bc.real univ \u2022 \u222b (y : \u03b2), f y \u2202\u03bd"}, {"line": "simpa using integral_prod_smul (1 : \u03b1 \u2192 \u211d) f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setToFun_zero_left {hT : DominatedFinMeasAdditive \u03bc (0 : Set \u03b1 \u2192 E \u2192L[\u211d] F) C} :\n    setToFun \u03bc 0 hT f = 0 := by\n  by_cases hf : Integrable f \u03bc\n  \u00b7 rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left hT _\n  \u00b7 exact setToFun_undef hT hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/SetToL1.lean", "context": {"open": ["scoped Topology NNReal", "Set Filter TopologicalSpace ENNReal", "AEEqFun Lp.simpleFunc Lp", "SimpleFunc", "Classical in"], "variables": ["{\u03b1 E F F' G \ud835\udd5c : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E]", "{G'' G' : Type*}", "[NormedSpace \ud835\udd5c F]", "(\u03b1 E \u03bc \ud835\udd5c)", "{\u03b1 E \u03bc \ud835\udd5c}", "{T T' T'' : Set \u03b1 \u2192 E \u2192L[\u211d] F} {C C' C'' : \u211d}", "{G' G'' : Type*}", "(\ud835\udd5c) [NontriviallyNormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c F] [CompleteSpace F]", "{\ud835\udd5c}", "{G' G'' : Type*}", "[CompleteSpace F] {T T' T'' : Set \u03b1 \u2192 E \u2192L[\u211d] F} {C C' C'' : \u211d} {f g : \u03b1 \u2192 E}", "(\u03bc T)", "{\u03bc T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\n\u22a2 sorry = 0"}, {"line": "by_cases hf : Integrable f \u03bc", "tactic_state": "case pos\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nhf : sorry\n\u22a2 sorry = 0\n---\ncase neg\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nhf : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left hT _", "tactic_state": "case neg\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nhf : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact setToFun_undef hT hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setToFun_zero_left' (hT : DominatedFinMeasAdditive \u03bc T C)\n    (h_zero : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 T s = 0) : setToFun \u03bc T hT f = 0 := by\n  by_cases hf : Integrable f \u03bc\n  \u00b7 rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left' hT h_zero _\n  \u00b7 exact setToFun_undef hT hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/SetToL1.lean", "context": {"open": ["scoped Topology NNReal", "Set Filter TopologicalSpace ENNReal", "AEEqFun Lp.simpleFunc Lp", "SimpleFunc", "Classical in"], "variables": ["{\u03b1 E F F' G \ud835\udd5c : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "[NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E]", "{G'' G' : Type*}", "[NormedSpace \ud835\udd5c F]", "(\u03b1 E \u03bc \ud835\udd5c)", "{\u03b1 E \u03bc \ud835\udd5c}", "{T T' T'' : Set \u03b1 \u2192 E \u2192L[\u211d] F} {C C' C'' : \u211d}", "{G' G'' : Type*}", "(\ud835\udd5c) [NontriviallyNormedField \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c F] [CompleteSpace F]", "{\ud835\udd5c}", "{G' G'' : Type*}", "[CompleteSpace F] {T T' T'' : Set \u03b1 \u2192 E \u2192L[\u211d] F} {C C' C'' : \u211d} {f g : \u03b1 \u2192 E}", "(\u03bc T)", "{\u03bc T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_10\nT : Set \u03b1 \u2192 sorry\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nh_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 sorry < \u22a4 \u2192 T s = 0\n\u22a2 sorry = 0"}, {"line": "by_cases hf : Integrable f \u03bc", "tactic_state": "case pos\n\u03b1 : Type u_10\nT : Set \u03b1 \u2192 sorry\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nh_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 sorry < \u22a4 \u2192 T s = 0\nhf : sorry\n\u22a2 sorry = 0\n---\ncase neg\n\u03b1 : Type u_10\nT : Set \u03b1 \u2192 sorry\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nh_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 sorry < \u22a4 \u2192 T s = 0\nhf : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 rw [setToFun_eq hT hf]; exact L1.setToL1_zero_left' hT h_zero _", "tactic_state": "case neg\n\u03b1 : Type u_10\nT : Set \u03b1 \u2192 sorry\nx\u271d\u00b9 : Sort u_7\nDominatedFinMeasAdditive : x\u271d\u00b9\nx\u271d : Sort u_8\nsetToFun : x\u271d\nhT : sorry\nh_zero : \u2200 (s : Set \u03b1), MeasurableSet s \u2192 sorry < \u22a4 \u2192 T s = 0\nhf : \u00acsorry\n\u22a2 sorry = 0"}, {"line": "\u00b7 exact setToFun_undef hT hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_comm (L : E \u2243L[\ud835\udd5c] F) (\u03c6 : X \u2192 E) : \u222b x, L (\u03c6 x) \u2202\u03bc = L (\u222b x, \u03c6 x \u2202\u03bc) := by\n  have : CompleteSpace E \u2194 CompleteSpace F :=\n    completeSpace_congr (e := L.toEquiv) L.isUniformEmbedding\n  obtain \u27e8_, _\u27e9|\u27e8_, _\u27e9 := iff_iff_and_or_not_and_not.mp this\n  \u00b7 exact L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _\n  \u00b7 simp [integral, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/ContinuousLinearMap.lean", "context": {"open": ["MeasureTheory RCLike", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*} [MeasurableSpace X] {\u03bc : Measure X} {\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "[NormedSpace \u211d F]", "[CompleteSpace F] [NormedSpace \u211d E]", "[CompleteSpace E]", "[CompleteSpace F] [NormedSpace \u211d F] [CompleteSpace E] [NormedSpace \u211d E]", "[NormedSpace \u211d F] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d : MeasurableSpace X\n\u03bc : Measure X\nL : sorry\n\u03c6 : X \u2192 E\n\u22a2 \u222b (x : X), sorry \u2202\u03bc = sorry"}, {"line": "have : CompleteSpace E \u2194 CompleteSpace F :=\n    completeSpace_congr (e := L.toEquiv) L.isUniformEmbedding", "tactic_state": "X : Type u_1\nE : Type u_3\ninst\u271d : MeasurableSpace X\n\u03bc : Measure X\nL : sorry\n\u03c6 : X \u2192 E\nthis : sorry \u2194 sorry\n\u22a2 \u222b (x : X), sorry \u2202\u03bc = sorry"}, {"line": "obtain \u27e8_, _\u27e9|\u27e8_, _\u27e9 := iff_iff_and_or_not_and_not.mp this", "tactic_state": "case inl.intro\nX : Type u_1\nE : Type u_3\ninst\u271d : MeasurableSpace X\n\u03bc : Measure X\nL : sorry\n\u03c6 : X \u2192 E\nthis : sorry \u2194 sorry\nleft\u271d : sorry\nright\u271d : sorry\n\u22a2 \u222b (x : X), sorry \u2202\u03bc = sorry\n---\ncase inr.intro\nX : Type u_1\nE : Type u_3\ninst\u271d : MeasurableSpace X\n\u03bc : Measure X\nL : sorry\n\u03c6 : X \u2192 E\nthis : sorry \u2194 sorry\nleft\u271d : \u00acsorry\nright\u271d : \u00acsorry\n\u22a2 \u222b (x : X), sorry \u2202\u03bc = sorry"}, {"line": "\u00b7 exact L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _", "tactic_state": "case inr.intro\nX : Type u_1\nE : Type u_3\ninst\u271d : MeasurableSpace X\n\u03bc : Measure X\nL : sorry\n\u03c6 : X \u2192 E\nthis : sorry \u2194 sorry\nleft\u271d : \u00acsorry\nright\u271d : \u00acsorry\n\u22a2 \u222b (x : X), sorry \u2202\u03bc = sorry"}, {"line": "\u00b7 simp [integral, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_const_mul_of_integrable {A : Type*} [NonUnitalNormedRing A] [NormedSpace \u211d A]\n    [IsScalarTower \u211d A A] [SMulCommClass \u211d A A] {f : X \u2192 A} (hf : Integrable f \u03bc) {c : A} :\n    \u222b x, c * f x \u2202\u03bc = c * \u222b x, f x \u2202\u03bc := by\n  by_cases hA : CompleteSpace A\n  \u00b7 show \u222b x, ContinuousLinearMap.mul \u211d _ c (f x) \u2202\u03bc = ContinuousLinearMap.mul \u211d _ c (\u222b x, f x \u2202\u03bc)\n    rw [ContinuousLinearMap.integral_comp_comm _ hf]\n  \u00b7 simp [integral, hA]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/ContinuousLinearMap.lean", "context": {"open": ["MeasureTheory RCLike", "scoped ENNReal NNReal", "scoped ContinuousMapZero in", "scoped ComplexConjugate in"], "variables": ["{X Y E F : Type*} [MeasurableSpace X] {\u03bc : Measure X} {\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "[NormedSpace \u211d F]", "[CompleteSpace F] [NormedSpace \u211d E]", "[CompleteSpace E]", "[CompleteSpace F] [NormedSpace \u211d F] [CompleteSpace E] [NormedSpace \u211d E]", "[NormedSpace \u211d F] [NormedSpace \u211d E]", "[TopologicalSpace Y] [CompactSpace Y]", "[NormedSpace \u211d E] [NormedSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\n\u22a2 \u222b (x : X), c * f x \u2202\u03bc = c * \u222b (x : X), f x \u2202\u03bc"}, {"line": "by_cases hA : CompleteSpace A", "tactic_state": "case pos\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : sorry\n\u22a2 \u222b (x : X), c * f x \u2202\u03bc = c * \u222b (x : X), f x \u2202\u03bc\n---\ncase neg\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : \u00acsorry\n\u22a2 \u222b (x : X), c * f x \u2202\u03bc = c * \u222b (x : X), f x \u2202\u03bc"}, {"line": "\u00b7 show \u222b x, ContinuousLinearMap.mul \u211d _ c (f x) \u2202\u03bc = ContinuousLinearMap.mul \u211d _ c (\u222b x, f x \u2202\u03bc)\n    rw [ContinuousLinearMap.integral_comp_comm _ hf]", "tactic_state": "case neg\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : \u00acsorry\n\u22a2 \u222b (x : X), c * f x \u2202\u03bc = c * \u222b (x : X), f x \u2202\u03bc"}, {"line": "\u00b7 simp [integral, hA]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_mul_const_of_integrable {A : Type*} [NonUnitalNormedRing A] [NormedSpace \u211d A]\n    [IsScalarTower \u211d A A] [SMulCommClass \u211d A A] {f : X \u2192 A} (hf : Integrable f \u03bc) {c : A} :\n    \u222b x, f x * c \u2202\u03bc = (\u222b x, f x \u2202\u03bc) * c := by\n  by_cases hA : CompleteSpace A\n  \u00b7 show \u222b x, (ContinuousLinearMap.mul \u211d _).flip c (f x) \u2202\u03bc\n      = (ContinuousLinearMap.mul \u211d _).flip c (\u222b x, f x \u2202\u03bc)\n    rw [ContinuousLinearMap.integral_comp_comm _ hf]\n  \u00b7 simp [integral, hA]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/ContinuousLinearMap.lean", "context": {"open": ["MeasureTheory RCLike", "scoped ENNReal NNReal", "scoped ContinuousMapZero in", "scoped ComplexConjugate in"], "variables": ["{X Y E F : Type*} [MeasurableSpace X] {\u03bc : Measure X} {\ud835\udd5c : Type*} [RCLike \ud835\udd5c]", "[NormedSpace \u211d F]", "[CompleteSpace F] [NormedSpace \u211d E]", "[CompleteSpace E]", "[CompleteSpace F] [NormedSpace \u211d F] [CompleteSpace E] [NormedSpace \u211d E]", "[NormedSpace \u211d F] [NormedSpace \u211d E]", "[TopologicalSpace Y] [CompactSpace Y]", "[NormedSpace \u211d E] [NormedSpace \u211d F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\n\u22a2 \u222b (x : X), f x * c \u2202\u03bc = (\u222b (x : X), f x \u2202\u03bc) * c"}, {"line": "by_cases hA : CompleteSpace A", "tactic_state": "case pos\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : sorry\n\u22a2 \u222b (x : X), f x * c \u2202\u03bc = (\u222b (x : X), f x \u2202\u03bc) * c\n---\ncase neg\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : \u00acsorry\n\u22a2 \u222b (x : X), f x * c \u2202\u03bc = (\u222b (x : X), f x \u2202\u03bc) * c"}, {"line": "\u00b7 show \u222b x, (ContinuousLinearMap.mul \u211d _).flip c (f x) \u2202\u03bc\n      = (ContinuousLinearMap.mul \u211d _).flip c (\u222b x, f x \u2202\u03bc)\n    rw [ContinuousLinearMap.integral_comp_comm _ hf]", "tactic_state": "case neg\nX : Type u_2\ninst\u271d\u2074 : MeasurableSpace X\n\u03bc : Measure X\nA : Type u_1\ninst\u271d\u00b3 : NonUnitalNormedRing A\ninst\u271d\u00b2 : NormedSpace \u211d A\ninst\u271d\u00b9 : IsScalarTower \u211d A A\ninst\u271d : SMulCommClass \u211d A A\nf : X \u2192 A\nhf : Integrable f \u03bc\nc : A\nhA : \u00acsorry\n\u22a2 \u222b (x : X), f x * c \u2202\u03bc = (\u222b (x : X), f x \u2202\u03bc) * c"}, {"line": "\u00b7 simp [integral, hA]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_dirac [MeasurableSpace \u03b1] [MeasurableSingletonClass \u03b1] (f : \u03b1 \u2192 E) (a : \u03b1) :\n    \u222b x, f x \u2202Measure.dirac a = f a :=\n  calc\n    \u222b x, f x \u2202Measure.dirac a = \u222b _, f a \u2202Measure.dirac a := integral_congr_ae <| ae_eq_dirac f\n    _ = f a := by simp [Measure.dirac_apply_of_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Basic.lean", "context": {"open": ["Filter ENNReal EMetric Set TopologicalSpace Topology", "scoped NNReal ENNReal MeasureTheory", "Classical in", "ContinuousLinearMap MeasureTheory.SimpleFunc"], "variables": ["{\u03b1 E F \ud835\udd5c : Type*}", "[NormedAddCommGroup E] [hE : CompleteSpace E] [NontriviallyNormedField \ud835\udd5c]", "[NormedSpace \u211d E]", "{f : \u03b1 \u2192 E} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}", "(\u03b1 G)", "{\u03b1 G}", "{X : Type*} [TopologicalSpace X] [FirstCountableTopology X]", "[PartialOrder E] [IsOrderedAddMonoid E] [OrderedSMul \u211d E] [OrderClosedTopology E]", "{H : Type*} [NormedAddCommGroup H]", "{\u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.11355\n\u03b1\u271d : Type u_1\nE\u271d : Type u_2\nF : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9\u2077 : NormedAddCommGroup E\u271d\nhE\u271d : CompleteSpace E\u271d\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\u271d\nf\u271d : \u03b1\u271d \u2192 E\u271d\nm : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\nG : ?m.13762\nX : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace X\ninst\u271d\u00b9\u00b3 : FirstCountableTopology X\ninst\u271d\u00b9\u00b2 : PartialOrder E\u271d\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\u271d\ninst\u271d\u00b9\u2070 : OrderedSMul \u211d E\u271d\ninst\u271d\u2079 : OrderClosedTopology E\u271d\nH : Type u_6\ninst\u271d\u2078 : NormedAddCommGroup H\n\u03bd : sorry\n\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\nhE : CompleteSpace E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : PartialOrder E\ninst\u271d\u2074 : IsOrderedAddMonoid E\ninst\u271d\u00b3 : OrderedSMul \u211d E\ninst\u271d\u00b2 : OrderClosedTopology E\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\na : \u03b1\n\u22a2 \u222b (x : ?m.13875), f a \u2202sorry = f a"}, {"line": "simp [Measure.dirac_apply_of_mem]", "tactic_state": "Measure : ?m.11355\n\u03b1\u271d : Type u_1\nE\u271d : Type u_2\nF : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b9\u2077 : NormedAddCommGroup E\u271d\nhE\u271d : CompleteSpace E\u271d\ninst\u271d\u00b9\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u2075 : NormedSpace \u211d E\u271d\nf\u271d : \u03b1\u271d \u2192 E\u271d\nm : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\nG : ?m.13762\nX : Type u_5\ninst\u271d\u00b9\u2074 : TopologicalSpace X\ninst\u271d\u00b9\u00b3 : FirstCountableTopology X\ninst\u271d\u00b9\u00b2 : PartialOrder E\u271d\ninst\u271d\u00b9\u00b9 : IsOrderedAddMonoid E\u271d\ninst\u271d\u00b9\u2070 : OrderedSMul \u211d E\u271d\ninst\u271d\u2079 : OrderClosedTopology E\u271d\nH : Type u_6\ninst\u271d\u2078 : NormedAddCommGroup H\n\u03bd : sorry\n\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup E\nhE : CompleteSpace E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : PartialOrder E\ninst\u271d\u2074 : IsOrderedAddMonoid E\ninst\u271d\u00b3 : OrderedSMul \u211d E\ninst\u271d\u00b2 : OrderClosedTopology E\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSingletonClass \u03b1\nf : \u03b1 \u2192 E\na : \u03b1\n\u22a2 \u222b (x : ?m.13875), f a \u2202sorry () = f a"}]}
{"declaration": "theorem setIntegral_const [CompleteSpace E] (c : E) : \u222b _ in s, c \u2202\u03bc = \u03bc.real s \u2022 c := by\n  rw [integral_const]\n  rw [measureReal_restrict_apply_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set \u03b1\u271d\ninst\u271d : CompleteSpace E\nc : E\n\u22a2 \u222b (x : \u03b1\u271d) in s, c \u2202\u03bc = \u03bc.real s \u2022 c"}, {"line": "rw [integral_const]", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set \u03b1\u271d\ninst\u271d : CompleteSpace E\nc : E\n\u22a2 (\u03bc.restrict s).real univ \u2022 c = \u03bc.real s \u2022 c\n---\nE : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set \u03b1\u271d\ninst\u271d : CompleteSpace E\nc : E\n\u22a2 CompleteSpace E"}, {"line": "rw [measureReal_restrict_apply_univ]", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\n\u03b1\u271d : Type u_5\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : Measure \u03b1\u271d\ns : Set \u03b1\u271d\ninst\u271d : CompleteSpace E\nc : E\n\u22a2 CompleteSpace E"}]}
{"declaration": "theorem _root_.MeasurableEmbedding.setIntegral_map {Y} {_ : MeasurableSpace Y} {f : X \u2192 Y}\n    (hf : MeasurableEmbedding f) (g : Y \u2192 E) (s : Set Y) :\n    \u222b y in s, g y \u2202Measure.map f \u03bc = \u222b x in f \u207b\u00b9' s, g (f x) \u2202\u03bc := by\n  rw [hf.restrict_map]\n  rw [hf.integral_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure X\nY : Type u_5\nx\u271d : MeasurableSpace Y\nf : X \u2192 Y\nhf : MeasurableEmbedding f\ng : Y \u2192 E\ns : Set Y\n\u22a2 \u222b (y : Y) in s, g y \u2202Measure.map f \u03bc = \u222b (x : X) in f \u207b\u00b9' s, g (f x) \u2202\u03bc"}, {"line": "rw [hf.restrict_map]", "tactic_state": "X : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03bc : Measure X\nY : Type u_5\nx\u271d : MeasurableSpace Y\nf : X \u2192 Y\nhf : MeasurableEmbedding f\ng : Y \u2192 E\ns : Set Y\n\u22a2 \u222b (y : Y), g y \u2202Measure.map f (\u03bc.restrict (f \u207b\u00b9' s)) = \u222b (x : X) in f \u207b\u00b9' s, g (f x) \u2202\u03bc"}, {"line": "rw [hf.integral_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setIntegral_pos_iff_support_of_nonneg_ae {f : X \u2192 \u211d} (hf : 0 \u2264\u1d50[\u03bc.restrict s] f)\n    (hfi : IntegrableOn f s \u03bc) : (0 < \u222b x in s, f x \u2202\u03bc) \u2194 0 < \u03bc (support f \u2229 s) := by\n  rw [integral_pos_iff_support_of_nonneg_ae hf hfi]\n  rw [Measure.restrict_apply\u2080]\n  rw [support_eq_preimage]\n  exact hfi.aestronglyMeasurable.aemeasurable.nullMeasurable (measurableSet_singleton 0).compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nmX : MeasurableSpace X\ns : Set X\n\u03bc : Measure X\nf : X \u2192 \u211d\nhf : 0 \u2264\u1da0[ae (\u03bc.restrict s)] f\nhfi : IntegrableOn f s \u03bc\n\u22a2 0 < \u222b (x : X) in s, f x \u2202\u03bc \u2194 0 < \u03bc (support f \u2229 s)"}, {"line": "rw [integral_pos_iff_support_of_nonneg_ae hf hfi]", "tactic_state": "X : Type u_1\nmX : MeasurableSpace X\ns : Set X\n\u03bc : Measure X\nf : X \u2192 \u211d\nhf : 0 \u2264\u1da0[ae (\u03bc.restrict s)] f\nhfi : IntegrableOn f s \u03bc\n\u22a2 0 < (\u03bc.restrict s) (support f) \u2194 0 < \u03bc (support f \u2229 s)"}, {"line": "rw [Measure.restrict_apply\u2080]", "tactic_state": "X : Type u_1\nmX : MeasurableSpace X\ns : Set X\n\u03bc : Measure X\nf : X \u2192 \u211d\nhf : 0 \u2264\u1da0[ae (\u03bc.restrict s)] f\nhfi : IntegrableOn f s \u03bc\n\u22a2 NullMeasurableSet (support f) (\u03bc.restrict s)"}, {"line": "rw [support_eq_preimage]", "tactic_state": "X : Type u_1\nmX : MeasurableSpace X\ns : Set X\n\u03bc : Measure X\nf : X \u2192 \u211d\nhf : 0 \u2264\u1da0[ae (\u03bc.restrict s)] f\nhfi : IntegrableOn f s \u03bc\n\u22a2 NullMeasurableSet (f \u207b\u00b9' {0}\u1d9c) (\u03bc.restrict s)"}, {"line": "exact hfi.aestronglyMeasurable.aemeasurable.nullMeasurable (measurableSet_singleton 0).compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setIntegral_ge_of_const_le {c : \u211d} (hs : MeasurableSet s) (h\u03bcs : \u03bc s \u2260 \u221e)\n    (hf : \u2200 x \u2208 s, c \u2264 f x) (hfint : IntegrableOn (fun x : X => f x) s \u03bc) :\n    c * \u03bc.real s \u2264 \u222b x in s, f x \u2202\u03bc := by\n  rw [mul_comm]\n  rw [\u2190 smul_eq_mul]\n  rw [\u2190 setIntegral_const c]\n  exact setIntegral_mono_on (integrableOn_const.2 (Or.inr h\u03bcs.lt_top)) hfint hs hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[PartialOrder X] {x y : X}", "[NoAtoms \u03bc]", "{\u03bc : Measure X} {f g : X \u2192 \u211d} {s t : Set X}", "(hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s \u03bc)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d\u00b9 : Measure ?m.2174\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d g : X\u271d \u2192 \u211d\ns\u271d t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d s\u271d \u03bc\u271d\nhg : IntegrableOn g s\u271d \u03bc\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nc : \u211d\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nhf : \u2200 x \u2208 s, c \u2264 f x\nhfint : IntegrableOn (fun x => f x) s \u03bc\n\u22a2 c * \u03bc.real s \u2264 \u222b (x : X) in s, f x \u2202\u03bc"}, {"line": "rw [mul_comm]", "tactic_state": "\u03bc\u271d\u00b9 : Measure ?m.2174\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d g : X\u271d \u2192 \u211d\ns\u271d t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d s\u271d \u03bc\u271d\nhg : IntegrableOn g s\u271d \u03bc\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nc : \u211d\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nhf : \u2200 x \u2208 s, c \u2264 f x\nhfint : IntegrableOn (fun x => f x) s \u03bc\n\u22a2 \u03bc.real s * c \u2264 \u222b (x : X) in s, f x \u2202\u03bc"}, {"line": "rw [\u2190 smul_eq_mul]", "tactic_state": "\u03bc\u271d\u00b9 : Measure ?m.2174\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d g : X\u271d \u2192 \u211d\ns\u271d t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d s\u271d \u03bc\u271d\nhg : IntegrableOn g s\u271d \u03bc\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nc : \u211d\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nhf : \u2200 x \u2208 s, c \u2264 f x\nhfint : IntegrableOn (fun x => f x) s \u03bc\n\u22a2 \u03bc.real s \u2022 c \u2264 \u222b (x : X) in s, f x \u2202\u03bc"}, {"line": "rw [\u2190 setIntegral_const c]", "tactic_state": "\u03bc\u271d\u00b9 : Measure ?m.2174\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d g : X\u271d \u2192 \u211d\ns\u271d t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d s\u271d \u03bc\u271d\nhg : IntegrableOn g s\u271d \u03bc\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nc : \u211d\nhs : MeasurableSet s\nh\u03bcs : \u03bc s \u2260 \u22a4\nhf : \u2200 x \u2208 s, c \u2264 f x\nhfint : IntegrableOn (fun x => f x) s \u03bc\n\u22a2 \u222b (x : X) in s, c \u2202\u03bc \u2264 \u222b (x : X) in s, f x \u2202\u03bc"}, {"line": "exact setIntegral_mono_on (integrableOn_const.2 (Or.inr h\u03bcs.lt_top)) hfint hs hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setIntegral_le_nonneg {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f \u03bc) : \u222b x in s, f x \u2202\u03bc \u2264 \u222b x in {y | 0 \u2264 f y}, f x \u2202\u03bc := by\n  rw [\u2190 integral_indicator hs]\n  rw [\u2190     integral_indicator (stronglyMeasurable_const.measurableSet_le hf)]\n  exact\n    integral_mono (hfi.indicator hs)\n      (hfi.indicator (stronglyMeasurable_const.measurableSet_le hf))\n      (indicator_le_indicator_nonneg s f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[PartialOrder X] {x y : X}", "[NoAtoms \u03bc]", "{\u03bc : Measure X} {f g : X \u2192 \u211d} {s t : Set X}", "(hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s \u03bc)", "{\u03bc : Measure X} {f : X \u2192 \u211d} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X) in s, f x \u2202\u03bc \u2264 \u222b (x : X) in {y | 0 \u2264 f y}, f x \u2202\u03bc"}, {"line": "rw [\u2190 integral_indicator hs]", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X), s.indicator f x \u2202\u03bc \u2264 \u222b (x : X) in {y | 0 \u2264 f y}, f x \u2202\u03bc"}, {"line": "rw [\u2190     integral_indicator (stronglyMeasurable_const.measurableSet_le hf)]", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X), s.indicator f x \u2202\u03bc \u2264 \u222b (x : X), {a | 0 \u2264 f a}.indicator f x \u2202\u03bc"}, {"line": "exact\n    integral_mono (hfi.indicator hs)\n      (hfi.indicator (stronglyMeasurable_const.measurableSet_le hf))\n      (indicator_le_indicator_nonneg s f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setIntegral_nonpos_le {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f \u03bc) : \u222b x in {y | f y \u2264 0}, f x \u2202\u03bc \u2264 \u222b x in s, f x \u2202\u03bc := by\n  rw [\u2190 integral_indicator hs]\n  rw [\u2190     integral_indicator (hf.measurableSet_le stronglyMeasurable_const)]\n  exact\n    integral_mono (hfi.indicator (hf.measurableSet_le stronglyMeasurable_const))\n      (hfi.indicator hs) (indicator_nonpos_le_indicator s f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[PartialOrder X] {x y : X}", "[NoAtoms \u03bc]", "{\u03bc : Measure X} {f g : X \u2192 \u211d} {s t : Set X}", "(hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s \u03bc)", "{\u03bc : Measure X} {f : X \u2192 \u211d} {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X) in {y | f y \u2264 0}, f x \u2202\u03bc \u2264 \u222b (x : X) in s, f x \u2202\u03bc"}, {"line": "rw [\u2190 integral_indicator hs]", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X) in {y | f y \u2264 0}, f x \u2202\u03bc \u2264 \u222b (x : X), s.indicator f x \u2202\u03bc"}, {"line": "rw [\u2190     integral_indicator (hf.measurableSet_le stronglyMeasurable_const)]", "tactic_state": "\u03bc\u271d\u00b2 : Measure ?m.3216\nX\u271d : Type u_1\nY : Type u_2\nE : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9 : NoAtoms \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b9\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b9\n\u03bc\u271d : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\nX : Type u_1\nmX : MeasurableSpace X\ninst\u271d : PartialOrder X\n\u03bc : Measure X\nf : X \u2192 \u211d\ns : Set X\nhs : MeasurableSet s\nhf : StronglyMeasurable f\nhfi : Integrable f \u03bc\n\u22a2 \u222b (x : X), {a | f a \u2264 0}.indicator f x \u2202\u03bc \u2264 \u222b (x : X), s.indicator f x \u2202\u03bc"}, {"line": "exact\n    integral_mono (hfi.indicator (hf.measurableSet_le stronglyMeasurable_const))\n      (hfi.indicator hs) (indicator_nonpos_le_indicator s f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_of_summable_norm_restrict {f : C(X, E)} {s : \u03b9 \u2192 Compacts X}\n    (hf : Summable fun i : \u03b9 => \u2016f.restrict (s i)\u2016 * \u03bc.real (s i))\n    (hs : \u22c3 i : \u03b9, \u2191(s i) = (univ : Set X)) : Integrable f \u03bc := by\n  simpa only [hs,integrableOn_univ] using integrableOn_iUnion_of_summable_norm_restrict hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[PartialOrder X] {x y : X}", "[NoAtoms \u03bc]", "{\u03bc : Measure X} {f g : X \u2192 \u211d} {s t : Set X}", "(hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s \u03bc)", "{\u03bc : Measure X} {f : X \u2192 \u211d} {s : Set X}", "{\u03b9 : Type*} [Countable \u03b9] {\u03bc : Measure X} [NormedAddCommGroup E]", "[TopologicalSpace X] [BorelSpace X] [T2Space X] [IsLocallyFiniteMeasure \u03bc]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.5573\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2078 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2077 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2076 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2075 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf\u271d : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9\u271d : Type u_5\ninst\u271d\u00b9\u2074 : Countable \u03b9\u271d\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b2 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b9 : BorelSpace X\u271d\ninst\u271d\u00b9\u2070 : T2Space X\u271d\ninst\u271d\u2079 : IsLocallyFiniteMeasure \u03bc\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03b9 : Type u_5\ninst\u271d\u2075 : Countable \u03b9\n\u03bc : Measure X\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : BorelSpace X\ninst\u271d\u00b9 : T2Space X\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nf : C(X, E)\ns : \u03b9 \u2192 Compacts X\nhf : Summable fun i => \u2016ContinuousMap.restrict (\u2191(s i)) f\u2016 * \u03bc.real \u2191(s i)\nhs : \u22c3 i, \u2191(s i) = univ\n\u22a2 Integrable (\u21d1f) \u03bc"}, {"line": "simpa only [hs,integrableOn_univ] using integrableOn_iUnion_of_summable_norm_restrict hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_Lp_toLp_restrict_le (s : Set X) (f : Lp E p \u03bc) :\n    \u2016((Lp.memLp f).restrict s).toLp f\u2016 \u2264 \u2016f\u2016 := by\n  rw [Lp.norm_def]\n  rw [Lp.norm_def]\n  rw [eLpNorm_congr_ae (MemLp.coeFn_toLp _)]\n  refine ENNReal.toReal_mono (Lp.eLpNorm_ne_top _) ?_\n  exact eLpNorm_mono_measure _ Measure.restrict_le_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Bochner/Set.lean", "context": {"open": ["Filter Function MeasureTheory RCLike Set TopologicalSpace Topology", "scoped ENNReal NNReal"], "variables": ["{X Y E F : Type*}", "{mX : MeasurableSpace X}", "[NormedAddCommGroup E] [NormedSpace \u211d E]", "[PartialOrder X] {x y : X}", "[NoAtoms \u03bc]", "{\u03bc : Measure X} {f g : X \u2192 \u211d} {s t : Set X}", "(hf : IntegrableOn f s \u03bc) (hg : IntegrableOn g s \u03bc)", "{\u03bc : Measure X} {f : X \u2192 \u211d} {s : Set X}", "{\u03b9 : Type*} [Countable \u03b9] {\u03bc : Measure X} [NormedAddCommGroup E]", "[TopologicalSpace X] [BorelSpace X] [T2Space X] [IsLocallyFiniteMeasure \u03bc]", "[NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.6879\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2079 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2078 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2077 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2076 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : Countable \u03b9\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b3 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b2 : BorelSpace X\u271d\ninst\u271d\u00b9\u00b9 : T2Space X\u271d\ninst\u271d\u00b9\u2070 : IsLocallyFiniteMeasure \u03bc\u271d\ninst\u271d\u2079 : NormedAddCommGroup E\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03bc : Measure X\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : NormedAddCommGroup E\np : ENNReal\ns : Set X\nf : \u21a5(Lp E p \u03bc)\n\u22a2 \u2016MemLp.toLp \u2191\u2191f \u22ef\u2016 \u2264 \u2016f\u2016"}, {"line": "rw [Lp.norm_def]", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.6879\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2079 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2078 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2077 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2076 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : Countable \u03b9\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b3 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b2 : BorelSpace X\u271d\ninst\u271d\u00b9\u00b9 : T2Space X\u271d\ninst\u271d\u00b9\u2070 : IsLocallyFiniteMeasure \u03bc\u271d\ninst\u271d\u2079 : NormedAddCommGroup E\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03bc : Measure X\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : NormedAddCommGroup E\np : ENNReal\ns : Set X\nf : \u21a5(Lp E p \u03bc)\n\u22a2 (eLpNorm (\u2191\u2191(MemLp.toLp \u2191\u2191f \u22ef)) p (\u03bc.restrict s)).toReal \u2264 \u2016f\u2016"}, {"line": "rw [Lp.norm_def]", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.6879\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2079 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2078 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2077 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2076 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : Countable \u03b9\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b3 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b2 : BorelSpace X\u271d\ninst\u271d\u00b9\u00b9 : T2Space X\u271d\ninst\u271d\u00b9\u2070 : IsLocallyFiniteMeasure \u03bc\u271d\ninst\u271d\u2079 : NormedAddCommGroup E\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03bc : Measure X\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : NormedAddCommGroup E\np : ENNReal\ns : Set X\nf : \u21a5(Lp E p \u03bc)\n\u22a2 (eLpNorm (\u2191\u2191(MemLp.toLp \u2191\u2191f \u22ef)) p (\u03bc.restrict s)).toReal \u2264 (eLpNorm (\u2191\u2191f) p \u03bc).toReal"}, {"line": "rw [eLpNorm_congr_ae (MemLp.coeFn_toLp _)]", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.6879\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2079 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2078 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2077 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2076 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : Countable \u03b9\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b3 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b2 : BorelSpace X\u271d\ninst\u271d\u00b9\u00b9 : T2Space X\u271d\ninst\u271d\u00b9\u2070 : IsLocallyFiniteMeasure \u03bc\u271d\ninst\u271d\u2079 : NormedAddCommGroup E\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03bc : Measure X\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : NormedAddCommGroup E\np : ENNReal\ns : Set X\nf : \u21a5(Lp E p \u03bc)\n\u22a2 (eLpNorm (\u2191\u2191f) p (\u03bc.restrict s)).toReal \u2264 (eLpNorm (\u2191\u2191f) p \u03bc).toReal"}, {"line": "refine ENNReal.toReal_mono (Lp.eLpNorm_ne_top _) ?_", "tactic_state": "\u03bc\u271d\u00b3 : Measure ?m.6879\nX\u271d : Type u_1\nY : Type u_2\nE\u271d : Type u_3\nF : Type u_4\nmX\u271d : MeasurableSpace X\u271d\ninst\u271d\u00b9\u2079 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2078 : NormedSpace \u211d E\u271d\ninst\u271d\u00b9\u2077 : PartialOrder X\u271d\nx y : X\u271d\ninst\u271d\u00b9\u2076 : NoAtoms \u03bc\u271d\u00b3\n\u03bc\u271d\u00b2 : Measure X\u271d\nf\u271d\u00b9 g : X\u271d \u2192 \u211d\ns\u271d\u00b9 t : Set X\u271d\nhf : IntegrableOn f\u271d\u00b9 s\u271d\u00b9 \u03bc\u271d\u00b2\nhg : IntegrableOn g s\u271d\u00b9 \u03bc\u271d\u00b2\n\u03bc\u271d\u00b9 : Measure X\u271d\nf\u271d : X\u271d \u2192 \u211d\ns\u271d : Set X\u271d\n\u03b9 : Type u_5\ninst\u271d\u00b9\u2075 : Countable \u03b9\n\u03bc\u271d : Measure X\u271d\ninst\u271d\u00b9\u2074 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9\u00b3 : TopologicalSpace X\u271d\ninst\u271d\u00b9\u00b2 : BorelSpace X\u271d\ninst\u271d\u00b9\u00b9 : T2Space X\u271d\ninst\u271d\u00b9\u2070 : IsLocallyFiniteMeasure \u03bc\u271d\ninst\u271d\u2079 : NormedAddCommGroup E\u271d\nX : Type u_1\nE : Type u_3\nmX : MeasurableSpace X\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : NormedSpace \u211d E\ninst\u271d\u2076 : PartialOrder X\n\u03bc : Measure X\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : BorelSpace X\ninst\u271d\u00b2 : T2Space X\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : NormedAddCommGroup E\np : ENNReal\ns : Set X\nf : \u21a5(Lp E p \u03bc)\n\u22a2 eLpNorm (\u2191\u2191f) p (\u03bc.restrict s) \u2264 eLpNorm (\u2191\u2191f) p \u03bc"}, {"line": "exact eLpNorm_mono_measure _ Measure.restrict_le_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_mul_deriv'' {f f' g : \u211d \u2192 \u211d} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b u in f a..f b, g u := by\n  simpa [mul_comm] using integral_comp_smul_deriv'' hf hff' hf' hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/IntegrationByParts.lean", "context": {"open": ["MeasureTheory Set", "scoped Topology Interval"], "variables": ["{a b : \u211d}", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] {u v u' v' : \u211d \u2192 A}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf f' g : \u211d \u2192 \u211d\nhf : ContinuousOn f (uIcc a b)\nhff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x\nhf' : ContinuousOn f' (uIcc a b)\nhg : ContinuousOn g (f '' uIcc a b)\n\u22a2 \u222b (x : \u211d) in a..b, (g \u2218 f) x * f' x = \u222b (u : \u211d) in f a..f b, g u"}, {"line": "simpa [mul_comm] using integral_comp_smul_deriv'' hf hff' hf' hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_mul_deriv' {f f' g : \u211d \u2192 \u211d} (h : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (h' : ContinuousOn f' (uIcc a b)) (hg : ContinuousOn g (f '' [[a, b]])) :\n    (\u222b x in a..b, (g \u2218 f) x * f' x) = \u222b x in f a..f b, g x := by\n  simpa [mul_comm] using integral_comp_smul_deriv' h h' hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/IntegrationByParts.lean", "context": {"open": ["MeasureTheory Set", "scoped Topology Interval"], "variables": ["{a b : \u211d}", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] {u v u' v' : \u211d \u2192 A}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf f' g : \u211d \u2192 \u211d\nh : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x\nh' : ContinuousOn f' (uIcc a b)\nhg : ContinuousOn g (f '' uIcc a b)\n\u22a2 \u222b (x : \u211d) in a..b, (g \u2218 f) x * f' x = \u222b (x : \u211d) in f a..f b, g x"}, {"line": "simpa [mul_comm] using integral_comp_smul_deriv' h h' hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_deriv_comp_mul_deriv' {f f' g g' : \u211d \u2192 \u211d} (hf : ContinuousOn f [[a, b]])\n    (hff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x)\n    (hf' : ContinuousOn f' [[a, b]]) (hg : ContinuousOn g [[f a, f b]])\n    (hgg' : \u2200 x \u2208 Ioo (min (f a) (f b)) (max (f a) (f b)), HasDerivWithinAt g (g' x) (Ioi x) x)\n    (hg' : ContinuousOn g' (f '' [[a, b]])) :\n    (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a := by\n  simpa [mul_comm] using integral_deriv_comp_smul_deriv' hf hff' hf' hg hgg' hg'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/IntegrationByParts.lean", "context": {"open": ["MeasureTheory Set", "scoped Topology Interval"], "variables": ["{a b : \u211d}", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] {u v u' v' : \u211d \u2192 A}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf f' g g' : \u211d \u2192 \u211d\nhf : ContinuousOn f (uIcc a b)\nhff' : \u2200 x \u2208 Ioo (min a b) (max a b), HasDerivWithinAt f (f' x) (Ioi x) x\nhf' : ContinuousOn f' (uIcc a b)\nhg : ContinuousOn g (uIcc (f a) (f b))\nhgg' : \u2200 x \u2208 Ioo (min (f a) (f b)) (max (f a) (f b)), HasDerivWithinAt g (g' x) (Ioi x) x\nhg' : ContinuousOn g' (f '' uIcc a b)\n\u22a2 \u222b (x : \u211d) in a..b, (g' \u2218 f) x * f' x = (g \u2218 f) b - (g \u2218 f) a"}, {"line": "simpa [mul_comm] using integral_deriv_comp_smul_deriv' hf hff' hf' hg hgg' hg'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_deriv_comp_mul_deriv {f f' g g' : \u211d \u2192 \u211d}\n    (hf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n    (hg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n    (hg' : Continuous g') : (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a := by\n  simpa [mul_comm] using integral_deriv_comp_smul_deriv hf hg hf' hg'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/IntegrationByParts.lean", "context": {"open": ["MeasureTheory Set", "scoped Topology Interval"], "variables": ["{a b : \u211d}", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] {u v u' v' : \u211d \u2192 A}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f f' : \u211d \u2192 \u211d} {g g' : \u211d \u2192 E}", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf f' g g' : \u211d \u2192 \u211d\nhf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x\nhg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)\nhf' : ContinuousOn f' (uIcc a b)\nhg' : Continuous g'\n\u22a2 \u222b (x : \u211d) in a..b, (g' \u2218 f) x * f' x = (g \u2218 f) b - (g \u2218 f) a"}, {"line": "simpa [mul_comm] using integral_deriv_comp_smul_deriv hf hg hf' hg'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_iff : IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (\u0399 a b) \u03bc := by\n  rw [uIoc_eq_union]\n  rw [integrableOn_union]\n  rw [IntervalIntegrable]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (uIoc a b) \u03bc"}, {"line": "rw [uIoc_eq_union]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ioc a b \u222a Ioc b a) \u03bc"}, {"line": "rw [integrableOn_union]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ioc a b) \u03bc \u2227 IntegrableOn f (Ioc b a) \u03bc"}, {"line": "rw [IntervalIntegrable]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_iff_integrableOn_Ioc_of_le (hab : a \u2264 b) :\n    IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ioc a b) \u03bc := by\n  rw [intervalIntegrable_iff]\n  rw [uIoc_of_le hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\nhab : a \u2264 b\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ioc a b) \u03bc"}, {"line": "rw [intervalIntegrable_iff]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\nhab : a \u2264 b\n\u22a2 IntegrableOn f (uIoc a b) \u03bc \u2194 IntegrableOn f (Ioc a b) \u03bc"}, {"line": "rw [uIoc_of_le hab]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_iff' [NoAtoms \u03bc] :\n    IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (uIcc a b) \u03bc := by\n  rw [intervalIntegrable_iff]\n  rw [\u2190 Icc_min_max]\n  rw [uIoc]\n  rw [integrableOn_Icc_iff_integrableOn_Ioc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (uIcc a b) \u03bc"}, {"line": "rw [intervalIntegrable_iff]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (uIoc a b) \u03bc \u2194 IntegrableOn f (uIcc a b) \u03bc"}, {"line": "rw [\u2190 Icc_min_max]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (uIoc a b) \u03bc \u2194 IntegrableOn f (Icc (min a b) (max a b)) \u03bc"}, {"line": "rw [uIoc]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (Ioc (min a b) (max a b)) \u03bc \u2194 IntegrableOn f (Icc (min a b) (max a b)) \u03bc"}, {"line": "rw [integrableOn_Icc_iff_integrableOn_Ioc]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 NoAtoms \u03bc"}]}
{"declaration": "theorem intervalIntegrable_iff_integrableOn_Icc_of_le {f : \u211d \u2192 E} {a b : \u211d} (hab : a \u2264 b)\n    {\u03bc : Measure \u211d} [NoAtoms \u03bc] : IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Icc a b) \u03bc := by\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hab]\n  rw [integrableOn_Icc_iff_integrableOn_Ioc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhab : a \u2264 b\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Icc a b) \u03bc"}, {"line": "rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hab]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhab : a \u2264 b\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 IntegrableOn f (Ioc a b) \u03bc \u2194 IntegrableOn f (Icc a b) \u03bc"}, {"line": "rw [integrableOn_Icc_iff_integrableOn_Ioc]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhab : a \u2264 b\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\n\u22a2 NoAtoms \u03bc"}]}
{"declaration": "theorem intervalIntegrable_iff_integrableOn_Ico_of_le [NoAtoms \u03bc] (hab : a \u2264 b) :\n    IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ico a b) \u03bc := by\n  rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab]\n  rw [integrableOn_Icc_iff_integrableOn_Ico]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\nhab : a \u2264 b\n\u22a2 IntervalIntegrable f \u03bc a b \u2194 IntegrableOn f (Ico a b) \u03bc"}, {"line": "rw [intervalIntegrable_iff_integrableOn_Icc_of_le hab]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\nhab : a \u2264 b\n\u22a2 IntegrableOn f (Icc a b) \u03bc \u2194 IntegrableOn f (Ico a b) \u03bc\n---\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\nhab : a \u2264 b\n\u22a2 NoAtoms \u03bc"}, {"line": "rw [integrableOn_Icc_iff_integrableOn_Ico]", "tactic_state": "E : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\nhab : a \u2264 b\n\u22a2 NoAtoms \u03bc\n---\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\ninst\u271d : NoAtoms \u03bc\nhab : a \u2264 b\n\u22a2 NoAtoms \u03bc"}]}
{"declaration": "theorem intervalIntegrable_const_iff {c : E} :\n    IntervalIntegrable (fun _ => c) \u03bc a b \u2194 c = 0 \u2228 \u03bc (\u0399 a b) < \u221e := by\n  simp only [intervalIntegrable_iff]\n  simp only [integrableOn_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\na b : \u211d\n\u03bc : Measure \u211d\nc : E\n\u22a2 IntervalIntegrable (fun x => c) \u03bc a b \u2194 c = 0 \u2228 \u03bc (uIoc a b) < \u22a4"}, {"line": "simp only [intervalIntegrable_iff]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\na b : \u211d\n\u03bc : Measure \u211d\nc : E\n\u22a2 IntegrableOn (fun x => c) (uIoc a b) \u03bc \u2194 c = 0 \u2228 \u03bc (uIoc a b) < \u22a4"}, {"line": "simp only [integrableOn_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem refl : IntervalIntegrable f \u03bc a a := by constructor <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na : \u211d\n\u03bc : Measure \u211d\n\u22a2 IntervalIntegrable f \u03bc a a"}, {"line": "constructor <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trans_iff (h : b \u2208 [[a, c]]) :\n    IntervalIntegrable f \u03bc a c \u2194 IntervalIntegrable f \u03bc a b \u2227 IntervalIntegrable f \u03bc b c := by\n  simp only [intervalIntegrable_iff]\n  simp only [\u2190 integrableOn_union]\n  simp only [uIoc_union_uIoc h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b c : \u211d\n\u03bc : Measure \u211d\nh : b \u2208 uIcc a c\n\u22a2 IntervalIntegrable f \u03bc a c \u2194 IntervalIntegrable f \u03bc a b \u2227 IntervalIntegrable f \u03bc b c"}, {"line": "simp only [intervalIntegrable_iff]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b c : \u211d\n\u03bc : Measure \u211d\nh : b \u2208 uIcc a c\n\u22a2 IntegrableOn f (uIoc a c) \u03bc \u2194 IntegrableOn f (uIoc a b) \u03bc \u2227 IntegrableOn f (uIoc b c) \u03bc"}, {"line": "simp only [\u2190 integrableOn_union]", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b c : \u211d\n\u03bc : Measure \u211d\nh : b \u2208 uIcc a c\n\u22a2 IntegrableOn f (uIoc a c) \u03bc \u2194 IntegrableOn f (uIoc a b \u222a uIoc b c) \u03bc"}, {"line": "simp only [uIoc_union_uIoc h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trans_iterate_Ico {a : \u2115 \u2192 \u211d} {m n : \u2115} (hmn : m \u2264 n)\n    (hint : \u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a <| k + 1)) :\n    IntervalIntegrable f \u03bc (a m) (a n) := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  \u00b7 simp\n  \u00b7 intro p hp IH h\n    exact (IH fun k hk => h k (Ico_subset_Ico_right p.le_succ hk)).trans (h p (by simp [hp]))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\nhint : \u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))\n\u22a2 IntervalIntegrable f \u03bc (a m) (a n)"}, {"line": "revert hint", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 (\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a n)"}, {"line": "refine Nat.le_induction ?_ ?_ n hmn", "tactic_state": "case refine_1\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 (\u2200 k \u2208 Ico m m, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a m)\n---\ncase refine_2\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 \u2200 (n : \u2115),\n    m \u2264 n \u2192\n      ((\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a n)) \u2192\n        (\u2200 k \u2208 Ico m (n + 1), IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a (n + 1))"}, {"line": "\u00b7 simp", "tactic_state": "case refine_2\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 \u2200 (n : \u2115),\n    m \u2264 n \u2192\n      ((\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a n)) \u2192\n        (\u2200 k \u2208 Ico m (n + 1), IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192 IntervalIntegrable f \u03bc (a m) (a (n + 1))"}, {"line": "\u00b7 intro p hp IH h\n    exact (IH fun k hk => h k (Ico_subset_Ico_right p.le_succ hk)).trans (h p (by simp [hp]))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_continuousOn {f g : \u211d \u2192 A} (hf : IntervalIntegrable f \u03bc a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => f x * g x) \u03bc a b := by\n  rw [intervalIntegrable_iff] at hf \u22a2\n  exact hf.mul_continuousOn_of_subset hg measurableSet_Ioc isCompact_uIcc Ioc_subset_Icc_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d : NormedRing A\na b : \u211d\n\u03bc : Measure \u211d\nf g : \u211d \u2192 A\nhf : IntervalIntegrable f \u03bc a b\nhg : ContinuousOn g (uIcc a b)\n\u22a2 IntervalIntegrable (fun x => f x * g x) \u03bc a b"}, {"line": "rw [intervalIntegrable_iff] at hf \u22a2", "tactic_state": "A : Type u_5\ninst\u271d : NormedRing A\na b : \u211d\n\u03bc : Measure \u211d\nf g : \u211d \u2192 A\nhf : IntegrableOn f (uIoc a b) \u03bc\nhg : ContinuousOn g (uIcc a b)\n\u22a2 IntegrableOn (fun x => f x * g x) (uIoc a b) \u03bc"}, {"line": "exact hf.mul_continuousOn_of_subset hg measurableSet_Ioc isCompact_uIcc Ioc_subset_Icc_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousOn_mul {f g : \u211d \u2192 A} (hf : IntervalIntegrable f \u03bc a b)\n    (hg : ContinuousOn g [[a, b]]) : IntervalIntegrable (fun x => g x * f x) \u03bc a b := by\n  rw [intervalIntegrable_iff] at hf \u22a2\n  exact hf.continuousOn_mul_of_subset hg isCompact_uIcc measurableSet_Ioc Ioc_subset_Icc_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d : NormedRing A\na b : \u211d\n\u03bc : Measure \u211d\nf g : \u211d \u2192 A\nhf : IntervalIntegrable f \u03bc a b\nhg : ContinuousOn g (uIcc a b)\n\u22a2 IntervalIntegrable (fun x => g x * f x) \u03bc a b"}, {"line": "rw [intervalIntegrable_iff] at hf \u22a2", "tactic_state": "A : Type u_5\ninst\u271d : NormedRing A\na b : \u211d\n\u03bc : Measure \u211d\nf g : \u211d \u2192 A\nhf : IntegrableOn f (uIoc a b) \u03bc\nhg : ContinuousOn g (uIcc a b)\n\u22a2 IntegrableOn (fun x => g x * f x) (uIoc a b) \u03bc"}, {"line": "exact hf.continuousOn_mul_of_subset hg isCompact_uIcc measurableSet_Ioc Ioc_subset_Icc_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_const {\ud835\udd5c : Type*} {f : \u211d \u2192 \ud835\udd5c} [NormedField \ud835\udd5c] (h : IntervalIntegrable f \u03bc a b)\n    (c : \ud835\udd5c) : IntervalIntegrable (fun x => f x / c) \u03bc a b := by\n  simpa only [div_eq_mul_inv] using mul_const h c\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u03bc : Measure \u211d\n\ud835\udd5c : Type u_6\nf : \u211d \u2192 \ud835\udd5c\ninst\u271d : NormedField \ud835\udd5c\nh : IntervalIntegrable f \u03bc a b\nc : \ud835\udd5c\n\u22a2 IntervalIntegrable (fun x => f x / c) \u03bc a b"}, {"line": "simpa only [div_eq_mul_inv] using mul_const h c\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_add_right (hf : IntervalIntegrable f volume a b) (c : \u211d) :\n    IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c) := by\n  wlog h : a \u2264 b generalizing a b\n  \u00b7 exact IntervalIntegrable.symm (this hf.symm (le_of_not_le h))\n  rw [intervalIntegrable_iff'] at hf \u22a2\n  have A : MeasurableEmbedding fun x => x + c :=\n    (Homeomorph.addRight c).isClosedEmbedding.measurableEmbedding\n  rw [\u2190 map_add_right_eq_self volume c] at hf\n  convert (MeasurableEmbedding.integrableOn_map_iff A).mp hf using 1\n  rw [preimage_add_const_uIcc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\n\u22a2 IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c)"}, {"line": "wlog h : a \u2264 b generalizing a b", "tactic_state": "case inr\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\nthis :\n  \u2200 {a b : \u211d}, IntervalIntegrable f volume a b \u2192 a \u2264 b \u2192 IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c)\nh : \u00aca \u2264 b\n\u22a2 IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c)\n---\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntervalIntegrable f volume a b\nh : a \u2264 b\n\u22a2 IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c)"}, {"line": "\u00b7 exact IntervalIntegrable.symm (this hf.symm (le_of_not_le h))", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntervalIntegrable f volume a b\nh : a \u2264 b\n\u22a2 IntervalIntegrable (fun x => f (x + c)) volume (a - c) (b - c)"}, {"line": "rw [intervalIntegrable_iff'] at hf \u22a2", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntegrableOn f (uIcc a b) volume\nh : a \u2264 b\n\u22a2 IntegrableOn (fun x => f (x + c)) (uIcc (a - c) (b - c)) volume"}, {"line": "have A : MeasurableEmbedding fun x => x + c :=\n    (Homeomorph.addRight c).isClosedEmbedding.measurableEmbedding", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntegrableOn f (uIcc a b) volume\nh : a \u2264 b\nA : MeasurableEmbedding fun x => x + c\n\u22a2 IntegrableOn (fun x => f (x + c)) (uIcc (a - c) (b - c)) volume"}, {"line": "rw [\u2190 map_add_right_eq_self volume c] at hf", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntegrableOn f (uIcc a b) (Measure.map (fun x => x + c) volume)\nh : a \u2264 b\nA : MeasurableEmbedding fun x => x + c\n\u22a2 IntegrableOn (fun x => f (x + c)) (uIcc (a - c) (b - c)) volume"}, {"line": "convert (MeasurableEmbedding.integrableOn_map_iff A).mp hf using 1", "tactic_state": "case h.e'_7\nE : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na\u271d b\u271d c a b : \u211d\nhf : IntegrableOn f (uIcc a b) (Measure.map (fun x => x + c) volume)\nh : a \u2264 b\nA : MeasurableEmbedding fun x => x + c\n\u22a2 uIcc (a - c) (b - c) = (fun x => x + c) \u207b\u00b9' uIcc a b"}, {"line": "rw [preimage_add_const_uIcc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_add_left (hf : IntervalIntegrable f volume a b) (c : \u211d) :\n    IntervalIntegrable (fun x => f (c + x)) volume (a - c) (b - c) := by\n  simpa only [add_comm] using IntervalIntegrable.comp_add_right hf c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\n\u22a2 IntervalIntegrable (fun x => f (c + x)) volume (a - c) (b - c)"}, {"line": "simpa only [add_comm] using IntervalIntegrable.comp_add_right hf c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_sub_right (hf : IntervalIntegrable f volume a b) (c : \u211d) :\n    IntervalIntegrable (fun x => f (x - c)) volume (a + c) (b + c) := by\n  simpa only [sub_neg_eq_add] using IntervalIntegrable.comp_add_right hf (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\n\u22a2 IntervalIntegrable (fun x => f (x - c)) volume (a + c) (b + c)"}, {"line": "simpa only [sub_neg_eq_add] using IntervalIntegrable.comp_add_right hf (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_sub_left (hf : IntervalIntegrable f volume a b) (c : \u211d) :\n    IntervalIntegrable (fun x => f (c - x)) volume (c - a) (c - b) := by\n  simpa only [neg_sub,\u2190 sub_eq_add_neg] using iff_comp_neg.mp (hf.comp_add_left c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d : NormedAddCommGroup E\nf : \u211d \u2192 E\na b : \u211d\nhf : IntervalIntegrable f volume a b\nc : \u211d\n\u22a2 IntervalIntegrable (fun x => f (c - x)) volume (c - a) (c - b)"}, {"line": "simpa only [neg_sub,\u2190 sub_eq_add_neg] using iff_comp_neg.mp (hf.comp_add_left c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.intervalIntegrable {u : \u211d \u2192 E} {a b : \u211d} (hu : MonotoneOn u (uIcc a b)) :\n    IntervalIntegrable u \u03bc a b := by\n  rw [intervalIntegrable_iff]\n  exact (hu.integrableOn_isCompact isCompact_uIcc).mono_set Ioc_subset_Icc_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : ConditionallyCompleteLinearOrder E\nu : \u211d \u2192 E\na b : \u211d\nhu : MonotoneOn u (uIcc a b)\n\u22a2 IntervalIntegrable u \u03bc a b"}, {"line": "rw [intervalIntegrable_iff]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\n\u03bc : Measure \u211d\ninst\u271d\u00b9 : IsLocallyFiniteMeasure \u03bc\ninst\u271d : ConditionallyCompleteLinearOrder E\nu : \u211d \u2192 E\na b : \u211d\nhu : MonotoneOn u (uIcc a b)\n\u22a2 IntegrableOn u (uIoc a b) \u03bc"}, {"line": "exact (hu.integrableOn_isCompact isCompact_uIcc).mono_set Ioc_subset_Icc_self", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_zero : (\u222b _ in a..b, (0 : E) \u2202\u03bc) = 0 := by simp [intervalIntegral]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\n\u03bc : Measure \u211d\n\u22a2 \u222b (x : \u211d) in a..b, 0 \u2202\u03bc = 0"}, {"line": "simp [intervalIntegral]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_of_le (h : a \u2264 b) : \u222b x in a..b, f x \u2202\u03bc = \u222b x in Ioc a b, f x \u2202\u03bc := by\n  simp [intervalIntegral, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh : a \u2264 b\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = \u222b (x : \u211d) in Ioc a b, f x \u2202\u03bc"}, {"line": "simp [intervalIntegral, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegral_eq_integral_uIoc (f : \u211d \u2192 E) (a b : \u211d) (\u03bc : Measure \u211d) :\n    \u222b x in a..b, f x \u2202\u03bc = (if a \u2264 b then 1 else -1 : \u211d) \u2022 \u222b x in \u0399 a b, f x \u2202\u03bc := by\n  split_ifs with h\n  \u00b7 simp only [integral_of_le h, uIoc_of_le h, one_smul]\n  \u00b7 simp only [integral_of_ge (not_le.1 h).le, uIoc_of_ge (not_le.1 h).le, neg_one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = (if a \u2264 b then 1 else -1) \u2022 \u222b (x : \u211d) in uIoc a b, f x \u2202\u03bc"}, {"line": "split_ifs with h", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\nh : a \u2264 b\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = 1 \u2022 \u222b (x : \u211d) in uIoc a b, f x \u2202\u03bc\n---\ncase neg\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\nh : \u00aca \u2264 b\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = -1 \u2022 \u222b (x : \u211d) in uIoc a b, f x \u2202\u03bc"}, {"line": "\u00b7 simp only [integral_of_le h, uIoc_of_le h, one_smul]", "tactic_state": "case neg\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\n\u03bc : Measure \u211d\nh : \u00aca \u2264 b\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = -1 \u2022 \u222b (x : \u211d) in uIoc a b, f x \u2202\u03bc"}, {"line": "\u00b7 simp only [integral_of_ge (not_le.1 h).le, uIoc_of_ge (not_le.1 h).le, neg_one_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_integral_min_max (f : \u211d \u2192 E) :\n    \u2016\u222b x in min a b..max a b, f x \u2202\u03bc\u2016 = \u2016\u222b x in a..b, f x \u2202\u03bc\u2016 := by\n  cases le_total a b <;> simp [*, integral_symm a b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\n\u03bc : Measure \u211d\nf : \u211d \u2192 E\n\u22a2 \u2016\u222b (x : \u211d) in min a b..max a b, f x \u2202\u03bc\u2016 = \u2016\u222b (x : \u211d) in a..b, f x \u2202\u03bc\u2016"}, {"line": "cases le_total a b <;> simp [*, integral_symm a b]", "tactic_state": "case inr\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\n\u03bc : Measure \u211d\nf : \u211d \u2192 E\nh\u271d : b \u2264 a\n\u22a2 \u2016\u222b (x : \u211d) in b..a, f x \u2202\u03bc\u2016 = \u2016\u222b (x : \u211d) in a..b, f x \u2202\u03bc\u2016"}]}
{"declaration": "theorem integral_mul_const {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (r : \ud835\udd5c) (f : \u211d \u2192 \ud835\udd5c) :\n    \u222b x in a..b, f x * r \u2202\u03bc = (\u222b x in a..b, f x \u2202\u03bc) * r := by\n  simpa only [mul_comm r] using integral_const_mul r f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u03bc : Measure \u211d\n\ud835\udd5c : Type u_6\ninst\u271d : RCLike \ud835\udd5c\nr : \ud835\udd5c\nf : \u211d \u2192 \ud835\udd5c\n\u22a2 \u222b (x : \u211d) in a..b, f x * r \u2202\u03bc = (\u222b (x : \u211d) in a..b, f x \u2202\u03bc) * r"}, {"line": "simpa only [mul_comm r] using integral_const_mul r f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_div {\ud835\udd5c : Type*} [RCLike \ud835\udd5c] (r : \ud835\udd5c) (f : \u211d \u2192 \ud835\udd5c) :\n    \u222b x in a..b, f x / r \u2202\u03bc = (\u222b x in a..b, f x \u2202\u03bc) / r := by\n  simpa only [div_eq_mul_inv] using integral_mul_const r\u207b\u00b9 f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u03bc : Measure \u211d\n\ud835\udd5c : Type u_6\ninst\u271d : RCLike \ud835\udd5c\nr : \ud835\udd5c\nf : \u211d \u2192 \ud835\udd5c\n\u22a2 \u222b (x : \u211d) in a..b, f x / r \u2202\u03bc = (\u222b (x : \u211d) in a..b, f x \u2202\u03bc) / r"}, {"line": "simpa only [div_eq_mul_inv] using integral_mul_const r\u207b\u00b9 f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_integral_comp_mul_right (c) :\n    (c \u2022 \u222b x in a..b, f (x * c)) = \u222b x in a * c..b * c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\n\u22a2 c \u2022 \u222b (x : \u211d) in a..b, f (x * c) = \u222b (x : \u211d) in a * c..b * c, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_right]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f 0 = 0"}]}
{"declaration": "theorem integral_comp_mul_left (hc : c \u2260 0) :\n    (\u222b x in a..b, f (c * x)) = c\u207b\u00b9 \u2022 \u222b x in c * a..c * b, f x := by\n  simpa only [mul_comm c] using integral_comp_mul_right f hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\n\u22a2 \u222b (x : \u211d) in a..b, f (c * x) = c\u207b\u00b9 \u2022 \u222b (x : \u211d) in c * a..c * b, f x"}, {"line": "simpa only [mul_comm c] using integral_comp_mul_right f hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_integral_comp_mul_left (c) :\n    (c \u2022 \u222b x in a..b, f (c * x)) = \u222b x in c * a..c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\n\u22a2 c \u2022 \u222b (x : \u211d) in a..b, f (c * x) = \u222b (x : \u211d) in c * a..c * b, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_left]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f 0 = 0"}]}
{"declaration": "theorem integral_comp_div (hc : c \u2260 0) :\n    (\u222b x in a..b, f (x / c)) = c \u2022 \u222b x in a / c..b / c, f x := by\n  simpa only [inv_inv] using integral_comp_mul_right f (inv_ne_zero hc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\n\u22a2 \u222b (x : \u211d) in a..b, f (x / c) = c \u2022 \u222b (x : \u211d) in a / c..b / c, f x"}, {"line": "simpa only [inv_inv] using integral_comp_mul_right f (inv_ne_zero hc)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_smul_integral_comp_div (c) :\n    (c\u207b\u00b9 \u2022 \u222b x in a..b, f (x / c)) = \u222b x in a / c..b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\n\u22a2 c\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f (x / c) = \u222b (x : \u211d) in a / c..b / c, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_div]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f 0 = 0"}]}
{"declaration": "theorem smul_integral_comp_mul_add (c d) :\n    (c \u2022 \u222b x in a..b, f (c * x + d)) = \u222b x in c * a + d..c * b + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c \u2022 \u222b (x : \u211d) in a..b, f (c * x + d) = \u222b (x : \u211d) in c * a + d..c * b + d, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_add]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f d = 0"}]}
{"declaration": "theorem smul_integral_comp_add_mul (c d) :\n    (c \u2022 \u222b x in a..b, f (d + c * x)) = \u222b x in d + c * a..d + c * b, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c \u2022 \u222b (x : \u211d) in a..b, f (d + c * x) = \u222b (x : \u211d) in d + c * a..d + c * b, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_add_mul]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f d = 0"}]}
{"declaration": "theorem integral_comp_div_add (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (x / c + d)) = c \u2022 \u222b x in a / c + d..b / c + d, f x := by\n  simpa only [div_eq_inv_mul,inv_inv] using integral_comp_mul_add f (inv_ne_zero hc) d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (x / c + d) = c \u2022 \u222b (x : \u211d) in a / c + d..b / c + d, f x"}, {"line": "simpa only [div_eq_inv_mul,inv_inv] using integral_comp_mul_add f (inv_ne_zero hc) d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_smul_integral_comp_div_add (c d) :\n    (c\u207b\u00b9 \u2022 \u222b x in a..b, f (x / c + d)) = \u222b x in a / c + d..b / c + d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f (x / c + d) = \u222b (x : \u211d) in a / c + d..b / c + d, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_div_add]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f d = 0"}]}
{"declaration": "theorem integral_comp_add_div (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (d + x / c)) = c \u2022 \u222b x in d + a / c..d + b / c, f x := by\n  simpa only [div_eq_inv_mul,inv_inv] using integral_comp_add_mul f (inv_ne_zero hc) d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (d + x / c) = c \u2022 \u222b (x : \u211d) in d + a / c..d + b / c, f x"}, {"line": "simpa only [div_eq_inv_mul,inv_inv] using integral_comp_add_mul f (inv_ne_zero hc) d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_smul_integral_comp_add_div (c d) :\n    (c\u207b\u00b9 \u2022 \u222b x in a..b, f (d + x / c)) = \u222b x in d + a / c..d + b / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_add_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f (d + x / c) = \u222b (x : \u211d) in d + a / c..d + b / c, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_add_div]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f d = 0"}]}
{"declaration": "theorem integral_comp_mul_sub (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (c * x - d)) = c\u207b\u00b9 \u2022 \u222b x in c * a - d..c * b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (c * x - d) = c\u207b\u00b9 \u2022 \u222b (x : \u211d) in c * a - d..c * b - d, f x"}, {"line": "simpa only [sub_eq_add_neg] using integral_comp_mul_add f hc (-d)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_integral_comp_mul_sub (c d) :\n    (c \u2022 \u222b x in a..b, f (c * x - d)) = \u222b x in c * a - d..c * b - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c \u2022 \u222b (x : \u211d) in a..b, f (c * x - d) = \u222b (x : \u211d) in c * a - d..c * b - d, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_mul_sub]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f (-d) = 0"}]}
{"declaration": "theorem integral_comp_div_sub (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (x / c - d)) = c \u2022 \u222b x in a / c - d..b / c - d, f x := by\n  simpa only [div_eq_inv_mul,inv_inv] using integral_comp_mul_sub f (inv_ne_zero hc) d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (x / c - d) = c \u2022 \u222b (x : \u211d) in a / c - d..b / c - d, f x"}, {"line": "simpa only [div_eq_inv_mul,inv_inv] using integral_comp_mul_sub f (inv_ne_zero hc) d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_smul_integral_comp_div_sub (c d) :\n    (c\u207b\u00b9 \u2022 \u222b x in a..b, f (x / c - d)) = \u222b x in a / c - d..b / c - d, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_div_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f (x / c - d) = \u222b (x : \u211d) in a / c - d..b / c - d, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_div_sub]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f (-d) = 0"}]}
{"declaration": "theorem integral_comp_sub_div (hc : c \u2260 0) (d) :\n    (\u222b x in a..b, f (d - x / c)) = c \u2022 \u222b x in d - b / c..d - a / c, f x := by\n  simpa only [div_eq_inv_mul,inv_inv] using integral_comp_sub_mul f (inv_ne_zero hc) d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b c : \u211d\nf : \u211d \u2192 E\nhc : c \u2260 0\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (d - x / c) = c \u2022 \u222b (x : \u211d) in d - b / c..d - a / c, f x"}, {"line": "simpa only [div_eq_inv_mul,inv_inv] using integral_comp_sub_mul f (inv_ne_zero hc) d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_smul_integral_comp_sub_div (c d) :\n    (c\u207b\u00b9 \u2022 \u222b x in a..b, f (d - x / c)) = \u222b x in d - b / c..d - a / c, f x := by\n  by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\n\u22a2 c\u207b\u00b9 \u2022 \u222b (x : \u211d) in a..b, f (d - x / c) = \u222b (x : \u211d) in d - b / c..d - a / c, f x"}, {"line": "by_cases hc : c = 0 <;> simp [hc, integral_comp_sub_div]", "tactic_state": "case pos\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nc d : \u211d\nhc : c = 0\n\u22a2 0 \u2022 \u222b (x : \u211d) in a..b, f d = 0"}]}
{"declaration": "theorem integral_comp_sub_right (d) : (\u222b x in a..b, f (x - d)) = \u222b x in a - d..b - d, f x := by\n  simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (x - d) = \u222b (x : \u211d) in a - d..b - d, f x"}, {"line": "simpa only [sub_eq_add_neg] using integral_comp_add_right f (-d)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_sub_left (d) : (\u222b x in a..b, f (d - x)) = \u222b x in d - b..d - a, f x := by\n  simpa only [one_mul,one_smul,inv_one] using integral_comp_sub_mul f one_ne_zero d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\nd : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, f (d - x) = \u222b (x : \u211d) in d - b..d - a, f x"}, {"line": "simpa only [one_mul,one_smul,inv_one] using integral_comp_sub_mul f one_ne_zero d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_comp_neg : (\u222b x in a..b, f (-x)) = \u222b x in -b..-a, f x := by\n  simpa only [zero_sub] using integral_comp_sub_left f 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\na b : \u211d\nf : \u211d \u2192 E\n\u22a2 \u222b (x : \u211d) in a..b, f (-x) = \u222b (x : \u211d) in -b..-a, f x"}, {"line": "simpa only [zero_sub] using integral_comp_sub_left f 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_congr {a b : \u211d} (h : EqOn f g [[a, b]]) :\n    \u222b x in a..b, f x \u2202\u03bc = \u222b x in a..b, g x \u2202\u03bc := by\n  rcases le_total a b with hab | hab <;>\n    simpa [hab, integral_of_le, integral_of_ge] using\n      setIntegral_congr_fun measurableSet_Ioc (h.mono Ioc_subset_Icc_self)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf g : \u211d \u2192 E\n\u03bc : Measure \u211d\na b : \u211d\nh : EqOn f g (uIcc a b)\n\u22a2 \u222b (x : \u211d) in a..b, f x \u2202\u03bc = \u222b (x : \u211d) in a..b, g x \u2202\u03bc"}, {"line": "rcases le_total a b with hab | hab <;>\n    simpa [hab, integral_of_le, integral_of_ge] using\n      setIntegral_congr_fun measurableSet_Ioc (h.mono Ioc_subset_Icc_self)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_integral_adjacent_intervals_Ico {a : \u2115 \u2192 \u211d} {m n : \u2115} (hmn : m \u2264 n)\n    (hint : \u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a <| k + 1)) :\n    \u2211 k \u2208 Finset.Ico m n, \u222b x in a k..a <| k + 1, f x \u2202\u03bc = \u222b x in a m..a n, f x \u2202\u03bc := by\n  revert hint\n  refine Nat.le_induction ?_ ?_ n hmn\n  \u00b7 simp\n  \u00b7 intro p hmp IH h\n    rw [Finset.sum_Ico_succ_top hmp]\n    rw [IH]\n    rw [integral_add_adjacent_intervals]\n    \u00b7 refine IntervalIntegrable.trans_iterate_Ico hmp fun k hk => h k ?_\n      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk\n    \u00b7 apply h\n      simp [hmp]\n    \u00b7 intro k hk\n      exact h _ (Ico_subset_Ico_right p.le_succ hk)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\nhint : \u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))\n\u22a2 \u2211 k \u2208 Finset.Ico m n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a n, f x \u2202\u03bc"}, {"line": "revert hint", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 (\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n    \u2211 k \u2208 Finset.Ico m n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a n, f x \u2202\u03bc"}, {"line": "refine Nat.le_induction ?_ ?_ n hmn", "tactic_state": "case refine_1\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 (\u2200 k \u2208 Ico m m, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n    \u2211 k \u2208 Finset.Ico m m, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a m, f x \u2202\u03bc\n---\ncase refine_2\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 \u2200 (n : \u2115),\n    m \u2264 n \u2192\n      ((\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n          \u2211 k \u2208 Finset.Ico m n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a n, f x \u2202\u03bc) \u2192\n        (\u2200 k \u2208 Ico m (n + 1), IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n          \u2211 k \u2208 Finset.Ico m (n + 1), \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a (n + 1), f x \u2202\u03bc"}, {"line": "\u00b7 simp", "tactic_state": "case refine_2\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 \u2200 (n : \u2115),\n    m \u2264 n \u2192\n      ((\u2200 k \u2208 Ico m n, IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n          \u2211 k \u2208 Finset.Ico m n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a n, f x \u2202\u03bc) \u2192\n        (\u2200 k \u2208 Ico m (n + 1), IntervalIntegrable f \u03bc (a k) (a (k + 1))) \u2192\n          \u2211 k \u2208 Finset.Ico m (n + 1), \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a m..a (n + 1), f x \u2202\u03bc"}, {"line": "\u00b7 intro p hmp IH h\n    rw [Finset.sum_Ico_succ_top hmp]\n    rw [IH]\n    rw [integral_add_adjacent_intervals]\n    \u00b7 refine IntervalIntegrable.trans_iterate_Ico hmp fun k hk => h k ?_\n      exact (Ico_subset_Ico le_rfl (Nat.le_succ _)) hk\n    \u00b7 apply h\n      simp [hmp]\n    \u00b7 intro k hk\n      exact h _ (Ico_subset_Ico_right p.le_succ hk)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_integral_adjacent_intervals {a : \u2115 \u2192 \u211d} {n : \u2115}\n    (hint : \u2200 k < n, IntervalIntegrable f \u03bc (a k) (a <| k + 1)) :\n    \u2211 k \u2208 Finset.range n, \u222b x in a k..a <| k + 1, f x \u2202\u03bc = \u222b x in (a 0)..(a n), f x \u2202\u03bc := by\n  rw [\u2190 Nat.Ico_zero_eq_range]\n  exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nn : \u2115\nhint : \u2200 k < n, IntervalIntegrable f \u03bc (a k) (a (k + 1))\n\u22a2 \u2211 k \u2208 Finset.range n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a 0 ..a n, f x \u2202\u03bc"}, {"line": "rw [\u2190 Nat.Ico_zero_eq_range]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\na : \u2115 \u2192 \u211d\nn : \u2115\nhint : \u2200 k < n, IntervalIntegrable f \u03bc (a k) (a (k + 1))\n\u22a2 \u2211 k \u2208 Finset.Ico 0 n, \u222b (x : \u211d) in a k..a (k + 1), f x \u2202\u03bc = \u222b (x : \u211d) in a 0 ..a n, f x \u2202\u03bc"}, {"line": "exact sum_integral_adjacent_intervals_Ico (zero_le n) fun k hk => hint k hk.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_Iic_add_Ioi (h_left : IntegrableOn f (Iic b) \u03bc)\n    (h_right : IntegrableOn f (Ioi b) \u03bc) :\n    (\u222b x in Iic b, f x \u2202\u03bc) + (\u222b x in Ioi b, f x \u2202\u03bc) = \u222b (x : \u211d), f x \u2202\u03bc := by\n  convert (setIntegral_union (Iic_disjoint_Ioi <| Eq.le rfl) measurableSet_Ioi h_left h_right).symm\n  rw [Iic_union_Ioi]\n  rw [Measure.restrict_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iic b) \u03bc\nh_right : IntegrableOn f (Ioi b) \u03bc\n\u22a2 \u222b (x : \u211d) in Iic b, f x \u2202\u03bc + \u222b (x : \u211d) in Ioi b, f x \u2202\u03bc = \u222b (x : \u211d), f x \u2202\u03bc"}, {"line": "convert (setIntegral_union (Iic_disjoint_Ioi <| Eq.le rfl) measurableSet_Ioi h_left h_right).symm", "tactic_state": "case h.e'_3.h.e'_6\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iic b) \u03bc\nh_right : IntegrableOn f (Ioi b) \u03bc\n\u22a2 \u03bc = \u03bc.restrict (Iic b \u222a Ioi b)"}, {"line": "rw [Iic_union_Ioi]", "tactic_state": "case h.e'_3.h.e'_6\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iic b) \u03bc\nh_right : IntegrableOn f (Ioi b) \u03bc\n\u22a2 \u03bc = \u03bc.restrict univ"}, {"line": "rw [Measure.restrict_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_Iio_add_Ici (h_left : IntegrableOn f (Iio b) \u03bc)\n    (h_right : IntegrableOn f (Ici b) \u03bc) :\n    (\u222b x in Iio b, f x \u2202\u03bc) + (\u222b x in Ici b, f x \u2202\u03bc) = \u222b (x : \u211d), f x \u2202\u03bc := by\n  convert (setIntegral_union (Iio_disjoint_Ici <| Eq.le rfl) measurableSet_Ici h_left h_right).symm\n  rw [Iio_union_Ici]\n  rw [Measure.restrict_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iio b) \u03bc\nh_right : IntegrableOn f (Ici b) \u03bc\n\u22a2 \u222b (x : \u211d) in Iio b, f x \u2202\u03bc + \u222b (x : \u211d) in Ici b, f x \u2202\u03bc = \u222b (x : \u211d), f x \u2202\u03bc"}, {"line": "convert (setIntegral_union (Iio_disjoint_Ici <| Eq.le rfl) measurableSet_Ici h_left h_right).symm", "tactic_state": "case h.e'_3.h.e'_6\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iio b) \u03bc\nh_right : IntegrableOn f (Ici b) \u03bc\n\u22a2 \u03bc = \u03bc.restrict (Iio b \u222a Ici b)"}, {"line": "rw [Iio_union_Ici]", "tactic_state": "case h.e'_3.h.e'_6\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nb : \u211d\nf : \u211d \u2192 E\n\u03bc : Measure \u211d\nh_left : IntegrableOn f (Iio b) \u03bc\nh_right : IntegrableOn f (Ici b) \u03bc\n\u22a2 \u03bc = \u03bc.restrict univ"}, {"line": "rw [Measure.restrict_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.MeasureTheory.Integrable.hasSum_intervalIntegral_comp_add_int (hfi : Integrable f) :\n    HasSum (fun n : \u2124 => \u222b x in (0 : \u211d)..(1 : \u211d), f (x + n)) (\u222b x, f x) := by\n  simpa only [integral_comp_add_right,zero_add,add_comm (1 : \u211d)] using\n    hfi.hasSum_intervalIntegral 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Basic.lean", "context": {"open": ["MeasureTheory Set Filter Function", "scoped Topology Filter ENNReal Interval NNReal", "ContinuousLinearMap"], "variables": ["{\u03b9 \ud835\udd5c E F A : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{f : \u211d \u2192 E} {a b c d : \u211d} {\u03bc \u03bd : Measure \u211d}", "[NormedRing A] {f g : \u211d \u2192 E} {a b : \u211d} {\u03bc : Measure \u211d}", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc]", "{\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] [ConditionallyCompleteLinearOrder E]", "{f : \u211d \u2192 E}", "[NormedSpace \u211d E]", "{a b : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{a b : \u211d} {\u03bc : Measure \u211d} {f : \u211d \u2192 E}", "[RCLike \ud835\udd5c] [NormedSpace \ud835\udd5c E] [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "[NormedSpace \u211d F] [CompleteSpace F]", "{a b c d : \u211d} (f : \u211d \u2192 E)", "{a b c d : \u211d} {f g : \u211d \u2192 E} {\u03bc : Measure \u211d}", "{f g : \u211d \u2192 \u211d} {a b : \u211d} {\u03bc : Measure \u211d}", "(hab : a \u2264 b) (hf : IntervalIntegrable f \u03bc a b) (hg : IntervalIntegrable g \u03bc a b)", "{\u03bc : Measure \u211d} {f : \u211d \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ConditionallyCompleteLinearOrder E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\nhfi : Integrable f volume\n\u22a2 HasSum (fun n => \u222b (x : \u211d) in 0 ..1, f (x + \u2191n)) (\u222b (x : \u211d), f x)"}, {"line": "simpa only [integral_comp_add_right,zero_add,add_comm (1 : \u211d)] using\n    hfi.hasSum_intervalIntegral 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right\n    (hab : IntervalIntegrable f \u03bc a b) (hmeas : StronglyMeasurableAtFilter f lb' \u03bc)\n    (hf : Tendsto f (lb' \u2293 ae \u03bc) (\ud835\udcdd c)) (hu : Tendsto u lt lb) (hv : Tendsto v lt lb) :\n    (fun t => ((\u222b x in a..v t, f x \u2202\u03bc) - \u222b x in a..u t, f x \u2202\u03bc) - \u222b _ in u t..v t, c \u2202\u03bc) =o[lt]\n      fun t => \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc := by\n  simpa using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab stronglyMeasurableAt_bot\n      hmeas ((tendsto_bot : Tendsto _ \u22a5 (\ud835\udcdd (0 : E))).mono_left inf_le_left) hf\n      (tendsto_const_pure : Tendsto _ _ (pure a)) tendsto_const_pure hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nc : E\nlb lb' : Filter \u211d\nlt : Filter \u03b9\n\u03bc : Measure \u211d\nu v : \u03b9 \u2192 \u211d\nhab : IntervalIntegrable f \u03bc a b\nhmeas : StronglyMeasurableAtFilter f lb' \u03bc\nhf : Tendsto f (lb' \u2293 ae \u03bc) (nhds c)\nhu : Tendsto u lt lb\nhv : Tendsto v lt lb\n\u22a2 (fun t => \u222b (x : \u211d) in a..v t, f x \u2202\u03bc - \u222b (x : \u211d) in a..u t, f x \u2202\u03bc - \u222b (x : \u211d) in u t..v t, c \u2202\u03bc) =o[lt] fun t =>\n    \u222b (x : \u211d) in u t..v t, 1 \u2202\u03bc"}, {"line": "simpa using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab stronglyMeasurableAt_bot\n      hmeas ((tendsto_bot : Tendsto _ \u22a5 (\ud835\udcdd (0 : E))).mono_left inf_le_left) hf\n      (tendsto_const_pure : Tendsto _ _ (pure a)) tendsto_const_pure hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left\n    (hab : IntervalIntegrable f \u03bc a b) (hmeas : StronglyMeasurableAtFilter f la' \u03bc)\n    (hf : Tendsto f (la' \u2293 ae \u03bc) (\ud835\udcdd c)) (hu : Tendsto u lt la) (hv : Tendsto v lt la) :\n    (fun t => ((\u222b x in v t..b, f x \u2202\u03bc) - \u222b x in u t..b, f x \u2202\u03bc) + \u222b _ in u t..v t, c \u2202\u03bc) =o[lt]\n      fun t => \u222b _ in u t..v t, (1 : \u211d) \u2202\u03bc := by\n  simpa using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab hmeas\n      stronglyMeasurableAt_bot hf ((tendsto_bot : Tendsto _ \u22a5 (\ud835\udcdd (0 : E))).mono_left inf_le_left) hu\n      hv (tendsto_const_pure : Tendsto _ _ (pure b)) tendsto_const_pure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nc : E\nla la' : Filter \u211d\nlt : Filter \u03b9\n\u03bc : Measure \u211d\nu v : \u03b9 \u2192 \u211d\nhab : IntervalIntegrable f \u03bc a b\nhmeas : StronglyMeasurableAtFilter f la' \u03bc\nhf : Tendsto f (la' \u2293 ae \u03bc) (nhds c)\nhu : Tendsto u lt la\nhv : Tendsto v lt la\n\u22a2 (fun t => \u222b (x : \u211d) in v t..b, f x \u2202\u03bc - \u222b (x : \u211d) in u t..b, f x \u2202\u03bc + \u222b (x : \u211d) in u t..v t, c \u2202\u03bc) =o[lt] fun t =>\n    \u222b (x : \u211d) in u t..v t, 1 \u2202\u03bc"}, {"line": "simpa using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab hmeas\n      stronglyMeasurableAt_bot hf ((tendsto_bot : Tendsto _ \u22a5 (\ud835\udcdd (0 : E))).mono_left inf_le_left) hu\n      hv (tendsto_const_pure : Tendsto _ _ (pure b)) tendsto_const_pure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae\n    (hab : IntervalIntegrable f volume a b) (hmeas_a : StronglyMeasurableAtFilter f la')\n    (hmeas_b : StronglyMeasurableAtFilter f lb') (ha_lim : Tendsto f (la' \u2293 ae volume) (\ud835\udcdd ca))\n    (hb_lim : Tendsto f (lb' \u2293 ae volume) (\ud835\udcdd cb)) (hua : Tendsto ua lt la) (hva : Tendsto va lt la)\n    (hub : Tendsto ub lt lb) (hvb : Tendsto vb lt lb) :\n    (fun t =>\n        ((\u222b x in va t..vb t, f x) - \u222b x in ua t..ub t, f x) -\n          ((vb t - ub t) \u2022 cb - (va t - ua t) \u2022 ca)) =o[lt]\n      fun t => \u2016va t - ua t\u2016 + \u2016vb t - ub t\u2016 := by\n  simpa [integral_const]\n    using measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab hmeas_a hmeas_b\n      ha_lim hb_lim hua hva hub hvb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nca cb : E\nla la' lb lb' : Filter \u211d\nlt : Filter \u03b9\ninst\u271d : CompleteSpace E\nua va ub vb : \u03b9 \u2192 \u211d\nhab : IntervalIntegrable f volume a b\nhmeas_a : StronglyMeasurableAtFilter f la' volume\nhmeas_b : StronglyMeasurableAtFilter f lb' volume\nha_lim : Tendsto f (la' \u2293 ae volume) (nhds ca)\nhb_lim : Tendsto f (lb' \u2293 ae volume) (nhds cb)\nhua : Tendsto ua lt la\nhva : Tendsto va lt la\nhub : Tendsto ub lt lb\nhvb : Tendsto vb lt lb\n\u22a2 (fun t =>\n      ((\u222b (x : \u211d) in va t..vb t, f x) - \u222b (x : \u211d) in ua t..ub t, f x) -\n        ((vb t - ub t) \u2022 cb - (va t - ua t) \u2022 ca)) =o[lt]\n    fun t => \u2016va t - ua t\u2016 + \u2016vb t - ub t\u2016"}, {"line": "simpa [integral_const]\n    using measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae hab hmeas_a hmeas_b\n      ha_lim hb_lim hua hva hub hvb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right\n    (hab : IntervalIntegrable f volume a b) (hmeas : StronglyMeasurableAtFilter f lb')\n    (hf : Tendsto f (lb' \u2293 ae volume) (\ud835\udcdd c)) (hu : Tendsto u lt lb) (hv : Tendsto v lt lb) :\n    (fun t => ((\u222b x in a..v t, f x) - \u222b x in a..u t, f x) - (v t - u t) \u2022 c) =o[lt] (v - u) := by\n  simpa only [integral_const,smul_eq_mul,mul_one] using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right hab hmeas hf hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nc : E\nlb lb' : Filter \u211d\nlt : Filter \u03b9\ninst\u271d : CompleteSpace E\nu v : \u03b9 \u2192 \u211d\nhab : IntervalIntegrable f volume a b\nhmeas : StronglyMeasurableAtFilter f lb' volume\nhf : Tendsto f (lb' \u2293 ae volume) (nhds c)\nhu : Tendsto u lt lb\nhv : Tendsto v lt lb\n\u22a2 (fun t => ((\u222b (x : \u211d) in a..v t, f x) - \u222b (x : \u211d) in a..u t, f x) - (v t - u t) \u2022 c) =o[lt] (v - u)"}, {"line": "simpa only [integral_const,smul_eq_mul,mul_one] using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_right hab hmeas hf hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left\n    (hab : IntervalIntegrable f volume a b) (hmeas : StronglyMeasurableAtFilter f la')\n    (hf : Tendsto f (la' \u2293 ae volume) (\ud835\udcdd c)) (hu : Tendsto u lt la) (hv : Tendsto v lt la) :\n    (fun t => ((\u222b x in v t..b, f x) - \u222b x in u t..b, f x) + (v t - u t) \u2022 c) =o[lt] (v - u) := by\n  simpa only [integral_const,smul_eq_mul,mul_one] using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left hab hmeas hf hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nc : E\nla la' : Filter \u211d\nlt : Filter \u03b9\ninst\u271d : CompleteSpace E\nu v : \u03b9 \u2192 \u211d\nhab : IntervalIntegrable f volume a b\nhmeas : StronglyMeasurableAtFilter f la' volume\nhf : Tendsto f (la' \u2293 ae volume) (nhds c)\nhu : Tendsto u lt la\nhv : Tendsto v lt la\n\u22a2 (fun t => ((\u222b (x : \u211d) in v t..b, f x) - \u222b (x : \u211d) in u t..b, f x) + (v t - u t) \u2022 c) =o[lt] (v - u)"}, {"line": "simpa only [integral_const,smul_eq_mul,mul_one] using\n    measure_integral_sub_integral_sub_linear_isLittleO_of_tendsto_ae_left hab hmeas hf hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_hasStrictDerivAt_of_tendsto_ae_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : Tendsto f (\ud835\udcdd a \u2293 ae volume) (\ud835\udcdd c)) :\n    HasStrictDerivAt (fun u => \u222b x in u..b, f x) (-c) a := by\n  simpa only [\u2190 integral_symm] using\n    (integral_hasStrictDerivAt_of_tendsto_ae_right hf.symm hmeas ha).neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\nc : E\ninst\u271d : CompleteSpace E\nhf : IntervalIntegrable f volume a b\nhmeas : StronglyMeasurableAtFilter f (nhds a) volume\nha : Tendsto f (nhds a \u2293 ae volume) (nhds c)\n\u22a2 HasStrictDerivAt (fun u => \u222b (x : \u211d) in u..b, f x) (-c) a"}, {"line": "simpa only [\u2190 integral_symm] using\n    (integral_hasStrictDerivAt_of_tendsto_ae_right hf.symm hmeas ha).neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_hasStrictDerivAt_left (hf : IntervalIntegrable f volume a b)\n    (hmeas : StronglyMeasurableAtFilter f (\ud835\udcdd a)) (ha : ContinuousAt f a) :\n    HasStrictDerivAt (fun u => \u222b x in u..b, f x) (-f a) a := by\n  simpa only [\u2190 integral_symm] using (integral_hasStrictDerivAt_right hf.symm hmeas ha).neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\nf : \u211d \u2192 E\na b : \u211d\ninst\u271d : CompleteSpace E\nhf : IntervalIntegrable f volume a b\nhmeas : StronglyMeasurableAtFilter f (nhds a) volume\nha : ContinuousAt f a\n\u22a2 HasStrictDerivAt (fun u => \u222b (x : \u211d) in u..b, f x) (-f a) a"}, {"line": "simpa only [\u2190 integral_symm] using (integral_hasStrictDerivAt_right hf.symm hmeas ha).neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le_Ico (hab : a \u2264 b)\n    (hcont : ContinuousOn g (Icc a b)) (hderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x)\n    (\u03c6int : IntegrableOn \u03c6 (Icc a b)) (h\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x) :\n    g b - g a \u2264 \u222b y in a..b, \u03c6 y := by\n  refine le_of_forall_pos_le_add fun \u03b5 \u03b5pos => ?_\n  -- Bound from above `g'` by a lower-semicontinuous function `G'`.\n  rcases exists_lt_lowerSemicontinuous_integral_lt \u03c6 \u03c6int \u03b5pos with\n    \u27e8G', f_lt_G', G'cont, G'int, G'lt_top, hG'\u27e9\n  -- we will show by \"induction\" that `g t - g a \u2264 \u222b u in a..t, G' u` for all `t \u2208 [a, b]`.\n  set s := {t | g t - g a \u2264 \u222b u in a..t, (G' u).toReal} \u2229 Icc a b\n  -- the set `s` of points where this property holds is closed.\n  have s_closed : IsClosed s := by\n    have : ContinuousOn (fun t => (g t - g a, \u222b u in a..t, (G' u).toReal)) (Icc a b) := by\n      rw [\u2190 uIcc_of_le hab] at G'int hcont \u22a2\n      exact (hcont.sub continuousOn_const).prodMk (continuousOn_primitive_interval G'int)\n    simp only [s]\n    simp only [inter_comm]\n    exact this.preimage_isClosed_of_isClosed isClosed_Icc OrderClosedTopology.isClosed_le'\n  have main : Icc a b \u2286 {t | g t - g a \u2264 \u222b u in a..t, (G' u).toReal} := by\n    -- to show that the set `s` is all `[a, b]`, it suffices to show that any point `t` in `s`\n    -- with `t < b` admits another point in `s` slightly to its right\n    -- (this is a sort of real induction).\n    refine s_closed.Icc_subset_of_forall_exists_gt\n      (by simp only [integral_same, mem_setOf_eq, sub_self, le_rfl]) fun t ht v t_lt_v => ?_\n    obtain \u27e8y, g'_lt_y', y_lt_G'\u27e9 : \u2203 y : \u211d, (g' t : EReal) < y \u2227 (y : EReal) < G' t :=\n      EReal.lt_iff_exists_real_btwn.1 ((EReal.coe_le_coe_iff.2 (h\u03c6g t ht.2)).trans_lt (f_lt_G' t))\n    -- bound from below the increase of `\u222b x in a..u, G' x` on the right of `t`, using the lower\n    -- semicontinuity of `G'`.\n    have I1 : \u2200\u1da0 u in \ud835\udcdd[>] t, (u - t) * y \u2264 \u222b w in t..u, (G' w).toReal := by\n      have B : \u2200\u1da0 u in \ud835\udcdd t, (y : EReal) < G' u := G'cont.lowerSemicontinuousAt _ _ y_lt_G'\n      rcases mem_nhds_iff_exists_Ioo_subset.1 B with \u27e8m, M, \u27e8hm, hM\u27e9, H\u27e9\n      have : Ioo t (min M b) \u2208 \ud835\udcdd[>] t := Ioo_mem_nhdsGT (lt_min hM ht.right.right)\n      filter_upwards [this] with u hu\n      have I : Icc t u \u2286 Icc a b := Icc_subset_Icc ht.2.1 (hu.2.le.trans (min_le_right _ _))\n      calc\n        (u - t) * y = \u222b _ in Icc t u, y := by\n          simp only [MeasureTheory.integral_const]\n          simp only [MeasurableSet.univ]\n          simp only [measureReal_restrict_apply]\n          simp only [univ_inter]\n          simp only [hu.left.le]\n          simp only [Real.volume_real_Icc_of_le]\n          simp only [smul_eq_mul]\n          simp only [s]\n        _ \u2264 \u222b w in t..u, (G' w).toReal := by\n          rw [intervalIntegral.integral_of_le hu.1.le]\n          rw [\u2190 integral_Icc_eq_integral_Ioc]\n          apply setIntegral_mono_ae_restrict\n          \u00b7 simp only [integrableOn_const, Real.volume_Icc, ENNReal.ofReal_lt_top, or_true]\n          \u00b7 exact IntegrableOn.mono_set G'int I\n          \u00b7 have C1 : \u2200\u1d50 x : \u211d \u2202volume.restrict (Icc t u), G' x < \u221e :=\n              ae_mono (Measure.restrict_mono I le_rfl) G'lt_top\n            have C2 : \u2200\u1d50 x : \u211d \u2202volume.restrict (Icc t u), x \u2208 Icc t u :=\n              ae_restrict_mem measurableSet_Icc\n            filter_upwards [C1, C2] with x G'x hx\n            apply EReal.coe_le_coe_iff.1\n            have : x \u2208 Ioo m M := by\n              simp only [hm.trans_le hx.left]\n              simp only [(hx.right.trans_lt hu.right).trans_le (min_le_left M b)]\n              simp only [mem_Ioo]\n              simp only [and_self_iff]\n            refine (H this).out.le.trans_eq ?_\n            exact (EReal.coe_toReal G'x.ne (f_lt_G' x).ne_bot).symm\n    -- bound from above the increase of `g u - g a` on the right of `t`, using the derivative at `t`\n    have I2 : \u2200\u1da0 u in \ud835\udcdd[>] t, g u - g t \u2264 (u - t) * y := by\n      have g'_lt_y : g' t < y := EReal.coe_lt_coe_iff.1 g'_lt_y'\n      filter_upwards [(hderiv t \u27e8ht.2.1, ht.2.2\u27e9).limsup_slope_le' (not_mem_Ioi.2 le_rfl) g'_lt_y,\n        self_mem_nhdsWithin] with u hu t_lt_u\n      have := mul_le_mul_of_nonneg_left hu.le (sub_pos.2 t_lt_u.out).le\n      rwa [\u2190 smul_eq_mul, sub_smul_slope] at this\n    -- combine the previous two bounds to show that `g u - g a` increases less quickly than\n    -- `\u222b x in a..u, G' x`.\n    have I3 : \u2200\u1da0 u in \ud835\udcdd[>] t, g u - g t \u2264 \u222b w in t..u, (G' w).toReal := by\n      filter_upwards [I1, I2] with u hu1 hu2 using hu2.trans hu1\n    have I4 : \u2200\u1da0 u in \ud835\udcdd[>] t, u \u2208 Ioc t (min v b) := Ioc_mem_nhdsGT <| lt_min t_lt_v ht.2.2\n    -- choose a point `x` slightly to the right of `t` which satisfies the above bound\n    rcases (I3.and I4).exists with \u27e8x, hx, h'x\u27e9\n    -- we check that it belongs to `s`, essentially by construction\n    refine \u27e8x, ?_, Ioc_subset_Ioc le_rfl (min_le_left _ _) h'x\u27e9\n    calc\n      g x - g a = g t - g a + (g x - g t) := by abel\n      _ \u2264 (\u222b w in a..t, (G' w).toReal) + \u222b w in t..x, (G' w).toReal := add_le_add ht.1 hx\n      _ = \u222b w in a..x, (G' w).toReal := by\n        apply integral_add_adjacent_intervals\n        \u00b7 rw [intervalIntegrable_iff_integrableOn_Ioc_of_le ht.2.1]\n          exact IntegrableOn.mono_set G'int\n            (Ioc_subset_Icc_self.trans (Icc_subset_Icc le_rfl ht.2.2.le))\n        \u00b7 rw [intervalIntegrable_iff_integrableOn_Ioc_of_le h'x.1.le]\n          apply IntegrableOn.mono_set G'int\n          exact Ioc_subset_Icc_self.trans (Icc_subset_Icc ht.2.1 (h'x.2.trans (min_le_right _ _)))\n  -- now that we know that `s` contains `[a, b]`, we get the desired result by applying this to `b`.\n  calc\n    g b - g a \u2264 \u222b y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)\n    _ \u2264 (\u222b y in a..b, \u03c6 y) + \u03b5 := by\n      convert hG'.le <;>\n        \u00b7 rw [intervalIntegral.integral_of_le hab]\n          simp only [integral_Icc_eq_integral_Ioc']\n          simp only [Real.volume_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "refine le_of_forall_pos_le_add fun \u03b5 \u03b5pos => ?_", "tactic_state": "g' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\n\u22a2 g b - g a \u2264 (\u222b (y : \u211d) in a..b, \u03c6 y) + \u03b5"}, {"line": "rcases exists_lt_lowerSemicontinuous_integral_lt \u03c6 \u03c6int \u03b5pos with\n    \u27e8G', f_lt_G', G'cont, G'int, G'lt_top, hG'\u27e9", "tactic_state": "case intro.intro.intro.intro.intro\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nG' : \u211d \u2192 EReal\nf_lt_G' : \u2200 (x : \u211d), \u2191(\u03c6 x) < G' x\nG'cont : LowerSemicontinuous G'\nG'int : Integrable (fun x => (G' x).toReal) (volume.restrict (Icc a b))\nG'lt_top : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Icc a b), G' x < \u22a4\nhG' : \u222b (x : \u211d) in Icc a b, (G' x).toReal \u2202volume < \u222b (x : \u211d) in Icc a b, \u03c6 x \u2202volume + \u03b5\n\u22a2 g b - g a \u2264 (\u222b (y : \u211d) in a..b, \u03c6 y) + \u03b5"}, {"line": "set s := {t | g t - g a \u2264 \u222b u in a..t, (G' u).toReal} \u2229 Icc a b", "tactic_state": "case intro.intro.intro.intro.intro\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nG' : \u211d \u2192 EReal\nf_lt_G' : \u2200 (x : \u211d), \u2191(\u03c6 x) < G' x\nG'cont : LowerSemicontinuous G'\nG'int : Integrable (fun x => (G' x).toReal) (volume.restrict (Icc a b))\nG'lt_top : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Icc a b), G' x < \u22a4\nhG' : \u222b (x : \u211d) in Icc a b, (G' x).toReal \u2202volume < \u222b (x : \u211d) in Icc a b, \u03c6 x \u2202volume + \u03b5\ns : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b\n\u22a2 g b - g a \u2264 (\u222b (y : \u211d) in a..b, \u03c6 y) + \u03b5"}, {"line": "have s_closed : IsClosed s := sorry", "tactic_state": "case intro.intro.intro.intro.intro\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nG' : \u211d \u2192 EReal\nf_lt_G' : \u2200 (x : \u211d), \u2191(\u03c6 x) < G' x\nG'cont : LowerSemicontinuous G'\nG'int : Integrable (fun x => (G' x).toReal) (volume.restrict (Icc a b))\nG'lt_top : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Icc a b), G' x < \u22a4\nhG' : \u222b (x : \u211d) in Icc a b, (G' x).toReal \u2202volume < \u222b (x : \u211d) in Icc a b, \u03c6 x \u2202volume + \u03b5\ns : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b\ns_closed : IsClosed s\n\u22a2 g b - g a \u2264 (\u222b (y : \u211d) in a..b, \u03c6 y) + \u03b5"}, {"line": "have main : Icc a b \u2286 {t | g t - g a \u2264 \u222b u in a..t, (G' u).toReal} := sorry", "tactic_state": "case intro.intro.intro.intro.intro\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ico a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ico a b, g' x \u2264 \u03c6 x\n\u03b5 : \u211d\n\u03b5pos : 0 < \u03b5\nG' : \u211d \u2192 EReal\nf_lt_G' : \u2200 (x : \u211d), \u2191(\u03c6 x) < G' x\nG'cont : LowerSemicontinuous G'\nG'int : Integrable (fun x => (G' x).toReal) (volume.restrict (Icc a b))\nG'lt_top : \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Icc a b), G' x < \u22a4\nhG' : \u222b (x : \u211d) in Icc a b, (G' x).toReal \u2202volume < \u222b (x : \u211d) in Icc a b, \u03c6 x \u2202volume + \u03b5\ns : Set \u211d := {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal} \u2229 Icc a b\ns_closed : IsClosed s\nmain : Icc a b \u2286 {t | g t - g a \u2264 \u222b (u : \u211d) in a..t, (G' u).toReal}\n\u22a2 g b - g a \u2264 (\u222b (y : \u211d) in a..b, \u03c6 y) + \u03b5"}, {"line": "calc\n    g b - g a \u2264 \u222b y in a..b, (G' y).toReal := main (right_mem_Icc.2 hab)\n    _ \u2264 (\u222b y in a..b, \u03c6 y) + \u03b5 := by\n      convert hG'.le <;>\n        \u00b7 rw [intervalIntegral.integral_of_le hab]\n          simp only [integral_Icc_eq_integral_Ioc']\n          simp only [Real.volume_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_le_integral_of_hasDeriv_right_of_le (hab : a \u2264 b) (hcont : ContinuousOn g (Icc a b))\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x) (\u03c6int : IntegrableOn \u03c6 (Icc a b))\n    (h\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x) : g b - g a \u2264 \u222b y in a..b, \u03c6 y := by\n  -- This follows from the version on a closed-open interval (applied to `[t, b)` for `t` close to\n  -- `a`) and a continuity argument.\n  obtain rfl | a_lt_b := hab.eq_or_lt\n  \u00b7 simp\n  set s := {t | g b - g t \u2264 \u222b u in t..b, \u03c6 u} \u2229 Icc a b\n  have s_closed : IsClosed s := by\n    have : ContinuousOn (fun t => (g b - g t, \u222b u in t..b, \u03c6 u)) (Icc a b) := by\n      rw [\u2190 uIcc_of_le hab] at hcont \u03c6int \u22a2\n      exact (continuousOn_const.sub hcont).prodMk (continuousOn_primitive_interval_left \u03c6int)\n    simp only [s]\n    simp only [inter_comm]\n    exact this.preimage_isClosed_of_isClosed isClosed_Icc isClosed_le_prod\n  have A : closure (Ioc a b) \u2286 s := by\n    apply s_closed.closure_subset_iff.2\n    intro t ht\n    refine \u27e8?_, \u27e8ht.1.le, ht.2\u27e9\u27e9\n    exact\n      sub_le_integral_of_hasDeriv_right_of_le_Ico ht.2 (hcont.mono (Icc_subset_Icc ht.1.le le_rfl))\n        (fun x hx => hderiv x \u27e8ht.1.trans_le hx.1, hx.2\u27e9)\n        (\u03c6int.mono_set (Icc_subset_Icc ht.1.le le_rfl)) fun x hx => h\u03c6g x \u27e8ht.1.trans_le hx.1, hx.2\u27e9\n  rw [closure_Ioc a_lt_b.ne] at A\n  exact (A (left_mem_Icc.2 hab)).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "obtain rfl | a_lt_b := hab.eq_or_lt", "tactic_state": "case inl\ng' g \u03c6 : \u211d \u2192 \u211d\na : \u211d\nhab : a \u2264 a\nhcont : ContinuousOn g (Icc a a)\nhderiv : \u2200 x \u2208 Ioo a a, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a a) volume\nh\u03c6g : \u2200 x \u2208 Ioo a a, g' x \u2264 \u03c6 x\n\u22a2 g a - g a \u2264 \u222b (y : \u211d) in a..a, \u03c6 y\n---\ncase inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "\u00b7 simp", "tactic_state": "case inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "set s := {t | g b - g t \u2264 \u222b u in t..b, \u03c6 u} \u2229 Icc a b", "tactic_state": "case inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\ns : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "have s_closed : IsClosed s := sorry", "tactic_state": "case inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\ns : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b\ns_closed : IsClosed s\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "have A : closure (Ioc a b) \u2286 s := sorry", "tactic_state": "case inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\ns : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b\ns_closed : IsClosed s\nA : closure (Ioc a b) \u2286 s\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "rw [closure_Ioc a_lt_b.ne] at A", "tactic_state": "case inr\ng' g \u03c6 : \u211d \u2192 \u211d\na b : \u211d\nhab : a \u2264 b\nhcont : ContinuousOn g (Icc a b)\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivWithinAt g (g' x) (Ioi x) x\n\u03c6int : IntegrableOn \u03c6 (Icc a b) volume\nh\u03c6g : \u2200 x \u2208 Ioo a b, g' x \u2264 \u03c6 x\na_lt_b : a < b\ns : Set \u211d := {t | g b - g t \u2264 \u222b (u : \u211d) in t..b, \u03c6 u} \u2229 Icc a b\ns_closed : IsClosed s\nA : Icc a b \u2286 s\n\u22a2 g b - g a \u2264 \u222b (y : \u211d) in a..b, \u03c6 y"}, {"line": "exact (A (left_mem_Icc.2 hab)).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_eq_sub_of_hasDerivAt_of_tendsto (hab : a < b) {fa fb}\n    (hderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x) (hint : IntervalIntegrable f' volume a b)\n    (ha : Tendsto f (\ud835\udcdd[>] a) (\ud835\udcdd fa)) (hb : Tendsto f (\ud835\udcdd[<] b) (\ud835\udcdd fb)) :\n    \u222b y in a..b, f' y = fb - fa := by\n  set F : \u211d \u2192 E := update (update f a fa) b fb\n  have Fderiv : \u2200 x \u2208 Ioo a b, HasDerivAt F (f' x) x := by\n    refine fun x hx => (hderiv x hx).congr_of_eventuallyEq ?_\n    filter_upwards [Ioo_mem_nhds hx.1 hx.2] with _ hy\n    unfold F\n    rw [update_of_ne hy.2.ne]\n    rw [update_of_ne hy.1.ne']\n  have hcont : ContinuousOn F (Icc a b) := by\n    rw [continuousOn_update_iff]\n    rw [continuousOn_update_iff]\n    rw [Icc_diff_right]\n    rw [Ico_diff_left]\n    refine \u27e8\u27e8fun z hz => (hderiv z hz).continuousAt.continuousWithinAt, ?_\u27e9, ?_\u27e9\n    \u00b7 exact fun _ => ha.mono_left (nhdsWithin_mono _ Ioo_subset_Ioi_self)\n    \u00b7 rintro -\n      refine (hb.congr' ?_).mono_left (nhdsWithin_mono _ Ico_subset_Iio_self)\n      filter_upwards [Ioo_mem_nhdsLT hab] with _ hz using (update_of_ne hz.1.ne' _ _).symm\n  simpa [F, hab.ne, hab.ne'] using integral_eq_sub_of_hasDerivAt_of_le hab.le hcont Fderiv hint\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/FundThmCalculus.lean", "context": {"open": ["MeasureTheory Set Filter Function Asymptotics", "scoped Topology ENNReal Interval NNReal", "ContinuousLinearMap (fst snd smulRight sub_apply smulRight_apply coe_fst' coe_snd' map_sub)"], "variables": ["{\u03b9 \ud835\udd5c E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{f : \u211d \u2192 E} {a b : \u211d} {c ca cb : E} {l l' la la' lb lb' : Filter \u211d} {lt : Filter \u03b9}", "[IsLocallyFiniteMeasure \u03bc]", "[FTCFilter a la la'] [FTCFilter b lb lb']", "[CompleteSpace E]", "{g' g \u03c6 : \u211d \u2192 \u211d} {a b : \u211d}", "[CompleteSpace E] {f f' : \u211d \u2192 E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\na b : \u211d\ninst\u271d : CompleteSpace E\nf f' : \u211d \u2192 E\nhab : a < b\nfa fb : E\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhint : IntervalIntegrable f' volume a b\nha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)\nhb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)\n\u22a2 \u222b (y : \u211d) in a..b, f' y = fb - fa"}, {"line": "set F : \u211d \u2192 E := update (update f a fa) b fb", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\na b : \u211d\ninst\u271d : CompleteSpace E\nf f' : \u211d \u2192 E\nhab : a < b\nfa fb : E\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhint : IntervalIntegrable f' volume a b\nha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)\nhb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)\nF : \u211d \u2192 E := update (update f a fa) b fb\n\u22a2 \u222b (y : \u211d) in a..b, f' y = fb - fa"}, {"line": "have Fderiv : \u2200 x \u2208 Ioo a b, HasDerivAt F (f' x) x := sorry", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\na b : \u211d\ninst\u271d : CompleteSpace E\nf f' : \u211d \u2192 E\nhab : a < b\nfa fb : E\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhint : IntervalIntegrable f' volume a b\nha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)\nhb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)\nF : \u211d \u2192 E := update (update f a fa) b fb\nFderiv : \u2200 x \u2208 Ioo a b, sorry\n\u22a2 \u222b (y : \u211d) in a..b, f' y = fb - fa"}, {"line": "have hcont : ContinuousOn F (Icc a b) := sorry", "tactic_state": "E : Type u_3\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : CompleteSpace E\na b : \u211d\ninst\u271d : CompleteSpace E\nf f' : \u211d \u2192 E\nhab : a < b\nfa fb : E\nhderiv : \u2200 x \u2208 Ioo a b, HasDerivAt f (f' x) x\nhint : IntervalIntegrable f' volume a b\nha : Tendsto f (nhdsWithin a (Ioi a)) (nhds fa)\nhb : Tendsto f (nhdsWithin b (Iio b)) (nhds fb)\nF : \u211d \u2192 E := update (update f a fa) b fb\nFderiv : \u2200 x \u2208 Ioo a b, sorry\nhcont : sorry\n\u22a2 \u222b (y : \u211d) in a..b, f' y = fb - fa"}, {"line": "simpa [F, hab.ne, hab.ne'] using integral_eq_sub_of_hasDerivAt_of_le hab.le hcont Fderiv hint", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atTop_intervalIntegral_of_pos (h\u2080 : 0 < \u222b x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => \u222b x in (0)..t, g x) atTop atTop := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h\u2080.ne'\n  apply tendsto_atTop_mono (hg.sInf_add_zsmul_le_integral_of_pos h_int hT)\n  apply atTop.tendsto_atTop_add_const_left (sInf <| (fun t => \u222b x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atTop_zsmul_const h\u2080\n  exact tendsto_floor_atTop.comp (tendsto_id.atTop_mul_const (inv_pos.mpr hT))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Periodic.lean", "context": {"open": ["Set Function MeasureTheory MeasureTheory.Measure TopologicalSpace AddSubgroup intervalIntegral", "scoped MeasureTheory NNReal ENNReal", "Filter"], "variables": ["(T : \u211d) [hT : Fact (0 < T)]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {T : \u211d}", "[NormedSpace \u211d E]", "{g : \u211d \u2192 \u211d}", "(hg : Periodic g T)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\n\u22a2 Tendsto (fun t => \u222b (x : \u211d) in 0 ..t, g x) atTop atTop"}, {"line": "have h_int := intervalIntegrable_of_integral_ne_zero h\u2080.ne'", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto (fun t => \u222b (x : \u211d) in 0 ..t, g x) atTop atTop"}, {"line": "apply tendsto_atTop_mono (hg.sInf_add_zsmul_le_integral_of_pos h_int hT)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.4882 atTop atTop\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u211d"}, {"line": "apply atTop.tendsto_atTop_add_const_left (sInf <| (fun t => \u222b x in (0)..t, g x) '' Icc 0 T)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.5157 atTop atTop\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u211d"}, {"line": "apply Tendsto.atTop_zsmul_const h\u2080", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.5729 atTop atTop\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u2124"}, {"line": "exact tendsto_floor_atTop.comp (tendsto_id.atTop_mul_const (inv_pos.mpr hT))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atBot_intervalIntegral_of_pos (h\u2080 : 0 < \u222b x in (0)..T, g x) (hT : 0 < T) :\n    Tendsto (fun t => \u222b x in (0)..t, g x) atBot atBot := by\n  have h_int := intervalIntegrable_of_integral_ne_zero h\u2080.ne'\n  apply tendsto_atBot_mono (hg.integral_le_sSup_add_zsmul_of_pos h_int hT)\n  apply atBot.tendsto_atBot_add_const_left (sSup <| (fun t => \u222b x in (0)..t, g x) '' Icc 0 T)\n  apply Tendsto.atBot_zsmul_const h\u2080\n  exact tendsto_floor_atBot.comp (tendsto_id.atBot_mul_const (inv_pos.mpr hT))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Periodic.lean", "context": {"open": ["Set Function MeasureTheory MeasureTheory.Measure TopologicalSpace AddSubgroup intervalIntegral", "scoped MeasureTheory NNReal ENNReal", "Filter"], "variables": ["(T : \u211d) [hT : Fact (0 < T)]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {T : \u211d}", "[NormedSpace \u211d E]", "{g : \u211d \u2192 \u211d}", "(hg : Periodic g T)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\n\u22a2 Tendsto (fun t => \u222b (x : \u211d) in 0 ..t, g x) atBot atBot"}, {"line": "have h_int := intervalIntegrable_of_integral_ne_zero h\u2080.ne'", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto (fun t => \u222b (x : \u211d) in 0 ..t, g x) atBot atBot"}, {"line": "apply tendsto_atBot_mono (hg.integral_le_sSup_add_zsmul_of_pos h_int hT)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.4883 atBot atBot\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u211d"}, {"line": "apply atBot.tendsto_atBot_add_const_left (sSup <| (fun t => \u222b x in (0)..t, g x) '' Icc 0 T)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.5157 atBot atBot\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u211d"}, {"line": "apply Tendsto.atBot_zsmul_const h\u2080", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 Tendsto ?m.5693 atBot atBot\n---\nT : \u211d\ng : \u211d \u2192 \u211d\nh\u2080 : 0 < \u222b (x : \u211d) in 0 ..T, g x\nhT : 0 < T\nh_int : IntervalIntegrable g volume 0 T\n\u22a2 \u211d \u2192 \u2124"}, {"line": "exact tendsto_floor_atBot.comp (tendsto_id.atBot_mul_const (inv_pos.mpr hT))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_atBot_intervalIntegral_of_pos'\n    (h_int : IntervalIntegrable g MeasureSpace.volume 0 T) (h\u2080 : \u2200 x, 0 < g x) (hT : 0 < T) :\n    Tendsto (fun t => \u222b x in (0)..t, g x) atBot atBot := by\n  exact hg.tendsto_atBot_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h\u2080 hT) hT\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/IntervalIntegral/Periodic.lean", "context": {"open": ["Set Function MeasureTheory MeasureTheory.Measure TopologicalSpace AddSubgroup intervalIntegral", "scoped MeasureTheory NNReal ENNReal", "Filter"], "variables": ["(T : \u211d) [hT : Fact (0 < T)]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E]", "{f : \u211d \u2192 E} {T : \u211d}", "[NormedSpace \u211d E]", "{g : \u211d \u2192 \u211d}", "(hg : Periodic g T)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\ng : \u211d \u2192 \u211d\nh_int : IntervalIntegrable g volume 0 T\nh\u2080 : \u2200 (x : \u211d), 0 < g x\nhT : 0 < T\n\u22a2 Tendsto (fun t => \u222b (x : \u211d) in 0 ..t, g x) atBot atBot"}, {"line": "exact hg.tendsto_atBot_intervalIntegral_of_pos (intervalIntegral_pos_of_pos h_int h\u2080 hT) hT", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_add_right' (f : \u03b1 \u2192 \u211d\u22650\u221e) {g : \u03b1 \u2192 \u211d\u22650\u221e} (hg : AEMeasurable g \u03bc) :\n    \u222b\u207b a, f a + g a \u2202\u03bc = \u222b\u207b a, f a \u2202\u03bc + \u222b\u207b a, g a \u2202\u03bc := by\n  simpa only [add_comm] using lintegral_add_left' hg f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Lebesgue/Add.lean", "context": {"open": ["Set Filter ENNReal Topology NNReal SimpleFunc", "Encodable in"], "variables": ["{\u03b1 \u03b2 : Type*} {m : MeasurableSpace \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\n\u03bc : MeasureTheory.Measure \u03b1\nf g : \u03b1 \u2192 ENNReal\nhg : AEMeasurable g \u03bc\n\u22a2 \u222b\u207b (a : \u03b1), f a + g a \u2202\u03bc = \u222b\u207b (a : \u03b1), f a \u2202\u03bc + \u222b\u207b (a : \u03b1), g a \u2202\u03bc"}, {"line": "simpa only [add_comm] using lintegral_add_left' hg f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_dirac [MeasurableSingletonClass \u03b1] (a : \u03b1) (f : \u03b1 \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b a, f a \u2202dirac a = f a := by simp [lintegral_congr_ae (ae_eq_dirac f)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Lebesgue/Countable.lean", "context": {"open": ["Set ENNReal NNReal Measure"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "(\u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.862\n\u03b1\u271d : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nx\u271d : Sort u_2\ndirac : x\u271d\ninst\u271d : MeasurableSingletonClass \u03b1\na : \u03b1\nf : \u03b1 \u2192 ENNReal\n\u22a2 \u222b\u207b (a : \u03b1), f a \u2202sorry = f a"}, {"line": "simp [lintegral_congr_ae (ae_eq_dirac f)]", "tactic_state": "Measure : ?m.862\n\u03b1\u271d : Type u_1\ninst\u271d\u00b2 : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\n\u03b1 : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\nx\u271d : Sort u_2\ndirac : x\u271d\ninst\u271d : MeasurableSingletonClass \u03b1\na : \u03b1\nf : \u03b1 \u2192 ENNReal\n\u22a2 \u222b\u207b (a : \u03b1), f a \u2202sorry () = f a"}]}
{"declaration": "lemma _root_.ENNReal.tsum_const_eq (c : \u211d\u22650\u221e) : \u2211' _ : \u03b1, c = c * count (univ : Set \u03b1) := by\n  simp [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/MeasureTheory/Integral/Lebesgue/Countable.lean", "context": {"open": ["Set ENNReal NNReal Measure"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {\u03bc : Measure \u03b1}", "(\u03bc) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.862\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\ncount : x\u271d\nc : ENNReal\n\u22a2 \u2211' (x : \u03b1), c = c * sorry"}, {"line": "simp [mul_comm]", "tactic_state": "Measure : ?m.862\n\u03b1\u271d : Type u_1\ninst\u271d\u00b9 : MeasurableSpace \u03b1\u271d\n\u03bc : sorry\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nx\u271d : Sort u_2\ncount : x\u271d\nc : ENNReal\n\u22a2 c * \u2191(ENat.card \u03b1) = c * sorry ()"}]}
