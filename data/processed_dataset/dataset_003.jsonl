{"declaration": "theorem LieAlgebra.toModule_injective (L : Type*) [LieRing L] :\n    Function.Injective (@LieAlgebra.toModule _ _ _ _ : LieAlgebra \u211a L \u2192 Module \u211a L) := by\n  rintro \u27e8h\u2081\u27e9 \u27e8h\u2082\u27e9 heq\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_4\ninst\u271d : LieRing L\n\u22a2 Injective (@toModule \u211a L Rat.commRing inst\u271d)"}, {"line": "rintro \u27e8h\u2081\u27e9 \u27e8h\u2082\u27e9 heq", "tactic_state": "case mk.mk\nL : Type u_4\ninst\u271d : LieRing L\ntoModule\u271d\u00b9 : Module \u211a L\nh\u2081 : \u2200 (t : \u211a) (x y : L), \u2045x, t \u2022 y\u2046 = t \u2022 \u2045x, y\u2046\ntoModule\u271d : Module \u211a L\nh\u2082 : \u2200 (t : \u211a) (x y : L), \u2045x, t \u2022 y\u2046 = t \u2022 \u2045x, y\u2046\nheq : toModule = toModule\n\u22a2 { toModule := toModule\u271d\u00b9, lie_smul := h\u2081 } = { toModule := toModule\u271d, lie_smul := h\u2082 }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lie_skew : -\u2045y, x\u2046 = \u2045x, y\u2046 := by\n  have h : \u2045x + y, x\u2046 + \u2045x + y, y\u2046 = 0 := by rw [\u2190 lie_add]; apply lie_self\n  simpa [neg_eq_iff_add_eq_zero] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\ninst\u271d : LieRing L\nx y : L\n\u22a2 -\u2045y, x\u2046 = \u2045x, y\u2046"}, {"line": "have h : \u2045x + y, x\u2046 + \u2045x + y, y\u2046 = 0 := by rw [\u2190 lie_add]; apply lie_self", "tactic_state": "L : Type v\ninst\u271d : LieRing L\nx y : L\nh : sorry\n\u22a2 -\u2045y, x\u2046 = \u2045x, y\u2046"}, {"line": "simpa [neg_eq_iff_add_eq_zero] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_lie : \u2045-x, m\u2046 = -\u2045x, m\u2046 := by\n  rw [\u2190 sub_eq_zero]\n  rw [sub_neg_eq_add]\n  rw [\u2190 add_lie]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045-x, m\u2046 = -\u2045x, m\u2046"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045-x, m\u2046 - -\u2045x, m\u2046 = 0\n---\nL : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 AddGroup M"}, {"line": "rw [sub_neg_eq_add]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045-x, m\u2046 + \u2045x, m\u2046 = 0"}, {"line": "rw [\u2190 add_lie]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045-x + x, m\u2046 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lie_neg : \u2045x, -m\u2046 = -\u2045x, m\u2046 := by\n  rw [\u2190 sub_eq_zero]\n  rw [sub_neg_eq_add]\n  rw [\u2190 lie_add]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045x, -m\u2046 = -\u2045x, m\u2046"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045x, -m\u2046 - -\u2045x, m\u2046 = 0\n---\nL : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 AddGroup M"}, {"line": "rw [sub_neg_eq_add]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045x, -m\u2046 + \u2045x, m\u2046 = 0"}, {"line": "rw [\u2190 lie_add]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm : M\n\u22a2 \u2045x, -m + m\u2046 = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_lie : \u2045x - y, m\u2046 = \u2045x, m\u2046 - \u2045y, m\u2046 := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx y : L\nm : M\n\u22a2 \u2045x - y, m\u2046 = \u2045x, m\u2046 - \u2045y, m\u2046"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lie_sub : \u2045x, m - n\u2046 = \u2045x, m\u2046 - \u2045x, n\u2046 := by simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx : L\nm n : M\n\u22a2 \u2045x, m - n\u2046 = \u2045x, m\u2046 - \u2045x, n\u2046"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lie_lie : \u2045\u2045x, y\u2046, m\u2046 = \u2045x, \u2045y, m\u2046\u2046 - \u2045y, \u2045x, m\u2046\u2046 := by rw [leibniz_lie, add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx y : L\nm : M\n\u22a2 \u2045\u2045x, y\u2046, m\u2046 = \u2045x, \u2045y, m\u2046\u2046 - \u2045y, \u2045x, m\u2046\u2046"}, {"line": "rw [leibniz_lie, add_sub_cancel_right]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : LieRingModule L M\nx y : L\nm : M\n\u22a2 IsLieTower L L M"}]}
{"declaration": "theorem coe_injective : @Function.Injective (L\u2081 \u2192\u2097\u2045R\u2046 L\u2082) (L\u2081 \u2192 L\u2082) (\u2191) := by\n  rintro \u27e8\u27e8\u27e8f, _\u27e9, _\u27e9, _\u27e9 \u27e8\u27e8\u27e8g, _\u27e9, _\u27e9, _\u27e9 h\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)", "(L) in", "{\u03b9 \u03ba : Type*}", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R]", "[LieRing L\u2081] [LieAlgebra R L\u2081]", "[LieRing L\u2082] [LieAlgebra R L\u2082]", "[LieRing L\u2083] [LieAlgebra R L\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL\u2081 : Type v\nL\u2082 : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\u2081\ninst\u271d\u00b2 : LieAlgebra R L\u2081\ninst\u271d\u00b9 : LieRing L\u2082\ninst\u271d : LieAlgebra R L\u2082\n\u22a2 Injective DFunLike.coe"}, {"line": "rintro \u27e8\u27e8\u27e8f, _\u27e9, _\u27e9, _\u27e9 \u27e8\u27e8\u27e8g, _\u27e9, _\u27e9, _\u27e9 h", "tactic_state": "case mk.mk.mk.mk.mk.mk\nR : Type u\nL\u2081 : Type v\nL\u2082 : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\u2081\ninst\u271d\u00b2 : LieAlgebra R L\u2081\ninst\u271d\u00b9 : LieRing L\u2082\ninst\u271d : LieAlgebra R L\u2082\nf : L\u2081 \u2192 L\u2082\nmap_add'\u271d\u00b9 : \u2200 (x y : L\u2081), f (x + y) = f x + f y\nmap_smul'\u271d\u00b9 :\n  \u2200 (m : R) (x : L\u2081),\n    { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun x\nmap_lie'\u271d\u00b9 :\n  \u2200 {x y : L\u2081},\n    { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun \u2045x, y\u2046 =\n      \u2045{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun x,\n        { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun y\u2046\ng : L\u2081 \u2192 L\u2082\nmap_add'\u271d : \u2200 (x y : L\u2081), g (x + y) = g x + g y\nmap_smul'\u271d :\n  \u2200 (m : R) (x : L\u2081),\n    { toFun := g, map_add' := map_add'\u271d }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := g, map_add' := map_add'\u271d }.toFun x\nmap_lie'\u271d :\n  \u2200 {x y : L\u2081},\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun \u2045x, y\u2046 =\n      \u2045{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun x,\n        { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun y\u2046\nh :\n  \u21d1{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    \u21d1{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }\n\u22a2 { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_injective : @Function.Injective (M \u2192\u2097\u2045R,L\u2046 N) (M \u2192 N) (\u2191) := by\n  rintro \u27e8\u27e8\u27e8f, _\u27e9\u27e9\u27e9 \u27e8\u27e8\u27e8g, _\u27e9\u27e9\u27e9 h\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)", "(L) in", "{\u03b9 \u03ba : Type*}", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R]", "[LieRing L\u2081] [LieAlgebra R L\u2081]", "[LieRing L\u2082] [LieAlgebra R L\u2082]", "[LieRing L\u2083] [LieAlgebra R L\u2083]", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} (M : Type w\u2081)", "[CommRing R] [LieRing L\u2081] [LieAlgebra R L\u2081] [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M] [LieRingModule L\u2082 M]", "(f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082)", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R] [LieRing L\u2081] [LieRing L\u2082] [LieRing L\u2083]", "[LieAlgebra R L\u2081] [LieAlgebra R L\u2082] [LieAlgebra R L\u2083]", "(R : Type u) (L : Type v) (M : Type w) (N : Type w\u2081) (P : Type w\u2082)", "[CommRing R] [LieRing L]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P]", "[Module R M] [Module R N] [Module R P]", "[LieRingModule L M] [LieRingModule L N] [LieRingModule L P]", "{R L M N P}", "[LieAlgebra R L] [LieModule R L N] [LieModule R L P] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : LieRing L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieRingModule L N\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L N\n\u22a2 Injective DFunLike.coe"}, {"line": "rintro \u27e8\u27e8\u27e8f, _\u27e9\u27e9\u27e9 \u27e8\u27e8\u27e8g, _\u27e9\u27e9\u27e9 h", "tactic_state": "case mk.mk.mk.mk.mk.mk\nR : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : LieRing L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieRingModule L N\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L N\nf : M \u2192 N\nmap_add'\u271d\u00b9 : \u2200 (x y : M), f (x + y) = f x + f y\nmap_smul'\u271d\u00b9 :\n  \u2200 (m : R) (x : M),\n    { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := f, map_add' := map_add'\u271d\u00b9 }.toFun x\nmap_lie'\u271d\u00b9 :\n  \u2200 {x : L} {m : M},\n    { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun \u2045x, m\u2046 =\n      \u2045x, { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9 }.toFun m\u2046\ng : M \u2192 N\nmap_add'\u271d : \u2200 (x y : M), g (x + y) = g x + g y\nmap_smul'\u271d :\n  \u2200 (m : R) (x : M),\n    { toFun := g, map_add' := map_add'\u271d }.toFun (m \u2022 x) =\n      (RingHom.id R) m \u2022 { toFun := g, map_add' := map_add'\u271d }.toFun x\nmap_lie'\u271d :\n  \u2200 {x : L} {m : M},\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun \u2045x, m\u2046 =\n      \u2045x, { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d }.toFun m\u2046\nh :\n  \u21d1{ toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    \u21d1{ toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }\n\u22a2 { toFun := f, map_add' := map_add'\u271d\u00b9, map_smul' := map_smul'\u271d\u00b9, map_lie' := map_lie'\u271d\u00b9 } =\n    { toFun := g, map_add' := map_add'\u271d, map_smul' := map_smul'\u271d, map_lie' := map_lie'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_coe (f : M \u2192\u2097\u2045R,L\u2046 N) (h) : (\u27e8f, h\u27e9 : M \u2192\u2097\u2045R,L\u2046 N) = f := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)", "(L) in", "{\u03b9 \u03ba : Type*}", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R]", "[LieRing L\u2081] [LieAlgebra R L\u2081]", "[LieRing L\u2082] [LieAlgebra R L\u2082]", "[LieRing L\u2083] [LieAlgebra R L\u2083]", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} (M : Type w\u2081)", "[CommRing R] [LieRing L\u2081] [LieAlgebra R L\u2081] [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M] [LieRingModule L\u2082 M]", "(f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082)", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R] [LieRing L\u2081] [LieRing L\u2082] [LieRing L\u2083]", "[LieAlgebra R L\u2081] [LieAlgebra R L\u2082] [LieAlgebra R L\u2083]", "(R : Type u) (L : Type v) (M : Type w) (N : Type w\u2081) (P : Type w\u2082)", "[CommRing R] [LieRing L]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P]", "[Module R M] [Module R N] [Module R P]", "[LieRingModule L M] [LieRingModule L N] [LieRingModule L P]", "{R L M N P}", "[LieAlgebra R L] [LieModule R L N] [LieModule R L P] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : LieRing L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieRingModule L N\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L N\nf : M \u2192\u2097\u2045R,L\u2046 N\nh : \u2200 {x : L} {m : M}, (\u2191f).toFun \u2045x, m\u2046 = \u2045x, (\u2191f).toFun m\u2046\n\u22a2 { toLinearMap := \u2191f, map_lie' := h } = f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_mk (f : M \u2192\u2097[R] N) (h) : ((\u27e8f, h\u27e9 : M \u2192\u2097\u2045R,L\u2046 N) : M \u2192 N) = f := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Basic.lean", "context": {"open": ["Function"], "variables": ["{L\u2081 L\u2082 M : Type*} [Bracket L\u2081 L\u2082] [Bracket L\u2081 M] [Bracket L\u2082 M]", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L] [LieAlgebra R L]", "[AddCommGroup M] [Module R M] [LieRingModule L M] [LieModule R L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N] [LieModule R L N]", "(t : R) (x y z : L) (m n : M)", "(L) in", "{\u03b9 \u03ba : Type*}", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R]", "[LieRing L\u2081] [LieAlgebra R L\u2081]", "[LieRing L\u2082] [LieAlgebra R L\u2082]", "[LieRing L\u2083] [LieAlgebra R L\u2083]", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} (M : Type w\u2081)", "[CommRing R] [LieRing L\u2081] [LieAlgebra R L\u2081] [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M] [LieRingModule L\u2082 M]", "(f : L\u2081 \u2192\u2097\u2045R\u2046 L\u2082)", "{R : Type u} {L\u2081 : Type v} {L\u2082 : Type w} {L\u2083 : Type w\u2081}", "[CommRing R] [LieRing L\u2081] [LieRing L\u2082] [LieRing L\u2083]", "[LieAlgebra R L\u2081] [LieAlgebra R L\u2082] [LieAlgebra R L\u2083]", "(R : Type u) (L : Type v) (M : Type w) (N : Type w\u2081) (P : Type w\u2082)", "[CommRing R] [LieRing L]", "[AddCommGroup M] [AddCommGroup N] [AddCommGroup P]", "[Module R M] [Module R N] [Module R P]", "[LieRingModule L M] [LieRingModule L N] [LieRingModule L P]", "{R L M N P}", "[LieAlgebra R L] [LieModule R L N] [LieModule R L P] in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\nN : Type w\u2081\ninst\u271d\u2079 : CommRing R\ninst\u271d\u2078 : LieRing L\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup N\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Module R N\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 : LieRingModule L N\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L N\nf : M \u2192\u2097[R] N\nh : \u2200 {x : L} {m : M}, f.toFun \u2045x, m\u2046 = \u2045x, f.toFun m\u2046\n\u22a2 \u21d1{ toLinearMap := f, map_lie' := h } = \u21d1f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem adE_of_eq_eq_zero (i : B) (h : A i i = 2) : adE R A \u27e8i, i\u27e9 = 0 := by\n  have h' : (-2 : \u2124).toNat = 0 := rfl\n  simp [adE, h, h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/CartanMatrix.lean", "context": {"open": ["Function"], "variables": ["(R : Type u) {B : Type v} [CommRing R]", "(A : Matrix B B \u2124)", "(B)", "{B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadE : x\u271d\ni : B\nh : A i i = 2\n\u22a2 sorry = 0"}, {"line": "have h' : (-2 : \u2124).toNat = 0 := rfl", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadE : x\u271d\ni : B\nh : A i i = 2\nh' : (-2).toNat = 0\n\u22a2 sorry = 0"}, {"line": "simp [adE, h, h']", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadE : x\u271d\ni : B\nh : A i i = 2\nh' : (-2).toNat = 0\n\u22a2 sorry () = 0"}]}
{"declaration": "private theorem adF_of_eq_eq_zero (i : B) (h : A i i = 2) : adF R A \u27e8i, i\u27e9 = 0 := by\n  have h' : (-2 : \u2124).toNat = 0 := rfl\n  simp [adF, h, h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/CartanMatrix.lean", "context": {"open": ["Function"], "variables": ["(R : Type u) {B : Type v} [CommRing R]", "(A : Matrix B B \u2124)", "(B)", "{B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadF : x\u271d\ni : B\nh : A i i = 2\n\u22a2 sorry = 0"}, {"line": "have h' : (-2 : \u2124).toNat = 0 := rfl", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadF : x\u271d\ni : B\nh : A i i = 2\nh' : (-2).toNat = 0\n\u22a2 sorry = 0"}, {"line": "simp [adF, h, h']", "tactic_state": "B : Type v\nA : Matrix B B \u2124\nx\u271d : Sort u_1\nadF : x\u271d\ni : B\nh : A i i = 2\nh' : (-2).toNat = 0\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem jb_transform : (PB l R)\u1d40 * JB l R * PB l R = (2 : R) \u2022 Matrix.fromBlocks 1 0 0 (S l R) := by\n  simp [PB, JB, jd_transform, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply,\n    Matrix.fromBlocks_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Classical.lean", "context": {"open": ["Matrix", "scoped Matrix"], "variables": ["(n p q l : Type*) (R : Type u\u2082)", "[DecidableEq n] [DecidableEq p] [DecidableEq q] [DecidableEq l]", "[CommRing R]", "{n} [Fintype n] (i j : n)", "[Fintype p] [Fintype q]", "[Fintype l]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\u2082\ninst\u271d : CommRing R\nx\u271d\u00b2 : Sort u_5\nPB : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_6\nJB : x\u271d\u00b9\nx\u271d : Sort u_7\nS : x\u271d\n\u22a2 sorry.transpose * sorry * sorry = 2 \u2022 fromBlocks 1 0 0 sorry"}, {"line": "simp [PB, JB, jd_transform, Matrix.fromBlocks_transpose, Matrix.fromBlocks_multiply,\n    Matrix.fromBlocks_smul]", "tactic_state": "R : Type u\u2082\ninst\u271d : CommRing R\nx\u271d\u00b2 : Sort u_5\nPB : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_6\nJB : x\u271d\u00b9\nx\u271d : Sort u_7\nS : x\u271d\n\u22a2 (sorry ()).transpose * sorry () * sorry () = 2 \u2022 fromBlocks 1 0 0 (sorry ())"}]}
{"declaration": "theorem le_ker_iff : I \u2264 f.ker \u2194 \u2200 x, x \u2208 I \u2192 f x = 0 := by\n  constructor <;> intro h x hx\n  \u00b7 specialize h hx; rw [mem_ker] at h; exact h\n  \u00b7 rw [mem_ker]; apply h x hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Ideal.lean", "context": {"open": [], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "[LieAlgebra R L] [LieModule R L M]", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{R : Type u} {L : Type v} {L' : Type w\u2082} {M : Type w} {M' : Type w\u2081}", "[CommRing R] [LieRing L] [LieRing L'] [LieAlgebra R L']", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup M'] [Module R M'] [LieRingModule L M']", "[LieAlgebra R L] [LieModule R L M] [LieModule R L M']", "(f : L \u2192\u2097\u2045R\u2046 L') (I I\u2082 : LieIdeal R L) (J : LieIdeal R L')", "{f I I\u2082 J}", "(f) in", "[LieAlgebra R L] [LieModule R L M] [LieModule R L M']", "(f : L \u2192\u2097\u2045R\u2046 L') (I : LieIdeal R L) (J : LieIdeal R L')", "{f} in", "{f} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nL' : Type w\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieRing L'\ninst\u271d\u00b9 : LieAlgebra R L'\ninst\u271d : LieAlgebra R L\nf : L \u2192\u2097\u2045R\u2046 L'\nI : LieIdeal R L\n\u22a2 I \u2264 f.ker \u2194 \u2200 x \u2208 I, f x = 0"}, {"line": "constructor <;> intro h x hx", "tactic_state": "case mp\nR : Type u\nL : Type v\nL' : Type w\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieRing L'\ninst\u271d\u00b9 : LieAlgebra R L'\ninst\u271d : LieAlgebra R L\nf : L \u2192\u2097\u2045R\u2046 L'\nI : LieIdeal R L\nh : I \u2264 f.ker\nx : L\nhx : x \u2208 I\n\u22a2 f x = 0\n---\ncase mpr\nR : Type u\nL : Type v\nL' : Type w\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieRing L'\ninst\u271d\u00b9 : LieAlgebra R L'\ninst\u271d : LieAlgebra R L\nf : L \u2192\u2097\u2045R\u2046 L'\nI : LieIdeal R L\nh : \u2200 x \u2208 I, f x = 0\nx : L\nhx : x \u2208 I\n\u22a2 x \u2208 f.ker"}, {"line": "\u00b7 specialize h hx; rw [mem_ker] at h; exact h", "tactic_state": "case mpr\nR : Type u\nL : Type v\nL' : Type w\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieRing L'\ninst\u271d\u00b9 : LieAlgebra R L'\ninst\u271d : LieAlgebra R L\nf : L \u2192\u2097\u2045R\u2046 L'\nI : LieIdeal R L\nh : \u2200 x \u2208 I, f x = 0\nx : L\nhx : x \u2208 I\n\u22a2 x \u2208 f.ker"}, {"line": "\u00b7 rw [mem_ker]; apply h x hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_sup_ker_eq_map' :\n    LieIdeal.map f I \u2294 LieIdeal.map f (LieHom.ker f) = LieIdeal.map f I := by\n  simpa using map_sup_ker_eq_map (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Ideal.lean", "context": {"open": [], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "[LieAlgebra R L] [LieModule R L M]", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{R : Type u} {L : Type v} {L' : Type w\u2082} {M : Type w} {M' : Type w\u2081}", "[CommRing R] [LieRing L] [LieRing L'] [LieAlgebra R L']", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup M'] [Module R M'] [LieRingModule L M']", "[LieAlgebra R L] [LieModule R L M] [LieModule R L M']", "(f : L \u2192\u2097\u2045R\u2046 L') (I I\u2082 : LieIdeal R L) (J : LieIdeal R L')", "{f I I\u2082 J}", "(f) in", "[LieAlgebra R L] [LieModule R L M] [LieModule R L M']", "(f : L \u2192\u2097\u2045R\u2046 L') (I : LieIdeal R L) (J : LieIdeal R L')", "{f} in", "{f} in", "[LieAlgebra R L] [LieModule R L M] [LieModule R L M']", "{f : L \u2192\u2097\u2045R\u2046 L'} {I : LieIdeal R L} {J : LieIdeal R L'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nL' : Type w\u2082\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieRing L'\ninst\u271d\u00b9 : LieAlgebra R L'\ninst\u271d : LieAlgebra R L\nf : L \u2192\u2097\u2045R\u2046 L'\nI : LieIdeal R L\n\u22a2 LieIdeal.map f I \u2294 LieIdeal.map f f.ker = LieIdeal.map f I"}, {"line": "simpa using map_sup_ker_eq_map (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma killingForm_nondegenerate :\n    (killingForm R L).Nondegenerate := by\n  simp [LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Killing.lean", "context": {"open": [], "variables": ["(R K L : Type*) [CommRing R] [Field K] [LieRing L] [LieAlgebra R L] [LieAlgebra K L]", "[IsKilling R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nL : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u22a2 (killingForm R L).Nondegenerate"}, {"line": "simp [LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot]", "tactic_state": "R : Type u_1\nL : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u22a2 LinearMap.ker (killingForm R L) = \u22a5"}]}
{"declaration": "theorem Matrix.lieConj_apply (P A : Matrix n n R) (h : Invertible P) :\n    P.lieConj h A = P * A * P\u207b\u00b9 := by\n  simp [LinearEquiv.conj_apply, Matrix.lieConj, LinearMap.toMatrix'_comp,\n    LinearMap.toMatrix'_toLin']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Matrix.lean", "context": {"open": ["scoped Matrix"], "variables": ["{R : Type u} [CommRing R]", "{n : Type w} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nP A : Matrix n n R\nh : Invertible P\n\u22a2 (P.lieConj h) A = P * A * P\u207b\u00b9"}, {"line": "simp [LinearEquiv.conj_apply, Matrix.lieConj, LinearMap.toMatrix'_comp,\n    LinearMap.toMatrix'_toLin']", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nP A : Matrix n n R\nh : Invertible P\n\u22a2 LinearMap.toMatrix' ((toLin' P \u2218\u2097 toLin' A) \u2218\u2097 toLin' P\u207b\u00b9) = P * A * P\u207b\u00b9"}]}
{"declaration": "theorem Matrix.lieConj_symm_apply (P A : Matrix n n R) (h : Invertible P) :\n    (P.lieConj h).symm A = P\u207b\u00b9 * A * P := by\n  simp [LinearEquiv.symm_conj_apply, Matrix.lieConj, LinearMap.toMatrix'_comp,\n    LinearMap.toMatrix'_toLin']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Matrix.lean", "context": {"open": ["scoped Matrix"], "variables": ["{R : Type u} [CommRing R]", "{n : Type w} [DecidableEq n] [Fintype n]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nP A : Matrix n n R\nh : Invertible P\n\u22a2 (P.lieConj h).symm A = P\u207b\u00b9 * A * P"}, {"line": "simp [LinearEquiv.symm_conj_apply, Matrix.lieConj, LinearMap.toMatrix'_comp,\n    LinearMap.toMatrix'_toLin']", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nn : Type w\ninst\u271d\u00b9 : DecidableEq n\ninst\u271d : Fintype n\nP A : Matrix n n R\nh : Invertible P\n\u22a2 LinearMap.toMatrix' ((toLin' P\u207b\u00b9 \u2218\u2097 toLin' A) \u2218\u2097 toLin' P) = P\u207b\u00b9 * A * P"}]}
{"declaration": "theorem trivial_iff_lower_central_eq_bot : IsTrivial L M \u2194 lowerCentralSeries R L M 1 = \u22a5 := by\n  constructor <;> intro h\n  \u00b7 simp\n  \u00b7 rw [LieSubmodule.eq_bot_iff] at h; apply IsTrivial.mk; intro x m; apply h\n    apply LieSubmodule.subset_lieSpan\n    simp only [LieSubmodule.top_coe]\n    simp only [Subtype.exists]\n    simp only [LieSubmodule.mem_top]\n    simp only [exists_prop]\n    simp only [true_and]\n    simp only [Set.mem_setOf]\n    exact \u27e8x, m, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\n\u22a2 IsTrivial L M \u2194 LieModule.lowerCentralSeries R L M 1 = \u22a5"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nh : IsTrivial L M\n\u22a2 LieModule.lowerCentralSeries R L M 1 = \u22a5\n---\ncase mpr\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nh : LieModule.lowerCentralSeries R L M 1 = \u22a5\n\u22a2 IsTrivial L M"}, {"line": "\u00b7 simp", "tactic_state": "case mpr\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nh : LieModule.lowerCentralSeries R L M 1 = \u22a5\n\u22a2 IsTrivial L M"}, {"line": "\u00b7 rw [LieSubmodule.eq_bot_iff] at h; apply IsTrivial.mk; intro x m; apply h\n    apply LieSubmodule.subset_lieSpan\n    simp only [LieSubmodule.top_coe]\n    simp only [Subtype.exists]\n    simp only [LieSubmodule.mem_top]\n    simp only [exists_prop]\n    simp only [true_and]\n    simp only [Set.mem_setOf]\n    exact \u27e8x, m, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNilpotent_iff :\n    IsNilpotent L M \u2194 \u2203 k, lowerCentralSeries R L M k = \u22a5 := by\n  simp [isNilpotent_iff_int, SetLike.ext'_iff, coe_lowerCentralSeries_eq_int R L M]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LieModule R L M\n\u22a2 LieModule.IsNilpotent L M \u2194 \u2203 k, LieModule.lowerCentralSeries R L M k = \u22a5"}, {"line": "simp [isNilpotent_iff_int, SetLike.ext'_iff, coe_lowerCentralSeries_eq_int R L M]", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : LieRing L\ninst\u271d\u2076 : LieAlgebra R L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LieModule R L M\n\u22a2 (\u2203 k, \u2191(LieModule.lowerCentralSeries \u2124 L M k) = {0}) \u2194 \u2203 k, \u2191(LieModule.lowerCentralSeries R L M k) = {0}"}]}
{"declaration": "theorem nilpotencyLength_eq_one_iff [Nontrivial M] :\n    nilpotencyLength L M = 1 \u2194 IsTrivial L M := by\n  rw [nilpotencyLength_eq_succ_iff \u2124]\n  rw [\u2190 trivial_iff_lower_central_eq_bot]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : Nontrivial M\n\u22a2 nilpotencyLength L M = 1 \u2194 IsTrivial L M"}, {"line": "rw [nilpotencyLength_eq_succ_iff \u2124]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : Nontrivial M\n\u22a2 LieModule.lowerCentralSeries \u2124 L M (0 + 1) = \u22a5 \u2227 LieModule.lowerCentralSeries \u2124 L M 0 \u2260 \u22a5 \u2194 IsTrivial L M"}, {"line": "rw [\u2190 trivial_iff_lower_central_eq_bot]", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : Nontrivial M\n\u22a2 IsTrivial L M \u2227 LieModule.lowerCentralSeries \u2124 L M 0 \u2260 \u22a5 \u2194 IsTrivial L M"}, {"line": "simp", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : Nontrivial M\n\u22a2 IsTrivial L M \u2192 \u00ac\u22a4 = \u22a5"}]}
{"declaration": "theorem isTrivial_of_nilpotencyLength_le_one [IsNilpotent L M] (h : nilpotencyLength L M \u2264 1) :\n    IsTrivial L M := by\n  nontriviality M\n  rcases Nat.le_one_iff_eq_zero_or_eq_one.mp h with h | h\n  \u00b7 rw [nilpotencyLength_eq_zero_iff] at h; infer_instance\n  \u00b7 rwa [nilpotencyLength_eq_one_iff] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule.IsNilpotent L M\nh : nilpotencyLength L M \u2264 1\n\u22a2 IsTrivial L M"}, {"line": "nontriviality M", "tactic_state": "L : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule.IsNilpotent L M\nh : nilpotencyLength L M \u2264 1\na\u271d : Nontrivial M\n\u22a2 IsTrivial L M"}, {"line": "rcases Nat.le_one_iff_eq_zero_or_eq_one.mp h with h | h", "tactic_state": "case inl\nL : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule.IsNilpotent L M\nh\u271d : nilpotencyLength L M \u2264 1\na\u271d : Nontrivial M\nh : nilpotencyLength L M = 0\n\u22a2 IsTrivial L M\n---\ncase inr\nL : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule.IsNilpotent L M\nh\u271d : nilpotencyLength L M \u2264 1\na\u271d : Nontrivial M\nh : nilpotencyLength L M = 1\n\u22a2 IsTrivial L M"}, {"line": "\u00b7 rw [nilpotencyLength_eq_zero_iff] at h; infer_instance", "tactic_state": "case inr\nL : Type v\nM : Type w\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule.IsNilpotent L M\nh\u271d : nilpotencyLength L M \u2264 1\na\u271d : Nontrivial M\nh : nilpotencyLength L M = 1\n\u22a2 IsTrivial L M"}, {"line": "\u00b7 rwa [nilpotencyLength_eq_one_iff] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ucs_bot_one : (\u22a5 : LieSubmodule R L M).ucs 1 = LieModule.maxTrivSubmodule R L M := by\n  simp [LieSubmodule.normalizer_bot_eq_maxTrivSubmodule]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u00b9\u00b2 : CommRing R\ninst\u271d\u00b9\u00b9 : LieRing L\ninst\u271d\u00b9\u2070 : LieAlgebra R L\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : LieRingModule L M\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : LieModule R L M\n\u22a2 LieSubmodule.ucs 1 \u22a5 = maxTrivSubmodule R L M"}, {"line": "simp [LieSubmodule.normalizer_bot_eq_maxTrivSubmodule]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LieEquiv.nilpotent_iff_equiv_nilpotent (e : L \u2243\u2097\u2045R\u2046 L') :\n    IsNilpotent L \u2194 IsNilpotent L' := by\n  constructor <;> intro h\n  \u00b7 exact e.symm.injective.lieAlgebra_isNilpotent\n  \u00b7 exact e.injective.lieAlgebra_isNilpotent\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nL' : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L \u2243\u2097\u2045R\u2046 L'\n\u22a2 LieRing.IsNilpotent L \u2194 LieRing.IsNilpotent L'"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nR : Type u\nL : Type v\nL' : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L \u2243\u2097\u2045R\u2046 L'\nh : LieRing.IsNilpotent L\n\u22a2 LieRing.IsNilpotent L'\n---\ncase mpr\nR : Type u\nL : Type v\nL' : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L \u2243\u2097\u2045R\u2046 L'\nh : LieRing.IsNilpotent L'\n\u22a2 LieRing.IsNilpotent L"}, {"line": "\u00b7 exact e.symm.injective.lieAlgebra_isNilpotent", "tactic_state": "case mpr\nR : Type u\nL : Type v\nL' : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : LieAlgebra R L\ninst\u271d\u00b9 : LieRing L'\ninst\u271d : LieAlgebra R L'\ne : L \u2243\u2097\u2045R\u2046 L'\nh : LieRing.IsNilpotent L'\n\u22a2 LieRing.IsNilpotent L"}, {"line": "\u00b7 exact e.injective.lieAlgebra_isNilpotent", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.LieAlgebra.ad_nilpotent_of_nilpotent {a : A} (h : IsNilpotent a) :\n    IsNilpotent (LieAlgebra.ad R A a) := by\n  rw [LieAlgebra.ad_eq_lmul_left_sub_lmul_right]\n  have hl : IsNilpotent (LinearMap.mulLeft R a) := by rwa [LinearMap.isNilpotent_mulLeft_iff]\n  have hr : IsNilpotent (LinearMap.mulRight R a) := by rwa [LinearMap.isNilpotent_mulRight_iff]\n  have := @LinearMap.commute_mulLeft_right R A _ _ _ _ _ a a\n  exact this.isNilpotent_sub hl hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\n\u22a2 _root_.IsNilpotent ((ad R A) a)"}, {"line": "rw [LieAlgebra.ad_eq_lmul_left_sub_lmul_right]", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\n\u22a2 _root_.IsNilpotent ((LinearMap.mulLeft R - LinearMap.mulRight R) a)"}, {"line": "have hl : IsNilpotent (LinearMap.mulLeft R a) := sorry", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\n\u22a2 _root_.IsNilpotent ((LinearMap.mulLeft R - LinearMap.mulRight R) a)"}, {"line": "have hr : IsNilpotent (LinearMap.mulRight R a) := sorry", "tactic_state": "R : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 _root_.IsNilpotent ((LinearMap.mulLeft R - LinearMap.mulRight R) a)"}, {"line": "have := @LinearMap.commute_mulLeft_right R A _ _ _ _ _ a a", "tactic_state": "case refine_6\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\nthis : Commute (LinearMap.mulLeft R a) (LinearMap.mulRight R a)\n\u22a2 _root_.IsNilpotent ((LinearMap.mulLeft R - LinearMap.mulRight R) a)\n---\ncase refine_1\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 CommSemiring R\n---\ncase refine_2\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 NonUnitalSemiring A\n---\ncase refine_3\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 Module R A\n---\ncase refine_4\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 SMulCommClass R A A\n---\ncase refine_5\nR : Type u\nA : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra R A\na : A\nh : _root_.IsNilpotent a\nhl : sorry\nhr : sorry\n\u22a2 IsScalarTower R A A"}, {"line": "exact this.isNilpotent_sub hl hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.LieSubalgebra.isNilpotent_ad_of_isNilpotent_ad {L : Type v} [LieRing L]\n    [LieAlgebra R L] (K : LieSubalgebra R L) {x : K} (h : IsNilpotent (LieAlgebra.ad R L \u2191x)) :\n    IsNilpotent (LieAlgebra.ad R K x) := by\n  obtain \u27e8n, hn\u27e9 := h\n  use n\n  exact Module.End.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Nilpotent.lean", "context": {"open": ["LieModule", "LieAlgebra", "LieModule Function", "LieRing", "LieModule (lowerCentralSeries)", "LieModule"], "variables": ["{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(k : \u2115) (N : LieSubmodule R L M)", "(R L M)", "[LieModule R L M]", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "(R L M)", "[LieModule R L M]", "{R L M}", "[LieModule R L M]", "{R L} in", "{R L M}", "[LieModule R L M]", "(R L M)", "[LieModule R L M]", "[LieModule R L M]", "{N\u2081 N\u2082 : LieSubmodule R L M}", "[LieModule R L M]", "(R) in", "[LieModule R L M]", "{L\u2082 M\u2082 : Type*} [LieRing L\u2082] [LieAlgebra R L\u2082]", "[AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L\u2082 M\u2082]", "{f : L \u2192\u2097\u2045R\u2046 L\u2082} {g : M \u2192\u2097[R] M\u2082}", "(hfg : \u2200 x m, \u2045f x, g m\u2046 = g \u2045x, m\u2046)", "[LieModule R L\u2082 M\u2082] (hg_inj : Injective g)", "(hf_surj : Surjective f) (hg_surj : Surjective g)", "(R L M)", "[LieModule R L M]", "(R : Type u) (L : Type v) (L' : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [LieRing L'] [LieAlgebra R L']", "{R L L'}", "{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L] (I : LieIdeal R L)", "(M : Type*) [AddCommGroup M] [Module R M] [LieRingModule L M]", "(k : \u2115)", "(R : Type u) {A : Type v} [CommRing R] [Ring A] [Algebra R A]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommRing R\nL : Type v\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nK : LieSubalgebra R L\nx : \u21a5K\nh : _root_.IsNilpotent ((ad R L) \u2191x)\n\u22a2 _root_.IsNilpotent ((ad R \u21a5K) x)"}, {"line": "obtain \u27e8n, hn\u27e9 := h", "tactic_state": "case intro\nR : Type u\ninst\u271d\u00b2 : CommRing R\nL : Type v\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nK : LieSubalgebra R L\nx : \u21a5K\nn : \u2115\nhn : (ad R L) \u2191x ^ n = 0\n\u22a2 _root_.IsNilpotent ((ad R \u21a5K) x)"}, {"line": "use n", "tactic_state": "case h\nR : Type u\ninst\u271d\u00b2 : CommRing R\nL : Type v\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nK : LieSubalgebra R L\nx : \u21a5K\nn : \u2115\nhn : (ad R L) \u2191x ^ n = 0\n\u22a2 (ad R \u21a5K) x ^ n = 0"}, {"line": "exact Module.End.submodule_pow_eq_zero_of_pow_eq_zero (K.ad_comp_incl_eq x) hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma LieModule.toEnd_lie (x y : L) (z : M) :\n    (\u03c6 x) \u2045y, z\u2046 = \u2045ad R L x y, z\u2046 + \u2045y, \u03c6 x z\u2046 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/OfAssociative.lean", "context": {"open": ["Function", "LieAlgebra LieModule"], "variables": ["{A : Type v} [Ring A]", "{M : Type w} [AddCommGroup M] [Module A M]", "{R : Type u} [CommRing R] [Algebra R A]", "{M : Type w} [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M]", "{B : Type w} {C : Type w\u2081} [Ring B] [Ring C] [Algebra R B] [Algebra R C]", "(f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C)", "(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M] [LieModule R L M]", "{R L} in", "{L M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx\u271d : Sort u_1\n\u03c6 : x\u271d\nx y : L\nz : M\n\u22a2 sorry = \u2045((ad R L) x) y, z\u2046 + \u2045y, sorry\u2046"}, {"line": "simp", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nx\u271d : Sort u_1\n\u03c6 : x\u271d\nx y : L\nz : M\n\u22a2 sorry () = \u2045x, \u2045y, z\u2046\u2046 - \u2045y, \u2045x, z\u2046\u2046 + \u2045y, sorry ()\u2046"}]}
{"declaration": "theorem coe_map_toEnd_le :\n    (N : Submodule R M).map (LieModule.toEnd R L M x) \u2264 N := by\n  rintro n \u27e8m, hm, rfl\u27e9\n  exact N.lie_mem hm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/OfAssociative.lean", "context": {"open": ["Function", "LieAlgebra LieModule", "Finset in", "Finset in", "LieModule Set"], "variables": ["{A : Type v} [Ring A]", "{M : Type w} [AddCommGroup M] [Module A M]", "{R : Type u} [CommRing R] [Algebra R A]", "{M : Type w} [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M]", "{B : Type w} {C : Type w\u2081} [Ring B] [Ring C] [Algebra R B] [Algebra R C]", "(f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C)", "(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M] [LieModule R L M]", "{R L} in", "{L M}", "{R L M}", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "{N : LieSubmodule R L M} {x : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nN : LieSubmodule R L M\nx : L\n\u22a2 Submodule.map ((toEnd R L M) x) \u2191N \u2264 \u2191N"}, {"line": "rintro n \u27e8m, hm, rfl\u27e9", "tactic_state": "case intro.intro\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nN : LieSubmodule R L M\nx : L\nm : M\nhm : m \u2208 \u2191\u2191N\n\u22a2 ((toEnd R L M) x) m \u2208 \u2191N"}, {"line": "exact N.lie_mem hm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toEnd_comp_subtype_mem (m : M) (hm : m \u2208 (N : Submodule R M)) :\n    (toEnd R L M x).comp (N : Submodule R M).subtype \u27e8m, hm\u27e9 \u2208 (N : Submodule R M) := by\n  simpa using N.lie_mem hm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/OfAssociative.lean", "context": {"open": ["Function", "LieAlgebra LieModule", "Finset in", "Finset in", "LieModule Set"], "variables": ["{A : Type v} [Ring A]", "{M : Type w} [AddCommGroup M] [Module A M]", "{R : Type u} [CommRing R] [Algebra R A]", "{M : Type w} [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M]", "{B : Type w} {C : Type w\u2081} [Ring B] [Ring C] [Algebra R B] [Algebra R C]", "(f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C)", "(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [LieAlgebra R L] [AddCommGroup M] [Module R M]", "[LieRingModule L M] [LieModule R L M]", "{R L} in", "{L M}", "{R L M}", "{M\u2082 : Type w\u2081} [AddCommGroup M\u2082] [Module R M\u2082] [LieRingModule L M\u2082] [LieModule R L M\u2082]", "{N : LieSubmodule R L M} {x : L}", "(N x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : LieAlgebra R L\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : LieRingModule L M\ninst\u271d : LieModule R L M\nN : LieSubmodule R L M\nx : L\nm : M\nhm : m \u2208 \u2191N\n\u22a2 ((toEnd R L M) x \u2218\u2097 (\u2191N).subtype) \u27e8m, hm\u27e9 \u2208 \u2191N"}, {"line": "simpa using N.lie_mem hm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lie_h_e_smul (t : IsSl2Triple h e f) : \u2045h, e\u2046 = (2 : R) \u2022 e := by\n  simp [t.lie_h_e_nsmul, two_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Sl2.lean", "context": {"open": ["LieModule Set"], "variables": ["(R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]", "{L} in", "{L M}", "{h e f : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 \u2045h, e\u2046 = 2 \u2022 e"}, {"line": "simp [t.lie_h_e_nsmul, two_smul]", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 \u2045h, e\u2046 = e + e"}]}
{"declaration": "lemma lie_lie_smul_f (t : IsSl2Triple h e f) : \u2045h, f\u2046 = -((2 : R) \u2022 f) := by\n  simp [t.lie_h_f_nsmul, two_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Sl2.lean", "context": {"open": ["LieModule Set"], "variables": ["(R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]", "{L} in", "{L M}", "{h e f : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 \u2045h, f\u2046 = -(2 \u2022 f)"}, {"line": "simp [t.lie_h_f_nsmul, two_smul]", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 \u2045h, f\u2046 = -(f + f)"}]}
{"declaration": "lemma e_ne_zero (t : IsSl2Triple h e f) : e \u2260 0 := by\n  have := t.h_ne_zero\n  contrapose! this\n  simpa [this] using t.lie_e_f.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Sl2.lean", "context": {"open": ["LieModule Set"], "variables": ["(R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]", "{L} in", "{L M}", "{h e f : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 e \u2260 0"}, {"line": "have := t.h_ne_zero", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\nthis : h \u2260 0\n\u22a2 e \u2260 0"}, {"line": "contrapose! this", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\nthis : e = 0\n\u22a2 h = 0"}, {"line": "simpa [this] using t.lie_e_f.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma f_ne_zero (t : IsSl2Triple h e f) : f \u2260 0 := by\n  have := t.h_ne_zero\n  contrapose! this\n  simpa [this] using t.lie_e_f.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Sl2.lean", "context": {"open": ["LieModule Set"], "variables": ["(R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]", "{L} in", "{L M}", "{h e f : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\n\u22a2 f \u2260 0"}, {"line": "have := t.h_ne_zero", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\nthis : h \u2260 0\n\u22a2 f \u2260 0"}, {"line": "contrapose! this", "tactic_state": "L : Type u_2\ninst\u271d : LieRing L\nh e f : L\nt : IsSl2Triple h e f\nthis : f = 0\n\u22a2 h = 0"}, {"line": "simpa [this] using t.lie_e_f.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubmodule_mk (p : Submodule R L) (h) :\n    (({ p with lie_mem' := h } : LieSubalgebra R L) : Submodule R L) = p := by\n  cases p\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Subalgebra.lean", "context": {"open": [], "variables": ["(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L]", "{R\u2081 : Type*} [Semiring R\u2081]", "{R L}", "(L' : LieSubalgebra R L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\np : Submodule R L\nh : \u2200 {x y : L}, x \u2208 p.carrier \u2192 y \u2208 p.carrier \u2192 \u2045x, y\u2046 \u2208 p.carrier\n\u22a2 { toSubmodule := p, lie_mem' := h }.toSubmodule = p"}, {"line": "cases p", "tactic_state": "case mk\nR : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\ntoAddSubmonoid\u271d : AddSubmonoid L\nsmul_mem'\u271d : \u2200 (c : R) {x : L}, x \u2208 toAddSubmonoid\u271d.carrier \u2192 c \u2022 x \u2208 toAddSubmonoid\u271d.carrier\nh :\n  \u2200 {x y : L},\n    x \u2208 { toAddSubmonoid := toAddSubmonoid\u271d, smul_mem' := smul_mem'\u271d }.carrier \u2192\n      y \u2208 { toAddSubmonoid := toAddSubmonoid\u271d, smul_mem' := smul_mem'\u271d }.carrier \u2192\n        \u2045x, y\u2046 \u2208 { toAddSubmonoid := toAddSubmonoid\u271d, smul_mem' := smul_mem'\u271d }.carrier\n\u22a2 { toAddSubmonoid := toAddSubmonoid\u271d, smul_mem' := smul_mem'\u271d, lie_mem' := h }.toSubmodule =\n    { toAddSubmonoid := toAddSubmonoid\u271d, smul_mem' := smul_mem'\u271d }"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_bot_iff : K = \u22a5 \u2194 \u2200 x : L, x \u2208 K \u2192 x = 0 := by\n  rw [_root_.eq_bot_iff]\n  exact Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Subalgebra.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L]", "{R\u2081 : Type*} [Semiring R\u2081]", "{R L}", "(L' : LieSubalgebra R L)", "{M : Type w} [AddCommGroup M] [LieRingModule L M]", "{N : Type w\u2081} [AddCommGroup N] [LieRingModule L N] [Module R N]", "[Module R M]", "{R L}", "{L\u2082 : Type w} [LieRing L\u2082] [LieAlgebra R L\u2082]", "(f : L \u2192\u2097\u2045R\u2046 L\u2082)", "(K K' : LieSubalgebra R L) (K\u2082 : LieSubalgebra R L\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nK : LieSubalgebra R L\n\u22a2 K = \u22a5 \u2194 \u2200 x \u2208 K, x = 0"}, {"line": "rw [_root_.eq_bot_iff]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\nK : LieSubalgebra R L\n\u22a2 K \u2264 \u22a5 \u2194 \u2200 x \u2208 K, x = 0"}, {"line": "exact Iff.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submodule_span_le_lieSpan : Submodule.span R s \u2264 lieSpan R L s := by\n  rw [Submodule.span_le]\n  apply subset_lieSpan\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Subalgebra.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L]", "{R\u2081 : Type*} [Semiring R\u2081]", "{R L}", "(L' : LieSubalgebra R L)", "{M : Type w} [AddCommGroup M] [LieRingModule L M]", "{N : Type w\u2081} [AddCommGroup N] [LieRingModule L N] [Module R N]", "[Module R M]", "{R L}", "{L\u2082 : Type w} [LieRing L\u2082] [LieAlgebra R L\u2082]", "(f : L \u2192\u2097\u2045R\u2046 L\u2082)", "(K K' : LieSubalgebra R L) (K\u2082 : LieSubalgebra R L\u2082)", "(R L)", "{R L K K' f}", "(h : K \u2264 K')", "(R L) (s : Set L)", "{R L s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\ns : Set L\nx\u271d : Sort u_2\nlieSpan : x\u271d\n\u22a2 Submodule.span R s \u2264 sorry"}, {"line": "rw [Submodule.span_le]", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\ns : Set L\nx\u271d : Sort u_2\nlieSpan : x\u271d\n\u22a2 s \u2286 \u2191sorry"}, {"line": "apply subset_lieSpan", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lieSpan_induction {p : (x : L) \u2192 x \u2208 lieSpan R L s \u2192 Prop}\n    (mem : \u2200 (x) (h : x \u2208 s), p x (subset_lieSpan h))\n    (zero : p 0 (LieSubalgebra.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (LieSubalgebra.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (smul : \u2200 (a : R) (x hx), p x hx \u2192 p (a \u2022 x) (LieSubalgebra.smul_mem _ _ \u2039_\u203a)) {x}\n    (lie : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (\u2045x, y\u2046) (LieSubalgebra.lie_mem _ \u2039_\u203a \u2039_\u203a))\n    (hx : x \u2208 lieSpan R L s) : p x hx := by\n  let p : LieSubalgebra R L :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9\n      lie_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, lie _ _ _ _ hpx hpy\u27e9 }\n  exact lieSpan_le (K := p) |>.mpr (fun y hy \u21a6 \u27e8subset_lieSpan hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Subalgebra.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) [CommRing R] [LieRing L] [LieAlgebra R L]", "{R\u2081 : Type*} [Semiring R\u2081]", "{R L}", "(L' : LieSubalgebra R L)", "{M : Type w} [AddCommGroup M] [LieRingModule L M]", "{N : Type w\u2081} [AddCommGroup N] [LieRingModule L N] [Module R N]", "[Module R M]", "{R L}", "{L\u2082 : Type w} [LieRing L\u2082] [LieAlgebra R L\u2082]", "(f : L \u2192\u2097\u2045R\u2046 L\u2082)", "(K K' : LieSubalgebra R L) (K\u2082 : LieSubalgebra R L\u2082)", "(R L)", "{R L K K' f}", "(h : K \u2264 K')", "(R L) (s : Set L)", "{R L s}", "(R L)", "{L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\ns : Set L\nx\u271d\u00b9 : Sort u_2\nlieSpan : x\u271d\u00b9\nx\u271d : Sort u_3\nsubset_lieSpan : x\u271d\np : (x : L) \u2192 x \u2208 sorry \u2192 Prop\nmem : \u2200 x \u2208 s, p x \u22ef\nzero : p 0 \u22ef\nadd : \u2200 (x y : L) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p x hx \u2192 p y hy \u2192 p (x + y) \u22ef\nsmul : \u2200 (a : R) (x : L) (hx : x \u2208 sorry), p x hx \u2192 p (a \u2022 x) \u22ef\nx : L\nlie : \u2200 (x y : L) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p x hx \u2192 p y hy \u2192 p \u2045x, y\u2046 \u22ef\nhx : x \u2208 sorry\n\u22a2 p x hx"}, {"line": "let p : LieSubalgebra R L :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9\n      lie_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, lie _ _ _ _ hpx hpy\u27e9 }", "tactic_state": "R : Type u\nL : Type v\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\ns : Set L\nx\u271d\u00b9 : Sort u_2\nlieSpan : x\u271d\u00b9\nx\u271d : Sort u_3\nsubset_lieSpan : x\u271d\np\u271d : (x : L) \u2192 x \u2208 sorry \u2192 Prop\nmem : \u2200 x \u2208 s, p\u271d x \u22ef\nzero : p\u271d 0 \u22ef\nadd : \u2200 (x y : L) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p\u271d x hx \u2192 p\u271d y hy \u2192 p\u271d (x + y) \u22ef\nsmul : \u2200 (a : R) (x : L) (hx : x \u2208 sorry), p\u271d x hx \u2192 p\u271d (a \u2022 x) \u22ef\nx : L\nlie : \u2200 (x y : L) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p\u271d x hx \u2192 p\u271d y hy \u2192 p\u271d \u2045x, y\u2046 \u22ef\nhx : x \u2208 sorry\np : sorry := sorry\n\u22a2 p\u271d x hx"}, {"line": "exact lieSpan_le (K := p) |>.mpr (fun y hy \u21a6 \u27e8subset_lieSpan hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submodule.exists_lieSubmodule_coe_eq_iff (p : Submodule R M) :\n    (\u2203 N : LieSubmodule R L M, \u2191N = p) \u2194 \u2200 (x : L) (m : M), m \u2208 p \u2192 \u2045x, m\u2046 \u2208 p := by\n  constructor\n  \u00b7 rintro \u27e8N, rfl\u27e9 _ _; exact N.lie_mem\n  \u00b7 intro h; use { p with lie_mem := @h }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": [], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L M\np : Submodule R M\n\u22a2 (\u2203 N, \u2191N = p) \u2194 \u2200 (x : L), \u2200 m \u2208 p, \u2045x, m\u2046 \u2208 p"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L M\np : Submodule R M\n\u22a2 (\u2203 N, \u2191N = p) \u2192 \u2200 (x : L), \u2200 m \u2208 p, \u2045x, m\u2046 \u2208 p\n---\ncase mpr\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L M\np : Submodule R M\n\u22a2 (\u2200 (x : L), \u2200 m \u2208 p, \u2045x, m\u2046 \u2208 p) \u2192 \u2203 N, \u2191N = p"}, {"line": "\u00b7 rintro \u27e8N, rfl\u27e9 _ _; exact N.lie_mem", "tactic_state": "case mpr\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : LieRing L\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : LieRingModule L M\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieModule R L M\np : Submodule R M\n\u22a2 (\u2200 (x : L), \u2200 m \u2208 p, \u2045x, m\u2046 \u2208 p) \u2192 \u2203 N, \u2191N = p"}, {"line": "\u00b7 intro h; use { p with lie_mem := @h }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_toSubmodule :\n    (\u2191(N \u2294 N') : Submodule R M) = (N : Submodule R M) \u2294 (N' : Submodule R M) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nN N' : LieSubmodule R L M\n\u22a2 \u2191(N \u2294 N') = \u2191N \u2294 \u2191N'"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_induction {\u03b9} (N : \u03b9 \u2192 LieSubmodule R L M) {motive : M \u2192 Prop} {x : M}\n    (hx : x \u2208 \u2a06 i, N i) (mem : \u2200 i, \u2200 y \u2208 N i, motive y) (zero : motive 0)\n    (add : \u2200 y z, motive y \u2192 motive z \u2192 motive (y + z)) : motive x := by\n  rw [\u2190 LieSubmodule.mem_toSubmodule] at hx\n  rw [LieSubmodule.iSup_toSubmodule] at hx\n  exact Submodule.iSup_induction (motive := motive) (fun i \u21a6 (N i : Submodule R M)) hx mem zero add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\n\u03b9 : Sort u_1\nN : \u03b9 \u2192 LieSubmodule R L M\nmotive : M \u2192 Prop\nx : M\nhx : x \u2208 \u2a06 i, N i\nmem : \u2200 (i : \u03b9), \u2200 y \u2208 N i, motive y\nzero : motive 0\nadd : \u2200 (y z : M), motive y \u2192 motive z \u2192 motive (y + z)\n\u22a2 motive x"}, {"line": "rw [\u2190 LieSubmodule.mem_toSubmodule] at hx", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\n\u03b9 : Sort u_1\nN : \u03b9 \u2192 LieSubmodule R L M\nmotive : M \u2192 Prop\nx : M\nhx : x \u2208 \u2191(\u2a06 i, N i)\nmem : \u2200 (i : \u03b9), \u2200 y \u2208 N i, motive y\nzero : motive 0\nadd : \u2200 (y z : M), motive y \u2192 motive z \u2192 motive (y + z)\n\u22a2 motive x"}, {"line": "rw [LieSubmodule.iSup_toSubmodule] at hx", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\n\u03b9 : Sort u_1\nN : \u03b9 \u2192 LieSubmodule R L M\nmotive : M \u2192 Prop\nx : M\nhx : x \u2208 \u2a06 i, \u2191(N i)\nmem : \u2200 (i : \u03b9), \u2200 y \u2208 N i, motive y\nzero : motive 0\nadd : \u2200 (y z : M), motive y \u2192 motive z \u2192 motive (y + z)\n\u22a2 motive x"}, {"line": "exact Submodule.iSup_induction (motive := motive) (fun i \u21a6 (N i : Submodule R M)) hx mem zero add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submodule_span_le_lieSpan : Submodule.span R s \u2264 lieSpan R L s := by\n  rw [Submodule.span_le]\n  apply subset_lieSpan\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\n\u22a2 Submodule.span R s \u2264 sorry"}, {"line": "rw [Submodule.span_le]", "tactic_state": "R : Type u\nM : Type w\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\n\u22a2 s \u2286 \u2191sorry"}, {"line": "apply subset_lieSpan", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lieSpan_le {N} : lieSpan R L s \u2264 N \u2194 s \u2286 N := by\n  constructor\n  \u00b7 exact Subset.trans subset_lieSpan\n  \u00b7 intro hs m hm; rw [mem_lieSpan] at hm; exact hm _ hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type w\ninst\u271d : AddCommGroup M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\nN : Set M\n\u22a2 sorry \u2264 N \u2194 s \u2286 N"}, {"line": "constructor", "tactic_state": "case mp\nM : Type w\ninst\u271d : AddCommGroup M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\nN : Set M\n\u22a2 sorry \u2264 N \u2192 s \u2286 N\n---\ncase mpr\nM : Type w\ninst\u271d : AddCommGroup M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\nN : Set M\n\u22a2 s \u2286 N \u2192 sorry \u2264 N"}, {"line": "\u00b7 exact Subset.trans subset_lieSpan", "tactic_state": "case mpr\nM : Type w\ninst\u271d : AddCommGroup M\ns : Set M\nx\u271d : Sort u_1\nlieSpan : x\u271d\nN : Set M\n\u22a2 s \u2286 N \u2192 sorry \u2264 N"}, {"line": "\u00b7 intro hs m hm; rw [mem_lieSpan] at hm; exact hm _ hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lieSpan_induction {p : (x : M) \u2192 x \u2208 lieSpan R L s \u2192 Prop}\n    (mem : \u2200 (x) (h : x \u2208 s), p x (subset_lieSpan h))\n    (zero : p 0 (LieSubmodule.zero_mem _))\n    (add : \u2200 x y hx hy, p x hx \u2192 p y hy \u2192 p (x + y) (add_mem \u2039_\u203a \u2039_\u203a))\n    (smul : \u2200 (a : R) (x hx), p x hx \u2192 p (a \u2022 x) (SMulMemClass.smul_mem _ hx)) {x}\n    (lie : \u2200 (x : L) (y hy), p y hy \u2192 p (\u2045x, y\u2046) (LieSubmodule.lie_mem _ \u2039_\u203a))\n    (hx : x \u2208 lieSpan R L s) : p x hx := by\n  let p : LieSubmodule R L M :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9\n      lie_mem := fun \u27e8_, hpy\u27e9 \u21a6 \u27e8_, lie _ _ _ hpy\u27e9 }\n  exact lieSpan_le (N := p) |>.mpr (fun y hy \u21a6 \u27e8subset_lieSpan hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}", "(R L M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\ns : Set M\nx\u271d\u00b9 : Sort u_1\nlieSpan : x\u271d\u00b9\nx\u271d : Sort u_2\nsubset_lieSpan : x\u271d\np : (x : M) \u2192 x \u2208 sorry \u2192 Prop\nmem : \u2200 x \u2208 s, p x \u22ef\nzero : p 0 \u22ef\nadd : \u2200 (x y : M) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p x hx \u2192 p y hy \u2192 p (x + y) \u22ef\nsmul : \u2200 (a : R) (x : M) (hx : x \u2208 sorry), p x hx \u2192 p (a \u2022 x) \u22ef\nx : M\nlie : \u2200 (x : L) (y : M) (hy : y \u2208 sorry), p y hy \u2192 p \u2045x, y\u2046 \u22ef\nhx : x \u2208 sorry\n\u22a2 p x hx"}, {"line": "let p : LieSubmodule R L M :=\n    { carrier := { x | \u2203 hx, p x hx }\n      add_mem' := fun \u27e8_, hpx\u27e9 \u27e8_, hpy\u27e9 \u21a6 \u27e8_, add _ _ _ _ hpx hpy\u27e9\n      zero_mem' := \u27e8_, zero\u27e9\n      smul_mem' := fun r \u21a6 fun \u27e8_, hpx\u27e9 \u21a6 \u27e8_, smul r _ _ hpx\u27e9\n      lie_mem := fun \u27e8_, hpy\u27e9 \u21a6 \u27e8_, lie _ _ _ hpy\u27e9 }", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\ns : Set M\nx\u271d\u00b9 : Sort u_1\nlieSpan : x\u271d\u00b9\nx\u271d : Sort u_2\nsubset_lieSpan : x\u271d\np\u271d : (x : M) \u2192 x \u2208 sorry \u2192 Prop\nmem : \u2200 x \u2208 s, p\u271d x \u22ef\nzero : p\u271d 0 \u22ef\nadd : \u2200 (x y : M) (hx : x \u2208 sorry) (hy : y \u2208 sorry), p\u271d x hx \u2192 p\u271d y hy \u2192 p\u271d (x + y) \u22ef\nsmul : \u2200 (a : R) (x : M) (hx : x \u2208 sorry), p\u271d x hx \u2192 p\u271d (a \u2022 x) \u22ef\nx : M\nlie : \u2200 (x : L) (y : M) (hy : y \u2208 sorry), p\u271d y hy \u2192 p\u271d \u2045x, y\u2046 \u22ef\nhx : x \u2208 sorry\np : sorry := sorry\n\u22a2 p\u271d x hx"}, {"line": "exact lieSpan_le (N := p) |>.mpr (fun y hy \u21a6 \u27e8subset_lieSpan hy, mem y hy\u27e9) hx |>.elim fun _ \u21a6 id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_incl_top : (\u22a4 : LieSubmodule R L N).map N.incl = N := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}", "(R L M)", "{M}", "{R : Type u} {L : Type v} {L' : Type w\u2082} {M : Type w} {M' : Type w\u2081}", "[CommRing R] [LieRing L] [LieRing L'] [LieAlgebra R L']", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup M'] [Module R M'] [LieRingModule L M']", "(f : M \u2192\u2097\u2045R,L\u2046 M') (N N\u2082 : LieSubmodule R L M) (N' : LieSubmodule R L M')", "{f N N\u2082 N'}", "(f) in", "(N) in", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N]", "(f : M \u2192\u2097\u2045R,L\u2046 N)", "{f}", "(f)", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "(N : LieSubmodule R L M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nN : LieSubmodule R L M\n\u22a2 LieSubmodule.map N.incl \u22a4 = N"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_le_range {M' : Type*}\n    [AddCommGroup M'] [Module R M'] [LieRingModule L M'] (f : M \u2192\u2097\u2045R,L\u2046 M') :\n    N.map f \u2264 f.range := by\n  rw [\u2190 LieModuleHom.map_top]\n  exact LieSubmodule.map_mono le_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}", "(R L M)", "{M}", "{R : Type u} {L : Type v} {L' : Type w\u2082} {M : Type w} {M' : Type w\u2081}", "[CommRing R] [LieRing L] [LieRing L'] [LieAlgebra R L']", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup M'] [Module R M'] [LieRingModule L M']", "(f : M \u2192\u2097\u2045R,L\u2046 M') (N N\u2082 : LieSubmodule R L M) (N' : LieSubmodule R L M')", "{f N N\u2082 N'}", "(f) in", "(N) in", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N]", "(f : M \u2192\u2097\u2045R,L\u2046 N)", "{f}", "(f)", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "(N : LieSubmodule R L M)", "{N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\nN : LieSubmodule R L M\nM' : Type u_1\ninst\u271d\u00b2 : AddCommGroup M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : LieRingModule L M'\nf : M \u2192\u2097\u2045R,L\u2046 M'\n\u22a2 LieSubmodule.map f N \u2264 f.range"}, {"line": "rw [\u2190 LieModuleHom.map_top]", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : LieRingModule L M\nN : LieSubmodule R L M\nM' : Type u_1\ninst\u271d\u00b2 : AddCommGroup M'\ninst\u271d\u00b9 : Module R M'\ninst\u271d : LieRingModule L M'\nf : M \u2192\u2097\u2045R,L\u2046 M'\n\u22a2 LieSubmodule.map f N \u2264 LieSubmodule.map f \u22a4"}, {"line": "exact LieSubmodule.map_mono le_top", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_incl_lt_iff_lt_top {N' : LieSubmodule R L N} :\n    N'.map (LieSubmodule.incl N) < N \u2194 N' < \u22a4 := by\n  convert (LieSubmodule.mapOrderEmbedding (f := N.incl) Subtype.coe_injective).lt_iff_lt\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Submodule.lean", "context": {"open": ["Set"], "variables": ["(R : Type u) (L : Type v) (M : Type w)", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "{R L M}", "(N N' : LieSubmodule R L M)", "[LieAlgebra R L] [LieModule R L M]", "{R M}", "{L}", "[LieAlgebra R L]", "(K : LieSubalgebra R L)", "{K}", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L] [AddCommGroup M] [Module R M]", "[LieRingModule L M]", "(N N' : LieSubmodule R L M)", "{N N'}", "(N N')", "(R L M)", "{R L M}", "{N N'}", "(h : N \u2264 N')", "(R L) (s : Set M)", "{R L s}", "(R L M)", "{M}", "{R : Type u} {L : Type v} {L' : Type w\u2082} {M : Type w} {M' : Type w\u2081}", "[CommRing R] [LieRing L] [LieRing L'] [LieAlgebra R L']", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup M'] [Module R M'] [LieRingModule L M']", "(f : M \u2192\u2097\u2045R,L\u2046 M') (N N\u2082 : LieSubmodule R L M) (N' : LieSubmodule R L M')", "{f N N\u2082 N'}", "(f) in", "(N) in", "{R : Type u} {L : Type v} {M : Type w} {N : Type w\u2081}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "[AddCommGroup N] [Module R N] [LieRingModule L N]", "(f : M \u2192\u2097\u2045R,L\u2046 N)", "{f}", "(f)", "{R : Type u} {L : Type v} {M : Type w}", "[CommRing R] [LieRing L]", "[AddCommGroup M] [Module R M] [LieRingModule L M]", "(N : LieSubmodule R L M)", "{N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nN : LieSubmodule R L M\nN' : LieSubmodule R L \u21a5N\n\u22a2 LieSubmodule.map N.incl N' < N \u2194 N' < \u22a4"}, {"line": "convert (LieSubmodule.mapOrderEmbedding (f := N.incl) Subtype.coe_injective).lt_iff_lt", "tactic_state": "case h.e'_1.h.e'_4\nR : Type u\nL : Type v\nM : Type w\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : LieRing L\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : LieRingModule L M\nN : LieSubmodule R L M\nN' : LieSubmodule R L \u21a5N\n\u22a2 N = (LieSubmodule.mapOrderEmbedding \u22ef) \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_weightSpace (\u03c7 : L \u2192 R) (m : M) : m \u2208 weightSpace M \u03c7 \u2194 \u2200 x, \u2045x, m\u2046 = \u03c7 x \u2022 m := by\n  simp [weightSpace]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u03c7 : L \u2192 R\nm : M\n\u22a2 m \u2208 sorry \u2194 L \u2192 sorry"}, {"line": "simp [weightSpace]", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u03c7 : L \u2192 R\nm : M\n\u22a2 m \u2208 sorry () \u2194 L \u2192 sorry ()"}]}
{"declaration": "theorem mem_genWeightSpaceOf (\u03c7 : R) (x : L) (m : M) :\n    m \u2208 genWeightSpaceOf M \u03c7 x \u2194 \u2203 k : \u2115, ((toEnd R L M x - \u03c7 \u2022 \u21911) ^ k) m = 0 := by\n  simp [genWeightSpaceOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u03c7 : R\nx : L\nm : M\n\u22a2 m \u2208 sorry \u2194 \u2203 k, sorry = 0"}, {"line": "simp [genWeightSpaceOf]", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u03c7 : R\nx : L\nm : M\n\u22a2 m \u2208 sorry () \u2194 sorry () = 0"}]}
{"declaration": "theorem mem_genWeightSpace (\u03c7 : L \u2192 R) (m : M) :\n    m \u2208 genWeightSpace M \u03c7 \u2194 \u2200 x, \u2203 k : \u2115, ((toEnd R L M x - \u03c7 x \u2022 \u21911) ^ k) m = 0 := by\n  simp [genWeightSpace, mem_genWeightSpaceOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\nm : M\n\u22a2 m \u2208 sorry \u2194 L \u2192 \u2203 k, sorry = 0"}, {"line": "simp [genWeightSpace, mem_genWeightSpaceOf]", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u03c7 : L \u2192 R\nm : M\n\u22a2 m \u2208 sorry () \u2194 L \u2192 sorry () = 0"}]}
{"declaration": "lemma ext_iff' {\u03c7\u2081 \u03c7\u2082 : Weight R L M} : (\u03c7\u2081 : L \u2192 R) = \u03c7\u2082 \u2194 \u03c7\u2081 = \u03c7\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]", "(R L) in", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c7\u2081 : sorry\n\u03c7\u2082 : sorry\n\u22a2 sorry = \u03c7\u2082 \u2194 \u03c7\u2081 = \u03c7\u2082"}, {"line": "simp", "tactic_state": "\u03c7\u2081 : sorry\n\u03c7\u2082 : sorry\n\u22a2 sorry () = \u03c7\u2082 \u2194 \u03c7\u2081 = \u03c7\u2082"}]}
{"declaration": "lemma mem_posFittingCompOf (x : L) (m : M) :\n    m \u2208 posFittingCompOf R M x \u2194 \u2200 (k : \u2115), \u2203 n, (toEnd R L M x ^ k) n = m := by\n  simp [posFittingCompOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]", "(R L) in", "{M}", "(R L M) in", "(R) in", "(R L)", "{L}", "{M} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\nx : L\nm : M\n\u22a2 m \u2208 sorry \u2194 \u2200 (k : \u2115), \u2203 n, sorry = m"}, {"line": "simp [posFittingCompOf]", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\nx : L\nm : M\n\u22a2 m \u2208 sorry () \u2194 \u2200 (k : \u2115), \u2203 n, sorry () = m"}]}
{"declaration": "lemma posFittingComp_le_iInf_lowerCentralSeries :\n    posFittingComp R L M \u2264 \u2a05 k, lowerCentralSeries R L M k := by\n  simp [posFittingComp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]", "(R L) in", "{M}", "(R L M) in", "(R) in", "(R L)", "{L}", "{M} in", "(L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2264 \u2a05 k, sorry"}, {"line": "simp [posFittingComp]", "tactic_state": "\u22a2 sorry () \u2264 \u2a05 k, sorry ()"}]}
{"declaration": "lemma map_genWeightSpace_eq (e : M \u2243\u2097\u2045R,L\u2046 M\u2082) :\n    (genWeightSpace M \u03c7).map e = genWeightSpace M\u2082 \u03c7 := by\n  simp [map_genWeightSpace_eq_of_injective e.injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]", "(R L) in", "{M}", "(R L M) in", "(R) in", "(R L)", "{L}", "{M} in", "(L)", "{R L M}", "", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2082 : Type u_5\nx\u271d\u00b9 : Type u_6\nx\u271d : Type u_7\n\u03c7 : x\u271d\u00b9 \u2192 x\u271d\ne : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [map_genWeightSpace_eq_of_injective e.injective]", "tactic_state": "M\u2082 : Type u_5\nx\u271d\u00b9 : Type u_6\nx\u271d : Type u_7\n\u03c7 : x\u271d\u00b9 \u2192 x\u271d\ne : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma isCompl_genWeightSpace_zero_posFittingComp :\n    IsCompl (genWeightSpace M 0) (posFittingComp R L M) := by\n  let P : LieSubmodule R L M \u2192 Prop := fun N \u21a6 IsCompl (genWeightSpace N 0) (posFittingComp R L N)\n  suffices P \u22a4 by\n    let e := LieModuleEquiv.ofTop R L M\n    rw [\u2190 map_genWeightSpace_eq e]\n    rw [\u2190 map_posFittingComp_eq e]\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mp this\n  refine (LieSubmodule.wellFoundedLT_of_isArtinian R L M).induction (C := P) _ fun N hN \u21a6 ?_\n  refine isCompl_genWeightSpace_zero_posFittingComp_aux R L N fun N' hN' \u21a6 ?_\n  suffices IsCompl (genWeightSpace (N'.map N.incl) 0) (posFittingComp R L (N'.map N.incl)) by\n    let e := LieSubmodule.equivMapOfInjective N' N.injective_incl\n    rw [\u2190 map_genWeightSpace_eq e] at this\n    rw [\u2190 map_posFittingComp_eq e] at this\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mpr this\n  exact hN _ (LieSubmodule.map_incl_lt_iff_lt_top.mpr hN')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Basic.lean", "context": {"open": ["Set Function TensorProduct LieModule"], "variables": ["{K R L M : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "(M) in", "(M)", "(M)", "[LieRing.IsNilpotent L]", "(R L) in", "{M}", "(R L M) in", "(R) in", "(R L)", "{L}", "{M} in", "(L)", "{R L M}", "", "{f}", "[IsNoetherian R M] [IsArtinian R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 IsCompl sorry sorry"}, {"line": "let P : LieSubmodule R L M \u2192 Prop := fun N \u21a6 IsCompl (genWeightSpace N 0) (posFittingComp R L N)", "tactic_state": "case refine_6\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\nP : sorry \u2192 Prop := fun N => IsCompl sorry sorry\n\u22a2 IsCompl sorry sorry\n---\ncase refine_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 CommRing R\n---\ncase refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 LieRing L\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}, {"line": "suffices P \u22a4 by\n    let e := LieModuleEquiv.ofTop R L M\n    rw [\u2190 map_genWeightSpace_eq e]\n    rw [\u2190 map_posFittingComp_eq e]\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mp this", "tactic_state": "case refine_6\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\nP : sorry \u2192 Prop := fun N => IsCompl sorry sorry\n\u22a2 P sorry\n---\ncase refine_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 CommRing R\n---\ncase refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 LieRing L\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}, {"line": "refine (LieSubmodule.wellFoundedLT_of_isArtinian R L M).induction (C := P) _ fun N hN \u21a6 ?_", "tactic_state": "case refine_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 CommRing R\n---\ncase refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 LieRing L\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}, {"line": "refine isCompl_genWeightSpace_zero_posFittingComp_aux R L N fun N' hN' \u21a6 ?_", "tactic_state": "case refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 LieRing L\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}, {"line": "suffices IsCompl (genWeightSpace (N'.map N.incl) 0) (posFittingComp R L (N'.map N.incl)) by\n    let e := LieSubmodule.equivMapOfInjective N' N.injective_incl\n    rw [\u2190 map_genWeightSpace_eq e] at this\n    rw [\u2190 map_posFittingComp_eq e] at this\n    exact (LieSubmodule.orderIsoMapComap e).isCompl_iff.mpr this", "tactic_state": "case refine_2.refine_6\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 IsCompl sorry sorry\n---\ncase refine_2.refine_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 CommRing R\n---\ncase refine_2.refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 LieRing L\n---\ncase refine_2.refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 AddCommGroup sorry\n---\ncase refine_2.refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 Module R sorry\n---\ncase refine_2.refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 LieRingModule L sorry\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}, {"line": "exact hN _ (LieSubmodule.map_incl_lt_iff_lt_top.mpr hN')", "tactic_state": "case refine_2.refine_1\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 CommRing R\n---\ncase refine_2.refine_2\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 LieRing L\n---\ncase refine_2.refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 AddCommGroup sorry\n---\ncase refine_2.refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 Module R sorry\n---\ncase refine_2.refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 LieRingModule L sorry\n---\ncase refine_3\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 sorry \u2192 AddCommGroup sorry\n---\ncase refine_4\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 Module R sorry\n---\ncase refine_5\nR : Type u_2\nL : Type u_3\nM : Type u_4\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : LieRing L\ninst\u271d\u00b9 : LieAlgebra R L\ninst\u271d : LieRing.IsNilpotent L\n\u22a2 (N : sorry) \u2192 LieRingModule L sorry"}]}
{"declaration": "lemma trace_toEnd_genWeightSpaceChain_eq_zero\n    (hp : genWeightSpace M (p \u2022 \u03b1 + \u03c7) = \u22a5)\n    (hq : genWeightSpace M (q \u2022 \u03b1 + \u03c7) = \u22a5)\n    {x : H} (hx : x \u2208 corootSpace \u03b1) :\n    LinearMap.trace R _ (toEnd R H (genWeightSpaceChain M \u03b1 \u03c7 p q) x) = 0 := by\n  rw [LieAlgebra.mem_corootSpace'] at hx\n  induction hx using Submodule.span_induction\n  \u00b7 next u hu =>\n    obtain \u27e8y, hy, z, hz, hyz\u27e9 := hu\n    let f : Module.End R (genWeightSpaceChain M \u03b1 \u03c7 p q) :=\n      { toFun := fun \u27e8m, hm\u27e9 \u21a6 \u27e8\u2045(y : L), m\u2046,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right M \u03b1 \u03c7 p q hq hy hm\u27e9\n        map_add' := fun _ _ \u21a6 by simp\n        map_smul' := fun t m \u21a6 by simp }\n    let g : Module.End R (genWeightSpaceChain M \u03b1 \u03c7 p q) :=\n      { toFun := fun \u27e8m, hm\u27e9 \u21a6 \u27e8\u2045(z : L), m\u2046,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_left M \u03b1 \u03c7 p q hp hz hm\u27e9\n        map_add' := fun _ _ \u21a6 by simp\n        map_smul' := fun t m \u21a6 by simp }\n    have hfg : toEnd R H _ u = \u2045f, g\u2046 := by\n      ext\n      rw [toEnd_apply_apply]\n      rw [LieSubmodule.coe_bracket]\n      rw [LieSubalgebra.coe_bracket_of_module]\n      rw [\u2190 hyz]\n      simp only [lie_lie]\n      simp only [LieHom.lie_apply]\n      simp only [LinearMap.coe_mk]\n      simp only [AddHom.coe_mk]\n      simp only [Module.End.lie_apply]\n      simp only [AddSubgroupClass.coe_sub]\n      simp only [f]\n      simp only [g]\n    simp [hfg]\n  \u00b7 simp\n  \u00b7 simp_all\n  \u00b7 simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Chain.lean", "context": {"open": ["Module Function Set", "LieAlgebra"], "variables": ["{R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]", "[LieRing.IsNilpotent L] (\u03c7\u2081 \u03c7\u2082 : L \u2192 R) (p q : \u2124)", "[NoZeroSMulDivisors \u2124 R] [NoZeroSMulDivisors R M] [IsNoetherian R M] (h\u03c7\u2081 : \u03c7\u2081 \u2260 0)", "{H : LieSubalgebra R L} (\u03b1 \u03c7 : H \u2192 R) (p q : \u2124)", "[H.IsCartanSubalgebra] [IsNoetherian R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b9 : Sort u_3\ngenWeightSpace : x\u271d\u00b9\nx\u271d : Sort u_4\ntoEnd : x\u271d\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\nhx : x \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0"}, {"line": "rw [LieAlgebra.mem_corootSpace'] at hx", "tactic_state": "R : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b9 : Sort u_3\ngenWeightSpace : x\u271d\u00b9\nx\u271d : Sort u_4\ntoEnd : x\u271d\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\nhx\u271d : x \u2208 corootSpace \u03b1\nhx : x \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx\u271d)) sorry = 0"}, {"line": "induction hx using Submodule.span_induction", "tactic_state": "case mem\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx x\u271d : \u21a5H\nh\u271d : x\u271d \u2208 {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\nhx : x\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase zero\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b9 : Sort u_3\ngenWeightSpace : x\u271d\u00b9\nx\u271d : Sort u_4\ntoEnd : x\u271d\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\nhx : 0 \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase add\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx x\u271d y\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\nhy\u271d : y\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d\u00b9 : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\na\u271d : \u2200 (hx : y\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : x\u271d + y\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase smul\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\na\u271d\u00b9 : R\nx\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : a\u271d\u00b9 \u2022 x\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0"}, {"line": "\u00b7 next u hu =>\n    obtain \u27e8y, hy, z, hz, hyz\u27e9 := hu\n    let f : Module.End R (genWeightSpaceChain M \u03b1 \u03c7 p q) :=\n      { toFun := fun \u27e8m, hm\u27e9 \u21a6 \u27e8\u2045(y : L), m\u2046,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right M \u03b1 \u03c7 p q hq hy hm\u27e9\n        map_add' := fun _ _ \u21a6 by simp\n        map_smul' := fun t m \u21a6 by simp }\n    let g : Module.End R (genWeightSpaceChain M \u03b1 \u03c7 p q) :=\n      { toFun := fun \u27e8m, hm\u27e9 \u21a6 \u27e8\u2045(z : L), m\u2046,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_left M \u03b1 \u03c7 p q hp hz hm\u27e9\n        map_add' := fun _ _ \u21a6 by simp\n        map_smul' := fun t m \u21a6 by simp }\n    have hfg : toEnd R H _ u = \u2045f, g\u2046 := by\n      ext\n      rw [toEnd_apply_apply]\n      rw [LieSubmodule.coe_bracket]\n      rw [LieSubalgebra.coe_bracket_of_module]\n      rw [\u2190 hyz]\n      simp only [lie_lie]\n      simp only [LieHom.lie_apply]\n      simp only [LinearMap.coe_mk]\n      simp only [AddHom.coe_mk]\n      simp only [Module.End.lie_apply]\n      simp only [AddSubgroupClass.coe_sub]\n      simp only [f]\n      simp only [g]\n    simp [hfg]", "tactic_state": "case zero\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b9 : Sort u_3\ngenWeightSpace : x\u271d\u00b9\nx\u271d : Sort u_4\ntoEnd : x\u271d\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\nhx : 0 \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase add\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx x\u271d y\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\nhy\u271d : y\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d\u00b9 : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\na\u271d : \u2200 (hx : y\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : x\u271d + y\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase smul\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\na\u271d\u00b9 : R\nx\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : a\u271d\u00b9 \u2022 x\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0"}, {"line": "\u00b7 simp", "tactic_state": "case add\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx x\u271d y\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\nhy\u271d : y\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d\u00b9 : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\na\u271d : \u2200 (hx : y\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : x\u271d + y\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\n---\ncase smul\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\na\u271d\u00b9 : R\nx\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : a\u271d\u00b9 \u2022 x\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0"}, {"line": "\u00b7 simp_all", "tactic_state": "case smul\nR : Type u_1\nL : Type u_2\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : LieRing.IsNilpotent L\nH : LieSubalgebra R L\n\u03b1 : \u21a5H \u2192 R\ninst\u271d\u00b9 : H.IsCartanSubalgebra\ninst\u271d : IsNoetherian R L\nx\u271d\u00b2 : Sort u_3\ngenWeightSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_4\ntoEnd : x\u271d\u00b9\nhp : sorry = \u22a5\nhq : sorry = \u22a5\nx : \u21a5H\na\u271d\u00b9 : R\nx\u271d : \u21a5H\nhx\u271d : x\u271d \u2208 Submodule.span R {x | \u2203 y \u2208 rootSpace H \u03b1, \u2203 z \u2208 rootSpace H (-\u03b1), \u2045y, z\u2046 = \u2191x}\na\u271d : \u2200 (hx : x\u271d \u2208 corootSpace \u03b1), (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0\nhx : a\u271d\u00b9 \u2022 x\u271d \u2208 corootSpace \u03b1\n\u22a2 (LinearMap.trace R (?m.33410 _fvar.5630 _fvar.5634 \u03b1 _fvar.5751 hp hq hx)) sorry = 0"}, {"line": "\u00b7 simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma traceForm_cartan_nondegenerate\n    [IsNoetherian R L] [IsArtinian R L] (H : LieSubalgebra R L) [H.IsCartanSubalgebra] :\n    (LieModule.traceForm R H L).Nondegenerate := by\n  simp [LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Killing.lean", "context": {"open": [], "variables": ["(R K L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] [Field K] [LieAlgebra K L]", "[IsKilling R L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nL : Type u_3\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : IsNoetherian R L\ninst\u271d\u00b9 : IsArtinian R L\nH : LieSubalgebra R L\ninst\u271d : H.IsCartanSubalgebra\n\u22a2 (LieModule.traceForm R (\u21a5H) L).Nondegenerate"}, {"line": "simp [LinearMap.BilinForm.nondegenerate_iff_ker_eq_bot]", "tactic_state": "R : Type u_1\nL : Type u_3\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 : LieRing L\ninst\u271d\u00b3 : LieAlgebra R L\ninst\u271d\u00b2 : IsNoetherian R L\ninst\u271d\u00b9 : IsArtinian R L\nH : LieSubalgebra R L\ninst\u271d : H.IsCartanSubalgebra\n\u22a2 LinearMap.ker (LieModule.traceForm R (\u21a5H) L) = \u22a5"}]}
{"declaration": "lemma iInf_ker_weight_eq_bot :\n    \u2a05 \u03b1 : Weight K H L, \u03b1.ker = \u22a5 := by\n  rw [\u2190 Subspace.dualAnnihilator_inj]\n  rw [Subspace.dualAnnihilator_iInf_eq]\n  rw [Submodule.dualAnnihilator_bot]\n  simp [\u2190 LinearMap.range_dualMap_eq_dualAnnihilator_ker, \u2190 Submodule.span_range_eq_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Killing.lean", "context": {"open": ["Module LieModule Set", "Submodule (span subset_span)"], "variables": ["(R K L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] [Field K] [LieAlgebra K L]", "[IsKilling R L]", "[Module.Free R L] [Module.Finite R L]", "[FiniteDimensional K L] (H : LieSubalgebra K L) [H.IsCartanSubalgebra]", "[IsTriangularizable K H L]", "[IsKilling K L]", "{K L} in", "{K L H}", "[IsTriangularizable K H L]", "(K L H) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 \u2a05 \u03b1, sorry = \u22a5"}, {"line": "rw [\u2190 Subspace.dualAnnihilator_inj]", "tactic_state": "K : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 (\u2a05 \u03b1, sorry).dualAnnihilator = \u22a5.dualAnnihilator"}, {"line": "rw [Subspace.dualAnnihilator_iInf_eq]", "tactic_state": "K : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 \u2a06 i, sorry.dualAnnihilator = \u22a5.dualAnnihilator\n---\nK : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 Finite (Weight K (\u21a5H) L)"}, {"line": "rw [Submodule.dualAnnihilator_bot]", "tactic_state": "K : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 \u2a06 i, sorry.dualAnnihilator = \u22a4\n---\nK : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 Finite (Weight K (\u21a5H) L)"}, {"line": "simp [\u2190 LinearMap.range_dualMap_eq_dualAnnihilator_ker, \u2190 Submodule.span_range_eq_iSup]", "tactic_state": "K : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 \u2a06 i, (sorry ()).dualAnnihilator = \u22a4\n---\nK : Type u_2\nL : Type u_3\ninst\u271d\u2076 : LieRing L\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : LieAlgebra K L\ninst\u271d\u00b3 : FiniteDimensional K L\nH : LieSubalgebra K L\ninst\u271d\u00b2 : H.IsCartanSubalgebra\ninst\u271d\u00b9 inst\u271d : IsTriangularizable K (\u21a5H) L\n\u22a2 Finite (Weight K (\u21a5H) L)"}]}
{"declaration": "lemma lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg\n    {\u03b1 : Weight K H L} {e f : L} (he\u03b1 : e \u2208 rootSpace H \u03b1) (hf\u03b1 : f \u2208 rootSpace H (-\u03b1)) :\n    \u2045e, f\u2046 = killingForm K L e f \u2022 (cartanEquivDual H).symm \u03b1 := by\n  apply lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux he\u03b1 hf\u03b1\n  exact lie_eq_smul_of_mem_rootSpace he\u03b1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Killing.lean", "context": {"open": ["Module LieModule Set", "Submodule (span subset_span)", "Module.End in"], "variables": ["(R K L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] [Field K] [LieAlgebra K L]", "[IsKilling R L]", "[Module.Free R L] [Module.Finite R L]", "[FiniteDimensional K L] (H : LieSubalgebra K L) [H.IsCartanSubalgebra]", "[IsTriangularizable K H L]", "[IsKilling K L]", "{K L} in", "{K L H}", "[IsTriangularizable K H L]", "(K L H) in", "[PerfectField K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nH : Type u_2\nL : Type u_3\nx\u271d\u00b9 : Sort u_4\nrootSpace : x\u271d\u00b9\nx\u271d : Sort u_5\ncartanEquivDual : x\u271d\n\u03b1 : sorry\ne f : L\nhe\u03b1 : e \u2208 sorry\nhf\u03b1 : f \u2208 sorry\n\u22a2 sorry = sorry \u2022 sorry"}, {"line": "apply lie_eq_killingForm_smul_of_mem_rootSpace_of_mem_rootSpace_neg_aux he\u03b1 hf\u03b1", "tactic_state": "\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.4995} \u2192\n          {cartanEquivDual : ?m.7856} \u2192 {\u03b1 : sorry} \u2192 {e f : L} \u2192 (he\u03b1 : e \u2208 sorry) \u2192 f \u2208 sorry \u2192 Type u_8\n---\n\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.4995} \u2192\n          {cartanEquivDual : ?m.7856} \u2192 {\u03b1 : sorry} \u2192 {e f : L} \u2192 (he\u03b1 : e \u2208 sorry) \u2192 f \u2208 sorry \u2192 Type u_9\n---\n\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.4995} \u2192\n          {cartanEquivDual : ?m.7856} \u2192 {\u03b1 : sorry} \u2192 {e f : L} \u2192 (he\u03b1 : e \u2208 sorry) \u2192 f \u2208 sorry \u2192 Type u_10\n---\n\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.4995} \u2192\n          {cartanEquivDual : ?m.7856} \u2192\n            {\u03b1 : sorry} \u2192\n              {e f : L} \u2192\n                (he\u03b1 : e \u2208 sorry) \u2192 (hf\u03b1 : f \u2208 sorry) \u2192 HSMul (?m.14651 he\u03b1 hf\u03b1) (?m.14652 he\u03b1 hf\u03b1) (?m.14650 he\u03b1 hf\u03b1)"}, {"line": "exact lie_eq_smul_of_mem_rootSpace he\u03b1", "tactic_state": "\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.15278} \u2192\n          {cartanEquivDual : ?m.15279} \u2192 {\u03b1 : sorry} \u2192 {e f : L} \u2192 (he\u03b1 : e \u2208 sorry) \u2192 f \u2208 sorry \u2192 Type u_9\n---\n\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.15278} \u2192\n          {cartanEquivDual : ?m.15279} \u2192 {\u03b1 : sorry} \u2192 {e f : L} \u2192 (he\u03b1 : e \u2208 sorry) \u2192 f \u2208 sorry \u2192 Type u_10\n---\n\u22a2 {K : Type u_1} \u2192\n    {H : Type u_2} \u2192\n      {L : Type u_3} \u2192\n        {rootSpace : ?m.15278} \u2192\n          {cartanEquivDual : ?m.15279} \u2192\n            {\u03b1 : sorry} \u2192\n              {e f : L} \u2192\n                (he\u03b1 : e \u2208 sorry) \u2192 (hf\u03b1 : f \u2208 sorry) \u2192 HSMul (?m.14651 he\u03b1 hf\u03b1) (?m.14652 he\u03b1 hf\u03b1) (sorry he\u03b1 hf\u03b1)"}]}
{"declaration": "lemma coroot_zero [Nontrivial L] : coroot (0 : Weight K H L) = 0 := by simp [Weight.isZero_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Killing.lean", "context": {"open": ["Module LieModule Set", "Submodule (span subset_span)", "Module.End in"], "variables": ["(R K L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] [Field K] [LieAlgebra K L]", "[IsKilling R L]", "[Module.Free R L] [Module.Finite R L]", "[FiniteDimensional K L] (H : LieSubalgebra K L) [H.IsCartanSubalgebra]", "[IsTriangularizable K H L]", "[IsKilling K L]", "{K L} in", "{K L H}", "[IsTriangularizable K H L]", "(K L H) in", "[PerfectField K]", "[CharZero K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_1\nx\u271d : Sort u_2\ncoroot : x\u271d\ninst\u271d : Nontrivial L\n\u22a2 sorry = 0"}, {"line": "simp [Weight.isZero_zero]", "tactic_state": "L : Type u_1\nx\u271d : Sort u_2\ncoroot : x\u271d\ninst\u271d : Nontrivial L\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma corootSpace_eq_bot_iff {\u03b1 : Weight K H L} :\n    corootSpace \u03b1 = \u22a5 \u2194 \u03b1.IsZero := by\n  simp [\u2190 LieSubmodule.toSubmodule_eq_bot, coe_corootSpace_eq_span_singleton \u03b1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Killing.lean", "context": {"open": ["Module LieModule Set", "Submodule (span subset_span)", "Module.End in"], "variables": ["(R K L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] [Field K] [LieAlgebra K L]", "[IsKilling R L]", "[Module.Free R L] [Module.Finite R L]", "[FiniteDimensional K L] (H : LieSubalgebra K L) [H.IsCartanSubalgebra]", "[IsTriangularizable K H L]", "[IsKilling K L]", "{K L} in", "{K L H}", "[IsTriangularizable K H L]", "(K L H) in", "[PerfectField K]", "[CharZero K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nH : Type u_2\nL : Type u_3\nx\u271d : Sort u_4\ncorootSpace : x\u271d\n\u03b1 : sorry\n\u22a2 sorry = \u22a5 \u2194 sorry"}, {"line": "simp [\u2190 LieSubmodule.toSubmodule_eq_bot, coe_corootSpace_eq_span_singleton \u03b1]", "tactic_state": "K : Type u_1\nH : Type u_2\nL : Type u_3\nx\u271d : Sort u_4\ncorootSpace : x\u271d\n\u03b1 : sorry\n\u22a2 sorry () = \u22a5 \u2194 sorry ()"}]}
{"declaration": "lemma coe_toLinear_ne_zero_iff : (\u03c7 : L \u2192\u2097[R] R) \u2260 0 \u2194 \u03c7.IsNonZero := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/Linear.lean", "context": {"open": ["Set"], "variables": ["(k R L M : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]", "[LieRing.IsNilpotent L] [LinearWeights R L M] (\u03c7 : Weight R L M)", "{R L M \u03c7}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nL : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u03c7 : L \u2192\u2097[R] R\n\u22a2 \u03c7 \u2260 0 \u2194 sorry"}, {"line": "simp", "tactic_state": "R : Type u_2\nL : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : LieRing L\ninst\u271d : LieAlgebra R L\n\u03c7 : L \u2192\u2097[R] R\n\u22a2 \u00ac\u03c7 = 0 \u2194 sorry ()"}]}
{"declaration": "lemma chainLength_zero [Nontrivial L] : chainLength 0 \u03b2 = 0 := by\n  simp [\u2190 chainBotCoeff_add_chainTopCoeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Lie/Weights/RootSystem.lean", "context": {"open": ["LieModule Module"], "variables": ["{K L : Type*} [Field K] [CharZero K] [LieRing L] [LieAlgebra K L]", "(\u03b1 \u03b2 : Weight K H L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "L : Type u_2\ninst\u271d\u00b9 : LieRing L\nx\u271d : Sort u_3\nchainLength : x\u271d\ninst\u271d : Nontrivial L\n\u22a2 sorry = 0"}, {"line": "simp [\u2190 chainBotCoeff_add_chainTopCoeff]", "tactic_state": "L : Type u_2\ninst\u271d\u00b9 : LieRing L\nx\u271d : Sort u_3\nchainLength : x\u271d\ninst\u271d : Nontrivial L\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem Units.neg_smul [Ring R] [AddCommGroup M] [Module R M] (u : R\u02e3) (x : M) :\n    -u \u2022 x = -(u \u2022 x) := by\n  rw [Units.smul_def]\n  rw [Units.val_neg]\n  rw [_root_.neg_smul]\n  rw [Units.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 R M M\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nx : M\n\u22a2 -u \u2022 x = -(u \u2022 x)"}, {"line": "rw [Units.smul_def]", "tactic_state": "R : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nx : M\n\u22a2 \u2191(-u) \u2022 x = -(u \u2022 x)"}, {"line": "rw [Units.val_neg]", "tactic_state": "R : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nx : M\n\u22a2 -\u2191u \u2022 x = -(u \u2022 x)"}, {"line": "rw [_root_.neg_smul]", "tactic_state": "R : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nu : R\u02e3\nx : M\n\u22a2 -(\u2191u \u2022 x) = -(u \u2022 x)"}, {"line": "rw [Units.smul_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_inv_intCast_smul [AddCommGroup M] [AddCommGroup M\u2082] {F : Type*} [FunLike F M M\u2082]\n    [AddMonoidHomClass F M M\u2082] (f : F) (R S : Type*) [DivisionRing R] [DivisionRing S] [Module R M]\n    [Module S M\u2082] (z : \u2124) (x : M) : f ((z\u207b\u00b9 : R) \u2022 x) = (z\u207b\u00b9 : S) \u2022 f x := by\n  obtain \u27e8n, rfl | rfl\u27e9 := z.eq_nat_or_neg\n  \u00b7 rw [Int.cast_natCast, Int.cast_natCast, map_inv_natCast_smul _ R S]\n  \u00b7 simp_rw [Int.cast_neg, Int.cast_natCast, inv_neg, neg_smul, map_neg,\n      map_inv_natCast_smul _ R S]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 R M M\u2082 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : DivisionRing R\ninst\u271d\u00b2 : DivisionRing S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nz : \u2124\nx : M\n\u22a2 f ((\u2191z)\u207b\u00b9 \u2022 x) = (\u2191z)\u207b\u00b9 \u2022 f x"}, {"line": "obtain \u27e8n, rfl | rfl\u27e9 := z.eq_nat_or_neg", "tactic_state": "case intro.inl\nM : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : DivisionRing R\ninst\u271d\u00b2 : DivisionRing S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nx : M\nn : \u2115\n\u22a2 f ((\u2191\u2191n)\u207b\u00b9 \u2022 x) = (\u2191\u2191n)\u207b\u00b9 \u2022 f x\n---\ncase intro.inr\nM : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : DivisionRing R\ninst\u271d\u00b2 : DivisionRing S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nx : M\nn : \u2115\n\u22a2 f ((\u2191(-\u2191n))\u207b\u00b9 \u2022 x) = (\u2191(-\u2191n))\u207b\u00b9 \u2022 f x"}, {"line": "\u00b7 rw [Int.cast_natCast, Int.cast_natCast, map_inv_natCast_smul _ R S]", "tactic_state": "case intro.inr\nM : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : DivisionRing R\ninst\u271d\u00b2 : DivisionRing S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nx : M\nn : \u2115\n\u22a2 f ((\u2191(-\u2191n))\u207b\u00b9 \u2022 x) = (\u2191(-\u2191n))\u207b\u00b9 \u2022 f x"}, {"line": "\u00b7 simp_rw [Int.cast_neg, Int.cast_natCast, inv_neg, neg_smul, map_neg,\n      map_inv_natCast_smul _ R S]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_smul_apply (s : Set \u03b1) (r : \u03b1 \u2192 R) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    indicator s (fun a \u21a6 r a \u2022 f a) a = r a \u2022 indicator s f a := by\n  dsimp only [indicator]\n  split_ifs\n  exacts [rfl, (smul_zero (r a)).symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 R M M\u2082 : Type*}", "[Zero M] [SMulZeroClass R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 s.indicator (fun a => r a \u2022 f a) a = r a \u2022 s.indicator f a"}, {"line": "dsimp only [indicator]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 (if a \u2208 s then r a \u2022 f a else 0) = r a \u2022 if a \u2208 s then f a else 0"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\nh\u271d : a \u2208 s\n\u22a2 r a \u2022 f a = r a \u2022 f a\n---\ncase neg\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\nh\u271d : a \u2209 s\n\u22a2 0 = r a \u2022 0"}, {"line": "exacts [rfl, (smul_zero (r a)).symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma indicator_smul_apply_left (s : Set \u03b1) (r : \u03b1 \u2192 R) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    indicator s (fun a \u21a6 r a \u2022 f a) a = indicator s r a \u2022 f a := by\n  dsimp only [indicator]\n  split_ifs\n  exacts [rfl, (zero_smul _ (f a)).symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Basic.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 R M M\u2082 : Type*}", "[Zero M] [SMulZeroClass R M]", "[Zero R] [Zero M] [SMulWithZero R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2074 : Zero M\ninst\u271d\u00b3 : SMulZeroClass R M\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 s.indicator (fun a => r a \u2022 f a) a = s.indicator r a \u2022 f a"}, {"line": "dsimp only [indicator]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2074 : Zero M\ninst\u271d\u00b3 : SMulZeroClass R M\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\n\u22a2 (if a \u2208 s then r a \u2022 f a else 0) = (if a \u2208 s then r a else 0) \u2022 f a"}, {"line": "split_ifs", "tactic_state": "case pos\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2074 : Zero M\ninst\u271d\u00b3 : SMulZeroClass R M\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\nh\u271d : a \u2208 s\n\u22a2 r a \u2022 f a = r a \u2022 f a\n---\ncase neg\n\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2074 : Zero M\ninst\u271d\u00b3 : SMulZeroClass R M\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\ns : Set \u03b1\nr : \u03b1 \u2192 R\nf : \u03b1 \u2192 M\na : \u03b1\nh\u271d : a \u2209 s\n\u22a2 0 = 0 \u2022 f a"}, {"line": "exacts [rfl, (zero_smul _ (f a)).symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multiset.sum_smul_sum {s : Multiset R} {t : Multiset M} :\n    s.sum \u2022 t.sum = ((s \u00d7\u02e2 t).map fun p : R \u00d7 M \u21a6 p.fst \u2022 p.snd).sum := by\n  induction' s using Multiset.induction with a s ih\n  \u00b7 simp\n  \u00b7 simp [add_smul, ih, \u2190 Multiset.smul_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Multiset R\nt : Multiset M\n\u22a2 s.sum \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) (s \u00d7\u02e2 t)).sum"}, {"line": "induction' s using Multiset.induction with a s ih", "tactic_state": "case empty\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nt : Multiset M\n\u22a2 sum 0 \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) (0 \u00d7\u02e2 t)).sum\n---\ncase cons\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nt : Multiset M\na : R\ns : Multiset R\nih : s.sum \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) (s \u00d7\u02e2 t)).sum\n\u22a2 (a ::\u2098 s).sum \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) ((a ::\u2098 s) \u00d7\u02e2 t)).sum"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nt : Multiset M\na : R\ns : Multiset R\nih : s.sum \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) (s \u00d7\u02e2 t)).sum\n\u22a2 (a ::\u2098 s).sum \u2022 t.sum = (map (fun p => p.1 \u2022 p.2) ((a ::\u2098 s) \u00d7\u02e2 t)).sum"}, {"line": "\u00b7 simp [add_smul, ih, \u2190 Multiset.smul_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Finset.sum_smul_sum (s : Finset \u03b1) (t : Finset \u03b2) {f : \u03b1 \u2192 R} {g : \u03b2 \u2192 M} :\n    (\u2211 i \u2208 s, f i) \u2022 \u2211 j \u2208 t, g j = \u2211 i \u2208 s, \u2211 j \u2208 t, f i \u2022 g j := by\n  simp_rw [sum_smul, \u2190 smul_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nR : Type u_5\nM : Type u_6\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\ns : Finset \u03b1\nt : Finset \u03b2\nf : \u03b1 \u2192 R\ng : \u03b2 \u2192 M\n\u22a2 (\u2211 i \u2208 s, f i) \u2022 \u2211 j \u2208 t, g j = \u2211 i \u2208 s, \u2211 j \u2208 t, f i \u2022 g j"}, {"line": "simp_rw [sum_smul, \u2190 smul_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.cast_card [NonAssocSemiring R] (s : Finset \u03b1) : (#s : R) = \u2211 _ \u2208 s, 1 := by\n  rw [Finset.sum_const]\n  rw [Nat.smul_one_eq_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/BigOperators.lean", "context": {"open": ["Finset"], "variables": ["{\u03b9 \u03ba \u03b1 \u03b2 R M : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nR : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\ns : Finset \u03b1\n\u22a2 \u2191s.card = \u2211 x \u2208 s, 1"}, {"line": "rw [Finset.sum_const]", "tactic_state": "\u03b1 : Type u_3\nR : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\ns : Finset \u03b1\n\u22a2 \u2191s.card = s.card \u2022 1"}, {"line": "rw [Nat.smul_one_eq_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Module.ext' {R : Type*} [Semiring R] {M : Type*} [AddCommMonoid M] (P Q : Module R M)\n    (w : \u2200 (r : R) (m : M), (haveI := P; r \u2022 m) = (haveI := Q; r \u2022 m)) :\n    P = Q := by\n  ext\n  exact w _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S M M\u2082 : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] (r s : R) (x : M)", "(R)", "{R}", "[Semiring R] [AddCommGroup M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Semiring R\nM : Type u_6\ninst\u271d : AddCommMonoid M\nP Q : Module R M\nw : \u2200 (r : R) (m : M), r \u2022 m = r \u2022 m\n\u22a2 P = Q"}, {"line": "ext", "tactic_state": "case smul.h.h\nR : Type u_5\ninst\u271d\u00b9 : Semiring R\nM : Type u_6\ninst\u271d : AddCommMonoid M\nP Q : Module R M\nw : \u2200 (r : R) (m : M), r \u2022 m = r \u2022 m\nx\u271d\u00b9 : R\nx\u271d : M\n\u22a2 SMul.smul x\u271d\u00b9 x\u271d = SMul.smul x\u271d\u00b9 x\u271d"}, {"line": "exact w _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_smul (r s : R) (y : M) : (r - s) \u2022 y = r \u2022 y - s \u2022 y := by\n  simp [add_smul, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Defs.lean", "context": {"open": ["Function Set"], "variables": ["{R S M M\u2082 : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] (r s : R) (x : M)", "(R)", "{R}", "[Semiring R] [AddCommGroup M]", "[Ring R] [AddCommGroup M] [Module R M] (r : R) (x : M)", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nr s : R\ny : M\n\u22a2 (r - s) \u2022 y = r \u2022 y - s \u2022 y"}, {"line": "simp [add_smul, sub_eq_add_neg]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommGroup M\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nr s : R\ny : M\n\u22a2 (r + -s) \u2022 y = r \u2022 y + -(s \u2022 y)"}]}
{"declaration": "theorem smulAddMonoidHom_apply_of_of [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    {i j} (x : A i) (y : M j) :\n    smulAddMonoidHom A M (DirectSum.of A i x) (of M j y) = of M (i +\u1d65 j) (GSMul.smul x y) := by\n  simp [smulAddMonoidHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/GradedModule.lean", "context": {"open": ["DirectSum", "GradedMonoid", "GradedMonoid DirectSum Gmodule"], "variables": ["{\u03b9A \u03b9B : Type*} (A : \u03b9A \u2192 Type*) (M : \u03b9B \u2192 Type*)", "[AddMonoid \u03b9A] [VAdd \u03b9A \u03b9B] [\u2200 i : \u03b9A, AddCommMonoid (A i)] [\u2200 i, AddCommMonoid (M i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9A : Type u_1\n\u03b9B : Type u_2\nA : \u03b9A \u2192 Type u_3\nM : \u03b9B \u2192 Type u_4\ninst\u271d\u2077 : AddMonoid \u03b9A\ninst\u271d\u2076 : VAdd \u03b9A \u03b9B\ninst\u271d\u2075 : (i : \u03b9A) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074 : (i : \u03b9B) \u2192 AddCommMonoid (M i)\ninst\u271d\u00b3 : DecidableEq \u03b9A\ninst\u271d\u00b2 : DecidableEq \u03b9B\ninst\u271d\u00b9 : GMonoid A\ninst\u271d : Gmodule A M\ni : \u03b9A\nj : \u03b9B\nx : A i\ny : M j\n\u22a2 ((smulAddMonoidHom A M) ((of A i) x)) ((of M j) y) = (of M (i +\u1d65 j)) (GSMul.smul x y)"}, {"line": "simp [smulAddMonoidHom]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_smul_of [DecidableEq \u03b9A] [DecidableEq \u03b9B] [GMonoid A] [Gmodule A M]\n    {i j} (x : A i) (y : M j) :\n    DirectSum.of A i x \u2022 of M j y = of M (i +\u1d65 j) (GSMul.smul x y) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/GradedModule.lean", "context": {"open": ["DirectSum", "GradedMonoid", "GradedMonoid DirectSum Gmodule"], "variables": ["{\u03b9A \u03b9B : Type*} (A : \u03b9A \u2192 Type*) (M : \u03b9B \u2192 Type*)", "[AddMonoid \u03b9A] [VAdd \u03b9A \u03b9B] [\u2200 i : \u03b9A, AddCommMonoid (A i)] [\u2200 i, AddCommMonoid (M i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9A : Type u_1\n\u03b9B : Type u_2\nA : \u03b9A \u2192 Type u_3\nM : \u03b9B \u2192 Type u_4\ninst\u271d\u2077 : AddMonoid \u03b9A\ninst\u271d\u2076 : VAdd \u03b9A \u03b9B\ninst\u271d\u2075 : (i : \u03b9A) \u2192 AddCommMonoid (A i)\ninst\u271d\u2074 : (i : \u03b9B) \u2192 AddCommMonoid (M i)\ninst\u271d\u00b3 : DecidableEq \u03b9A\ninst\u271d\u00b2 : DecidableEq \u03b9B\ninst\u271d\u00b9 : GMonoid A\ninst\u271d : Gmodule A M\ni : \u03b9A\nj : \u03b9B\nx : A i\ny : M j\n\u22a2 (of A i) x \u2022 (of M j) y = (of M (i +\u1d65 j)) (GSMul.smul x y)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_mem (p : Submodule (A \u2297[R] B) M) (a : A) {m : M} (hm : m \u2208 p) : a \u2022 m \u2208 p := by\n  suffices a \u2022 m = a \u2297\u209c[R] (1 : B) \u2022 m by exact this.symm \u25b8 p.smul_mem _ hm\n  simp [TensorProduct.Algebra.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Bimodule.lean", "context": {"open": ["TensorProduct"], "variables": ["{R A B M : Type*}", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "[Semiring A] [Semiring B] [Module A M] [Module B M]", "[Algebra R A] [Algebra R B]", "[IsScalarTower R A M] [IsScalarTower R B M]", "[SMulCommClass A B M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Module A M\np : sorry\na : A\nm : M\nhm : sorry\n\u22a2 sorry"}, {"line": "suffices a \u2022 m = a \u2297\u209c[R] (1 : B) \u2022 m by exact this.symm \u25b8 p.smul_mem _ hm", "tactic_state": "A : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Module A M\np : sorry\na : A\nm : M\nhm : sorry\n\u22a2 sorry"}, {"line": "simp [TensorProduct.Algebra.smul_def]", "tactic_state": "A : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring A\ninst\u271d : Module A M\np : sorry\na : A\nm : M\nhm : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem smul_mem' (p : Submodule (A \u2297[R] B) M) (b : B) {m : M} (hm : m \u2208 p) : b \u2022 m \u2208 p := by\n  suffices b \u2022 m = (1 : A) \u2297\u209c[R] b \u2022 m by exact this.symm \u25b8 p.smul_mem _ hm\n  simp [TensorProduct.Algebra.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Bimodule.lean", "context": {"open": ["TensorProduct"], "variables": ["{R A B M : Type*}", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "[Semiring A] [Semiring B] [Module A M] [Module B M]", "[Algebra R A] [Algebra R B]", "[IsScalarTower R A M] [IsScalarTower R B M]", "[SMulCommClass A B M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Module B M\np : sorry\nb : B\nm : M\nhm : sorry\n\u22a2 sorry"}, {"line": "suffices b \u2022 m = (1 : A) \u2297\u209c[R] b \u2022 m by exact this.symm \u25b8 p.smul_mem _ hm", "tactic_state": "B : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Module B M\np : sorry\nb : B\nm : M\nhm : sorry\n\u22a2 sorry"}, {"line": "simp [TensorProduct.Algebra.smul_def]", "tactic_state": "B : Type u_3\nM : Type u_4\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Semiring B\ninst\u271d : Module B M\np : sorry\nb : B\nm : M\nhm : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem map_intCast_smul [AddCommGroup M] [AddCommGroup M\u2082] {F : Type*} [FunLike F M M\u2082]\n    [AddMonoidHomClass F M M\u2082] (f : F) (R S : Type*) [Ring R] [Ring S] [Module R M] [Module S M\u2082]\n    (x : \u2124) (a : M) :\n    f ((x : R) \u2022 a) = (x : S) \u2022 f a := by simp only [Int.cast_smul_eq_zsmul, map_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/End.lean", "context": {"open": ["Function Set"], "variables": ["{R S M M\u2082 : Type*}", "[Semiring R] [AddCommMonoid M] [Module R M] (r s : R) (x : M)", "(R M)", "{R M}", "{x}", "{r} (x)", "(R M) [Semiring R] [AddCommGroup M]", "[Ring R] [AddCommGroup M] [Module R M]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nx : \u2124\na : M\n\u22a2 f (\u2191x \u2022 a) = \u2191x \u2022 f a"}, {"line": "simp only [Int.cast_smul_eq_zsmul, map_zsmul]", "tactic_state": "M : Type u_3\nM\u2082 : Type u_4\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : AddCommGroup M\u2082\nF : Type u_5\ninst\u271d\u2075 : FunLike F M M\u2082\ninst\u271d\u2074 : AddMonoidHomClass F M M\u2082\nf : F\nR : Type u_6\nS : Type u_7\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : Ring S\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module S M\u2082\nx : \u2124\na : M\n\u22a2 f (\u2191x \u2022 a) = x \u2022 f a"}]}
{"declaration": "lemma Module.finitePresentation_of_finite [IsNoetherianRing R] [h : Module.Finite R M] :\n    Module.FinitePresentation R M := by\n  obtain \u27e8s, hs\u27e9 := h\n  exact \u27e8s, hs, IsNoetherian.noetherian _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/FinitePresentation.lean", "context": {"open": ["Finsupp"], "variables": ["(R M) [Semiring R] [AddCommMonoid M] [Module R M]", "(R : Type u) (M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "(R M N) [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type u_1\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\nh : Module.Finite R M\n\u22a2 FinitePresentation R M"}, {"line": "obtain \u27e8s, hs\u27e9 := h", "tactic_state": "case mk.intro\nR : Type u\nM : Type u_1\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ninst\u271d : IsNoetherianRing R\ns : Finset M\nhs : Submodule.span R \u2191s = \u22a4\n\u22a2 FinitePresentation R M"}, {"line": "exact \u27e8s, hs, IsNoetherian.noetherian _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Module.FinitePresentation.of_equiv (e : M \u2243\u2097[R] N) [Module.FinitePresentation R M] :\n    Module.FinitePresentation R N := by\n  simp [\u2190 Module.FinitePresentation.fg_ker_iff e.toLinearMap e.surjective, Submodule.fg_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/FinitePresentation.lean", "context": {"open": ["Finsupp"], "variables": ["(R M) [Semiring R] [AddCommMonoid M] [Module R M]", "(R : Type u) (M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "(R M N) [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N] [Module R N]", "{R M N}", "(R M) in", "{\u03b9} [Finite \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type u_1\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ne : sorry\ninst\u271d : FinitePresentation R M\n\u22a2 sorry"}, {"line": "simp [\u2190 Module.FinitePresentation.fg_ker_iff e.toLinearMap e.surjective, Submodule.fg_bot]", "tactic_state": "R : Type u\nM : Type u_1\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : AddCommGroup M\ninst\u271d\u00b9 : Module R M\ne : sorry\ninst\u271d : FinitePresentation R M\n\u22a2 sorry ()"}]}
{"declaration": "lemma spanFinrank_eq_iInf (p : Submodule R M) :\n    p.spanFinrank = \u2a05 (s : {s : Set M // s.Finite \u2227 span R s = p}), s.2.1.toFinset.card := by\n  simp [spanFinrank, Cardinal.toNat, spanRank_toENat_eq_iInf_finset_card, ENat.iInf_toNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/SpanRank.lean", "context": {"open": ["Cardinal"], "variables": ["{R : Type*} {M : Type u} [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_2\nspan : x\u271d\np : Submodule R M\n\u22a2 p.spanFinrank = \u2a05 s, \u22ef.toFinset.card"}, {"line": "simp [spanFinrank, Cardinal.toNat, spanRank_toENat_eq_iInf_finset_card, ENat.iInf_toNat]", "tactic_state": "R : Type u_1\nM : Type u\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_2\nspan : x\u271d\np : Submodule R M\n\u22a2 p.spanFinrank = \u2a05 s, \u22ef.toFinset.card"}]}
{"declaration": "theorem rank_le_spanRank [StrongRankCondition R] :\n    Module.rank R M \u2264 (\u22a4 : Submodule R M).spanRank := by\n  rw [Module.rank]\n  rw [Submodule.spanRank]\n  refine ciSup_le' (fun \u03b9 \u21a6 (le_ciInf fun s \u21a6 ?_))\n  have := linearIndependent_le_span'' \u03b9.2 s.1 s.2\n  simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/SpanRank.lean", "context": {"open": ["Cardinal", "Cardinal"], "variables": ["{R : Type*} {M : Type u} [Semiring R] [AddCommMonoid M] [Module R M]", "{R : Type u} {M : Type v} [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : StrongRankCondition R\n\u22a2 Module.rank R M \u2264 \u22a4.spanRank"}, {"line": "rw [Module.rank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : StrongRankCondition R\n\u22a2 \u2a06 \u03b9, mk \u2191\u2191\u03b9 \u2264 \u22a4.spanRank"}, {"line": "rw [Submodule.spanRank]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : StrongRankCondition R\n\u22a2 \u2a06 \u03b9, mk \u2191\u2191\u03b9 \u2264 \u2a05 s, mk \u2191\u2191s"}, {"line": "refine ciSup_le' (fun \u03b9 \u21a6 (le_ciInf fun s \u21a6 ?_))", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : StrongRankCondition R\n\u03b9 : { s // LinearIndepOn R id s }\ns : { s // Submodule.span R s = \u22a4 }\n\u22a2 mk \u2191\u2191\u03b9 \u2264 mk \u2191\u2191s"}, {"line": "have := linearIndependent_le_span'' \u03b9.2 s.1 s.2", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : StrongRankCondition R\n\u03b9 : { s // LinearIndepOn R id s }\ns : { s // Submodule.span R s = \u22a4 }\nthis : mk \u2191\u2191\u03b9 \u2264 mk \u2191\u2191s\n\u22a2 mk \u2191\u2191\u03b9 \u2264 mk \u2191\u2191s"}, {"line": "simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem torsionOf_zero : torsionOf R M (0 : M) = \u22a4 := by simp [torsionOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Torsion.lean", "context": {"open": [], "variables": ["(R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\ntorsionOf : x\u271d\n\u22a2 sorry = \u22a4"}, {"line": "simp [torsionOf]", "tactic_state": "x\u271d : Sort u_3\ntorsionOf : x\u271d\n\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem isTorsionBySet_iff_is_torsion_by_span :\n    IsTorsionBySet R M s \u2194 IsTorsionBySet R M (Ideal.span s) := by\n  simpa only [isTorsionBySet_iff_subset_annihilator] using Ideal.span_le.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Torsion.lean", "context": {"open": ["nonZeroDivisors", "Submodule"], "variables": ["(R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]", "{R M}", "(R)", "(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}", "(R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]", "{R M : Type*}", "[CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)", "[Semiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_11\nIsTorsionBySet : x\u271d\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [isTorsionBySet_iff_subset_annihilator] using Ideal.span_le.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma infinite_range_add_nsmul_iff [AddCommGroup M] [NoZeroSMulDivisors \u2124 M] (x y : M) :\n    (Set.range <| fun n : \u2115 \u21a6 x + n \u2022 y).Infinite \u2194 y \u2260 0 := by\n  refine \u27e8fun h hy \u21a6 by simp [hy] at h, fun h \u21a6 Set.infinite_range_of_injective fun r s hrs \u21a6 ?_\u27e9\n  rw [add_right_inj] at hrs\n  rw [\u2190 natCast_zsmul] at hrs\n  rw [\u2190 natCast_zsmul] at hrs\n  simpa using smul_left_injective _ h hrs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Torsion.lean", "context": {"open": ["nonZeroDivisors", "Submodule", "Module", "scoped Function -- required for scoped `on` notation", "scoped Function in -- required for scoped `on` notation", "Pointwise Submodule", "Pointwise", "Module", "Module", "Submodule"], "variables": ["(R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]", "{R M}", "(R)", "(R M : Type*) [Ring R] [AddCommGroup M] [Module R M]", "{R M}", "(R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]", "{R M : Type*}", "[CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)", "[Semiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)", "[CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)", "[CommSemiring R] [AddCommMonoid M] [Module R M] (s : Set R) (a : R)", "(R M)", "{R M}", "{\u03b9 : Type*} {p : \u03b9 \u2192 Ideal R} {S : Finset \u03b9}", "{q : \u03b9 \u2192 R}", "[CommRing R] [AddCommGroup M] [Module R M]", "{\u03b9 : Type*} [DecidableEq \u03b9] {S : Finset \u03b9}", "[Ring R] [AddCommGroup M] [Module R M]", "{I : Ideal R} {r : R}", "(M I) (s : Set R) (r : R)", "(M) [CommRing R] [AddCommGroup M] [Module R M] (s : Set R) (r : R)", "[CommRing R] [AddCommGroup M] [Module R M]", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "(S : Type*) [CommMonoid S] [DistribMulAction S M] [SMulCommClass S R M]", "[CommSemiring R] [AddCommMonoid M] [Module R M]", "(R M)", "{R M}", "[NoZeroDivisors R] [Nontrivial R]", "[CommRing R] [AddCommGroup M] [Module R M]", "[Monoid R] [AddCommMonoid M] [DistribMulAction R M]", "[CommSemiring R] [AddCommMonoid M] [Module R M] [\u2200 x : M, Decidable (x = 0)]", "(A : Type*) [AddCommGroup A] (n : \u2124)", "{A} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\n\u22a2 (Set.range fun n => x + n \u2022 y).Infinite \u2194 y \u2260 0"}, {"line": "refine \u27e8fun h hy \u21a6 by simp [hy] at h, fun h \u21a6 Set.infinite_range_of_injective fun r s hrs \u21a6 ?_\u27e9", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : x + r \u2022 y = x + s \u2022 y\n\u22a2 r = s"}, {"line": "rw [add_right_inj] at hrs", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : r \u2022 y = s \u2022 y\n\u22a2 r = s\n---\nM : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : x + r \u2022 y = x + s \u2022 y\n\u22a2 IsLeftCancelAdd M"}, {"line": "rw [\u2190 natCast_zsmul] at hrs", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : \u2191r \u2022 y = s \u2022 y\n\u22a2 r = s\n---\nM : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : x + r \u2022 y = x + s \u2022 y\n\u22a2 IsLeftCancelAdd M"}, {"line": "rw [\u2190 natCast_zsmul] at hrs", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : \u2191r \u2022 y = \u2191s \u2022 y\n\u22a2 r = s\n---\nM : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : x + r \u2022 y = x + s \u2022 y\n\u22a2 IsLeftCancelAdd M"}, {"line": "simpa using smul_left_injective _ h hrs", "tactic_state": "M : Type u_10\ninst\u271d\u00b9\u2074 inst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 inst\u271d\u2079 inst\u271d\u2078 : AddCommGroup M\ninst\u271d\u2077 inst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : (x : M) \u2192 Decidable (x = 0)\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : NoZeroSMulDivisors \u2124 M\nx y : M\nh : y \u2260 0\nr s : \u2115\nhrs : x + r \u2022 y = x + s \u2022 y\n\u22a2 IsLeftCancelAdd M"}]}
{"declaration": "theorem neg_apply (x : M) : neg R x = -x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Equiv/Basic.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2082 : Type*}", "{K : Type*} {S : Type*} {M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "[Semiring R] [Semiring S] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "(R)", "[Module R M] [Module R M\u2082] [Module S M] [Module S M\u2082]", "[Module R M]", "(M M\u2082)", "[Module R M] [Module R M\u2082] [Subsingleton M] [Subsingleton M\u2082]", "(R M) [Semiring R] [AddCommMonoid M] [Module R M]", "[Group S] [DistribMulAction S M] [SMulCommClass S R M]", "[Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R M\u2082]", "(e : M \u2243+ M\u2082)", "[AddCommGroup M] [AddCommGroup M\u2082] [AddCommGroup M\u2083]", "(e : M \u2243+ M\u2082)", "(R S M)", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M]", "[Semiring R] [Semiring R\u2082]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}", "[RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "[Subsingleton M] [Subsingleton M\u2082]", "[Semiring R]", "[AddCommMonoid M] [Module R M]", "(V V\u2082 R M)", "[Semiring R] [Semiring R\u2082]", "[AddCommMonoid M] [AddCommMonoid M\u2082]", "{module_M : Module R M} {module_M\u2082 : Module R\u2082 M\u2082}", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}", "{re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}", "(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M)", "(R) [Semiring R] [AddCommGroup M] [Module R M]", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_5\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Subsingleton M\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Subsingleton M\ninst\u271d\u00b9 inst\u271d : AddCommMonoid M\nx\u271d : Sort u_9\nneg : x\u271d\nx : M\n\u22a2 sorry = -x"}, {"line": "simp", "tactic_state": "M : Type u_5\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : Subsingleton M\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 inst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Subsingleton M\ninst\u271d\u00b9 inst\u271d : AddCommMonoid M\nx\u271d : Sort u_9\nneg : x\u271d\nx : M\n\u22a2 sorry () = -x"}]}
{"declaration": "theorem toFun_eq_coe : e.toFun = e := by dsimp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Equiv/Defs.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{S : Type*} {M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{N\u2081 : Type*} {N\u2082 : Type*}", "(F : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[Module R M] [Module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "{F}", "[Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[Module R M] [Module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "[Semiring R\u2081] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[AddCommMonoid M\u2083]", "[AddCommMonoid N\u2081] [AddCommMonoid N\u2082]", "{module_M : Module R M} {module_S_M\u2082 : Module S M\u2082} {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "{re\u2081 : RingHomInvPair \u03c3 \u03c3'} {re\u2082 : RingHomInvPair \u03c3' \u03c3}", "(e e' : M \u2243\u209b\u2097[\u03c3] M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_5\nM : Type u_6\nM\u2082 : Type u_8\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : Semiring S\ninst\u271d\u00b9\u00b9 : AddCommMonoid M\ninst\u271d\u00b9\u2070 : AddCommMonoid M\u2082\ninst\u271d\u2079 : Module R M\ninst\u271d\u2078 : Module S M\u2082\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring S\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module S M\u2082\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : AddCommMonoid M\u2082\nmodule_M : Module R M\nmodule_S_M\u2082 : Module S M\u2082\n\u03c3 : R \u2192+* S\n\u03c3' : S \u2192+* R\nre\u2081 : RingHomInvPair \u03c3 \u03c3'\nre\u2082 : RingHomInvPair \u03c3' \u03c3\ne : M \u2243\u209b\u2097[\u03c3] M\u2082\n\u22a2 (\u2191e).toFun = \u21d1e"}, {"line": "dsimp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_toAddEquiv_symm : (e\u2081\u2082.symm : M\u2082 \u2243+ M\u2081) = (e\u2081\u2082 : M\u2081 \u2243+ M\u2082).symm := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Equiv/Defs.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{S : Type*} {M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{N\u2081 : Type*} {N\u2082 : Type*}", "(F : Type*) [Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[Module R M] [Module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "{F}", "[Semiring R] [Semiring S]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[Module R M] [Module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "[RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]", "[Semiring R\u2081] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]", "[AddCommMonoid M\u2083]", "[AddCommMonoid N\u2081] [AddCommMonoid N\u2082]", "{module_M : Module R M} {module_S_M\u2082 : Module S M\u2082} {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R}", "{re\u2081 : RingHomInvPair \u03c3 \u03c3'} {re\u2082 : RingHomInvPair \u03c3' \u03c3}", "(e e' : M \u2243\u209b\u2097[\u03c3] M\u2082)", "{e e'}", "(M R)", "{module_M\u2081 : Module R\u2081 M\u2081} {module_M\u2082 : Module R\u2082 M\u2082} {module_M\u2083 : Module R\u2083 M\u2083}", "{module_N\u2081 : Module R\u2081 N\u2081} {module_N\u2082 : Module R\u2081 N\u2082}", "{\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083}", "{\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} {\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082} {\u03c3\u2083\u2081 : R\u2083 \u2192+* R\u2081}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "[RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081]", "{re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082}", "[RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081] {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}", "{re\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083} [RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083]", "(e\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (e\u2082\u2083 : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083)", "{e\u2081\u2082} {e\u2082\u2083}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 : Type u_2\nR\u2082 : Type u_3\nM\u2081 : Type u_7\nM\u2082 : Type u_8\ninst\u271d\u2077 : AddCommMonoid M\u2081\ninst\u271d\u2076 : AddCommMonoid M\u2082\ninst\u271d\u2075 : AddCommMonoid M\u2081\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Semiring R\u2081\ninst\u271d\u00b2 : Semiring R\u2082\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : AddCommMonoid M\u2082\nmodule_M\u2081 : Module R\u2081 M\u2081\nmodule_M\u2082 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081\nre\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\nre\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\ne\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082\n\u22a2 \u2191e\u2081\u2082.symm = (\u2191e\u2081\u2082).symm"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toMvPolynomial_totalDegree_le (M : Matrix m n R) (i : m) :\n    (M.toMvPolynomial i).totalDegree \u2264 1 := by\n  apply (toMvPolynomial_isHomogeneous _ _).totalDegree_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LinearMap/Polynomial.lean", "context": {"open": ["scoped Matrix", "MvPolynomial"], "variables": ["{m n o R S : Type*}", "[Fintype n] [Fintype o] [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : Type u_1\nn : Type u_2\nR : Type u_4\ninst\u271d\u00b9 : Fintype n\ninst\u271d : CommSemiring R\nM : Matrix m n R\ni : m\n\u22a2 (M.toMvPolynomial i).totalDegree \u2264 1"}, {"line": "apply (toMvPolynomial_isHomogeneous _ _).totalDegree_le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma polyCharpolyAux_eval_eq_toMatrix_charpoly_coeff (x : L) (i : \u2115) :\n    MvPolynomial.eval (b.repr x) ((polyCharpolyAux \u03c6 b b\u2098).coeff i) =\n      (toMatrix b\u2098 b\u2098 (\u03c6 x)).charpoly.coeff i := by\n  simp [\u2190 polyCharpolyAux_map_eq_toMatrix_charpoly \u03c6 b b\u2098 x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LinearMap/Polynomial.lean", "context": {"open": ["scoped Matrix", "MvPolynomial", "MvPolynomial", "Algebra.TensorProduct in", "Matrix", "Algebra.TensorProduct MvPolynomial in", "LinearMap in", "LinearMap in"], "variables": ["{m n o R S : Type*}", "[Fintype n] [Fintype o] [CommSemiring R] [CommSemiring S]", "{R M\u2081 M\u2082 \u03b9\u2081 \u03b9\u2082 : Type*}", "[CommRing R] [AddCommGroup M\u2081] [AddCommGroup M\u2082]", "[Module R M\u2081] [Module R M\u2082]", "[Fintype \u03b9\u2081] [Finite \u03b9\u2082]", "[DecidableEq \u03b9\u2081]", "(b\u2081 : Basis \u03b9\u2081 R M\u2081) (b\u2082 : Basis \u03b9\u2082 R M\u2082)", "{R M\u2081 M\u2082 M\u2083 \u03b9\u2081 \u03b9\u2082 \u03b9\u2083 : Type*}", "[CommRing R] [AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup M\u2083]", "[Module R M\u2081] [Module R M\u2082] [Module R M\u2083]", "[Fintype \u03b9\u2081] [Fintype \u03b9\u2082] [Finite \u03b9\u2083]", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(b\u2081 : Basis \u03b9\u2081 R M\u2081) (b\u2082 : Basis \u03b9\u2082 R M\u2082) (b\u2083 : Basis \u03b9\u2083 R M\u2083)", "{R L M n \u03b9 \u03b9' \u03b9M : Type*}", "[CommRing R] [AddCommGroup L] [Module R L] [AddCommGroup M] [Module R M]", "(\u03c6 : L \u2192\u2097[R] Module.End R M)", "[Fintype \u03b9] [Fintype \u03b9'] [Fintype \u03b9M] [DecidableEq \u03b9] [DecidableEq \u03b9']", "[DecidableEq \u03b9M] (b : Basis \u03b9 R L) (b\u2098 : Basis \u03b9M R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u2075 : CommSemiring sorry\nR : Type u_13\nL : Type u_14\n\u03b9 : Type u_17\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup L\ninst\u271d\u00b2 : Module R L\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R L\nx\u271d\u00b9 : Sort u_20\npolyCharpolyAux : x\u271d\u00b9\nx\u271d : Sort u_21\ntoMatrix : x\u271d\nx : L\ni : \u2115\n\u22a2 (eval \u21d1(b.repr x)) sorry = sorry"}, {"line": "simp [\u2190 polyCharpolyAux_map_eq_toMatrix_charpoly \u03c6 b b\u2098 x]", "tactic_state": "inst\u271d\u2075 : CommSemiring sorry\nR : Type u_13\nL : Type u_14\n\u03b9 : Type u_17\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : AddCommGroup L\ninst\u271d\u00b2 : Module R L\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nb : Basis \u03b9 R L\nx\u271d\u00b9 : Sort u_20\npolyCharpolyAux : x\u271d\u00b9\nx\u271d : Sort u_21\ntoMatrix : x\u271d\nx : L\ni : \u2115\n\u22a2 (eval \u21d1(b.repr x)) (sorry ()) = sorry ()"}]}
{"declaration": "lemma polyCharpoly_coeff_eq_zero_iff_of_basis (b : Basis \u03b9 R L) (b' : Basis \u03b9' R L) (k : \u2115) :\n    (polyCharpoly \u03c6 b).coeff k = 0 \u2194 (polyCharpoly \u03c6 b').coeff k = 0 := by\n  constructor <;> apply polyCharpoly_coeff_eq_zero_of_basis\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LinearMap/Polynomial.lean", "context": {"open": ["scoped Matrix", "MvPolynomial", "MvPolynomial", "Algebra.TensorProduct in", "Matrix", "Algebra.TensorProduct MvPolynomial in", "LinearMap in", "LinearMap in", "Algebra.TensorProduct TensorProduct in", "Algebra.TensorProduct MvPolynomial in", "Module Matrix", "Algebra.TensorProduct MvPolynomial in"], "variables": ["{m n o R S : Type*}", "[Fintype n] [Fintype o] [CommSemiring R] [CommSemiring S]", "{R M\u2081 M\u2082 \u03b9\u2081 \u03b9\u2082 : Type*}", "[CommRing R] [AddCommGroup M\u2081] [AddCommGroup M\u2082]", "[Module R M\u2081] [Module R M\u2082]", "[Fintype \u03b9\u2081] [Finite \u03b9\u2082]", "[DecidableEq \u03b9\u2081]", "(b\u2081 : Basis \u03b9\u2081 R M\u2081) (b\u2082 : Basis \u03b9\u2082 R M\u2082)", "{R M\u2081 M\u2082 M\u2083 \u03b9\u2081 \u03b9\u2082 \u03b9\u2083 : Type*}", "[CommRing R] [AddCommGroup M\u2081] [AddCommGroup M\u2082] [AddCommGroup M\u2083]", "[Module R M\u2081] [Module R M\u2082] [Module R M\u2083]", "[Fintype \u03b9\u2081] [Fintype \u03b9\u2082] [Finite \u03b9\u2083]", "[DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082]", "(b\u2081 : Basis \u03b9\u2081 R M\u2081) (b\u2082 : Basis \u03b9\u2082 R M\u2082) (b\u2083 : Basis \u03b9\u2083 R M\u2083)", "{R L M n \u03b9 \u03b9' \u03b9M : Type*}", "[CommRing R] [AddCommGroup L] [Module R L] [AddCommGroup M] [Module R M]", "(\u03c6 : L \u2192\u2097[R] Module.End R M)", "[Fintype \u03b9] [Fintype \u03b9'] [Fintype \u03b9M] [DecidableEq \u03b9] [DecidableEq \u03b9']", "[DecidableEq \u03b9M] (b : Basis \u03b9 R L) (b\u2098 : Basis \u03b9M R M)", "[Module.Free R M] [Module.Finite R M] (b : Basis \u03b9 R L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "inst\u271d\u2077 : CommSemiring sorry\nR : Type u_13\nL : Type u_14\n\u03b9 : Type u_17\n\u03b9' : Type u_18\ninst\u271d\u2076 : CommRing R\ninst\u271d\u2075 : AddCommGroup L\ninst\u271d\u2074 : Module R L\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : Fintype \u03b9'\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq \u03b9'\nx\u271d : Sort u_20\npolyCharpoly : x\u271d\nb : Basis \u03b9 R L\nb' : Basis \u03b9' R L\nk : \u2115\n\u22a2 sorry = 0 \u2194 sorry = 0"}, {"line": "constructor <;> apply polyCharpoly_coeff_eq_zero_of_basis", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma LinearMapClass.map_smul {R M M\u2082 : outParam Type*} [Semiring R] [AddCommMonoid M]\n    [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082]\n    {F : Type*} [FunLike F M M\u2082] [LinearMapClass F R M M\u2082] (f : F) (r : R) (x : M) :\n    f (r \u2022 x) = r \u2022 f x := by rw [map_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LinearMap/Defs.lean", "context": {"open": ["Function"], "variables": ["{R R\u2081 R\u2082 R\u2083 S S\u2083 T M M\u2081 M\u2082 M\u2083 N\u2082 N\u2083 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : outParam (Type u_14)\nM : outParam (Type u_15)\nM\u2082 : outParam (Type u_16)\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\nF : Type u_17\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : LinearMapClass F R M M\u2082\nf : F\nr : R\nx : M\n\u22a2 f (r \u2022 x) = r \u2022 f x"}, {"line": "rw [map_smul]", "tactic_state": "R : outParam (Type u_14)\nM : outParam (Type u_15)\nM\u2082 : outParam (Type u_16)\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M\u2082\nF : Type u_17\ninst\u271d\u00b9 : FunLike F M M\u2082\ninst\u271d : LinearMapClass F R M M\u2082\nf : F\nr : R\nx : M\n\u22a2 MulActionHomClass F R M M\u2082"}]}
{"declaration": "lemma isLocalizedModule_iff_isLocalization' :\n    IsLocalizedModule S (Algebra.linearMap R A) \u2194 IsLocalization S A := by\n  convert isLocalizedModule_iff_isLocalization (S := S) (A := R) (A\u209b := A)\n  exact (Submonoid.map_id S).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/IsLocalization.lean", "context": {"open": [], "variables": ["{R : Type*} [CommSemiring R] (S : Submonoid R)", "{A A\u209b : Type*} [CommSemiring A] [Algebra R A]", "[CommSemiring A\u209b] [Algebra A A\u209b] [Algebra R A\u209b] [IsScalarTower R A A\u209b]", "{S} in", "(A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u22a2 IsLocalizedModule S (Algebra.linearMap R A) \u2194 IsLocalization S A"}, {"line": "convert isLocalizedModule_iff_isLocalization (S := S) (A := R) (A\u209b := A)", "tactic_state": "case h.e'_2.h.e'_3\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u22a2 S = Algebra.algebraMapSubmonoid R S\n---\ncase convert_6\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u22a2 IsScalarTower R R A"}, {"line": "exact (Submonoid.map_id S).symm", "tactic_state": "case convert_6\nR : Type u_1\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst\u271d\u00b9 : CommSemiring A\ninst\u271d : Algebra R A\n\u22a2 IsScalarTower R R A"}]}
{"declaration": "theorem liftOn_mk {\u03b1 : Type*} {f : M \u00d7 S \u2192 \u03b1} (wd : \u2200 (p p' : M \u00d7 S), p \u2248 p' \u2192 f p = f p')\n    (m : M) (s : S) : liftOn (mk m s) f wd = f \u27e8m, s\u27e9 := by convert Quotient.liftOn_mk f wd \u27e8m, s\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_3\nliftOn : x\u271d\n\u03b1 : Type u_2\nf : M \u00d7 \u21a5S \u2192 \u03b1\nwd : \u2200 (p p' : M \u00d7 \u21a5S), p \u2248 p' \u2192 f p = f p'\nm : M\ns : \u21a5S\n\u22a2 sorry = f (m, s)"}, {"line": "convert Quotient.liftOn_mk f wd \u27e8m, s\u27e9", "tactic_state": "case h.e'_2\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_3\nliftOn : x\u271d\n\u03b1 : Type u_2\nf : M \u00d7 \u21a5S \u2192 \u03b1\nwd : \u2200 (p p' : M \u00d7 \u21a5S), p \u2248 p' \u2192 f p = f p'\nm : M\ns : \u21a5S\n\u22a2 sorry = \u27e6(m, s)\u27e7.liftOn f wd"}]}
{"declaration": "theorem liftOn\u2082_mk {\u03b1 : Type*} (f : M \u00d7 S \u2192 M \u00d7 S \u2192 \u03b1)\n    (wd : \u2200 (p q p' q' : M \u00d7 S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn\u2082 (mk m s) (mk m' s') f wd = f \u27e8m, s\u27e9 \u27e8m', s'\u27e9 := by\n  convert Quotient.liftOn\u2082_mk f wd _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_3\nliftOn\u2082 : x\u271d\n\u03b1 : Type u_2\nf : M \u00d7 \u21a5S \u2192 M \u00d7 \u21a5S \u2192 \u03b1\nwd : \u2200 (p q p' q' : M \u00d7 \u21a5S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q'\nm m' : M\ns s' : \u21a5S\n\u22a2 sorry = f (m, s) (m', s')"}, {"line": "convert Quotient.liftOn\u2082_mk f wd _ _", "tactic_state": "case h.e'_2\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nx\u271d : Sort u_3\nliftOn\u2082 : x\u271d\n\u03b1 : Type u_2\nf : M \u00d7 \u21a5S \u2192 M \u00d7 \u21a5S \u2192 \u03b1\nwd : \u2200 (p q p' q' : M \u00d7 \u21a5S), p \u2248 p' \u2192 q \u2248 q' \u2192 f p q = f p' q'\nm m' : M\ns s' : \u21a5S\n\u22a2 sorry = \u27e6(m, s)\u27e7.liftOn\u2082 \u27e6(m', s')\u27e7 f wd"}]}
{"declaration": "theorem subsingleton (h : 0 \u2208 S) : Subsingleton (LocalizedModule S M) := by\n  refine \u27e8fun a b \u21a6 ?_\u27e9\n  induction a,b using LocalizedModule.induction_on\u2082\n  exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nh : 0 \u2208 S\n\u22a2 Subsingleton (LocalizedModule S M)"}, {"line": "refine \u27e8fun a b \u21a6 ?_\u27e9", "tactic_state": "R : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nh : 0 \u2208 S\na b : LocalizedModule S M\n\u22a2 a = b"}, {"line": "induction a,b using LocalizedModule.induction_on\u2082", "tactic_state": "case h\nR : Type u\ninst\u271d\u00b2 : CommSemiring R\nS : Submonoid R\nM : Type v\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nh : 0 \u2208 S\nm\u271d m'\u271d : M\ns\u271d s'\u271d : \u21a5S\n\u22a2 LocalizedModule.mk m\u271d s\u271d = LocalizedModule.mk m'\u271d s'\u271d"}, {"line": "exact mk_eq.mpr \u27e8\u27e80, h\u27e9, by simp only [Submonoid.mk_smul, zero_smul]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lift_mk_one (h : \u2200 (x : S), IsUnit ((algebraMap R (Module.End R M'')) x)) (m : M) :\n    (LocalizedModule.lift S g h) (LocalizedModule.mk m 1) = g m := by\n  simp [lift_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}", "{T}", "(T)", "(S M)", "{R : Type*} [CommSemiring R] (S : Submonoid R)", "{M M' M'' : Type*} [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M'']", "{A : Type*} [CommSemiring A] [Algebra R A] [Module A M'] [IsLocalization S A]", "[Module R M] [Module R M'] [Module R M''] [IsScalarTower R A M']", "(f : M \u2192\u2097[R] M') (g : M \u2192\u2097[R] M'')", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2074 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM'' : Type u_5\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M''\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M''\ng : M \u2192\u2097[R] M''\nh : \u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R M'')) \u2191x)\nm : M\n\u22a2 (LocalizedModule.lift S g h) (LocalizedModule.mk m 1) = g m"}, {"line": "simp [lift_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lift_iso (h : \u2200 (x : S), IsUnit ((algebraMap R (Module.End R M'')) x))\n    (x : LocalizedModule S M) :\n    IsLocalizedModule.lift S f g h ((iso S f) x) = LocalizedModule.lift S g h x := by\n  simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}", "{T}", "(T)", "(S M)", "{R : Type*} [CommSemiring R] (S : Submonoid R)", "{M M' M'' : Type*} [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M'']", "{A : Type*} [CommSemiring A] [Algebra R A] [Module A M'] [IsLocalization S A]", "[Module R M] [Module R M'] [Module R M''] [IsScalarTower R A M']", "(f : M \u2192\u2097[R] M') (g : M \u2192\u2097[R] M'')", "(M) in", "[IsLocalizedModule S f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2074 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM'' : Type u_5\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M''\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M''\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\niso : x\u271d\nh : \u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R M'')) \u2191x)\nx : LocalizedModule S M\n\u22a2 sorry = (LocalizedModule.lift S g h) x"}, {"line": "simp [lift]", "tactic_state": "R : Type u_2\ninst\u271d\u2074 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM'' : Type u_5\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M''\ninst\u271d\u00b9 : Module R M\ninst\u271d : Module R M''\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\niso : x\u271d\nh : \u2200 (x : \u21a5S), IsUnit ((algebraMap R (Module.End R M'')) \u2191x)\nx : LocalizedModule S M\n\u22a2 sorry () = (LocalizedModule.lift S g h) x"}]}
{"declaration": "lemma linearEquiv_apply [IsLocalizedModule S g] (x : M) :\n    (linearEquiv S f g) (f x) = g x := by\n  simp [linearEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}", "{T}", "(T)", "(S M)", "{R : Type*} [CommSemiring R] (S : Submonoid R)", "{M M' M'' : Type*} [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M'']", "{A : Type*} [CommSemiring A] [Algebra R A] [Module A M'] [IsLocalization S A]", "[Module R M] [Module R M'] [Module R M''] [IsScalarTower R A M']", "(f : M \u2192\u2097[R] M') (g : M \u2192\u2097[R] M'')", "(M) in", "[IsLocalizedModule S f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM'' : Type u_5\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M''\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\nlinearEquiv : x\u271d\ninst\u271d : IsLocalizedModule S g\nx : M\n\u22a2 sorry = g x"}, {"line": "simp [linearEquiv]", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM'' : Type u_5\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M''\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R M''\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\nlinearEquiv : x\u271d\ninst\u271d : IsLocalizedModule S g\nx : M\n\u22a2 sorry () = g x"}]}
{"declaration": "lemma linearEquiv_symm_apply [IsLocalizedModule S g] (x : M) :\n    (linearEquiv S f g).symm (g x) = f x := by\n  simp [linearEquiv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/LocalizedModule/Basic.lean", "context": {"open": [], "variables": ["{R : Type u} [CommSemiring R] (S : Submonoid R)", "(M : Type v) [AddCommMonoid M] [Module R M]", "(T : Type*) [CommSemiring T] [Algebra R T] [IsLocalization S T]", "{M S}", "{T}", "(T)", "(S M)", "{R : Type*} [CommSemiring R] (S : Submonoid R)", "{M M' M'' : Type*} [AddCommMonoid M] [AddCommMonoid M'] [AddCommMonoid M'']", "{A : Type*} [CommSemiring A] [Algebra R A] [Module A M'] [IsLocalization S A]", "[Module R M] [Module R M'] [Module R M''] [IsScalarTower R A M']", "(f : M \u2192\u2097[R] M') (g : M \u2192\u2097[R] M'')", "(M) in", "[IsLocalizedModule S f]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM' : Type u_4\nM'' : Type u_5\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M'\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M''\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\nlinearEquiv : x\u271d\ninst\u271d : IsLocalizedModule S g\nx : M\n\u22a2 sorry = f x"}, {"line": "simp [linearEquiv]", "tactic_state": "R : Type u_2\ninst\u271d\u2077 : CommSemiring R\nS : Submonoid R\nM : Type u_3\nM' : Type u_4\nM'' : Type u_5\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M'\ninst\u271d\u2074 : AddCommMonoid M''\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R M'\ninst\u271d\u00b9 : Module R M''\nf : M \u2192\u2097[R] M'\ng : M \u2192\u2097[R] M''\nx\u271d : Sort u_7\nlinearEquiv : x\u271d\ninst\u271d : IsLocalizedModule S g\nx : M\n\u22a2 sorry () = f x"}]}
{"declaration": "lemma map_single (r : relations.R) :\n    relations.map (Finsupp.single r 1) = relations.relation r := by\n  simp [map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.47\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nr : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [map]", "tactic_state": "Relations : ?m.47\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nr : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma toQuotient_map : relations.toQuotient.comp relations.map = 0 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.47\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\n\u22a2 sorry = 0"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u03c0_single (g : relations.G) :\n    solution.\u03c0 (Finsupp.single g 1) = solution.var g := by simp [\u03c0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.916\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nM : ?m.932\nsolution : sorry\ng : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [\u03c0]", "tactic_state": "Relations : ?m.916\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nM : ?m.932\nsolution : sorry\ng : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma \u03c0_comp_map : solution.\u03c0.comp relations.map = 0 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.916\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nM : ?m.932\nsolution : sorry\n\u22a2 sorry = 0"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of\u03c0'_\u03c0 : (of\u03c0' \u03c0 h\u03c0).\u03c0 = \u03c0 := by simp [of\u03c0']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.25684\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nM : ?m.25700\nsolution : sorry\nx\u271d : Sort u_1\nof\u03c0' : x\u271d\n\u03b1\u271d : Sort u_2\n\u03c0 : \u03b1\u271d\n\u22a2 sorry = \u03c0"}, {"line": "simp [of\u03c0']", "tactic_state": "Relations : ?m.25684\nA : Type u\ninst\u271d : Ring A\nrelations : sorry\nM : ?m.25700\nsolution : sorry\nx\u271d : Sort u_1\nof\u03c0' : x\u271d\n\u03b1\u271d : Sort u_2\n\u03c0 : \u03b1\u271d\n\u22a2 sorry () = \u03c0"}]}
{"declaration": "lemma desc_comp_\u03c0 (s : relations.Solution N) : (h.desc s).comp solution.\u03c0 = s.\u03c0 := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.26594\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.27411\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\ns : sorry\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma postcomp_desc (s : relations.Solution N) :\n    solution.postcomp (h.desc s) = s := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.26594\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.27411\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\ns : sorry\n\u22a2 sorry = s"}, {"line": "aesop", "tactic_state": "Relations : ?m.26594\nA : Type u\ninst : Ring A\nrelations : sorry\nM : ?m.27411\nsolution_1 : sorry\nsolution_2 : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst_1 : AddCommGroup N\ninst_2 : Module A N\ns : sorry\n\u22a2 sorry () = s"}]}
{"declaration": "lemma postcomp_uniq : solution.postcomp (uniq h h').toLinearMap = solution' := by\n  simp [uniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]", "{solution' : relations.Solution N} (h' : solution'.IsPresentation)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution'\u271d : sorry\nh' : sorry\nsolution' : sorry\n\u22a2 sorry = solution'"}, {"line": "simp [uniq]", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution'\u271d : sorry\nh' : sorry\nsolution' : sorry\n\u22a2 sorry () = solution'"}]}
{"declaration": "lemma postcomp_uniq_symm : solution'.postcomp (uniq h h').symm.toLinearMap = solution := by\n  simp [uniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]", "{solution' : relations.Solution N} (h' : solution'.IsPresentation)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b2 : sorry\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nsolution : sorry\n\u22a2 sorry = solution"}, {"line": "simp [uniq]", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b2 : sorry\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nsolution : sorry\n\u22a2 sorry () = solution"}]}
{"declaration": "lemma uniq_var (g : relations.G) : uniq h h' (solution.var g) = solution'.var g := by\n  simp [uniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]", "{solution' : relations.Solution N} (h' : solution'.IsPresentation)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nx\u271d : Sort u_1\nuniq : x\u271d\ng : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [uniq]", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nx\u271d : Sort u_1\nuniq : x\u271d\ng : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma uniq_symm_var (g : relations.G) : (uniq h h').symm (solution'.var g) = solution.var g := by\n  simp [uniq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]", "{solution' : relations.Solution N} (h' : solution'.IsPresentation)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nx\u271d : Sort u_1\nuniq : x\u271d\ng : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [uniq]", "tactic_state": "Relations : ?m.27438\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.28261\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nx\u271d : Sort u_1\nuniq : x\u271d\ng : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma ofQuotient_fromQuotient : (ofQuotient relations).fromQuotient = .id := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Basic.lean", "context": {"open": [], "variables": ["(A : Type u) [Ring A]", "{A} (relations : Relations.{w\u2080, w\u2081} A)", "{relations} in", "(M : Type v) [AddCommGroup M] [Module A M]", "{relations M}", "(solution : relations.Solution M)", "{N : Type v'} [AddCommGroup N] [Module A N] (f : M \u2192\u2097[A] N)", "{solution}", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u2200 (r : relations.R), \u03c0 (relations.relation r) = 0)", "(\u03c0 : (relations.G \u2192\u2080 A) \u2192\u2097[A] M) (h\u03c0 : \u03c0.comp relations.map = 0)", "(solution : relations.Solution M)", "{solution : relations.Solution M} (h : solution.IsPresentation)", "{N : Type v'} [AddCommGroup N] [Module A N]", "{solution' : relations.Solution N} (h' : solution'.IsPresentation)", "(relations)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Relations : ?m.28284\nA : Type u\ninst\u271d\u00b2 : Ring A\nrelations : sorry\nM : ?m.29107 relations\nsolution\u271d\u00b9 : sorry\nsolution\u271d : sorry\nsolution : sorry\nh : sorry\nN : Type v'\ninst\u271d\u00b9 : AddCommGroup N\ninst\u271d : Module A N\nsolution' : sorry\nh' : sorry\nx\u271d : Sort u_1\nofQuotient : x\u271d\n\u22a2 sorry = sorry"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom\u2081_single (r : pres.rels) :\n    hom\u2081 pres (Finsupp.single r 1) = Extension.Cotangent.mk \u27e8pres.relation r, by simp\u27e9 := by\n  simp [hom\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Presentation/Differentials.lean", "context": {"open": ["KaehlerDifferential"], "variables": ["{R : Type u} {S : Type v} [CommRing R] [CommRing S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nhom\u2081 : x\u271d\nr : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [hom\u2081]", "tactic_state": "x\u271d : Sort u_1\nhom\u2081 : x\u271d\nr : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem image2_subset_map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) :\n    Set.image2 (fun m n => f m n) (\u2191p : Set M) (\u2191q : Set N) \u2286 (\u2191(map\u2082 f p q) : Set P) := by\n  rintro _ \u27e8i, hi, j, hj, rfl\u27e9\n  exact apply_mem_map\u2082 _ hi hj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Bilinear.lean", "context": {"open": ["Set", "Pointwise"], "variables": ["{\u03b9 : Sort u\u03b9} {R M N P : Type*}", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[Module R M] [Module R N] [Module R P]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nx\u271d : Sort u_5\nmap\u2082 : x\u271d\nf : M \u2192\u2097[R] N \u2192\u2097[R] P\np : Submodule R M\nq : Submodule R N\n\u22a2 image2 (fun m n => (f m) n) \u2191p \u2191q \u2286 sorry"}, {"line": "rintro _ \u27e8i, hi, j, hj, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nR : Type u_1\nM : Type u_2\nN : Type u_3\nP : Type u_4\ninst\u271d\u2076 : CommSemiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : AddCommMonoid P\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R N\ninst\u271d : Module R P\nx\u271d : Sort u_5\nmap\u2082 : x\u271d\nf : M \u2192\u2097[R] N \u2192\u2097[R] P\np : Submodule R M\nq : Submodule R N\ni : M\nhi : i \u2208 \u2191p\nj : N\nhj : j \u2208 \u2191q\n\u22a2 (fun m n => (f m) n) i j \u2208 sorry"}, {"line": "exact apply_mem_map\u2082 _ hi hj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_ker {f : F} {p : Submodule R M} :\n    Disjoint p (ker f) \u2194 \u2200 x \u2208 p, f x = 0 \u2192 x = 0 := by\n  simp [disjoint_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Ker.lean", "context": {"open": ["Function", "Pointwise", "Submodule"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\nF : Type u_11\ninst\u271d : FunLike F M M\u2082\nx\u271d : Sort u_12\nker : x\u271d\nf : F\np : Submodule R M\n\u22a2 Disjoint p sorry \u2194 \u2200 x \u2208 p, f x = 0 \u2192 x = 0"}, {"line": "simp [disjoint_def]", "tactic_state": "R : Type u_1\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9 : Module R M\nF : Type u_11\ninst\u271d : FunLike F M M\u2082\nx\u271d : Sort u_12\nker : x\u271d\nf : F\np : Submodule R M\n\u22a2 (\u2200 x \u2208 p, x \u2208 sorry () \u2192 x = 0) \u2194 \u2200 x \u2208 p, f x = 0 \u2192 x = 0"}]}
{"declaration": "theorem ker_inclusion (p p' : Submodule R M) (h : p \u2264 p') : ker (inclusion h) = \u22a5 := by\n  rw [inclusion]\n  rw [ker_codRestrict]\n  rw [ker_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Ker.lean", "context": {"open": ["Function", "Pointwise", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "(F) in", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np p' : Submodule R M\nh : p \u2264 p'\n\u22a2 ker (inclusion h) = \u22a5"}, {"line": "rw [inclusion]", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np p' : Submodule R M\nh : p \u2264 p'\n\u22a2 ker (codRestrict p' p.subtype \u22ef) = \u22a5"}, {"line": "rw [ker_codRestrict]", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np p' : Submodule R M\nh : p \u2264 p'\n\u22a2 ker p.subtype = \u22a5"}, {"line": "rw [ker_subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_comp_of_ker_eq_bot (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} (hg : ker g = \u22a5) :\n    ker (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = ker f := by rw [ker_comp, hg, Submodule.comap_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Ker.lean", "context": {"open": ["Function", "Pointwise", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "(F) in", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\nM\u2083 : Type u_8\ninst\u271d\u00b3\u2070 : Semiring R\ninst\u271d\u00b2\u2079 : Semiring R\u2082\ninst\u271d\u00b2\u2078 : Semiring R\u2083\ninst\u271d\u00b2\u2077 : AddCommMonoid M\ninst\u271d\u00b2\u2076 : AddCommMonoid M\u2082\ninst\u271d\u00b2\u2075 : AddCommMonoid M\u2083\ninst\u271d\u00b2\u2074 : Module R M\ninst\u271d\u00b2\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b2\u00b2 : Module R\u2083 M\u2083\ninst\u271d\u00b2\u00b9 : Ring R\ninst\u271d\u00b2\u2070 : Ring R\u2082\ninst\u271d\u00b9\u2079 : AddCommGroup M\ninst\u271d\u00b9\u2078 : AddCommGroup M\u2082\ninst\u271d\u00b9\u2077 : Module R M\ninst\u271d\u00b9\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2075 : Semiring R\ninst\u271d\u00b9\u2074 : Semiring R\u2082\ninst\u271d\u00b9\u00b3 : AddCommMonoid M\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Module R\u2082 M\u2082\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : Semiring R\u2082\ninst\u271d\u2077 : Semiring R\u2083\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : AddCommMonoid M\u2082\ninst\u271d\u2074 : AddCommMonoid M\u2083\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\ninst\u271d\u00b9 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c4\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d : RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083\nhg : ker g = \u22a5\n\u22a2 ker (g \u2218\u209b\u2097 f) = ker f"}, {"line": "rw [ker_comp, hg, Submodule.comap_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofBijective_symm_apply_apply [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {h} (x : M) :\n    (ofBijective f h).symm (f x) = x := by\n  simp [LinearEquiv.symm_apply_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Equiv.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{N : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "{module_M : Module R M} {module_M\u2082 : Module R\u2082 M\u2082} {module_M\u2083 : Module R\u2083 M\u2083}", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}", "{\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083} [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "{\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082}", "{re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}", "{re\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082} {re\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083}", "(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) (e : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083)", "(p q : Submodule R M)", "{p q}", "(p)", "{f g}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Semiring R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\nx\u271d : Sort u_10\nofBijective : x\u271d\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nh : ?m.28400 _fvar.25879 _fvar.26494 _fvar.26814 _fvar.26821\nx : M\n\u22a2 sorry = x"}, {"line": "simp [LinearEquiv.symm_apply_eq]", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Semiring R\u2082\ninst\u271d\u00b2 : AddCommMonoid M\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\n\u03c3\u2082\u2081 : R\u2082 \u2192+* R\nx\u271d : Sort u_10\nofBijective : x\u271d\ninst\u271d\u00b9 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081\ninst\u271d : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082\nh : ?m.28400 _fvar.25879 _fvar.26494 _fvar.26814 _fvar.26821\nx : M\n\u22a2 sorry () = x"}]}
{"declaration": "theorem equivSubtypeMap_symm_apply {p : Submodule R M} {q : Submodule R p} (x : q.map p.subtype) :\n    ((p.equivSubtypeMap q).symm x : M) = x := by\n  cases x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Equiv.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{N : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "{module_M : Module R M} {module_M\u2082 : Module R\u2082 M\u2082} {module_M\u2083 : Module R\u2083 M\u2083}", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}", "{\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083} [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "{\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082}", "{re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}", "{re\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082} {re\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083}", "(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) (e : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083)", "(p q : Submodule R M)", "{p q}", "(p)", "{f g}", "(f)", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\nq : Submodule R \u21a5p\nx : \u21a5(Submodule.map p.subtype q)\n\u22a2 \u2191\u2191((p.equivSubtypeMap q).symm x) = \u2191x"}, {"line": "cases x", "tactic_state": "case mk\nR : Type u_1\nM : Type u_5\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\nq : Submodule R \u21a5p\nval\u271d : M\nproperty\u271d : val\u271d \u2208 Submodule.map p.subtype q\n\u22a2 \u2191\u2191((p.equivSubtypeMap q).symm \u27e8val\u271d, property\u271d\u27e9) = \u2191\u27e8val\u271d, property\u271d\u27e9"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma codRestrictOfInjective_comp_apply (x : M\u2081) :\n    i (LinearMap.codRestrictOfInjective f i hi hf x) = f x := by\n  simp [LinearMap.codRestrictOfInjective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Equiv.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{N : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "{module_M : Module R M} {module_M\u2082 : Module R\u2082 M\u2082} {module_M\u2083 : Module R\u2083 M\u2083}", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R}", "{\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083} [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "{\u03c3\u2083\u2082 : R\u2083 \u2192+* R\u2082}", "{re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}", "{re\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082} {re\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083}", "(f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) (e : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083)", "(p q : Submodule R M)", "{p q}", "(p)", "{f g}", "(f)", "[Semiring R] [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N]", "[CommSemiring R] [AddCommMonoid M] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "(f : M\u2081 \u2192\u2097[R] M\u2082) (i : M\u2083 \u2192\u2097[R] M\u2082) (hi : Injective i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Semiring R\u2082\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M\u2082\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : AddCommMonoid M\u2082\nx\u271d : Sort u_10\ni : x\u271d\nx : M\u2081\n\u22a2 sorry = f sorry"}, {"line": "simp [LinearMap.codRestrictOfInjective]", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2081 : Type u_6\nM\u2082 : Type u_7\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Semiring R\u2082\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M\u2082\nmodule_M : Module R M\nmodule_M\u2082 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\nf : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : Module R M\ninst\u271d\u00b3 : CommSemiring R\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : AddCommMonoid M\u2081\ninst\u271d : AddCommMonoid M\u2082\nx\u271d : Sort u_10\ni : x\u271d\nx : M\u2081\n\u22a2 sorry () = f (sorry ())"}]}
{"declaration": "lemma _root_.LinearEquiv.map_mem_invtSubmodule_iff {R M N : Type*} [CommSemiring R]\n    [AddCommMonoid M] [Module R M] [AddCommMonoid N] [Module R N] {f : End R N}\n    {e : M \u2243\u2097[R] N} {p : Submodule R M} :\n    p.map e \u2208 f.invtSubmodule \u2194 p \u2208 (e.symm.conj f).invtSubmodule := by\n  simp [\u2190 e.map_mem_invtSubmodule_conj_iff, \u2190 LinearEquiv.trans_apply, LinearEquiv.conj_trans]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Invariant.lean", "context": {"open": ["Submodule (span)"], "variables": ["{R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] (f : End R M)", "{f}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "End : ?m.1525\nR\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2077 : Semiring R\u271d\ninst\u271d\u2076 : AddCommMonoid M\u271d\ninst\u271d\u2075 : Module R\u271d M\u271d\nf\u271d : sorry\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nf : sorry\ne : M \u2243\u2097[R] N\np : Submodule R M\n\u22a2 Submodule.map e p \u2208 sorry \u2194 p \u2208 (e.symm.conj sorry).invtSubmodule"}, {"line": "simp [\u2190 e.map_mem_invtSubmodule_conj_iff, \u2190 LinearEquiv.trans_apply, LinearEquiv.conj_trans]", "tactic_state": "End : ?m.1525\nR\u271d : Type u_1\nM\u271d : Type u_2\ninst\u271d\u2077 : Semiring R\u271d\ninst\u271d\u2076 : AddCommMonoid M\u271d\ninst\u271d\u2075 : Module R\u271d M\u271d\nf\u271d : sorry\nR : Type u_3\nM : Type u_4\nN : Type u_5\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : AddCommMonoid N\ninst\u271d : Module R N\nf : sorry\ne : M \u2243\u2097[R] N\np : Submodule R M\n\u22a2 Submodule.map e p \u2208 sorry () \u2194 p \u2208 (e.symm.conj (sorry ())).invtSubmodule"}]}
{"declaration": "theorem subsingleton_iff_eq_bot : Subsingleton p \u2194 p = \u22a5 := by\n  rw [subsingleton_iff]\n  rw [Submodule.eq_bot_iff]\n  refine \u27e8fun h x hx \u21a6 by simpa using h \u27e8x, hx\u27e9 \u27e80, p.zero_mem\u27e9,\n    fun h \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 \u21a6 by simp [h x hx, h y hy]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Lattice.lean", "context": {"open": [], "variables": ["{R S M : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M] [Module S M]", "[SMul S R] [IsScalarTower S R M]", "{p q : Submodule R M}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 Subsingleton \u21a5p \u2194 p = \u22a5"}, {"line": "rw [subsingleton_iff]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 (\u2200 (x y : \u21a5p), x = y) \u2194 p = \u22a5"}, {"line": "rw [Submodule.eq_bot_iff]", "tactic_state": "R : Type u_1\nM : Type u_3\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 (\u2200 (x y : \u21a5p), x = y) \u2194 \u2200 x \u2208 p, x = 0"}, {"line": "refine \u27e8fun h x hx \u21a6 by simpa using h \u27e8x, hx\u27e9 \u27e80, p.zero_mem\u27e9,\n    fun h \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 \u21a6 by simp [h x hx, h y hy]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_mem_sup {R' M' : Type*} [Ring R'] [AddCommGroup M'] [Module R' M']\n    {S T : Submodule R' M'} {s t : M'} (hs : s \u2208 S) (ht : t \u2208 T) : s - t \u2208 S \u2294 T := by\n  rw [sub_eq_add_neg]\n  exact add_mem_sup hs (neg_mem ht)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Lattice.lean", "context": {"open": [], "variables": ["{R S M : Type*}", "[Semiring R] [Semiring S] [AddCommMonoid M] [Module R M] [Module S M]", "[SMul S R] [IsScalarTower S R M]", "{p q : Submodule R M}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R' : Type u_4\nM' : Type u_5\ninst\u271d\u00b2 : Ring R'\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R' M'\nS T : Submodule R' M'\ns t : M'\nhs : s \u2208 S\nht : t \u2208 T\n\u22a2 s - t \u2208 S \u2294 T"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "R' : Type u_4\nM' : Type u_5\ninst\u271d\u00b2 : Ring R'\ninst\u271d\u00b9 : AddCommGroup M'\ninst\u271d : Module R' M'\nS T : Submodule R' M'\ns t : M'\nhs : s \u2208 S\nht : t \u2208 T\n\u22a2 s + -t \u2208 S \u2294 T"}, {"line": "exact add_mem_sup hs (neg_mem ht)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comap_lt_comap_iff_of_surjective {p q : Submodule R\u2082 M\u2082} : p.comap f < q.comap f \u2194 p < q := by\n  apply lt_iff_lt_of_le_iff_le' <;> exact comap_le_comap_iff_of_surjective hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Map.lean", "context": {"open": ["Function Pointwise Set"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "(p p' : Submodule R M) (q q' : Submodule R\u2082 M\u2082)", "{x : M}", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c3\u2081\u2082]", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Surjective f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : Semiring R\u2082\ninst\u271d\u2078 : AddCommMonoid M\ninst\u271d\u2077 : AddCommMonoid M\u2082\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\n\u03c3\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d\u2074 : RingHomSurjective \u03c3\u2081\u2082\nF : Type u_10\ninst\u271d\u00b3 : FunLike F M M\u2082\ninst\u271d\u00b2 : SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082\ninst\u271d\u00b9 inst\u271d : RingHomSurjective \u03c3\u2081\u2082\nf : F\np q : Submodule R\u2082 M\u2082\n\u22a2 Submodule.comap f p < Submodule.comap f q \u2194 p < q"}, {"line": "apply lt_iff_lt_of_le_iff_le' <;> exact comap_le_comap_iff_of_surjective hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_smul' (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V\u2082) (a : K) :\n    p.comap (a \u2022 f) = \u2a05 _ : a \u2260 0, p.comap f := by\n  classical by_cases h : a = 0 <;> simp [h, comap_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Map.lean", "context": {"open": ["Function Pointwise Set"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "(p p' : Submodule R M) (q q' : Submodule R\u2082 M\u2082)", "{x : M}", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c3\u2081\u2082]", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Surjective f)", "{p q}", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Injective f)", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*}", "[EquivLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082] {e : F}", "{p}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M)", "[AddCommGroup M\u2082] [Module R M\u2082]", "{K : Type*} {V : Type*} {V\u2082 : Type*}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\n\u22a2 Submodule.comap (a \u2022 f) p = \u2a05 (_ : a \u2260 0), Submodule.comap f p"}, {"line": "classical by_cases h : a = 0 <;> simp [h, comap_smul]", "tactic_state": "K : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\nh : a = 0\n\u22a2 Submodule.comap (0 \u2022 f) p = \u2a05 (_ : \u00ac0 = 0), Submodule.comap f p\n---\ncase neg\nK : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\u2082\na : K\nh : \u00aca = 0\n\u22a2 Submodule.comap (a \u2022 f) p = \u2a05 (_ : \u00aca = 0), Submodule.comap f p"}]}
{"declaration": "theorem map_smul' (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V) (a : K) :\n    p.map (a \u2022 f) = \u2a06 _ : a \u2260 0, map f p := by\n  classical by_cases h : a = 0 <;> simp [h, Submodule.map_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Map.lean", "context": {"open": ["Function Pointwise Set"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "(p p' : Submodule R M) (q q' : Submodule R\u2082 M\u2082)", "{x : M}", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c3\u2081\u2082]", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Surjective f)", "{p q}", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Injective f)", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*}", "[EquivLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082] {e : F}", "{p}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M)", "[AddCommGroup M\u2082] [Module R M\u2082]", "{K : Type*} {V : Type*} {V\u2082 : Type*}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nx\u271d : Sort u_16\nmap : x\u271d\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\n\u22a2 Submodule.map (a \u2022 f) p = \u2a06 (_ : a \u2260 0), sorry"}, {"line": "classical by_cases h : a = 0 <;> simp [h, Submodule.map_smul]", "tactic_state": "K : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nx\u271d : Sort u_16\nmap : x\u271d\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nx\u271d : Sort u_16\nmap : x\u271d\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\nh : a = 0\n\u22a2 Submodule.map (0 \u2022 f) p = \u2a06 (_ : \u00ac0 = 0), sorry ()\n---\ncase neg\nK : Type u_13\nV : Type u_14\nV\u2082 : Type u_15\ninst\u271d\u2074 : Semifield K\ninst\u271d\u00b3 : AddCommMonoid V\ninst\u271d\u00b2 : Module K V\ninst\u271d\u00b9 : AddCommMonoid V\u2082\ninst\u271d : Module K V\u2082\nx\u271d : Sort u_16\nmap : x\u271d\nf : V \u2192\u2097[K] V\u2082\np : Submodule K V\na : K\nh : \u00aca = 0\n\u22a2 Submodule.map (a \u2022 f) p = \u2a06 (_ : \u00aca = 0), sorry ()"}]}
{"declaration": "theorem map_symm_eq_iff (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {K : Submodule R\u2082 M\u2082} :\n    K.map e.symm = p \u2194 p.map e = K := by\n  constructor <;> rintro rfl\n  \u00b7 calc\n      map e (map e.symm K) = comap e.symm (map e.symm K) := map_equiv_eq_comap_symm _ _\n      _ = K := comap_map_eq_of_injective e.symm.injective _\n  \u00b7 calc\n      map e.symm (map e p) = comap e (map e p) := (comap_equiv_eq_map_symm _ _).symm\n      _ = p := comap_map_eq_of_injective e.injective _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Map.lean", "context": {"open": ["Function Pointwise Set"], "variables": ["{R : Type*} {R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{M : Type*} {M\u2081 : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083]", "(p p' : Submodule R M) (q q' : Submodule R\u2082 M\u2082)", "{x : M}", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "{\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c3\u2081\u2082]", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Surjective f)", "{p q}", "[RingHomSurjective \u03c3\u2081\u2082] {f : F}", "(hf : Injective f)", "[RingHomSurjective \u03c3\u2081\u2082] {F : Type*}", "[EquivLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082] {e : F}", "{p}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c3\u2081\u2082 M M\u2082]", "[Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M)", "[AddCommGroup M\u2082] [Module R M\u2082]", "{K : Type*} {V : Type*} {V\u2082 : Type*}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Semiring R] [Semiring R\u2082]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2081 : R\u2082 \u2192+* R}", "[RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081] [RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082]", "(p : Submodule R M) (q : Submodule R\u2082 M\u2082)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u00b2\u00b9 : Semiring R\ninst\u271d\u00b2\u2070 : Semiring R\u2082\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2077 : Module R M\ninst\u271d\u00b9\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b9 : Module R M\u2082\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\ne : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nK : Submodule R\u2082 M\u2082\n\u22a2 Submodule.map e.symm K = p \u2194 Submodule.map e p = K"}, {"line": "constructor <;> rintro rfl", "tactic_state": "case mp\nR : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u00b2\u00b9 : Semiring R\ninst\u271d\u00b2\u2070 : Semiring R\u2082\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2077 : Module R M\ninst\u271d\u00b9\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b9 : Module R M\u2082\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\ne : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nK : Submodule R\u2082 M\u2082\n\u22a2 Submodule.map e (Submodule.map e.symm K) = K\n---\ncase mpr\nR : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u00b2\u00b9 : Semiring R\ninst\u271d\u00b2\u2070 : Semiring R\u2082\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2077 : Module R M\ninst\u271d\u00b9\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b9 : Module R M\u2082\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\ne : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 Submodule.map e.symm (Submodule.map e p) = p"}, {"line": "\u00b7 calc\n      map e (map e.symm K) = comap e.symm (map e.symm K) := map_equiv_eq_comap_symm _ _\n      _ = K := comap_map_eq_of_injective e.symm.injective _", "tactic_state": "case mpr\nR : Type u_1\nR\u2082 : Type u_3\nM : Type u_5\nM\u2082 : Type u_7\ninst\u271d\u00b2\u00b9 : Semiring R\ninst\u271d\u00b2\u2070 : Semiring R\u2082\ninst\u271d\u00b9\u2079 : AddCommMonoid M\ninst\u271d\u00b9\u2078 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2077 : Module R M\ninst\u271d\u00b9\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2075 : Ring R\ninst\u271d\u00b9\u2074 : AddCommGroup M\ninst\u271d\u00b9\u00b3 : Module R M\ninst\u271d\u00b9\u00b2 : AddCommGroup M\u2082\ninst\u271d\u00b9\u00b9 : Module R M\u2082\ninst\u271d\u00b9\u2070 : Semiring R\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : Semiring R\u2082\ninst\u271d\u2075 : AddCommMonoid M\ninst\u271d\u2074 : AddCommMonoid M\u2082\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d\u00b9 : RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081\ninst\u271d : RingHomInvPair \u03c4\u2082\u2081 \u03c4\u2081\u2082\np : Submodule R M\ne : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 Submodule.map e.symm (Submodule.map e p) = p"}, {"line": "\u00b7 calc\n      map e.symm (map e p) = comap e (map e p) := (comap_equiv_eq_map_symm _ _).symm\n      _ = p := comap_map_eq_of_injective e.injective _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma smul_def (a : \u03b1) (S : Submodule R M) : a \u2022 S = span R (a \u2022 S : Set M) := by simp [\u2190 smul_span]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Pointwise.lean", "context": {"open": ["Pointwise", "Pointwise", "Pointwise", "Pointwise"], "variables": ["{\u03b1 : Type*} {R : Type*} {M : Type*}", "[Semiring R] [AddCommGroup M] [Module R M]", "[Semiring R] [AddCommMonoid M] [Module R M]", "[Monoid \u03b1] [DistribMulAction \u03b1 M] [SMulCommClass \u03b1 R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DistribMulAction \u03b1 M\ninst\u271d : SMulCommClass \u03b1 R M\nx\u271d : Sort u_4\nspan : x\u271d\na : \u03b1\nS : Submodule R M\n\u22a2 sorry"}, {"line": "simp [\u2190 smul_span]", "tactic_state": "\u03b1 : Type u_1\nR : Type u_2\nM : Type u_3\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommGroup M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Monoid \u03b1\ninst\u271d\u00b9 : DistribMulAction \u03b1 M\ninst\u271d : SMulCommClass \u03b1 R M\nx\u271d : Sort u_4\nspan : x\u271d\na : \u03b1\nS : Submodule R M\n\u22a2 sorry ()"}]}
{"declaration": "lemma range_domRestrict_le_range [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (S : Submodule R M) :\n    LinearMap.range (f.domRestrict S) \u2264 LinearMap.range f := by\n  rintro x \u27e8\u27e8y, hy\u27e9, rfl\u27e9\n  exact LinearMap.mem_range_self f y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nS : Submodule R M\n\u22a2 LinearMap.range (f.domRestrict S) \u2264 LinearMap.range f"}, {"line": "rintro x \u27e8\u27e8y, hy\u27e9, rfl\u27e9", "tactic_state": "case intro.mk\nR : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\nS : Submodule R M\ny : M\nhy : y \u2208 S\n\u22a2 (f.domRestrict S) \u27e8y, hy\u27e9 \u2208 LinearMap.range f"}, {"line": "exact LinearMap.mem_range_self f y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_codRestrict {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [RingHomSurjective \u03c4\u2082\u2081] (p : Submodule R M)\n    (f : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M) (hf) :\n    range (codRestrict p f hf) = comap p.subtype (LinearMap.range f) := by\n  simpa only [range_eq_map] using map_codRestrict _ _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\nx\u271d : Sort u_12\nrange : x\u271d\n\u03c4\u2082\u2081 : R\u2082 \u2192+* R\ninst\u271d : RingHomSurjective \u03c4\u2082\u2081\np : Submodule R M\nf : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M\nhf : ?m.11498 p f\n\u22a2 sorry = comap p.subtype (LinearMap.range f)"}, {"line": "simpa only [range_eq_map] using map_codRestrict _ _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_subtype : range p.subtype = p := by simpa using map_comap_subtype p \u22a4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 range p.subtype = p"}, {"line": "simpa using map_comap_subtype p \u22a4", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_top : map p.subtype (\u22a4 : Submodule R p) = p := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np : Submodule R M\n\u22a2 map p.subtype \u22a4 = p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_subtype_range_inclusion {p p' : Submodule R M} (h : p \u2264 p') :\n    map p'.subtype (range <| inclusion h) = p := by simp [range_inclusion, map_comap_eq, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : AddCommMonoid M\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\np p' : Submodule R M\nh : p \u2264 p'\n\u22a2 map p'.subtype (range (inclusion h)) = p"}, {"line": "simp [range_inclusion, map_comap_eq, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_comp_of_range_eq_top [RingHomSurjective \u03c4\u2081\u2082] [RingHomSurjective \u03c4\u2082\u2083]\n    [RingHomSurjective \u03c4\u2081\u2083] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) (hf : range f = \u22a4) :\n    range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = range g := by rw [range_comp, hf, Submodule.map_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nR\u2083 : Type u_3\nM : Type u_5\nM\u2082 : Type u_6\nM\u2083 : Type u_7\ninst\u271d\u00b3\u00b3 : Semiring R\ninst\u271d\u00b3\u00b2 : Semiring R\u2082\ninst\u271d\u00b3\u00b9 : Semiring R\u2083\ninst\u271d\u00b3\u2070 : AddCommMonoid M\ninst\u271d\u00b2\u2079 : AddCommMonoid M\u2082\ninst\u271d\u00b2\u2078 : AddCommMonoid M\u2083\ninst\u271d\u00b2\u2077 : Module R M\ninst\u271d\u00b2\u2076 : Module R\u2082 M\u2082\ninst\u271d\u00b2\u2075 : Module R\u2083 M\u2083\ninst\u271d\u00b2\u2074 : Ring R\ninst\u271d\u00b2\u00b3 : Ring R\u2082\ninst\u271d\u00b2\u00b2 : AddCommGroup M\ninst\u271d\u00b2\u00b9 : AddCommGroup M\u2082\ninst\u271d\u00b2\u2070 : Module R M\ninst\u271d\u00b9\u2079 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2078 : Semiring R\ninst\u271d\u00b9\u2077 : Semiring R\u2082\ninst\u271d\u00b9\u2076 : AddCommMonoid M\ninst\u271d\u00b9\u2075 : AddCommMonoid M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : Semiring R\u2083\ninst\u271d\u2079 : AddCommMonoid M\ninst\u271d\u2078 : AddCommMonoid M\u2082\ninst\u271d\u2077 : AddCommMonoid M\u2083\ninst\u271d\u2076 : Module R M\ninst\u271d\u2075 : Module R\u2082 M\u2082\ninst\u271d\u2074 : Module R\u2083 M\u2083\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\n\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083\n\u03c4\u2081\u2083 : R \u2192+* R\u2083\ninst\u271d\u00b3 : RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083\ninst\u271d\u00b2 : RingHomSurjective \u03c4\u2081\u2082\ninst\u271d\u00b9 : RingHomSurjective \u03c4\u2082\u2083\ninst\u271d : RingHomSurjective \u03c4\u2081\u2083\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\ng : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083\nhf : range f = \u22a4\n\u22a2 range (g \u2218\u209b\u2097 f) = range g"}, {"line": "rw [range_comp, hf, Submodule.map_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_submoduleImage {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {\u03d5 : O \u2192\u2097[R] M'} {N : Submodule R M} {x : M'} :\n    x \u2208 \u03d5.submoduleImage N \u2194 \u2203 (y : _) (yO : y \u2208 O), y \u2208 N \u2227 \u03d5 \u27e8y, yO\u27e9 = x := by\n  refine Submodule.mem_map.trans \u27e8?_, ?_\u27e9 <;> simp_rw [Submodule.mem_comap]\n  \u00b7 rintro \u27e8\u27e8y, yO\u27e9, yN : y \u2208 N, h\u27e9\n    exact \u27e8y, yO, yN, h\u27e9\n  \u00b7 rintro \u27e8y, yO, yN, h\u27e9\n    exact \u27e8\u27e8y, yO\u27e9, yN, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nx : M'\n\u22a2 x \u2208 \u03d5.submoduleImage N \u2194 \u2203 y, \u2203 (yO : y \u2208 O), y \u2208 N \u2227 \u03d5 \u27e8y, yO\u27e9 = x"}, {"line": "refine Submodule.mem_map.trans \u27e8?_, ?_\u27e9 <;> simp_rw [Submodule.mem_comap]", "tactic_state": "case refine_1\nR : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nx : M'\n\u22a2 (\u2203 y, O.subtype y \u2208 N \u2227 \u03d5 y = x) \u2192 \u2203 y, \u2203 (yO : y \u2208 O), y \u2208 N \u2227 \u03d5 \u27e8y, yO\u27e9 = x\n---\ncase refine_2\nR : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nx : M'\n\u22a2 (\u2203 y, \u2203 (yO : y \u2208 O), y \u2208 N \u2227 \u03d5 \u27e8y, yO\u27e9 = x) \u2192 \u2203 y, O.subtype y \u2208 N \u2227 \u03d5 y = x"}, {"line": "\u00b7 rintro \u27e8\u27e8y, yO\u27e9, yN : y \u2208 N, h\u27e9\n    exact \u27e8y, yO, yN, h\u27e9", "tactic_state": "case refine_2\nR : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nx : M'\n\u22a2 (\u2203 y, \u2203 (yO : y \u2208 O), y \u2208 N \u2227 \u03d5 \u27e8y, yO\u27e9 = x) \u2192 \u2203 y, O.subtype y \u2208 N \u2227 \u03d5 y = x"}, {"line": "\u00b7 rintro \u27e8y, yO, yN, h\u27e9\n    exact \u27e8\u27e8y, yO\u27e9, yN, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem submoduleImage_apply_of_le {M' : Type*} [AddCommMonoid M'] [Module R M']\n    {O : Submodule R M} (\u03d5 : O \u2192\u2097[R] M') (N : Submodule R M) (hNO : N \u2264 O) :\n    \u03d5.submoduleImage N = range (\u03d5.comp (Submodule.inclusion hNO)) := by\n  rw [submoduleImage]\n  rw [range_comp]\n  rw [Submodule.range_inclusion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nhNO : N \u2264 O\n\u22a2 \u03d5.submoduleImage N = range (\u03d5 \u2218\u2097 inclusion hNO)"}, {"line": "rw [submoduleImage]", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nhNO : N \u2264 O\n\u22a2 map \u03d5 (comap O.subtype N) = range (\u03d5 \u2218\u2097 inclusion hNO)"}, {"line": "rw [range_comp]", "tactic_state": "R : Type u_1\nM : Type u_5\ninst\u271d\u00b9\u00b3 : Semiring R\ninst\u271d\u00b9\u00b2 : AddCommMonoid M\ninst\u271d\u00b9\u00b9 : Module R M\ninst\u271d\u00b9\u2070 : Ring R\ninst\u271d\u2079 : AddCommGroup M\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : AddCommMonoid M\ninst\u271d\u2075 : Module R M\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : AddCommMonoid M\ninst\u271d\u00b2 : Module R M\nM' : Type u_14\ninst\u271d\u00b9 : AddCommMonoid M'\ninst\u271d : Module R M'\nO : Submodule R M\n\u03d5 : \u21a5O \u2192\u2097[R] M'\nN : Submodule R M\nhNO : N \u2264 O\n\u22a2 map \u03d5 (comap O.subtype N) = map \u03d5 (range (inclusion hNO))"}, {"line": "rw [Submodule.range_inclusion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjective_rangeRestrict : Surjective f.rangeRestrict := by\n  rw [\u2190 range_eq_top]\n  rw [range_rangeRestrict]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/Range.lean", "context": {"open": ["Function", "Submodule", "Submodule", "LinearMap"], "variables": ["{R : Type*} {R\u2082 : Type*} {R\u2083 : Type*}", "{K : Type*}", "{M : Type*} {M\u2082 : Type*} {M\u2083 : Type*}", "{V : Type*} {V\u2082 : Type*}", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[RingHomSurjective \u03c4\u2081\u2082]", "[Ring R] [Ring R\u2082]", "[AddCommGroup M] [AddCommGroup M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "{f : F}", "[Semifield K]", "[AddCommMonoid V] [Module K V]", "[AddCommMonoid V\u2082] [Module K V\u2082]", "[Semiring R] [Semiring R\u2082] [AddCommMonoid M] [AddCommMonoid M\u2082]", "[Module R M] [Module R\u2082 M\u2082]", "(p : Submodule R M)", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082}", "{F : Type*} [FunLike F M M\u2082] [SemilinearMapClass F \u03c4\u2081\u2082 M M\u2082]", "[Semiring R] [Semiring R\u2082] [Semiring R\u2083]", "[AddCommMonoid M] [AddCommMonoid M\u2082] [AddCommMonoid M\u2083]", "[Module R M] [Module R\u2082 M\u2082] [Module R\u2083 M\u2083]", "{\u03c4\u2081\u2082 : R \u2192+* R\u2082} {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083}", "[RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]", "[RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b2\u2074 : Semiring R\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : AddCommMonoid M\ninst\u271d\u00b2\u00b9 : AddCommMonoid M\u2082\ninst\u271d\u00b2\u2070 : Module R M\ninst\u271d\u00b9\u2079 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2078 : Ring R\ninst\u271d\u00b9\u2077 : Ring R\u2082\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Module R\u2082 M\u2082\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 Surjective \u21d1f.rangeRestrict"}, {"line": "rw [\u2190 range_eq_top]", "tactic_state": "R : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b2\u2074 : Semiring R\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : AddCommMonoid M\ninst\u271d\u00b2\u00b9 : AddCommMonoid M\u2082\ninst\u271d\u00b2\u2070 : Module R M\ninst\u271d\u00b9\u2079 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2078 : Ring R\ninst\u271d\u00b9\u2077 : Ring R\u2082\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Module R\u2082 M\u2082\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 range f.rangeRestrict = \u22a4\n---\nR : Type u_1\nR\u2082 : Type u_2\nM : Type u_5\nM\u2082 : Type u_6\ninst\u271d\u00b2\u2074 : Semiring R\ninst\u271d\u00b2\u00b3 : Semiring R\u2082\ninst\u271d\u00b2\u00b2 : AddCommMonoid M\ninst\u271d\u00b2\u00b9 : AddCommMonoid M\u2082\ninst\u271d\u00b2\u2070 : Module R M\ninst\u271d\u00b9\u2079 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u2078 : Ring R\ninst\u271d\u00b9\u2077 : Ring R\u2082\ninst\u271d\u00b9\u2076 : AddCommGroup M\ninst\u271d\u00b9\u2075 : AddCommGroup M\u2082\ninst\u271d\u00b9\u2074 : Module R M\ninst\u271d\u00b9\u00b3 : Module R\u2082 M\u2082\ninst\u271d\u00b9\u00b2 : Semiring R\ninst\u271d\u00b9\u00b9 : Semiring R\u2082\ninst\u271d\u00b9\u2070 : AddCommMonoid M\ninst\u271d\u2079 : AddCommMonoid M\u2082\ninst\u271d\u2078 : Module R M\ninst\u271d\u2077 : Module R\u2082 M\u2082\ninst\u271d\u2076 : Semiring R\ninst\u271d\u2075 : Semiring R\u2082\ninst\u271d\u2074 : AddCommMonoid M\ninst\u271d\u00b3 : AddCommMonoid M\u2082\ninst\u271d\u00b2 : Module R M\ninst\u271d\u00b9 : Module R\u2082 M\u2082\n\u03c4\u2081\u2082 : R \u2192+* R\u2082\ninst\u271d : RingHomSurjective \u03c4\u2081\u2082\nf : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\n\u22a2 RingHomSurjective \u03c4\u2081\u2082"}, {"line": "rw [range_rangeRestrict]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrictScalars_eq_bot_iff {p : Submodule R M} : restrictScalars S p = \u22a5 \u2194 p = \u22a5 := by\n  simp [SetLike.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/RestrictScalars.lean", "context": {"open": [], "variables": ["(S : Type*) {R M : Type*} [Semiring R] [AddCommMonoid M] [Semiring S]", "(R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nrestrictScalars : x\u271d\np : sorry\n\u22a2 sorry = \u22a5 \u2194 p = \u22a5"}, {"line": "simp [SetLike.ext_iff]", "tactic_state": "x\u271d : Sort u_4\nrestrictScalars : x\u271d\np : sorry\n\u22a2 sorry () = \u22a5 \u2194 p = \u22a5"}]}
{"declaration": "theorem restrictScalars_eq_top_iff {p : Submodule R M} : restrictScalars S p = \u22a4 \u2194 p = \u22a4 := by\n  simp [SetLike.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/Submodule/RestrictScalars.lean", "context": {"open": [], "variables": ["(S : Type*) {R M : Type*} [Semiring R] [AddCommMonoid M] [Semiring S]", "(R M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nrestrictScalars : x\u271d\np : sorry\n\u22a2 sorry = \u22a4 \u2194 p = \u22a4"}, {"line": "simp [SetLike.ext_iff]", "tactic_state": "x\u271d : Sort u_4\nrestrictScalars : x\u271d\np : sorry\n\u22a2 sorry () = \u22a4 \u2194 p = \u22a4"}]}
{"declaration": "theorem map {F : Type*} [AddCommGroup F] [Module K F] (f : E \u2243\u2097[K] F) :\n    Submodule.map (f.restrictScalars \u2124) (span \u2124 (Set.range b)) = span \u2124 (Set.range (b.map f)) := by\n  simp_rw [Submodule.map_span, LinearEquiv.restrictScalars_apply, Basis.coe_map, Set.range_comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/ZLattice/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSet Submodule Bornology"], "variables": ["{E \u03b9 : Type*}", "{K : Type*} [NormedField K]", "[NormedAddCommGroup E] [NormedSpace K E]", "(b : Basis \u03b9 K E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\n\u03b9 : Type u_2\nK : Type u_3\ninst\u271d\u2074 : NormedField K\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace K E\nb : Basis \u03b9 K E\nF : Type u_4\ninst\u271d\u00b9 : AddCommGroup F\ninst\u271d : Module K F\nf : E \u2243\u2097[K] F\n\u22a2 Submodule.map (LinearEquiv.restrictScalars \u2124 f) (span \u2124 (Set.range \u21d1b)) = span \u2124 (Set.range \u21d1(b.map f))"}, {"line": "simp_rw [Submodule.map_span, LinearEquiv.restrictScalars_apply, Basis.coe_map, Set.range_comp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measureReal_fundamentalDomain\n    [Fintype \u03b9] [DecidableEq \u03b9] [MeasurableSpace E] (\u03bc : Measure E)\n    [BorelSpace E] [Measure.IsAddHaarMeasure \u03bc] (b\u2080 : Basis \u03b9 \u211d E) :\n    \u03bc.real (fundamentalDomain b) = |b\u2080.det b| * \u03bc.real (fundamentalDomain b\u2080) := by\n  simp [measureReal_def, measure_fundamentalDomain b \u03bc b\u2080]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/ZLattice/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSet Submodule Bornology", "scoped Pointwise in"], "variables": ["{E \u03b9 : Type*}", "{K : Type*} [NormedField K]", "[NormedAddCommGroup E] [NormedSpace K E]", "(b : Basis \u03b9 K E)", "[LinearOrder K]", "[IsStrictOrderedRing K]", "[FloorRing K]", "[Fintype \u03b9]", "{b} in", "[Unique \u03b9]", "[NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\n\u03b9 : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : Fintype \u03b9\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\nb : Basis \u03b9 \u211d E\nx\u271d : Sort u_2\nfundamentalDomain : x\u271d\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : MeasurableSpace E\n\u03bc : Measure E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : \u03bc.IsAddHaarMeasure\nb\u2080 : Basis \u03b9 \u211d E\n\u22a2 \u03bc.real sorry = |b\u2080.det \u21d1b| * \u03bc.real sorry"}, {"line": "simp [measureReal_def, measure_fundamentalDomain b \u03bc b\u2080]", "tactic_state": "E : Type u_4\n\u03b9 : Type u_3\ninst\u271d\u2078 : NormedAddCommGroup E\ninst\u271d\u2077 : Fintype \u03b9\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \u211d E\nb : Basis \u03b9 \u211d E\nx\u271d : Sort u_2\nfundamentalDomain : x\u271d\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : MeasurableSpace E\n\u03bc : Measure E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : \u03bc.IsAddHaarMeasure\nb\u2080 : Basis \u03b9 \u211d E\n\u22a2 (\u03bc (sorry ())).toReal = |b\u2080.det \u21d1b| * (\u03bc (sorry ())).toReal"}]}
{"declaration": "theorem ZLattice.module_free [IsZLattice K L] : Module.Free \u2124 L := by\n  have : Module.Finite \u2124 L := module_finite K L\n  have : Module \u211a E := Module.compHom E (algebraMap \u211a K)\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/ZLattice/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSet Submodule Bornology", "scoped Pointwise in", "Submodule Module ZSpan"], "variables": ["{E \u03b9 : Type*}", "{K : Type*} [NormedField K]", "[NormedAddCommGroup E] [NormedSpace K E]", "(b : Basis \u03b9 K E)", "[LinearOrder K]", "[IsStrictOrderedRing K]", "[FloorRing K]", "[Fintype \u03b9]", "{b} in", "[Unique \u03b9]", "[NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)", "(K : Type*) [NormedField K] [LinearOrder K] [IsStrictOrderedRing K]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]", "[ProperSpace E] (L : Submodule \u2124 E) [DiscreteTopology L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\ninst\u271d\u2078 : NormedField K\ninst\u271d\u2077 : LinearOrder K\ninst\u271d\u2076 : IsStrictOrderedRing K\nE : Type u_5\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace K E\ninst\u271d\u00b3 : FiniteDimensional K E\ninst\u271d\u00b2 : ProperSpace E\nL : Submodule \u2124 E\ninst\u271d\u00b9 : DiscreteTopology \u21a5L\ninst\u271d : IsZLattice K L\n\u22a2 Module.Free \u2124 \u21a5L"}, {"line": "have : Module.Finite \u2124 L := module_finite K L", "tactic_state": "K : Type u_4\ninst\u271d\u2078 : NormedField K\ninst\u271d\u2077 : LinearOrder K\ninst\u271d\u2076 : IsStrictOrderedRing K\nE : Type u_5\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace K E\ninst\u271d\u00b3 : FiniteDimensional K E\ninst\u271d\u00b2 : ProperSpace E\nL : Submodule \u2124 E\ninst\u271d\u00b9 : DiscreteTopology \u21a5L\ninst\u271d : IsZLattice K L\nthis : Module.Finite \u2124 \u21a5L\n\u22a2 Module.Free \u2124 \u21a5L"}, {"line": "have : Module \u211a E := Module.compHom E (algebraMap \u211a K)", "tactic_state": "K : Type u_4\ninst\u271d\u2078 : NormedField K\ninst\u271d\u2077 : LinearOrder K\ninst\u271d\u2076 : IsStrictOrderedRing K\nE : Type u_5\ninst\u271d\u2075 : NormedAddCommGroup E\ninst\u271d\u2074 : NormedSpace K E\ninst\u271d\u00b3 : FiniteDimensional K E\ninst\u271d\u00b2 : ProperSpace E\nL : Submodule \u2124 E\ninst\u271d\u00b9 : DiscreteTopology \u21a5L\ninst\u271d : IsZLattice K L\nthis\u271d : Module.Finite \u2124 \u21a5L\nthis : sorry\n\u22a2 Module.Free \u2124 \u21a5L"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Basis.ofZLatticeBasis_apply (i : \u03b9) :\n    b.ofZLatticeBasis K L i = b i := by simp [Basis.ofZLatticeBasis]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/ZLattice/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSet Submodule Bornology", "scoped Pointwise in", "Submodule Module ZSpan", "Module"], "variables": ["{E \u03b9 : Type*}", "{K : Type*} [NormedField K]", "[NormedAddCommGroup E] [NormedSpace K E]", "(b : Basis \u03b9 K E)", "[LinearOrder K]", "[IsStrictOrderedRing K]", "[FloorRing K]", "[Fintype \u03b9]", "{b} in", "[Unique \u03b9]", "[NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)", "(K : Type*) [NormedField K] [LinearOrder K] [IsStrictOrderedRing K]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]", "[ProperSpace E] (L : Submodule \u2124 E) [DiscreteTopology L]", "{\u03b9 : Type*} [hs : IsZLattice K L] (b : Basis \u03b9 \u2124 L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ProperSpace E\nL : Submodule \u2124 E\ninst\u271d : DiscreteTopology \u21a5L\n\u03b9 : Type u_6\nb : Basis \u03b9 \u2124 \u21a5L\ni : \u03b9\n\u22a2 sorry = b i"}, {"line": "simp [Basis.ofZLatticeBasis]", "tactic_state": "E : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : ProperSpace E\nL : Submodule \u2124 E\ninst\u271d : DiscreteTopology \u21a5L\n\u03b9 : Type u_6\nb : Basis \u03b9 \u2124 \u21a5L\ni : \u03b9\n\u22a2 sorry () = b i"}]}
{"declaration": "theorem ZLattice.isAddFundamentalDomain {E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]\n    [FiniteDimensional \u211d E] {L : Submodule \u2124 E} [DiscreteTopology L] [IsZLattice \u211d L] [Finite \u03b9]\n    (b : Basis \u03b9 \u2124 L) [MeasurableSpace E] [OpensMeasurableSpace E] (\u03bc : Measure E) :\n    IsAddFundamentalDomain L (fundamentalDomain (b.ofZLatticeBasis \u211d)) \u03bc := by\n  convert ZSpan.isAddFundamentalDomain (b.ofZLatticeBasis \u211d) \u03bc\n  all_goals exact (b.ofZLatticeBasis_span \u211d).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Module/ZLattice/Basic.lean", "context": {"open": ["MeasureTheory MeasurableSet Submodule Bornology", "scoped Pointwise in", "Submodule Module ZSpan", "Module", "MeasureTheory in"], "variables": ["{E \u03b9 : Type*}", "{K : Type*} [NormedField K]", "[NormedAddCommGroup E] [NormedSpace K E]", "(b : Basis \u03b9 K E)", "[LinearOrder K]", "[IsStrictOrderedRing K]", "[FloorRing K]", "[Fintype \u03b9]", "{b} in", "[Unique \u03b9]", "[NormedAddCommGroup E] [NormedSpace \u211d E] (b : Basis \u03b9 \u211d E)", "(K : Type*) [NormedField K] [LinearOrder K] [IsStrictOrderedRing K]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace K E] [FiniteDimensional K E]", "[ProperSpace E] (L : Submodule \u2124 E) [DiscreteTopology L]", "{\u03b9 : Type*} [hs : IsZLattice K L] (b : Basis \u03b9 \u2124 L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 IsAddFundamentalDomain \u21a5L sorry \u03bc"}, {"line": "convert ZSpan.isAddFundamentalDomain (b.ofZLatticeBasis \u211d) \u03bc", "tactic_state": "case h.e'_1.h.e'_2.h.h.e'_4\n\u03b9 : Type u_4\nx\u271d\u00b9 : Sort u_6\nfundamentalDomain : x\u271d\u00b9\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\nx\u271d : E\n\u22a2 L = span \u2124 (Set.range \u21d1(Basis.ofZLatticeBasis \u211d L b))\n---\ncase h.e'_3.e'_6\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\ne_1\u271d : \u21a5L = \u21a5(span \u2124 (Set.range \u21d1(Basis.ofZLatticeBasis \u211d L b)))\n\u22a2 L = span \u2124 (Set.range \u21d1(Basis.ofZLatticeBasis \u211d L b))\n---\ncase h.e'_4.e'_6\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\ne_1\u271d : \u21a5L = \u21a5(span \u2124 (Set.range \u21d1(Basis.ofZLatticeBasis \u211d L b)))\n\u22a2 L = span \u2124 (Set.range \u21d1(Basis.ofZLatticeBasis \u211d L b))\n---\ncase h.e'_6\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 sorry = ZSpan.fundamentalDomain (Basis.ofZLatticeBasis \u211d L b)\n---\ncase convert_1\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 NormedSpace \u211d E\n---\ncase convert_2\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 FiniteDimensional \u211d E\n---\ncase convert_3\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 ProperSpace E\n---\ncase convert_4\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 DiscreteTopology \u21a5L\n---\ncase convert_5\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 IsZLattice \u211d L\n---\ncase convert_6\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 Finite \u03b9\n---\ncase convert_7\n\u03b9 : Type u_4\nx\u271d : Sort u_6\nfundamentalDomain : x\u271d\nE : Type u_5\ninst\u271d\u2077 : NormedAddCommGroup E\ninst\u271d\u2076 : NormedSpace \u211d E\ninst\u271d\u2075 : FiniteDimensional \u211d E\nL : Submodule \u2124 E\ninst\u271d\u2074 : DiscreteTopology \u21a5L\ninst\u271d\u00b3 : IsZLattice \u211d L\ninst\u271d\u00b2 : Finite \u03b9\nb : Basis \u03b9 \u2124 \u21a5L\ninst\u271d\u00b9 : MeasurableSpace E\ninst\u271d : OpensMeasurableSpace E\n\u03bc : Measure E\n\u22a2 OpensMeasurableSpace E"}, {"line": "all_goals exact (b.ofZLatticeBasis_span \u211d).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of'_divOf (a : G) : of' k G a /\u1d52\u1da0 a = 1 := by\n  simpa only [one_mul] using mul_of'_divOf (1 : k[G]) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Division.lean", "context": {"open": [], "variables": ["{k G : Type*} [Semiring k]", "[AddCommMonoid G]", "[IsCancelAdd G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : AddCommMonoid G\ninst\u271d : IsCancelAdd G\nx\u271d : Sort u_3\nof' : x\u271d\na : G\n\u22a2 sorry / sorry = 1"}, {"line": "simpa only [one_mul] using mul_of'_divOf (1 : k[G]) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of'_modOf (g : G) : of' k G g %\u1d52\u1da0 g = 0 := by\n  simpa only [one_mul] using mul_of'_modOf (1 : k[G]) g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Division.lean", "context": {"open": [], "variables": ["{k G : Type*} [Semiring k]", "[AddCommMonoid G]", "[IsCancelAdd G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : AddCommMonoid G\ninst\u271d : IsCancelAdd G\nx\u271d : Sort u_3\nof' : x\u271d\ng : G\n\u22a2 sorry % sorry = 0"}, {"line": "simpa only [one_mul] using mul_of'_modOf (1 : k[G]) g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_mul [Mul G] [DecidableEq G] (a b : MonoidAlgebra k G) :\n    (a * b).support \u2286 a.support * b.support := by\n  rw [MonoidAlgebra.mul_def]\n  exact support_sum.trans <| biUnion_subset.2 fun _x hx \u21a6\n    support_sum.trans <| biUnion_subset.2 fun _y hy \u21a6\n      support_single_subset.trans <| singleton_subset_iff.2 <| mem_image\u2082_of_mem hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Support.lean", "context": {"open": ["scoped Pointwise", "Finset Finsupp"], "variables": ["{k : Type u\u2081} {G : Type u\u2082} [Semiring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : Mul G\ninst\u271d : DecidableEq G\na b : MonoidAlgebra k G\n\u22a2 (a * b).support \u2286 a.support * b.support"}, {"line": "rw [MonoidAlgebra.mul_def]", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b2 : Semiring k\ninst\u271d\u00b9 : Mul G\ninst\u271d : DecidableEq G\na b : MonoidAlgebra k G\n\u22a2 (sum a fun a\u2081 b\u2081 => sum b fun a\u2082 b\u2082 => MonoidAlgebra.single (a\u2081 * a\u2082) (b\u2081 * b\u2082)).support \u2286 a.support * b.support"}, {"line": "exact support_sum.trans <| biUnion_subset.2 fun _x hx \u21a6\n    support_sum.trans <| biUnion_subset.2 fun _y hy \u21a6\n      support_single_subset.trans <| singleton_subset_iff.2 <| mem_image\u2082_of_mem hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toAddMonoidAlgebra_mul [AddMonoid \u03b9] [Semiring M]\n    [\u2200 m : M, Decidable (m \u2260 0)] (f g : \u2a01 _ : \u03b9, M) :\n    (f * g).toAddMonoidAlgebra = toAddMonoidAlgebra f * toAddMonoidAlgebra g := by\n  apply_fun AddMonoidAlgebra.toDirectSum\n  \u00b7 simp\n  \u00b7 apply Function.LeftInverse.injective\n    apply AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/ToDirectSum.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*} {A : Type*}", "[DecidableEq \u03b9] [Semiring M]", "[\u2200 m : M, Decidable (m \u2260 0)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Semiring M\ninst\u271d\u2074 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddMonoid \u03b9\ninst\u271d\u00b9 : Semiring M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf g : DirectSum \u03b9 fun x => M\n\u22a2 (f * g).toAddMonoidAlgebra = f.toAddMonoidAlgebra * g.toAddMonoidAlgebra"}, {"line": "apply_fun AddMonoidAlgebra.toDirectSum", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Semiring M\ninst\u271d\u2074 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddMonoid \u03b9\ninst\u271d\u00b9 : Semiring M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf g : DirectSum \u03b9 fun x => M\n\u22a2 (f * g).toAddMonoidAlgebra.toDirectSum = (f.toAddMonoidAlgebra * g.toAddMonoidAlgebra).toDirectSum\n---\ncase inj\n\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Semiring M\ninst\u271d\u2074 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddMonoid \u03b9\ninst\u271d\u00b9 : Semiring M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf g : DirectSum \u03b9 fun x => M\n\u22a2 Function.Injective AddMonoidAlgebra.toDirectSum"}, {"line": "\u00b7 simp", "tactic_state": "case inj\n\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Semiring M\ninst\u271d\u2074 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddMonoid \u03b9\ninst\u271d\u00b9 : Semiring M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf g : DirectSum \u03b9 fun x => M\n\u22a2 Function.Injective AddMonoidAlgebra.toDirectSum"}, {"line": "\u00b7 apply Function.LeftInverse.injective\n    apply AddMonoidAlgebra.toDirectSum_toAddMonoidAlgebra", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AddMonoidAlgebra.toDirectSum_pow [DecidableEq \u03b9] [AddMonoid \u03b9] [Semiring M]\n    (f : AddMonoidAlgebra M \u03b9) (n : \u2115) :\n    (f ^ n).toDirectSum = f.toDirectSum ^ n := by\n  classical exact map_pow addMonoidAlgebraRingEquivDirectSum f n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/ToDirectSum.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*} {A : Type*}", "[DecidableEq \u03b9] [Semiring M]", "[\u2200 m : M, Decidable (m \u2260 0)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2076 : DecidableEq \u03b9\ninst\u271d\u2075 : Semiring M\ninst\u271d\u2074 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b9\ninst\u271d\u00b9 : AddMonoid \u03b9\ninst\u271d : Semiring M\nf : AddMonoidAlgebra M \u03b9\nn : \u2115\n\u22a2 (f ^ n).toDirectSum = f.toDirectSum ^ n"}, {"line": "classical exact map_pow addMonoidAlgebraRingEquivDirectSum f n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectSum.toAddMonoidAlgebra_pow [DecidableEq \u03b9] [AddMonoid \u03b9] [Semiring M]\n    [\u2200 m : M, Decidable (m \u2260 0)] (f : \u2a01 _ : \u03b9, M) (n : \u2115):\n    (f ^ n).toAddMonoidAlgebra = toAddMonoidAlgebra f ^ n :=  by\n  classical exact map_pow addMonoidAlgebraRingEquivDirectSum.symm f n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/ToDirectSum.lean", "context": {"open": ["DirectSum"], "variables": ["{\u03b9 : Type*} {R : Type*} {M : Type*} {A : Type*}", "[DecidableEq \u03b9] [Semiring M]", "[\u2200 m : M, Decidable (m \u2260 0)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2077 : DecidableEq \u03b9\ninst\u271d\u2076 : Semiring M\ninst\u271d\u2075 : (m : M) \u2192 Decidable (m \u2260 0)\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : AddMonoid \u03b9\ninst\u271d\u00b9 : Semiring M\ninst\u271d : (m : M) \u2192 Decidable (m \u2260 0)\nf : DirectSum \u03b9 fun x => M\nn : \u2115\n\u22a2 (f ^ n).toAddMonoidAlgebra = f.toAddMonoidAlgebra ^ n"}, {"line": "classical exact map_pow addMonoidAlgebraRingEquivDirectSum.symm f n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [CommSemiring k] [Semiring A]\n    [Algebra k A] [Monoid G] (a : G) (b : k) :\n    single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b * of A G a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "context": {"open": ["Finset", "Finsupp hiding single mapDomain"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "{k G}", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{A : Type u\u2083} [NonUnitalNonAssocSemiring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u2075 : Semiring k\ninst\u271d\u2074 : Mul G\nx\u271d\u00b9 : Sort u_4\nsingle : x\u271d\u00b9\nx\u271d : Sort u_5\nof : x\u271d\nA : Type u_3\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra k A\ninst\u271d : Monoid G\na : G\nb : k\n\u22a2 sorry = (algebraMap k (MonoidAlgebra A G)) b * sorry"}, {"line": "simp", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u2075 : Semiring k\ninst\u271d\u2074 : Mul G\nx\u271d\u00b9 : Sort u_4\nsingle : x\u271d\u00b9\nx\u271d : Sort u_5\nof : x\u271d\nA : Type u_3\ninst\u271d\u00b3 : CommSemiring k\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra k A\ninst\u271d : Monoid G\na : G\nb : k\n\u22a2 sorry () = MonoidAlgebra.single 1 ((algebraMap k A) b) * sorry ()"}]}
{"declaration": "theorem lift_of (F : G \u2192* A) (x) : lift k G A F (of k G x) = F x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Basic.lean", "context": {"open": ["Finset", "Finsupp hiding single mapDomain"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "{k G}", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{A : Type u\u2083} [NonUnitalNonAssocSemiring A]", "[CommSemiring k] [Monoid G] [Monoid H]", "{A : Type u\u2083} [Semiring A] [Algebra k A] {B : Type*} [Semiring B] [Algebra k B]", "(k G A)", "{k G H A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\u2082\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Monoid G\nA : Type u\u2083\ninst\u271d : Semiring A\nx\u271d : Sort u_4\nof : x\u271d\nF : G \u2192* A\nx : G\n\u22a2 sorry = F x"}, {"line": "simp", "tactic_state": "G : Type u\u2082\ninst\u271d\u00b2 : Mul G\ninst\u271d\u00b9 : Monoid G\nA : Type u\u2083\ninst\u271d : Semiring A\nx\u271d : Sort u_4\nof : x\u271d\nF : G \u2192* A\nx : G\n\u22a2 sorry () = F x"}]}
{"declaration": "theorem liftNC_one {g_hom : Type*} [FunLike g_hom G R] [OneHomClass g_hom G R]\n    (f : k \u2192+* R) (g : g_hom) :\n    liftNC (f : k \u2192+ R) g 1 = 1 := by simp [one_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\nR : Type u_2\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : Mul G\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring k\ninst\u271d\u2076 : Semigroup G\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : One G\nx\u271d : Sort u_4\nliftNC : x\u271d\ng_hom : Type u_3\ninst\u271d\u00b9 : FunLike g_hom G R\ninst\u271d : OneHomClass g_hom G R\nf : k \u2192+* R\ng : g_hom\n\u22a2 sorry = 1"}, {"line": "simp [one_def]", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\nR : Type u_2\ninst\u271d\u00b9\u00b3 inst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : NonUnitalNonAssocSemiring R\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : Mul G\ninst\u271d\u2078 : Semiring R\ninst\u271d\u2077 : Semiring k\ninst\u271d\u2076 : Semigroup G\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : NonAssocSemiring R\ninst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : One G\nx\u271d : Sort u_4\nliftNC : x\u271d\ng_hom : Type u_3\ninst\u271d\u00b9 : FunLike g_hom G R\ninst\u271d : OneHomClass g_hom G R\nf : k \u2192+* R\ng : g_hom\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem smul_of [MulOneClass G] (g : G) (r : k) : r \u2022 of k G g = single g r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain", "Finset in"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]", "[Semiring k] [MulOneClass G]", "[Semiring k] [Monoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_6\nG : Type u_4\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : Semiring k\ninst\u271d\u00b9\u2070 : Mul G\ninst\u271d\u2079 : Semiring k\ninst\u271d\u2078 : Semigroup G\ninst\u271d\u2077 : Semiring k\ninst\u271d\u2076 : One G\ninst\u271d\u2075 : Semiring k\ninst\u271d\u2074 : MulOneClass G\ninst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_2\nof : x\u271d\u00b9\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : MulOneClass G\ng : G\nr : k\n\u22a2 r \u2022 sorry = sorry"}, {"line": "simp", "tactic_state": "k : Type u_6\nG : Type u_4\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : Semiring k\ninst\u271d\u00b9\u2070 : Mul G\ninst\u271d\u2079 : Semiring k\ninst\u271d\u2078 : Semigroup G\ninst\u271d\u2077 : Semiring k\ninst\u271d\u2076 : One G\ninst\u271d\u2075 : Semiring k\ninst\u271d\u2074 : MulOneClass G\ninst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_2\nof : x\u271d\u00b9\nx\u271d : Sort u_3\nsingle : x\u271d\ninst\u271d : MulOneClass G\ng : G\nr : k\n\u22a2 r \u2022 sorry () = sorry ()"}]}
{"declaration": "theorem opRingEquiv_single [Monoid G] (r : k) (x : G) :\n    MonoidAlgebra.opRingEquiv (op (single x r)) = single (op x) (op r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain", "Finset in", "Finset in", "Finsupp MulOpposite"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]", "[Semiring k] [MulOneClass G]", "[Semiring k] [Monoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{\u03b9 : Type ui}", "[Semiring k] [Group G]", "[Semiring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Mul G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Semigroup G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : One G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : MulOneClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_4\nop : x\u271d\u00b9\nx\u271d : Sort u_5\nsingle : x\u271d\ninst\u271d : Monoid G\nr : k\nx : G\n\u22a2 MonoidAlgebra.opRingEquiv sorry = sorry"}, {"line": "simp", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Mul G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Semigroup G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : One G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : MulOneClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_4\nop : x\u271d\u00b9\nx\u271d : Sort u_5\nsingle : x\u271d\ninst\u271d : Monoid G\nr : k\nx : G\n\u22a2 MonoidAlgebra.opRingEquiv (sorry ()) = sorry ()"}]}
{"declaration": "theorem opRingEquiv_symm_single [Monoid G] (r : k\u1d50\u1d52\u1d56) (x : G\u1d50\u1d52\u1d56) :\n    MonoidAlgebra.opRingEquiv.symm (single x r) = op (single x.unop r.unop) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain", "Finset in", "Finset in", "Finsupp MulOpposite"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]", "[Semiring k] [MulOneClass G]", "[Semiring k] [Monoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{\u03b9 : Type ui}", "[Semiring k] [Group G]", "[Semiring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Mul G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Semigroup G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : One G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : MulOneClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_4\nsingle : x\u271d\u00b9\nx\u271d : Sort u_5\nop : x\u271d\ninst\u271d : Monoid G\nr : k\u1d50\u1d52\u1d56\nx : G\u1d50\u1d52\u1d56\n\u22a2 MonoidAlgebra.opRingEquiv.symm sorry = sorry"}, {"line": "simp", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Mul G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Semigroup G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : One G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : MulOneClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : Monoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Semiring k\nx\u271d\u00b9 : Sort u_4\nsingle : x\u271d\u00b9\nx\u271d : Sort u_5\nop : x\u271d\ninst\u271d : Monoid G\nr : k\u1d50\u1d52\u1d56\nx : G\u1d50\u1d52\u1d56\n\u22a2 MonoidAlgebra.opRingEquiv.symm (sorry ()) = sorry ()"}]}
{"declaration": "theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain", "Finset in", "Finset in", "Finsupp MulOpposite", "Finsupp MulOpposite"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]", "[Semiring k] [MulOneClass G]", "[Semiring k] [Monoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{\u03b9 : Type ui}", "[Semiring k] [Group G]", "[Semiring k]", "[CommSemiring k] [Monoid G]", "{V : Type*} [AddCommMonoid V]", "[Module k V] [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V]", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Add G]", "[Semiring R]", "[Semiring k] [Zero G] [NonAssocSemiring R]", "[Semiring k] [AddSemigroup G]", "[Semiring k] [AddZeroClass G]", "[Semiring k] [AddMonoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "{k G H}", "(k) [Semiring k] [DistribSMul R k] [Add G]", "[Semiring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b3\u2074 inst\u271d\u00b3\u00b3 inst\u271d\u00b3\u00b2 : Semiring k\ninst\u271d\u00b3\u00b9 : Mul G\ninst\u271d\u00b3\u2070 : Semiring k\ninst\u271d\u00b2\u2079 : Semigroup G\ninst\u271d\u00b2\u2078 : Semiring k\ninst\u271d\u00b2\u2077 : One G\ninst\u271d\u00b2\u2076 : Semiring k\ninst\u271d\u00b2\u2075 : MulOneClass G\ninst\u271d\u00b2\u2074 : Semiring k\ninst\u271d\u00b2\u00b3 : Monoid G\ninst\u271d\u00b2\u00b2 inst\u271d\u00b2\u00b9 : Semiring k\ninst\u271d\u00b2\u2070 : Group G\ninst\u271d\u00b9\u2079 : Semiring k\ninst\u271d\u00b9\u2078 : CommSemiring k\ninst\u271d\u00b9\u2077 : Monoid G\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Add G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Zero G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : AddSemigroup G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : AddZeroClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : AddMonoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Add G\ninst\u271d\u00b9 : Semiring k\ninst\u271d : AddCommMonoid G\nr : k\nx : G\n\u22a2 AddMonoidAlgebra.opRingEquiv (op fun\u2080 | x => r) = fun\u2080 | x => op r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem opRingEquiv_symm_single [AddCommMonoid G] (r : k\u1d50\u1d52\u1d56) (x : G\u1d50\u1d52\u1d56) :\n    AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Defs.lean", "context": {"open": ["Finsupp hiding single mapDomain", "Finset in", "Finset in", "Finsupp MulOpposite", "Finsupp MulOpposite"], "variables": ["(k : Type u\u2081) (G : Type u\u2082) (H : Type*) {R : Type*}", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Mul G]", "[Semiring R]", "[Semiring k] [Semigroup G] [Semiring R]", "[NonAssocSemiring R] [Semiring k] [One G]", "[Semiring k] [MulOneClass G]", "[Semiring k] [Monoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "(k) [Semiring k] [DistribSMul R k] [Mul G]", "{\u03b9 : Type ui}", "[Semiring k] [Group G]", "[Semiring k]", "[CommSemiring k] [Monoid G]", "{V : Type*} [AddCommMonoid V]", "[Module k V] [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V]", "[Semiring k]", "{k G}", "[Semiring k] [NonUnitalNonAssocSemiring R]", "[Semiring k] [Add G]", "[Semiring R]", "[Semiring k] [Zero G] [NonAssocSemiring R]", "[Semiring k] [AddSemigroup G]", "[Semiring k] [AddZeroClass G]", "[Semiring k] [AddMonoid G]", "[Semiring R]", "{S : Type*}", "[Semiring k]", "(k G)", "{k G H}", "(k) [Semiring k] [DistribSMul R k] [Add G]", "[Semiring k]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u\u2081\nG : Type u\u2082\ninst\u271d\u00b3\u2074 inst\u271d\u00b3\u00b3 inst\u271d\u00b3\u00b2 : Semiring k\ninst\u271d\u00b3\u00b9 : Mul G\ninst\u271d\u00b3\u2070 : Semiring k\ninst\u271d\u00b2\u2079 : Semigroup G\ninst\u271d\u00b2\u2078 : Semiring k\ninst\u271d\u00b2\u2077 : One G\ninst\u271d\u00b2\u2076 : Semiring k\ninst\u271d\u00b2\u2075 : MulOneClass G\ninst\u271d\u00b2\u2074 : Semiring k\ninst\u271d\u00b2\u00b3 : Monoid G\ninst\u271d\u00b2\u00b2 inst\u271d\u00b2\u00b9 : Semiring k\ninst\u271d\u00b2\u2070 : Group G\ninst\u271d\u00b9\u2079 : Semiring k\ninst\u271d\u00b9\u2078 : CommSemiring k\ninst\u271d\u00b9\u2077 : Monoid G\ninst\u271d\u00b9\u2076 inst\u271d\u00b9\u2075 inst\u271d\u00b9\u2074 : Semiring k\ninst\u271d\u00b9\u00b3 : Add G\ninst\u271d\u00b9\u00b2 : Semiring k\ninst\u271d\u00b9\u00b9 : Zero G\ninst\u271d\u00b9\u2070 : Semiring k\ninst\u271d\u2079 : AddSemigroup G\ninst\u271d\u2078 : Semiring k\ninst\u271d\u2077 : AddZeroClass G\ninst\u271d\u2076 : Semiring k\ninst\u271d\u2075 : AddMonoid G\ninst\u271d\u2074 inst\u271d\u00b3 : Semiring k\ninst\u271d\u00b2 : Add G\ninst\u271d\u00b9 : Semiring k\ninst\u271d : AddCommMonoid G\nr : k\u1d50\u1d52\u1d56\nx : G\u1d50\u1d52\u1d56\n\u22a2 (AddMonoidAlgebra.opRingEquiv.symm fun\u2080 | x => r) = op fun\u2080 | x => unop r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supDegree_zero : (0 : R[A]).supDegree D = \u22a5 := by simp [supDegree]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Degree.lean", "context": {"open": ["Classical in"], "variables": ["{R R' A T B \u03b9 : Type*}", "[SemilatticeSup B] [OrderBot B] [SemilatticeInf T] [OrderTop T]", "[Semiring R]", "(degb : A \u2192 B) (degt : A \u2192 T) (f g : R[A])", "[Add A] [Add B] [Add T] [AddLeftMono B] [AddRightMono B]", "[AddMonoid A] [AddMonoid B] [AddLeftMono B] [AddRightMono B]", "[CommSemiring R] [AddCommMonoid A] [AddCommMonoid B] [AddLeftMono B] [AddRightMono B]", "[Semiring R] [Ring R']", "[SemilatticeSup B] [OrderBot B] (D : A \u2192 B)", "{D}", "[AddZeroClass A] {p q : R[A]}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a5"}, {"line": "simp [supDegree]", "tactic_state": "\u22a2 sorry () = \u22a5"}]}
{"declaration": "lemma Monic.supDegree_mul\n    (hD : D.Injective) (hadd : \u2200 a1 a2, D (a1 + a2) = D a1 + D a2)\n    (hbot : (\u22a5 : B) + \u22a5 = \u22a5) (hp : p.Monic D) (hq : q.Monic D) :\n    (p * q).supDegree D = p.supDegree D + q.supDegree D := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 simp_rw [Subsingleton.eq_zero p, Subsingleton.eq_zero q, mul_zero, supDegree_zero, hbot]\n  exact hq.supDegree_mul_of_ne_zero_left hD hadd hp.ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MonoidAlgebra/Degree.lean", "context": {"open": ["Classical in", "Finsupp in", "Finset in"], "variables": ["{R R' A T B \u03b9 : Type*}", "[SemilatticeSup B] [OrderBot B] [SemilatticeInf T] [OrderTop T]", "[Semiring R]", "(degb : A \u2192 B) (degt : A \u2192 T) (f g : R[A])", "[Add A] [Add B] [Add T] [AddLeftMono B] [AddRightMono B]", "[AddMonoid A] [AddMonoid B] [AddLeftMono B] [AddRightMono B]", "[CommSemiring R] [AddCommMonoid A] [AddCommMonoid B] [AddLeftMono B] [AddRightMono B]", "[Semiring R] [Ring R']", "[SemilatticeSup B] [OrderBot B] (D : A \u2192 B)", "{D}", "[AddZeroClass A] {p q : R[A]}", "[Add B]", "[LinearOrder B] [OrderBot B] {p q : R[A]} (D : A \u2192 B)", "{D}", "(D) in", "(D) in", "{\u03b9 : Type*} {s : Finset \u03b9} {i : \u03b9} (hi : i \u2208 s) {f : \u03b9 \u2192 R[A]}", "[AddZeroClass A]", "[Add B]", "[AddLeftStrictMono B] [AddRightStrictMono B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type ?u.2091\nT : Type ?u.2368\nR : Type ?u.2490\ninst\u271d\u2074 : SemilatticeSup B\ninst\u271d\u00b3 : OrderBot B\ninst\u271d\u00b2 : SemilatticeInf T\ninst\u271d\u00b9 : OrderTop T\ninst\u271d : Semiring R\nA : Sort ?u.2498\ndegb : A \u2192 B\ndegt : A \u2192 T\n\u22a2 ?m.2513 R A"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\nB : Type ?u.2091\nT : Type ?u.2368\nR : Type ?u.2490\ninst\u271d\u2074 : SemilatticeSup B\ninst\u271d\u00b3 : OrderBot B\ninst\u271d\u00b2 : SemilatticeInf T\ninst\u271d\u00b9 : OrderTop T\ninst\u271d : Semiring R\nA : Sort ?u.2498\ndegb : A \u2192 B\ndegt : A \u2192 T\nh\u271d : Subsingleton R\n\u22a2 ?m.2513 R A\n---\ncase inr\nB : Type ?u.2091\nT : Type ?u.2368\nR : Type ?u.2490\ninst\u271d\u2074 : SemilatticeSup B\ninst\u271d\u00b3 : OrderBot B\ninst\u271d\u00b2 : SemilatticeInf T\ninst\u271d\u00b9 : OrderTop T\ninst\u271d : Semiring R\nA : Sort ?u.2498\ndegb : A \u2192 B\ndegt : A \u2192 T\nh\u271d : Nontrivial R\n\u22a2 ?m.2513 R A"}, {"line": "\u00b7 simp_rw [Subsingleton.eq_zero p, Subsingleton.eq_zero q, mul_zero, supDegree_zero, hbot]", "tactic_state": "case inr\nB : Type ?u.2091\nT : Type ?u.2368\nR : Type ?u.2490\ninst\u271d\u2074 : SemilatticeSup B\ninst\u271d\u00b3 : OrderBot B\ninst\u271d\u00b2 : SemilatticeInf T\ninst\u271d\u00b9 : OrderTop T\ninst\u271d : Semiring R\nA : Sort ?u.2498\ndegb : A \u2192 B\ndegt : A \u2192 T\nh\u271d : Nontrivial R\n\u22a2 ?m.2513 R A"}, {"line": "exact hq.supDegree_mul_of_ne_zero_left hD hadd hp.ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_le_max_lift {\u03c3 : Type u} {R : Type v} [CommSemiring R] : #(MvPolynomial \u03c3 R) \u2264\n    max (max (Cardinal.lift.{u} #R) <| Cardinal.lift.{v} #\u03c3) \u2135\u2080 := by\n  cases subsingleton_or_nontrivial R\n  \u00b7 exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph0)\n  cases isEmpty_or_nonempty \u03c3\n  \u00b7 exact cardinalMk_eq_lift.trans_le (le_max_of_le_left <| le_max_left _ _)\n  \u00b7 exact cardinalMk_eq_max_lift.le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Cardinal.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03c3 : Type u} {R : Type v} [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0"}, {"line": "cases subsingleton_or_nontrivial R", "tactic_state": "case inl\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d : Subsingleton R\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0\n---\ncase inr\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d : Nontrivial R\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0"}, {"line": "\u00b7 exact (mk_eq_one _).trans_le (le_max_of_le_right one_le_aleph0)", "tactic_state": "case inr\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d : Nontrivial R\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0"}, {"line": "cases isEmpty_or_nonempty \u03c3", "tactic_state": "case inr.inl\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d\u00b9 : Nontrivial R\nh\u271d : IsEmpty \u03c3\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0\n---\ncase inr.inr\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d\u00b9 : Nontrivial R\nh\u271d : Nonempty \u03c3\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0"}, {"line": "\u00b7 exact cardinalMk_eq_lift.trans_le (le_max_of_le_left <| le_max_left _ _)", "tactic_state": "case inr.inr\n\u03c3 : Type u\nR : Type v\ninst\u271d : CommSemiring R\nh\u271d\u00b9 : Nontrivial R\nh\u271d : Nonempty \u03c3\n\u22a2 mk (MvPolynomial \u03c3 R) \u2264 max (max (lift.{u, v} (mk R)) (lift.{v, u} (mk \u03c3))) aleph0"}, {"line": "\u00b7 exact cardinalMk_eq_max_lift.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_comp (f : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R)\n    (g : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c5 R) : comap (g.comp f) = comap f \u2218 comap g := by\n  funext x\n  exact comap_comp_apply _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Comap.lean", "context": {"open": [], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {\u03c5 : Type*} {R : Type*} [CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03c5 : Type u_3\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_5\ncomap : x\u271d\nf : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R\ng : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c5 R\n\u22a2 sorry = sorry \u2218 sorry"}, {"line": "funext x", "tactic_state": "case h\n\u03c3 : Type u_1\n\u03c4 : Type u_2\n\u03c5 : Type u_3\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_5\ncomap : x\u271d\nf : MvPolynomial \u03c3 R \u2192\u2090[R] MvPolynomial \u03c4 R\ng : MvPolynomial \u03c4 R \u2192\u2090[R] MvPolynomial \u03c5 R\nx : ?m.1830 f g\n\u22a2 sorry x = (sorry \u2218 sorry) x"}, {"line": "exact comap_comp_apply _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_rename (f : \u03c3 \u2192 \u03c4) (x : \u03c4 \u2192 R) : comap (rename f) x = x \u2218 f := by\n  funext\n  simp [rename_X, comap_apply, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Comap.lean", "context": {"open": [], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*} {\u03c5 : Type*} {R : Type*} [CommSemiring R]", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_5\ncomap : x\u271d\nf : \u03c3 \u2192 \u03c4\nx : \u03c4 \u2192 R\n\u22a2 sorry = x \u2218 f"}, {"line": "funext", "tactic_state": "case h\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_5\ncomap : x\u271d\u00b9\nf : \u03c3 \u2192 \u03c4\nx : \u03c4 \u2192 R\nx\u271d : \u03c3\n\u22a2 sorry x\u271d = (x \u2218 f) x\u271d"}, {"line": "simp [rename_X, comap_apply, aeval_X]", "tactic_state": "case h\n\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_5\ncomap : x\u271d\u00b9\nf : \u03c3 \u2192 \u03c4\nx : \u03c4 \u2192 R\nx\u271d : \u03c3\n\u22a2 sorry () x\u271d = x (f x\u271d)"}]}
{"declaration": "theorem vars_neg : (-p).vars = p.vars := by simp [vars, degrees_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/CommRing.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommRing R]", "{p q : MvPolynomial \u03c3 R}", "(\u03c3 a a')", "{\u03c3} (p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommRing R\np : MvPolynomial \u03c3 R\n\u22a2 (-p).vars = p.vars"}, {"line": "simp [vars, degrees_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem vars_sub_subset [DecidableEq \u03c3] : (p - q).vars \u2286 p.vars \u222a q.vars := by\n  convert vars_add_subset p (-q) using 2 <;> simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/CommRing.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommRing R]", "{p q : MvPolynomial \u03c3 R}", "(\u03c3 a a')", "{\u03c3} (p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommRing R\np q : MvPolynomial \u03c3 R\ninst\u271d : DecidableEq \u03c3\n\u22a2 (p - q).vars \u2286 p.vars \u222a q.vars"}, {"line": "convert vars_add_subset p (-q) using 2 <;> simp [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_expand (f : R \u2192+* S) (p : \u2115) (\u03c6 : MvPolynomial \u03c3 R) :\n    map f (expand p \u03c6) = expand p (map f \u03c6) := by simp [expand, map_bind\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Expand.lean", "context": {"open": [], "variables": ["{\u03c3 \u03c4 R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nx\u271d : Sort u_6\nexpand : x\u271d\nf : R \u2192+* S\np : \u2115\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 sorry = sorry"}, {"line": "simp [expand, map_bind\u2081]", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d\u00b9 : Sort u_5\nmap : x\u271d\u00b9\nx\u271d : Sort u_6\nexpand : x\u271d\nf : R \u2192+* S\np : \u2115\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem rename_expand (f : \u03c3 \u2192 \u03c4) (p : \u2115) (\u03c6 : MvPolynomial \u03c3 R) :\n    rename f (expand p \u03c6) = expand p (rename f \u03c6) := by\n  simp [expand, bind\u2081_rename, rename_bind\u2081, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Expand.lean", "context": {"open": [], "variables": ["{\u03c3 \u03c4 R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_5\nrename : x\u271d\u00b9\nx\u271d : Sort u_6\nexpand : x\u271d\nf : \u03c3 \u2192 \u03c4\np : \u2115\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 sorry = sorry"}, {"line": "simp [expand, bind\u2081_rename, rename_bind\u2081, Function.comp_def]", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_3\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_5\nrename : x\u271d\u00b9\nx\u271d : Sort u_6\nexpand : x\u271d\nf : \u03c3 \u2192 \u03c4\np : \u2115\n\u03c6 : MvPolynomial \u03c3 R\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem eval\u2082Hom_comp_C (f : R \u2192+* S) (g : \u03c3 \u2192 S) : (eval\u2082Hom f g).comp C = f := by\n  ext1 r\n  exact eval\u2082_C f g r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Monad.lean", "context": {"open": ["Finsupp"], "variables": ["{\u03c3 : Type*} {\u03c4 : Type*}", "{R S T : Type*} [CommSemiring R] [CommSemiring S] [CommSemiring T]", "(\u03c3 R)", "(f : \u03c3 \u2192 MvPolynomial \u03c4 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d : Sort u_6\neval\u2082Hom : x\u271d\nf : R \u2192+* S\ng : \u03c3 \u2192 S\n\u22a2 sorry = f"}, {"line": "ext1 r", "tactic_state": "case a\n\u03c3 : Type u_1\nR : Type u_3\nS : Type u_4\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\nx\u271d : Sort u_6\neval\u2082Hom : x\u271d\nf : R \u2192+* S\ng : \u03c3 \u2192 S\nr : R\n\u22a2 sorry r = f r"}, {"line": "exact eval\u2082_C f g r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supportedEquivMvPolynomial_symm_X (s : Set \u03c3) (i : s) :\n    (\u2191((supportedEquivMvPolynomial s).symm (X i : MvPolynomial s R)) : MvPolynomial \u03c3 R) = X \u2191i :=\n  by simp [supportedEquivMvPolynomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Supported.lean", "context": {"open": ["Algebra"], "variables": ["{\u03c3 : Type*} {R : Type u}", "[CommSemiring R] {p : MvPolynomial \u03c3 R}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u\ninst\u271d : CommSemiring R\nx\u271d\u00b9 : Sort u_2\nsupportedEquivMvPolynomial : x\u271d\u00b9\nx\u271d : Sort u_3\nX : x\u271d\ns : Set \u03c3\ni : \u2191s\n\u22a2 sorry = sorry"}, {"line": "simp [supportedEquivMvPolynomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem supported_univ : supported R (Set.univ : Set \u03c3) = \u22a4 := by\n  simp [Algebra.eq_top_iff, mem_supported]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Supported.lean", "context": {"open": ["Algebra"], "variables": ["{\u03c3 : Type*} {R : Type u}", "[CommSemiring R] {p : MvPolynomial \u03c3 R}", "(R) in", "{s t : Set \u03c3}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nsupported : x\u271d\n\u22a2 sorry = \u22a4"}, {"line": "simp [Algebra.eq_top_iff, mem_supported]", "tactic_state": "x\u271d : Sort u_2\nsupported : x\u271d\n\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem supported_empty : supported R (\u2205 : Set \u03c3) = \u22a5 := by simp [supported_eq_adjoin_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Supported.lean", "context": {"open": ["Algebra"], "variables": ["{\u03c3 : Type*} {R : Type u}", "[CommSemiring R] {p : MvPolynomial \u03c3 R}", "(R) in", "{s t : Set \u03c3}", "(s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nsupported : x\u271d\n\u22a2 sorry = \u22a5"}, {"line": "simp [supported_eq_adjoin_X]", "tactic_state": "x\u271d : Sort u_2\nsupported : x\u271d\n\u22a2 sorry () = \u22a5"}]}
{"declaration": "theorem C_eq_coe_nat (n : \u2115) : (C \u2191n : MvPolynomial \u03c3 R) = n := by\n  induction n <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_2\nC : x\u271d\nn : \u2115\n\u22a2 sorry = \u2191n"}, {"line": "induction n <;> simp [*]", "tactic_state": "case zero\nR : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_2\nC : x\u271d\n\u22a2 sorry () = 0\n---\ncase succ\nR : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_2\nC : x\u271d\nn\u271d : \u2115\na\u271d : sorry = \u2191n\u271d\n\u22a2 \u2191n\u271d = \u2191n\u271d + 1"}]}
{"declaration": "theorem X_pow_eq_monomial : X n ^ e = monomial (Finsupp.single n e) (1 : R) := by\n  simp [X, monomial_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e : \u2115\nx\u271d\u00b9 : Sort u_2\nX : x\u271d\u00b9\nx\u271d : Sort u_3\nmonomial : x\u271d\n\u22a2 sorry ^ e = sorry"}, {"line": "simp [X, monomial_pow]", "tactic_state": "e : \u2115\nx\u271d\u00b9 : Sort u_2\nX : x\u271d\u00b9\nx\u271d : Sort u_3\nmonomial : x\u271d\n\u22a2 sorry () ^ e = sorry ()"}]}
{"declaration": "theorem mem_support_iff {p : MvPolynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} : m \u2208 p.support \u2194 p.coeff m \u2260 0 := by\n  simp [support, coeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 m \u2208 p.support \u2194 MvPolynomial.coeff m p \u2260 0"}, {"line": "simp [support, coeff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_support_iff {p : MvPolynomial \u03c3 R} {m : \u03c3 \u2192\u2080 \u2115} : m \u2209 p.support \u2194 p.coeff m = 0 :=\n  by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\nm : \u03c3 \u2192\u2080 \u2115\n\u22a2 m \u2209 p.support \u2194 MvPolynomial.coeff m p = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_def {A} [AddCommMonoid A] {p : MvPolynomial \u03c3 R} {b : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A} :\n    p.sum b = \u2211 m \u2208 p.support, b m (p.coeff m) := by simp [support, Finsupp.sum, coeff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_2\ninst\u271d : AddCommMonoid A\np : MvPolynomial \u03c3 R\nb : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A\n\u22a2 sum p b = \u2211 m \u2208 p.support, b m (MvPolynomial.coeff m p)"}, {"line": "simp [support, Finsupp.sum, coeff]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nA : Type u_2\ninst\u271d : AddCommMonoid A\np : MvPolynomial \u03c3 R\nb : (\u03c3 \u2192\u2080 \u2115) \u2192 R \u2192 A\n\u22a2 \u2211 a \u2208 p.support, b a (p a) = \u2211 m \u2208 p.support, b m (MvPolynomial.coeff m p)"}]}
{"declaration": "theorem monic_monomial_eq (m) :\n    monomial m (1 : R) = (m.prod fun n e => X n ^ e : MvPolynomial \u03c3 R) := by simp [monomial_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_2\nmonomial : x\u271d\nm : ?m.981 R\n\u22a2 sorry = sorry"}, {"line": "simp [monomial_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coeff_single_X [DecidableEq \u03c3] (s s' : \u03c3) (n : \u2115) :\n    (X s).coeff (R := R) (Finsupp.single s' n) = if n = 1 \u2227 s = s' then 1 else 0 := by\n  simpa [eq_comm, and_comm] using coeff_single_X_pow s s' 1 n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nx\u271d : Sort u_2\nX : x\u271d\ninst\u271d : DecidableEq \u03c3\ns s' : \u03c3\nn : \u2115\n\u22a2 sorry = if n = 1 \u2227 s = s' then 1 else 0"}, {"line": "simpa [eq_comm, and_comm] using coeff_single_X_pow s s' 1 n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem constantCoeff_C (r : R) : constantCoeff (C r : MvPolynomial \u03c3 R) = r := by\n  classical simp [constantCoeff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise", "scoped symmDiff in"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}", "(R) in", "(\u03c3) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Sort u_3\nx\u271d : Sort u_2\nconstantCoeff : x\u271d\nr : R\n\u22a2 sorry = r"}, {"line": "classical simp [constantCoeff_eq]", "tactic_state": "R : Sort u_3\nx\u271d : Sort u_2\nconstantCoeff : x\u271d\nr : R\n\u22a2 sorry () = r"}]}
{"declaration": "theorem constantCoeff_X (i : \u03c3) : constantCoeff (X i : MvPolynomial \u03c3 R) = 0 := by\n  simp [constantCoeff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Basic.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise", "scoped symmDiff in"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(R \u03c3)", "{R \u03c3}", "(\u03c3 R)", "{\u03c3 R}", "(R) in", "(\u03c3) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nx\u271d : Sort u_2\nconstantCoeff : x\u271d\ni : \u03c3\n\u22a2 sorry = 0"}, {"line": "simp [constantCoeff_eq]", "tactic_state": "\u03c3 : Type u_1\nx\u271d : Sort u_2\nconstantCoeff : x\u271d\ni : \u03c3\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem degrees_monomial_eq (s : \u03c3 \u2192\u2080 \u2115) (a : R) (ha : a \u2260 0) :\n    degrees (monomial s a) = toMultiset s := by\n  classical\n    exact (supDegree_single s a).trans (if_neg ha)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\ndegrees : x\u271d\ns : \u03c3 \u2192\u2080 \u2115\na : R\nha : a \u2260 0\n\u22a2 sorry = toMultiset s"}, {"line": "classical\n    exact (supDegree_single s a).trans (if_neg ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degrees_prod_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 MvPolynomial \u03c3 R} :\n    (\u220f i \u2208 s, f i).degrees \u2264 \u2211 i \u2208 s, (f i).degrees := by\n  classical exact supDegree_prod_le (map_zero _) (map_add _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\n\u03b9 : Type u_3\ns : Finset \u03b9\nf : \u03b9 \u2192 MvPolynomial \u03c3 R\n\u22a2 (\u220f i \u2208 s, f i).degrees \u2264 \u2211 i \u2208 s, (f i).degrees"}, {"line": "classical exact supDegree_prod_le (map_zero _) (map_add _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degrees_pow_le {p : MvPolynomial \u03c3 R} {n : \u2115} : (p ^ n).degrees \u2264 n \u2022 p.degrees := by\n  simpa using degrees_prod_le (s := .range n) (f := fun _ \u21a6 p)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\nn : \u2115\n\u22a2 (p ^ n).degrees \u2264 n \u2022 p.degrees"}, {"line": "simpa using degrees_prod_le (s := .range n) (f := fun _ \u21a6 p)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_degrees_add_right (h : Disjoint p.degrees q.degrees) : q.degrees \u2264 (p + q).degrees := by\n  simpa [add_comm] using le_degrees_add_left h.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np q : MvPolynomial \u03c3 R\nh : Disjoint p.degrees q.degrees\n\u22a2 q.degrees \u2264 (p + q).degrees"}, {"line": "simpa [add_comm] using le_degrees_add_left h.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem degreeOf_C (a : R) (x : \u03c3) : degreeOf x (C a : MvPolynomial \u03c3 R) = 0 := by\n  classical simp [degreeOf_def, degrees_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\ndegreeOf : x\u271d\na : R\nx : \u03c3\n\u22a2 sorry = 0"}, {"line": "classical simp [degreeOf_def, degrees_C]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\ndegreeOf : x\u271d\na : R\nx : \u03c3\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem degreeOf_pow_le (i : \u03c3) (p : MvPolynomial \u03c3 R) (n : \u2115) :\n    degreeOf i (p ^ n) \u2264 n * degreeOf i p := by\n  simpa using degreeOf_prod_le i (Finset.range n) (fun _ => p)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\ndegreeOf : x\u271d\ni : \u03c3\np : MvPolynomial \u03c3 R\nn : \u2115\n\u22a2 sorry \u2264 n * sorry"}, {"line": "simpa using degreeOf_prod_le i (Finset.range n) (fun _ => p)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totalDegree_monomial (s : \u03c3 \u2192\u2080 \u2115) {c : R} (hc : c \u2260 0) :\n    (monomial s c : MvPolynomial \u03c3 R).totalDegree = s.sum fun _ e => e := by\n  classical simp [totalDegree, support_monomial, if_neg hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\nmonomial : x\u271d\ns : \u03c3 \u2192\u2080 \u2115\nc : R\nhc : c \u2260 0\n\u22a2 sorry.totalDegree = s.sum fun x e => e"}, {"line": "classical simp [totalDegree, support_monomial, if_neg hc]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_3\nmonomial : x\u271d\ns : \u03c3 \u2192\u2080 \u2115\nc : R\nhc : c \u2260 0\n\u22a2 (sorry ()).totalDegree = s.sum fun x e => e"}]}
{"declaration": "theorem totalDegree_X_pow [Nontrivial R] (s : \u03c3) (n : \u2115) :\n    (X s ^ n : MvPolynomial \u03c3 R).totalDegree = n := by simp [X_pow_eq_monomial, one_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Degrees.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\nX : x\u271d\ninst\u271d : Nontrivial R\ns : \u03c3\nn : \u2115\n\u22a2 (sorry ^ n).totalDegree = n"}, {"line": "simp [X_pow_eq_monomial, one_ne_zero]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\nx\u271d : Sort u_3\nX : x\u271d\ninst\u271d : Nontrivial R\ns : \u03c3\nn : \u2115\n\u22a2 (sorry () ^ n).totalDegree = n"}]}
{"declaration": "theorem pUnitAlgEquiv_monomial {d : PUnit \u2192\u2080 \u2115} {r : R} :\n    MvPolynomial.pUnitAlgEquiv R (MvPolynomial.monomial d r)\n      = Polynomial.monomial (d ()) r := by\n  simp [Polynomial.C_mul_X_pow_eq_monomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nd : PUnit.{1} \u2192\u2080 \u2115\nr : R\n\u22a2 (MvPolynomial.pUnitAlgEquiv R) ((MvPolynomial.monomial d) r) = (monomial (d ())) r"}, {"line": "simp [Polynomial.C_mul_X_pow_eq_monomial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pUnitAlgEquiv_symm_monomial {d : PUnit \u2192\u2080 \u2115} {r : R} :\n    (MvPolynomial.pUnitAlgEquiv R).symm (Polynomial.monomial (d ()) r)\n      = MvPolynomial.monomial d r := by\n  simp [MvPolynomial.monomial_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nd : PUnit.{1} \u2192\u2080 \u2115\nr : R\n\u22a2 (MvPolynomial.pUnitAlgEquiv R).symm ((monomial (d ())) r) = (MvPolynomial.monomial d) r"}, {"line": "simp [MvPolynomial.monomial_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma commAlgEquiv_C_X (i) : commAlgEquiv R S\u2081 S\u2082 (.C (.X i)) = .X i := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_7\ncommAlgEquiv : x\u271d\ni : ?m.2984\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_7\ncommAlgEquiv : x\u271d\ni : ?m.2984\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma optionEquivLeft_X_some (x : S\u2081) : optionEquivLeft R S\u2081 (X (some x)) = Polynomial.C (X x) := by\n  simp [optionEquivLeft_apply, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S\u2081 : Type v\nx\u271d : Sort u_7\noptionEquivLeft : x\u271d\nx : S\u2081\n\u22a2 sorry = C sorry"}, {"line": "simp [optionEquivLeft_apply, aeval_X]", "tactic_state": "S\u2081 : Type v\nx\u271d : Sort u_7\noptionEquivLeft : x\u271d\nx : S\u2081\n\u22a2 sorry () = C (sorry ())"}]}
{"declaration": "lemma optionEquivLeft_X_none : optionEquivLeft R S\u2081 (X none) = Polynomial.X := by\n  simp [optionEquivLeft_apply, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_7\noptionEquivLeft : x\u271d\n\u22a2 sorry = X"}, {"line": "simp [optionEquivLeft_apply, aeval_X]", "tactic_state": "x\u271d : Sort u_7\noptionEquivLeft : x\u271d\n\u22a2 sorry () = X"}]}
{"declaration": "lemma optionEquivRight_X_some (x : S\u2081) : optionEquivRight R S\u2081 (X (some x)) = X x := by\n  simp [optionEquivRight_apply, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S\u2081 : Type v\nx\u271d : Sort u_7\noptionEquivRight : x\u271d\nx : S\u2081\n\u22a2 sorry = sorry"}, {"line": "simp [optionEquivRight_apply, aeval_X]", "tactic_state": "S\u2081 : Type v\nx\u271d : Sort u_7\noptionEquivRight : x\u271d\nx : S\u2081\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma optionEquivRight_X_none : optionEquivRight R S\u2081 (X none) = C Polynomial.X := by\n  simp [optionEquivRight_apply, aeval_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_7\noptionEquivRight : x\u271d\n\u22a2 sorry = C X"}, {"line": "simp [optionEquivRight_apply, aeval_X]", "tactic_state": "x\u271d : Sort u_7\noptionEquivRight : x\u271d\n\u22a2 sorry () = C X"}]}
{"declaration": "theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X := by simp [finSuccEquiv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Fin (sorry + 1)\n\u22a2 sorry = X"}, {"line": "simp [finSuccEquiv_apply]", "tactic_state": "n : Fin (sorry + 1)\n\u22a2 sorry () = X"}]}
{"declaration": "theorem finSuccEquiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j) := by\n  simp [finSuccEquiv_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry = C sorry"}, {"line": "simp [finSuccEquiv_apply]", "tactic_state": "n : \u2115\nj : Fin n\n\u22a2 sorry () = C (sorry ())"}]}
{"declaration": "lemma mem_image_support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : \u2115} {x} :\n    x \u2208 Finsupp.cons i '' ((finSuccEquiv R n f).coeff i).support \u2194\n      x \u2208 f.support \u2227 x 0 = i := by\n  simpa using congr(x \u2208 $image_support_finSuccEquiv)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d : CommSemiring R\nn : \u2115\nf : MvPolynomial (Fin (n + 1)) R\ni : \u2115\nx : Fin (n + 1) \u2192\u2080 \u2115\n\u22a2 x \u2208 cons i '' sorry \u2194 x \u2208 f.support \u2227 x 0 = i"}, {"line": "simpa using congr(x \u2208 $image_support_finSuccEquiv)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Polynomial.toMvPolynomial_C (i : \u03c3) (r : R) : (C r).toMvPolynomial i = MvPolynomial.C r := by\n  simp [toMvPolynomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}", "{R S \u03c3 \u03c4 : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\nr : R\n\u22a2 (toMvPolynomial i) (C r) = MvPolynomial.C r"}, {"line": "simp [toMvPolynomial]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Polynomial.toMvPolynomial_injective (i : \u03c3) :\n    Function.Injective (toMvPolynomial (R := R) i) := by\n  simp only [toMvPolynomial_eq_rename_comp]\n  simp only [AlgHom.coe_comp]\n  simp only [AlgHom.coe_coe]\n  simp only [EquivLike.injective_comp]\n  exact MvPolynomial.rename_injective (fun x \u21a6 i) fun _ _ _ \u21a6 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}", "{R S \u03c3 \u03c4 : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\n\u22a2 Injective \u21d1(toMvPolynomial i)"}, {"line": "simp only [toMvPolynomial_eq_rename_comp]", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\n\u22a2 Injective \u21d1((MvPolynomial.rename fun x => i).comp \u2191(MvPolynomial.pUnitAlgEquiv R).symm)"}, {"line": "simp only [AlgHom.coe_comp]", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\n\u22a2 Injective (\u21d1(MvPolynomial.rename fun x => i) \u2218 \u21d1\u2191(MvPolynomial.pUnitAlgEquiv R).symm)"}, {"line": "simp only [AlgHom.coe_coe]", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\n\u22a2 Injective (\u21d1(MvPolynomial.rename fun x => i) \u2218 \u21d1(MvPolynomial.pUnitAlgEquiv R).symm)"}, {"line": "simp only [EquivLike.injective_comp]", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\ni : \u03c3\n\u22a2 Injective \u21d1(MvPolynomial.rename fun x => i)"}, {"line": "exact MvPolynomial.rename_injective (fun x \u21a6 i) fun _ _ _ \u21a6 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MvPolynomial.eval_comp_toMvPolynomial (f : \u03c3 \u2192 R) (i : \u03c3) :\n    (eval f).comp (toMvPolynomial (R := R) i) = Polynomial.evalRingHom (f i) := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Equiv.lean", "context": {"open": ["Polynomial Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {s : \u03c3 \u2192\u2080 \u2115}", "(R) [CommSemiring R]", "{R} (\u03c3)", "{A\u2081 A\u2082 A\u2083 : Type*} [CommSemiring A\u2081] [CommSemiring A\u2082] [CommSemiring A\u2083]", "[Algebra R A\u2081] [Algebra R A\u2082] [Algebra R A\u2083]", "{R S : Type*} [CommSemiring R] [CommSemiring S]", "(S\u2081 S\u2082 S\u2083)", "[IsEmpty \u03c3]", "(\u03c3) in", "{R S\u2081} in", "(\u03c3) in", "{R S\u2081 S\u2082 : Type*} [CommSemiring R]", "(R S\u2081 S\u2082) in", "(n : \u2115)", "{n} {R}", "{R S \u03c3 \u03c4 : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\n\u03c3 : Type u_9\ninst\u271d : CommSemiring R\nf : \u03c3 \u2192 R\ni : \u03c3\n\u22a2 (eval f).comp \u2191(toMvPolynomial i) = evalRingHom (f i)"}, {"line": "ext <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_add : (p + q).eval\u2082 f g = p.eval\u2082 f g + q.eval\u2082 f g := by\n  classical exact Finsupp.sum_add_index (by simp [f.map_zero]) (by simp [add_mul, f.map_add])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Eval.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS\u2081 : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : CommSemiring S\u2081\np q : MvPolynomial \u03c3 R\nf : R \u2192+* S\u2081\ng : \u03c3 \u2192 S\u2081\n\u22a2 MvPolynomial.eval\u2082 f g (p + q) = MvPolynomial.eval\u2082 f g p + MvPolynomial.eval\u2082 f g q"}, {"line": "classical exact Finsupp.sum_add_index (by simp [f.map_zero]) (by simp [add_mul, f.map_add])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082_X (n) : (X n).eval\u2082 f g = g n := by\n  simp [eval\u2082_monomial, f.map_one, X, prod_single_index, pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Eval.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S\u2081 : Type v\n\u03c3 : Type u_1\ninst\u271d : CommSemiring S\u2081\ng : \u03c3 \u2192 S\u2081\nx\u271d : Sort u_2\nX : x\u271d\nn : \u03c3\n\u22a2 sorry = g n"}, {"line": "simp [eval\u2082_monomial, f.map_one, X, prod_single_index, pow_one]", "tactic_state": "S\u2081 : Type v\n\u03c3 : Type u_1\ninst\u271d : CommSemiring S\u2081\ng : \u03c3 \u2192 S\u2081\nx\u271d : Sort u_2\nX : x\u271d\nn : \u03c3\n\u22a2 sorry () = g n"}]}
{"declaration": "theorem eval\u2082_eta (p : MvPolynomial \u03c3 R) : eval\u2082 C X p = p := by\n  apply MvPolynomial.induction_on p <;>\n    simp +contextual [eval\u2082_add, eval\u2082_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Eval.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\nx\u271d : Sort u_2\neval\u2082 : x\u271d\np : MvPolynomial \u03c3 R\n\u22a2 sorry = p"}, {"line": "apply MvPolynomial.induction_on p <;>\n    simp +contextual [eval\u2082_add, eval\u2082_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval\u2082Hom_zero (f : R \u2192+* S\u2082) : eval\u2082Hom f (0 : \u03c3 \u2192 S\u2082) = f.comp constantCoeff := by\n  ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Eval.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)", "{f : \u03c3 \u2192 R}", "(f : R \u2192+* S\u2081)", "[Algebra R S\u2081] [CommSemiring S\u2082]", "(f : \u03c3 \u2192 S\u2081)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS\u2082 : Type w\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2082\nx\u271d : Sort u_2\neval\u2082Hom : x\u271d\n\u03b1\u271d : Type u_3\ninst\u271d : NonAssocSemiring \u03b1\u271d\nconstantCoeff : \u03b1\u271d \u2192+* R\nf : R \u2192+* S\u2082\n\u22a2 sorry = f.comp constantCoeff"}, {"line": "ext <;> simp", "tactic_state": "case a\nR : Type u\nS\u2082 : Type w\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2082\nx\u271d\u00b9 : Sort u_2\neval\u2082Hom : x\u271d\u00b9\n\u03b1\u271d : Type u_3\ninst\u271d : NonAssocSemiring \u03b1\u271d\nconstantCoeff : \u03b1\u271d \u2192+* R\nf : R \u2192+* S\u2082\nx\u271d : \u03b1\u271d\n\u22a2 (sorry ()) x\u271d = f (constantCoeff x\u271d)"}]}
{"declaration": "theorem _root_.Algebra.adjoin_eq_range (s : Set S\u2081) :\n    Algebra.adjoin R s = (MvPolynomial.aeval ((\u2191) : s \u2192 S\u2081)).range := by\n  rw [\u2190 Algebra.adjoin_range_eq_range_aeval]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Eval.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "scoped Pointwise"], "variables": ["{R : Type u} {S\u2081 : Type v} {S\u2082 : Type w} {S\u2083 : Type x}", "{\u03c3 : Type*} {a a' a\u2081 a\u2082 : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] [CommSemiring S\u2081] {p q : MvPolynomial \u03c3 R}", "(f : R \u2192+* S\u2081) (g : \u03c3 \u2192 S\u2081)", "{f : \u03c3 \u2192 R}", "(f : R \u2192+* S\u2081)", "[Algebra R S\u2081] [CommSemiring S\u2082]", "(f : \u03c3 \u2192 S\u2081)", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS\u2081 : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2081\ninst\u271d : Algebra R S\u2081\ns : Set S\u2081\n\u22a2 Algebra.adjoin R s = (MvPolynomial.aeval Subtype.val).range"}, {"line": "rw [\u2190 Algebra.adjoin_range_eq_range_aeval]", "tactic_state": "R : Type u\nS\u2081 : Type v\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : CommSemiring S\u2081\ninst\u271d : Algebra R S\u2081\ns : Set S\u2081\n\u22a2 Algebra.adjoin R s = Algebra.adjoin R (range Subtype.val)"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pderiv_X_self (i : \u03c3) : pderiv i (X i : MvPolynomial \u03c3 R) = 1 := by classical simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/PDeriv.lean", "context": {"open": ["Set Function Finsupp"], "variables": ["{R : Type u} {\u03c3 : Type v} {a a' a\u2081 a\u2082 : R} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type v\nx\u271d : Sort u_1\npderiv : x\u271d\ni : \u03c3\n\u22a2 sorry = 1"}, {"line": "classical simp", "tactic_state": "\u03c3 : Type v\nx\u271d : Sort u_1\npderiv : x\u271d\ni : \u03c3\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem pderiv_X_of_ne {i j : \u03c3} (h : j \u2260 i) : pderiv i (X j : MvPolynomial \u03c3 R) = 0 := by\n  classical simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/PDeriv.lean", "context": {"open": ["Set Function Finsupp"], "variables": ["{R : Type u} {\u03c3 : Type v} {a a' a\u2081 a\u2082 : R} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type v\nx\u271d : Sort u_1\npderiv : x\u271d\ni j : \u03c3\nh : j \u2260 i\n\u22a2 sorry = 0"}, {"line": "classical simp [h]", "tactic_state": "\u03c3 : Type v\nx\u271d : Sort u_1\npderiv : x\u271d\ni j : \u03c3\nh : j \u2260 i\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma rename_id_apply (p : MvPolynomial \u03c3 R) : rename id p = p := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Rename.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{\u03c3 \u03c4 \u03b1 R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nrename : x\u271d\np : MvPolynomial \u03c3 R\n\u22a2 sorry = p"}, {"line": "simp", "tactic_state": "\u03c3 : Type u_1\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nrename : x\u271d\np : MvPolynomial \u03c3 R\n\u22a2 sorry () = p"}]}
{"declaration": "theorem rename_leftInverse {f : \u03c3 \u2192 \u03c4} {g : \u03c4 \u2192 \u03c3} (hf : Function.LeftInverse f g) :\n    Function.LeftInverse (rename f : MvPolynomial \u03c3 R \u2192 MvPolynomial \u03c4 R) (rename g) := by\n  intro x\n  simp [hf.comp_eq_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Rename.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{\u03c3 \u03c4 \u03b1 R S : Type*} [CommSemiring R] [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nrename : x\u271d\nf : \u03c3 \u2192 \u03c4\ng : \u03c4 \u2192 \u03c3\nhf : LeftInverse f g\n\u22a2 LeftInverse sorry sorry"}, {"line": "intro x", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nrename : x\u271d\nf : \u03c3 \u2192 \u03c4\ng : \u03c4 \u2192 \u03c3\nhf : LeftInverse f g\nx : MvPolynomial \u03c4 R\n\u22a2 sorry (sorry x) = x"}, {"line": "simp [hf.comp_eq_id]", "tactic_state": "\u03c3 : Type u_1\n\u03c4 : Type u_2\nR : Type u_4\ninst\u271d : CommSemiring R\nx\u271d : Sort u_6\nrename : x\u271d\nf : \u03c3 \u2192 \u03c4\ng : \u03c4 \u2192 \u03c3\nhf : LeftInverse f g\nx : MvPolynomial \u03c4 R\n\u22a2 sorry () (sorry () x) = x"}]}
{"declaration": "theorem coeff_rename_ne_zero (f : \u03c3 \u2192 \u03c4) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c4 \u2192\u2080 \u2115)\n    (h : (rename f \u03c6).coeff d \u2260 0) : \u2203 u : \u03c3 \u2192\u2080 \u2115, u.mapDomain f = d \u2227 \u03c6.coeff u \u2260 0 := by\n  contrapose! h\n  apply coeff_rename_eq_zero _ _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Rename.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra", "Classical in"], "variables": ["{\u03c3 \u03c4 \u03b1 R S : Type*} [CommSemiring R] [CommSemiring S]", "{f : \u03c3 \u2192 \u03c4} (hf : Function.Injective f)", "(R)", "(f : R \u2192+* S) (k : \u03c3 \u2192 \u03c4) (g : \u03c4 \u2192 S) (p : MvPolynomial \u03c3 R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3 : Type u_3\n\u03c4 : Type u_4\nx\u271d : Sort u_1\nrename : x\u271d\nf : \u03c3 \u2192 \u03c4\n\u03c6 : sorry\nd : \u03c4 \u2192\u2080 \u2115\nh : sorry \u2260 0\n\u22a2 \u2203 u, Finsupp.mapDomain f u = d \u2227 sorry \u2260 0"}, {"line": "contrapose! h", "tactic_state": "\u03c3 : Type u_3\n\u03c4 : Type u_4\nx\u271d : Sort u_1\nrename : x\u271d\nf : \u03c3 \u2192 \u03c4\n\u03c6 : sorry\nd : \u03c4 \u2192\u2080 \u2115\nh : \u2200 (u : \u03c3 \u2192\u2080 \u2115), Finsupp.mapDomain f u = d \u2192 sorry = 0\n\u22a2 sorry = 0"}, {"line": "apply coeff_rename_eq_zero _ _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_vars (i : \u03c3) : i \u2208 p.vars \u2194 \u2203 d \u2208 p.support, i \u2208 d.support := by\n  classical simp only [vars_def, Multiset.mem_toFinset, mem_degrees, mem_support_iff, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Variables.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\ni : \u03c3\n\u22a2 i \u2208 p.vars \u2194 \u2203 d \u2208 p.support, i \u2208 d.support"}, {"line": "classical simp only [vars_def, Multiset.mem_toFinset, mem_degrees, mem_support_iff, exists_prop]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\ni : \u03c3\n\u22a2 i \u2208 p.vars \u2194 \u2203 d \u2208 p.support, d i \u2260 0"}]}
{"declaration": "theorem vars_map : (map f p).vars \u2286 p.vars := by\n  classical simp [vars_def, Multiset.subset_of_le degrees_map_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Variables.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}", "{A : Type*} [CommRing A] [NoZeroDivisors A]", "{\u03b9 : Type*} (t : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R)", "[CommSemiring S] (f : R \u2192+* S)", "(p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\nx\u271d : Sort u_5\nmap : x\u271d\n\u22a2 sorry \u2286 p.vars"}, {"line": "classical simp [vars_def, Multiset.subset_of_le degrees_map_le]", "tactic_state": "R : Type u\n\u03c3 : Type u_1\ninst\u271d : CommSemiring R\np : MvPolynomial \u03c3 R\nx\u271d : Sort u_5\nmap : x\u271d\n\u22a2 sorry () \u2286 p.vars"}]}
{"declaration": "theorem vars_map_of_injective (hf : Injective f) : (map f p).vars = p.vars := by\n  simp [vars, degrees_map_of_injective _ hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/MvPolynomial/Variables.lean", "context": {"open": ["Set Function Finsupp AddMonoidAlgebra"], "variables": ["{R : Type u} {S : Type v}", "{\u03c3 \u03c4 : Type*} {r : R} {e : \u2115} {n m : \u03c3} {s : \u03c3 \u2192\u2080 \u2115}", "[CommSemiring R] {p q : MvPolynomial \u03c3 R}", "{A : Type*} [CommRing A] [NoZeroDivisors A]", "{\u03b9 : Type*} (t : Finset \u03b9) (\u03c6 : \u03b9 \u2192 MvPolynomial \u03c3 R)", "[CommSemiring S] (f : R \u2192+* S)", "(p)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nS : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx\u271d : Sort u_5\nmap : x\u271d\nhf : Injective \u21d1f\n\u22a2 sorry = p.vars"}, {"line": "simp [vars, degrees_map_of_injective _ hf]", "tactic_state": "R : Type u\nS : Type v\n\u03c3 : Type u_1\ninst\u271d\u00b9 : CommSemiring R\np : MvPolynomial \u03c3 R\ninst\u271d : CommSemiring S\nf : R \u2192+* S\nx\u271d : Sort u_5\nmap : x\u271d\nhf : Injective \u21d1f\n\u22a2 sorry () = p.vars"}]}
{"declaration": "theorem smul_ne_zero_iff : c \u2022 x \u2260 0 \u2194 c \u2260 0 \u2227 x \u2260 0 := by rw [Ne, smul_eq_zero, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/NoZeroSMulDivisors/Defs.lean", "context": {"open": [], "variables": ["{R M : Type*}", "[Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] {c : R} {x : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\n\u22a2 c \u2022 x \u2260 0 \u2194 c \u2260 0 \u2227 x \u2260 0"}, {"line": "rw [Ne, smul_eq_zero, not_or]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\n\u22a2 NoZeroSMulDivisors R M"}]}
{"declaration": "lemma smul_ne_zero_iff_left (hx : x \u2260 0) : c \u2022 x \u2260 0 \u2194 c \u2260 0 := by simp [hx]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/NoZeroSMulDivisors/Defs.lean", "context": {"open": [], "variables": ["{R M : Type*}", "[Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] {c : R} {x : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\nhx : x \u2260 0\n\u22a2 c \u2022 x \u2260 0 \u2194 c \u2260 0"}, {"line": "simp [hx]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\nhx : x \u2260 0\n\u22a2 \u00acc \u2022 x = 0 \u2194 \u00acc = 0"}]}
{"declaration": "lemma smul_ne_zero_iff_right (hc : c \u2260 0) : c \u2022 x \u2260 0 \u2194 x \u2260 0 := by simp [hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/NoZeroSMulDivisors/Defs.lean", "context": {"open": [], "variables": ["{R M : Type*}", "[Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] {c : R} {x : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\nhc : c \u2260 0\n\u22a2 c \u2022 x \u2260 0 \u2194 x \u2260 0"}, {"line": "simp [hc]", "tactic_state": "R : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : Zero R\ninst\u271d\u00b2 : Zero M\ninst\u271d\u00b9 : SMulWithZero R M\ninst\u271d : NoZeroSMulDivisors R M\nc : R\nx : M\nhc : c \u2260 0\n\u22a2 \u00acc \u2022 x = 0 \u2194 \u00acx = 0"}]}
{"declaration": "lemma mul_dite (a : \u03b1) (b : P \u2192 \u03b1) (c : \u00ac P \u2192 \u03b1) :\n    (a * if h : P then b h else c h) = if h : P then a * b h else a * c h := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Mul \u03b1\na : \u03b1\nb : P \u2192 \u03b1\nc : \u00acP \u2192 \u03b1\n\u22a2 (a * if h : P then b h else c h) = if h : P then a * b h else a * c h"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dite_mul (a : P \u2192 \u03b1) (b : \u00ac P \u2192 \u03b1) (c : \u03b1) :\n    (if h : P then a h else b h) * c = if h : P then a h * c else b h * c := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Mul \u03b1\na : P \u2192 \u03b1\nb : \u00acP \u2192 \u03b1\nc : \u03b1\n\u22a2 (if h : P then a h else b h) * c = if h : P then a h * c else b h * c"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dite_mul_dite (a : P \u2192 \u03b1) (b : \u00ac P \u2192 \u03b1) (c : P \u2192 \u03b1) (d : \u00ac P \u2192 \u03b1) :\n    ((if h : P then a h else b h) * if h : P then c h else d h) =\n      if h : P then a h * c h else b h * d h := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Mul \u03b1\na : P \u2192 \u03b1\nb : \u00acP \u2192 \u03b1\nc : P \u2192 \u03b1\nd : \u00acP \u2192 \u03b1\n\u22a2 ((if h : P then a h else b h) * if h : P then c h else d h) = if h : P then a h * c h else b h * d h"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ite_mul_ite (a b c d : \u03b1) :\n    ((if P then a else b) * if P then c else d) = if P then a * c else b * d := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b9 : Decidable P\ninst\u271d : Mul \u03b1\na b c d : \u03b1\n\u22a2 ((if P then a else b) * if P then c else d) = if P then a * c else b * d"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_dite (a : \u03b1) (b : P \u2192 \u03b1) (c : \u00ac P \u2192 \u03b1) :\n    (a / if h : P then b h else c h) = if h : P then a / b h else a / c h := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]", "[Div \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b2 : Decidable P\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Div \u03b1\na : \u03b1\nb : P \u2192 \u03b1\nc : \u00acP \u2192 \u03b1\n\u22a2 (a / if h : P then b h else c h) = if h : P then a / b h else a / c h"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dite_div (a : P \u2192 \u03b1) (b : \u00ac P \u2192 \u03b1) (c : \u03b1) :\n    (if h : P then a h else b h) / c = if h : P then a h / c else b h / c := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]", "[Div \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b2 : Decidable P\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Div \u03b1\na : P \u2192 \u03b1\nb : \u00acP \u2192 \u03b1\nc : \u03b1\n\u22a2 (if h : P then a h else b h) / c = if h : P then a h / c else b h / c"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dite_div_dite (a : P \u2192 \u03b1) (b : \u00ac P \u2192 \u03b1) (c : P \u2192 \u03b1) (d : \u00ac P \u2192 \u03b1) :\n    ((if h : P then a h else b h) / if h : P then c h else d h) =\n      if h : P then a h / c h else b h / d h := by split <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Defs.lean", "context": {"open": [], "variables": ["{G : Type*}", "{\u03b1 : Type*} (P : Prop) [Decidable P]", "[Mul \u03b1]", "[Div \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nP : Prop\ninst\u271d\u00b2 : Decidable P\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Div \u03b1\na : P \u2192 \u03b1\nb : \u00acP \u2192 \u03b1\nc : P \u2192 \u03b1\nd : \u00acP \u2192 \u03b1\n\u22a2 ((if h : P then a h else b h) / if h : P then c h else d h) = if h : P then a h / c h else b h / d h"}, {"line": "split <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_ite [LE \u03b1] (ha : 1 \u2264 a) (hb : 1 \u2264 b) : 1 \u2264 ite p a b := by split <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[One \u03b1] {p : Prop} [Decidable p] {a : p \u2192 \u03b1} {b : \u00ac p \u2192 \u03b1}", "[One \u03b1] {p : Prop} [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : One \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LE \u03b1\nha : 1 \u2264 a\nhb : 1 \u2264 b\n\u22a2 1 \u2264 if p then a else b"}, {"line": "split <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ite_le_one [LE \u03b1] (ha : a \u2264 1) (hb : b \u2264 1) : ite p a b \u2264 1 := by split <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[One \u03b1] {p : Prop} [Decidable p] {a : p \u2192 \u03b1} {b : \u00ac p \u2192 \u03b1}", "[One \u03b1] {p : Prop} [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : One \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LE \u03b1\nha : a \u2264 1\nhb : b \u2264 1\n\u22a2 (if p then a else b) \u2264 1"}, {"line": "split <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_lt_ite [LT \u03b1] (ha : 1 < a) (hb : 1 < b) : 1 < ite p a b := by split <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[One \u03b1] {p : Prop} [Decidable p] {a : p \u2192 \u03b1} {b : \u00ac p \u2192 \u03b1}", "[One \u03b1] {p : Prop} [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : One \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LT \u03b1\nha : 1 < a\nhb : 1 < b\n\u22a2 1 < if p then a else b"}, {"line": "split <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ite_lt_one [LT \u03b1] (ha : a < 1) (hb : b < 1) : ite p a b < 1 := by split <;> assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Notation/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[One \u03b1] {p : Prop} [Decidable p] {a : p \u2192 \u03b1} {b : \u00ac p \u2192 \u03b1}", "[One \u03b1] {p : Prop} [Decidable p] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : One \u03b1\np : Prop\ninst\u271d\u00b9 : Decidable p\na b : \u03b1\ninst\u271d : LT \u03b1\nha : a < 1\nhb : b < 1\n\u22a2 (if p then a else b) < 1"}, {"line": "split <;> assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sq_sum_le_card_mul_sum_sq : (\u2211 i \u2208 s, f i) ^ 2 \u2264 #s * \u2211 i \u2208 s, f i ^ 2 := by\n  simp_rw [sq]\n  exact (monovaryOn_self _ _).sum_mul_sum_le_card_mul_sum\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Chebyshev.lean", "context": {"open": ["Equiv Equiv.Perm Finset Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semiring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [ExistsAddOfLE \u03b1]", "[Fintype \u03b9]", "[Semiring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [ExistsAddOfLE \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\n\u22a2 (\u2211 i \u2208 s, sorry) ^ 2 \u2264 s.card * \u2211 i \u2208 s, sorry ^ 2"}, {"line": "simp_rw [sq]", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\n\u22a2 (\u2211 i \u2208 s, sorry) * \u2211 i \u2208 s, sorry \u2264 s.card * \u2211 x \u2208 s, sorry * sorry"}, {"line": "exact (monovaryOn_self _ _).sum_mul_sum_le_card_mul_sum", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invOf_nonpos [Invertible a] : \u215f a \u2264 0 \u2194 a \u2264 0 := by simp only [\u2190 not_lt, invOf_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Invertible.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] {a : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\na : R\ninst\u271d : Invertible a\n\u22a2 \u215f a \u2264 0 \u2194 a \u2264 0"}, {"line": "simp only [\u2190 not_lt, invOf_pos]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\na : R\ninst\u271d : Invertible a\n\u22a2 \u00ac0 < \u215f a \u2194 \u00ac0 < a"}]}
{"declaration": "theorem invOf_lt_zero [Invertible a] : \u215f a < 0 \u2194 a < 0 := by simp only [\u2190 not_le, invOf_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Invertible.lean", "context": {"open": [], "variables": ["{R : Type*} [Semiring R] [LinearOrder R] [IsStrictOrderedRing R] {a : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\na : R\ninst\u271d : Invertible a\n\u22a2 \u215f a < 0 \u2194 a < 0"}, {"line": "simp only [\u2190 not_le, invOf_nonneg]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\na : R\ninst\u271d : Invertible a\n\u22a2 \u00ac0 \u2264 \u215f a \u2194 \u00ac0 \u2264 a"}]}
{"declaration": "lemma one_le_mulSingle : 1 \u2264 mulSingle i a \u2194 1 \u2264 a := by simp [mulSingle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Pi.lean", "context": {"open": [], "variables": ["{I \u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type*}", "(\u03b2) [One \u03b1] [Preorder \u03b1] {a : \u03b1}", "{\u03b2} [Nonempty \u03b2]", "[One \u03b3] [LE \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {e : \u03b2 \u2192 \u03b3}", "{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [DecidableEq \u03b9] [\u2200 i, One (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)] {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\nx\u271d : Sort u_8\nmulSingle : x\u271d\n\u22a2 1 \u2264 sorry \u2194 1 \u2264 a"}, {"line": "simp [mulSingle]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\nx\u271d : Sort u_8\nmulSingle : x\u271d\n\u22a2 1 \u2264 sorry () \u2194 1 \u2264 a"}]}
{"declaration": "lemma mulSingle_le_one : mulSingle i a \u2264 1 \u2194 a \u2264 1 := by simp [mulSingle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Pi.lean", "context": {"open": [], "variables": ["{I \u03b1 \u03b2 \u03b3 : Type*}", "{f : I \u2192 Type*}", "(\u03b2) [One \u03b1] [Preorder \u03b1] {a : \u03b1}", "{\u03b2} [Nonempty \u03b2]", "[One \u03b3] [LE \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {e : \u03b2 \u2192 \u03b3}", "{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [DecidableEq \u03b9] [\u2200 i, One (\u03b1 i)] [\u2200 i, Preorder (\u03b1 i)] {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\nx\u271d : Sort u_8\nmulSingle : x\u271d\n\u22a2 sorry \u2264 1 \u2194 a \u2264 1"}, {"line": "simp [mulSingle]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : Preorder \u03b1\na : \u03b1\nx\u271d : Sort u_8\nmulSingle : x\u271d\n\u22a2 sorry () \u2264 1 \u2194 a \u2264 1"}]}
{"declaration": "theorem sub_top {a : WithTop \u03b1} : a - \u22a4 = \u22a4 := by cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AddGroupWithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[LinearOrderedAddCommMonoidWithTop \u03b1]", "[AddCommGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommMonoidWithTop \u03b1\ninst\u271d : AddCommGroup \u03b1\na : WithTop \u03b1\n\u22a2 a - \u22a4 = \u22a4"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_eq_top_iff {a b : WithTop \u03b1} : a - b = \u22a4 \u2194 (a = \u22a4 \u2228 b = \u22a4) := by\n  cases a <;> cases b <;> simp [\u2190 coe_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AddGroupWithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[LinearOrderedAddCommMonoidWithTop \u03b1]", "[AddCommGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrderedAddCommMonoidWithTop \u03b1\ninst\u271d : AddCommGroup \u03b1\na b : WithTop \u03b1\n\u22a2 a - b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4"}, {"line": "cases a <;> cases b <;> simp [\u2190 coe_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma injective_add_right_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : Function.Injective (fun x \u21a6 b + x) := by\n  simpa [add_comm] using injective_add_left_of_ne_top b h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AddGroupWithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[LinearOrderedAddCommMonoidWithTop \u03b1]", "[AddCommGroup \u03b1]", "[LinearOrderedAddCommGroupWithTop \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop \u03b1\ninst\u271d\u00b9 : AddCommGroup \u03b1\ninst\u271d : LinearOrderedAddCommGroupWithTop \u03b1\nb : \u03b1\nh : b \u2260 \u22a4\n\u22a2 Injective fun x => b + x"}, {"line": "simpa [add_comm] using injective_add_left_of_ne_top b h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMono_add_right_of_ne_top (b : \u03b1) (h : b \u2260 \u22a4) : StrictMono (fun x \u21a6 b + x) := by\n  simpa [add_comm] using strictMono_add_left_of_ne_top b h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AddGroupWithTop.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[LinearOrderedAddCommMonoidWithTop \u03b1]", "[AddCommGroup \u03b1]", "[LinearOrderedAddCommGroupWithTop \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrderedAddCommMonoidWithTop \u03b1\ninst\u271d\u00b9 : AddCommGroup \u03b1\ninst\u271d : LinearOrderedAddCommGroupWithTop \u03b1\nb : \u03b1\nh : b \u2260 \u22a4\n\u22a2 StrictMono fun x => b + x"}, {"line": "simpa [add_comm] using strictMono_add_left_of_ne_top b h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cutMap_self (a : \u03b1) : cutMap \u03b1 a = Iio a \u2229 range (Rat.cast : \u211a \u2192 \u03b1) := by\n  ext\n  constructor\n  \u00b7 rintro \u27e8q, h, rfl\u27e9\n    exact \u27e8h, q, rfl\u27e9\n  \u00b7 rintro \u27e8h, q, rfl\u27e9\n    exact \u27e8q, h, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CompleteField.lean", "context": {"open": ["Function Rat Set", "scoped Pointwise"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*}", "[Field \u03b1] [LinearOrder \u03b1]", "(\u03b2) [DivisionRing \u03b2] {a a\u2081 a\u2082 : \u03b1} {b : \u03b2} {q : \u211a}", "{\u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d : Sort u_5\ncutMap : x\u271d\na : \u03b1\n\u22a2 sorry = Iio a \u2229 range Rat.cast"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d\u00b9 : Sort u_5\ncutMap : x\u271d\u00b9\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 Iio a \u2229 range Rat.cast"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d\u00b9 : Sort u_5\ncutMap : x\u271d\u00b9\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 sorry \u2192 x\u271d \u2208 Iio a \u2229 range Rat.cast\n---\ncase h.mpr\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d\u00b9 : Sort u_5\ncutMap : x\u271d\u00b9\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 Iio a \u2229 range Rat.cast \u2192 x\u271d \u2208 sorry"}, {"line": "\u00b7 rintro \u27e8q, h, rfl\u27e9\n    exact \u27e8h, q, rfl\u27e9", "tactic_state": "case h.mpr\n\u03b1 : Type u_2\ninst\u271d\u00b9 : Field \u03b1\ninst\u271d : LinearOrder \u03b1\nx\u271d\u00b9 : Sort u_5\ncutMap : x\u271d\u00b9\na x\u271d : \u03b1\n\u22a2 x\u271d \u2208 Iio a \u2229 range Rat.cast \u2192 x\u271d \u2208 sorry"}, {"line": "\u00b7 rintro \u27e8h, q, rfl\u27e9\n    exact \u27e8q, h, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjointed_add_one [NoMaxOrder \u03b9] (f : \u03b9 \u2192 \u03b1) (i : \u03b9) :\n    disjointed f (i + 1) = f (i + 1) \\ partialSups f i := by\n  simpa only [succ_eq_add_one] using disjointed_succ f (not_isMax i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Disjointed.lean", "context": {"open": ["Order"], "variables": ["{\u03b1 \u03b9 : Type*} [GeneralizedBooleanAlgebra \u03b1]", "[LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [Add \u03b9] [One \u03b9] [SuccAddOrder \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2076 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u2075 : LinearOrder \u03b9\ninst\u271d\u2074 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u00b3 : Add \u03b9\ninst\u271d\u00b2 : One \u03b9\ninst\u271d\u00b9 : SuccAddOrder \u03b9\ninst\u271d : NoMaxOrder \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\n\u22a2 disjointed f (i + 1) = f (i + 1) \\ (partialSups f) i"}, {"line": "simpa only [succ_eq_add_one] using disjointed_succ f (not_isMax i)", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Monotone.disjointed_add_one_sup {f : \u03b9 \u2192 \u03b1} (hf : Monotone f) (i : \u03b9) :\n    disjointed f (i + 1) \u2294 f i = f (i + 1) := by\n  simpa only [succ_eq_add_one i] using hf.disjointed_succ_sup i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Disjointed.lean", "context": {"open": ["Order"], "variables": ["{\u03b1 \u03b9 : Type*} [GeneralizedBooleanAlgebra \u03b1]", "[LinearOrder \u03b9] [LocallyFiniteOrderBot \u03b9] [Add \u03b9] [One \u03b9] [SuccAddOrder \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2075 : GeneralizedBooleanAlgebra \u03b1\ninst\u271d\u2074 : LinearOrder \u03b9\ninst\u271d\u00b3 : LocallyFiniteOrderBot \u03b9\ninst\u271d\u00b2 : Add \u03b9\ninst\u271d\u00b9 : One \u03b9\ninst\u271d : SuccAddOrder \u03b9\nf : \u03b9 \u2192 \u03b1\nhf : Monotone f\ni : \u03b9\n\u22a2 disjointed f (i + 1) \u2294 f i = f (i + 1)"}, {"line": "simpa only [succ_eq_add_one i] using hf.disjointed_succ_sup i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem round_zero : round (0 : \u03b1) = 0 := by simp [round]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 round 0 = 0"}, {"line": "simp [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 (if 2 * fract 0 < 1 then \u230a0\u230b else \u23080\u2309) = 0"}]}
{"declaration": "theorem round_one : round (1 : \u03b1) = 1 := by simp [round]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 round 1 = 1"}, {"line": "simp [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\n\u22a2 (if 2 * fract 1 < 1 then \u230a1\u230b else \u23081\u2309) = 1"}]}
{"declaration": "theorem round_natCast (n : \u2115) : round (n : \u03b1) = n := by simp [round]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nn : \u2115\n\u22a2 round \u2191n = \u2191n"}, {"line": "simp [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nn : \u2115\n\u22a2 (if 2 * fract \u2191n < 1 then \u230a\u2191n\u230b else \u2308\u2191n\u2309) = \u2191n"}]}
{"declaration": "theorem round_intCast (n : \u2124) : round (n : \u03b1) = n := by simp [round]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nn : \u2124\n\u22a2 round \u2191n = n"}, {"line": "simp [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nn : \u2124\n\u22a2 (if 2 * fract \u2191n < 1 then \u230a\u2191n\u230b else \u2308\u2191n\u2309) = n"}]}
{"declaration": "theorem round_add_intCast (x : \u03b1) (y : \u2124) : round (x + y) = round x + y := by\n  rw [round]\n  rw [round]\n  rw [Int.fract_add_intCast]\n  rw [Int.floor_add_intCast]\n  rw [Int.ceil_add_intCast]\n  rw [\u2190 apply_ite\u2082]\n  rw [ite_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 round (x + \u2191y) = round x + y"}, {"line": "rw [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 (if 2 * fract (x + \u2191y) < 1 then \u230ax + \u2191y\u230b else \u2308x + \u2191y\u2309) = round x + y"}, {"line": "rw [round]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 (if 2 * fract (x + \u2191y) < 1 then \u230ax + \u2191y\u230b else \u2308x + \u2191y\u2309) = (if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + y"}, {"line": "rw [Int.fract_add_intCast]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 (if 2 * fract x < 1 then \u230ax + \u2191y\u230b else \u2308x + \u2191y\u2309) = (if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + y\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}, {"line": "rw [Int.floor_add_intCast]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 (if 2 * fract x < 1 then \u230ax\u230b + y else \u2308x + \u2191y\u2309) = (if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + y\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}, {"line": "rw [Int.ceil_add_intCast]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 (if 2 * fract x < 1 then \u230ax\u230b + y else \u2308x\u2309 + y) = (if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + y\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}, {"line": "rw [\u2190 apply_ite\u2082]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 ((if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + if 2 * fract x < 1 then y else y) =\n    (if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309) + y\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}, {"line": "rw [ite_self]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}]}
{"declaration": "theorem round_sub_intCast (x : \u03b1) (y : \u2124) : round (x - y) = round x - y := by\n  rw [sub_eq_add_neg]\n  norm_cast\n  rw [round_add_intCast]\n  rw [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Round.lean", "context": {"open": ["Set", "Int"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 round (x - \u2191y) = round x - y"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 round (x + -\u2191y) = round x - y"}, {"line": "norm_cast", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 round (x + \u2191(-y)) = round x - y"}, {"line": "rw [round_add_intCast]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 round x + -y = round x - y\n---\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}, {"line": "rw [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\nx : \u03b1\ny : \u2124\n\u22a2 IsStrictOrderedRing \u03b1"}]}
{"declaration": "theorem IsSuccLimit.natCast_lt [AddMonoidWithOne \u03b1] [SuccAddOrder \u03b1] [CanonicallyOrderedAdd \u03b1]\n    (hx : IsSuccLimit x) : \u2200 n : \u2115, n < x := by\n  simpa [bot_eq_zero] using hx.add_natCast_lt hx.bot_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\ninst\u271d\u00b9\u2070 : Preorder \u03b1\ninst\u271d\u2079 : Add \u03b1\ninst\u271d\u2078 : One \u03b1\ninst\u271d\u2077 : SuccAddOrder \u03b1\ninst\u271d\u2076 : Sub \u03b1\ninst\u271d\u2075 : One \u03b1\ninst\u271d\u2074 : PredSubOrder \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\nx\u271d : Sort u_2\nIsSuccLimit : x\u271d\ninst\u271d\u00b2 : AddMonoidWithOne \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : CanonicallyOrderedAdd \u03b1\nhx : sorry\n\u22a2 \u2200 (n : \u2115), \u2191n < x"}, {"line": "simpa [bot_eq_zero] using hx.add_natCast_lt hx.bot_lt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotoneOn_of_le_add_one (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f a \u2264 f (a + 1)) \u2192 MonotoneOn f s := by\n  simpa [Order.succ_eq_add_one] using monotoneOn_of_le_succ hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f a \u2264 f (a + 1)) \u2192 MonotoneOn f s"}, {"line": "simpa [Order.succ_eq_add_one] using monotoneOn_of_le_succ hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitoneOn_of_add_one_le (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f (a + 1) \u2264 f a) \u2192 AntitoneOn f s := by\n  simpa [Order.succ_eq_add_one] using antitoneOn_of_succ_le hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f (a + 1) \u2264 f a) \u2192 AntitoneOn f s"}, {"line": "simpa [Order.succ_eq_add_one] using antitoneOn_of_succ_le hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_of_lt_add_one (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f a < f (a + 1)) \u2192 StrictMonoOn f s := by\n  simpa [Order.succ_eq_add_one] using strictMonoOn_of_lt_succ hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f a < f (a + 1)) \u2192 StrictMonoOn f s"}, {"line": "simpa [Order.succ_eq_add_one] using strictMonoOn_of_lt_succ hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAntiOn_of_add_one_lt (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f (a + 1) < f a) \u2192 StrictAntiOn f s := by\n  simpa [Order.succ_eq_add_one] using strictAntiOn_of_succ_lt hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 a \u2208 s \u2192 a + 1 \u2208 s \u2192 f (a + 1) < f a) \u2192 StrictAntiOn f s"}, {"line": "simpa [Order.succ_eq_add_one] using strictAntiOn_of_succ_lt hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotone_of_le_add_one : (\u2200 a, \u00ac IsMax a \u2192 f a \u2264 f (a + 1)) \u2192 Monotone f := by\n  simpa [Order.succ_eq_add_one] using monotone_of_le_succ (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 f a \u2264 f (a + 1)) \u2192 Monotone f"}, {"line": "simpa [Order.succ_eq_add_one] using monotone_of_le_succ (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitone_of_add_one_le : (\u2200 a, \u00ac IsMax a \u2192 f (a + 1) \u2264 f a) \u2192 Antitone f := by\n  simpa [Order.succ_eq_add_one] using antitone_of_succ_le (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 f (a + 1) \u2264 f a) \u2192 Antitone f"}, {"line": "simpa [Order.succ_eq_add_one] using antitone_of_succ_le (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMono_of_lt_add_one : (\u2200 a, \u00ac IsMax a \u2192 f a < f (a + 1)) \u2192 StrictMono f := by\n  simpa [Order.succ_eq_add_one] using strictMono_of_lt_succ (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 f a < f (a + 1)) \u2192 StrictMono f"}, {"line": "simpa [Order.succ_eq_add_one] using strictMono_of_lt_succ (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_of_add_one_lt : (\u2200 a, \u00ac IsMax a \u2192 f (a + 1) < f a) \u2192 StrictAnti f := by\n  simpa [Order.succ_eq_add_one] using strictAnti_of_succ_lt (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Add \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : SuccAddOrder \u03b1\ninst\u271d : IsSuccArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMax a \u2192 f (a + 1) < f a) \u2192 StrictAnti f"}, {"line": "simpa [Order.succ_eq_add_one] using strictAnti_of_succ_lt (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotoneOn_of_sub_one_le (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f (a - 1) \u2264 f a) \u2192 MonotoneOn f s := by\n  simpa [Order.pred_eq_sub_one] using monotoneOn_of_pred_le hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f (a - 1) \u2264 f a) \u2192 MonotoneOn f s"}, {"line": "simpa [Order.pred_eq_sub_one] using monotoneOn_of_pred_le hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitoneOn_of_le_sub_one (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f a \u2264 f (a - 1)) \u2192 AntitoneOn f s := by\n  simpa [Order.pred_eq_sub_one] using antitoneOn_of_le_pred hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f a \u2264 f (a - 1)) \u2192 AntitoneOn f s"}, {"line": "simpa [Order.pred_eq_sub_one] using antitoneOn_of_le_pred hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_of_sub_one_lt (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f (a - 1) < f a) \u2192 StrictMonoOn f s := by\n  simpa [Order.pred_eq_sub_one] using strictMonoOn_of_pred_lt hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f (a - 1) < f a) \u2192 StrictMonoOn f s"}, {"line": "simpa [Order.pred_eq_sub_one] using strictMonoOn_of_pred_lt hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAntiOn_of_lt_sub_one (hs : s.OrdConnected) :\n    (\u2200 a, \u00ac IsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f a < f (a - 1)) \u2192 StrictAntiOn f s := by\n  simpa [Order.pred_eq_sub_one] using strictAntiOn_of_lt_pred hs (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.OrdConnected\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 a \u2208 s \u2192 a - 1 \u2208 s \u2192 f a < f (a - 1)) \u2192 StrictAntiOn f s"}, {"line": "simpa [Order.pred_eq_sub_one] using strictAntiOn_of_lt_pred hs (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotone_of_sub_one_le : (\u2200 a, \u00ac IsMin a \u2192 f (a - 1) \u2264 f a) \u2192 Monotone f := by\n  simpa [Order.pred_eq_sub_one] using monotone_of_pred_le (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 f (a - 1) \u2264 f a) \u2192 Monotone f"}, {"line": "simpa [Order.pred_eq_sub_one] using monotone_of_pred_le (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitone_of_le_sub_one : (\u2200 a, \u00ac IsMin a \u2192 f a \u2264 f (a - 1)) \u2192 Antitone f := by\n  simpa [Order.pred_eq_sub_one] using antitone_of_le_pred (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 f a \u2264 f (a - 1)) \u2192 Antitone f"}, {"line": "simpa [Order.pred_eq_sub_one] using antitone_of_le_pred (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMono_of_sub_one_lt : (\u2200 a, \u00ac IsMin a \u2192 f (a - 1) < f a) \u2192 StrictMono f := by\n  simpa [Order.pred_eq_sub_one] using strictMono_of_pred_lt (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 f (a - 1) < f a) \u2192 StrictMono f"}, {"line": "simpa [Order.pred_eq_sub_one] using strictMono_of_pred_lt (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_of_lt_sub_one : (\u2200 a, \u00ac IsMin a \u2192 f a < f (a - 1)) \u2192 StrictAnti f := by\n  simpa [Order.pred_eq_sub_one] using strictAnti_of_lt_pred (f := f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/SuccPred.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {x y : \u03b1}", "[Preorder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1]", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1]", "{\u03b1 \u03b2 : Type*} [PartialOrder \u03b1] [Preorder \u03b2]", "[Add \u03b1] [One \u03b1] [SuccAddOrder \u03b1] [IsSuccArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[Sub \u03b1] [One \u03b1] [PredSubOrder \u03b1] [IsPredArchimedean \u03b1] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2079 : PartialOrder \u03b1\ninst\u271d\u2078 : Preorder \u03b2\ninst\u271d\u2077 : Add \u03b1\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : SuccAddOrder \u03b1\ninst\u271d\u2074 : IsSuccArchimedean \u03b1\ninst\u271d\u00b3 : Sub \u03b1\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : PredSubOrder \u03b1\ninst\u271d : IsPredArchimedean \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (\u2200 (a : \u03b1), \u00acIsMin a \u2192 f a < f (a - 1)) \u2192 StrictAnti f"}, {"line": "simpa [Order.pred_eq_sub_one] using strictAnti_of_lt_pred (f := f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_mem_Ico' (b : \u03b1) : toIcoMod hp 0 b \u2208 Set.Ico 0 p := by\n  convert toIcoMod_mem_Ico hp 0 b\n  exact (zero_add p).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\np a\u271d : \u03b1\nhp : 0 < a\u271d\nb : \u03b1\n\u22a2 toIcoMod hp 0 b \u2208 Set.Ico 0 p"}, {"line": "convert toIcoMod_mem_Ico hp 0 b", "tactic_state": "case h.e'_4.h.e'_4\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\np a\u271d : \u03b1\nhp : 0 < a\u271d\nb : \u03b1\n\u22a2 p = 0 + a\u271d"}, {"line": "exact (zero_add p).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_sub_self (a b : \u03b1) : toIcoMod hp a b - b = -toIcoDiv hp a b \u2022 p := by\n  rw [toIcoMod]\n  rw [sub_sub_cancel_left]\n  rw [neg_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp a b - b = -toIcoDiv hp a b \u2022 p"}, {"line": "rw [toIcoMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - toIcoDiv hp a b \u2022 a\u271d - b = -toIcoDiv hp a b \u2022 p"}, {"line": "rw [sub_sub_cancel_left]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 -(toIcoDiv hp a b \u2022 a\u271d) = -toIcoDiv hp a b \u2022 p"}, {"line": "rw [neg_smul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 -(toIcoDiv hp a b \u2022 a\u271d) = -(toIcoDiv hp a b \u2022 p)"}]}
{"declaration": "theorem toIocMod_sub_self (a b : \u03b1) : toIocMod hp a b - b = -toIocDiv hp a b \u2022 p := by\n  rw [toIocMod]\n  rw [sub_sub_cancel_left]\n  rw [neg_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp a b - b = -toIocDiv hp a b \u2022 p"}, {"line": "rw [toIocMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - toIocDiv hp a b \u2022 a\u271d - b = -toIocDiv hp a b \u2022 p"}, {"line": "rw [sub_sub_cancel_left]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 -(toIocDiv hp a b \u2022 a\u271d) = -toIocDiv hp a b \u2022 p"}, {"line": "rw [neg_smul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 -(toIocDiv hp a b \u2022 a\u271d) = -(toIocDiv hp a b \u2022 p)"}]}
{"declaration": "theorem self_sub_toIcoMod (a b : \u03b1) : b - toIcoMod hp a b = toIcoDiv hp a b \u2022 p := by\n  rw [toIcoMod]\n  rw [sub_sub_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - toIcoMod hp a b = toIcoDiv hp a b \u2022 p"}, {"line": "rw [toIcoMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - (b - toIcoDiv hp a b \u2022 a\u271d) = toIcoDiv hp a b \u2022 p"}, {"line": "rw [sub_sub_cancel]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoDiv hp a b \u2022 a\u271d = toIcoDiv hp a b \u2022 p"}]}
{"declaration": "theorem self_sub_toIocMod (a b : \u03b1) : b - toIocMod hp a b = toIocDiv hp a b \u2022 p := by\n  rw [toIocMod]\n  rw [sub_sub_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - toIocMod hp a b = toIocDiv hp a b \u2022 p"}, {"line": "rw [toIocMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 b - (b - toIocDiv hp a b \u2022 a\u271d) = toIocDiv hp a b \u2022 p"}, {"line": "rw [sub_sub_cancel]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocDiv hp a b \u2022 a\u271d = toIocDiv hp a b \u2022 p"}]}
{"declaration": "theorem toIcoDiv_add_right (a b : \u03b1) : toIcoDiv hp a (b + p) = toIcoDiv hp a b + 1 := by\n  simpa only [one_zsmul] using toIcoDiv_add_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoDiv hp a (b + p) = toIcoDiv hp a b + 1"}, {"line": "simpa only [one_zsmul] using toIcoDiv_add_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoDiv_add_right' (a b : \u03b1) : toIcoDiv hp (a + p) b = toIcoDiv hp a b - 1 := by\n  simpa only [one_zsmul] using toIcoDiv_add_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoDiv hp (a + p) b = toIcoDiv hp a b - 1"}, {"line": "simpa only [one_zsmul] using toIcoDiv_add_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocDiv_add_right (a b : \u03b1) : toIocDiv hp a (b + p) = toIocDiv hp a b + 1 := by\n  simpa only [one_zsmul] using toIocDiv_add_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocDiv hp a (b + p) = toIocDiv hp a b + 1"}, {"line": "simpa only [one_zsmul] using toIocDiv_add_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocDiv_add_right' (a b : \u03b1) : toIocDiv hp (a + p) b = toIocDiv hp a b - 1 := by\n  simpa only [one_zsmul] using toIocDiv_add_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocDiv hp (a + p) b = toIocDiv hp a b - 1"}, {"line": "simpa only [one_zsmul] using toIocDiv_add_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoDiv_sub (a b : \u03b1) : toIcoDiv hp a (b - p) = toIcoDiv hp a b - 1 := by\n  simpa only [one_zsmul] using toIcoDiv_sub_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoDiv hp a (b - p) = toIcoDiv hp a b - 1"}, {"line": "simpa only [one_zsmul] using toIcoDiv_sub_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoDiv_sub' (a b : \u03b1) : toIcoDiv hp (a - p) b = toIcoDiv hp a b + 1 := by\n  simpa only [one_zsmul] using toIcoDiv_sub_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoDiv hp (a - p) b = toIcoDiv hp a b + 1"}, {"line": "simpa only [one_zsmul] using toIcoDiv_sub_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocDiv_sub (a b : \u03b1) : toIocDiv hp a (b - p) = toIocDiv hp a b - 1 := by\n  simpa only [one_zsmul] using toIocDiv_sub_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocDiv hp a (b - p) = toIocDiv hp a b - 1"}, {"line": "simpa only [one_zsmul] using toIocDiv_sub_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocDiv_sub' (a b : \u03b1) : toIocDiv hp (a - p) b = toIocDiv hp a b + 1 := by\n  simpa only [one_zsmul] using toIocDiv_sub_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocDiv hp (a - p) b = toIocDiv hp a b + 1"}, {"line": "simpa only [one_zsmul] using toIocDiv_sub_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoDiv_neg' (a b : \u03b1) : toIcoDiv hp (-a) b = -(toIocDiv hp a (-b) + 1) := by\n  simpa only [neg_neg] using toIcoDiv_neg hp (-a) (-b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIcoDiv hp (-a) b = -(toIocDiv hp a (-b) + 1)"}, {"line": "simpa only [neg_neg] using toIcoDiv_neg hp (-a) (-b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocDiv_neg' (a b : \u03b1) : toIocDiv hp (-a) b = -(toIcoDiv hp a (-b) + 1) := by\n  simpa only [neg_neg] using toIocDiv_neg hp (-a) (-b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIocDiv hp (-a) b = -(toIcoDiv hp a (-b) + 1)"}, {"line": "simpa only [neg_neg] using toIocDiv_neg hp (-a) (-b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_add_right (a b : \u03b1) : toIcoMod hp a (b + p) = toIcoMod hp a b := by\n  simpa only [one_zsmul] using toIcoMod_add_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp a (b + p) = toIcoMod hp a b"}, {"line": "simpa only [one_zsmul] using toIcoMod_add_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_add_right' (a b : \u03b1) : toIcoMod hp (a + p) b = toIcoMod hp a b + p := by\n  simpa only [one_zsmul] using toIcoMod_add_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp (a + p) b = toIcoMod hp a b + p"}, {"line": "simpa only [one_zsmul] using toIcoMod_add_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocMod_add_right (a b : \u03b1) : toIocMod hp a (b + p) = toIocMod hp a b := by\n  simpa only [one_zsmul] using toIocMod_add_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp a (b + p) = toIocMod hp a b"}, {"line": "simpa only [one_zsmul] using toIocMod_add_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocMod_add_right' (a b : \u03b1) : toIocMod hp (a + p) b = toIocMod hp a b + p := by\n  simpa only [one_zsmul] using toIocMod_add_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp (a + p) b = toIocMod hp a b + p"}, {"line": "simpa only [one_zsmul] using toIocMod_add_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_sub (a b : \u03b1) : toIcoMod hp a (b - p) = toIcoMod hp a b := by\n  simpa only [one_zsmul] using toIcoMod_sub_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp a (b - p) = toIcoMod hp a b"}, {"line": "simpa only [one_zsmul] using toIcoMod_sub_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_sub' (a b : \u03b1) : toIcoMod hp (a - p) b = toIcoMod hp a b - p := by\n  simpa only [one_zsmul] using toIcoMod_sub_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp (a - p) b = toIcoMod hp a b - p"}, {"line": "simpa only [one_zsmul] using toIcoMod_sub_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocMod_sub (a b : \u03b1) : toIocMod hp a (b - p) = toIocMod hp a b := by\n  simpa only [one_zsmul] using toIocMod_sub_zsmul hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp a (b - p) = toIocMod hp a b"}, {"line": "simpa only [one_zsmul] using toIocMod_sub_zsmul hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocMod_sub' (a b : \u03b1) : toIocMod hp (a - p) b = toIocMod hp a b - p := by\n  simpa only [one_zsmul] using toIocMod_sub_zsmul' hp a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp (a - p) b = toIocMod hp a b - p"}, {"line": "simpa only [one_zsmul] using toIocMod_sub_zsmul' hp a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_neg' (a b : \u03b1) : toIcoMod hp (-a) b = p - toIocMod hp a (-b) := by\n  simpa only [neg_neg] using toIcoMod_neg hp (-a) (-b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp (-a) b = p - toIocMod hp a (-b)"}, {"line": "simpa only [neg_neg] using toIcoMod_neg hp (-a) (-b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIocMod_neg' (a b : \u03b1) : toIocMod hp (-a) b = p - toIcoMod hp a (-b) := by\n  simpa only [neg_neg] using toIocMod_neg hp (-a) (-b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp (-a) b = p - toIcoMod hp a (-b)"}, {"line": "simpa only [neg_neg] using toIocMod_neg hp (-a) (-b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toIcoMod_le_toIocMod (a b : \u03b1) : toIcoMod hp a b \u2264 toIocMod hp a b := by\n  rw [toIcoMod]\n  rw [toIocMod]\n  rw [sub_le_sub_iff_left]\n  exact zsmul_left_mono hp.le (toIocDiv_wcovBy_toIcoDiv _ _ _).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIcoMod hp a b \u2264 toIocMod hp a b"}, {"line": "rw [toIcoMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - toIcoDiv hp a b \u2022 a\u271d \u2264 toIocMod hp a b"}, {"line": "rw [toIocMod]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - toIcoDiv hp a b \u2022 a\u271d \u2264 b - toIocDiv hp a b \u2022 a\u271d"}, {"line": "rw [sub_le_sub_iff_left]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIocDiv hp a b \u2022 a\u271d \u2264 toIcoDiv hp a b \u2022 a\u271d\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 AddLeftMono \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 AddRightMono \u03b1"}, {"line": "exact zsmul_left_mono hp.le (toIocDiv_wcovBy_toIcoDiv _ _ _).le", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 AddLeftMono \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 AddRightMono \u03b1"}]}
{"declaration": "theorem toIcoMod_add_toIocMod_zero (a b : \u03b1) :\n    toIcoMod hp 0 (a - b) + toIocMod hp 0 (b - a) = p := by\n  rw [toIcoMod_zero_sub_comm]\n  rw [sub_add_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp 0 (a - b) + toIocMod hp 0 (b - a) = p"}, {"line": "rw [toIcoMod_zero_sub_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 a\u271d - toIocMod hp 0 (b - a) + toIocMod hp 0 (b - a) = p"}, {"line": "rw [sub_add_cancel]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 a\u271d = p"}]}
{"declaration": "theorem toIocMod_add_toIcoMod_zero (a b : \u03b1) :\n    toIocMod hp 0 (a - b) + toIcoMod hp 0 (b - a) = p := by\n  rw [_root_.add_comm]\n  rw [toIcoMod_add_toIocMod_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIocMod hp 0 (a - b) + toIcoMod hp 0 (b - a) = p"}, {"line": "rw [_root_.add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 toIcoMod hp 0 (b - a) + toIocMod hp 0 (a - b) = p"}, {"line": "rw [toIcoMod_add_toIocMod_zero]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\nh\u03b1 : Archimedean \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\np a b : \u03b1\n\u22a2 a\u271d = p"}]}
{"declaration": "theorem toIcoMod_eq_add_fract_mul (a b : \u03b1) :\n    toIcoMod hp a b = a + Int.fract ((b - a) / p) * p := by\n  rw [toIcoMod]\n  rw [toIcoDiv_eq_floor]\n  rw [Int.fract]\n  field_simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIcoMod hp a b = a + Int.fract ((b - a) / \u2191p) * \u2191p"}, {"line": "rw [toIcoMod]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - toIcoDiv hp a b \u2022 a\u271d = a + Int.fract ((b - a) / \u2191p) * \u2191p"}, {"line": "rw [toIcoDiv_eq_floor]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - \u230a(b - a) / a\u271d\u230b \u2022 a\u271d = a + Int.fract ((b - a) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "rw [Int.fract]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - \u230a(b - a) / a\u271d\u230b \u2022 a\u271d = a + ((b - a) / \u2191p - \u2191\u230a(b - a) / \u2191p\u230b) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "field_simp", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - \u230a(b - a) / a\u271d\u230b \u2022 a\u271d = a + Int.fract ((b - a) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "ring", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - \u230a(b - a) / a\u271d\u230b \u2022 a\u271d = a + Int.fract ((b - a) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}]}
{"declaration": "theorem toIocMod_eq_sub_fract_mul (a b : \u03b1) :\n    toIocMod hp a b = a + p - Int.fract ((a + p - b) / p) * p := by\n  rw [toIocMod]\n  rw [toIocDiv_eq_neg_floor]\n  rw [Int.fract]\n  field_simp\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 toIocMod hp a b = a + \u2191p - Int.fract ((a + \u2191p - b) / \u2191p) * \u2191p"}, {"line": "rw [toIocMod]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - toIocDiv hp a b \u2022 a\u271d = a + \u2191p - Int.fract ((a + \u2191p - b) / \u2191p) * \u2191p"}, {"line": "rw [toIocDiv_eq_neg_floor]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - -\u230a(a + a\u271d - b) / a\u271d\u230b \u2022 a\u271d = a + \u2191p - Int.fract ((a + \u2191p - b) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "rw [Int.fract]", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b - -\u230a(a + a\u271d - b) / a\u271d\u230b \u2022 a\u271d = a + \u2191p - ((a + \u2191p - b) / \u2191p - \u2191\u230a(a + \u2191p - b) / \u2191p\u230b) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "field_simp", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b + \u230a(a + a\u271d - b) / a\u271d\u230b \u2022 a\u271d = a + \u2191p - Int.fract ((a + \u2191p - b) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}, {"line": "ring", "tactic_state": "p : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 b + \u230a(a + a\u271d - b) / a\u271d\u230b \u2022 a\u271d = a + \u2191p - Int.fract ((a + \u2191p - b) / \u2191p) * \u2191p\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\np : \u2115\nhp' : Fact (0 < p)\n\u03b1 : Type u_2\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : FloorRing \u03b1\na\u271d : \u03b1\nhp : 0 < a\u271d\na b : \u03b1\n\u22a2 FloorRing \u03b1"}]}
{"declaration": "theorem iUnion_Ioc_add_intCast : \u22c3 n : \u2124, Ioc (a + n) (a + n + 1) = Set.univ := by\n  simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Ioc_add_zsmul zero_lt_one a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\na : \u03b1\n\u22a2 \u22c3 n, Ioc (a + \u2191n) (a + \u2191n + 1) = univ"}, {"line": "simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Ioc_add_zsmul zero_lt_one a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ico_add_intCast : \u22c3 n : \u2124, Ico (a + n) (a + n + 1) = Set.univ := by\n  simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Ico_add_zsmul zero_lt_one a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\na : \u03b1\n\u22a2 \u22c3 n, Ico (a + \u2191n) (a + \u2191n + 1) = univ"}, {"line": "simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Ico_add_zsmul zero_lt_one a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Icc_add_intCast : \u22c3 n : \u2124, Icc (a + n) (a + n + 1) = Set.univ := by\n  simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Icc_add_zsmul zero_lt_one a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\na : \u03b1\n\u22a2 \u22c3 n, Icc (a + \u2191n) (a + \u2191n + 1) = univ"}, {"line": "simpa only [zsmul_one, Int.cast_add, Int.cast_one, \u2190 add_assoc] using\n    iUnion_Icc_add_zsmul zero_lt_one a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ioc_intCast : \u22c3 n : \u2124, Ioc (n : \u03b1) (n + 1) = Set.univ := by\n  simpa only [zero_add] using iUnion_Ioc_add_intCast (0 : \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\n\u22a2 \u22c3 n, Ioc (\u2191n) (\u2191n + 1) = univ"}, {"line": "simpa only [zero_add] using iUnion_Ioc_add_intCast (0 : \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Ico_intCast : \u22c3 n : \u2124, Ico (n : \u03b1) (n + 1) = Set.univ := by\n  simpa only [zero_add] using iUnion_Ico_add_intCast (0 : \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\n\u22a2 \u22c3 n, Ico (\u2191n) (\u2191n + 1) = univ"}, {"line": "simpa only [zero_add] using iUnion_Ico_add_intCast (0 : \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_Icc_intCast : \u22c3 n : \u2124, Icc (n : \u03b1) (n + 1) = Set.univ := by\n  simpa only [zero_add] using iUnion_Icc_add_intCast (0 : \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/ToIntervalMod.lean", "context": {"open": ["List in", "AddCommGroup", "AddCommGroup", "AddCommGroup", "Set Int"], "variables": ["{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [h\u03b1 : Archimedean \u03b1]", "(a b)", "{a b}", "[hp' : Fact (0 < p)]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Archimedean \u03b1]", "{\u03b1 : Type*} [Ring \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Archimedean \u03b1] (a : \u03b1)", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b3 : Ring \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\n\u22a2 \u22c3 n, Icc (\u2191n) (\u2191n + 1) = univ"}, {"line": "simpa only [zero_add] using iUnion_Icc_add_intCast (0 : \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_le_add (a b : R) : abv (a - b) \u2264 abv a + abv b := by\n  simpa only [\u2190 sub_eq_add_neg, AbsoluteValue.map_neg] using abv.add_le a (-b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AbsoluteValue/Basic.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 R S : Type*}", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Ring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "[IsDomain S] [Nontrivial R]", "{R S : Type*} [Ring R] [Ring S] [PartialOrder S] [IsOrderedRing S]", "[CommRing S] [PartialOrder S] [IsOrderedRing S] [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u271d : Type u_9\nS : Type u_10\ninst\u271d\u2076 : Semiring R\u271d\ninst\u271d\u2075 : Semiring S\ninst\u271d\u2074 : PartialOrder S\nabv : AbsoluteValue R\u271d S\ninst\u271d\u00b3 : IsDomain S\ninst\u271d\u00b2 : Nontrivial R\u271d\nR : Type u_11\ninst\u271d\u00b9 inst\u271d : Ring R\na b : R\n\u22a2 abv sorry \u2264 abv sorry + abv sorry"}, {"line": "simpa only [\u2190 sub_eq_add_neg, AbsoluteValue.map_neg] using abv.add_le a (-b)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma apply_natAbs_eq (x : \u2124) : abv (natAbs x) = abv x := by\n  obtain \u27e8_, rfl | rfl\u27e9 := Int.eq_nat_or_neg x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AbsoluteValue/Basic.lean", "context": {"open": ["Int in"], "variables": ["{\u03b9 \u03b1 R S : Type*}", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Ring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "[IsDomain S] [Nontrivial R]", "{R S : Type*} [Ring R] [Ring S] [PartialOrder S] [IsOrderedRing S]", "[CommRing S] [PartialOrder S] [IsOrderedRing S] [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\nS : Type u_6\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : Semiring S\ninst\u271d\u00b2 : PartialOrder S\nabv : AbsoluteValue R S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : Nontrivial R\nx\u271d : Sort u_9\nnatAbs : x\u271d\nx : \u2124\n\u22a2 abv sorry = abv sorry"}, {"line": "obtain \u27e8_, rfl | rfl\u27e9 := Int.eq_nat_or_neg x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_on_nat_iff_eq_on_int {f g : AbsoluteValue R S} :\n    (\u2200 n : \u2115 , f n = g n) \u2194 \u2200 n : \u2124 , f n = g n := by\n  refine \u27e8fun h z \u21a6 ?_, fun a n \u21a6 mod_cast a n\u27e9\n  obtain \u27e8n , rfl | rfl\u27e9 := Int.eq_nat_or_neg z <;> simp [h n]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AbsoluteValue/Basic.lean", "context": {"open": ["Int in", "Int in"], "variables": ["{\u03b9 \u03b1 R S : Type*}", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Ring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "[IsDomain S] [Nontrivial R]", "{R S : Type*} [Ring R] [Ring S] [PartialOrder S] [IsOrderedRing S]", "[CommRing S] [PartialOrder S] [IsOrderedRing S] [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\nS : Type u_8\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : Ring S\ninst\u271d\u2075 : PartialOrder S\ninst\u271d\u2074 : IsOrderedRing S\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : PartialOrder S\ninst\u271d\u00b9 : IsOrderedRing S\ninst\u271d : Ring R\nf g : AbsoluteValue R S\n\u22a2 (\u2200 (n : \u2115), f \u2191n = g \u2191n) \u2194 \u2200 (n : \u2124), f \u2191n = g \u2191n"}, {"line": "refine \u27e8fun h z \u21a6 ?_, fun a n \u21a6 mod_cast a n\u27e9", "tactic_state": "R : Type u_7\nS : Type u_8\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : Ring S\ninst\u271d\u2075 : PartialOrder S\ninst\u271d\u2074 : IsOrderedRing S\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : PartialOrder S\ninst\u271d\u00b9 : IsOrderedRing S\ninst\u271d : Ring R\nf g : AbsoluteValue R S\nh : \u2200 (n : \u2115), f \u2191n = g \u2191n\nz : \u2124\n\u22a2 f \u2191z = g \u2191z"}, {"line": "obtain \u27e8n , rfl | rfl\u27e9 := Int.eq_nat_or_neg z <;> simp [h n]", "tactic_state": "case intro.inr\nR : Type u_7\nS : Type u_8\ninst\u271d\u2077 : Ring R\ninst\u271d\u2076 : Ring S\ninst\u271d\u2075 : PartialOrder S\ninst\u271d\u2074 : IsOrderedRing S\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : PartialOrder S\ninst\u271d\u00b9 : IsOrderedRing S\ninst\u271d : Ring R\nf g : AbsoluteValue R S\nh : \u2200 (n : \u2115), f \u2191n = g \u2191n\nn : \u2115\n\u22a2 f (-\u2191n) = g (-\u2191n)"}]}
{"declaration": "theorem abv_sub_le (a b c : R) : abv (a - c) \u2264 abv (a - b) + abv (b - c) := by\n  simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/AbsoluteValue/Basic.lean", "context": {"open": ["Int in", "Int in", "Lean Meta Mathlib Meta Positivity Qq in"], "variables": ["{\u03b9 \u03b1 R S : Type*}", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Ring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "{R S : Type*} [Semiring R] [Semiring S] [PartialOrder S] (abv : AbsoluteValue R S)", "[IsDomain S] [Nontrivial R]", "{R S : Type*} [Ring R] [Ring S] [PartialOrder S] [IsOrderedRing S]", "[CommRing S] [PartialOrder S] [IsOrderedRing S] [Ring R]", "{R S : Type*} [Semiring R] [Ring S] [LinearOrder S] [IsStrictOrderedRing S]", "{R S : Type*} [Ring R] [CommRing S] [LinearOrder S] [IsStrictOrderedRing S]", "{R : Type*} [Semiring R] [DecidablePred fun x : R \u21a6 x = 0] [NoZeroDivisors R]", "{S : Type*} [Semiring S] [PartialOrder S] [IsOrderedRing S] [Nontrivial S]", "{R : Type*} [Semiring R] {S : Type*} [Semiring S] [PartialOrder S] [IsOrderedRing S]", "[Field R] [Semifield S] [LinearOrder S] [IsStrictOrderedRing S] [ExistsAddOfLE S]", "{S : Type*} [Semiring S] [PartialOrder S]", "{R : Type*} [Semiring R] (abv : R \u2192 S) [IsAbsoluteValue abv]", "{S : Type*} [Ring S] [LinearOrder S] [IsStrictOrderedRing S]", "{S : Type*} [Ring S] [PartialOrder S]", "{R : Type*} [Semiring R] (abv : R \u2192 S) [IsAbsoluteValue abv]", "[IsDomain S]", "{R : Type*} [Ring R] (abv : R \u2192 S) [IsAbsoluteValue abv]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_20\ninst\u271d\u2074 : Ring S\ninst\u271d\u00b3 : PartialOrder S\ninst\u271d\u00b2 : IsDomain S\nR : Type u_22\ninst\u271d\u00b9 : Ring R\nabv : R \u2192 S\ninst\u271d : IsAbsoluteValue abv\na b c : R\n\u22a2 abv (a - c) \u2264 abv (a - b) + abv (b - c)"}, {"line": "simpa [sub_eq_add_neg, add_assoc] using abv_add abv (a - b) (b - c)", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem card_finMulAntidiag_pi (d n : \u2115) (hn : Squarefree n) :\n    #(n.primeFactors.pi fun _ => (univ : Finset <| Fin d)) =\n      #(finMulAntidiag d n) := by\n  apply Finset.card_bij (Nat.primeFactorsPiBij d n) (primeFactorsPiBij_img d n hn)\n    (primeFactorsPiBij_inj d n) (primeFactorsPiBij_surj d n hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Antidiag/Nat.lean", "context": {"open": ["Finset", "scoped BigOperators ArithmeticFunction"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfinMulAntidiag : x\u271d\nd n : \u2115\nhn : Squarefree n\n\u22a2 (n.primeFactors.pi fun x => univ).card = sorry.card"}, {"line": "apply Finset.card_bij (Nat.primeFactorsPiBij d n) (primeFactorsPiBij_img d n hn)\n    (primeFactorsPiBij_inj d n) (primeFactorsPiBij_surj d n hn)", "tactic_state": "\u22a2 {finMulAntidiag : ?m.571} \u2192 \u2115 \u2192 (n : \u2115) \u2192 Squarefree n \u2192 Type u_2"}]}
{"declaration": "theorem existsUnique_zpow_near_of_one_lt' {a : G} (ha : 1 < a) (g : G) :\n    \u2203! k : \u2124, 1 \u2264 g / a ^ k \u2227 g / a ^ k < a := by\n  simpa only [one_le_div', zpow_add_one, div_lt_iff_lt_mul'] using\n    existsUnique_zpow_near_of_one_lt ha g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Archimedean/Basic.lean", "context": {"open": ["Int Set"], "variables": ["{G M R K : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] [MulArchimedean G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\na : G\nha : 1 < a\ng : G\n\u22a2 \u2203! k, 1 \u2264 g / a ^ k \u2227 g / a ^ k < a"}, {"line": "simpa only [one_le_div', zpow_add_one, div_lt_iff_lt_mul'] using\n    existsUnique_zpow_near_of_one_lt ha g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem existsUnique_div_zpow_mem_Ico {a : G} (ha : 1 < a) (b c : G) :\n    \u2203! m : \u2124, b / a ^ m \u2208 Set.Ico c (c * a) := by\n  simpa only [mem_Ico, le_div_iff_mul_le, one_mul, mul_comm c, div_lt_iff_lt_mul, mul_assoc] using\n    existsUnique_zpow_near_of_one_lt' ha (b / c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Archimedean/Basic.lean", "context": {"open": ["Int Set"], "variables": ["{G M R K : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] [MulArchimedean G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\na : G\nha : 1 < a\nb c : G\n\u22a2 \u2203! m, b / a ^ m \u2208 Ico c (c * a)"}, {"line": "simpa only [mem_Ico, le_div_iff_mul_le, one_mul, mul_comm c, div_lt_iff_lt_mul, mul_assoc] using\n    existsUnique_zpow_near_of_one_lt' ha (b / c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pos_rat_lt {x : K} (x0 : 0 < x) : \u2203 q : \u211a, 0 < q \u2227 (q : K) < x := by\n  simpa only [Rat.cast_pos] using exists_rat_btwn x0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Archimedean/Basic.lean", "context": {"open": ["Int Set"], "variables": ["{G M R K : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] [MulArchimedean G]", "[Semiring R] [PartialOrder R] [IsOrderedRing R] [Archimedean R]", "[Semiring R] [PartialOrder R] [IsStrictOrderedRing R] [Archimedean R] {y : R}", "[Ring R] [PartialOrder R] [IsOrderedRing R] [Archimedean R]", "[Ring R] [PartialOrder R] [IsStrictOrderedRing R] [Archimedean R]", "[Semiring R] [LinearOrder R] [IsStrictOrderedRing R] [Archimedean R] [ExistsAddOfLE R]", "[Semifield K] [LinearOrder K] [IsStrictOrderedRing K] [Archimedean K] {x y \u03b5 : K}", "[ExistsAddOfLE K]", "[Field K] [LinearOrder K] [IsStrictOrderedRing K]", "[Archimedean K] {x y \u03b5 : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\ninst\u271d\u2078 : Semifield K\ninst\u271d\u2077 : LinearOrder K\ninst\u271d\u2076 : IsStrictOrderedRing K\ninst\u271d\u2075 : Archimedean K\ninst\u271d\u2074 : ExistsAddOfLE K\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : Archimedean K\nx : K\nx0 : 0 < x\n\u22a2 \u2203 q, 0 < q \u2227 \u2191q < x"}, {"line": "simpa only [Rat.cast_pos] using exists_rat_btwn x0", "tactic_state": "No Goals!"}]}
{"declaration": "lemma expect_eq_zero_iff_of_nonneg (hs : s.Nonempty) (hf : \u2200 i \u2208 s, 0 \u2264 f i) :\n    \ud835\udd3c i \u2208 s, f i = 0 \u2194 \u2200 i \u2208 s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, hs.ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\nhs : s.Nonempty\nhf : \u2200 i \u2208 s, 0 \u2264 sorry\n\u22a2 (s.expect fun i => sorry) = 0 \u2194 \u2200 i \u2208 s, sorry = 0"}, {"line": "simp [expect, sum_eq_zero_iff_of_nonneg hf, hs.ne_empty]", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\nhs : s.Nonempty\nhf : \u2200 i \u2208 s, 0 \u2264 sorry\n\u22a2 (s.expect fun i => sorry ()) = 0 \u2194 \u2200 i \u2208 s, sorry () = 0"}]}
{"declaration": "lemma expect_eq_zero_iff_of_nonpos (hs : s.Nonempty) (hf : \u2200 i \u2208 s, f i \u2264 0) :\n    \ud835\udd3c i \u2208 s, f i = 0 \u2194 \u2200 i \u2208 s, f i = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, hs.ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\nhs : s.Nonempty\nhf : \u2200 i \u2208 s, sorry \u2264 0\n\u22a2 (s.expect fun i => sorry) = 0 \u2194 \u2200 i \u2208 s, sorry = 0"}, {"line": "simp [expect, sum_eq_zero_iff_of_nonpos hf, hs.ne_empty]", "tactic_state": "\u03b1\u271d : Type u_4\ns : Finset \u03b1\u271d\nx\u271d : Sort u_5\nf : x\u271d\nhs : s.Nonempty\nhf : \u2200 i \u2208 s, sorry \u2264 0\n\u22a2 (s.expect fun i => sorry ()) = 0 \u2194 \u2200 i \u2208 s, sorry () = 0"}]}
{"declaration": "lemma expect_eq_zero_iff_of_nonneg [Nonempty \u03b9] (hf : 0 \u2264 f) : \ud835\udd3c i, f i = 0 \u2194 f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonneg hf, univ_nonempty.ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2078 : PartialOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b9\u2076 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2075 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2077 : Module \u211a\u22650 \u03b1\ninst\u271d\u2076 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9 : Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d : Nonempty \u03b9\nhf : 0 \u2264 f\n\u22a2 (univ.expect fun i => f i) = 0 \u2194 f = 0"}, {"line": "simp [expect, sum_eq_zero_iff_of_nonneg hf, univ_nonempty.ne_empty]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2078 : PartialOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b9\u2076 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2075 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2077 : Module \u211a\u22650 \u03b1\ninst\u271d\u2076 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9 : Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d : Nonempty \u03b9\nhf : 0 \u2264 f\n\u22a2 (\u2191(Fintype.card \u03b9))\u207b\u00b9 \u2022 \u2211 x, f x = 0 \u2194 f = 0"}]}
{"declaration": "lemma expect_eq_zero_iff_of_nonpos [Nonempty \u03b9] (hf : f \u2264 0) : \ud835\udd3c i, f i = 0 \u2194 f = 0 := by\n  simp [expect, sum_eq_zero_iff_of_nonpos hf, univ_nonempty.ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2078 : PartialOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b9\u2076 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2075 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2077 : Module \u211a\u22650 \u03b1\ninst\u271d\u2076 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9 : Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d : Nonempty \u03b9\nhf : f \u2264 0\n\u22a2 (univ.expect fun i => f i) = 0 \u2194 f = 0"}, {"line": "simp [expect, sum_eq_zero_iff_of_nonpos hf, univ_nonempty.ne_empty]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2078 : PartialOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b9\u2076 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2075 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2077 : Module \u211a\u22650 \u03b1\ninst\u271d\u2076 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2075 : Fintype \u03b9\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9 : Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d : Nonempty \u03b9\nhf : f \u2264 0\n\u22a2 (\u2191(Fintype.card \u03b9))\u207b\u00b9 \u2022 \u2211 x, f x = 0 \u2194 f = 0"}]}
{"declaration": "example (n : \u2115) (a : \u2115 \u2192 \u211a) : 0 \u2264 \ud835\udd3c j \u2208 range n, a j^2 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset", "Finset", "Qq Lean Meta Finset", "scoped BigOperators"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\ninst\u271d\u00b3\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2079 : PartialOrder \u03b1\ninst\u271d\u00b2\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u2077 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2076 : PosSMulMono \u211a\u22650 \u03b1\na\u271d : \u03b1\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b2\u2075 : AddCommMonoid M\ninst\u271d\u00b2\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b2\u2070 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u2075 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : ExistsAddOfLE R\ninst\u271d\u2075 : _root_.Module \u211a\u22650 R\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : _root_.Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 \u2264 (range n).expect fun j => a j ^ 2"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : ULift.{2} \u2115 \u2192 \u211a) (s : Finset (ULift.{2} \u2115)) : 0 \u2264 \ud835\udd3c j \u2208 s, a j^2 := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset", "Finset", "Qq Lean Meta Finset", "scoped BigOperators"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\ninst\u271d\u00b3\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2079 : PartialOrder \u03b1\ninst\u271d\u00b2\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u2077 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2076 : PosSMulMono \u211a\u22650 \u03b1\na\u271d : \u03b1\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b2\u2075 : AddCommMonoid M\ninst\u271d\u00b2\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b2\u2070 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u2075 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : ExistsAddOfLE R\ninst\u271d\u2075 : _root_.Module \u211a\u22650 R\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : _root_.Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\na : ULift.{2, 0} \u2115 \u2192 \u211a\ns : Finset (ULift.{2, 0} \u2115)\n\u22a2 0 \u2264 s.expect fun j => a j ^ 2"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) (a : \u2115 \u2192 \u211a) : 0 \u2264 \ud835\udd3c j : Fin 8, \ud835\udd3c i \u2208 range n, (a j^2 + i ^ 2) := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset", "Finset", "Qq Lean Meta Finset", "scoped BigOperators"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\ninst\u271d\u00b3\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2079 : PartialOrder \u03b1\ninst\u271d\u00b2\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u2077 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2076 : PosSMulMono \u211a\u22650 \u03b1\na\u271d : \u03b1\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b2\u2075 : AddCommMonoid M\ninst\u271d\u00b2\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b2\u2070 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u2075 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : ExistsAddOfLE R\ninst\u271d\u2075 : _root_.Module \u211a\u22650 R\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : _root_.Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 \u2264 univ.expect fun j => (range n).expect fun i => a \u2191j ^ 2 + \u2191i ^ 2"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) (a : \u2115 \u2192 \u211a) : 0 < \ud835\udd3c j : Fin (n + 1), (a j^2 + 1) := by positivity", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset", "Finset", "Qq Lean Meta Finset", "scoped BigOperators"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\ninst\u271d\u00b3\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2079 : PartialOrder \u03b1\ninst\u271d\u00b2\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u2077 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2076 : PosSMulMono \u211a\u22650 \u03b1\na\u271d : \u03b1\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b2\u2075 : AddCommMonoid M\ninst\u271d\u00b2\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b2\u2070 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u2075 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : ExistsAddOfLE R\ninst\u271d\u2075 : _root_.Module \u211a\u22650 R\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : _root_.Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\nn : \u2115\na : \u2115 \u2192 \u211a\n\u22a2 0 < univ.expect fun j => a \u2191j ^ 2 + 1"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "example (a : \u2115 \u2192 \u211a) : 0 < \ud835\udd3c j \u2208 ({1} : Finset \u2115), (a j^2 + 1) := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Expect.lean", "context": {"open": ["Function", "Fintype (card)", "scoped BigOperators Pointwise NNRat", "Finset", "Finset", "Qq Lean Meta Finset", "scoped BigOperators"], "variables": ["{\u03b9 \u03b1 R : Type*}", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulMono \u211a\u22650 \u03b1] {a : \u03b1}", "{M N : Type*} [AddCommMonoid M] [Module \u211a\u22650 M]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[PosSMulStrictMono \u211a\u22650 \u03b1]", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] [PosSMulMono \u211a\u22650 \u03b1]", "[CommSemiring R] [LinearOrder R] [IsStrictOrderedRing R] [ExistsAddOfLE R] [Module \u211a\u22650 R]", "[Fintype \u03b9]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] [Module \u211a\u22650 \u03b1] {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\nR : Type u_3\ninst\u271d\u00b3\u2070 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2079 : PartialOrder \u03b1\ninst\u271d\u00b2\u2078 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2\u2077 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b2\u2076 : PosSMulMono \u211a\u22650 \u03b1\na\u271d : \u03b1\nM : Type u_4\nN : Type u_5\ninst\u271d\u00b2\u2075 : AddCommMonoid M\ninst\u271d\u00b2\u2074 : _root_.Module \u211a\u22650 M\ninst\u271d\u00b2\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : IsOrderedCancelAddMonoid \u03b1\ninst\u271d\u00b2\u2070 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2079 : PosSMulStrictMono \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2078 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2077 : LinearOrder \u03b1\ninst\u271d\u00b9\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u2075 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2074 : AddCommGroup \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b9\u00b9 : _root_.Module \u211a\u22650 \u03b1\ninst\u271d\u00b9\u2070 : PosSMulMono \u211a\u22650 \u03b1\ninst\u271d\u2079 : CommSemiring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : ExistsAddOfLE R\ninst\u271d\u2075 : _root_.Module \u211a\u22650 R\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : IsOrderedAddMonoid \u03b1\ninst\u271d : _root_.Module \u211a\u22650 \u03b1\nf : \u03b9 \u2192 \u03b1\na : \u2115 \u2192 \u211a\n\u22a2 0 < {1}.expect fun j => a j ^ 2 + 1"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_le_pow_card (s : Multiset \u03b1) (n : \u03b1) (h : \u2200 x \u2208 s, x \u2264 n) : s.prod \u2264 n ^ card s := by\n  induction s using Quotient.inductionOn\n  simpa using List.prod_le_pow_card _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s t : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_4\ncard : x\u271d\ns : Multiset \u03b1\nn : \u03b1\nh : \u2200 x \u2208 s, x \u2264 n\n\u22a2 s.prod \u2264 n ^ sorry"}, {"line": "induction s using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_4\ncard : x\u271d\nn : \u03b1\na\u271d : List \u03b1\nh : \u2200 x \u2208 \u27e6a\u271d\u27e7, x \u2264 n\n\u22a2 Multiset.prod \u27e6a\u271d\u27e7 \u2264 n ^ sorry"}, {"line": "simpa using List.prod_le_pow_card _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_lt_prod' (hle : \u2200 i \u2208 s, f i \u2264 g i) (hlt : \u2203 i \u2208 s, f i < g i) :\n    (s.map f).prod < (s.map g).prod := by\n  obtain \u27e8l\u27e9 := s\n  simp only [Multiset.quot_mk_to_coe'']\n  simp only [Multiset.map_coe]\n  simp only [Multiset.prod_coe]\n  exact List.prod_lt_prod' f g hle hlt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s t : Multiset \u03b1} {a : \u03b1}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedMonoid \u03b2]", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\nhle : \u2200 i \u2208 s, f i \u2264 g i\nhlt : \u2203 i \u2208 s, f i < g i\n\u22a2 (Multiset.map f s).prod < (Multiset.map g s).prod"}, {"line": "obtain \u27e8l\u27e9 := s", "tactic_state": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\nl : List \u03b9\nhle : \u2200 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i \u2264 g i\nhlt : \u2203 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i < g i\n\u22a2 (Multiset.map f (Quot.mk (\u21d1(List.isSetoid \u03b9)) l)).prod < (Multiset.map g (Quot.mk (\u21d1(List.isSetoid \u03b9)) l)).prod"}, {"line": "simp only [Multiset.quot_mk_to_coe'']", "tactic_state": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\nl : List \u03b9\nhle : \u2200 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i \u2264 g i\nhlt : \u2203 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i < g i\n\u22a2 (Multiset.map f \u2191l).prod < (Multiset.map g \u2191l).prod"}, {"line": "simp only [Multiset.map_coe]", "tactic_state": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\nl : List \u03b9\nhle : \u2200 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i \u2264 g i\nhlt : \u2203 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i < g i\n\u22a2 (\u2191(List.map f l)).prod < (\u2191(List.map g l)).prod"}, {"line": "simp only [Multiset.prod_coe]", "tactic_state": "case mk\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedCancelMonoid \u03b1\ns : Multiset \u03b9\nf g : \u03b9 \u2192 \u03b1\nl : List \u03b9\nhle : \u2200 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i \u2264 g i\nhlt : \u2203 i \u2208 Quot.mk (\u21d1(List.isSetoid \u03b9)) l, f i < g i\n\u22a2 (List.map f l).prod < (List.map g l).prod"}, {"line": "exact List.prod_lt_prod' f g hle hlt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma max_le_of_forall_le {\u03b1 : Type*} [LinearOrder \u03b1] [OrderBot \u03b1] (l : Multiset \u03b1)\n    (n : \u03b1) (h : \u2200 x \u2208 l, x \u2264 n) : l.fold max \u22a5 \u2264 n := by\n  induction l using Quotient.inductionOn\n  simpa using List.max_le_of_forall_le _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Multiset.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s t : Multiset \u03b1} {a : \u03b1}", "[CommMonoid \u03b1] [CommMonoid \u03b2] [PartialOrder \u03b2] [IsOrderedMonoid \u03b2]", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedCancelMonoid \u03b1] {s : Multiset \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [CanonicallyOrderedMul \u03b1] {m : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\nl : Multiset \u03b1\nn : \u03b1\nh : \u2200 x \u2208 l, x \u2264 n\n\u22a2 Multiset.fold max \u22a5 l \u2264 n"}, {"line": "induction l using Quotient.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_4\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : OrderBot \u03b1\nn : \u03b1\na\u271d : List \u03b1\nh : \u2200 x \u2208 \u27e6a\u271d\u27e7, x \u2264 n\n\u22a2 Multiset.fold max \u22a5 \u27e6a\u271d\u27e7 \u2264 n"}, {"line": "simpa using List.max_le_of_forall_le _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mulLECancellable_prod :\n    MulLECancellable (\u220f i \u2208 s, f i) \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 MulLECancellable (f i) := by\n  induction' s using Finset.cons_induction with i s hi ih <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N G k R : Type*}", "[CommMonoid M] [CommMonoid N] [PartialOrder N] [IsOrderedMonoid N]", "{f g : \u03b9 \u2192 N} {s t : Finset \u03b9}", "{\u03b9' : Type*} [DecidableEq \u03b9']", "[CommMonoid \u03b1] [LE \u03b1] [MulLeftMono \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 MulLECancellable (\u220f i \u2208 s, f i) \u2194 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 MulLECancellable (f i)"}, {"line": "induction' s using Finset.cons_induction with i s hi ih <;> simp [*]", "tactic_state": "case cons\n\u03b9 : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\ns\u271d : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\ni : \u03b9\ns : Finset \u03b9\nhi : i \u2209 s\nih : MulLECancellable (\u220f i \u2208 s, f i) \u2194 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 MulLECancellable (f i)\n\u22a2 MulLECancellable (f i * \u220f i \u2208 s, f i) \u2194 MulLECancellable (f i) \u2227 \u2200 a \u2208 s, MulLECancellable (f a)"}]}
{"declaration": "theorem prod_eq_prod_iff_of_le {f g : \u03b9 \u2192 M} (h : \u2200 i \u2208 s, f i \u2264 g i) :\n    ((\u220f i \u2208 s, f i) = \u220f i \u2208 s, g i) \u2194 \u2200 i \u2208 s, f i = g i := by\n  classical\n    revert h\n    refine Finset.induction_on s (fun _ \u21a6 \u27e8fun _ _ h \u21a6 False.elim (Finset.not_mem_empty _ h),\n      fun _ \u21a6 rfl\u27e9) fun a s ha ih H \u21a6 ?_\n    specialize ih fun i \u21a6 H i \u2218 Finset.mem_insert_of_mem\n    rw [Finset.prod_insert ha]\n    rw [Finset.prod_insert ha]\n    rw [Finset.forall_mem_insert]\n    rw [\u2190 ih]\n    exact\n      mul_eq_mul_iff_eq_and_eq (H a (s.mem_insert_self a))\n        (Finset.prod_le_prod' fun i \u21a6 H i \u2218 Finset.mem_insert_of_mem)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N G k R : Type*}", "[CommMonoid M] [CommMonoid N] [PartialOrder N] [IsOrderedMonoid N]", "{f g : \u03b9 \u2192 N} {s t : Finset \u03b9}", "{\u03b9' : Type*} [DecidableEq \u03b9']", "[CommMonoid \u03b1] [LE \u03b1] [MulLeftMono \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[DecidableEq \u03b2]", "[DecidableEq \u03b1] {s : Finset \u03b1} {B : Finset (Finset \u03b1)} {n : \u2115}", "[CommMonoid M] [PartialOrder M] [IsOrderedMonoid M] [CanonicallyOrderedMul M]", "[CommMonoid M] [PartialOrder M] [IsOrderedCancelMonoid M] {f g : \u03b9 \u2192 M} {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u2077 inst\u271d\u2076 : CommMonoid M\ninst\u271d\u2075 : PartialOrder M\ninst\u271d\u2074 : IsOrderedMonoid M\ninst\u271d\u00b3 : CanonicallyOrderedMul M\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : PartialOrder M\ninst\u271d : IsOrderedCancelMonoid M\ns : Finset \u03b9\nf g : \u03b9 \u2192 M\nh : \u2200 i \u2208 s, f i \u2264 g i\n\u22a2 \u220f i \u2208 s, f i = \u220f i \u2208 s, g i \u2194 \u2200 i \u2208 s, f i = g i"}, {"line": "classical\n    revert h\n    refine Finset.induction_on s (fun _ \u21a6 \u27e8fun _ _ h \u21a6 False.elim (Finset.not_mem_empty _ h),\n      fun _ \u21a6 rfl\u27e9) fun a s ha ih H \u21a6 ?_\n    specialize ih fun i \u21a6 H i \u2218 Finset.mem_insert_of_mem\n    rw [Finset.prod_insert ha]\n    rw [Finset.prod_insert ha]\n    rw [Finset.forall_mem_insert]\n    rw [\u2190 ih]\n    exact\n      mul_eq_mul_iff_eq_and_eq (H a (s.mem_insert_self a))\n        (Finset.prod_le_prod' fun i \u21a6 H i \u2218 Finset.mem_insert_of_mem)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_lt_of_prod_lt' (Hlt : \u220f i \u2208 s, f i < \u220f i \u2208 s, g i) : \u2203 i \u2208 s, f i < g i := by\n  contrapose! Hlt with Hle\n  exact prod_le_prod' Hle\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N G k R : Type*}", "[CommMonoid M] [CommMonoid N] [PartialOrder N] [IsOrderedMonoid N]", "{f g : \u03b9 \u2192 N} {s t : Finset \u03b9}", "{\u03b9' : Type*} [DecidableEq \u03b9']", "[CommMonoid \u03b1] [LE \u03b1] [MulLeftMono \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[DecidableEq \u03b2]", "[DecidableEq \u03b1] {s : Finset \u03b1} {B : Finset (Finset \u03b1)} {n : \u2115}", "[CommMonoid M] [PartialOrder M] [IsOrderedMonoid M] [CanonicallyOrderedMul M]", "[CommMonoid M] [PartialOrder M] [IsOrderedCancelMonoid M] {f g : \u03b9 \u2192 M} {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "[CommMonoid M] [LinearOrder M] [IsOrderedCancelMonoid M] {f g : \u03b9 \u2192 M} {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : CommMonoid M\ninst\u271d\u2079 : PartialOrder M\ninst\u271d\u2078 : IsOrderedMonoid M\ninst\u271d\u2077 : CanonicallyOrderedMul M\ninst\u271d\u2076 : CommMonoid M\ninst\u271d\u2075 : PartialOrder M\ninst\u271d\u2074 : IsOrderedCancelMonoid M\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : LinearOrder M\ninst\u271d : IsOrderedCancelMonoid M\nf g : \u03b9 \u2192 M\ns : Finset \u03b9\nHlt : \u220f i \u2208 s, f i < \u220f i \u2208 s, g i\n\u22a2 \u2203 i \u2208 s, f i < g i"}, {"line": "contrapose! Hlt with Hle", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : CommMonoid M\ninst\u271d\u2079 : PartialOrder M\ninst\u271d\u2078 : IsOrderedMonoid M\ninst\u271d\u2077 : CanonicallyOrderedMul M\ninst\u271d\u2076 : CommMonoid M\ninst\u271d\u2075 : PartialOrder M\ninst\u271d\u2074 : IsOrderedCancelMonoid M\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : LinearOrder M\ninst\u271d : IsOrderedCancelMonoid M\nf g : \u03b9 \u2192 M\ns : Finset \u03b9\nHle : \u2200 i \u2208 s, \u00acf i < g i\n\u22a2 \u00ac\u220f i \u2208 s, f i < \u220f i \u2208 s, g i"}, {"line": "exact prod_le_prod' Hle", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_le_of_prod_le' (hs : s.Nonempty) (Hle : \u220f i \u2208 s, f i \u2264 \u220f i \u2208 s, g i) :\n    \u2203 i \u2208 s, f i \u2264 g i := by\n  contrapose! Hle with Hlt\n  exact prod_lt_prod_of_nonempty' hs Hlt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/Finset.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 \u03b1 \u03b2 M N G k R : Type*}", "[CommMonoid M] [CommMonoid N] [PartialOrder N] [IsOrderedMonoid N]", "{f g : \u03b9 \u2192 N} {s t : Finset \u03b9}", "{\u03b9' : Type*} [DecidableEq \u03b9']", "[CommMonoid \u03b1] [LE \u03b1] [MulLeftMono \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}", "[DecidableEq \u03b2]", "[DecidableEq \u03b1] {s : Finset \u03b1} {B : Finset (Finset \u03b1)} {n : \u2115}", "[CommMonoid M] [PartialOrder M] [IsOrderedMonoid M] [CanonicallyOrderedMul M]", "[CommMonoid M] [PartialOrder M] [IsOrderedCancelMonoid M] {f g : \u03b9 \u2192 M} {s t : Finset \u03b9}", "[DecidableEq \u03b9]", "[CommMonoid M] [LinearOrder M] [IsOrderedCancelMonoid M] {f g : \u03b9 \u2192 M} {s t : Finset \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : CommMonoid M\ninst\u271d\u2079 : PartialOrder M\ninst\u271d\u2078 : IsOrderedMonoid M\ninst\u271d\u2077 : CanonicallyOrderedMul M\ninst\u271d\u2076 : CommMonoid M\ninst\u271d\u2075 : PartialOrder M\ninst\u271d\u2074 : IsOrderedCancelMonoid M\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : LinearOrder M\ninst\u271d : IsOrderedCancelMonoid M\nf g : \u03b9 \u2192 M\ns : Finset \u03b9\nhs : s.Nonempty\nHle : \u220f i \u2208 s, f i \u2264 \u220f i \u2208 s, g i\n\u22a2 \u2203 i \u2208 s, f i \u2264 g i"}, {"line": "contrapose! Hle with Hlt", "tactic_state": "\u03b9 : Type u_1\nM : Type u_4\ninst\u271d\u00b9\u00b9 inst\u271d\u00b9\u2070 : CommMonoid M\ninst\u271d\u2079 : PartialOrder M\ninst\u271d\u2078 : IsOrderedMonoid M\ninst\u271d\u2077 : CanonicallyOrderedMul M\ninst\u271d\u2076 : CommMonoid M\ninst\u271d\u2075 : PartialOrder M\ninst\u271d\u2074 : IsOrderedCancelMonoid M\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : LinearOrder M\ninst\u271d : IsOrderedCancelMonoid M\nf g : \u03b9 \u2192 M\ns : Finset \u03b9\nhs : s.Nonempty\nHlt : \u2200 i \u2208 s, \u00acf i \u2264 g i\n\u22a2 \u00ac\u220f i \u2208 s, f i \u2264 \u220f i \u2208 s, g i"}, {"line": "exact prod_lt_prod_of_nonempty' hs Hlt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prod_le_pow_card [Preorder M] [MulRightMono M]\n    [MulLeftMono M] (l : List M) (n : M) (h : \u2200 x \u2208 l, x \u2264 n) :\n    l.prod \u2264 n ^ l.length := by\n  simpa only [map_id', map_const', prod_replicate] using prod_le_prod' h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/List.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 M N : Type*}", "[Monoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : Preorder M\ninst\u271d\u00b9 : MulRightMono M\ninst\u271d : MulLeftMono M\nl : List M\nn : M\nh : \u2200 x \u2208 l, x \u2264 n\n\u22a2 l.prod \u2264 n ^ l.length"}, {"line": "simpa only [map_id', map_const', prod_replicate] using prod_le_prod' h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_lt_of_prod_lt' [LinearOrder M] [MulRightMono M]\n    [MulLeftMono M] {l : List \u03b9} (f g : \u03b9 \u2192 M)\n    (h : (l.map f).prod < (l.map g).prod) : \u2203 i \u2208 l, f i < g i := by\n  contrapose! h\n  exact prod_le_prod' h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/List.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 M N : Type*}", "[Monoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : LinearOrder M\ninst\u271d\u00b9 : MulRightMono M\ninst\u271d : MulLeftMono M\nl : List \u03b9\nf g : \u03b9 \u2192 M\nh : (List.map f l).prod < (List.map g l).prod\n\u22a2 \u2203 i \u2208 l, f i < g i"}, {"line": "contrapose! h", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : LinearOrder M\ninst\u271d\u00b9 : MulRightMono M\ninst\u271d : MulLeftMono M\nl : List \u03b9\nf g : \u03b9 \u2192 M\nh : \u2200 i \u2208 l, \u00acf i < g i\n\u22a2 \u00ac(List.map f l).prod < (List.map g l).prod"}, {"line": "exact prod_le_prod' h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_le_of_prod_le' [LinearOrder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List \u03b9} (hl : l \u2260 []) (f g : \u03b9 \u2192 M)\n    (h : (l.map f).prod \u2264 (l.map g).prod) : \u2203 x \u2208 l, f x \u2264 g x := by\n  contrapose! h\n  exact prod_lt_prod_of_ne_nil hl _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/List.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 M N : Type*}", "[Monoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : LinearOrder M\ninst\u271d\u00b3 : MulLeftStrictMono M\ninst\u271d\u00b2 : MulLeftMono M\ninst\u271d\u00b9 : MulRightStrictMono M\ninst\u271d : MulRightMono M\nl : List \u03b9\nhl : l \u2260 []\nf g : \u03b9 \u2192 M\nh : (List.map f l).prod \u2264 (List.map g l).prod\n\u22a2 \u2203 x \u2208 l, f x \u2264 g x"}, {"line": "contrapose! h", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : LinearOrder M\ninst\u271d\u00b3 : MulLeftStrictMono M\ninst\u271d\u00b2 : MulLeftMono M\ninst\u271d\u00b9 : MulRightStrictMono M\ninst\u271d : MulRightMono M\nl : List \u03b9\nhl : l \u2260 []\nf g : \u03b9 \u2192 M\nh : \u2200 x \u2208 l, \u00acf x \u2264 g x\n\u22a2 \u00ac(List.map f l).prod \u2264 (List.map g l).prod"}, {"line": "exact prod_lt_prod_of_ne_nil hl _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_le_foldr_max [AddZeroClass M] [Zero N] [LinearOrder N] (f : M \u2192 N) (h0 : f 0 \u2264 0)\n    (hadd : \u2200 x y, f (x + y) \u2264 max (f x) (f y)) (l : List M) : f l.sum \u2264 (l.map f).foldr max 0 := by\n  induction' l with hd tl IH\n  \u00b7 simpa using h0\n  simp only [List.sum_cons] at IH \u22a2\n  simp only [List.foldr_map] at IH \u22a2\n  simp only [List.foldr] at IH \u22a2\n  exact (hadd _ _).trans (max_le_max le_rfl IH)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Group/List.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 M N : Type*}", "[Monoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nl : List M\n\u22a2 f l.sum \u2264 List.foldr max 0 (List.map f l)"}, {"line": "induction' l with hd tl IH", "tactic_state": "case nil\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\n\u22a2 f [].sum \u2264 List.foldr max 0 (List.map f [])\n---\ncase cons\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nhd : M\ntl : List M\nIH : f tl.sum \u2264 List.foldr max 0 (List.map f tl)\n\u22a2 f (hd :: tl).sum \u2264 List.foldr max 0 (List.map f (hd :: tl))"}, {"line": "\u00b7 simpa using h0", "tactic_state": "case cons\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nhd : M\ntl : List M\nIH : f tl.sum \u2264 List.foldr max 0 (List.map f tl)\n\u22a2 f (hd :: tl).sum \u2264 List.foldr max 0 (List.map f (hd :: tl))"}, {"line": "simp only [List.sum_cons] at IH \u22a2", "tactic_state": "case cons\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nhd : M\ntl : List M\nIH : f tl.sum \u2264 List.foldr max 0 (List.map f tl)\n\u22a2 f (hd + tl.sum) \u2264 List.foldr max 0 (List.map f (hd :: tl))"}, {"line": "simp only [List.foldr_map] at IH \u22a2", "tactic_state": "case cons\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nhd : M\ntl : List M\nIH : f tl.sum \u2264 List.foldr (fun x y => max (f x) y) 0 tl\n\u22a2 f (hd + tl.sum) \u2264 List.foldr (fun x y => max (f x) y) 0 (hd :: tl)"}, {"line": "simp only [List.foldr] at IH \u22a2", "tactic_state": "case cons\nM : Type u_3\nN : Type u_4\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : AddZeroClass M\ninst\u271d\u00b9 : Zero N\ninst\u271d : LinearOrder N\nf : M \u2192 N\nh0 : f 0 \u2264 0\nhadd : \u2200 (x y : M), f (x + y) \u2264 max (f x) (f y)\nhd : M\ntl : List M\nIH : f tl.sum \u2264 List.foldr (fun x y => max (f x) y) 0 tl\n\u22a2 f (hd + tl.sum) \u2264 max (f hd) (List.foldr (fun x y => max (f x) y) 0 tl)"}, {"line": "exact (hadd _ _).trans (max_le_max le_rfl IH)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma CanonicallyOrderedAdd.multiset_prod_pos {R : Type*}\n    [CommSemiring R] [PartialOrder R] [CanonicallyOrderedAdd R] [NoZeroDivisors R] [Nontrivial R]\n    {m : Multiset R} : 0 < m.prod \u2194 \u2200 x \u2208 m, 0 < x := by\n  rcases m with \u27e8l\u27e9\n  rw [Multiset.quot_mk_to_coe'']\n  rw [Multiset.prod_coe]\n  exact CanonicallyOrderedAdd.list_prod_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/BigOperators/Ring/Multiset.lean", "context": {"open": ["Multiset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : CanonicallyOrderedAdd R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nm : Multiset R\n\u22a2 0 < m.prod \u2194 \u2200 x \u2208 m, 0 < x"}, {"line": "rcases m with \u27e8l\u27e9", "tactic_state": "case mk\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : CanonicallyOrderedAdd R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < prod (Quot.mk (\u21d1(List.isSetoid R)) l) \u2194 \u2200 x \u2208 Quot.mk (\u21d1(List.isSetoid R)) l, 0 < x"}, {"line": "rw [Multiset.quot_mk_to_coe'']", "tactic_state": "case mk\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : CanonicallyOrderedAdd R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < (\u2191l).prod \u2194 \u2200 x \u2208 \u2191l, 0 < x"}, {"line": "rw [Multiset.prod_coe]", "tactic_state": "case mk\nR : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : CanonicallyOrderedAdd R\ninst\u271d\u00b9 : NoZeroDivisors R\ninst\u271d : Nontrivial R\nm : Multiset R\nl : List R\n\u22a2 0 < l.prod \u2194 \u2200 x \u2208 \u2191l, 0 < x"}, {"line": "exact CanonicallyOrderedAdd.list_prod_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_limZero {f g : CauSeq \u03b2 abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f - g) := by\n  simpa only [sub_eq_add_neg] using add_limZero hf (neg_limZero hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nx\u271d : Sort u_3\nLimZero : x\u271d\nf g : CauSeq \u03b2 abv\nhf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_eq_add_neg] using add_limZero hf (neg_limZero hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem limZero_sub_rev {f g : CauSeq \u03b2 abv} (hfg : LimZero (f - g)) : LimZero (g - f) := by\n  simpa using neg_limZero hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nx\u271d : Sort u_3\nLimZero : x\u271d\nf g : CauSeq \u03b2 abv\nhfg : sorry\n\u22a2 sorry"}, {"line": "simpa using neg_limZero hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_equiv_add {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 + g1 \u2248 f2 + g2 := by simpa only [\u2190 add_sub_add_comm] using add_limZero hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nhg : g1 \u2248 g2\n\u22a2 f1 + g1 \u2248 f2 + g2"}, {"line": "simpa only [\u2190 add_sub_add_comm] using add_limZero hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_equiv_neg {f g : CauSeq \u03b2 abv} (hf : f \u2248 g) : -f \u2248 -g := by\n  simpa only [neg_sub'] using neg_limZero hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf g : CauSeq \u03b2 abv\nhf : f \u2248 g\n\u22a2 -f \u2248 -g"}, {"line": "simpa only [neg_sub'] using neg_limZero hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_equiv_sub {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 - g1 \u2248 f2 - g2 := by simpa only [sub_eq_add_neg] using add_equiv_add hf (neg_equiv_neg hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nhg : g1 \u2248 g2\n\u22a2 f1 - g1 \u2248 f2 - g2"}, {"line": "simpa only [sub_eq_add_neg] using add_equiv_add hf (neg_equiv_neg hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_equiv_mul {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 * g1 \u2248 f2 * g2 := by\n  simpa only [mul_sub, sub_mul, sub_add_sub_cancel]\n    using add_limZero (mul_limZero_left g1 hf) (mul_limZero_right f2 hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b2 : Field \u03b1\ninst\u271d\u00b9\u00b9 : LinearOrder \u03b1\ninst\u271d\u00b9\u2070 : IsStrictOrderedRing \u03b1\ninst\u271d\u2079 : Ring \u03b2\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Ring \u03b2\ninst\u271d\u2074 : Field \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq \u03b2 abv\nhf : f1 \u2248 f2\nhg : g1 \u2248 g2\n\u22a2 f1 * g1 \u2248 f2 * g2"}, {"line": "simpa only [mul_sub, sub_mul, sub_add_sub_cancel]\n    using add_limZero (mul_limZero_left g1 hf) (mul_limZero_right f2 hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_equiv_smul {G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2] {f1 f2 : CauSeq \u03b2 abv} (c : G)\n    (hf : f1 \u2248 f2) : c \u2022 f1 \u2248 c \u2022 f2 := by\n  simpa [const_smul, smul_one_mul _ _] using\n    mul_equiv_mul (const_equiv.mpr <| Eq.refl <| c \u2022 (1 : \u03b2)) hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2074 : Field \u03b1\ninst\u271d\u00b9\u00b3 : LinearOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b9\u00b9 : Ring \u03b2\ninst\u271d\u00b9\u2070 : Field \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsStrictOrderedRing \u03b1\ninst\u271d\u2077 : Ring \u03b2\ninst\u271d\u2076 : Field \u03b1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b3 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b2 : IsAbsoluteValue abv\nG : Type u_3\ninst\u271d\u00b9 : SMul G \u03b2\ninst\u271d : IsScalarTower G \u03b2 \u03b2\nf1 f2 : CauSeq \u03b2 abv\nc : G\nhf : f1 \u2248 f2\n\u22a2 c \u2022 f1 \u2248 c \u2022 f2"}, {"line": "simpa [const_smul, smul_one_mul _ _] using\n    mul_equiv_mul (const_equiv.mpr <| Eq.refl <| c \u2022 (1 : \u03b2)) hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sup_equiv_sup {a\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs} (ha : a\u2081 \u2248 a\u2082) (hb : b\u2081 \u2248 b\u2082) :\n    a\u2081 \u2294 b\u2081 \u2248 a\u2082 \u2294 b\u2082 := by\n  intro \u03b5 \u03b50\n  obtain \u27e8ai, hai\u27e9 := ha \u03b5 \u03b50\n  obtain \u27e8bi, hbi\u27e9 := hb \u03b5 \u03b50\n  exact\n    \u27e8ai \u2294 bi, fun i hi =>\n      (abs_max_sub_max_le_max (a\u2081 i) (b\u2081 i) (a\u2082 i) (b\u2082 i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]", "[Ring \u03b2] [IsDomain \u03b2] (abv : \u03b2 \u2192 \u03b1) [IsAbsoluteValue abv]", "[DivisionRing \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u22a2 a\u2081 \u2294 b\u2081 \u2248 a\u2082 \u2294 b\u2082"}, {"line": "intro \u03b5 \u03b50", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2294 b\u2081 - a\u2082 \u2294 b\u2082) j| < \u03b5"}, {"line": "obtain \u27e8ai, hai\u27e9 := ha \u03b5 \u03b50", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\nai : \u2115\nhai : \u2200 j \u2265 ai, |\u2191(a\u2081 - a\u2082) j| < \u03b5\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2294 b\u2081 - a\u2082 \u2294 b\u2082) j| < \u03b5"}, {"line": "obtain \u27e8bi, hbi\u27e9 := hb \u03b5 \u03b50", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\nai : \u2115\nhai : \u2200 j \u2265 ai, |\u2191(a\u2081 - a\u2082) j| < \u03b5\nbi : \u2115\nhbi : \u2200 j \u2265 bi, |\u2191(b\u2081 - b\u2082) j| < \u03b5\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2294 b\u2081 - a\u2082 \u2294 b\u2082) j| < \u03b5"}, {"line": "exact\n    \u27e8ai \u2294 bi, fun i hi =>\n      (abs_max_sub_max_le_max (a\u2081 i) (b\u2081 i) (a\u2082 i) (b\u2082 i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inf_equiv_inf {a\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs} (ha : a\u2081 \u2248 a\u2082) (hb : b\u2081 \u2248 b\u2082) :\n    a\u2081 \u2293 b\u2081 \u2248 a\u2082 \u2293 b\u2082 := by\n  intro \u03b5 \u03b50\n  obtain \u27e8ai, hai\u27e9 := ha \u03b5 \u03b50\n  obtain \u27e8bi, hbi\u27e9 := hb \u03b5 \u03b50\n  exact\n    \u27e8ai \u2294 bi, fun i hi =>\n      (abs_min_sub_min_le_max (a\u2081 i) (b\u2081 i) (a\u2082 i) (b\u2082 i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Basic.lean", "context": {"open": ["IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "[Ring \u03b2] {abv : \u03b2 \u2192 \u03b1}", "[IsAbsoluteValue abv]", "(abv) in", "{G : Type*} [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2]", "[Ring \u03b2] [IsDomain \u03b2] (abv : \u03b2 \u2192 \u03b1) [IsAbsoluteValue abv]", "[DivisionRing \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u22a2 a\u2081 \u2293 b\u2081 \u2248 a\u2082 \u2293 b\u2082"}, {"line": "intro \u03b5 \u03b50", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2293 b\u2081 - a\u2082 \u2293 b\u2082) j| < \u03b5"}, {"line": "obtain \u27e8ai, hai\u27e9 := ha \u03b5 \u03b50", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\nai : \u2115\nhai : \u2200 j \u2265 ai, |\u2191(a\u2081 - a\u2082) j| < \u03b5\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2293 b\u2081 - a\u2082 \u2293 b\u2082) j| < \u03b5"}, {"line": "obtain \u27e8bi, hbi\u27e9 := hb \u03b5 \u03b50", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d\u2078 : Field \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsStrictOrderedRing \u03b1\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs\nha : a\u2081 \u2248 a\u2082\nhb : b\u2081 \u2248 b\u2082\n\u03b5 : \u03b1\n\u03b50 : \u03b5 > 0\nai : \u2115\nhai : \u2200 j \u2265 ai, |\u2191(a\u2081 - a\u2082) j| < \u03b5\nbi : \u2115\nhbi : \u2200 j \u2265 bi, |\u2191(b\u2081 - b\u2082) j| < \u03b5\n\u22a2 \u2203 i, \u2200 j \u2265 i, |\u2191(a\u2081 \u2293 b\u2081 - a\u2082 \u2293 b\u2082) j| < \u03b5"}, {"line": "exact\n    \u27e8ai \u2294 bi, fun i hi =>\n      (abs_min_sub_min_le_max (a\u2081 i) (b\u2081 i) (a\u2082 i) (b\u2082 i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma geo_series_const (a : \u03b1) {x : \u03b1} (hx1 : |x| < 1) :\n    IsCauSeq abs fun m \u21a6 \u2211 n \u2208 range m, (a * x ^ n) := by\n  simpa [mul_sum, Pi.mul_def] using (const a).mul (geo_series x hx1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/BigOperators.lean", "context": {"open": ["Finset IsAbsoluteValue"], "variables": ["{\u03b1 \u03b2 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [Ring \u03b2]", "[Archimedean \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Field \u03b1\ninst\u271d\u00b2 : LinearOrder \u03b1\ninst\u271d\u00b9 : IsStrictOrderedRing \u03b1\ninst\u271d : Archimedean \u03b1\na x : \u03b1\nhx1 : |x| < 1\n\u22a2 IsCauSeq abs fun m => \u2211 n \u2208 range m, a * x ^ n"}, {"line": "simpa [mul_sum, Pi.mul_def] using (const a).mul (geo_series x hx1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lim_mul (f : CauSeq \u03b2 abv) (x : \u03b2) : lim f * x = lim (f * const abv x) := by\n  rw [\u2190 lim_mul_lim]\n  rw [lim_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/CauSeq/Completion.lean", "context": {"open": ["CauSeq", "Classical in"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "{\u03b2 : Type*} [Ring \u03b2] (abv : \u03b2 \u2192 \u03b1) [IsAbsoluteValue abv]", "{abv}", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "{\u03b2 : Type*} [CommRing \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "{\u03b2 : Type*} [DivisionRing \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "{\u03b2 : Type*} [Field \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]", "{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]", "(\u03b2 : Type*) [Ring \u03b2] (abv : \u03b2 \u2192 \u03b1) [IsAbsoluteValue abv]", "{\u03b2 : Type*} [Ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [IsAbsoluteValue abv]", "[IsComplete \u03b2 abv]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\ninst\u271d : CauSeq.IsComplete \u03b2 abv\nf : CauSeq \u03b2 abv\nx : \u03b2\n\u22a2 f.lim * x = (f * const abv x).lim"}, {"line": "rw [\u2190 lim_mul_lim]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d\u2075 : Field \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\n\u03b2 : Type u_9\ninst\u271d\u00b2 : Ring \u03b2\nabv : \u03b2 \u2192 \u03b1\ninst\u271d\u00b9 : IsAbsoluteValue abv\ninst\u271d : CauSeq.IsComplete \u03b2 abv\nf : CauSeq \u03b2 abv\nx : \u03b2\n\u22a2 f.lim * x = f.lim * (const abv x).lim"}, {"line": "rw [lim_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_pow_le_one_div_pow_of_le (a1 : 1 \u2264 a) {m n : \u2115} (mn : m \u2264 n) :\n    1 / a ^ n \u2264 1 / a ^ m := by\n  refine (one_div_le_one_div ?_ ?_).mpr (pow_right_mono\u2080 a1 mn) <;>\n    exact pow_pos (zero_lt_one.trans_le a1) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Semifield \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\na1 : 1 \u2264 a\nm n : \u2115\nmn : m \u2264 n\n\u22a2 1 / a ^ n \u2264 1 / a ^ m"}, {"line": "refine (one_div_le_one_div ?_ ?_).mpr (pow_right_mono\u2080 a1 mn) <;>\n    exact pow_pos (zero_lt_one.trans_le a1) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_pow_lt_one_div_pow_of_lt (a1 : 1 < a) {m n : \u2115} (mn : m < n) :\n    1 / a ^ n < 1 / a ^ m := by\n  refine (one_div_lt_one_div ?_ ?_).2 (pow_lt_pow_right\u2080 a1 mn) <;>\n    exact pow_pos (zero_lt_one.trans a1) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Semifield \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\na1 : 1 < a\nm n : \u2115\nmn : m < n\n\u22a2 1 / a ^ n < 1 / a ^ m"}, {"line": "refine (one_div_lt_one_div ?_ ?_).2 (pow_lt_pow_right\u2080 a1 mn) <;>\n    exact pow_pos (zero_lt_one.trans a1) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsGLB.mul_right {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsGLB s b) :\n    IsGLB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : Semifield \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\ns : Set \u03b1\nha : 0 \u2264 a\nhs : IsGLB s b\n\u22a2 IsGLB ((fun b => b * a) '' s) (b * a)"}, {"line": "simpa [mul_comm] using hs.mul_left ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_neg_iff : a / b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b := by\n  simp [division_def, mul_neg_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 a / b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b"}, {"line": "simp [division_def, mul_neg_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 a * b\u207b\u00b9 < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b"}]}
{"declaration": "theorem div_nonneg_iff : 0 \u2264 a / b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0 := by\n  simp [division_def, mul_nonneg_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 0 \u2264 a / b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0"}, {"line": "simp [division_def, mul_nonneg_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 0 \u2264 a * b\u207b\u00b9 \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0"}]}
{"declaration": "theorem div_nonpos_iff : a / b \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b := by\n  simp [division_def, mul_nonpos_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 a / b \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b"}, {"line": "simp [division_def, mul_nonpos_iff]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\n\u22a2 a * b\u207b\u00b9 \u2264 0 \u2194 0 \u2264 a \u2227 b \u2264 0 \u2228 a \u2264 0 \u2227 0 \u2264 b"}]}
{"declaration": "theorem div_le_one_of_ge (h : b \u2264 a) (hb : b \u2264 0) : a / b \u2264 1 := by\n  simpa only [neg_div_neg_eq] using div_le_one_of_le\u2080 (neg_le_neg h) (neg_nonneg_of_nonpos hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nh : b \u2264 a\nhb : b \u2264 0\n\u22a2 a / b \u2264 1"}, {"line": "simpa only [neg_div_neg_eq] using div_le_one_of_le\u2080 (neg_le_neg h) (neg_nonneg_of_nonpos hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_inv_antitoneOn_Icc_right (ha : c < a) :\n    AntitoneOn (fun x \u21a6 (x-c)\u207b\u00b9) (Set.Icc a b) := by\n  by_cases hab : a \u2264 b\n  \u00b7 exact sub_inv_antitoneOn_Ioi.mono <| (Set.Icc_subset_Ioi_iff hab).mpr ha\n  \u00b7 simp [hab, Set.Subsingleton.antitoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : c < a\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "by_cases hab : a \u2264 b", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : c < a\nhab : sorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : c < a\nhab : \u00acsorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "\u00b7 exact sub_inv_antitoneOn_Ioi.mono <| (Set.Icc_subset_Ioi_iff hab).mpr ha", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : c < a\nhab : \u00acsorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "\u00b7 simp [hab, Set.Subsingleton.antitoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_inv_antitoneOn_Icc_left (ha : b < c) :\n    AntitoneOn (fun x \u21a6 (x-c)\u207b\u00b9) (Set.Icc a b) := by\n  by_cases hab : a \u2264 b\n  \u00b7 exact sub_inv_antitoneOn_Iio.mono <| (Set.Icc_subset_Iio_iff hab).mpr ha\n  \u00b7 simp [hab, Set.Subsingleton.antitoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : b < c\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "by_cases hab : a \u2264 b", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : b < c\nhab : sorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : b < c\nhab : \u00acsorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "\u00b7 exact sub_inv_antitoneOn_Iio.mono <| (Set.Icc_subset_Iio_iff hab).mpr ha", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\nha : b < c\nhab : \u00acsorry\n\u22a2 AntitoneOn (fun x => (x - c)\u207b\u00b9) (Set.Icc a b)"}, {"line": "\u00b7 simp [hab, Set.Subsingleton.antitoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_le_of_neg (ha : a < 0) (hb : b < 0) : 1 / a \u2264 b \u2194 1 / b \u2264 a := by\n  simpa using inv_le_of_neg ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nha : a < 0\nhb : b < 0\n\u22a2 1 / a \u2264 b \u2194 1 / b \u2264 a"}, {"line": "simpa using inv_le_of_neg ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_lt_of_neg (ha : a < 0) (hb : b < 0) : 1 / a < b \u2194 1 / b < a := by\n  simpa using inv_lt_of_neg ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nha : a < 0\nhb : b < 0\n\u22a2 1 / a < b \u2194 1 / b < a"}, {"line": "simpa using inv_lt_of_neg ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_one_div_of_neg (ha : a < 0) (hb : b < 0) : a \u2264 1 / b \u2194 b \u2264 1 / a := by\n  simpa using le_inv_of_neg ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nha : a < 0\nhb : b < 0\n\u22a2 a \u2264 1 / b \u2194 b \u2264 1 / a"}, {"line": "simpa using le_inv_of_neg ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_one_div_of_neg (ha : a < 0) (hb : b < 0) : a < 1 / b \u2194 b < 1 / a := by\n  simpa using lt_inv_of_neg ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nha : a < 0\nhb : b < 0\n\u22a2 a < 1 / b \u2194 b < 1 / a"}, {"line": "simpa using lt_inv_of_neg ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_le_one_div_of_neg (ha : a < 0) (hb : b < 0) : 1 / a \u2264 1 / b \u2194 b \u2264 a := by\n  simpa [one_div] using inv_le_inv_of_neg ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nha : a < 0\nhb : b < 0\n\u22a2 1 / a \u2264 1 / b \u2194 b \u2264 a"}, {"line": "simpa [one_div] using inv_le_inv_of_neg ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_two_sub_self (a : \u03b1) : a / 2 - a = -(a / 2) := by\n  suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this\n  rw [sub_add_eq_sub_sub]\n  rw [sub_self]\n  rw [zero_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 a / 2 - a = -(a / 2)"}, {"line": "suffices a / 2 - (a / 2 + a / 2) = -(a / 2) by rwa [add_halves] at this", "tactic_state": "case refine_5\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 a / 2 - (a / 2 + a / 2) = -(a / 2)\n---\ncase refine_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_2\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_3\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_4\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124"}, {"line": "rw [sub_add_eq_sub_sub]", "tactic_state": "case refine_5\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 a / 2 - a / 2 - a / 2 = -(a / 2)\n---\ncase refine_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_2\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_3\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_4\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124"}, {"line": "rw [sub_self]", "tactic_state": "case refine_5\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 0 - a / 2 = -(a / 2)\n---\ncase refine_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_3\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_4\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124"}, {"line": "rw [zero_sub]", "tactic_state": "case refine_1\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124\n---\ncase refine_4\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 HDiv \u03b1 \u2115 \u2124"}]}
{"declaration": "theorem IsLUB.mul_right {s : Set \u03b1} (ha : 0 \u2264 a) (hs : IsLUB s b) :\n    IsLUB ((fun b => b * a) '' s) (b * a) := by simpa [mul_comm] using hs.mul_left ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\ns : Set \u03b1\nha : 0 \u2264 a\nhs : IsLUB s b\n\u22a2 IsLUB ((fun b => b * a) '' s) (b * a)"}, {"line": "simpa [mul_comm] using hs.mul_left ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_one_div (a : \u03b1) : |1 / a| = 1 / |a| := by rw [abs_div, abs_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Basic.lean", "context": {"open": ["Function OrderDual"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "[Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d e : \u03b1} {m n : \u2124}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b c d : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 |1 / a| = 1 / |a|"}, {"line": "rw [abs_div, abs_one]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1\n---\n\u03b1 : Type u_2\ninst\u271d\u2075 : Semifield \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsStrictOrderedRing \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\n\u22a2 IsStrictOrderedRing \u03b1"}]}
{"declaration": "lemma zpow_eq_zpow_iff_cases\u2080 : a ^ n = b ^ n \u2194 n = 0 \u2228 a = b \u2228 a = -b \u2227 Even n := by\n  rcases eq_or_ne n 0 with rfl | hn <;> simp [zpow_eq_zpow_iff_of_ne_zero\u2080, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Power.lean", "context": {"open": ["Function Int"], "variables": ["{\u03b1 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nn : \u2124\n\u22a2 a ^ n = b ^ n \u2194 n = 0 \u2228 a = b \u2228 a = -b \u2227 Even n"}, {"line": "rcases eq_or_ne n 0 with rfl | hn <;> simp [zpow_eq_zpow_iff_of_ne_zero\u2080, *]", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b : \u03b1\nn : \u2124\nhn : n \u2260 0\n\u22a2 a ^ n = b ^ n \u2194 a = b \u2228 a = -b \u2227 Even n"}]}
{"declaration": "lemma zpow_eq_neg_one_iff\u2080 : a ^ n = -1 \u2194 a = -1 \u2227 Odd n := by\n  simpa using zpow_eq_neg_zpow_iff\u2080 (\u03b1 := \u03b1) one_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Field/Power.lean", "context": {"open": ["Function Int"], "variables": ["{\u03b1 : Type*}", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a b : \u03b1} {n : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na : \u03b1\nn : \u2124\n\u22a2 a ^ n = -1 \u2194 a = -1 \u2227 Odd n"}, {"line": "simpa using zpow_eq_neg_zpow_iff\u2080 (\u03b1 := \u03b1) one_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma floorDiv_zero (b : \u03b2) : b \u230a/\u230b (0 : \u03b1) = 0 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Div.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2) [AddCommMonoid \u03b1] [PartialOrder \u03b1] [AddCommMonoid \u03b2] [PartialOrder \u03b2]", "{\u03b1 \u03b2}", "[FloorDiv \u03b1 \u03b2] {a : \u03b1} {b c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : PartialOrder \u03b2\nb : \u03b2\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : PartialOrder \u03b2\nb : \u03b2\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma ceilDiv_zero (b : \u03b2) : b \u2308/\u2309 (0 : \u03b1) = 0 := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Div.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2) [AddCommMonoid \u03b1] [PartialOrder \u03b1] [AddCommMonoid \u03b2] [PartialOrder \u03b2]", "{\u03b1 \u03b2}", "[FloorDiv \u03b1 \u03b2] {a : \u03b1} {b c : \u03b2}", "[CeilDiv \u03b1 \u03b2] {a : \u03b1} {b c : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : PartialOrder \u03b2\nb : \u03b2\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : PartialOrder \u03b2\nb : \u03b2\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma support_ceilDiv_subset : (f \u2308/\u2309 a).support \u2286 f.support := by\n  simp +contextual [Finset.subset_iff, not_imp_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Div.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "(\u03b1 \u03b2) [AddCommMonoid \u03b1] [PartialOrder \u03b1] [AddCommMonoid \u03b2] [PartialOrder \u03b2]", "{\u03b1 \u03b2}", "[FloorDiv \u03b1 \u03b2] {a : \u03b1} {b c : \u03b2}", "[CeilDiv \u03b1 \u03b2] {a : \u03b1} {b c : \u03b2}", "[AddCommMonoid \u03b1] [LinearOrder \u03b1] [AddCommMonoid \u03b2] [PartialOrder \u03b2] [SMulZeroClass \u03b1 \u03b2]", "[Semiring \u03b1] [PartialOrder \u03b1] [AddCommMonoid \u03b2] [PartialOrder \u03b2] [MulActionWithZero \u03b1 \u03b2]", "[FloorDiv \u03b1 \u03b2] {a : \u03b1}", "[CeilDiv \u03b1 \u03b2] {a : \u03b1}", "[FloorDiv \u03b1 \u03b1] {a b c : \u03b1}", "[CeilDiv \u03b1 \u03b1] {a b c : \u03b1}", "{\u03c0 : \u03b9 \u2192 Type*} [AddCommMonoid \u03b1] [PartialOrder \u03b1]", "[\u2200 i, FloorDiv \u03b1 (\u03c0 i)]", "[\u2200 i, CeilDiv \u03b1 (\u03c0 i)]", "[AddCommMonoid \u03b1] [PartialOrder \u03b1]", "[FloorDiv \u03b1 \u03b2] {f : \u03b9 \u2192\u2080 \u03b2} {a : \u03b1}", "[CeilDiv \u03b1 \u03b2] {f : \u03b9 \u2192\u2080 \u03b2} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b2\u00b9 : AddCommMonoid \u03b1\ninst\u271d\u00b2\u2070 : PartialOrder \u03b1\ninst\u271d\u00b9\u2079 : AddCommMonoid \u03b2\ninst\u271d\u00b9\u2078 : PartialOrder \u03b2\ninst\u271d\u00b9\u2077 : AddCommMonoid \u03b1\ninst\u271d\u00b9\u2076 : LinearOrder \u03b1\ninst\u271d\u00b9\u2075 : AddCommMonoid \u03b2\ninst\u271d\u00b9\u2074 : PartialOrder \u03b2\ninst\u271d\u00b9\u00b3 : SMulZeroClass \u03b1 \u03b2\ninst\u271d\u00b9\u00b2 : Semiring \u03b1\ninst\u271d\u00b9\u00b9 : PartialOrder \u03b1\ninst\u271d\u00b9\u2070 : AddCommMonoid \u03b2\ninst\u271d\u2079 : PartialOrder \u03b2\ninst\u271d\u2078 : MulActionWithZero \u03b1 \u03b2\ninst\u271d\u2077 : FloorDiv \u03b1 \u03b2\ninst\u271d\u2076 : CeilDiv \u03b1 \u03b2\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : FloorDiv \u03b1 \u03b2\ninst\u271d : CeilDiv \u03b1 \u03b2\nf : \u03b9 \u2192\u2080 \u03b2\na : \u03b1\n\u22a2 (f \u2308/\u2309 a).support \u2286 f.support"}, {"line": "simp +contextual [Finset.subset_iff, not_imp_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_floor_add_one (a : R) : a < \u230aa\u230b + 1 := by\n  simpa only [Int.succ, Int.cast_add, Int.cast_one] using lt_succ_floor a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : FloorRing R\na : R\n\u22a2 a < \u2191\u230aa\u230b + 1"}, {"line": "simpa only [Int.succ, Int.cast_add, Int.cast_one] using lt_succ_floor a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem floor_eq_zero_iff : \u230aa\u230b = 0 \u2194 a \u2208 Ico (0 : R) 1 := by simp [floor_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : LinearOrder R\ninst\u271d : FloorRing R\na : R\n\u22a2 \u230aa\u230b = 0 \u2194 a \u2208 Ico 0 1"}, {"line": "simp [floor_eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem floor_intCast_add (z : \u2124) (a : R) : \u230a\u2191z + a\u230b = z + \u230aa\u230b := by\n  simpa only [add_comm] using floor_add_intCast a z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorRing R\ninst\u271d : IsStrictOrderedRing R\nz : \u2124\na : R\n\u22a2 \u230a\u2191z + a\u230b = z + \u230aa\u230b"}, {"line": "simpa only [add_comm] using floor_add_intCast a z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma floor_eq_self_iff_mem (a : R) : \u230aa\u230b = a \u2194 a \u2208 Set.range Int.cast := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorRing R\ninst\u271d : IsStrictOrderedRing R\na : R\n\u22a2 \u2191\u230aa\u230b = a \u2194 a \u2208 range Int.cast"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fract_one : fract (1 : R) = 0 := by simp [fract]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nfract : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [fract]", "tactic_state": "x\u271d : Sort u_4\nfract : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem fract_natCast (n : \u2115) : fract (n : R) = 0 := by simp [fract]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nfract : x\u271d\nn : \u2115\n\u22a2 sorry = 0"}, {"line": "simp [fract]", "tactic_state": "x\u271d : Sort u_4\nfract : x\u271d\nn : \u2115\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem ceil_nonneg_of_neg_one_lt (ha : -1 < a) : 0 \u2264 \u2308a\u2309 := by\n  rwa [Int.le_ceil_iff, Int.cast_zero, zero_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorRing R\na : R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\nha : -1 < a\n\u22a2 0 \u2264 \u2308a\u2309"}, {"line": "rwa [Int.le_ceil_iff, Int.cast_zero, zero_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ceil_eq_zero_iff : \u2308a\u2309 = 0 \u2194 a \u2208 Ioc (-1 : R) 0 := by simp [ceil_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2074 : Ring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorRing R\na : R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\n\u22a2 \u2308a\u2309 = 0 \u2194 a \u2208 Ioc (-1) 0"}, {"line": "simp [ceil_eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ceil_eq_self_iff_mem (a : R) : \u2308a\u2309 = a \u2194 a \u2208 Set.range Int.cast := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\n\u22a2 \u2191\u2308a\u2309 = a \u2194 a \u2208 range Int.cast"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ceil_eq_floor_add_one_iff_not_mem (a : R) : \u2308a\u2309 = \u230aa\u230b + 1 \u2194 a \u2209 Set.range Int.cast := by\n  refine \u27e8fun h ht => ?_, fun h => ?_\u27e9\n  \u00b7 have := ((floor_eq_self_iff_mem _).mpr ht).trans ((ceil_eq_self_iff_mem _).mpr ht).symm\n    linarith [Int.cast_inj.mp this]\n  \u00b7 apply le_antisymm (Int.ceil_le_floor_add_one _)\n    rw [Int.add_one_le_ceil_iff]\n    exact lt_of_le_of_ne (Int.floor_le a) ((iff_false_right h).mp (floor_eq_self_iff_mem a))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\n\u22a2 \u2308a\u2309 = \u230aa\u230b + 1 \u2194 a \u2209 range Int.cast"}, {"line": "refine \u27e8fun h ht => ?_, fun h => ?_\u27e9", "tactic_state": "case refine_1\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nh : \u2308a\u2309 = \u230aa\u230b + 1\nht : a \u2208 range Int.cast\n\u22a2 False\n---\ncase refine_2\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nh : a \u2209 range Int.cast\n\u22a2 \u2308a\u2309 = \u230aa\u230b + 1"}, {"line": "\u00b7 have := ((floor_eq_self_iff_mem _).mpr ht).trans ((ceil_eq_self_iff_mem _).mpr ht).symm\n    linarith [Int.cast_inj.mp this]", "tactic_state": "case refine_2\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nh : a \u2209 range Int.cast\n\u22a2 \u2308a\u2309 = \u230aa\u230b + 1"}, {"line": "\u00b7 apply le_antisymm (Int.ceil_le_floor_add_one _)\n    rw [Int.add_one_le_ceil_iff]\n    exact lt_of_le_of_ne (Int.floor_le a) ((iff_false_right h).mp (floor_eq_self_iff_mem a))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Ioo {a b : R} : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Ioo a b = Set.Ioo \u230aa\u230b \u2308b\u2309 := by\n  ext\n  simp [floor_lt, lt_ceil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\n\u22a2 Int.cast \u207b\u00b9' Ioo a b = Ioo \u230aa\u230b \u2308b\u2309"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Ioo a b \u2194 x\u271d \u2208 Ioo \u230aa\u230b \u2308b\u2309"}, {"line": "simp [floor_lt, lt_ceil]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 a < \u2191x\u271d \u2227 \u2191x\u271d < b \u2194 \u230aa\u230b < x\u271d \u2227 x\u271d < \u2308b\u2309"}]}
{"declaration": "theorem preimage_Ico {a b : R} : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309 \u2308b\u2309 := by\n  ext\n  simp [ceil_le, lt_ceil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\n\u22a2 Int.cast \u207b\u00b9' Ico a b = Ico \u2308a\u2309 \u2308b\u2309"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309 \u2308b\u2309"}, {"line": "simp [ceil_le, lt_ceil]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 a \u2264 \u2191x\u271d \u2227 \u2191x\u271d < b \u2194 \u2308a\u2309 \u2264 x\u271d \u2227 x\u271d < \u2308b\u2309"}]}
{"declaration": "theorem preimage_Ioc {a b : R} : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Ioc a b = Set.Ioc \u230aa\u230b \u230ab\u230b := by\n  ext\n  simp [floor_lt, le_floor]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\n\u22a2 Int.cast \u207b\u00b9' Ioc a b = Ioc \u230aa\u230b \u230ab\u230b"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Ioc a b \u2194 x\u271d \u2208 Ioc \u230aa\u230b \u230ab\u230b"}, {"line": "simp [floor_lt, le_floor]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 a < \u2191x\u271d \u2227 \u2191x\u271d \u2264 b \u2194 \u230aa\u230b < x\u271d \u2227 x\u271d \u2264 \u230ab\u230b"}]}
{"declaration": "theorem preimage_Icc {a b : R} : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309 \u230ab\u230b := by\n  ext\n  simp [ceil_le, le_floor]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\n\u22a2 Int.cast \u207b\u00b9' Icc a b = Icc \u2308a\u2309 \u230ab\u230b"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Icc a b \u2194 x\u271d \u2208 Icc \u2308a\u2309 \u230ab\u230b"}, {"line": "simp [ceil_le, le_floor]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2075 : Ring R\ninst\u271d\u2074 : LinearOrder R\ninst\u271d\u00b3 : FloorRing R\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2124\n\u22a2 a \u2264 \u2191x\u271d \u2227 \u2191x\u271d \u2264 b \u2194 \u2308a\u2309 \u2264 x\u271d \u2227 x\u271d \u2264 \u230ab\u230b"}]}
{"declaration": "theorem preimage_Ioi : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Ioi a = Set.Ioi \u230aa\u230b := by\n  ext\n  simp [floor_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\n\u22a2 Int.cast \u207b\u00b9' Ioi sorry = Ioi \u230aa\u230b"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Ioi sorry \u2194 x\u271d \u2208 Ioi \u230aa\u230b"}, {"line": "simp [floor_lt]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 sorry () < \u2191x\u271d \u2194 \u230aa\u230b < x\u271d"}]}
{"declaration": "theorem preimage_Ici : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Ici a = Set.Ici \u2308a\u2309 := by\n  ext\n  simp [ceil_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\n\u22a2 Int.cast \u207b\u00b9' Ici sorry = Ici \u2308a\u2309"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Ici sorry \u2194 x\u271d \u2208 Ici \u2308a\u2309"}, {"line": "simp [ceil_le]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 sorry () \u2264 \u2191x\u271d \u2194 \u2308a\u2309 \u2264 x\u271d"}]}
{"declaration": "theorem preimage_Iio : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Iio a = Set.Iio \u2308a\u2309 := by\n  ext\n  simp [lt_ceil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\n\u22a2 Int.cast \u207b\u00b9' Iio sorry = Iio \u2308a\u2309"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Iio sorry \u2194 x\u271d \u2208 Iio \u2308a\u2309"}, {"line": "simp [lt_ceil]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 \u2191x\u271d < sorry () \u2194 x\u271d < \u2308a\u2309"}]}
{"declaration": "theorem preimage_Iic : ((\u2191) : \u2124 \u2192 R) \u207b\u00b9' Set.Iic a = Set.Iic \u230aa\u230b := by\n  ext\n  simp [le_floor]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\n\u22a2 Int.cast \u207b\u00b9' Iic sorry = Iic \u230aa\u230b"}, {"line": "ext", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 Int.cast \u207b\u00b9' Iic sorry \u2194 x\u271d \u2208 Iic \u230aa\u230b"}, {"line": "simp [le_floor]", "tactic_state": "case h\nR : Type u_2\ninst\u271d\u2079 : Ring R\ninst\u271d\u2078 : LinearOrder R\ninst\u271d\u2077 : FloorRing R\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : IsStrictOrderedRing R\nk : Type u_5\ninst\u271d\u00b3 : Field k\ninst\u271d\u00b2 : LinearOrder k\ninst\u271d\u00b9 : IsStrictOrderedRing k\ninst\u271d : FloorRing k\na : k\nx\u271d : \u2124\n\u22a2 \u2191x\u271d \u2264 sorry () \u2194 x\u271d \u2264 \u230aa\u230b"}]}
{"declaration": "theorem Int.natCast_floor_eq_floor (ha : 0 \u2264 a) : (\u230aa\u230b\u208a : \u2124) = \u230aa\u230b := by\n  rw [\u2190 Int.floor_toNat]\n  rw [Int.toNat_of_nonneg (Int.floor_nonneg.2 ha)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Ring.lean", "context": {"open": ["Set"], "variables": ["{F R S : Type*}", "[Ring R] [LinearOrder R] [FloorRing R] {z : \u2124} {a b : R}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {b : k}", "[IsStrictOrderedRing R]", "{k : Type*} [Field k] [LinearOrder k] [IsStrictOrderedRing k] [FloorRing k] {a b : k}", "[Ring R] [LinearOrder R] [Ring S] [LinearOrder S] [FloorRing R] [FloorRing S]", "[FunLike F R S] [RingHomClass F R S] {a : R} {b : S}", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [FloorRing R]", "{a : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : LinearOrder R\ninst\u271d\u00b9\u2070 : FloorRing R\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : LinearOrder R\ninst\u271d\u2074 : FloorRing R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorRing R\na : R\nha : 0 \u2264 a\n\u22a2 \u2191\u230aa\u230b\u208a = \u230aa\u230b"}, {"line": "rw [\u2190 Int.floor_toNat]", "tactic_state": "R : Type u_2\ninst\u271d\u00b9\u00b2 : Ring R\ninst\u271d\u00b9\u00b9 : LinearOrder R\ninst\u271d\u00b9\u2070 : FloorRing R\ninst\u271d\u2079 inst\u271d\u2078 inst\u271d\u2077 : IsStrictOrderedRing R\ninst\u271d\u2076 : Ring R\ninst\u271d\u2075 : LinearOrder R\ninst\u271d\u2074 : FloorRing R\ninst\u271d\u00b3 : Ring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : IsStrictOrderedRing R\ninst\u271d : FloorRing R\na : R\nha : 0 \u2264 a\n\u22a2 \u2191\u230aa\u230b.toNat = \u230aa\u230b"}, {"line": "rw [Int.toNat_of_nonneg (Int.floor_nonneg.2 ha)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_floor_add_one (a : R) : a < \u230aa\u230b\u208a + 1 := by simpa using lt_succ_floor a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\ninst\u271d : IsStrictOrderedRing R\na : R\n\u22a2 a < \u2191\u230aa\u230b\u208a + 1"}, {"line": "simpa using lt_succ_floor a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_le_ceil_iff : n + 1 \u2264 \u2308a\u2309\u208a \u2194 (n : R) < a := by\n  rw [\u2190 Nat.lt_ceil]\n  rw [Nat.add_one_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\nn : \u2115\ninst\u271d : IsStrictOrderedRing R\n\u22a2 n + 1 \u2264 \u2308a\u2309\u208a \u2194 \u2191n < a"}, {"line": "rw [\u2190 Nat.lt_ceil]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\nn : \u2115\ninst\u271d : IsStrictOrderedRing R\n\u22a2 n + 1 \u2264 \u2308a\u2309\u208a \u2194 n < \u2308a\u2309\u208a\n---\nR : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\nn : \u2115\ninst\u271d : IsStrictOrderedRing R\n\u22a2 FloorSemiring R"}, {"line": "rw [Nat.add_one_le_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_ceil_iff : 1 \u2264 \u2308a\u2309\u208a \u2194 0 < a := by\n  rw [\u2190 zero_add 1]\n  rw [Nat.add_one_le_ceil_iff]\n  rw [Nat.cast_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\ninst\u271d : IsStrictOrderedRing R\n\u22a2 1 \u2264 \u2308a\u2309\u208a \u2194 0 < a"}, {"line": "rw [\u2190 zero_add 1]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\ninst\u271d : IsStrictOrderedRing R\n\u22a2 0 + 1 \u2264 \u2308a\u2309\u208a \u2194 0 < a"}, {"line": "rw [Nat.add_one_le_ceil_iff]", "tactic_state": "R : Type u_1\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : LinearOrder R\ninst\u271d\u00b9 : FloorSemiring R\na : R\ninst\u271d : IsStrictOrderedRing R\n\u22a2 \u21910 < a \u2194 0 < a"}, {"line": "rw [Nat.cast_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Ioo {a b : R} (ha : 0 \u2264 a) :\n    (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Ioo a b = Set.Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a := by\n  ext\n  simp [floor_lt, lt_ceil, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\n\u22a2 Nat.cast \u207b\u00b9' Ioo a b = Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ioo a b \u2194 x\u271d \u2208 Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a"}, {"line": "simp [floor_lt, lt_ceil, ha]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 a < \u2191x\u271d \u2227 \u2191x\u271d < b \u2194 \u230aa\u230b\u208a < x\u271d \u2227 x\u271d < \u2308b\u2309\u208a"}]}
{"declaration": "theorem preimage_Ico {a b : R} : (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309\u208a \u2308b\u2309\u208a := by\n  ext\n  simp [ceil_le, lt_ceil]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\n\u22a2 Nat.cast \u207b\u00b9' Ico a b = Ico \u2308a\u2309\u208a \u2308b\u2309\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ico a b \u2194 x\u271d \u2208 Ico \u2308a\u2309\u208a \u2308b\u2309\u208a"}, {"line": "simp [ceil_le, lt_ceil]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nx\u271d : \u2115\n\u22a2 a \u2264 \u2191x\u271d \u2192 (\u2191x\u271d < b \u2194 x\u271d < \u2308b\u2309\u208a)"}]}
{"declaration": "theorem preimage_Ioc {a b : R} (ha : 0 \u2264 a) (hb : 0 \u2264 b) :\n    (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Ioc a b = Set.Ioc \u230aa\u230b\u208a \u230ab\u230b\u208a := by\n  ext\n  simp [floor_lt, le_floor_iff, hb, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 Nat.cast \u207b\u00b9' Ioc a b = Ioc \u230aa\u230b\u208a \u230ab\u230b\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ioc a b \u2194 x\u271d \u2208 Ioc \u230aa\u230b\u208a \u230ab\u230b\u208a"}, {"line": "simp [floor_lt, le_floor_iff, hb, ha]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nha : 0 \u2264 a\nhb : 0 \u2264 b\nx\u271d : \u2115\n\u22a2 a < \u2191x\u271d \u2227 \u2191x\u271d \u2264 b \u2194 \u230aa\u230b\u208a < x\u271d \u2227 x\u271d \u2264 \u230ab\u230b\u208a"}]}
{"declaration": "theorem preimage_Icc {a b : R} (hb : 0 \u2264 b) :\n    (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309\u208a \u230ab\u230b\u208a := by\n  ext\n  simp [ceil_le, hb, le_floor_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nhb : 0 \u2264 b\n\u22a2 Nat.cast \u207b\u00b9' Icc a b = Icc \u2308a\u2309\u208a \u230ab\u230b\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nhb : 0 \u2264 b\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Icc a b \u2194 x\u271d \u2208 Icc \u2308a\u2309\u208a \u230ab\u230b\u208a"}, {"line": "simp [ceil_le, hb, le_floor_iff]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na b : R\nhb : 0 \u2264 b\nx\u271d : \u2115\n\u22a2 a \u2264 \u2191x\u271d \u2192 (\u2191x\u271d \u2264 b \u2194 x\u271d \u2264 \u230ab\u230b\u208a)"}]}
{"declaration": "theorem preimage_Ioi {a : R} (ha : 0 \u2264 a) : (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Ioi a = Set.Ioi \u230aa\u230b\u208a := by\n  ext\n  simp [floor_lt, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\n\u22a2 Nat.cast \u207b\u00b9' Ioi a = Ioi \u230aa\u230b\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ioi a \u2194 x\u271d \u2208 Ioi \u230aa\u230b\u208a"}, {"line": "simp [floor_lt, ha]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 a < \u2191x\u271d \u2194 \u230aa\u230b\u208a < x\u271d"}]}
{"declaration": "theorem preimage_Ici {a : R} : (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Ici a = Set.Ici \u2308a\u2309\u208a := by\n  ext\n  simp [ceil_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\n\u22a2 Nat.cast \u207b\u00b9' Ici a = Ici \u2308a\u2309\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Ici a \u2194 x\u271d \u2208 Ici \u2308a\u2309\u208a"}, {"line": "simp [ceil_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_Iic {a : R} (ha : 0 \u2264 a) : (Nat.cast : \u2115 \u2192 R) \u207b\u00b9' Set.Iic a = Set.Iic \u230aa\u230b\u208a := by\n  ext\n  simp [le_floor_iff, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\n\u22a2 Nat.cast \u207b\u00b9' Iic a = Iic \u230aa\u230b\u208a"}, {"line": "ext", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 Nat.cast \u207b\u00b9' Iic a \u2194 x\u271d \u2208 Iic \u230aa\u230b\u208a"}, {"line": "simp [le_floor_iff, ha]", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : LinearOrder R\ninst\u271d\u00b2 : FloorSemiring R\ninst\u271d\u00b9 inst\u271d : IsStrictOrderedRing R\na : R\nha : 0 \u2264 a\nx\u271d : \u2115\n\u22a2 \u2191x\u271d \u2264 a \u2194 x\u271d \u2264 \u230aa\u230b\u208a"}]}
{"declaration": "theorem subsingleton_floorSemiring {R} [Semiring R] [LinearOrder R] :\n    Subsingleton (FloorSemiring R) := by\n  refine \u27e8fun H\u2081 H\u2082 => ?_\u27e9\n  have : H\u2081.ceil = H\u2082.ceil := funext fun a => (H\u2081.gc_ceil.l_unique H\u2082.gc_ceil) fun n => rfl\n  have : H\u2081.floor = H\u2082.floor := by\n    ext a\n    rcases lt_or_le a 0 with h | h\n    \u00b7 rw [H\u2081.floor_of_neg, H\u2082.floor_of_neg] <;> exact h\n    \u00b7 refine eq_of_forall_le_iff fun n => ?_\n      rw [H\u2081.gc_floor] <;> exact h\n      rw [H\u2082.gc_floor] <;> exact h\n  cases H\u2081\n  cases H\u2082\n  congr", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Floor/Semiring.lean", "context": {"open": ["Set"], "variables": ["{R K : Type*}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a b : R} {n : \u2115}", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "[IsStrictOrderedRing R]", "[Ring R] [LinearOrder R] [IsStrictOrderedRing R] [FloorSemiring R]", "[Semifield K] [LinearOrder K] [IsStrictOrderedRing K] [FloorSemiring K]", "[Field K] [LinearOrder K] [IsStrictOrderedRing K] [FloorSemiring K] {a b : K}", "[Semiring R] [LinearOrder R] [FloorSemiring R] {a : R}", "{S : Type*} [Semiring S] [LinearOrder S] [FloorSemiring S] {b : S}", "{F : Type*} [FunLike F R S] [RingHomClass F R S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\n\u22a2 Subsingleton (FloorSemiring R)"}, {"line": "refine \u27e8fun H\u2081 H\u2082 => ?_\u27e9", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\nH\u2081 H\u2082 : FloorSemiring R\n\u22a2 H\u2081 = H\u2082"}, {"line": "have : H\u2081.ceil = H\u2082.ceil := funext fun a => (H\u2081.gc_ceil.l_unique H\u2082.gc_ceil) fun n => rfl", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\nH\u2081 H\u2082 : FloorSemiring R\nthis : FloorSemiring.ceil = FloorSemiring.ceil\n\u22a2 H\u2081 = H\u2082"}, {"line": "have : H\u2081.floor = H\u2082.floor := by\n    ext a\n    rcases lt_or_le a 0 with h | h\n    \u00b7 rw [H\u2081.floor_of_neg, H\u2082.floor_of_neg] <;> exact h\n    \u00b7 refine eq_of_forall_le_iff fun n => ?_\n      rw [H\u2081.gc_floor] <;> exact h\n      rw [H\u2082.gc_floor] <;> exact h", "tactic_state": "R : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\nH\u2081 H\u2082 : FloorSemiring R\nthis\u271d : FloorSemiring.ceil = FloorSemiring.ceil\nthis : FloorSemiring.floor = FloorSemiring.floor\n\u22a2 H\u2081 = H\u2082"}, {"line": "cases H\u2081", "tactic_state": "case mk\nR : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\nH\u2082 : FloorSemiring R\nfloor\u271d ceil\u271d : R \u2192 \u2115\nfloor_of_neg\u271d : \u2200 {a : R}, a < 0 \u2192 floor\u271d a = 0\ngc_floor\u271d : \u2200 {a : R} {n : \u2115}, 0 \u2264 a \u2192 (n \u2264 floor\u271d a \u2194 \u2191n \u2264 a)\ngc_ceil\u271d : GaloisConnection ceil\u271d Nat.cast\nthis\u271d : FloorSemiring.ceil = FloorSemiring.ceil\nthis : FloorSemiring.floor = FloorSemiring.floor\n\u22a2 { floor := floor\u271d, ceil := ceil\u271d, floor_of_neg := floor_of_neg\u271d, gc_floor := gc_floor\u271d, gc_ceil := gc_ceil\u271d } = H\u2082"}, {"line": "cases H\u2082", "tactic_state": "case mk.mk\nR : Type u_5\ninst\u271d\u00b9 : Semiring R\ninst\u271d : LinearOrder R\nfloor\u271d\u00b9 ceil\u271d\u00b9 : R \u2192 \u2115\nfloor_of_neg\u271d\u00b9 : \u2200 {a : R}, a < 0 \u2192 floor\u271d\u00b9 a = 0\ngc_floor\u271d\u00b9 : \u2200 {a : R} {n : \u2115}, 0 \u2264 a \u2192 (n \u2264 floor\u271d\u00b9 a \u2194 \u2191n \u2264 a)\ngc_ceil\u271d\u00b9 : GaloisConnection ceil\u271d\u00b9 Nat.cast\nfloor\u271d ceil\u271d : R \u2192 \u2115\nfloor_of_neg\u271d : \u2200 {a : R}, a < 0 \u2192 floor\u271d a = 0\ngc_floor\u271d : \u2200 {a : R} {n : \u2115}, 0 \u2264 a \u2192 (n \u2264 floor\u271d a \u2194 \u2191n \u2264 a)\ngc_ceil\u271d : GaloisConnection ceil\u271d Nat.cast\nthis\u271d : FloorSemiring.ceil = FloorSemiring.ceil\nthis : FloorSemiring.floor = FloorSemiring.floor\n\u22a2 { floor := floor\u271d\u00b9, ceil := ceil\u271d\u00b9, floor_of_neg := floor_of_neg\u271d\u00b9, gc_floor := gc_floor\u271d\u00b9, gc_ceil := gc_ceil\u271d\u00b9 } =\n    { floor := floor\u271d, ceil := ceil\u271d, floor_of_neg := floor_of_neg\u271d, gc_floor := gc_floor\u271d, gc_ceil := gc_ceil\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma max_inv_one (a : \u03b1) : max a\u207b\u00b9 1 = a\u207b\u00b9 * max a 1 := by\n  rw [eq_inv_mul_iff_mul_eq]\n  rw [\u2190 eq_div_iff_mul_eq']\n  rw [max_one_div_max_inv_one_eq_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Group \u03b1] [LinearOrder \u03b1] [MulLeftMono \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : MulLeftMono \u03b1\na : \u03b1\n\u22a2 max a\u207b\u00b9 1 = a\u207b\u00b9 * max a 1"}, {"line": "rw [eq_inv_mul_iff_mul_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : MulLeftMono \u03b1\na : \u03b1\n\u22a2 a * max a\u207b\u00b9 1 = max a 1"}, {"line": "rw [\u2190 eq_div_iff_mul_eq']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : MulLeftMono \u03b1\na : \u03b1\n\u22a2 a = max a 1 / max a\u207b\u00b9 1"}, {"line": "rw [max_one_div_max_inv_one_eq_self]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : MulLeftMono \u03b1\na : \u03b1\n\u22a2 MulLeftMono \u03b1"}]}
{"declaration": "theorem max_div_div_right' (a b c : \u03b1) : max (a / c) (b / c) = max a b / c := by\n  simpa only [div_eq_mul_inv] using max_mul_mul_right a b c\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Group \u03b1] [LinearOrder \u03b1] [MulLeftMono \u03b1]", "{\u03b1 : Type*} [CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\na b c : \u03b1\n\u22a2 max (a / c) (b / c) = max a b / c"}, {"line": "simpa only [div_eq_mul_inv] using max_mul_mul_right a b c\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_max_sub_max_le_abs (a b c : \u03b1) : |max a c - max b c| \u2264 |a - b| := by\n  simpa only [sub_self, abs_zero, max_eq_left (abs_nonneg (a - b))]\n    using abs_max_sub_max_le_max a c b c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/MinMax.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [Group \u03b1] [LinearOrder \u03b1] [MulLeftMono \u03b1]", "{\u03b1 : Type*} [CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "{\u03b1 : Type*} [AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 |max a c - max b c| \u2264 |a - b|"}, {"line": "simpa only [sub_self, abs_zero, max_eq_left (abs_nonneg (a - b))]\n    using abs_max_sub_max_le_max a c b c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem OrderIso.mulRight_symm (a : \u03b1) : (OrderIso.mulRight a).symm = OrderIso.mulRight a\u207b\u00b9 := by\n  ext x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/OrderIso.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Group \u03b1]", "[LE \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1] {a b : \u03b1}", "(\u03b1)", "[Group \u03b1] [LE \u03b1]", "[MulRightMono \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : Group \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulLeftMono \u03b1\ninst\u271d\u00b3 : MulRightMono \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulRightMono \u03b1\na : \u03b1\n\u22a2 (mulRight a).symm = mulRight a\u207b\u00b9"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u2076 : Group \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulLeftMono \u03b1\ninst\u271d\u00b3 : MulRightMono \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulRightMono \u03b1\na x : \u03b1\n\u22a2 (mulRight a).symm x = (mulRight a\u207b\u00b9) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem OrderIso.mulLeft_symm (a : \u03b1) : (OrderIso.mulLeft a).symm = OrderIso.mulLeft a\u207b\u00b9 := by\n  ext x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/OrderIso.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Group \u03b1]", "[LE \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1] {a b : \u03b1}", "(\u03b1)", "[Group \u03b1] [LE \u03b1]", "[MulRightMono \u03b1] {a : \u03b1}", "[MulLeftMono \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : MulRightMono \u03b1\ninst\u271d : MulLeftMono \u03b1\na : \u03b1\n\u22a2 (mulLeft a).symm = mulLeft a\u207b\u00b9"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : LE \u03b1\ninst\u271d\u2075 : MulLeftMono \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : LE \u03b1\ninst\u271d\u00b9 : MulRightMono \u03b1\ninst\u271d : MulLeftMono \u03b1\na x : \u03b1\n\u22a2 (mulLeft a).symm x = (mulLeft a\u207b\u00b9) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma leOnePart_le_one' : a\u207b\u1d50 \u2264 1 \u2194 a\u207b\u00b9 \u2264 1 := by simp [leOnePart]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/PosPart.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1]", "[Group \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Lattice \u03b1\ninst\u271d : Group \u03b1\na : \u03b1\n\u22a2 a\u207b\u1d50 \u2264 1 \u2194 a\u207b\u00b9 \u2264 1"}, {"line": "simp [leOnePart]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma leOnePart_eq_one : a\u207b\u1d50 = 1 \u2194 1 \u2264 a := by simp [leOnePart_eq_one']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/PosPart.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*}", "[Lattice \u03b1]", "[Group \u03b1] {a b : \u03b1}", "[MulLeftMono \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : Group \u03b1\na : \u03b1\ninst\u271d : MulLeftMono \u03b1\n\u22a2 a\u207b\u1d50 = 1 \u2194 1 \u2264 a"}, {"line": "simp [leOnePart_eq_one']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : Lattice \u03b1\ninst\u271d\u00b9 : Group \u03b1\na : \u03b1\ninst\u271d : MulLeftMono \u03b1\n\u22a2 a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a"}]}
{"declaration": "theorem mabs_le : |a|\u2098 \u2264 b \u2194 b\u207b\u00b9 \u2264 a \u2227 a \u2264 b := by rw [mabs_le', and_comm, inv_le']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 mabs a \u2264 b \u2194 b\u207b\u00b9 \u2264 a \u2227 a \u2264 b"}, {"line": "rw [mabs_le', and_comm, inv_le']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 MulRightMono G"}]}
{"declaration": "theorem le_mabs' : a \u2264 |b|\u2098 \u2194 b \u2264 a\u207b\u00b9 \u2228 a \u2264 b := by rw [le_mabs, or_comm, le_inv']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 a \u2264 mabs b \u2194 b \u2264 a\u207b\u00b9 \u2228 a \u2264 b"}, {"line": "rw [le_mabs, or_comm, le_inv']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 MulRightMono G"}]}
{"declaration": "theorem mabs_mul' (a b : G) : |a|\u2098 \u2264 |b|\u2098 * |b * a|\u2098 := by simpa using mabs_mul b\u207b\u00b9 (b * a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b : G\n\u22a2 mabs a \u2264 mabs b * mabs (b * a)"}, {"line": "simpa using mabs_mul b\u207b\u00b9 (b * a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mabs_div_le_iff : |a / b|\u2098 \u2264 c \u2194 a / b \u2264 c \u2227 b / a \u2264 c := by\n  rw [mabs_le]\n  rw [inv_le_div_iff_le_mul]\n  rw [div_le_iff_le_mul']\n  rw [and_comm]\n  rw [div_le_iff_le_mul']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 mabs (a / b) \u2264 c \u2194 a / b \u2264 c \u2227 b / a \u2264 c"}, {"line": "rw [mabs_le]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 c\u207b\u00b9 \u2264 a / b \u2227 a / b \u2264 c \u2194 a / b \u2264 c \u2227 b / a \u2264 c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [inv_le_div_iff_le_mul]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 b \u2264 a * c \u2227 a / b \u2264 c \u2194 a / b \u2264 c \u2227 b / a \u2264 c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_le_iff_le_mul']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 b \u2264 a * c \u2227 a \u2264 b * c \u2194 a \u2264 b * c \u2227 b / a \u2264 c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [and_comm]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 a \u2264 b * c \u2227 b \u2264 a * c \u2194 a \u2264 b * c \u2227 b / a \u2264 c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_le_iff_le_mul']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 IsOrderedMonoid G"}]}
{"declaration": "theorem mabs_div_lt_iff : |a / b|\u2098 < c \u2194 a / b < c \u2227 b / a < c := by\n  rw [mabs_lt]\n  rw [inv_lt_div_iff_lt_mul']\n  rw [div_lt_iff_lt_mul']\n  rw [and_comm]\n  rw [div_lt_iff_lt_mul']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 mabs (a / b) < c \u2194 a / b < c \u2227 b / a < c"}, {"line": "rw [mabs_lt]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 c\u207b\u00b9 < a / b \u2227 a / b < c \u2194 a / b < c \u2227 b / a < c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulRightMono G"}, {"line": "rw [inv_lt_div_iff_lt_mul']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 b < a * c \u2227 a / b < c \u2194 a / b < c \u2227 b / a < c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulRightMono G"}, {"line": "rw [div_lt_iff_lt_mul']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 b < a * c \u2227 a < b * c \u2194 a < b * c \u2227 b / a < c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulRightMono G"}, {"line": "rw [and_comm]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 a < b * c \u2227 b < a * c \u2194 a < b * c \u2227 b / a < c\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulRightMono G"}, {"line": "rw [div_lt_iff_lt_mul']", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulLeftMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b c : G\n\u22a2 MulRightMono G"}]}
{"declaration": "theorem mabs_div_le_of_one_le_of_le {a b n : G} (one_le_a : 1 \u2264 a) (a_le_n : a \u2264 n)\n    (one_le_b : 1 \u2264 b) (b_le_n : b \u2264 n) : |a / b|\u2098 \u2264 n := by\n  rw [mabs_div_le_iff]\n  rw [div_le_iff_le_mul]\n  rw [div_le_iff_le_mul]\n  exact \u27e8le_mul_of_le_of_one_le a_le_n one_le_b, le_mul_of_le_of_one_le b_le_n one_le_a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 mabs (a / b) \u2264 n"}, {"line": "rw [mabs_div_le_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 a / b \u2264 n \u2227 b / a \u2264 n\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_le_iff_le_mul]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 a \u2264 n * b \u2227 b / a \u2264 n\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 MulRightMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_le_iff_le_mul]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 a \u2264 n * b \u2227 b \u2264 n * a\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 MulRightMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 MulRightMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 IsOrderedMonoid G"}, {"line": "exact \u27e8le_mul_of_le_of_one_le a_le_n one_le_b, le_mul_of_le_of_one_le b_le_n one_le_a\u27e9", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 MulRightMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 MulRightMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_le_n : a \u2264 n\none_le_b : 1 \u2264 b\nb_le_n : b \u2264 n\n\u22a2 IsOrderedMonoid G"}]}
{"declaration": "theorem mabs_div_lt_of_one_le_of_lt {a b n : G} (one_le_a : 1 \u2264 a) (a_lt_n : a < n)\n    (one_le_b : 1 \u2264 b) (b_lt_n : b < n) : |a / b|\u2098 < n := by\n  rw [mabs_div_lt_iff]\n  rw [div_lt_iff_lt_mul]\n  rw [div_lt_iff_lt_mul]\n  exact \u27e8lt_mul_of_lt_of_one_le a_lt_n one_le_b, lt_mul_of_lt_of_one_le b_lt_n one_le_a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 mabs (a / b) < n"}, {"line": "rw [mabs_div_lt_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 a / b < n \u2227 b / a < n\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_lt_iff_lt_mul]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 a < n * b \u2227 b / a < n\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 MulRightStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 IsOrderedMonoid G"}, {"line": "rw [div_lt_iff_lt_mul]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 a < n * b \u2227 b < n * a\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 MulRightStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 MulRightStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 IsOrderedMonoid G"}, {"line": "exact \u27e8lt_mul_of_lt_of_one_le a_lt_n one_le_b, lt_mul_of_lt_of_one_le b_lt_n one_le_a\u27e9", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 MulRightStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 MulRightStrictMono G\n---\nG : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na b n : G\none_le_a : 1 \u2264 a\na_lt_n : a < n\none_le_b : 1 \u2264 b\nb_lt_n : b < n\n\u22a2 IsOrderedMonoid G"}]}
{"declaration": "theorem mabs_eq_self : |a|\u2098 = a \u2194 1 \u2264 a := by\n  rw [mabs_eq_max_inv]\n  rw [max_eq_left_iff]\n  rw [inv_le_self_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 mabs a = a \u2194 1 \u2264 a"}, {"line": "rw [mabs_eq_max_inv]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 max a a\u207b\u00b9 = a \u2194 1 \u2264 a"}, {"line": "rw [max_eq_left_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 a\u207b\u00b9 \u2264 a \u2194 1 \u2264 a"}, {"line": "rw [inv_le_self_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 IsOrderedMonoid G"}]}
{"declaration": "theorem mabs_eq_inv_self : |a|\u2098 = a\u207b\u00b9 \u2194 a \u2264 1 := by\n  rw [mabs_eq_max_inv]\n  rw [max_eq_right_iff]\n  rw [le_inv_self_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Abs.lean", "context": {"open": ["Function"], "variables": ["{G : Type*}", "[CommGroup G] [LinearOrder G] [IsOrderedMonoid G] {a b c : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 mabs a = a\u207b\u00b9 \u2194 a \u2264 1"}, {"line": "rw [mabs_eq_max_inv]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 max a a\u207b\u00b9 = a\u207b\u00b9 \u2194 a \u2264 1"}, {"line": "rw [max_eq_right_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 a \u2264 a\u207b\u00b9 \u2194 a \u2264 1"}, {"line": "rw [le_inv_self_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\na : G\n\u22a2 IsOrderedMonoid G"}]}
{"declaration": "lemma toFinset_card_eq_one_iff (s : Multiset \u03b1) :\n    #s.toFinset = 1 \u2194 Multiset.card s \u2260 0 \u2227 \u2203 a : \u03b1, s = Multiset.card s \u2022 {a} := by\n  simp_rw [Finset.card_eq_one, Multiset.toFinset_eq_singleton_iff, exists_and_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Finset.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 s.toFinset.card = 1 \u2194 s.card \u2260 0 \u2227 \u2203 a, s = s.card \u2022 {a}"}, {"line": "simp_rw [Finset.card_eq_one, Multiset.toFinset_eq_singleton_iff, exists_and_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fold_max_add [LinearOrder M] [Add M] [AddRightMono M] (s : Finset \u03b9) (a : WithBot M)\n    (f : \u03b9 \u2192 M) : s.fold max \u22a5 (fun i \u21a6 \u2191(f i) + a) = s.fold max \u22a5 ((\u2191) \u2218 f) + a := by\n  classical\n    induction' s using Finset.induction_on with a s _ ih <;> simp [*, max_add_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Finset.lean", "context": {"open": ["scoped Finset"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1]", "{\u03b9 \u03ba M G : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : LinearOrder M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddRightMono M\ns : Finset \u03b9\na : WithBot M\nf : \u03b9 \u2192 M\n\u22a2 Finset.fold max \u22a5 (fun i => \u2191(f i) + a) s = Finset.fold max \u22a5 (WithBot.some \u2218 f) s + a"}, {"line": "classical\n    induction' s using Finset.induction_on with a s _ ih <;> simp [*, max_add_add_right]", "tactic_state": "case insert\n\u03b9 : Type u_2\nM : Type u_4\ninst\u271d\u00b2 : LinearOrder M\ninst\u271d\u00b9 : Add M\ninst\u271d : AddRightMono M\na\u271d\u00b9 : WithBot M\nf : \u03b9 \u2192 M\na : \u03b9\ns : Finset \u03b9\na\u271d : a \u2209 s\nih : Finset.fold max \u22a5 (fun i => \u2191(f i) + a\u271d\u00b9) s = Finset.fold max \u22a5 (WithBot.some \u2218 f) s + a\u271d\u00b9\n\u22a2 max (\u2191(f a) + a\u271d\u00b9) (Finset.fold max \u22a5 (fun x => \u2191(f x)) s + a\u271d\u00b9) =\n    max (\u2191(f a)) (Finset.fold max \u22a5 (fun x => \u2191(f x)) s) + a\u271d\u00b9"}]}
{"declaration": "lemma mulIndicator_apply_le' (hfg : a \u2208 s \u2192 f a \u2264 y) (hg : a \u2209 s \u2192 1 \u2264 y) :\n    mulIndicator s f a \u2264 y := by\n  by_cases ha : a \u2208 s\n  \u00b7 simpa [ha] using hfg ha\n  \u00b7 simpa [ha] using hg ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Indicator.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Sort*} {\u03b1 M : Type*}", "[One M]", "[LE M] [One M] {s : Set \u03b1} {f g : \u03b1 \u2192 M} {a : \u03b1} {y : M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : LE M\ninst\u271d : One M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\ny : M\nhfg : a \u2208 s \u2192 f a \u2264 y\nhg : a \u2209 s \u2192 1 \u2264 y\n\u22a2 s.mulIndicator f a \u2264 y"}, {"line": "by_cases ha : a \u2208 s", "tactic_state": "case pos\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : LE M\ninst\u271d : One M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\ny : M\nhfg : a \u2208 s \u2192 f a \u2264 y\nhg : a \u2209 s \u2192 1 \u2264 y\nha : a \u2208 s\n\u22a2 s.mulIndicator f a \u2264 y\n---\ncase neg\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : LE M\ninst\u271d : One M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\ny : M\nhfg : a \u2208 s \u2192 f a \u2264 y\nhg : a \u2209 s \u2192 1 \u2264 y\nha : a \u2209 s\n\u22a2 s.mulIndicator f a \u2264 y"}, {"line": "\u00b7 simpa [ha] using hfg ha", "tactic_state": "case neg\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : One M\ninst\u271d\u00b9 : LE M\ninst\u271d : One M\ns : Set \u03b1\nf : \u03b1 \u2192 M\na : \u03b1\ny : M\nhfg : a \u2208 s \u2192 f a \u2264 y\nhg : a \u2209 s \u2192 1 \u2264 y\nha : a \u2209 s\n\u22a2 s.mulIndicator f a \u2264 y"}, {"line": "\u00b7 simpa [ha] using hg ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_nsmul_of_ne_zero {a : \u03b1} {s : Multiset \u03b1} {n : \u2115} (h0 : n \u2260 0) : a \u2208 n \u2022 s \u2194 a \u2208 s := by\n  simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Multiset.lean", "context": {"open": ["List Nat"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ns : Multiset \u03b1\nn : \u2115\nh0 : n \u2260 0\n\u22a2 a \u2208 n \u2022 s \u2194 a \u2208 s"}, {"line": "simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nodup.le_nsmul_iff_le {s t : Multiset \u03b1} {n : \u2115} (h : s.Nodup) (hn : n \u2260 0) :\n    s \u2264 n \u2022 t \u2194 s \u2264 t := by\n  classical simp [\u2190 h.le_dedup_iff_le, Iff.comm, \u2190 h.le_dedup_iff_le, hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Multiset.lean", "context": {"open": ["List Nat"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1]", "(p : \u03b1 \u2192 Prop) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nn : \u2115\nh : s.Nodup\nhn : n \u2260 0\n\u22a2 s \u2264 n \u2022 t \u2194 s \u2264 t"}, {"line": "classical simp [\u2190 h.le_dedup_iff_le, Iff.comm, \u2190 h.le_dedup_iff_le, hn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_Icc (a b : \u03b1) : (Icc a b)\u207b\u00b9 = Icc b\u207b\u00b9 a\u207b\u00b9 := by simp [\u2190 Ici_inter_Iic, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\na b : \u03b1\n\u22a2 sorry\u207b\u00b9 = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\na b : \u03b1\n\u22a2 (sorry ())\u207b\u00b9 = sorry ()"}]}
{"declaration": "lemma inv_Ico (a b : \u03b1) : (Ico a b)\u207b\u00b9 = Ioc b\u207b\u00b9 a\u207b\u00b9 := by\n  simp [\u2190 Ici_inter_Iio, \u2190 Ioi_inter_Iic, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\na b : \u03b1\n\u22a2 sorry\u207b\u00b9 = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio, \u2190 Ioi_inter_Iic, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\na b : \u03b1\n\u22a2 (sorry ())\u207b\u00b9 = sorry ()"}]}
{"declaration": "lemma inv_Ioc (a b : \u03b1) : (Ioc a b)\u207b\u00b9 = Ico b\u207b\u00b9 a\u207b\u00b9 := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\na b : \u03b1\n\u22a2 sorry\u207b\u00b9 = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\na b : \u03b1\n\u22a2 (sorry ())\u207b\u00b9 = sorry ()"}]}
{"declaration": "lemma inv_Ioo (a b : \u03b1) : (Ioo a b)\u207b\u00b9 = Ioo b\u207b\u00b9 a\u207b\u00b9 := by simp [\u2190 Ioi_inter_Iio, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\na b : \u03b1\n\u22a2 sorry\u207b\u00b9 = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : Mul \u03b1\ninst\u271d\u00b9\u2074 : Preorder \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b9\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9\u00b9 : Mul \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : MulRightStrictMono \u03b1\ninst\u271d\u2077 : CommMonoid \u03b1\ninst\u271d\u2076 : LinearOrder \u03b1\ninst\u271d\u2075 : IsOrderedMonoid \u03b1\ninst\u271d\u2074 : MulLeftReflectLE \u03b1\ninst\u271d\u00b3 : ExistsMulOfLE \u03b1\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\na b : \u03b1\n\u22a2 (sorry ())\u207b\u00b9 = sorry ()"}]}
{"declaration": "theorem preimage_const_add_Icc : (fun x => a + x) \u207b\u00b9' Icc b c = Icc (b - a) (c - a) := by\n  simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_add_Ico : (fun x => a + x) \u207b\u00b9' Ico b c = Ico (b - a) (c - a) := by\n  simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_add_Ioc : (fun x => a + x) \u207b\u00b9' Ioc b c = Ioc (b - a) (c - a) := by\n  simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_add_Ioo : (fun x => a + x) \u207b\u00b9' Ioo b c = Ioo (b - a) (c - a) := by\n  simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_add_const_Icc : (fun x => x + a) \u207b\u00b9' Icc b c = Icc (b - a) (c - a) := by\n  simp [\u2190 Ici_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_add_const_Ico : (fun x => x + a) \u207b\u00b9' Ico b c = Ico (b - a) (c - a) := by\n  simp [\u2190 Ici_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_add_const_Ioc : (fun x => x + a) \u207b\u00b9' Ioc b c = Ioc (b - a) (c - a) := by\n  simp [\u2190 Ioi_inter_Iic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_add_const_Ioo : (fun x => x + a) \u207b\u00b9' Ioo b c = Ioo (b - a) (c - a) := by\n  simp [\u2190 Ioi_inter_Iio]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x + a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Ici : (fun x => x - a) \u207b\u00b9' Ici b = Ici (b + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIci : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIci : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Ioi : (fun x => x - a) \u207b\u00b9' Ioi b = Ioi (b + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoi : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoi : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Iic : (fun x => x - a) \u207b\u00b9' Iic b = Iic (b + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Iio : (fun x => x - a) \u207b\u00b9' Iio b = Iio (b + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Icc : (fun x => x - a) \u207b\u00b9' Icc b c = Icc (b + a) (c + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Ico : (fun x => x - a) \u207b\u00b9' Ico b c = Ico (b + a) (c + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Ioc : (fun x => x - a) \u207b\u00b9' Ioc b c = Ioc (b + a) (c + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_sub_const_Ioo : (fun x => x - a) \u207b\u00b9' Ioo b c = Ioo (b + a) (c + a) := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x - a) \u207b\u00b9' sorry = sorry"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_sub_Icc : (fun x => a - x) \u207b\u00b9' Icc b c = Icc (a - c) (a - b) := by\n  simp [\u2190 Ici_inter_Iic, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_sub_Ico : (fun x => a - x) \u207b\u00b9' Ico b c = Ioc (a - c) (a - b) := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_sub_Ioc : (fun x => a - x) \u207b\u00b9' Ioc b c = Ico (a - c) (a - b) := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_sub_Ioo : (fun x => a - x) \u207b\u00b9' Ioo b c = Ioo (a - c) (a - b) := by\n  simp [\u2190 Ioi_inter_Iio, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => a - x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem image_const_add_Iic : (fun x => a + x) '' Iic b = Iic (a + b) := by simp [add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => a + x) '' sorry = sorry"}, {"line": "simp [add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => -a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem image_const_add_Iio : (fun x => a + x) '' Iio b = Iio (a + b) := by simp [add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => a + x) '' sorry = sorry"}, {"line": "simp [add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => -a + x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem image_add_const_Iic : (fun x => x + a) '' Iic b = Iic (b + a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x + a) '' sorry = sorry"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x + -a) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem image_neg_Icc : Neg.neg '' Icc a b = Icc (-b) (-a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 Neg.neg '' sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 -sorry () = sorry ()"}]}
{"declaration": "theorem image_neg_Ico : Neg.neg '' Ico a b = Ioc (-b) (-a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\n\u22a2 Neg.neg '' sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIco : x\u271d\u00b9\nx\u271d : Sort u_3\nIoc : x\u271d\n\u22a2 -sorry () = sorry ()"}]}
{"declaration": "theorem image_neg_Ioc : Neg.neg '' Ioc a b = Ico (-b) (-a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\n\u22a2 Neg.neg '' sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d\u00b9 : Sort u_2\nIoc : x\u271d\u00b9\nx\u271d : Sort u_3\nIco : x\u271d\n\u22a2 -sorry () = sorry ()"}]}
{"declaration": "theorem image_neg_Ioo : Neg.neg '' Ioo a b = Ioo (-b) (-a) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 Neg.neg '' sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 -sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Ici : (fun x => x - a) '' Ici b = Ici (b - a) := by simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIci : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIci : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Iic : (fun x => x - a) '' Iic b = Iic (b - a) := by simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIic : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Ioi : (fun x => x - a) '' Ioi b = Ioi (b - a) := by simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoi : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoi : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Iio : (fun x => x - a) '' Iio b = Iio (b - a) := by simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIio : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Icc : (fun x => x - a) '' Icc b c = Icc (b - a) (c - a) := by\n  simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIcc : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Ico : (fun x => x - a) '' Ico b c = Ico (b - a) (c - a) := by\n  simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIco : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Ioc : (fun x => x - a) '' Ioc b c = Ioc (b - a) (c - a) := by\n  simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoc : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem image_sub_const_Ioo : (fun x => x - a) '' Ioo b c = Ioo (b - a) (c - a) := by\n  simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x - a) '' sorry = sorry"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2078 : Mul \u03b1\ninst\u271d\u00b9\u2077 : Preorder \u03b1\ninst\u271d\u00b9\u2076 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2075 : MulRightMono \u03b1\ninst\u271d\u00b9\u2074 : Mul \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u00b9 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2070 : CommMonoid \u03b1\ninst\u271d\u2079 : LinearOrder \u03b1\ninst\u271d\u2078 : IsOrderedMonoid \u03b1\ninst\u271d\u2077 : MulLeftReflectLE \u03b1\ninst\u271d\u2076 : ExistsMulOfLE \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na : \u03b1\nx\u271d : Sort u_2\nIoo : x\u271d\n\u22a2 (fun x => x - a) '' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_add_const_uIcc : (fun x => x + a) \u207b\u00b9' [[b, c]] = [[b - a, c - a]] := by\n  simpa only [add_comm] using preimage_const_add_uIcc a b c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + a) \u207b\u00b9' Set.uIcc b c = Set.uIcc (b - a) (c - a)"}, {"line": "simpa only [add_comm] using preimage_const_add_uIcc a b c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_sub_const_uIcc : (fun x => x - a) \u207b\u00b9' [[b, c]] = [[b + a, c + a]] := by\n  simp [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x - a) \u207b\u00b9' Set.uIcc b c = Set.uIcc (b + a) (c + a)"}, {"line": "simp [sub_eq_add_neg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + -a) \u207b\u00b9' Set.uIcc b c = Set.uIcc (b + a) (c + a)"}]}
{"declaration": "theorem image_const_add_uIcc : (fun x => a + x) '' [[b, c]] = [[a + b, a + c]] := by simp [add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => a + x) '' Set.uIcc b c = Set.uIcc (a + b) (a + c)"}, {"line": "simp [add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => -a + x) \u207b\u00b9' Set.uIcc b c = Set.uIcc (a + b) (a + c)"}]}
{"declaration": "theorem image_add_const_uIcc : (fun x => x + a) '' [[b, c]] = [[b + a, c + a]] := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + a) '' Set.uIcc b c = Set.uIcc (b + a) (c + a)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + -a) \u207b\u00b9' Set.uIcc b c = Set.uIcc (b + a) (c + a)"}]}
{"declaration": "theorem image_sub_const_uIcc : (fun x => x - a) '' [[b, c]] = [[b - a, c - a]] := by\n  simp [sub_eq_add_neg, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x - a) '' Set.uIcc b c = Set.uIcc (b - a) (c - a)"}, {"line": "simp [sub_eq_add_neg, add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2074 : Mul \u03b1\ninst\u271d\u00b2\u00b3 : Preorder \u03b1\ninst\u271d\u00b2\u00b2 : MulLeftMono \u03b1\ninst\u271d\u00b2\u00b9 : MulRightMono \u03b1\ninst\u271d\u00b2\u2070 : Mul \u03b1\ninst\u271d\u00b9\u2079 : PartialOrder \u03b1\ninst\u271d\u00b9\u2078 : MulLeftStrictMono \u03b1\ninst\u271d\u00b9\u2077 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : LinearOrder \u03b1\ninst\u271d\u00b9\u2074 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b3 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u00b2 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedMonoid \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b1\ninst\u271d\u2077 : PartialOrder \u03b1\ninst\u271d\u2076 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2075 : CommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedMonoid \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsOrderedAddMonoid \u03b1\na b c : \u03b1\n\u22a2 (fun x => x + - -a) \u207b\u00b9' Set.uIcc b c = Set.uIcc (b + -a) (c + -a)"}]}
{"declaration": "theorem preimage_mul_const_Iic (a : G\u2080) (h : 0 < c) : (\u00b7 * c) \u207b\u00b9' Iic a = Iic (a / c) := by\n  simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Iic a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIic : x\u271d\na : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Iic a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_mul_const_Ici (a : G\u2080) (h : 0 < c) : (\u00b7 * c) \u207b\u00b9' Ici a = Ici (a / c) := by\n  simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Ici a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIci : x\u271d\na : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Ici a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_mul_const_Ioi (a : G\u2080) (h : 0 < c) : (\u00b7 * c) \u207b\u00b9' Ioi a = Ioi (a / c) := by\n  simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Ioi a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIoi : x\u271d\na : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Ioi a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_mul_const_Iio (a : G\u2080) (h : 0 < c) : (\u00b7 * c) \u207b\u00b9' Iio a = Iio (a / c) := by\n  simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Iio a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIio : x\u271d\na : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [division_def] using (OrderIso.mulRight\u2080 c h).preimage_Iio a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_mul_const_Icc (a b : G\u2080) (h : 0 < c) :\n    (\u00b7 * c) \u207b\u00b9' Icc a b = Icc (a / c) (b / c) := by simp [\u2190 Ici_inter_Iic, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIcc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic, h]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIcc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ioo (a b : G\u2080) (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ioo a b = Ioo (a / c) (b / c) := by simp [\u2190 Ioi_inter_Iio, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIoo : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio, h]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIoo : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ioc (a b : G\u2080) (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ioc a b = Ioc (a / c) (b / c) := by simp [\u2190 Ioi_inter_Iic, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIoc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, h]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIoc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ico (a b : G\u2080) (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ico a b = Ico (a / c) (b / c) := by simp [\u2190 Ici_inter_Iio, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIco : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio, h]", "tactic_state": "G\u2080 : Type u_2\ninst\u271d\u00b2 : GroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : MulPosReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_3\nIco : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_mul_Icc (a b : G\u2080) {c : G\u2080} (h : 0 < c) :\n    (c * \u00b7) \u207b\u00b9' Icc a b = Icc (a / c) (b / c) := by simp [\u2190 Ici_inter_Iic, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nx\u271d : Sort u_6\nIcc : x\u271d\na b c : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic, h]", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nx\u271d : Sort u_6\nIcc : x\u271d\na b c : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_mul_Ioo (a b : G\u2080) (h : 0 < c) :\n    (c * \u00b7) \u207b\u00b9' Ioo a b = Ioo (a / c) (b / c) := by simp [\u2190 Ioi_inter_Iio, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIoo : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio, h]", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIoo : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_mul_Ioc (a b : G\u2080) (h : 0 < c) :\n    (c * \u00b7) \u207b\u00b9' Ioc a b = Ioc (a / c) (b / c) := by simp [\u2190 Ioi_inter_Iic, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIoc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, h]", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIoc : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_mul_Ico (a b : G\u2080) (h : 0 < c) :\n    (c * \u00b7) \u207b\u00b9' Ico a b = Ico (a / c) (b / c) := by simp [\u2190 Ici_inter_Iio, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIco : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio, h]", "tactic_state": "G\u2080 : Type u_5\ninst\u271d\u00b2 : CommGroupWithZero G\u2080\ninst\u271d\u00b9 : PartialOrder G\u2080\ninst\u271d : PosMulReflectLT G\u2080\nc : G\u2080\nx\u271d : Sort u_6\nIco : x\u271d\na b : G\u2080\nh : 0 < c\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ioo_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ioo a b = Ioo (b / c) (a / c) := by simp [\u2190 Ioi_inter_Iio, h, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIoo : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iio, h, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIoo : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ioc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ioc a b = Ico (b / c) (a / c) := by\n  simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, h, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIoc : x\u271d\u00b9\nx\u271d : Sort u_8\nIco : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ioi_inter_Iic, \u2190 Ici_inter_Iio, h, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIoc : x\u271d\u00b9\nx\u271d : Sort u_8\nIco : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Ico_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ico a b = Ioc (b / c) (a / c) := by\n  simp [\u2190 Ici_inter_Iio, \u2190 Ioi_inter_Iic, h, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIco : x\u271d\u00b9\nx\u271d : Sort u_8\nIoc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iio, \u2190 Ioi_inter_Iic, h, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIco : x\u271d\u00b9\nx\u271d : Sort u_8\nIoc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_mul_const_Icc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Icc a b = Icc (b / c) (a / c) := by simp [\u2190 Ici_inter_Iic, h, inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIcc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry = sorry"}, {"line": "simp [\u2190 Ici_inter_Iic, h, inter_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIcc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => x * c) \u207b\u00b9' sorry () = sorry ()"}]}
{"declaration": "theorem preimage_const_mul_Ioi_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Ioi a = Iio (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Ioi_of_neg a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIoi : x\u271d\u00b9\nx\u271d : Sort u_8\nIio : x\u271d\na c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Ioi_of_neg a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const_mul_Iic_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Iic a = Ici (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Iic_of_neg a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIic : x\u271d\u00b9\nx\u271d : Sort u_8\nIci : x\u271d\na c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Iic_of_neg a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const_mul_Ici_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Ici a = Iic (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Ici_of_neg a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIci : x\u271d\u00b9\nx\u271d : Sort u_8\nIic : x\u271d\na c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Ici_of_neg a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const_mul_Ioo_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Ioo a b = Ioo (b / c) (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Ioo_of_neg a b h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIoo : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Ioo_of_neg a b h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const_mul_Ico_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Ico a b = Ioc (b / c) (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Ico_of_neg a b h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d\u00b9 : Sort u_7\nIco : x\u271d\u00b9\nx\u271d : Sort u_8\nIoc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Ico_of_neg a b h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const_mul_Icc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (c * \u00b7) \u207b\u00b9' Icc a b = Icc (b / c) (a / c) := by\n  simpa only [mul_comm] using preimage_mul_const_Icc_of_neg a b h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\nx\u271d : Sort u_7\nIcc : x\u271d\na b c : \u03b1\nh : c < 0\n\u22a2 (fun x => c * x) \u207b\u00b9' sorry = sorry"}, {"line": "simpa only [mul_comm] using preimage_mul_const_Icc_of_neg a b h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_const_mul_uIcc (a b c : \u03b1) : (a * \u00b7) '' [[b, c]] = [[a * b, a * c]] := by\n  simpa only [mul_comm] using image_mul_const_uIcc a b c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Pointwise/Interval.lean", "context": {"open": ["Interval Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] [Preorder \u03b1] [MulLeftMono \u03b1] [MulRightMono \u03b1]", "[Mul \u03b1] [PartialOrder \u03b1] [MulLeftStrictMono \u03b1] [MulRightStrictMono \u03b1]", "[CommMonoid \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1] [MulLeftReflectLE \u03b1] [ExistsMulOfLE \u03b1]", "[CommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c : \u03b1)", "[CommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedMonoid \u03b1]", "[AddCommGroup \u03b1] [LinearOrder \u03b1] [IsOrderedAddMonoid \u03b1] (a b c d : \u03b1)", "{a b c d}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [MulPosReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{G\u2080 : Type*} [GroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080]", "{G\u2080 : Type*} [CommGroupWithZero G\u2080] [PartialOrder G\u2080] [PosMulReflectLT G\u2080] {a b c : G\u2080}", "{K : Type*} [DivisionSemiring K] [PartialOrder K] [PosMulReflectLT K]", "[Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2\u2077 : Mul \u03b1\ninst\u271d\u00b2\u2076 : Preorder \u03b1\ninst\u271d\u00b2\u2075 : MulLeftMono \u03b1\ninst\u271d\u00b2\u2074 : MulRightMono \u03b1\ninst\u271d\u00b2\u00b3 : Mul \u03b1\ninst\u271d\u00b2\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b2\u00b9 : MulLeftStrictMono \u03b1\ninst\u271d\u00b2\u2070 : MulRightStrictMono \u03b1\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : LinearOrder \u03b1\ninst\u271d\u00b9\u2077 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u2076 : MulLeftReflectLE \u03b1\ninst\u271d\u00b9\u2075 : ExistsMulOfLE \u03b1\ninst\u271d\u00b9\u2074 : CommGroup \u03b1\ninst\u271d\u00b9\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b2 : IsOrderedMonoid \u03b1\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : PartialOrder \u03b1\ninst\u271d\u2079 : IsOrderedAddMonoid \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : LinearOrder \u03b1\ninst\u271d\u2076 : IsOrderedMonoid \u03b1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : IsOrderedAddMonoid \u03b1\ninst\u271d\u00b2 : Field \u03b1\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : IsStrictOrderedRing \u03b1\na b c : \u03b1\n\u22a2 (fun x => a * x) '' Set.uIcc b c = Set.uIcc (a * b) (a * c)"}, {"line": "simpa only [mul_comm] using image_mul_const_uIcc a b c", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natAbs_le_self_sq (a : \u2124) : (Int.natAbs a : \u2124) \u2264 a ^ 2 := by\n  rw [\u2190 Int.natAbs_sq a]\n  rw [sq]\n  norm_cast\n  apply Nat.le_mul_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Int.lean", "context": {"open": ["Function Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 a ^ 2"}, {"line": "rw [\u2190 Int.natAbs_sq a]", "tactic_state": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 \u2191a.natAbs ^ 2"}, {"line": "rw [sq]", "tactic_state": "a : \u2124\n\u22a2 \u2191a.natAbs \u2264 \u2191a.natAbs * \u2191a.natAbs"}, {"line": "norm_cast", "tactic_state": "a : \u2124\n\u22a2 a.natAbs \u2264 a.natAbs * a.natAbs"}, {"line": "apply Nat.le_mul_self", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_zero_of_abs_lt_dvd {m x : \u2124} (h1 : m \u2223 x) (h2 : |x| < m) : x = 0 := by\n  by_contra h\n  have := Int.natAbs_le_of_dvd_ne_zero h1 h\n  rw [Int.abs_eq_natAbs] at h2\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Int.lean", "context": {"open": ["Function Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m x : \u2124\nh1 : m \u2223 x\nh2 : |x| < m\n\u22a2 x = 0"}, {"line": "by_contra h", "tactic_state": "m x : \u2124\nh1 : m \u2223 x\nh2 : |x| < m\nh : \u00acx = 0\n\u22a2 False"}, {"line": "have := Int.natAbs_le_of_dvd_ne_zero h1 h", "tactic_state": "m x : \u2124\nh1 : m \u2223 x\nh2 : |x| < m\nh : \u00acx = 0\nthis : m.natAbs \u2264 x.natAbs\n\u22a2 False"}, {"line": "rw [Int.abs_eq_natAbs] at h2", "tactic_state": "m x : \u2124\nh1 : m \u2223 x\nh2 : \u2191x.natAbs < m\nh : \u00acx = 0\nthis : m.natAbs \u2264 x.natAbs\n\u22a2 False"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_abs_eq_one (a : G) (n : \u2124) : a ^ |n| = 1 \u2194 a ^ n = 1 := by\n  rw [\u2190 Int.natCast_natAbs]\n  rw [zpow_natCast]\n  rw [pow_natAbs_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Int.lean", "context": {"open": ["Function Nat"], "variables": ["{G : Type*} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ |n| = 1 \u2194 a ^ n = 1"}, {"line": "rw [\u2190 Int.natCast_natAbs]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ \u2191n.natAbs = 1 \u2194 a ^ n = 1"}, {"line": "rw [zpow_natCast]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ n.natAbs = 1 \u2194 a ^ n = 1"}, {"line": "rw [pow_natAbs_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_le_self_iff (a : \u03b1) {b : \u03b1} : a / b \u2264 a \u2194 1 \u2264 b := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Group \u03b1]", "[LE \u03b1] [MulLeftMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulLeftStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulRightMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulRightStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulLeftMono \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : MulLeftMono \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : MulLeftStrictMono \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : MulRightStrictMono \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\na b : \u03b1\n\u22a2 a / b \u2264 a \u2194 1 \u2264 b"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : MulLeftMono \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : MulLeftStrictMono \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : MulRightStrictMono \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\na b : \u03b1\n\u22a2 a * b\u207b\u00b9 \u2264 a \u2194 1 \u2264 b"}]}
{"declaration": "theorem le_div_self_iff (a : \u03b1) {b : \u03b1} : a \u2264 a / b \u2194 b \u2264 1 := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Group \u03b1]", "[LE \u03b1] [MulLeftMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulLeftStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulRightMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulRightStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulLeftMono \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : MulLeftMono \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : MulLeftStrictMono \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : MulRightStrictMono \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\na b : \u03b1\n\u22a2 a \u2264 a / b \u2194 b \u2264 1"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 : LE \u03b1\ninst\u271d\u2078 : MulLeftMono \u03b1\ninst\u271d\u2077 : LT \u03b1\ninst\u271d\u2076 : MulLeftStrictMono \u03b1\ninst\u271d\u2075 : LE \u03b1\ninst\u271d\u2074 : MulRightMono \u03b1\ninst\u271d\u00b3 : LT \u03b1\ninst\u271d\u00b2 : MulRightStrictMono \u03b1\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : MulLeftMono \u03b1\na b : \u03b1\n\u22a2 a \u2264 a * b\u207b\u00b9 \u2194 b \u2264 1"}]}
{"declaration": "theorem div_lt_self_iff (a : \u03b1) {b : \u03b1} : a / b < a \u2194 1 < b := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Group/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u}", "[Group \u03b1]", "[LE \u03b1] [MulLeftMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulLeftStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulRightMono \u03b1] {a b c : \u03b1}", "[LT \u03b1] [MulRightStrictMono \u03b1] {a b c : \u03b1}", "[LE \u03b1] [MulLeftMono \u03b1] {a b c d : \u03b1}", "[MulRightMono \u03b1]", "[LT \u03b1] [MulLeftStrictMono \u03b1] {a b c d : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b3 : Group \u03b1\ninst\u271d\u00b9\u00b2 : LE \u03b1\ninst\u271d\u00b9\u00b9 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : MulRightMono \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : MulRightStrictMono \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b : \u03b1\n\u22a2 a / b < a \u2194 1 < b"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u00b3 : Group \u03b1\ninst\u271d\u00b9\u00b2 : LE \u03b1\ninst\u271d\u00b9\u00b9 : MulLeftMono \u03b1\ninst\u271d\u00b9\u2070 : LT \u03b1\ninst\u271d\u2079 : MulLeftStrictMono \u03b1\ninst\u271d\u2078 : LE \u03b1\ninst\u271d\u2077 : MulRightMono \u03b1\ninst\u271d\u2076 : LT \u03b1\ninst\u271d\u2075 : MulRightStrictMono \u03b1\ninst\u271d\u2074 : LE \u03b1\ninst\u271d\u00b3 : MulLeftMono \u03b1\ninst\u271d\u00b2 : MulRightMono \u03b1\ninst\u271d\u00b9 : LT \u03b1\ninst\u271d : MulLeftStrictMono \u03b1\na b : \u03b1\n\u22a2 a * b\u207b\u00b9 < a \u2194 1 < b"}]}
{"declaration": "theorem Left.mul_pos [PosMulStrictMono \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < a * b := by\n  simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulStrictMono \u03b1\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < a * b"}, {"line": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_neg_of_pos_of_neg [PosMulStrictMono \u03b1] (ha : 0 < a) (hb : b < 0) : a * b < 0 := by\n  simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulStrictMono \u03b1\nha : 0 < a\nhb : b < 0\n\u22a2 a * b < 0"}, {"line": "simpa only [mul_zero] using mul_lt_mul_of_pos_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_pos_iff_of_pos_left [PosMulStrictMono \u03b1] [PosMulReflectLT \u03b1] (h : 0 < a) :\n    0 < a * b \u2194 0 < b := by simpa using mul_lt_mul_left (b := 0) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : PosMulStrictMono \u03b1\ninst\u271d : PosMulReflectLT \u03b1\nh : 0 < a\n\u22a2 0 < a * b \u2194 0 < b"}, {"line": "simpa using mul_lt_mul_left (b := 0) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Right.mul_pos [MulPosStrictMono \u03b1] (ha : 0 < a) (hb : 0 < b) : 0 < a * b := by\n  simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosStrictMono \u03b1\nha : 0 < a\nhb : 0 < b\n\u22a2 0 < a * b"}, {"line": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_neg_of_neg_of_pos [MulPosStrictMono \u03b1] (ha : a < 0) (hb : 0 < b) : a * b < 0 := by\n  simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosStrictMono \u03b1\nha : a < 0\nhb : 0 < b\n\u22a2 a * b < 0"}, {"line": "simpa only [zero_mul] using mul_lt_mul_of_pos_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_pos_iff_of_pos_right [MulPosStrictMono \u03b1] [MulPosReflectLT \u03b1] (h : 0 < b) :\n    0 < a * b \u2194 0 < a := by simpa using mul_lt_mul_right (b := 0) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b2 : Preorder \u03b1\ninst\u271d\u00b9 : MulPosStrictMono \u03b1\ninst\u271d : MulPosReflectLT \u03b1\nh : 0 < b\n\u22a2 0 < a * b \u2194 0 < a"}, {"line": "simpa using mul_lt_mul_right (b := 0) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Left.mul_nonneg [PosMulMono \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b := by\n  simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulMono \u03b1\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 a * b"}, {"line": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_nonpos_of_nonneg_of_nonpos [PosMulMono \u03b1] (ha : 0 \u2264 a) (hb : b \u2264 0) : a * b \u2264 0 := by\n  simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulMono \u03b1\nha : 0 \u2264 a\nhb : b \u2264 0\n\u22a2 a * b \u2264 0"}, {"line": "simpa only [mul_zero] using mul_le_mul_of_nonneg_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Right.mul_nonneg [MulPosMono \u03b1] (ha : 0 \u2264 a) (hb : 0 \u2264 b) : 0 \u2264 a * b := by\n  simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosMono \u03b1\nha : 0 \u2264 a\nhb : 0 \u2264 b\n\u22a2 0 \u2264 a * b"}, {"line": "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_nonpos_of_nonpos_of_nonneg [MulPosMono \u03b1] (ha : a \u2264 0) (hb : 0 \u2264 b) : a * b \u2264 0 := by\n  simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : MulZeroClass \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosMono \u03b1\nha : a \u2264 0\nhb : 0 \u2264 b\n\u22a2 a * b \u2264 0"}, {"line": "simpa only [zero_mul] using mul_le_mul_of_nonneg_right ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_of_le_one_left [MulPosMono \u03b1] (hb : 0 \u2264 b) (h : a \u2264 1) : a * b \u2264 b := by\n  simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosMono \u03b1\nhb : 0 \u2264 b\nh : a \u2264 1\n\u22a2 a * b \u2264 b"}, {"line": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_of_one_le_left [MulPosMono \u03b1] (hb : 0 \u2264 b) (h : 1 \u2264 a) : b \u2264 a * b := by\n  simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosMono \u03b1\nhb : 0 \u2264 b\nh : 1 \u2264 a\n\u22a2 b \u2264 a * b"}, {"line": "simpa only [one_mul] using mul_le_mul_of_nonneg_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_of_le_one_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : b \u2264 1) : a * b \u2264 a := by\n  simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulMono \u03b1\nha : 0 \u2264 a\nh : b \u2264 1\n\u22a2 a * b \u2264 a"}, {"line": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_of_one_le_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : 1 \u2264 b) : a \u2264 a * b := by\n  simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulMono \u03b1\nha : 0 \u2264 a\nh : 1 \u2264 b\n\u22a2 a \u2264 a * b"}, {"line": "simpa only [mul_one] using mul_le_mul_of_nonneg_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_lt_of_lt_one_left [MulPosStrictMono \u03b1] (hb : 0 < b) (h : a < 1) : a * b < b := by\n  simpa only [one_mul] using mul_lt_mul_of_pos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosStrictMono \u03b1\nhb : 0 < b\nh : a < 1\n\u22a2 a * b < b"}, {"line": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_mul_of_one_lt_left [MulPosStrictMono \u03b1] (hb : 0 < b) (h : 1 < a) : b < a * b := by\n  simpa only [one_mul] using mul_lt_mul_of_pos_right h hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : MulPosStrictMono \u03b1\nhb : 0 < b\nh : 1 < a\n\u22a2 b < a * b"}, {"line": "simpa only [one_mul] using mul_lt_mul_of_pos_right h hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_lt_of_lt_one_right [PosMulStrictMono \u03b1] (ha : 0 < a) (h : b < 1) : a * b < a := by\n  simpa only [mul_one] using mul_lt_mul_of_pos_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulStrictMono \u03b1\nha : 0 < a\nh : b < 1\n\u22a2 a * b < a"}, {"line": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_mul_of_one_lt_right [PosMulStrictMono \u03b1] (ha : 0 < a) (h : 1 < b) : a < a * b := by\n  simpa only [mul_one] using mul_lt_mul_of_pos_left h ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2077 : MulZeroClass \u03b1\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : MulOneClass \u03b1\ninst\u271d\u00b2 : Zero \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : PosMulStrictMono \u03b1\nha : 0 < a\nh : 1 < b\n\u22a2 a < a * b"}, {"line": "simpa only [mul_one] using mul_lt_mul_of_pos_left h ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Bound.pow_le_pow_right_of_le_one_or_one_le [ZeroLEOneClass M\u2080] [PosMulMono M\u2080]\n    (h : 1 \u2264 a \u2227 n \u2264 m \u2228 0 \u2264 a \u2227 a \u2264 1 \u2227 m \u2264 n) :\n    a ^ n \u2264 a ^ m := by\n  obtain \u27e8a1, nm\u27e9 | \u27e8a0, a1, mn\u27e9 := h\n  \u00b7 exact pow_right_mono\u2080 a1 nm\n  \u00b7 exact pow_le_pow_of_le_one a0 a1 mn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\na : M\u2080\nm n : \u2115\ninst\u271d\u00b9 : ZeroLEOneClass M\u2080\ninst\u271d : PosMulMono M\u2080\nh : 1 \u2264 a \u2227 n \u2264 m \u2228 0 \u2264 a \u2227 a \u2264 1 \u2227 m \u2264 n\n\u22a2 a ^ n \u2264 a ^ m"}, {"line": "obtain \u27e8a1, nm\u27e9 | \u27e8a0, a1, mn\u27e9 := h", "tactic_state": "case inl.intro\nM\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\na : M\u2080\nm n : \u2115\ninst\u271d\u00b9 : ZeroLEOneClass M\u2080\ninst\u271d : PosMulMono M\u2080\na1 : 1 \u2264 a\nnm : n \u2264 m\n\u22a2 a ^ n \u2264 a ^ m\n---\ncase inr.intro.intro\nM\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\na : M\u2080\nm n : \u2115\ninst\u271d\u00b9 : ZeroLEOneClass M\u2080\ninst\u271d : PosMulMono M\u2080\na0 : 0 \u2264 a\na1 : a \u2264 1\nmn : m \u2264 n\n\u22a2 a ^ n \u2264 a ^ m"}, {"line": "\u00b7 exact pow_right_mono\u2080 a1 nm", "tactic_state": "case inr.intro.intro\nM\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\na : M\u2080\nm n : \u2115\ninst\u271d\u00b9 : ZeroLEOneClass M\u2080\ninst\u271d : PosMulMono M\u2080\na0 : 0 \u2264 a\na1 : a \u2264 1\nmn : m \u2264 n\n\u22a2 a ^ n \u2264 a ^ m"}, {"line": "\u00b7 exact pow_le_pow_of_le_one a0 a1 mn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_mul_left [MulPosStrictMono M\u2080] (ha : 0 < a) (hb : 1 < b) : a < b * a := by\n  simpa using mul_lt_mul_of_pos_right hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[PartialOrder M\u2080] {a b c d : M\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\ninst\u271d\u00b9 : PartialOrder M\u2080\na b : M\u2080\ninst\u271d : MulPosStrictMono M\u2080\nha : 0 < a\nhb : 1 < b\n\u22a2 a < b * a"}, {"line": "simpa using mul_lt_mul_of_pos_right hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_mul_right [PosMulStrictMono M\u2080] (ha : 0 < a) (hb : 1 < b) : a < a * b := by\n  simpa using mul_lt_mul_of_pos_left hb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[PartialOrder M\u2080] {a b c d : M\u2080} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2080 : Type u_2\ninst\u271d\u2076 : Mul M\u2080\ninst\u271d\u2075 : Zero M\u2080\ninst\u271d\u2074 : Preorder M\u2080\ninst\u271d\u00b3 : MonoidWithZero M\u2080\ninst\u271d\u00b2 : Preorder M\u2080\ninst\u271d\u00b9 : PartialOrder M\u2080\na b : M\u2080\ninst\u271d : PosMulStrictMono M\u2080\nha : 0 < a\nhb : 1 < b\n\u22a2 a < a * b"}, {"line": "simpa using mul_lt_mul_of_pos_left hb ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_div_mul_right_le (h : 0 \u2264 a / b) : a * c / (b * c) \u2264 a / b := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simpa\n  \u00b7 rw [mul_div_mul_right _ _ hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[PartialOrder M\u2080] {a b c d : M\u2080} {m n : \u2115}", "[ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080]", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[LinearOrder M\u2080] [ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080] {a b : M\u2080}", "[MulPosMono M\u2080]", "[CancelMonoidWithZero \u03b1]", "[PartialOrder \u03b1]", "[GroupWithZero G\u2080]", "[Preorder G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : 0 \u2264 a / b\n\u22a2 a * c / (b * c) \u2264 a / b"}, {"line": "obtain rfl | hc := eq_or_ne c 0", "tactic_state": "case inl\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b : G\u2080\nh : 0 \u2264 a / b\n\u22a2 a * sorry / (b * sorry) \u2264 a / b\n---\ncase inr\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : 0 \u2264 a / b\nhc : c \u2260 sorry\n\u22a2 a * c / (b * c) \u2264 a / b"}, {"line": "\u00b7 simpa", "tactic_state": "case inr\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : 0 \u2264 a / b\nhc : c \u2260 sorry\n\u22a2 a * c / (b * c) \u2264 a / b"}, {"line": "\u00b7 rw [mul_div_mul_right _ _ hc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_mul_div_mul_right (h : a / b \u2264 0) : a / b \u2264 a * c / (b * c) := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simpa\n  \u00b7 rw [mul_div_mul_right _ _ hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[PartialOrder M\u2080] {a b c d : M\u2080} {m n : \u2115}", "[ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080]", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[LinearOrder M\u2080] [ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080] {a b : M\u2080}", "[MulPosMono M\u2080]", "[CancelMonoidWithZero \u03b1]", "[PartialOrder \u03b1]", "[GroupWithZero G\u2080]", "[Preorder G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : a / b \u2264 0\n\u22a2 a / b \u2264 a * c / (b * c)"}, {"line": "obtain rfl | hc := eq_or_ne c 0", "tactic_state": "case inl\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b : G\u2080\nh : a / b \u2264 0\n\u22a2 a / b \u2264 a * sorry / (b * sorry)\n---\ncase inr\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : a / b \u2264 0\nhc : c \u2260 sorry\n\u22a2 a / b \u2264 a * c / (b * c)"}, {"line": "\u00b7 simpa", "tactic_state": "case inr\nG\u2080 : Type u_3\ninst\u271d\u00b9 : GroupWithZero G\u2080\ninst\u271d : Preorder G\u2080\na b c : G\u2080\nh : a / b \u2264 0\nhc : c \u2260 sorry\n\u22a2 a / b \u2264 a * c / (b * c)"}, {"line": "\u00b7 rw [mul_div_mul_right _ _ hc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_inv_le_one : a * a\u207b\u00b9 \u2264 1 := by simpa only [div_eq_mul_inv] using div_self_le_one a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 M\u2080 G\u2080 : Type*}", "[MulZeroClass \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[PartialOrder \u03b1]", "[LinearOrder \u03b1]", "[MulOneClass \u03b1] [Zero \u03b1] {a b c d : \u03b1}", "[Preorder \u03b1]", "[Mul M\u2080] [Zero M\u2080] [Preorder M\u2080] [Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[MonoidWithZero M\u2080]", "[Preorder M\u2080] {a b : M\u2080} {m n : \u2115}", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[PartialOrder M\u2080] {a b c d : M\u2080} {m n : \u2115}", "[ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080]", "[Preorder \u03b1] {f g : \u03b1 \u2192 M\u2080}", "[LinearOrder M\u2080] [ZeroLEOneClass M\u2080] [PosMulStrictMono M\u2080] {a b : M\u2080}", "[MulPosMono M\u2080]", "[CancelMonoidWithZero \u03b1]", "[PartialOrder \u03b1]", "[GroupWithZero G\u2080]", "[Preorder G\u2080] {a b c : G\u2080}", "[Preorder G\u2080] [ZeroLEOneClass G\u2080] {a b c : G\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2080 : Type u_3\ninst\u271d\u00b3 : GroupWithZero G\u2080\ninst\u271d\u00b2 inst\u271d\u00b9 : Preorder G\u2080\ninst\u271d : ZeroLEOneClass G\u2080\na : G\u2080\n\u22a2 a * a\u207b\u00b9 \u2264 1"}, {"line": "simpa only [div_eq_mul_inv] using div_self_le_one a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem posMulStrictMono_iff_mulPosStrictMono : PosMulStrictMono \u03b1 \u2194 MulPosStrictMono \u03b1 := by\n  simp only [posMulStrictMono_iff]\n  simp only [mulPosStrictMono_iff]\n  simp only [Std.Commutative.comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.lean", "context": {"open": ["Function"], "variables": ["(\u03b1 : Type*)", "[Mul \u03b1] [Zero \u03b1] [Preorder \u03b1]", "{\u03b1}", "[Mul \u03b1] [Zero \u03b1]", "[Preorder \u03b1] {a b c d : \u03b1}", "[@Std.Commutative \u03b1 (\u00b7 * \u00b7)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 PosMulStrictMono \u03b1 \u2194 MulPosStrictMono \u03b1"}, {"line": "simp only [posMulStrictMono_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (CovariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2) \u2194 MulPosStrictMono \u03b1"}, {"line": "simp only [mulPosStrictMono_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (CovariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2) \u2194\n    CovariantClass { x // 0 < x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 < x2"}, {"line": "simp only [Std.Commutative.comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (CovariantClass { x // 0 < x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 < x2) \u2194\n    CovariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2"}]}
{"declaration": "theorem posMulReflectLE_iff_mulPosReflectLE : PosMulReflectLE \u03b1 \u2194 MulPosReflectLE \u03b1 := by\n  simp only [posMulReflectLE_iff]\n  simp only [mulPosReflectLE_iff]\n  simp only [Std.Commutative.comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.lean", "context": {"open": ["Function"], "variables": ["(\u03b1 : Type*)", "[Mul \u03b1] [Zero \u03b1] [Preorder \u03b1]", "{\u03b1}", "[Mul \u03b1] [Zero \u03b1]", "[Preorder \u03b1] {a b c d : \u03b1}", "[@Std.Commutative \u03b1 (\u00b7 * \u00b7)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 PosMulReflectLE \u03b1 \u2194 MulPosReflectLE \u03b1"}, {"line": "simp only [posMulReflectLE_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 \u2264 x2) \u2194 MulPosReflectLE \u03b1"}, {"line": "simp only [mulPosReflectLE_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 \u2264 x2) \u2194\n    ContravariantClass { x // 0 < x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 \u2264 x2"}, {"line": "simp only [Std.Commutative.comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 < x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 \u2264 x2) \u2194\n    ContravariantClass { x // 0 < x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 \u2264 x2"}]}
{"declaration": "theorem posMulReflectLT_iff_mulPosReflectLT : PosMulReflectLT \u03b1 \u2194 MulPosReflectLT \u03b1 := by\n  simp only [posMulReflectLT_iff]\n  simp only [mulPosReflectLT_iff]\n  simp only [Std.Commutative.comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/GroupWithZero/Unbundled/Defs.lean", "context": {"open": ["Function"], "variables": ["(\u03b1 : Type*)", "[Mul \u03b1] [Zero \u03b1] [Preorder \u03b1]", "{\u03b1}", "[Mul \u03b1] [Zero \u03b1]", "[Preorder \u03b1] {a b c d : \u03b1}", "[@Std.Commutative \u03b1 (\u00b7 * \u00b7)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 PosMulReflectLT \u03b1 \u2194 MulPosReflectLT \u03b1"}, {"line": "simp only [posMulReflectLT_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 \u2264 x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2) \u2194 MulPosReflectLT \u03b1"}, {"line": "simp only [mulPosReflectLT_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 \u2264 x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2) \u2194\n    ContravariantClass { x // 0 \u2264 x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 < x2"}, {"line": "simp only [Std.Commutative.comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2076 : Mul \u03b1\ninst\u271d\u2075 : Zero \u03b1\ninst\u271d\u2074 : Preorder \u03b1\ninst\u271d\u00b3 : Mul \u03b1\ninst\u271d\u00b2 : Zero \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Std.Commutative fun x1 x2 => x1 * x2\n\u22a2 (ContravariantClass { x // 0 \u2264 x } \u03b1 (fun x y => y * \u2191x) fun x1 x2 => x1 < x2) \u2194\n    ContravariantClass { x // 0 \u2264 x } \u03b1 (fun x y => \u2191x * y) fun x1 x2 => x1 < x2"}]}
{"declaration": "theorem refl_apply (x : \u03b1) : OrderRingIso.refl \u03b1 x = x := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Hom/Ring.lean", "context": {"open": ["Function"], "variables": ["{F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]", "[EquivLike F \u03b1 \u03b2]", "[NonAssocSemiring \u03b1] [Preorder \u03b1]", "[NonAssocSemiring \u03b2] [Preorder \u03b2] [NonAssocSemiring \u03b3] [Preorder \u03b3] [NonAssocSemiring \u03b4]", "(\u03b1)", "{\u03b1}", "[NonAssocSemiring \u03b2]", "[Mul \u03b1] [Add \u03b1] [LE \u03b1] [Mul \u03b2] [Add \u03b2] [LE \u03b2] [Mul \u03b3] [Add \u03b3] [LE \u03b3]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : NonAssocSemiring \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Mul \u03b1\ninst\u271d\u00b9 : Add \u03b1\ninst\u271d : LE \u03b1\nx : \u03b1\n\u22a2 (OrderRingIso.refl \u03b1) x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_map_mul_map_div [Group \u03b1] [CommMagma \u03b2] [LE \u03b2] [SubmultiplicativeHomClass F \u03b1 \u03b2]\n    (f : F) (a b : \u03b1) : f a \u2264 f b * f (a / b) := by\n  simpa only [mul_comm, div_mul_cancel] using map_mul_le_mul f (a / b) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Hom/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : CommMagma \u03b2\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : SubmultiplicativeHomClass F \u03b1 \u03b2\nf : F\na b : \u03b1\n\u22a2 f a \u2264 f b * f (a / b)"}, {"line": "simpa only [mul_comm, div_mul_cancel] using map_mul_le_mul f (a / b) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_map_add_map_div [Group \u03b1] [AddCommMagma \u03b2] [LE \u03b2] [MulLEAddHomClass F \u03b1 \u03b2] (f : F)\n    (a b : \u03b1) : f a \u2264 f b + f (a / b) := by\n  simpa only [add_comm, div_mul_cancel] using map_mul_le_add f (a / b) b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Hom/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : AddCommMagma \u03b2\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : MulLEAddHomClass F \u03b1 \u03b2\nf : F\na b : \u03b1\n\u22a2 f a \u2264 f b + f (a / b)"}, {"line": "simpa only [add_comm, div_mul_cancel] using map_mul_le_add f (a / b) b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_map_div_mul_map_div [Group \u03b1] [Mul \u03b2] [LE \u03b2] [SubmultiplicativeHomClass F \u03b1 \u03b2]\n    (f : F) (a b c : \u03b1) : f (a / c) \u2264 f (a / b) * f (b / c) := by\n  simpa only [div_mul_div_cancel] using map_mul_le_mul f (a / b) (b / c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Hom/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : Mul \u03b2\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : SubmultiplicativeHomClass F \u03b1 \u03b2\nf : F\na b c : \u03b1\n\u22a2 f (a / c) \u2264 f (a / b) * f (b / c)"}, {"line": "simpa only [div_mul_div_cancel] using map_mul_le_mul f (a / b) (b / c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_map_div_add_map_div [Group \u03b1] [Add \u03b2] [LE \u03b2] [MulLEAddHomClass F \u03b1 \u03b2]\n    (f : F) (a b c : \u03b1) : f (a / c) \u2264 f (a / b) + f (b / c) := by\n    simpa only [div_mul_div_cancel] using map_mul_le_add f (a / b) (b / c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Hom/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b9 F \u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[FunLike F \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u2074 : FunLike F \u03b1 \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : Add \u03b2\ninst\u271d\u00b9 : LE \u03b2\ninst\u271d : MulLEAddHomClass F \u03b1 \u03b2\nf : F\na b c : \u03b1\n\u22a2 f (a / c) \u2264 f (a / b) + f (b / c)"}, {"line": "simpa only [div_mul_div_cancel] using map_mul_le_add f (a / b) (b / c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_eq_zero {x : Icc (0 : R) 1} : (x : R) = 0 \u2194 x = 0 := by\n  symm\n  exact Subtype.ext_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Interval/Set/Instances.lean", "context": {"open": ["Set"], "variables": ["{R : Type*}", "[Semiring R] [PartialOrder R] [IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx : \u2191(Icc 0 1)\n\u22a2 \u2191x = 0 \u2194 x = 0"}, {"line": "symm", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx : \u2191(Icc 0 1)\n\u22a2 x = 0 \u2194 \u2191x = 0"}, {"line": "exact Subtype.ext_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_eq_one {x : Icc (0 : R) 1} : (x : R) = 1 \u2194 x = 1 := by\n  symm\n  exact Subtype.ext_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Interval/Set/Instances.lean", "context": {"open": ["Set"], "variables": ["{R : Type*}", "[Semiring R] [PartialOrder R] [IsOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx : \u2191(Icc 0 1)\n\u22a2 \u2191x = 1 \u2194 x = 1"}, {"line": "symm", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsOrderedRing R\nx : \u2191(Icc 0 1)\n\u22a2 x = 1 \u2194 \u2191x = 1"}, {"line": "exact Subtype.ext_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_eq_one {x : Ioc (0 : R) 1} : (x : R) = 1 \u2194 x = 1 := by\n  symm\n  exact Subtype.ext_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Interval/Set/Instances.lean", "context": {"open": ["Set"], "variables": ["{R : Type*}", "[Semiring R] [PartialOrder R] [IsOrderedRing R]", "{\u03b2 : Type*} [Ring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2]", "[Semiring R] [PartialOrder R] [IsStrictOrderedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : IsOrderedRing R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsStrictOrderedRing R\nx : \u2191(Ioc 0 1)\n\u22a2 \u2191x = 1 \u2194 x = 1"}, {"line": "symm", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : Semiring R\ninst\u271d\u2074 : PartialOrder R\ninst\u271d\u00b3 : IsOrderedRing R\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : PartialOrder R\ninst\u271d : IsStrictOrderedRing R\nx : \u2191(Ioc 0 1)\n\u22a2 x = 1 \u2194 \u2191x = 1"}, {"line": "exact Subtype.ext_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_sub_mem {t : \u03b2} (ht : t \u2208 Ioo (0 : \u03b2) 1) : 1 - t \u2208 Ioo (0 : \u03b2) 1 := by\n  rw [mem_Ioo] at *\n  refine \u27e8sub_pos.2 ht.2, ?_\u27e9\n  exact lt_of_le_of_ne ((sub_le_self_iff 1).2 ht.1.le) (mt sub_eq_self.mp ht.1.ne')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Interval/Set/Instances.lean", "context": {"open": ["Set"], "variables": ["{R : Type*}", "[Semiring R] [PartialOrder R] [IsOrderedRing R]", "{\u03b2 : Type*} [Ring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2]", "[Semiring R] [PartialOrder R] [IsStrictOrderedRing R]", "{\u03b2 : Type*} [Ring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nt : \u03b2\nht : t \u2208 Ioo 0 1\n\u22a2 1 - t \u2208 Ioo 0 1"}, {"line": "rw [mem_Ioo] at *", "tactic_state": "\u03b2 : Type u_3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nt : \u03b2\nht : 0 < t \u2227 t < 1\n\u22a2 0 < 1 - t \u2227 1 - t < 1"}, {"line": "refine \u27e8sub_pos.2 ht.2, ?_\u27e9", "tactic_state": "case refine_1\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nt : \u03b2\nht : 0 < t \u2227 t < 1\n\u22a2 AddRightStrictMono \u03b2\n---\ncase refine_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nt : \u03b2\nht : 0 < t \u2227 t < 1\n\u22a2 1 - t < 1"}, {"line": "exact lt_of_le_of_ne ((sub_le_self_iff 1).2 ht.1.le) (mt sub_eq_self.mp ht.1.ne')", "tactic_state": "case refine_2\n\u03b2 : Type u_3\ninst\u271d\u00b2 : Ring \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b2\ninst\u271d : IsOrderedRing \u03b2\nt : \u03b2\nht : 0 < t \u2227 t < 1\n\u22a2 1 - t < 1"}]}
{"declaration": "lemma algebraMap_nonneg (ha : 0 \u2264 a) : 0 \u2264 algebraMap \u03b1 \u03b2 a := by simpa using algebraMap_mono \u03b2 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Algebra.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [CommSemiring \u03b1] [PartialOrder \u03b1]", "(\u03b2)", "[Semiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2] [Algebra \u03b1 \u03b2] [SMulPosMono \u03b1 \u03b2] {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : CommSemiring \u03b1\ninst\u271d\u2075 : PartialOrder \u03b1\ninst\u271d\u2074 : Semiring \u03b2\ninst\u271d\u00b3 : PartialOrder \u03b2\ninst\u271d\u00b2 : IsOrderedRing \u03b2\ninst\u271d\u00b9 : Algebra \u03b1 \u03b2\ninst\u271d : SMulPosMono \u03b1 \u03b2\na : \u03b1\nha : 0 \u2264 a\n\u22a2 0 \u2264 (algebraMap \u03b1 \u03b2) a"}, {"line": "simpa using algebraMap_mono \u03b2 ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma algebraMap_pos (ha : 0 < a) : 0 < algebraMap \u03b1 \u03b2 a := by\n  simpa using algebraMap_strictMono \u03b2 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Algebra/Order/Module/Algebra.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [CommSemiring \u03b1] [PartialOrder \u03b1]", "(\u03b2)", "[Semiring \u03b2] [PartialOrder \u03b2] [IsOrderedRing \u03b2] [Algebra \u03b1 \u03b2] [SMulPosMono \u03b1 \u03b2] {a : \u03b1}", "[Semiring \u03b2] [PartialOrder \u03b2] [IsStrictOrderedRing \u03b2] [Algebra \u03b1 \u03b2]", "[SMulPosMono \u03b1 \u03b2] [SMulPosReflectLE \u03b1 \u03b2] {a\u2081 a\u2082 : \u03b1}", "[SMulPosStrictMono \u03b1 \u03b2] {a a\u2081 a\u2082 : \u03b1}", "(\u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b3 : CommSemiring \u03b1\ninst\u271d\u00b9\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9\u00b9 : Semiring \u03b2\ninst\u271d\u00b9\u2070 : PartialOrder \u03b2\ninst\u271d\u2079 : IsOrderedRing \u03b2\ninst\u271d\u2078 : Algebra \u03b1 \u03b2\ninst\u271d\u2077 : SMulPosMono \u03b1 \u03b2\ninst\u271d\u2076 : Semiring \u03b2\ninst\u271d\u2075 : PartialOrder \u03b2\ninst\u271d\u2074 : IsStrictOrderedRing \u03b2\ninst\u271d\u00b3 : Algebra \u03b1 \u03b2\ninst\u271d\u00b2 : SMulPosMono \u03b1 \u03b2\ninst\u271d\u00b9 : SMulPosReflectLE \u03b1 \u03b2\ninst\u271d : SMulPosStrictMono \u03b1 \u03b2\na : \u03b1\nha : 0 < a\n\u22a2 0 < (algebraMap \u03b1 \u03b2) a"}, {"line": "simpa using algebraMap_strictMono \u03b2 ha", "tactic_state": "No Goals!"}]}
