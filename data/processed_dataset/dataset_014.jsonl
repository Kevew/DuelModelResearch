{"declaration": "theorem cos_eq_zero_iff_angle_eq_pi_div_two : cos (angle x y) = 0 \u2194 angle x y = \u03c0 / 2 := by\n  rw [\u2190 cos_pi_div_two]\n  apply injOn_cos.eq_iff \u27e8angle_nonneg x y, angle_le_pi x y\u27e9\n  constructor <;> linarith [pi_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean", "context": {"open": ["Real Set", "Real", "RealInnerProductSpace"], "variables": ["{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nangle : x\u271d\n\u22a2 cos sorry = 0 \u2194 sorry = Real.pi / 2"}, {"line": "rw [\u2190 cos_pi_div_two]", "tactic_state": "x\u271d : Sort u_2\nangle : x\u271d\n\u22a2 cos sorry = cos (Real.pi / 2) \u2194 sorry = Real.pi / 2"}, {"line": "apply injOn_cos.eq_iff \u27e8angle_nonneg x y, angle_le_pi x y\u27e9", "tactic_state": "x\u271d : Sort u_2\nangle : x\u271d\n\u22a2 Real.pi / 2 \u2208 Icc 0 Real.pi"}, {"line": "constructor <;> linarith [pi_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_eq_neg_one_iff_angle_eq_pi : cos (angle x y) = -1 \u2194 angle x y = \u03c0 := by\n  rw [\u2190 cos_pi]\n  exact injOn_cos.eq_iff \u27e8angle_nonneg x y, angle_le_pi x y\u27e9 (right_mem_Icc.2 pi_pos.le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Unoriented/Basic.lean", "context": {"open": ["Real Set", "Real", "RealInnerProductSpace"], "variables": ["{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] {x y : V}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nangle : x\u271d\n\u22a2 cos sorry = -1 \u2194 sorry = Real.pi"}, {"line": "rw [\u2190 cos_pi]", "tactic_state": "x\u271d : Sort u_2\nangle : x\u271d\n\u22a2 cos sorry = cos Real.pi \u2194 sorry = Real.pi"}, {"line": "exact injOn_cos.eq_iff \u27e8angle_nonneg x y, angle_le_pi x y\u27e9 (right_mem_Icc.2 pi_pos.le)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem DifferentiableAt.inversion (hc : DifferentiableAt \u211d c a)\n    (hR : DifferentiableAt \u211d R a) (hx : DifferentiableAt \u211d x a) (hne : x a \u2260 c a) :\n    DifferentiableAt \u211d (fun a \u21a6 inversion (c a) (R a) (x a)) a := by\n  rw [\u2190 differentiableWithinAt_univ] at *\n  exact hc.inversion hR hx hne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Inversion/Calculus.lean", "context": {"open": ["Metric Function AffineMap Set AffineSubspace", "scoped Topology RealInnerProductSpace", "EuclideanGeometry"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{c x : E \u2192 F} {R : E \u2192 \u211d} {s : Set E} {a : E} {n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nc x : E \u2192 F\nR : E \u2192 \u211d\na : E\nhc : sorry\nhR : DifferentiableAt \u211d R a\nhx : sorry\nhne : x a \u2260 c a\n\u22a2 sorry"}, {"line": "rw [\u2190 differentiableWithinAt_univ] at *", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nc x : E \u2192 F\nR : E \u2192 \u211d\na : E\nhc : sorry\nhR : DifferentiableWithinAt \u211d R univ a\nhx : sorry\nhne : x a \u2260 c a\n\u22a2 sorry"}, {"line": "exact hc.inversion hR hx hne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inversion_self (c : P) (R : \u211d) : inversion c R c = c := by simp [inversion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "context": {"open": ["Metric Function AffineMap Set AffineSubspace", "scoped Topology"], "variables": ["{V P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "{c x y : P} {R : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\ninversion : x\u271d\nc : P\nR : \u211d\n\u22a2 sorry = c"}, {"line": "simp [inversion]", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\ninversion : x\u271d\nc : P\nR : \u211d\n\u22a2 sorry () = c"}]}
{"declaration": "theorem inversion_zero_radius (c x : P) : inversion c 0 x = c := by simp [inversion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "context": {"open": ["Metric Function AffineMap Set AffineSubspace", "scoped Topology"], "variables": ["{V P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "{c x y : P} {R : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\ninversion : x\u271d\nc x : P\n\u22a2 sorry = c"}, {"line": "simp [inversion]", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\ninversion : x\u271d\nc x : P\n\u22a2 sorry () = c"}]}
{"declaration": "theorem inversion_eq_center' : inversion c R x = c \u2194 x = c \u2228 R = 0 := by\n  by_cases hR : R = 0 <;> simp [inversion_eq_center, hR]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Inversion/Basic.lean", "context": {"open": ["Metric Function AffineMap Set AffineSubspace", "scoped Topology"], "variables": ["{V P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "{c x y : P} {R : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nc x : P\nR : \u211d\nx\u271d : Sort u_3\ninversion : x\u271d\n\u22a2 sorry = c \u2194 x = c \u2228 R = 0"}, {"line": "by_cases hR : R = 0 <;> simp [inversion_eq_center, hR]", "tactic_state": "case pos\nP : Type u_2\ninst\u271d : MetricSpace P\nc x : P\nR : \u211d\nx\u271d : Sort u_3\ninversion : x\u271d\nhR : R = 0\n\u22a2 sorry () = c\n---\ncase neg\nP : Type u_2\ninst\u271d : MetricSpace P\nc x : P\nR : \u211d\nx\u271d : Sort u_3\ninversion : x\u271d\nhR : \u00acR = 0\n\u22a2 sorry () = c \u2194 x = c"}]}
{"declaration": "theorem mul_dist_eq_mul_dist_of_cospherical_of_angle_eq_pi {a b c d p : P}\n    (h : Cospherical ({a, b, c, d} : Set P)) (hapb : \u2220 a p b = \u03c0) (hcpd : \u2220 c p d = \u03c0) :\n    dist a p * dist b p = dist c p * dist d p := by\n  obtain \u27e8-, k\u2081, _, hab\u27e9 := angle_eq_pi_iff.mp hapb\n  obtain \u27e8-, k\u2082, _, hcd\u27e9 := angle_eq_pi_iff.mp hcpd\n  exact mul_dist_eq_mul_dist_of_cospherical h \u27e8k\u2081, by linarith, hab\u27e9 \u27e8k\u2082, by linarith, hcd\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Sphere/Power.lean", "context": {"open": ["Real", "EuclideanGeometry RealInnerProductSpace Real", "InnerProductGeometry"], "variables": ["{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V]", "{P : Type*} [MetricSpace P] [NormedAddTorsor V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\nP : Type u_2\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\na b c d p : P\nh : Cospherical {a, b, c, d}\nhapb : EuclideanGeometry.angle a p b = Real.pi\nhcpd : EuclideanGeometry.angle c p d = Real.pi\n\u22a2 dist a p * dist b p = dist c p * dist d p"}, {"line": "obtain \u27e8-, k\u2081, _, hab\u27e9 := angle_eq_pi_iff.mp hapb", "tactic_state": "case intro.intro.intro\nV : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\nP : Type u_2\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\na b c d p : P\nh : Cospherical {a, b, c, d}\nhapb : EuclideanGeometry.angle a p b = Real.pi\nhcpd : EuclideanGeometry.angle c p d = Real.pi\nk\u2081 : \u211d\nleft\u271d : k\u2081 < 0\nhab : b -\u1d65 p = k\u2081 \u2022 (a -\u1d65 p)\n\u22a2 dist a p * dist b p = dist c p * dist d p"}, {"line": "obtain \u27e8-, k\u2082, _, hcd\u27e9 := angle_eq_pi_iff.mp hcpd", "tactic_state": "case intro.intro.intro.intro.intro.intro\nV : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup V\ninst\u271d\u00b2 : InnerProductSpace \u211d V\nP : Type u_2\ninst\u271d\u00b9 : MetricSpace P\ninst\u271d : NormedAddTorsor V P\na b c d p : P\nh : Cospherical {a, b, c, d}\nhapb : EuclideanGeometry.angle a p b = Real.pi\nhcpd : EuclideanGeometry.angle c p d = Real.pi\nk\u2081 : \u211d\nleft\u271d\u00b9 : k\u2081 < 0\nhab : b -\u1d65 p = k\u2081 \u2022 (a -\u1d65 p)\nk\u2082 : \u211d\nleft\u271d : k\u2082 < 0\nhcd : d -\u1d65 p = k\u2082 \u2022 (c -\u1d65 p)\n\u22a2 dist a p * dist b p = dist c p * dist d p"}, {"line": "exact mul_dist_eq_mul_dist_of_cospherical h \u27e8k\u2081, by linarith, hab\u27e9 \u27e8k\u2082, by linarith, hcd\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Sphere.secondInter_zero (s : Sphere P) (p : P) : s.secondInter p (0 : V) = p := by\n  simp [Sphere.secondInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Sphere/SecondInter.lean", "context": {"open": ["RealInnerProductSpace"], "variables": ["{V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "(V) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\nSphere : x\u271d\ns : sorry\np : P\n\u22a2 sorry = p"}, {"line": "simp [Sphere.secondInter]", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\nx\u271d : Sort u_3\nSphere : x\u271d\ns : sorry\np : P\n\u22a2 sorry () = p"}]}
{"declaration": "lemma IsDiameter.dist_left_right_div_two (h : s.IsDiameter p\u2081 p\u2082) :\n    (dist p\u2081 p\u2082) / 2 = s.radius := by\n  simp [h.dist_left_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Sphere/Basic.lean", "context": {"open": ["RealInnerProductSpace", "Module"], "variables": ["{V : Type*} (P : Type*)", "{P}", "[MetricSpace P]", "[NormedAddCommGroup V] [NormedSpace \u211d V] [MetricSpace P] [NormedAddTorsor V P]", "{s : Sphere P} {p\u2081 p\u2082 p\u2083 : P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Sphere : ?m.1747\nV : Type u_1\nP\u271d : Type u_2\ninst\u271d\u2076 : MetricSpace P\u271d\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : NormedSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\u271d\ninst\u271d\u00b2 : NormedAddTorsor V P\u271d\ns : sorry\np\u2081\u271d p\u2082\u271d p\u2083 : P\u271d\nP : Type u_2\ninst\u271d\u00b9 inst\u271d : MetricSpace P\np\u2081 p\u2082 : P\nh : sorry\n\u22a2 dist p\u2081 p\u2082 / 2 = sorry"}, {"line": "simp [h.dist_left_right]", "tactic_state": "Sphere : ?m.1747\nV : Type u_1\nP\u271d : Type u_2\ninst\u271d\u2076 : MetricSpace P\u271d\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : NormedSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\u271d\ninst\u271d\u00b2 : NormedAddTorsor V P\u271d\ns : sorry\np\u2081\u271d p\u2082\u271d p\u2083 : P\u271d\nP : Type u_2\ninst\u271d\u00b9 inst\u271d : MetricSpace P\np\u2081 p\u2082 : P\nh : sorry\n\u22a2 dist p\u2081 p\u2082 / 2 = sorry ()"}]}
{"declaration": "lemma pow_right_strictMonoOn (hX\u2081 : 1 \u2208 X) (hX : X.Nontrivial) :\n    StrictMonoOn (fun n \u21a6 X ^ n) {n | (X ^ (n - 1) : Set G) \u2260 closure (X : Set G)} := by\n  refine strictMonoOn_of_lt_add_one \u27e8?_\u27e9 fun n _ _ hn \u21a6\n    pow_ssubset_pow_succ_of_pow_ne_closure hX\u2081 hX hn\n  rintro - - n hn m \u27e8-, hmn\u27e9 hm\n  apply hn\n  obtain rfl | hm\u2080 := m.eq_zero_or_pos\n  \u00b7 simp [eq_comm (a := (1 : Set _)), coe_set_eq_one, -Set.subset_singleton_iff,\n      hX.coe.not_subset_singleton] at hm\n  \u00b7 calc (X : Set G) ^ (n - 1)\n    _ = X ^ (n - m) * X ^ (m - 1) := by rw [\u2190 pow_add]; congr 1; omega\n    _ = closure (X : Set G) := by rw [hm, Set.pow_mul_subgroupClosure hX.nonempty.to_set]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Group/Growth/LinearLowerBound.lean", "context": {"open": ["Subgroup", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] [DecidableEq G] {X : Finset G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\n\u22a2 StrictMonoOn (fun n => X ^ n) {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}"}, {"line": "refine strictMonoOn_of_lt_add_one \u27e8?_\u27e9 fun n _ _ hn \u21a6\n    pow_ssubset_pow_succ_of_pow_ne_closure hX\u2081 hX hn", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\n\u22a2 \u2200 \u2983x : \u2115\u2984,\n    x \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)} \u2192\n      \u2200 \u2983y : \u2115\u2984,\n        y \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)} \u2192 Set.Icc x y \u2286 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}"}, {"line": "rintro - - n hn m \u27e8-, hmn\u27e9 hm", "tactic_state": "case intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\nn : \u2115\nhn : n \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}\nm : \u2115\nhmn : m \u2264 n\nhm : \u2191X ^ (m - 1) = \u2191(Subgroup.closure \u2191X)\n\u22a2 False"}, {"line": "apply hn", "tactic_state": "case intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\nn : \u2115\nhn : n \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}\nm : \u2115\nhmn : m \u2264 n\nhm : \u2191X ^ (m - 1) = \u2191(Subgroup.closure \u2191X)\n\u22a2 \u2191X ^ (n - 1) = \u2191(Subgroup.closure \u2191X)"}, {"line": "obtain rfl | hm\u2080 := m.eq_zero_or_pos", "tactic_state": "case intro.inl\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\nn : \u2115\nhn : n \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}\nhmn : 0 \u2264 n\nhm : \u2191X ^ (0 - 1) = \u2191(Subgroup.closure \u2191X)\n\u22a2 \u2191X ^ (n - 1) = \u2191(Subgroup.closure \u2191X)\n---\ncase intro.inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\nn : \u2115\nhn : n \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}\nm : \u2115\nhmn : m \u2264 n\nhm : \u2191X ^ (m - 1) = \u2191(Subgroup.closure \u2191X)\nhm\u2080 : m > 0\n\u22a2 \u2191X ^ (n - 1) = \u2191(Subgroup.closure \u2191X)"}, {"line": "\u00b7 simp [eq_comm (a := (1 : Set _)), coe_set_eq_one, -Set.subset_singleton_iff,\n      hX.coe.not_subset_singleton] at hm", "tactic_state": "case intro.inr\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : DecidableEq G\nX : Finset G\nhX\u2081 : 1 \u2208 X\nhX : X.Nontrivial\nn : \u2115\nhn : n \u2208 {n | \u2191X ^ (n - 1) \u2260 \u2191(Subgroup.closure \u2191X)}\nm : \u2115\nhmn : m \u2264 n\nhm : \u2191X ^ (m - 1) = \u2191(Subgroup.closure \u2191X)\nhm\u2080 : m > 0\n\u22a2 \u2191X ^ (n - 1) = \u2191(Subgroup.closure \u2191X)"}, {"line": "\u00b7 calc (X : Set G) ^ (n - 1)\n    _ = X ^ (n - m) * X ^ (m - 1) := by rw [\u2190 pow_add]; congr 1; omega\n    _ = closure (X : Set G) := by rw [hm, Set.pow_mul_subgroupClosure hX.nonempty.to_set]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem groupoid_of_pregroupoid_le (PG\u2081 PG\u2082 : Pregroupoid H)\n    (h : \u2200 f s, PG\u2081.property f s \u2192 PG\u2082.property f s) : PG\u2081.groupoid \u2264 PG\u2082.groupoid := by\n  refine StructureGroupoid.le_iff.2 fun e he \u21a6 ?_\n  rw [mem_groupoid_of_pregroupoid] at he \u22a2\n  exact \u27e8h _ _ he.1, h _ _ he.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nPG\u2081 PG\u2082 : Pregroupoid H\nh : \u2200 (f : H \u2192 H) (s : Set H), PG\u2081.property f s \u2192 PG\u2082.property f s\n\u22a2 PG\u2081.groupoid \u2264 PG\u2082.groupoid"}, {"line": "refine StructureGroupoid.le_iff.2 fun e he \u21a6 ?_", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nPG\u2081 PG\u2082 : Pregroupoid H\nh : \u2200 (f : H \u2192 H) (s : Set H), PG\u2081.property f s \u2192 PG\u2082.property f s\ne : PartialHomeomorph H H\nhe : e \u2208 PG\u2081.groupoid\n\u22a2 e \u2208 PG\u2082.groupoid"}, {"line": "rw [mem_groupoid_of_pregroupoid] at he \u22a2", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nPG\u2081 PG\u2082 : Pregroupoid H\nh : \u2200 (f : H \u2192 H) (s : Set H), PG\u2081.property f s \u2192 PG\u2082.property f s\ne : PartialHomeomorph H H\nhe : PG\u2081.property (\u2191e) e.source \u2227 PG\u2081.property (\u2191e.symm) e.target\n\u22a2 PG\u2082.property (\u2191e) e.source \u2227 PG\u2082.property (\u2191e.symm) e.target"}, {"line": "exact \u27e8h _ _ he.1, h _ _ he.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_pregroupoid_of_eqOnSource (PG : Pregroupoid H) {e e' : PartialHomeomorph H H}\n    (he' : e \u2248 e') (he : PG.property e e.source) : PG.property e' e'.source := by\n  rw [\u2190 he'.1]\n  exact PG.congr e.open_source he'.eqOn.symm he\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nPG : Pregroupoid H\ne e' : PartialHomeomorph H H\nhe' : e \u2248 e'\nhe : PG.property (\u2191e) e.source\n\u22a2 PG.property (\u2191e') e'.source"}, {"line": "rw [\u2190 he'.1]", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nPG : Pregroupoid H\ne e' : PartialHomeomorph H H\nhe' : e \u2248 e'\nhe : PG.property (\u2191e) e.source\n\u22a2 PG.property (\u2191e') e.source"}, {"line": "exact PG.congr e.open_source he'.eqOn.symm he", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closedUnderRestriction_iff_id_le (G : StructureGroupoid H) :\n    ClosedUnderRestriction G \u2194 idRestrGroupoid \u2264 G := by\n  constructor\n  \u00b7 intro _i\n    rw [StructureGroupoid.le_iff]\n    rintro e \u27e8s, hs, hes\u27e9\n    refine G.mem_of_eqOnSource ?_ hes\n    convert closedUnderRestriction' G.id_mem hs\n    -- Porting note: was\n    -- change s = _ \u2229 _\n    -- rw [hs.interior_eq]\n    -- simp only [mfld_simps]\n    ext\n    \u00b7 rw [PartialHomeomorph.restr_apply, PartialHomeomorph.refl_apply, id, ofSet_apply, id_eq]\n    \u00b7 simp [hs]\n    \u00b7 simp [hs.interior_eq]\n  \u00b7 intro h\n    constructor\n    intro e he s hs\n    rw [\u2190 ofSet_trans (e : PartialHomeomorph H H) hs]\n    refine G.trans ?_ he\n    apply StructureGroupoid.le_iff.mp h\n    exact idRestrGroupoid_mem hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\ninst\u271d : TopologicalSpace H\nG : StructureGroupoid H\n\u22a2 ClosedUnderRestriction G \u2194 idRestrGroupoid \u2264 G"}, {"line": "constructor", "tactic_state": "case mp\nH : Type u\ninst\u271d : TopologicalSpace H\nG : StructureGroupoid H\n\u22a2 ClosedUnderRestriction G \u2192 idRestrGroupoid \u2264 G\n---\ncase mpr\nH : Type u\ninst\u271d : TopologicalSpace H\nG : StructureGroupoid H\n\u22a2 idRestrGroupoid \u2264 G \u2192 ClosedUnderRestriction G"}, {"line": "\u00b7 intro _i\n    rw [StructureGroupoid.le_iff]\n    rintro e \u27e8s, hs, hes\u27e9\n    refine G.mem_of_eqOnSource ?_ hes\n    convert closedUnderRestriction' G.id_mem hs\n    ext\n    \u00b7 rw [PartialHomeomorph.restr_apply, PartialHomeomorph.refl_apply, id, ofSet_apply, id_eq]\n    \u00b7 simp [hs]\n    \u00b7 simp [hs.interior_eq]", "tactic_state": "case mpr\nH : Type u\ninst\u271d : TopologicalSpace H\nG : StructureGroupoid H\n\u22a2 idRestrGroupoid \u2264 G \u2192 ClosedUnderRestriction G"}, {"line": "\u00b7 intro h\n    constructor\n    intro e he s hs\n    rw [\u2190 ofSet_trans (e : PartialHomeomorph H H) hs]\n    refine G.trans ?_ he\n    apply StructureGroupoid.le_iff.mp h\n    exact idRestrGroupoid_mem hs", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isEmpty_of_chartedSpace (H : Type*) {M : Type*} [TopologicalSpace H] [TopologicalSpace M]\n    [ChartedSpace H M] [IsEmpty H] : IsEmpty M := by\n  rcases isEmpty_or_nonempty M with hM | \u27e8\u27e8x\u27e9\u27e9\n  \u00b7 exact hM\n  \u00b7 exact (IsEmpty.false (chartAt H x x)).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : IsEmpty H\n\u22a2 IsEmpty M"}, {"line": "rcases isEmpty_or_nonempty M with hM | \u27e8\u27e8x\u27e9\u27e9", "tactic_state": "case inl\nH : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : IsEmpty H\nhM : IsEmpty M\n\u22a2 IsEmpty M\n---\ncase inr.intro\nH : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : IsEmpty H\nx : M\n\u22a2 IsEmpty M"}, {"line": "\u00b7 exact hM", "tactic_state": "case inr.intro\nH : Type u_5\nM : Type u_6\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : IsEmpty H\nx : M\n\u22a2 IsEmpty M"}, {"line": "\u00b7 exact (IsEmpty.false (chartAt H x x)).elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ChartedSpace.secondCountable_of_countable_cover [SecondCountableTopology H] {s : Set M}\n    (hs : \u22c3 (x) (_ : x \u2208 s), (chartAt H x).source = univ) (hsc : s.Countable) :\n    SecondCountableTopology M := by\n  haveI : \u2200 x : M, SecondCountableTopology (chartAt H x).source :=\n    fun x \u21a6 (chartAt (H := H) x).secondCountableTopology_source\n  haveI := hsc.toEncodable\n  rw [biUnion_eq_iUnion] at hs\n  exact secondCountableTopology_of_countable_cover (fun x : s \u21a6 (chartAt H (x : M)).open_source) hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhsc : s.Countable\n\u22a2 SecondCountableTopology M"}, {"line": "haveI : \u2200 x : M, SecondCountableTopology (chartAt H x).source :=\n    fun x \u21a6 (chartAt (H := H) x).secondCountableTopology_source", "tactic_state": "case refine_2\nH : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhsc : s.Countable\nthis : \u2200 (x : M), SecondCountableTopology sorry\n\u22a2 SecondCountableTopology M\n---\ncase refine_1\nH : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhsc : s.Countable\n\u22a2 M \u2192 TopologicalSpace sorry"}, {"line": "haveI := hsc.toEncodable", "tactic_state": "case refine_2\nH : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhsc : s.Countable\nthis\u271d : \u2200 (x : M), SecondCountableTopology sorry\nthis : Encodable \u2191s\n\u22a2 SecondCountableTopology M\n---\ncase refine_1\nH : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhsc : s.Countable\n\u22a2 M \u2192 TopologicalSpace sorry"}, {"line": "rw [biUnion_eq_iUnion] at hs", "tactic_state": "case refine_2\nH : Type u\nM : Type u_2\ninst\u271d\u2074 inst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\ninst\u271d : SecondCountableTopology H\ns : Set M\nhs\u271d : \u22c3 x \u2208 s, (chartAt H x).source = univ\nhs : \u22c3 x, (chartAt H \u2191x).source = univ\nhsc : s.Countable\nthis\u271d : \u2200 (x : M), SecondCountableTopology sorry\nthis : Encodable \u2191s\n\u22a2 SecondCountableTopology M"}, {"line": "exact secondCountableTopology_of_countable_cover (fun x : s \u21a6 (chartAt H (x : M)).open_source) hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem modelProd_range_prod_id {H : Type*} {H' : Type*} {\u03b1 : Type*} (f : H \u2192 \u03b1) :\n    (range fun p : ModelProd H H' \u21a6 (f p.1, p.2)) = range f \u00d7\u02e2 (univ : Set H') := by\n  rw [prod_range_univ_eq]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_5\nH' : Type u_6\n\u03b1 : Type u_7\nf : H \u2192 \u03b1\n\u22a2 (range fun p => (f p.1, p.2)) = range f \u00d7\u02e2 univ"}, {"line": "rw [prod_range_univ_eq]", "tactic_state": "H : Type u_5\nH' : Type u_6\n\u03b1 : Type u_7\nf : H \u2192 \u03b1\n\u22a2 (range fun p => (f p.1, p.2)) = range fun p => (f p.1, p.2)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem open_target (he : e \u2208 c.atlas) : IsOpen e.target := by\n  have E : e.target \u2229 e.symm \u207b\u00b9' e.source = e.target :=\n    Subset.antisymm inter_subset_left fun x hx \u21a6\n      \u27e8hx, PartialEquiv.target_subset_preimage_source _ hx\u27e9\n  simpa [PartialEquiv.trans_source, E] using c.open_source e e he he\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace", "scoped Classical in"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in", "(M)", "{\u03b9 : Type*} {Hi : \u03b9 \u2192 Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] [TopologicalSpace H']", "[TopologicalSpace H] [TopologicalSpace M] [TopologicalSpace M']", "[TopologicalSpace H] (c : ChartedSpaceCore H M) {e : PartialEquiv M H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\nH : Type u_3\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : TopologicalSpace H\nc : ChartedSpaceCore H M\ne : PartialEquiv M H\nhe : e \u2208 c.atlas\n\u22a2 IsOpen e.target"}, {"line": "have E : e.target \u2229 e.symm \u207b\u00b9' e.source = e.target :=\n    Subset.antisymm inter_subset_left fun x hx \u21a6\n      \u27e8hx, PartialEquiv.target_subset_preimage_source _ hx\u27e9", "tactic_state": "M : Type u_4\nH : Type u_3\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : TopologicalSpace H\nc : ChartedSpaceCore H M\ne : PartialEquiv M H\nhe : e \u2208 c.atlas\nE : e.target \u2229 \u2191e.symm \u207b\u00b9' e.source = e.target\n\u22a2 IsOpen e.target"}, {"line": "simpa [PartialEquiv.trans_source, E] using c.open_source e e he he", "tactic_state": "No Goals!"}]}
{"declaration": "lemma StructureGroupoid.mem_maximalAtlas_of_eqOnSource {e e' : PartialHomeomorph M H} (h : e' \u2248 e)\n    (he : e \u2208 G.maximalAtlas M) : e' \u2208 G.maximalAtlas M := by\n  intro e'' he''\n  obtain \u27e8l, r\u27e9 := mem_maximalAtlas_iff.mp he e'' he''\n  exact \u27e8G.mem_of_eqOnSource l (EqOnSource.trans' (EqOnSource.symm' h) (e''.eqOnSource_refl)),\n         G.mem_of_eqOnSource r (EqOnSource.trans' (e''.symm).eqOnSource_refl h)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace", "scoped Classical in", "PartialHomeomorph in"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in", "(M)", "{\u03b9 : Type*} {Hi : \u03b9 \u2192 Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] [TopologicalSpace H']", "[TopologicalSpace H] [TopologicalSpace M] [TopologicalSpace M']", "[TopologicalSpace H] (c : ChartedSpaceCore H M) {e : PartialEquiv M H}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(G : StructureGroupoid H)", "(M) in", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\nH : Type u_4\ninst\u271d\u00b9\u00b9 : TopologicalSpace H\ninst\u271d\u00b9\u2070 : TopologicalSpace M\ninst\u271d\u2079 : ChartedSpace H M\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nG : StructureGroupoid H\ne e' : PartialHomeomorph M H\nh : e' \u2248 e\nhe : e \u2208 maximalAtlas M G\n\u22a2 e' \u2208 maximalAtlas M G"}, {"line": "intro e'' he''", "tactic_state": "M : Type u_3\nH : Type u_4\ninst\u271d\u00b9\u00b9 : TopologicalSpace H\ninst\u271d\u00b9\u2070 : TopologicalSpace M\ninst\u271d\u2079 : ChartedSpace H M\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nG : StructureGroupoid H\ne e' : PartialHomeomorph M H\nh : e' \u2248 e\nhe : e \u2208 maximalAtlas M G\ne'' : PartialHomeomorph M H\nhe'' : e'' \u2208 atlas H M\n\u22a2 e'.symm.trans e'' \u2208 G \u2227 e''.symm.trans e' \u2208 G"}, {"line": "obtain \u27e8l, r\u27e9 := mem_maximalAtlas_iff.mp he e'' he''", "tactic_state": "case intro\nM : Type u_3\nH : Type u_4\ninst\u271d\u00b9\u00b9 : TopologicalSpace H\ninst\u271d\u00b9\u2070 : TopologicalSpace M\ninst\u271d\u2079 : ChartedSpace H M\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nG : StructureGroupoid H\ne e' : PartialHomeomorph M H\nh : e' \u2248 e\nhe : e \u2208 maximalAtlas M G\ne'' : PartialHomeomorph M H\nhe'' : e'' \u2208 atlas H M\nl : e.symm.trans e'' \u2208 G\nr : e''.symm.trans e \u2208 G\n\u22a2 e'.symm.trans e'' \u2208 G \u2227 e''.symm.trans e' \u2208 G"}, {"line": "exact \u27e8G.mem_of_eqOnSource l (EqOnSource.trans' (EqOnSource.symm' h) (e''.eqOnSource_refl)),\n         G.mem_of_eqOnSource r (EqOnSource.trans' (e''.symm).eqOnSource_refl h)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma chart_eq {s : Opens M} (hs : Nonempty s) {e : PartialHomeomorph s H} (he : e \u2208 atlas H s) :\n    \u2203 x : s, e = (chartAt H (x : M)).subtypeRestr hs := by\n  rcases he with \u27e8xset, \u27e8x, hx\u27e9, he\u27e9\n  exact \u27e8x, mem_singleton_iff.mp (by convert he)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace", "scoped Classical in", "PartialHomeomorph in", "TopologicalSpace"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in", "(M)", "{\u03b9 : Type*} {Hi : \u03b9 \u2192 Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] [TopologicalSpace H']", "[TopologicalSpace H] [TopologicalSpace M] [TopologicalSpace M']", "[TopologicalSpace H] (c : ChartedSpaceCore H M) {e : PartialEquiv M H}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(G : StructureGroupoid H)", "(M) in", "{G}", "(G)", "{\u03b1 : Type*} [TopologicalSpace \u03b1]", "(e : PartialHomeomorph \u03b1 H)", "[Nonempty \u03b1]", "(G : StructureGroupoid H) [HasGroupoid M G]", "(s : Opens M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\nM : Type u_2\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : TopologicalSpace H\ninst\u271d\u00b9\u2070 : TopologicalSpace M\ninst\u271d\u2079 : ChartedSpace H M\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\ns : Opens M\nhs : Nonempty \u21a5s\ne : PartialHomeomorph (\u21a5s) H\nhe : e \u2208 atlas H \u21a5s\n\u22a2 \u2203 x, e = (chartAt H \u2191x).subtypeRestr hs"}, {"line": "rcases he with \u27e8xset, \u27e8x, hx\u27e9, he\u27e9", "tactic_state": "case intro.intro.intro\nH : Type u\nM : Type u_2\ninst\u271d\u00b9\u00b2 inst\u271d\u00b9\u00b9 : TopologicalSpace H\ninst\u271d\u00b9\u2070 : TopologicalSpace M\ninst\u271d\u2079 : ChartedSpace H M\ninst\u271d\u2078 : TopologicalSpace H\ninst\u271d\u2077 : TopologicalSpace M\ninst\u271d\u2076 : ChartedSpace H M\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\ns : Opens M\nhs : Nonempty \u21a5s\ne : PartialHomeomorph (\u21a5s) H\nxset : Set (PartialHomeomorph (\u21a5s) H)\nhe : e \u2208 xset\nx : \u21a5s\nhx : (fun x => {(chartAt H \u2191x).subtypeRestr \u22ef}) x = xset\n\u22a2 \u2203 x, e = (chartAt H \u2191x).subtypeRestr hs"}, {"line": "exact \u27e8x, mem_singleton_iff.mp (by convert he)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma chart_eq' {t : Opens H} (ht : Nonempty t) {e' : PartialHomeomorph t H}\n    (he' : e' \u2208 atlas H t) : \u2203 x : t, e' = (chartAt H \u2191x).subtypeRestr ht := by\n  rcases he' with \u27e8xset, \u27e8x, hx\u27e9, he'\u27e9\n  exact \u27e8x, mem_singleton_iff.mp (by convert he')\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ChartedSpace.lean", "context": {"open": ["TopologicalSpace Topology", "Set PartialHomeomorph Manifold  -- Porting note: Added `Manifold`", "TopologicalSpace", "scoped Classical in", "PartialHomeomorph in", "TopologicalSpace"], "variables": ["{H : Type u} {H' : Type*} {M : Type*} {M' : Type*} {M'' : Type*}", "[TopologicalSpace H]", "(H) [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(M) in", "(M)", "{\u03b9 : Type*} {Hi : \u03b9 \u2192 Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M] [TopologicalSpace H']", "[TopologicalSpace H] [TopologicalSpace M] [TopologicalSpace M']", "[TopologicalSpace H] (c : ChartedSpaceCore H M) {e : PartialEquiv M H}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "(G : StructureGroupoid H)", "(M) in", "{G}", "(G)", "{\u03b1 : Type*} [TopologicalSpace \u03b1]", "(e : PartialHomeomorph \u03b1 H)", "[Nonempty \u03b1]", "(G : StructureGroupoid H) [HasGroupoid M G]", "(s : Opens M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace H\nt : Opens H\nht : Nonempty \u21a5t\ne' : PartialHomeomorph (\u21a5t) H\nhe' : e' \u2208 atlas H \u21a5t\n\u22a2 \u2203 x, e' = (chartAt H \u2191x).subtypeRestr ht"}, {"line": "rcases he' with \u27e8xset, \u27e8x, hx\u27e9, he'\u27e9", "tactic_state": "case intro.intro.intro\nH : Type u\ninst\u271d\u2075 inst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : TopologicalSpace H\nt : Opens H\nht : Nonempty \u21a5t\ne' : PartialHomeomorph (\u21a5t) H\nxset : Set (PartialHomeomorph (\u21a5t) H)\nhe' : e' \u2208 xset\nx : \u21a5t\nhx : (fun x => {(chartAt H \u2191x).subtypeRestr \u22ef}) x = xset\n\u22a2 \u2203 x, e' = (chartAt H \u2191x).subtypeRestr ht"}, {"line": "exact \u27e8x, mem_singleton_iff.mp (by convert he')\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftPropWithinAt_indep_chart [HasGroupoid M G] [HasGroupoid M' G']\n    (he : e \u2208 G.maximalAtlas M) (xe : x \u2208 e.source) (hf : f \u2208 G'.maximalAtlas M')\n    (xf : g x \u2208 f.source) :\n    LiftPropWithinAt P g s x \u2194\n    ContinuousWithinAt g s x \u2227 P (f \u2218 g \u2218 e.symm) (e.symm \u207b\u00b9' s) (e x) := by\n  simp only [liftPropWithinAt_iff']\n  exact and_congr_right <|\n    hG.liftPropWithinAt_indep_chart_aux (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) he xe\n      (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) hf xf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Manifold Topology", "ChartedSpace"], "variables": ["{H M H' M' X : Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "[TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M']", "[TopologicalSpace X]", "(G : StructureGroupoid H) (G' : StructureGroupoid H')", "{G G'} {P : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop}", "(hG : G.LocalInvariantProp G' P)", "{G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : PartialHomeomorph M H}", "(hG : G.LocalInvariantProp G' P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : ChartedSpace H M\ninst\u271d\u2074 : TopologicalSpace H'\ninst\u271d\u00b3 : TopologicalSpace M'\ninst\u271d\u00b2 : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nG : StructureGroupoid H\nG' : StructureGroupoid H'\ne : PartialHomeomorph M H\nx : M\nf : PartialHomeomorph M' H'\ng : M \u2192 M'\ns : Set M\ninst\u271d\u00b9 : HasGroupoid M G\ninst\u271d : HasGroupoid M' G'\nhe : e \u2208 StructureGroupoid.maximalAtlas M G\nxe : x \u2208 e.source\nhf : f \u2208 StructureGroupoid.maximalAtlas M' G'\nxf : g x \u2208 f.source\n\u22a2 LiftPropWithinAt P g s x \u2194 ContinuousWithinAt g s x \u2227 P (\u2191f \u2218 g \u2218 \u2191e.symm) (\u2191e.symm \u207b\u00b9' s) (\u2191e x)"}, {"line": "simp only [liftPropWithinAt_iff']", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : ChartedSpace H M\ninst\u271d\u2074 : TopologicalSpace H'\ninst\u271d\u00b3 : TopologicalSpace M'\ninst\u271d\u00b2 : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nG : StructureGroupoid H\nG' : StructureGroupoid H'\ne : PartialHomeomorph M H\nx : M\nf : PartialHomeomorph M' H'\ng : M \u2192 M'\ns : Set M\ninst\u271d\u00b9 : HasGroupoid M G\ninst\u271d : HasGroupoid M' G'\nhe : e \u2208 StructureGroupoid.maximalAtlas M G\nxe : x \u2208 e.source\nhf : f \u2208 StructureGroupoid.maximalAtlas M' G'\nxf : g x \u2208 f.source\n\u22a2 ContinuousWithinAt g s x \u2227\n      P (\u2191(chartAt H' (g x)) \u2218 g \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' s) (\u2191(chartAt H x) x) \u2194\n    ContinuousWithinAt g s x \u2227 P (\u2191f \u2218 g \u2218 \u2191e.symm) (\u2191e.symm \u207b\u00b9' s) (\u2191e x)"}, {"line": "exact and_congr_right <|\n    hG.liftPropWithinAt_indep_chart_aux (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) he xe\n      (chart_mem_maximalAtlas _ _) (mem_chart_source _ _) hf xf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftPropAt_symm_of_mem_maximalAtlas [HasGroupoid M G] {x : H}\n    (hG : G.LocalInvariantProp G Q) (hQ : \u2200 y, Q id univ y) (he : e \u2208 maximalAtlas M G)\n    (hx : x \u2208 e.target) : LiftPropAt Q e.symm x := by\n  suffices h : Q (e \u2218 e.symm) univ x by\n    have : e.symm x \u2208 e.source := by simp only [hx, mfld_simps]\n    rw [LiftPropAt]\n    rw [hG.liftPropWithinAt_indep_chart G.id_mem_maximalAtlas (mem_univ _) he this]\n    refine \u27e8(e.symm.continuousAt hx).continuousWithinAt, ?_\u27e9\n    simp only [h]\n    simp only [mfld_simps]\n  exact hG.congr' (e.eventually_right_inverse hx) (hQ x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Manifold Topology", "ChartedSpace"], "variables": ["{H M H' M' X : Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "[TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M']", "[TopologicalSpace X]", "(G : StructureGroupoid H) (G' : StructureGroupoid H')", "{G G'} {P : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop}", "(hG : G.LocalInvariantProp G' P)", "{G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : PartialHomeomorph M H}", "(hG : G.LocalInvariantProp G' P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\nG : StructureGroupoid H\ne : PartialHomeomorph M H\nQ : (H \u2192 H) \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nmaximalAtlas : x\u271d\ninst\u271d : HasGroupoid M G\nx : H\nhG : G.LocalInvariantProp G Q\nhQ : \u2200 (y : H), Q id univ y\nhe : e \u2208 sorry\nhx : x \u2208 e.target\n\u22a2 LiftPropAt Q (\u2191e.symm) x"}, {"line": "suffices h : Q (e \u2218 e.symm) univ x by\n    have : e.symm x \u2208 e.source := by simp only [hx, mfld_simps]\n    rw [LiftPropAt]\n    rw [hG.liftPropWithinAt_indep_chart G.id_mem_maximalAtlas (mem_univ _) he this]\n    refine \u27e8(e.symm.continuousAt hx).continuousWithinAt, ?_\u27e9\n    simp only [h]\n    simp only [mfld_simps]", "tactic_state": "H : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : TopologicalSpace H\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : ChartedSpace H M\nG : StructureGroupoid H\ne : PartialHomeomorph M H\nQ : (H \u2192 H) \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nmaximalAtlas : x\u271d\ninst\u271d : HasGroupoid M G\nx : H\nhG : G.LocalInvariantProp G Q\nhQ : \u2200 (y : H), Q id univ y\nhe : e \u2208 sorry\nhx : x \u2208 e.target\n\u22a2 Q (\u2191e \u2218 sorry) univ x"}, {"line": "exact hG.congr' (e.eventually_right_inverse hx) (hQ x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftProp_id (hG : G.LocalInvariantProp G Q) (hQ : \u2200 y, Q id univ y) :\n    LiftProp Q (id : M \u2192 M) := by\n  simp_rw [liftProp_iff, continuous_id, true_and]\n  exact fun x \u21a6 hG.congr' ((chartAt H x).eventually_right_inverse <| mem_chart_target H x) (hQ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Manifold Topology", "ChartedSpace"], "variables": ["{H M H' M' X : Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "[TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M']", "[TopologicalSpace X]", "(G : StructureGroupoid H) (G' : StructureGroupoid H')", "{G G'} {P : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop}", "(hG : G.LocalInvariantProp G' P)", "{G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : PartialHomeomorph M H}", "(hG : G.LocalInvariantProp G' P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nG : StructureGroupoid H\nQ : (H \u2192 H) \u2192 Set H \u2192 H \u2192 Prop\nhG : G.LocalInvariantProp G Q\nhQ : \u2200 (y : H), Q id univ y\n\u22a2 LiftProp Q id"}, {"line": "simp_rw [liftProp_iff, continuous_id, true_and]", "tactic_state": "H : Type u_1\nM : Type u_2\ninst\u271d\u00b2 : TopologicalSpace H\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ChartedSpace H M\nG : StructureGroupoid H\nQ : (H \u2192 H) \u2192 Set H \u2192 H \u2192 Prop\nhG : G.LocalInvariantProp G Q\nhQ : \u2200 (y : H), Q id univ y\n\u22a2 \u2200 (x : M), Q (\u2191(chartAt H (id x)) \u2218 id \u2218 \u2191(chartAt H x).symm) univ (\u2191(chartAt H x) x)"}, {"line": "exact fun x \u21a6 hG.congr' ((chartAt H x).eventually_right_inverse <| mem_chart_target H x) (hQ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftPropAt_iff_comp_subtype_val (hG : LocalInvariantProp G G' P) {U : Opens M}\n    (f : M \u2192 M') (x : U) :\n    LiftPropAt P f x \u2194 LiftPropAt P (f \u2218 Subtype.val) x := by\n  simp only [LiftPropAt]\n  simp only [liftPropWithinAt_iff']\n  congrm ?_ \u2227 ?_\n  \u00b7 simp_rw [continuousWithinAt_univ, U.isOpenEmbedding'.continuousAt_iff]\n  \u00b7 apply hG.congr_iff\n    exact (U.chartAt_subtype_val_symm_eventuallyEq).fun_comp (chartAt H' (f x) \u2218 f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Manifold Topology", "ChartedSpace"], "variables": ["{H M H' M' X : Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "[TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M']", "[TopologicalSpace X]", "(G : StructureGroupoid H) (G' : StructureGroupoid H')", "{G G'} {P : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop}", "(hG : G.LocalInvariantProp G' P)", "{G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : PartialHomeomorph M H}", "(hG : G.LocalInvariantProp G' P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 LiftPropAt P f \u2191x \u2194 LiftPropAt P (f \u2218 Subtype.val) x"}, {"line": "simp only [LiftPropAt]", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 LiftPropWithinAt P f univ \u2191x \u2194 LiftPropWithinAt P (f \u2218 Subtype.val) univ x"}, {"line": "simp only [liftPropWithinAt_iff']", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 ContinuousWithinAt f univ \u2191x \u2227\n      P (\u2191(chartAt H' (f \u2191x)) \u2218 f \u2218 \u2191(chartAt H \u2191x).symm) (\u2191(chartAt H \u2191x).symm \u207b\u00b9' univ) (\u2191(chartAt H \u2191x) \u2191x) \u2194\n    ContinuousWithinAt (f \u2218 Subtype.val) univ x \u2227\n      P (\u2191(chartAt H' ((f \u2218 Subtype.val) x)) \u2218 (f \u2218 Subtype.val) \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' univ)\n        (\u2191(chartAt H x) x)"}, {"line": "congrm ?_ \u2227 ?_", "tactic_state": "case a.refine_1\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 ContinuousWithinAt f univ \u2191x \u2194 ContinuousWithinAt (f \u2218 Subtype.val) univ x\n---\ncase a.refine_2\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 P (\u2191(chartAt H' (f \u2191x)) \u2218 f \u2218 \u2191(chartAt H \u2191x).symm) (\u2191(chartAt H \u2191x).symm \u207b\u00b9' univ) (\u2191(chartAt H \u2191x) \u2191x) \u2194\n    P (\u2191(chartAt H' ((f \u2218 Subtype.val) x)) \u2218 (f \u2218 Subtype.val) \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' univ)\n      (\u2191(chartAt H x) x)"}, {"line": "\u00b7 simp_rw [continuousWithinAt_univ, U.isOpenEmbedding'.continuousAt_iff]", "tactic_state": "case a.refine_2\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU : Opens M\nf : M \u2192 M'\nx : \u21a5U\n\u22a2 P (\u2191(chartAt H' (f \u2191x)) \u2218 f \u2218 \u2191(chartAt H \u2191x).symm) (\u2191(chartAt H \u2191x).symm \u207b\u00b9' univ) (\u2191(chartAt H \u2191x) \u2191x) \u2194\n    P (\u2191(chartAt H' ((f \u2218 Subtype.val) x)) \u2218 (f \u2218 Subtype.val) \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' univ)\n      (\u2191(chartAt H x) x)"}, {"line": "\u00b7 apply hG.congr_iff\n    exact (U.chartAt_subtype_val_symm_eventuallyEq).fun_comp (chartAt H' (f x) \u2218 f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftPropAt_iff_comp_inclusion (hG : LocalInvariantProp G G' P) {U V : Opens M} (hUV : U \u2264 V)\n    (f : V \u2192 M') (x : U) :\n    LiftPropAt P f (Set.inclusion hUV x) \u2194 LiftPropAt P (f \u2218 Set.inclusion hUV : U \u2192 M') x := by\n  simp only [LiftPropAt]\n  simp only [liftPropWithinAt_iff']\n  congrm ?_ \u2227 ?_\n  \u00b7 simp_rw [continuousWithinAt_univ,\n      (TopologicalSpace.Opens.isOpenEmbedding_of_le hUV).continuousAt_iff]\n  \u00b7 apply hG.congr_iff\n    exact (TopologicalSpace.Opens.chartAt_inclusion_symm_eventuallyEq hUV).fun_comp\n      (chartAt H' (f (Set.inclusion hUV x)) \u2218 f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/LocalInvariantProperties.lean", "context": {"open": ["Set Filter TopologicalSpace", "scoped Manifold Topology", "ChartedSpace"], "variables": ["{H M H' M' X : Type*}", "[TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]", "[TopologicalSpace H'] [TopologicalSpace M'] [ChartedSpace H' M']", "[TopologicalSpace X]", "(G : StructureGroupoid H) (G' : StructureGroupoid H')", "{G G'} {P : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop}", "(hG : G.LocalInvariantProp G' P)", "{G : StructureGroupoid H} {G' : StructureGroupoid H'} {e e' : PartialHomeomorph M H}", "(hG : G.LocalInvariantProp G' P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 LiftPropAt P f (inclusion hUV x) \u2194 LiftPropAt P (f \u2218 inclusion hUV) x"}, {"line": "simp only [LiftPropAt]", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 LiftPropWithinAt P f univ (inclusion hUV x) \u2194 LiftPropWithinAt P (f \u2218 inclusion hUV) univ x"}, {"line": "simp only [liftPropWithinAt_iff']", "tactic_state": "H : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 ContinuousWithinAt f univ (inclusion hUV x) \u2227\n      P (\u2191(chartAt H' (f (inclusion hUV x))) \u2218 f \u2218 \u2191(chartAt H (inclusion hUV x)).symm)\n        (\u2191(chartAt H (inclusion hUV x)).symm \u207b\u00b9' univ) (\u2191(chartAt H (inclusion hUV x)) (inclusion hUV x)) \u2194\n    ContinuousWithinAt (f \u2218 inclusion hUV) univ x \u2227\n      P (\u2191(chartAt H' ((f \u2218 inclusion hUV) x)) \u2218 (f \u2218 inclusion hUV) \u2218 \u2191(chartAt H x).symm)\n        (\u2191(chartAt H x).symm \u207b\u00b9' univ) (\u2191(chartAt H x) x)"}, {"line": "congrm ?_ \u2227 ?_", "tactic_state": "case a.refine_1\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 ContinuousWithinAt f univ (inclusion hUV x) \u2194 ContinuousWithinAt (f \u2218 inclusion hUV) univ x\n---\ncase a.refine_2\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 P (\u2191(chartAt H' (f (inclusion hUV x))) \u2218 f \u2218 \u2191(chartAt H (inclusion hUV x)).symm)\n      (\u2191(chartAt H (inclusion hUV x)).symm \u207b\u00b9' univ) (\u2191(chartAt H (inclusion hUV x)) (inclusion hUV x)) \u2194\n    P (\u2191(chartAt H' ((f \u2218 inclusion hUV) x)) \u2218 (f \u2218 inclusion hUV) \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' univ)\n      (\u2191(chartAt H x) x)"}, {"line": "\u00b7 simp_rw [continuousWithinAt_univ,\n      (TopologicalSpace.Opens.isOpenEmbedding_of_le hUV).continuousAt_iff]", "tactic_state": "case a.refine_2\nH : Type u_1\nM : Type u_2\nH' : Type u_3\nM' : Type u_4\ninst\u271d\u2075 : TopologicalSpace H\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 : ChartedSpace H M\ninst\u271d\u00b2 : TopologicalSpace H'\ninst\u271d\u00b9 : TopologicalSpace M'\ninst\u271d : ChartedSpace H' M'\nP : (H \u2192 H') \u2192 Set H \u2192 H \u2192 Prop\nx\u271d : Sort u_6\nLocalInvariantProp : x\u271d\nhG : sorry\nU V : Opens M\nhUV : U \u2264 V\nf : \u21a5V \u2192 M'\nx : \u21a5U\n\u22a2 P (\u2191(chartAt H' (f (inclusion hUV x))) \u2218 f \u2218 \u2191(chartAt H (inclusion hUV x)).symm)\n      (\u2191(chartAt H (inclusion hUV x)).symm \u207b\u00b9' univ) (\u2191(chartAt H (inclusion hUV x)) (inclusion hUV x)) \u2194\n    P (\u2191(chartAt H' ((f \u2218 inclusion hUV) x)) \u2218 (f \u2218 inclusion hUV) \u2218 \u2191(chartAt H x).symm) (\u2191(chartAt H x).symm \u207b\u00b9' univ)\n      (\u2191(chartAt H x) x)"}, {"line": "\u00b7 apply hG.congr_iff\n    exact (TopologicalSpace.Opens.chartAt_inclusion_symm_eventuallyEq hUV).fun_comp\n      (chartAt H' (f (Set.inclusion hUV x)) \u2218 f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContMDiffWithinAt.mfderivWithin_const {x\u2080 : M} {f : M \u2192 M'}\n    (hf : ContMDiffWithinAt I I' n f s x\u2080)\n    (hmn : m + 1 \u2264 n) (hx : x\u2080 \u2208 s) (hs : UniqueMDiffOn I s) :\n    ContMDiffWithinAt I \ud835\udcd8(\ud835\udd5c, E \u2192L[\ud835\udd5c] E') m\n      (inTangentCoordinates I I' id f (mfderivWithin I I' f s) x\u2080) s x\u2080 := by\n  have : ContMDiffWithinAt (I.prod I) I' n (fun x : M \u00d7 M => f x.2) (s \u00d7\u02e2 s) (x\u2080, x\u2080) :=\n    ContMDiffWithinAt.comp (x\u2080, x\u2080) hf contMDiffWithinAt_snd mapsTo_snd_prod\n  exact this.mfderivWithin contMDiffWithinAt_id hx (mapsTo_id _) hmn hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiffMFDeriv.lean", "context": {"open": ["Set Function Filter ChartedSpace IsManifold Bundle", "scoped Topology Manifold Bundle"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {m n : WithTop \u2115\u221e}", "[Is : IsManifold I 1 M] [I's : IsManifold I' 1 M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nm n : WithTop \u2115\u221e\nM : Type u_2\nM' : Type u_3\nE\u271d\u00b9 : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\u271d\u00b9\nX\u271d\u00b9 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \ud835\udd5c E\u271d\u00b9 X\u271d\u00b9\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \ud835\udd5c E\u271d X\u271d\ns : Set M\nE : Type u_8\nE' : Type u_9\nx\u2080 : M\nf : M \u2192 M'\nhf : sorry\nhmn : m + 1 \u2264 n\nhx : x\u2080 \u2208 s\nhs : sorry\n\u22a2 sorry"}, {"line": "have : ContMDiffWithinAt (I.prod I) I' n (fun x : M \u00d7 M => f x.2) (s \u00d7\u02e2 s) (x\u2080, x\u2080) :=\n    ContMDiffWithinAt.comp (x\u2080, x\u2080) hf contMDiffWithinAt_snd mapsTo_snd_prod", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\nm n : WithTop \u2115\u221e\nM : Type u_2\nM' : Type u_3\nE\u271d\u00b9 : Type u_4\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2074 : NormedSpace \ud835\udd5c E\u271d\u00b9\nX\u271d\u00b9 : Type u_5\ninst\u271d\u00b3 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \ud835\udd5c E\u271d\u00b9 X\u271d\u00b9\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \ud835\udd5c E\u271d X\u271d\ns : Set M\nE : Type u_8\nE' : Type u_9\nx\u2080 : M\nf : M \u2192 M'\nhf : sorry\nhmn : m + 1 \u2264 n\nhx : x\u2080 \u2208 s\nhs : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "exact this.mfderivWithin contMDiffWithinAt_id hx (mapsTo_id _) hmn hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContMDiffWithinAt.div\u2080\n    (hf : ContMDiffWithinAt I' I n f s a) (hg : ContMDiffWithinAt I' I n g s a) (h\u2080 : g a \u2260 0) :\n    ContMDiffWithinAt I' I n (f / g) s a := by\n  simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "context": {"open": ["scoped Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {H : Type*} [TopologicalSpace H] {E : Type*}", "[LieGroup I n G]", "(I n)", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "[ContMDiffInv\u2080 I n G]", "{s : Set M} {a : M}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\na : M\n\u03b1\u271d : Type u_6\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_7\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_8\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nf g : M \u2192 \u2115\nhf : sorry\nhg : sorry\nh\u2080 : g a \u2260 0\n\u22a2 sorry"}, {"line": "simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContMDiffOn.div\u2080 (hf : ContMDiffOn I' I n f s) (hg : ContMDiffOn I' I n g s)\n    (h\u2080 : \u2200 x \u2208 s, g x \u2260 0) : ContMDiffOn I' I n (f / g) s := by\n  simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "context": {"open": ["scoped Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {H : Type*} [TopologicalSpace H] {E : Type*}", "[LieGroup I n G]", "(I n)", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "[ContMDiffInv\u2080 I n G]", "{s : Set M} {a : M}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\ns : Set M\n\u03b1\u271d : Type u_6\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_7\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_8\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nf g : M \u2192 \u2115\nhf : sorry\nhg : sorry\nh\u2080 : \u2200 x \u2208 s, g x \u2260 0\n\u22a2 sorry"}, {"line": "simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContMDiffAt.div\u2080 (hf : ContMDiffAt I' I n f a) (hg : ContMDiffAt I' I n g a)\n    (h\u2080 : g a \u2260 0) : ContMDiffAt I' I n (f / g) a := by\n  simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Algebra/LieGroup.lean", "context": {"open": ["scoped Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {H : Type*} [TopologicalSpace H] {E : Type*}", "[LieGroup I n G]", "(I n)", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "[ContMDiffInv\u2080 I n G]", "{s : Set M} {a : M}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\na : M\n\u03b1\u271d : Type u_6\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_7\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_8\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nf g : M \u2192 \u2115\nhf : sorry\nhg : sorry\nh\u2080 : g a \u2260 0\n\u22a2 sorry"}, {"line": "simpa [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContMDiffWithinAt.div_const (hf : ContMDiffWithinAt I' I n f s x) :\n    ContMDiffWithinAt I' I n (fun x \u21a6 f x / c) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul contMDiffWithinAt_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Algebra/Monoid.lean", "context": {"open": ["scoped Manifold ContDiff", "scoped LieGroup", "Function"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {H : Type*} [TopologicalSpace H] {E : Type*}", "(I n)", "[ContMDiffMul I n G] {f g : M \u2192 G} {s : Set M} {x : M}", "[ContMDiffMul I 1 G]", "(I) (g h : G)", "[ContMDiffMul I \u221e G]", "{G' : Type*} [Monoid G'] [TopologicalSpace G'] [ChartedSpace H G'] [ContMDiffMul I \u221e G']", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "{\u03b9 \ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e} {H : Type*} [TopologicalSpace H]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {n : WithTop \u2115\u221e}", "{f : M \u2192 G} {s : Set M} {x : M} (c : G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u271d : Type u_11\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_12\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_13\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nhf : sorry\n\u22a2 sorry"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul contMDiffWithinAt_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contMDiffOn_extChartAt_symm (x : M) :\n    ContMDiffOn \ud835\udcd8(\ud835\udd5c, E) I n (extChartAt I x).symm (extChartAt I x).target := by\n  convert contMDiffOn_extend_symm (chart_mem_maximalAtlas (I := I) x)\n  \u00b7 rw [extChartAt_target, I.image_eq]\n  \u00b7 infer_instance\n  \u00b7 infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiff/Atlas.lean", "context": {"open": ["Set ChartedSpace IsManifold", "scoped Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 sorry"}, {"line": "convert contMDiffOn_extend_symm (chart_mem_maximalAtlas (I := I) x)", "tactic_state": "case a\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 sorry \u2194\n    ContMDiffOn (modelWithCornersSelf \ud835\udd5c E\u271d) I ?convert_2 (\u2191((chartAt X\u271d x).extend I).symm) (\u2191I '' (chartAt X\u271d x).target)\n---\ncase convert_1\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I ?convert_2 M\n---\ncase convert_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 WithTop \u2115\u221e\n---\ncase convert_3\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 TopologicalSpace M\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 ChartedSpace X\u271d M\n---\ncase convert_5\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I ?convert_2 M"}, {"line": "\u00b7 rw [extChartAt_target, I.image_eq]", "tactic_state": "case convert_1\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I ?convert_2 M\n---\ncase convert_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 WithTop \u2115\u221e\n---\ncase convert_3\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 TopologicalSpace M\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 ChartedSpace X\u271d M\n---\ncase convert_5\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I ?convert_2 M"}, {"line": "\u00b7 infer_instance", "tactic_state": "case convert_2\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 WithTop \u2115\u221e\n---\ncase convert_3\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 TopologicalSpace M\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 ChartedSpace X\u271d M\n---\ncase convert_5\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I ?convert_2 M"}, {"line": "\u00b7 infer_instance", "tactic_state": "case convert_3\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 TopologicalSpace M\n---\ncase convert_4\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 ChartedSpace X\u271d M\n---\ncase convert_5\n\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\nM : Type u_2\nE : Type u_3\nE\u271d : Type u_4\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c E\u271d\nX\u271d : Type u_5\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \ud835\udd5c E\u271d X\u271d\nn : WithTop \u2115\u221e\nx : M\n\u22a2 IsManifold I sorry M"}]}
{"declaration": "lemma extChartAt_inl_apply {x y : M} :\n    (extChartAt I (.inl x : M \u2295 M')) (Sum.inl y) = (extChartAt I x) y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiff/Constructions.lean", "context": {"open": ["Set Function Filter ChartedSpace", "scoped Topology Manifold", "Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{g : N \u2192 N'} {r : Set N} {y : N}", "{\u03b9 : Type*} [Fintype \u03b9] {Fi : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (Fi i)]", "{M' : Type*} [TopologicalSpace M'] [ChartedSpace H M'] {n : WithTop \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM' : Type u_8\nx y : M\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "M : Type u_4\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM' : Type u_8\nx y : M\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma extChartAt_inr_apply {x y : M'} :\n    (extChartAt I (.inr x : M \u2295 M')) (Sum.inr y) = (extChartAt I x) y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiff/Constructions.lean", "context": {"open": ["Set Function Filter ChartedSpace", "scoped Topology Manifold", "Topology"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{g : N \u2192 N'} {r : Set N} {y : N}", "{\u03b9 : Type*} [Fintype \u03b9] {Fi : \u03b9 \u2192 Type*} [\u2200 i, NormedAddCommGroup (Fi i)]", "{M' : Type*} [TopologicalSpace M'] [ChartedSpace H M'] {n : WithTop \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type u_4\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM : Type u_8\nx y : M'\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "M' : Type u_4\n\u03b1\u271d : Type u_5\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_6\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_7\ninst\u271d : TopologicalSpace X\u271d\nI : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM : Type u_8\nx y : M'\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem contMDiffOn_iff_of_mem_maximalAtlas (he : e \u2208 maximalAtlas I n M)\n    (he' : e' \u2208 maximalAtlas I' n M') (hs : s \u2286 e.source) (h2s : MapsTo f s e'.source) :\n    ContMDiffOn I I' n f s \u2194\n      ContinuousOn f s \u2227\n        ContDiffOn \ud835\udd5c n (e'.extend I' \u2218 f \u2218 (e.extend I).symm) (e.extend I '' s) := by\n  simp_rw [ContinuousOn, ContDiffOn, Set.forall_mem_image, \u2190 forall_and, ContMDiffOn]\n  exact forall\u2082_congr fun x hx => contMDiffWithinAt_iff_image he he' hs (hs hx) (h2s hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiff/Defs.lean", "context": {"open": ["Set Function Filter ChartedSpace IsManifold", "scoped Topology Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(I I') in", "(I I') in", "(I I') in", "(I I') in", "(I I') in", "[IsManifold I n M] [IsManifold I' n M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d\u00b9 : Type u_2\nself\u271d : NontriviallyNormedField \u03b1\u271d\u00b9\nE\u271d\u00b9 : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2076 : NormedSpace \u03b1\u271d\u00b9 E\u271d\u00b9\nX\u271d\u00b9 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \u03b1\u271d\u00b9 E\u271d\u00b9 X\u271d\u00b9\nn : WithTop \u2115\u221e\nM : Type u_5\ninst\u271d\u2074 : TopologicalSpace M\ne : PartialHomeomorph M X\u271d\u00b9\nE\u271d : Type u_6\ninst\u271d\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b2 : NormedSpace \u03b1\u271d\u00b9 E\u271d\nX\u271d : Type u_7\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d\u00b9 E\u271d X\u271d\nM' : Type u_8\ninst\u271d : TopologicalSpace M'\ne' : PartialHomeomorph M' X\u271d\n\u03b1\u271d : Type u_9\ns : Set \u03b1\u271d\n\u03b2\u271d : Type u_10\nf : \u03b1\u271d \u2192 \u03b2\u271d\nhe : e \u2208 sorry\nhe' : e' \u2208 sorry\nhs : s \u2286 sorry\nh2s : MapsTo f s sorry\n\u22a2 ContMDiffOn I I' n f s \u2194 ContinuousOn f s \u2227 ContDiffOn \ud835\udd5c n (sorry \u2218 f \u2218 sorry) (sorry '' s)"}, {"line": "simp_rw [ContinuousOn, ContDiffOn, Set.forall_mem_image, \u2190 forall_and, ContMDiffOn]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2078 : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d\u00b9 : Type u_2\nself\u271d : NontriviallyNormedField \u03b1\u271d\u00b9\nE\u271d\u00b9 : Type u_3\ninst\u271d\u2077 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2076 : NormedSpace \u03b1\u271d\u00b9 E\u271d\u00b9\nX\u271d\u00b9 : Type u_4\ninst\u271d\u2075 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \u03b1\u271d\u00b9 E\u271d\u00b9 X\u271d\u00b9\nn : WithTop \u2115\u221e\nM : Type u_5\ninst\u271d\u2074 : TopologicalSpace M\ne : PartialHomeomorph M X\u271d\u00b9\nE\u271d : Type u_6\ninst\u271d\u00b3 : NormedAddCommGroup E\u271d\ninst\u271d\u00b2 : NormedSpace \u03b1\u271d\u00b9 E\u271d\nX\u271d : Type u_7\ninst\u271d\u00b9 : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d\u00b9 E\u271d X\u271d\nM' : Type u_8\ninst\u271d : TopologicalSpace M'\ne' : PartialHomeomorph M' X\u271d\n\u03b1\u271d : Type u_9\ns : Set \u03b1\u271d\n\u03b2\u271d : Type u_10\nf : \u03b1\u271d \u2192 \u03b2\u271d\nhe : e \u2208 sorry\nhe' : e' \u2208 sorry\nhs : s \u2286 sorry\nh2s : MapsTo f s sorry\n\u22a2 (\u2200 x \u2208 s, ContMDiffWithinAt I I' n f s x) \u2194\n    \u2200 x \u2208 s, ContinuousWithinAt f s x \u2227 ContDiffWithinAt \ud835\udd5c n (sorry \u2218 f \u2218 sorry) (sorry '' s) (sorry x)"}, {"line": "exact forall\u2082_congr fun x hx => contMDiffWithinAt_iff_image he he' hs (hs hx) (h2s hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem contMDiff_iff :\n    ContMDiff I I' n f \u2194\n      Continuous f \u2227\n        \u2200 (x : M) (y : M'),\n          ContDiffOn \ud835\udd5c n (extChartAt I' y \u2218 f \u2218 (extChartAt I x).symm)\n            ((extChartAt I x).target \u2229\n              (extChartAt I x).symm \u207b\u00b9' (f \u207b\u00b9' (extChartAt I' y).source)) := by\n  simp [\u2190 contMDiffOn_univ, contMDiffOn_iff, continuous_iff_continuousOn_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/ContMDiff/Defs.lean", "context": {"open": ["Set Function Filter ChartedSpace IsManifold", "scoped Topology Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "(I I') in", "(I I') in", "(I I') in", "(I I') in", "(I I') in", "[IsManifold I n M] [IsManifold I' n M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d\u00b9 : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2074 : NormedSpace \u03b1\u271d E\u271d\u00b9\nX\u271d\u00b9 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \u03b1\u271d E\u271d\u00b9 X\u271d\u00b9\nE\u271d : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_6\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nn : WithTop \u2115\u221e\nM\u271d : Type u_7\nM'\u271d : Type u_8\nf : M\u271d \u2192 M'\u271d\nM : Type u_9\nM' : Type u_10\n\u22a2 ContMDiff I I' n f \u2194\n    Continuous f \u2227 \u2200 (x : M) (y : M'), ContDiffOn \ud835\udd5c n (sorry \u2218 f \u2218 ?m.17126) (?m.17934 \u2229 ?m.18728 \u207b\u00b9' (f \u207b\u00b9' ?m.19150))"}, {"line": "simp [\u2190 contMDiffOn_univ, contMDiffOn_iff, continuous_iff_continuousOn_univ]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_2\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d\u00b9 : Type u_3\ninst\u271d\u2075 : NormedAddCommGroup E\u271d\u00b9\ninst\u271d\u2074 : NormedSpace \u03b1\u271d E\u271d\u00b9\nX\u271d\u00b9 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace X\u271d\u00b9\nI : ModelWithCorners \u03b1\u271d E\u271d\u00b9 X\u271d\u00b9\nE\u271d : Type u_5\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_6\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nn : WithTop \u2115\u221e\nM\u271d : Type u_7\nM'\u271d : Type u_8\nf : M\u271d \u2192 M'\u271d\nM : Type u_9\nM' : Type u_10\n\u22a2 ContMDiff I I' n f \u2194\n    Continuous f \u2227\n      \u2200 (x : M) (y : M'), ContDiffOn \ud835\udd5c n (sorry () \u2218 f \u2218 ?m.17126) (?m.17934 \u2229 ?m.18728 \u207b\u00b9' (f \u207b\u00b9' ?m.19150))"}]}
{"declaration": "lemma IccLeftChart_extend_bot : (IccLeftChart x y).extend (\ud835\udce1\u2202 1) \u22a5 = 0 := by\n  norm_num [IccLeftChart, modelWithCornersEuclideanHalfSpace_zero]\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Real.lean", "context": {"open": ["Set Function", "scoped Manifold ContDiff", "ENNReal in", "ENNReal in", "ENNReal in", "ENNReal in", "Fact.Manifold"], "variables": ["{n : \u2115}", "{x y : \u211d} [hxy : Fact (x < y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191((IccLeftChart x y).extend (modelWithCornersEuclideanHalfSpace 1)) sorry = 0"}, {"line": "norm_num [IccLeftChart, modelWithCornersEuclideanHalfSpace_zero]", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(modelWithCornersEuclideanHalfSpace 1) \u27e8fun x_1 => \u2191(sorry ()) - x, \u22ef\u27e9 = 0"}, {"line": "congr", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(modelWithCornersEuclideanHalfSpace 1) \u27e8fun x_1 => \u2191(sorry ()) - x, \u22ef\u27e9 = 0"}]}
{"declaration": "lemma IccLeftChart_extend_interior_pos {p : Set.Icc x y} (hp : x < p.val \u2227 p.val < y) :\n    0 < (IccLeftChart x y).extend (\ud835\udce1\u2202 1) p 0 := by\n  simp_rw [iccLeftChart_extend_zero]\n  norm_num [hp.1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Real.lean", "context": {"open": ["Set Function", "scoped Manifold ContDiff", "ENNReal in", "ENNReal in", "ENNReal in", "ENNReal in", "Fact.Manifold"], "variables": ["{n : \u2115}", "{x y : \u211d} [hxy : Fact (x < y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\np : \u2191(Icc x y)\nhp : x < \u2191p \u2227 \u2191p < y\n\u22a2 0 < \u2191((IccLeftChart x y).extend (modelWithCornersEuclideanHalfSpace 1)) p 0"}, {"line": "simp_rw [iccLeftChart_extend_zero]", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\np : \u2191(Icc x y)\nhp : x < \u2191p \u2227 \u2191p < y\n\u22a2 0 < \u2191p - x"}, {"line": "norm_num [hp.1]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IccRightChart_extend_top :\n    (IccRightChart x y).extend (\ud835\udce1\u2202 1) \u22a4 = 0 := by\n  norm_num [IccRightChart, modelWithCornersEuclideanHalfSpace_zero]\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Real.lean", "context": {"open": ["Set Function", "scoped Manifold ContDiff", "ENNReal in", "ENNReal in", "ENNReal in", "ENNReal in", "Fact.Manifold"], "variables": ["{n : \u2115}", "{x y : \u211d} [hxy : Fact (x < y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191((IccRightChart x y).extend (modelWithCornersEuclideanHalfSpace 1)) sorry = 0"}, {"line": "norm_num [IccRightChart, modelWithCornersEuclideanHalfSpace_zero]", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(modelWithCornersEuclideanHalfSpace 1) \u27e8fun x_1 => y - \u2191(sorry ()), \u22ef\u27e9 = 0"}, {"line": "congr", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\n\u22a2 \u2191(modelWithCornersEuclideanHalfSpace 1) \u27e8fun x_1 => y - \u2191(sorry ()), \u22ef\u27e9 = 0"}]}
{"declaration": "lemma Icc_chartedSpaceChartAt_of_le_top {z : Set.Icc x y} (h : z.val < y) :\n    chartAt _ z = IccLeftChart x y := by\n  simp [Icc_chartedSpaceChartAt, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Real.lean", "context": {"open": ["Set Function", "scoped Manifold ContDiff", "ENNReal in", "ENNReal in", "ENNReal in", "ENNReal in", "Fact.Manifold"], "variables": ["{n : \u2115}", "{x y : \u211d} [hxy : Fact (x < y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\nz : \u2191(Icc x y)\nh : \u2191z < y\n\u22a2 chartAt (EuclideanHalfSpace 1) z = IccLeftChart x y"}, {"line": "simp [Icc_chartedSpaceChartAt, h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Icc_chartedSpaceChartAt_of_top_le {z : Set.Icc x y} (h : y \u2264 z.val) :\n    chartAt _ z = IccRightChart x y := by\n  simp [Icc_chartedSpaceChartAt, reduceIte, not_lt.mpr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Real.lean", "context": {"open": ["Set Function", "scoped Manifold ContDiff", "ENNReal in", "ENNReal in", "ENNReal in", "ENNReal in", "Fact.Manifold"], "variables": ["{n : \u2115}", "{x y : \u211d} [hxy : Fact (x < y)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhxy : Fact (x < y)\nz : \u2191(Icc x y)\nh : y \u2264 \u2191z\n\u22a2 chartAt (EuclideanHalfSpace 1) z = IccRightChart x y"}, {"line": "simp [Icc_chartedSpaceChartAt, reduceIte, not_lt.mpr h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasFDerivAt_stereoInvFunAux_comp_coe (v : E) :\n    HasFDerivAt (stereoInvFunAux v \u2218 ((\u2191) : (\u211d \u2219 v)\u15ee \u2192 E)) (\u211d \u2219 v)\u15ee.subtypeL 0 := by\n  have : HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id \u211d E) ((\u211d \u2219 v)\u15ee.subtypeL 0) :=\n    hasFDerivAt_stereoInvFunAux v\n  refine this.comp (0 : (\u211d \u2219 v)\u15ee) (by apply ContinuousLinearMap.hasFDerivAt)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Sphere.lean", "context": {"open": ["Metric Module Function", "scoped Manifold ContDiff"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "(v : E)", "{v}", "(v) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\n\u22a2 HasFDerivAt (stereoInvFunAux v \u2218 Subtype.val) (Submodule.span \u211d {v})\u15ee.subtypeL 0"}, {"line": "have : HasFDerivAt (stereoInvFunAux v) (ContinuousLinearMap.id \u211d E) ((\u211d \u2219 v)\u15ee.subtypeL 0) :=\n    hasFDerivAt_stereoInvFunAux v", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : InnerProductSpace \u211d E\nv : E\nthis : sorry\n\u22a2 HasFDerivAt (stereoInvFunAux v \u2218 Subtype.val) (Submodule.span \u211d {v})\u15ee.subtypeL 0"}, {"line": "refine this.comp (0 : (\u211d \u2219 v)\u15ee) (by apply ContinuousLinearMap.hasFDerivAt)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stereographic'_symm_apply {n : \u2115} [Fact (finrank \u211d E = n + 1)] (v : sphere (0 : E) 1)\n    (x : EuclideanSpace \u211d (Fin n)) :\n    ((stereographic' n v).symm x : E) =\n      let U : (\u211d \u2219 (v : E))\u15ee \u2243\u2097\u1d62[\u211d] EuclideanSpace \u211d (Fin n) :=\n        (OrthonormalBasis.fromOrthogonalSpanSingleton n (ne_zero_of_mem_unit_sphere v)).repr\n      (\u2016(U.symm x : E)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (4 : \u211d) \u2022 (U.symm x : E) +\n        (\u2016(U.symm x : E)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (\u2016(U.symm x : E)\u2016 ^ 2 - 4) \u2022 v.val := by\n  simp [real_inner_comm, stereographic, stereographic', \u2190 Submodule.coe_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/Instances/Sphere.lean", "context": {"open": ["Metric Module Function", "scoped Manifold ContDiff", "scoped InnerProductSpace in", "scoped InnerProductSpace in", "scoped InnerProductSpace"], "variables": ["{E : Type*} [NormedAddCommGroup E] [InnerProductSpace \u211d E]", "(v : E)", "{v}", "(v) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\nn : \u2115\ninst\u271d : Fact (finrank \u211d E = n + 1)\nv : \u2191(sphere 0 1)\nx : EuclideanSpace \u211d (Fin n)\n\u22a2 \u2191(\u2191(stereographic' n v).symm x) =\n    let U := (OrthonormalBasis.fromOrthogonalSpanSingleton n \u22ef).repr;\n    (\u2016\u2191(U.symm x)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 4 \u2022 \u2191(U.symm x) + (\u2016\u2191(U.symm x)\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (\u2016\u2191(U.symm x)\u2016 ^ 2 - 4) \u2022 \u2191v"}, {"line": "simp [real_inner_comm, stereographic, stereographic', \u2190 Submodule.coe_norm]", "tactic_state": "E : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : InnerProductSpace \u211d E\nn : \u2115\ninst\u271d : Fact (finrank \u211d E = n + 1)\nv : \u2191(sphere 0 1)\nx : EuclideanSpace \u211d (Fin n)\n\u22a2 (\u2016x\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (4 \u2022 \u2191((OrthonormalBasis.fromOrthogonalSpanSingleton n \u22ef).repr.symm x) + (\u2016x\u2016 ^ 2 - 4) \u2022 \u2191v) =\n    (\u2016x\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 4 \u2022 \u2191((OrthonormalBasis.fromOrthogonalSpanSingleton n \u22ef).repr.symm x) +\n      (\u2016x\u2016 ^ 2 + 4)\u207b\u00b9 \u2022 (\u2016x\u2016 ^ 2 - 4) \u2022 \u2191v"}]}
{"declaration": "theorem uniqueMDiffOn_iff_uniqueDiffOn : UniqueMDiffOn \ud835\udcd8(\ud835\udd5c, E) s \u2194 UniqueDiffOn \ud835\udd5c s := by\n  simp [UniqueMDiffOn, UniqueDiffOn, uniqueMDiffWithinAt_iff_uniqueDiffWithinAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/MFDeriv/FDeriv.lean", "context": {"open": ["scoped Manifold"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_3\ns : Set \u03b1\u271d\n\u22a2 sorry \u2194 UniqueDiffOn \ud835\udd5c s"}, {"line": "simp [UniqueMDiffOn, UniqueDiffOn, uniqueMDiffWithinAt_iff_uniqueDiffWithinAt]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u03b1\u271d : Type u_3\ns : Set \u03b1\u271d\n\u22a2 sorry () \u2194 \u2200 x \u2208 s, UniqueDiffWithinAt \ud835\udd5c s x"}]}
{"declaration": "theorem hasMFDerivWithinAt_iff_hasFDerivWithinAt {f'} :\n    HasMFDerivWithinAt \ud835\udcd8(\ud835\udd5c, E) \ud835\udcd8(\ud835\udd5c, E') f s x f' \u2194 HasFDerivWithinAt f f' s x := by\n  simpa only [HasMFDerivWithinAt,and_iff_right_iff_imp,mfld_simps] using\n    HasFDerivWithinAt.continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/MFDeriv/FDeriv.lean", "context": {"open": ["scoped Manifold"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : Type u_2\ninst\u271d : NormedAddCommGroup E\nE' : Type u_3\nf : E \u2192 E'\ns : Set E\nx : E\nf' : TangentSpace sorry x \u2192L[\ud835\udd5c] TangentSpace sorry (f x)\n\u22a2 sorry \u2194 sorry"}, {"line": "simpa only [HasMFDerivWithinAt,and_iff_right_iff_imp,mfld_simps] using\n    HasFDerivWithinAt.continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mdifferentiable_iff :\n    MDifferentiable I I' f \u2194\n      Continuous f \u2227\n        \u2200 (x : M) (y : M'),\n          DifferentiableOn \ud835\udd5c (extChartAt I' y \u2218 f \u2218 (extChartAt I x).symm)\n            ((extChartAt I x).target \u2229\n              (extChartAt I x).symm \u207b\u00b9' (f \u207b\u00b9' (extChartAt I' y).source)) := by\n  simp [\u2190 mdifferentiableOn_univ, mdifferentiableOn_iff, continuous_iff_continuousOn_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/MFDeriv/Basic.lean", "context": {"open": ["scoped Topology Manifold", "Set Bundle ChartedSpace", "IsManifold"], "variables": ["", "{I}", "{e : PartialHomeomorph M H} {e' : PartialHomeomorph M' H'}", "[IsManifold I 1 M] [IsManifold I' 1 M']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\nM' : Type u_10\nI : ModelWithCorners ?m.53775 ?m.53773 ?m.53778\n\u03b1\u271d : Type u_1\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_3\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM\u271d : Type u_4\nM'\u271d : Type u_5\nf : M\u271d \u2192 M'\u271d\n\ud835\udd5c : Type u_6\n\u22a2 MDifferentiable I I' f \u2194 Continuous f \u2227 (M \u2192 M' \u2192 sorry)"}, {"line": "simp [\u2190 mdifferentiableOn_univ, mdifferentiableOn_iff, continuous_iff_continuousOn_univ]", "tactic_state": "M : Type u_9\nM' : Type u_10\nI : ModelWithCorners ?m.53775 ?m.53773 ?m.53778\n\u03b1\u271d : Type u_1\nself\u271d : NontriviallyNormedField \u03b1\u271d\nE\u271d : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\u271d\ninst\u271d\u00b9 : NormedSpace \u03b1\u271d E\u271d\nX\u271d : Type u_3\ninst\u271d : TopologicalSpace X\u271d\nI' : ModelWithCorners \u03b1\u271d E\u271d X\u271d\nM\u271d : Type u_4\nM'\u271d : Type u_5\nf : M\u271d \u2192 M'\u271d\n\ud835\udd5c : Type u_6\n\u22a2 MDifferentiable I I' f \u2194 Continuous f \u2227 (M \u2192 M' \u2192 sorry ())"}]}
{"declaration": "theorem coe_zsmul (s : C\u209b^n\u27eeI; F, V\u27ef) (z : \u2124) : \u21d1(z \u2022 s : C\u209b^n\u27eeI; F, V\u27ef) = z \u2022 \u21d1s := by\n  rcases z with n | n\n  \u00b7 refine (coe_nsmul s n).trans ?_\n    simp only [Int.ofNat_eq_coe]\n    simp only [natCast_zsmul]\n  \u00b7 refine (congr_arg Neg.neg (coe_nsmul s (n + 1))).trans ?_\n    simp only [negSucc_zsmul]\n    simp only [neg_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/VectorBundle/SmoothSection.lean", "context": {"open": ["Bundle Filter Function", "scoped Bundle Manifold ContDiff"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [NormedAddCommGroup E]", "(F : Type*) [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "{I} {n} {F} {V}", "{s t : C\u209b^n\u27eeI; F, V\u27ef}", "[\u2200 x, AddCommGroup (V x)] [\u2200 x, Module \ud835\udd5c (V x)] [VectorBundle \ud835\udd5c F V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : sorry\nz : \u2124\n\u22a2 sorry = z \u2022 sorry"}, {"line": "rcases z with n | n", "tactic_state": "case ofNat\ns : sorry\nn : \u2115\n\u22a2 sorry = Int.ofNat n \u2022 sorry\n---\ncase negSucc\ns : sorry\nn : \u2115\n\u22a2 sorry = Int.negSucc n \u2022 sorry"}, {"line": "\u00b7 refine (coe_nsmul s n).trans ?_\n    simp only [Int.ofNat_eq_coe]\n    simp only [natCast_zsmul]", "tactic_state": "case negSucc\ns : sorry\nn : \u2115\n\u22a2 sorry = Int.negSucc n \u2022 sorry"}, {"line": "\u00b7 refine (congr_arg Neg.neg (coe_nsmul s (n + 1))).trans ?_\n    simp only [negSucc_zsmul]\n    simp only [neg_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mpullbackWithin_add_apply :\n    mpullbackWithin I I' f (V + V\u2081) s x =\n      mpullbackWithin I I' f V s x + mpullbackWithin I I' f V\u2081 s x := by\n  simp [mpullbackWithin_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/VectorField/Pullback.lean", "context": {"open": ["Set Function Filter", "scoped Topology Manifold ContDiff", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{V W V\u2081 W\u2081 : \u03a0 (x : M'), TangentSpace I' x}", "{c : \ud835\udd5c} {m n : WithTop \u2115\u221e} {t : Set M'} {y\u2080 : M'}", "(I I') in", "(I I') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullbackWithin : x\u271d\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [mpullbackWithin_apply]", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullbackWithin : x\u271d\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "lemma mpullbackWithin_neg_apply :\n    mpullbackWithin I I' f (-V) s x = - mpullbackWithin I I' f V s x := by\n  simp [mpullbackWithin_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/VectorField/Pullback.lean", "context": {"open": ["Set Function Filter", "scoped Topology Manifold ContDiff", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{V W V\u2081 W\u2081 : \u03a0 (x : M'), TangentSpace I' x}", "{c : \ud835\udd5c} {m n : WithTop \u2115\u221e} {t : Set M'} {y\u2080 : M'}", "(I I') in", "(I I') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullbackWithin : x\u271d\n\u22a2 sorry = -sorry"}, {"line": "simp [mpullbackWithin_apply]", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullbackWithin : x\u271d\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "lemma mpullback_add_apply :\n    mpullback I I' f (V + V\u2081) x = mpullback I I' f V x + mpullback I I' f V\u2081 x := by\n  simp [mpullback_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/VectorField/Pullback.lean", "context": {"open": ["Set Function Filter", "scoped Topology Manifold ContDiff", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{V W V\u2081 W\u2081 : \u03a0 (x : M'), TangentSpace I' x}", "{c : \ud835\udd5c} {m n : WithTop \u2115\u221e} {t : Set M'} {y\u2080 : M'}", "(I I') in", "(I I') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullback : x\u271d\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [mpullback_apply]", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullback : x\u271d\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "lemma mpullback_neg_apply :\n    mpullback I I' f (-V) x = - mpullback I I' f V x := by\n  simp [mpullback_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Manifold/VectorField/Pullback.lean", "context": {"open": ["Set Function Filter", "scoped Topology Manifold ContDiff", "ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c]", "{V W V\u2081 W\u2081 : \u03a0 (x : M'), TangentSpace I' x}", "{c : \ud835\udd5c} {m n : WithTop \u2115\u221e} {t : Set M'} {y\u2080 : M'}", "(I I') in", "(I I') in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullback : x\u271d\n\u22a2 sorry = -sorry"}, {"line": "simp [mpullback_apply]", "tactic_state": "M' : Type ?u.41385\nI'\u271d : ModelWithCorners ?m.41787 ?m.41789 ?m.41792\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nV : M' \u2192 sorry\nW : M' \u2192 sorry\nV\u2081 : M' \u2192 sorry\nW\u2081 : M' \u2192 sorry\nc : \ud835\udd5c\nm n : WithTop \u2115\u221e\nt : Set M'\ny\u2080 : M'\nI : ?m.54601\nI' : ?m.54602 I\nx\u271d : Sort u_2\nmpullback : x\u271d\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "lemma zeroLocus_singleton {U : Opens X} (f : X.presheaf.obj (op U)) :\n    X.zeroLocus {f} = (X.basicOpen f).carrier\u1d9c := by\n  simp [zeroLocus]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/RingedSpace/Basic.lean", "context": {"open": ["CategoryTheory", "TopologicalSpace", "Opposite", "TopCat", "TopCat.Presheaf", "SheafedSpace"], "variables": ["(X : RingedSpace)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : sorry\nf : sorry\n\u22a2 sorry = sorry\u1d9c"}, {"line": "simp [zeroLocus]", "tactic_state": "U : sorry\nf : sorry\n\u22a2 sorry () = (sorry ())\u1d9c"}]}
{"declaration": "lemma zeroLocus_empty_eq_univ {U : Opens X} :\n    X.zeroLocus (\u2205 : Set (X.presheaf.obj (op U))) = Set.univ := by\n  simp [zeroLocus]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/RingedSpace/Basic.lean", "context": {"open": ["CategoryTheory", "TopologicalSpace", "Opposite", "TopCat", "TopCat.Presheaf", "SheafedSpace"], "variables": ["(X : RingedSpace)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "U : sorry\n\u22a2 sorry = Set.univ"}, {"line": "simp [zeroLocus]", "tactic_state": "U : sorry\n\u22a2 sorry () = Set.univ"}]}
{"declaration": "theorem congr_app {X Y : PresheafedSpace C} {\u03b1 \u03b2 : X \u27f6 Y} (h : \u03b1 = \u03b2) (U) :\n    \u03b1.c.app U = \u03b2.c.app U \u226b X.presheaf.map (eqToHom (by subst h; rfl)) := by\n  subst h\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/RingedSpace/PresheafedSpace.lean", "context": {"open": ["Opposite CategoryTheory CategoryTheory.Category CategoryTheory.Functor TopCat TopologicalSpace"], "variables": ["(C : Type*) [Category C]", "{C}", "(C)", "{C}", "{C}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nPresheafedSpace : x\u271d\nX : sorry\nY : sorry\n\u03b1 \u03b2 : X \u27f6 Y\nh : \u03b1 = \u03b2\nU : ?m.3237 h\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "subst h", "tactic_state": "x\u271d : Sort u_2\nPresheafedSpace : x\u271d\nX : sorry\nY : sorry\n\u03b1 : X \u27f6 Y\nU : ?m.3237 \u22ef\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_2\nPresheafedSpace : x\u271d\nX : sorry\nY : sorry\n\u03b1 : X \u27f6 Y\nU : ?m.3237 \u22ef\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem map_id_c_app (F : J \u2964 PresheafedSpace.{_, _, v} C) (j) (U) :\n    (F.map (\ud835\udfd9 j)).c.app U =\n      (Pushforward.id (F.obj j).presheaf).inv.app U \u226b\n        (pushforwardEq (by simp) (F.obj j).presheaf).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_id j)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/RingedSpace/PresheafedSpace/HasColimits.lean", "context": {"open": ["CategoryTheory Opposite CategoryTheory.Category CategoryTheory.Functor CategoryTheory.Limits"], "variables": ["{J : Type u'} [Category.{v'} J] {C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nPresheafedSpace : x\u271d\u00b9\nx\u271d : Sort u_2\npushforwardEq : x\u271d\nF : sorry\nj : ?m.1670 F\nU : ?m.1671 F j\n\u22a2 sorry = CategoryStruct.comp sorry sorry"}, {"line": "simp [PresheafedSpace.congr_app (F.map_id j)]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nPresheafedSpace : x\u271d\u00b9\nx\u271d : Sort u_2\npushforwardEq : x\u271d\nF : sorry\nj : ?m.1670 F\nU : ?m.1671 F j\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (sorry ())"}]}
{"declaration": "theorem map_comp_c_app (F : J \u2964 PresheafedSpace.{_, _, v} C) {j\u2081 j\u2082 j\u2083}\n    (f : j\u2081 \u27f6 j\u2082) (g : j\u2082 \u27f6 j\u2083) (U) :\n    (F.map (f \u226b g)).c.app U =\n      (F.map g).c.app U \u226b\n        ((pushforward C (F.map g).base).map (F.map f).c).app U \u226b\n          (pushforwardEq (congr_arg Hom.base (F.map_comp f g).symm) _).hom.app U := by\n  simp [PresheafedSpace.congr_app (F.map_comp f g)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/RingedSpace/PresheafedSpace/HasColimits.lean", "context": {"open": ["CategoryTheory Opposite CategoryTheory.Category CategoryTheory.Functor CategoryTheory.Limits"], "variables": ["{J : Type u'} [Category.{v'} J] {C : Type u} [Category.{v} C]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_1\nPresheafedSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\npushforward : x\u271d\u00b9\nx\u271d : Sort u_3\npushforwardEq : x\u271d\nF : sorry\nj\u2081 j\u2082 j\u2083 : ?m.4880 F\nf : j\u2081 \u27f6 j\u2082\ng : j\u2082 \u27f6 j\u2083\nU : ?m.4883 F f g\n\u22a2 sorry = CategoryStruct.comp sorry (CategoryStruct.comp sorry sorry)"}, {"line": "simp [PresheafedSpace.congr_app (F.map_comp f g)]", "tactic_state": "x\u271d\u00b2 : Sort u_1\nPresheafedSpace : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_2\npushforward : x\u271d\u00b9\nx\u271d : Sort u_3\npushforwardEq : x\u271d\nF : sorry\nj\u2081 j\u2082 j\u2083 : ?m.4880 F\nf : j\u2081 \u27f6 j\u2082\ng : j\u2082 \u27f6 j\u2083\nU : ?m.4883 F f g\n\u22a2 sorry () = CategoryStruct.comp (sorry ()) (CategoryStruct.comp (sorry ()) (sorry ()))"}]}
{"declaration": "theorem isComplement_univ_left : IsComplement univ S \u2194 \u2203 g : G, S = {g} := by\n  refine\n    \u27e8fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr \u27e8?_, fun a ha b hb => ?_\u27e9, ?_\u27e9\n  \u00b7 obtain \u27e8a, _\u27e9 := h.2 1\n    exact \u27e8a.2.1, a.2.2\u27e9\n  \u00b7 have : (\u27e8\u27e8_, mem_top a\u207b\u00b9\u27e9, \u27e8a, ha\u27e9\u27e9 : (\u22a4 : Set G) \u00d7 S) = \u27e8\u27e8_, mem_top b\u207b\u00b9\u27e9, \u27e8b, hb\u27e9\u27e9 :=\n      h.1 ((inv_mul_cancel a).trans (inv_mul_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).2\n  \u00b7 rintro \u27e8g, rfl\u27e9\n    exact isComplement_univ_singleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Complement.lean", "context": {"open": ["Function Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] (H K : Subgroup G) (S T : Set G)", "{H K S T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 sorry \u2194 \u2203 g, S = {g}"}, {"line": "refine\n    \u27e8fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr \u27e8?_, fun a ha b hb => ?_\u27e9, ?_\u27e9", "tactic_state": "case refine_1\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\n\u22a2 S.Nonempty\n---\ncase refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\na : G\nha : a \u2208 S\nb : G\nhb : b \u2208 S\n\u22a2 a = b\n---\ncase refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 obtain \u27e8a, _\u27e9 := h.2 1\n    exact \u27e8a.2.1, a.2.2\u27e9", "tactic_state": "case refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\na : G\nha : a \u2208 S\nb : G\nhb : b \u2208 S\n\u22a2 a = b\n---\ncase refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 have : (\u27e8\u27e8_, mem_top a\u207b\u00b9\u27e9, \u27e8a, ha\u27e9\u27e9 : (\u22a4 : Set G) \u00d7 S) = \u27e8\u27e8_, mem_top b\u207b\u00b9\u27e9, \u27e8b, hb\u27e9\u27e9 :=\n      h.1 ((inv_mul_cancel a).trans (inv_mul_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).2", "tactic_state": "case refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8g, rfl\u27e9\n    exact isComplement_univ_singleton", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isComplement_univ_right : IsComplement S univ \u2194 \u2203 g : G, S = {g} := by\n  refine\n    \u27e8fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr \u27e8?_, fun a ha b hb => ?_\u27e9, ?_\u27e9\n  \u00b7 obtain \u27e8a, _\u27e9 := h.2 1\n    exact \u27e8a.1.1, a.1.2\u27e9\n  \u00b7 have : (\u27e8\u27e8a, ha\u27e9, \u27e8_, mem_top a\u207b\u00b9\u27e9\u27e9 : S \u00d7 (\u22a4 : Set G)) = \u27e8\u27e8b, hb\u27e9, \u27e8_, mem_top b\u207b\u00b9\u27e9\u27e9 :=\n      h.1 ((mul_inv_cancel a).trans (mul_inv_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).1\n  \u00b7 rintro \u27e8g, rfl\u27e9\n    exact isComplement_singleton_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Complement.lean", "context": {"open": ["Function Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] (H K : Subgroup G) (S T : Set G)", "{H K S T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 sorry \u2194 \u2203 g, S = {g}"}, {"line": "refine\n    \u27e8fun h => Set.exists_eq_singleton_iff_nonempty_subsingleton.mpr \u27e8?_, fun a ha b hb => ?_\u27e9, ?_\u27e9", "tactic_state": "case refine_1\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\n\u22a2 S.Nonempty\n---\ncase refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\na : G\nha : a \u2208 S\nb : G\nhb : b \u2208 S\n\u22a2 a = b\n---\ncase refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 obtain \u27e8a, _\u27e9 := h.2 1\n    exact \u27e8a.1.1, a.1.2\u27e9", "tactic_state": "case refine_2\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\nh : sorry\na : G\nha : a \u2208 S\nb : G\nhb : b \u2208 S\n\u22a2 a = b\n---\ncase refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 have : (\u27e8\u27e8a, ha\u27e9, \u27e8_, mem_top a\u207b\u00b9\u27e9\u27e9 : S \u00d7 (\u22a4 : Set G)) = \u27e8\u27e8b, hb\u27e9, \u27e8_, mem_top b\u207b\u00b9\u27e9\u27e9 :=\n      h.1 ((mul_inv_cancel a).trans (mul_inv_cancel b).symm)\n    exact Subtype.ext_iff.mp (Prod.ext_iff.mp this).1", "tactic_state": "case refine_3\nG : Type u_1\ninst\u271d : Group G\nS : Set G\nx\u271d : Sort u_2\nIsComplement : x\u271d\n\u22a2 (\u2203 g, S = {g}) \u2192 sorry"}, {"line": "\u00b7 rintro \u27e8g, rfl\u27e9\n    exact isComplement_singleton_univ", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_right_transversal_of_le {H' H : Subgroup G} (h : H' \u2264 H) :\n    \u2203 S : Set G, H' * S = H \u2227 Nat.card H' * Nat.card S = Nat.card H := by\n  let H'' : Subgroup H := H'.comap H.subtype\n  have : H' = H''.map H.subtype := by simp [H'', h]\n  rw [this]\n  obtain \u27e8S, cmem, -\u27e9 := H''.exists_isComplement_right 1\n  refine \u27e8H.subtype '' S, ?_, ?_\u27e9\n  \u00b7 have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype\n    rw [\u2190 this]\n    rw [cmem.mul_eq]\n    simp [Set.ext_iff]\n  \u00b7 have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card\n    rw [\u2190 this]\n    refine congr_arg\u2082 (\u00b7 * \u00b7) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Complement.lean", "context": {"open": ["Function Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] (H K : Subgroup G) (S T : Set G)", "{H K S T}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\n\u22a2 \u2203 S, \u2191H' * S = \u2191H \u2227 Nat.card \u21a5H' * Nat.card \u2191S = Nat.card \u21a5H"}, {"line": "let H'' : Subgroup H := H'.comap H.subtype", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\n\u22a2 \u2203 S, \u2191H' * S = \u2191H \u2227 Nat.card \u21a5H' * Nat.card \u2191S = Nat.card \u21a5H"}, {"line": "have : H' = H''.map H.subtype := by simp [H'', h]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\n\u22a2 \u2203 S, \u2191H' * S = \u2191H \u2227 Nat.card \u21a5H' * Nat.card \u2191S = Nat.card \u21a5H"}, {"line": "rw [this]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\n\u22a2 \u2203 S, \u2191sorry * S = \u2191H \u2227 Nat.card \u21a5sorry * Nat.card \u2191S = Nat.card \u21a5H"}, {"line": "obtain \u27e8S, cmem, -\u27e9 := H''.exists_isComplement_right 1", "tactic_state": "case intro.intro\nG : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\nS : Set \u21a5H\ncmem : Subgroup.IsComplement (\u2191H'') S\n\u22a2 \u2203 S, \u2191sorry * S = \u2191H \u2227 Nat.card \u21a5sorry * Nat.card \u2191S = Nat.card \u21a5H"}, {"line": "refine \u27e8H.subtype '' S, ?_, ?_\u27e9", "tactic_state": "case intro.intro.refine_1\nG : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\nS : Set \u21a5H\ncmem : Subgroup.IsComplement (\u2191H'') S\n\u22a2 \u2191sorry * sorry '' S = \u2191H\n---\ncase intro.intro.refine_2\nG : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\nS : Set \u21a5H\ncmem : Subgroup.IsComplement (\u2191H'') S\n\u22a2 Nat.card \u21a5sorry * Nat.card \u2191(sorry '' S) = Nat.card \u21a5H"}, {"line": "\u00b7 have : H.subtype '' (H'' * S) = H''.map H.subtype * H.subtype '' S := image_mul H.subtype\n    rw [\u2190 this]\n    rw [cmem.mul_eq]\n    simp [Set.ext_iff]", "tactic_state": "case intro.intro.refine_2\nG : Type u_1\ninst\u271d : Group G\nH' H : Subgroup G\nh : H' \u2264 H\nH'' : Subgroup \u21a5H := sorry\nthis : H' = sorry\nS : Set \u21a5H\ncmem : Subgroup.IsComplement (\u2191H'') S\n\u22a2 Nat.card \u21a5sorry * Nat.card \u2191(sorry '' S) = Nat.card \u21a5H"}, {"line": "\u00b7 have : Nat.card H'' * Nat.card S = Nat.card H := cmem.card_mul_card\n    rw [\u2190 this]\n    refine congr_arg\u2082 (\u00b7 * \u00b7) ?_ ?_ <;>\n      exact Nat.card_congr (Equiv.Set.image _ _ <| subtype_injective H).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equiv_fst_eq_self_iff_mem {g : G} (h1 : 1 \u2208 T) :\n    ((hST.equiv g).fst : G) = g \u2194 g \u2208 S := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 h]\n    exact Subtype.prop _\n  \u00b7 intro h\n    rw [hST.equiv_fst_eq_self_of_mem_of_one_mem h1 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Complement.lean", "context": {"open": ["Function Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] (H K : Subgroup G) (S T : Set G)", "{H K S T}", "(hST : IsComplement S T) (hHT : IsComplement H T) (hSK : IsComplement S K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 T\n\u22a2 sorry = g \u2194 g \u2208 S"}, {"line": "constructor", "tactic_state": "case mp\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 T\n\u22a2 sorry = g \u2192 g \u2208 S\n---\ncase mpr\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 T\n\u22a2 g \u2208 S \u2192 sorry = g"}, {"line": "\u00b7 intro h\n    rw [\u2190 h]\n    exact Subtype.prop _", "tactic_state": "case mpr\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 T\n\u22a2 g \u2208 S \u2192 sorry = g"}, {"line": "\u00b7 intro h\n    rw [hST.equiv_fst_eq_self_of_mem_of_one_mem h1 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equiv_snd_eq_self_iff_mem {g : G} (h1 : 1 \u2208 S) :\n    ((hST.equiv g).snd : G) = g \u2194 g \u2208 T := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 h]\n    exact Subtype.prop _\n  \u00b7 intro h\n    rw [hST.equiv_snd_eq_self_of_mem_of_one_mem h1 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Complement.lean", "context": {"open": ["Function Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] (H K : Subgroup G) (S T : Set G)", "{H K S T}", "(hST : IsComplement S T) (hHT : IsComplement H T) (hSK : IsComplement S K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 S\n\u22a2 sorry = g \u2194 g \u2208 T"}, {"line": "constructor", "tactic_state": "case mp\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 S\n\u22a2 sorry = g \u2192 g \u2208 T\n---\ncase mpr\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 S\n\u22a2 g \u2208 T \u2192 sorry = g"}, {"line": "\u00b7 intro h\n    rw [\u2190 h]\n    exact Subtype.prop _", "tactic_state": "case mpr\nIsComplement : ?m.1343\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nH K : Subgroup G\u271d\nS\u271d T\u271d : Set G\u271d\nhST : sorry\nhHT : sorry\nhSK : sorry\nG : Type u_1\ninst\u271d : Group G\nS T : Set G\ng : G\nh1 : 1 \u2208 S\n\u22a2 g \u2208 T \u2192 sorry = g"}, {"line": "\u00b7 intro h\n    rw [hST.equiv_snd_eq_self_of_mem_of_one_mem h1 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul : m\u2081 = m\u2082 := by\n  funext a b\n  calc\n    m\u2081 a b = m\u2081 (m\u2082 a e\u2081) (m\u2082 e\u2081 b) := by\n      { simp only [one h\u2081 h\u2082 distrib, h\u2081.left_id, h\u2081.right_id, h\u2082.left_id, h\u2082.right_id] }\n    _ = m\u2082 a b := by simp only [distrib, h\u2081.left_id, h\u2081.right_id, h\u2082.left_id, h\u2082.right_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/EckmannHilton.lean", "context": {"open": [], "variables": ["{X : Type u}", "{m\u2081 m\u2082 : X \u2192 X \u2192 X} {e\u2081 e\u2082 : X}", "(h\u2081 : IsUnital m\u2081 e\u2081) (h\u2082 : IsUnital m\u2082 e\u2082)", "(distrib : \u2200 a b c d, ((a <m\u2082> b) <m\u2081> c <m\u2082> d) = (a <m\u2081> c) <m\u2082> b <m\u2081> d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "IsUnital : ?m.1767\nX\u271d : Type u\nm\u2081\u271d m\u2082\u271d : X\u271d \u2192 X\u271d \u2192 X\u271d\ne\u2081 e\u2082 : X\u271d\nh\u2081 : sorry\nh\u2082 : sorry\ndistrib : \u2200 (a : Matroid (?m.2626 h\u2081 h\u2082)) (b : ?m.2627 h\u2081 h\u2082 a) (c : ?m.2628 h\u2081 h\u2082 a b), ?m.2629 h\u2081 h\u2082 a b c \u2192 sorry\nX : Type u\nm\u2081 m\u2082 : X \u2192 X \u2192 X\n\u22a2 m\u2081 = m\u2082"}, {"line": "funext a b", "tactic_state": "case h.h\nIsUnital : ?m.1767\nX\u271d : Type u\nm\u2081\u271d m\u2082\u271d : X\u271d \u2192 X\u271d \u2192 X\u271d\ne\u2081 e\u2082 : X\u271d\nh\u2081 : sorry\nh\u2082 : sorry\ndistrib : \u2200 (a : Matroid (?m.2626 h\u2081 h\u2082)) (b : ?m.2627 h\u2081 h\u2082 a) (c : ?m.2628 h\u2081 h\u2082 a b), ?m.2629 h\u2081 h\u2082 a b c \u2192 sorry\nX : Type u\nm\u2081 m\u2082 : X \u2192 X \u2192 X\na b : X\n\u22a2 m\u2081 a b = m\u2082 a b"}, {"line": "calc\n    m\u2081 a b = m\u2081 (m\u2082 a e\u2081) (m\u2082 e\u2081 b) := by\n      { simp only [one h\u2081 h\u2082 distrib, h\u2081.left_id, h\u2081.right_id, h\u2082.left_id, h\u2082.right_id] }\n    _ = m\u2082 a b := by simp only [distrib, h\u2081.left_id, h\u2081.right_id, h\u2082.left_id, h\u2082.right_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_fixed_point_of_prime_dvd_card_of_fixed_point (hp\u03b1 : p \u2223 Nat.card \u03b1) {a : \u03b1}\n    (ha : a \u2208 fixedPoints G \u03b1) : \u2203 b, b \u2208 fixedPoints G \u03b1 \u2227 a \u2260 b := by\n  have hpf : p \u2223 Nat.card (fixedPoints G \u03b1) :=\n    Nat.modEq_zero_iff_dvd.mp ((hG.card_modEq_card_fixedPoints \u03b1).symm.trans hp\u03b1.modEq_zero_nat)\n  have h\u03b1 : 1 < Nat.card (fixedPoints G \u03b1) :=\n    (Fact.out (p := p.Prime)).one_lt.trans_le (Nat.le_of_dvd (Finite.card_pos_iff.2 \u27e8\u27e8a, ha\u27e9\u27e9) hpf)\n  rw [Finite.one_lt_card_iff_nontrivial] at h\u03b1\n  exact\n    let \u27e8\u27e8b, hb\u27e9, hba\u27e9 := exists_ne (\u27e8a, ha\u27e9 : fixedPoints G \u03b1)\n    \u27e8b, hb, fun hab => hba (by simp_rw [hab])\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PGroup.lean", "context": {"open": ["Fintype MulAction"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(hG : IsPGroup p G)", "[hp : Fact p.Prime]", "{\u03b1 : Type*} [MulAction G \u03b1]", "(\u03b1) [Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\n\u22a2 \u2203 b \u2208 fixedPoints G \u03b1, a \u2260 b"}, {"line": "have hpf : p \u2223 Nat.card (fixedPoints G \u03b1) :=\n    Nat.modEq_zero_iff_dvd.mp ((hG.card_modEq_card_fixedPoints \u03b1).symm.trans hp\u03b1.modEq_zero_nat)", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\nhpf : p \u2223 Nat.card sorry\n\u22a2 \u2203 b \u2208 fixedPoints G \u03b1, a \u2260 b"}, {"line": "have h\u03b1 : 1 < Nat.card (fixedPoints G \u03b1) :=\n    (Fact.out (p := p.Prime)).one_lt.trans_le (Nat.le_of_dvd (Finite.card_pos_iff.2 \u27e8\u27e8a, ha\u27e9\u27e9) hpf)", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\nhpf : p \u2223 Nat.card sorry\nh\u03b1 : 1 < Nat.card sorry\n\u22a2 \u2203 b \u2208 fixedPoints G \u03b1, a \u2260 b"}, {"line": "rw [Finite.one_lt_card_iff_nontrivial] at h\u03b1", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\nhpf : p \u2223 Nat.card sorry\nh\u03b1 : Nontrivial sorry\n\u22a2 \u2203 b \u2208 fixedPoints G \u03b1, a \u2260 b\n---\np : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\nhpf : p \u2223 Nat.card sorry\nh\u03b1 : 1 < Nat.card sorry\n\u22a2 Finite sorry"}, {"line": "exact\n    let \u27e8\u27e8b, hb\u27e9, hba\u27e9 := exists_ne (\u27e8a, ha\u27e9 : fixedPoints G \u03b1)\n    \u27e8b, hb, fun hab => hba (by simp_rw [hab])\u27e9", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d\u00b2 : Group G\nhp : Fact (Nat.Prime p)\n\u03b1 : Type u_2\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : Finite \u03b1\nhp\u03b1 : p \u2223 Nat.card \u03b1\na : \u03b1\nha : a \u2208 fixedPoints G \u03b1\nhpf : p \u2223 Nat.card sorry\nh\u03b1 : 1 < Nat.card sorry\n\u22a2 Finite sorry"}]}
{"declaration": "lemma isPGroup_multiplicative : IsPGroup n (Multiplicative G) := by\n  simpa [IsPGroup, Multiplicative.forall] using\n    fun _ \u21a6 \u27e81, by simp [\u2190 ofAdd_nsmul, ZModModule.char_nsmul_eq_zero]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PGroup.lean", "context": {"open": ["Fintype MulAction", "Subgroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(hG : IsPGroup p G)", "[hp : Fact p.Prime]", "{\u03b1 : Type*} [MulAction G \u03b1]", "(\u03b1) [Finite \u03b1]", "[Fact p.Prime] {n : \u2115}", "{n : \u2115} {G : Type*} [AddCommGroup G] [Module (ZMod n) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nG : Type u_3\ninst\u271d\u00b9 : AddCommGroup G\ninst\u271d : Module (ZMod n) G\n\u22a2 IsPGroup n (Multiplicative G)"}, {"line": "simpa [IsPGroup, Multiplicative.forall] using\n    fun _ \u21a6 \u27e81, by simp [\u2190 ofAdd_nsmul, ZModModule.char_nsmul_eq_zero]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_mul_image_eq_top (hR : IsComplement H R) (hR1 : (1 : G) \u2208 R)\n    (hS : closure S = \u22a4) : closure ((R * S).image fun g =>\n      \u27e8g * (hR.toRightFun g : G)\u207b\u00b9, hR.mul_inv_toRightFun_mem g\u27e9 : Set H) = \u22a4 := by\n  rw [eq_top_iff]\n  rw [\u2190 map_subtype_le_map_subtype]\n  rw [MonoidHom.map_closure]\n  rw [Set.image_image]\n  exact (map_subtype_le \u22a4).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Schreier.lean", "context": {"open": ["scoped Finset Pointwise", "Subgroup", "MemRightTransversals"], "variables": ["(G : Type*) [CommGroup G] [Group.FG G]", "{G : Type*} [Group G] {H : Subgroup G} {R S : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nR S : Set G\nhR : IsComplement (\u2191H) R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure S = \u22a4\n\u22a2 Subgroup.closure ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' (R * S)) = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nR S : Set G\nhR : IsComplement (\u2191H) R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure S = \u22a4\n\u22a2 \u22a4 \u2264 Subgroup.closure ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' (R * S))"}, {"line": "rw [\u2190 map_subtype_le_map_subtype]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nR S : Set G\nhR : IsComplement (\u2191H) R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure S = \u22a4\n\u22a2 map H.subtype \u22a4 \u2264 map H.subtype (Subgroup.closure ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' (R * S)))"}, {"line": "rw [MonoidHom.map_closure]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nR S : Set G\nhR : IsComplement (\u2191H) R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure S = \u22a4\n\u22a2 map H.subtype \u22a4 \u2264 Subgroup.closure (\u21d1H.subtype '' ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' (R * S)))"}, {"line": "rw [Set.image_image]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nR S : Set G\nhR : IsComplement (\u2191H) R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure S = \u22a4\n\u22a2 map H.subtype \u22a4 \u2264 Subgroup.closure ((fun x => H.subtype \u27e8x * (\u2191(hR.toRightFun x))\u207b\u00b9, \u22ef\u27e9) '' (R * S))"}, {"line": "exact (map_subtype_le \u22a4).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_mul_image_eq_top' [DecidableEq G] {R S : Finset G}\n    (hR : IsComplement (H : Set G) R) (hR1 : (1 : G) \u2208 R)\n    (hS : closure (S : Set G) = \u22a4) :\n    closure (((R * S).image fun g => \u27e8_, hR.mul_inv_toRightFun_mem g\u27e9 : Finset H) : Set H) = \u22a4 := by\n  rw [Finset.coe_image]\n  rw [Finset.coe_mul]\n  exact closure_mul_image_eq_top hR hR1 hS\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Schreier.lean", "context": {"open": ["scoped Finset Pointwise", "Subgroup", "MemRightTransversals"], "variables": ["(G : Type*) [CommGroup G] [Group.FG G]", "{G : Type*} [Group G] {H : Subgroup G} {R S : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : DecidableEq G\nR S : Finset G\nhR : IsComplement \u2191H \u2191R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure \u2191S = \u22a4\n\u22a2 Subgroup.closure \u2191(Finset.image (fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) (R * S)) = \u22a4"}, {"line": "rw [Finset.coe_image]", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : DecidableEq G\nR S : Finset G\nhR : IsComplement \u2191H \u2191R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure \u2191S = \u22a4\n\u22a2 Subgroup.closure ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' \u2191(R * S)) = \u22a4"}, {"line": "rw [Finset.coe_mul]", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : Group G\nH : Subgroup G\ninst\u271d : DecidableEq G\nR S : Finset G\nhR : IsComplement \u2191H \u2191R\nhR1 : 1 \u2208 R\nhS : Subgroup.closure \u2191S = \u22a4\n\u22a2 Subgroup.closure ((fun g => \u27e8g * (\u2191(hR.toRightFun g))\u207b\u00b9, \u22ef\u27e9) '' (\u2191R * \u2191S)) = \u22a4"}, {"line": "exact closure_mul_image_eq_top hR hR1 hS", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commutator_eq_closure : commutator G = Subgroup.closure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def, commutatorSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Abelianization.lean", "context": {"open": ["Subgroup (centralizer)"], "variables": ["(G : Type u) [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 commutator G = Subgroup.closure (commutatorSet G)"}, {"line": "simp [commutator, Subgroup.commutator_def, commutatorSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commutator_eq_normalClosure : commutator G = Subgroup.normalClosure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def', commutatorSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Abelianization.lean", "context": {"open": ["Subgroup (centralizer)"], "variables": ["(G : Type u) [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 commutator G = Subgroup.normalClosure (commutatorSet G)"}, {"line": "simp [commutator, Subgroup.commutator_def', commutatorSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commutator_subset_ker : commutator G \u2264 f.ker := by\n  rw [commutator_eq_closure]\n  rw [Subgroup.closure_le]\n  rintro x \u27e8p, q, rfl\u27e9\n  simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Abelianization.lean", "context": {"open": ["Subgroup (centralizer)"], "variables": ["(G : Type u) [Group G]", "{G} in", "{G}", "(G) in", "{A : Type v} [CommGroup A] (f : G \u2192* A)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 commutator G \u2264 sorry"}, {"line": "rw [commutator_eq_closure]", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 Subgroup.closure (commutatorSet G) \u2264 sorry"}, {"line": "rw [Subgroup.closure_le]", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 commutatorSet G \u2286 \u2191sorry"}, {"line": "rintro x \u27e8p, q, rfl\u27e9", "tactic_state": "case intro.intro\nG : Type u\ninst\u271d : Group G\np q : G\n\u22a2 \u2045p, q\u2046 \u2208 \u2191sorry"}, {"line": "simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]", "tactic_state": "case intro.intro\nG : Type u\ninst\u271d : Group G\np q : G\n\u22a2 p * q * p\u207b\u00b9 * q\u207b\u00b9 \u2208 sorry ()"}]}
{"declaration": "theorem image_commutatorSet_closureCommutatorRepresentatives :\n    (closureCommutatorRepresentatives G).subtype ''\n        commutatorSet (closureCommutatorRepresentatives G) =\n      commutatorSet G := by\n  apply Set.Subset.antisymm\n  \u00b7 rintro - \u27e8-, \u27e8g\u2081, g\u2082, rfl\u27e9, rfl\u27e9\n    exact \u27e8g\u2081, g\u2082, rfl\u27e9\n  \u00b7 exact fun g hg =>\n      \u27e8_,\n        \u27e8\u27e8_, subset_closure (Or.inl \u27e8_, \u27e8\u27e8g, hg\u27e9, rfl\u27e9, rfl\u27e9)\u27e9,\n          \u27e8_, subset_closure (Or.inr \u27e8_, \u27e8\u27e8g, hg\u27e9, rfl\u27e9, rfl\u27e9)\u27e9, rfl\u27e9,\n        hg.choose_spec.choose_spec\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Abelianization.lean", "context": {"open": ["Subgroup (centralizer)", "Subgroup"], "variables": ["(G : Type u) [Group G]", "{G} in", "{G}", "(G) in", "{A : Type v} [CommGroup A] (f : G \u2192* A)", "{A : Type v} [Monoid A]", "{H : Type v} [Group H] (f : G \u2192* H)", "{G} {H : Type v} [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Group G\n\u22a2 \u21d1(closureCommutatorRepresentatives G).subtype '' commutatorSet \u21a5(closureCommutatorRepresentatives G) = commutatorSet G"}, {"line": "apply Set.Subset.antisymm", "tactic_state": "case h\u2081\nG : Type u\ninst\u271d : Group G\n\u22a2 \u21d1(closureCommutatorRepresentatives G).subtype '' commutatorSet \u21a5(closureCommutatorRepresentatives G) \u2286 commutatorSet G\n---\ncase h\u2082\nG : Type u\ninst\u271d : Group G\n\u22a2 commutatorSet G \u2286 \u21d1(closureCommutatorRepresentatives G).subtype '' commutatorSet \u21a5(closureCommutatorRepresentatives G)"}, {"line": "\u00b7 rintro - \u27e8-, \u27e8g\u2081, g\u2082, rfl\u27e9, rfl\u27e9\n    exact \u27e8g\u2081, g\u2082, rfl\u27e9", "tactic_state": "case h\u2082\nG : Type u\ninst\u271d : Group G\n\u22a2 commutatorSet G \u2286 \u21d1(closureCommutatorRepresentatives G).subtype '' commutatorSet \u21a5(closureCommutatorRepresentatives G)"}, {"line": "\u00b7 exact fun g hg =>\n      \u27e8_,\n        \u27e8\u27e8_, subset_closure (Or.inl \u27e8_, \u27e8\u27e8g, hg\u27e9, rfl\u27e9, rfl\u27e9)\u27e9,\n          \u27e8_, subset_closure (Or.inr \u27e8_, \u27e8\u27e8g, hg\u27e9, rfl\u27e9, rfl\u27e9)\u27e9, rfl\u27e9,\n        hg.choose_spec.choose_spec\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subgroup.Normal.quotient_commutative_iff_commutator_le {N : Subgroup G} [N.Normal] :\n    Std.Commutative (\u00b7 * \u00b7 : G \u29f8 N \u2192 _ \u2192 _) \u2194 _root_.commutator G \u2264 N := by\n  constructor\n  \u00b7 intro hcomm\n    rw [commutator_eq_normalClosure]\n    rw [\u2190 Subgroup.normalClosure_subset_iff]\n    rintro x \u27e8p, q, rfl\u27e9\n    rw [SetLike.mem_coe]\n    rw [\u2190 QuotientGroup.eq_one_iff]\n    rw [commutatorElement_def]\n    simp only [SetLike.mem_coe]\n    simp only [\u2190 QuotientGroup.eq_one_iff]\n    simp only [commutatorElement_def]\n    simp only [QuotientGroup.mk_mul]\n    simp only [QuotientGroup.mk_inv]\n    simp only [\u2190 commutatorElement_def]\n    simp only [commutatorElement_eq_one_iff_mul_comm]\n    apply hcomm.comm\n  \u00b7 intro hGN\n    apply Std.Commutative.mk\n    rintro x'; obtain \u27e8x, rfl\u27e9 := QuotientGroup.mk'_surjective N x'\n    intro y'; obtain \u27e8y, rfl\u27e9 := QuotientGroup.mk'_surjective N y'\n    rw [\u2190 commutatorElement_eq_one_iff_mul_comm]\n    rw [\u2190 map_commutatorElement]\n    rw [QuotientGroup.mk'_apply]\n    rw [QuotientGroup.eq_one_iff]\n    apply hGN\n    rw [commutator_eq_closure]\n    exact Subgroup.subset_closure (commutator_mem_commutatorSet x y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Abelianization.lean", "context": {"open": ["Subgroup (centralizer)", "Subgroup"], "variables": ["(G : Type u) [Group G]", "{G} in", "{G}", "(G) in", "{A : Type v} [CommGroup A] (f : G \u2192* A)", "{A : Type v} [Monoid A]", "{H : Type v} [Group H] (f : G \u2192* H)", "{G} {H : Type v} [Group H]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\nN : Subgroup G\ninst\u271d : N.Normal\n\u22a2 (Std.Commutative fun x1 x2 => x1 * x2) \u2194 _root_.commutator G \u2264 N"}, {"line": "constructor", "tactic_state": "case mp\nG : Type u\ninst\u271d\u00b9 : Group G\nN : Subgroup G\ninst\u271d : N.Normal\n\u22a2 (Std.Commutative fun x1 x2 => x1 * x2) \u2192 _root_.commutator G \u2264 N\n---\ncase mpr\nG : Type u\ninst\u271d\u00b9 : Group G\nN : Subgroup G\ninst\u271d : N.Normal\n\u22a2 _root_.commutator G \u2264 N \u2192 Std.Commutative fun x1 x2 => x1 * x2"}, {"line": "\u00b7 intro hcomm\n    rw [commutator_eq_normalClosure]\n    rw [\u2190 Subgroup.normalClosure_subset_iff]\n    rintro x \u27e8p, q, rfl\u27e9\n    rw [SetLike.mem_coe]\n    rw [\u2190 QuotientGroup.eq_one_iff]\n    rw [commutatorElement_def]\n    simp only [SetLike.mem_coe]\n    simp only [\u2190 QuotientGroup.eq_one_iff]\n    simp only [commutatorElement_def]\n    simp only [QuotientGroup.mk_mul]\n    simp only [QuotientGroup.mk_inv]\n    simp only [\u2190 commutatorElement_def]\n    simp only [commutatorElement_eq_one_iff_mul_comm]\n    apply hcomm.comm", "tactic_state": "case mpr\nG : Type u\ninst\u271d\u00b9 : Group G\nN : Subgroup G\ninst\u271d : N.Normal\n\u22a2 _root_.commutator G \u2264 N \u2192 Std.Commutative fun x1 x2 => x1 * x2"}, {"line": "\u00b7 intro hGN\n    apply Std.Commutative.mk\n    rintro x'; obtain \u27e8x, rfl\u27e9 := QuotientGroup.mk'_surjective N x'\n    intro y'; obtain \u27e8y, rfl\u27e9 := QuotientGroup.mk'_surjective N y'\n    rw [\u2190 commutatorElement_eq_one_iff_mul_comm]\n    rw [\u2190 map_commutatorElement]\n    rw [QuotientGroup.mk'_apply]\n    rw [QuotientGroup.eq_one_iff]\n    apply hGN\n    rw [commutator_eq_closure]\n    exact Subgroup.subset_closure (commutator_mem_commutatorSet x y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subgroup.cyclic_of_isolated_one {H : Subgroup G} {a : G} (h\u2080 : 1 < a)\n    (hd : Disjoint (H : Set G) (Ioo 1 a)) : \u2203 b, H = closure {b} := by\n  rcases eq_or_ne H \u22a5 with rfl | hbot\n  \u00b7 exact \u27e81, closure_singleton_one.symm\u27e9\n  \u00b7 exact (exists_isLeast_one_lt hbot h\u2080 hd).imp fun _ => cyclic_of_min\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Archimedean.lean", "context": {"open": ["Set"], "variables": ["{G : Type*} [CommGroup G] [LinearOrder G] [IsOrderedMonoid G] [MulArchimedean G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\nH : Subgroup G\na : G\nh\u2080 : 1 < a\nhd : Disjoint (\u2191H) (Ioo 1 a)\n\u22a2 \u2203 b, H = closure {b}"}, {"line": "rcases eq_or_ne H \u22a5 with rfl | hbot", "tactic_state": "case inl\nG : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\na : G\nh\u2080 : 1 < a\nhd : Disjoint (\u2191\u22a5) (Ioo 1 a)\n\u22a2 \u2203 b, \u22a5 = closure {b}\n---\ncase inr\nG : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\nH : Subgroup G\na : G\nh\u2080 : 1 < a\nhd : Disjoint (\u2191H) (Ioo 1 a)\nhbot : H \u2260 \u22a5\n\u22a2 \u2203 b, H = closure {b}"}, {"line": "\u00b7 exact \u27e81, closure_singleton_one.symm\u27e9", "tactic_state": "case inr\nG : Type u_1\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : LinearOrder G\ninst\u271d\u00b9 : IsOrderedMonoid G\ninst\u271d : MulArchimedean G\nH : Subgroup G\na : G\nh\u2080 : 1 < a\nhd : Disjoint (\u2191H) (Ioo 1 a)\nhbot : H \u2260 \u22a5\n\u22a2 \u2203 b, H = closure {b}"}, {"line": "\u00b7 exact (exists_isLeast_one_lt hbot h\u2080 hd).imp fun _ => cyclic_of_min", "tactic_state": "No Goals!"}]}
{"declaration": "lemma WithZero.mulArchimedean_iff {\u03b1} [CommGroup \u03b1] [PartialOrder \u03b1] :\n    MulArchimedean (WithZero \u03b1) \u2194 MulArchimedean \u03b1 := by\n  constructor <;> intro _\n  \u00b7 exact OrderMonoidIso.unitsWithZero.mulArchimedean\n  \u00b7 infer_instance", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/ArchimedeanDensely.lean", "context": {"open": ["Multiplicative Set", "Subgroup in", "WithZero in"], "variables": ["{G : Type*} [CommGroup G] [LinearOrder G] [IsOrderedMonoid G] [MulArchimedean G]", "(G) in", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : PartialOrder \u03b1\n\u22a2 MulArchimedean (WithZero \u03b1) \u2194 MulArchimedean \u03b1"}, {"line": "constructor <;> intro _", "tactic_state": "case mp\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : PartialOrder \u03b1\na\u271d : MulArchimedean (WithZero \u03b1)\n\u22a2 MulArchimedean \u03b1\n---\ncase mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : PartialOrder \u03b1\na\u271d : MulArchimedean \u03b1\n\u22a2 MulArchimedean (WithZero \u03b1)"}, {"line": "\u00b7 exact OrderMonoidIso.unitsWithZero.mulArchimedean", "tactic_state": "case mpr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : CommGroup \u03b1\ninst\u271d : PartialOrder \u03b1\na\u271d : MulArchimedean \u03b1\n\u22a2 MulArchimedean (WithZero \u03b1)"}, {"line": "\u00b7 infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commProb_prod (M' : Type*) [Mul M'] : commProb (M \u00d7 M') = commProb M * commProb M' := by\n  simp_rw [commProb_def, div_mul_div_comm, Nat.card_prod, Nat.cast_mul, mul_pow, \u2190 Nat.cast_mul,\n    \u2190 Nat.card_prod, Commute, SemiconjBy, Prod.ext_iff]\n  congr 2\n  exact Nat.card_congr \u27e8fun x => \u27e8\u27e8\u27e8x.1.1.1, x.1.2.1\u27e9, x.2.1\u27e9, \u27e8\u27e8x.1.1.2, x.1.2.2\u27e9, x.2.2\u27e9\u27e9,\n    fun x => \u27e8\u27e8\u27e8x.1.1.1, x.2.1.1\u27e9, \u27e8x.1.1.2, x.2.1.2\u27e9\u27e9, \u27e8x.1.2, x.2.2\u27e9\u27e9, fun x => rfl, fun x => rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CommutingProbability.lean", "context": {"open": ["Fintype"], "variables": ["(M : Type*) [Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Mul M\nM' : Type u_2\ninst\u271d : Mul M'\n\u22a2 commProb (M \u00d7 M') = commProb M * commProb M'"}, {"line": "simp_rw [commProb_def, div_mul_div_comm, Nat.card_prod, Nat.cast_mul, mul_pow, \u2190 Nat.cast_mul,\n    \u2190 Nat.card_prod, Commute, SemiconjBy, Prod.ext_iff]", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Mul M\nM' : Type u_2\ninst\u271d : Mul M'\n\u22a2 \u2191(Nat.card { p // (p.1 * p.2).1 = (p.2 * p.1).1 \u2227 (p.1 * p.2).2 = (p.2 * p.1).2 }) /\n      (\u2191(Nat.card M) ^ 2 * \u2191(Nat.card M') ^ 2) =\n    \u2191(Nat.card ({ p // p.1 * p.2 = p.2 * p.1 } \u00d7 { p // p.1 * p.2 = p.2 * p.1 })) /\n      (\u2191(Nat.card M) ^ 2 * \u2191(Nat.card M') ^ 2)"}, {"line": "congr 2", "tactic_state": "case e_a.e_a\nM : Type u_1\ninst\u271d\u00b9 : Mul M\nM' : Type u_2\ninst\u271d : Mul M'\n\u22a2 Nat.card { p // (p.1 * p.2).1 = (p.2 * p.1).1 \u2227 (p.1 * p.2).2 = (p.2 * p.1).2 } =\n    Nat.card ({ p // p.1 * p.2 = p.2 * p.1 } \u00d7 { p // p.1 * p.2 = p.2 * p.1 })"}, {"line": "exact Nat.card_congr \u27e8fun x => \u27e8\u27e8\u27e8x.1.1.1, x.1.2.1\u27e9, x.2.1\u27e9, \u27e8\u27e8x.1.1.2, x.1.2.2\u27e9, x.2.2\u27e9\u27e9,\n    fun x => \u27e8\u27e8\u27e8x.1.1.1, x.2.1.1\u27e9, \u27e8x.1.1.2, x.2.1.2\u27e9\u27e9, \u27e8x.1.2, x.2.2\u27e9\u27e9, fun x => rfl, fun x => rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commProb_pi {\u03b1 : Type*} (i : \u03b1 \u2192 Type*) [Fintype \u03b1] [\u2200 a, Mul (i a)] :\n    commProb (\u2200 a, i a) = \u220f a, commProb (i a) := by\n  simp_rw [commProb_def, Finset.prod_div_distrib, Finset.prod_pow, \u2190 Nat.cast_prod,\n    \u2190 Nat.card_pi, Commute, SemiconjBy, funext_iff]\n  congr 2\n  exact Nat.card_congr \u27e8fun x a => \u27e8\u27e8x.1.1 a, x.1.2 a\u27e9, x.2 a\u27e9, fun x => \u27e8\u27e8fun a => (x a).1.1,\n    fun a => (x a).1.2\u27e9, fun a => (x a).2\u27e9, fun x => rfl, fun x => rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CommutingProbability.lean", "context": {"open": ["Fintype"], "variables": ["(M : Type*) [Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ni : \u03b1 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : (a : \u03b1) \u2192 Mul (i a)\n\u22a2 commProb ((a : \u03b1) \u2192 i a) = \u220f a, commProb (i a)"}, {"line": "simp_rw [commProb_def, Finset.prod_div_distrib, Finset.prod_pow, \u2190 Nat.cast_prod,\n    \u2190 Nat.card_pi, Commute, SemiconjBy, funext_iff]", "tactic_state": "\u03b1 : Type u_2\ni : \u03b1 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : (a : \u03b1) \u2192 Mul (i a)\n\u22a2 \u2191(Nat.card { p // \u2200 (x : \u03b1), (p.1 * p.2) x = (p.2 * p.1) x }) / \u2191(Nat.card ((a : \u03b1) \u2192 i a)) ^ 2 =\n    \u2191(Nat.card ((a : \u03b1) \u2192 { p // p.1 * p.2 = p.2 * p.1 })) / \u2191(Nat.card ((a : \u03b1) \u2192 i a)) ^ 2"}, {"line": "congr 2", "tactic_state": "case e_a.e_a\n\u03b1 : Type u_2\ni : \u03b1 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : (a : \u03b1) \u2192 Mul (i a)\n\u22a2 Nat.card { p // \u2200 (x : \u03b1), (p.1 * p.2) x = (p.2 * p.1) x } = Nat.card ((a : \u03b1) \u2192 { p // p.1 * p.2 = p.2 * p.1 })"}, {"line": "exact Nat.card_congr \u27e8fun x a => \u27e8\u27e8x.1.1 a, x.1.2 a\u27e9, x.2 a\u27e9, fun x => \u27e8\u27e8fun a => (x a).1.1,\n    fun a => (x a).1.2\u27e9, fun a => (x a).2\u27e9, fun x => rfl, fun x => rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commProb_def' : commProb G = Nat.card (ConjClasses G) / Nat.card G := by\n  rw [commProb]\n  rw [card_comm_eq_card_conjClasses_mul_card]\n  rw [Nat.cast_mul]\n  rw [sq]\n  by_cases h : (Nat.card G : \u211a) = 0\n  \u00b7 rw [h, zero_mul, div_zero, div_zero]\n  \u00b7 exact mul_div_mul_right _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CommutingProbability.lean", "context": {"open": ["Fintype"], "variables": ["(M : Type*) [Mul M]", "[Finite M]", "{M}", "(G : Type*) [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\n\u22a2 commProb G = \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "rw [commProb]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\n\u22a2 \u2191(Nat.card { p // Commute p.1 p.2 }) / \u2191(Nat.card G) ^ 2 = \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "rw [card_comm_eq_card_conjClasses_mul_card]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\n\u22a2 \u2191(Nat.card (ConjClasses G) * Nat.card G) / \u2191(Nat.card G) ^ 2 = \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "rw [Nat.cast_mul]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\n\u22a2 \u2191(Nat.card (ConjClasses G)) * \u2191(Nat.card G) / \u2191(Nat.card G) ^ 2 = \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "rw [sq]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\n\u22a2 \u2191(Nat.card (ConjClasses G)) * \u2191(Nat.card G) / (\u2191(Nat.card G) * \u2191(Nat.card G)) =\n    \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "by_cases h : (Nat.card G : \u211a) = 0", "tactic_state": "case pos\nG : Type u_2\ninst\u271d : Group G\nh : \u2191(Nat.card G) = 0\n\u22a2 \u2191(Nat.card (ConjClasses G)) * \u2191(Nat.card G) / (\u2191(Nat.card G) * \u2191(Nat.card G)) =\n    \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)\n---\ncase neg\nG : Type u_2\ninst\u271d : Group G\nh : \u00ac\u2191(Nat.card G) = 0\n\u22a2 \u2191(Nat.card (ConjClasses G)) * \u2191(Nat.card G) / (\u2191(Nat.card G) * \u2191(Nat.card G)) =\n    \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "\u00b7 rw [h, zero_mul, div_zero, div_zero]", "tactic_state": "case neg\nG : Type u_2\ninst\u271d : Group G\nh : \u00ac\u2191(Nat.card G) = 0\n\u22a2 \u2191(Nat.card (ConjClasses G)) * \u2191(Nat.card G) / (\u2191(Nat.card G) * \u2191(Nat.card G)) =\n    \u2191(Nat.card (ConjClasses G)) / \u2191(Nat.card G)"}, {"line": "\u00b7 exact mul_div_mul_right _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma commProb_nil : commProb (Product []) = 1 := by\n  simp [Product, commProb_pi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CommutingProbability.lean", "context": {"open": ["Fintype"], "variables": ["(M : Type*) [Mul M]", "[Finite M]", "{M}", "(G : Type*) [Group G]", "{G}", "[Finite G] (H : Subgroup G)", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nProduct : x\u271d\n\u22a2 commProb sorry = 1"}, {"line": "simp [Product, commProb_pi]", "tactic_state": "x\u271d : Sort u_3\nProduct : x\u271d\n\u22a2 commProb (sorry ()) = 1"}]}
{"declaration": "lemma commProb_cons (n : \u2115) (l : List \u2115) :\n    commProb (Product (n :: l)) = commProb (DihedralGroup n) * commProb (Product l) := by\n  simp [Product, commProb_pi, Fin.prod_univ_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CommutingProbability.lean", "context": {"open": ["Fintype"], "variables": ["(M : Type*) [Mul M]", "[Finite M]", "{M}", "(G : Type*) [Group G]", "{G}", "[Finite G] (H : Subgroup G)", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nProduct : x\u271d\nn : \u2115\nl : List \u2115\n\u22a2 commProb sorry = commProb (DihedralGroup n) * commProb sorry"}, {"line": "simp [Product, commProb_pi, Fin.prod_univ_succ]", "tactic_state": "x\u271d : Sort u_3\nProduct : x\u271d\nn : \u2115\nl : List \u2115\n\u22a2 commProb (sorry ()) = commProb (DihedralGroup n) * commProb (sorry ())"}]}
{"declaration": "theorem lift_mrange_le {N} [Monoid N] (f : \u2200 i, M i \u2192* N) {s : Submonoid N} :\n    MonoidHom.mrange (lift f) \u2264 s \u2194 \u2200 i, MonoidHom.mrange (f i) \u2264 s := by\n  simp [mrange_eq_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (M i)\nx\u271d : Sort u_4\nlift : x\u271d\nN : Type u_5\ninst\u271d : Monoid N\nf : (i : \u03b9) \u2192 M i \u2192* N\ns : Submonoid N\n\u22a2 MonoidHom.mrange sorry \u2264 s \u2194 \u2200 (i : \u03b9), MonoidHom.mrange (f i) \u2264 s"}, {"line": "simp [mrange_eq_iSup]", "tactic_state": "\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (M i)\nx\u271d : Sort u_4\nlift : x\u271d\nN : Type u_5\ninst\u271d : Monoid N\nf : (i : \u03b9) \u2192 M i \u2192* N\ns : Submonoid N\n\u22a2 MonoidHom.mrange (sorry ()) \u2264 s \u2194 \u2200 (i : \u03b9), MonoidHom.mrange (f i) \u2264 s"}]}
{"declaration": "theorem range_eq_iSup {N} [Group N] (f : \u2200 i, G i \u2192* N) : (lift f).range = \u2a06 i, (f i).range := by\n  apply le_antisymm (lift_range_le _ f fun i => le_iSup (fun i => MonoidHom.range (f i)) i)\n  apply iSup_le _\n  rintro i _ \u27e8x, rfl\u27e9\n  exact \u27e8of x, by simp only [lift_of]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Group (G i)\nx\u271d : Sort u_5\nlift : x\u271d\nN : Type u_6\ninst\u271d : Group N\nf : (i : \u03b9) \u2192 G i \u2192* N\n\u22a2 sorry = \u2a06 i, (f i).range"}, {"line": "apply le_antisymm (lift_range_le _ f fun i => le_iSup (fun i => MonoidHom.range (f i)) i)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Group (G i)\nx\u271d : Sort u_5\nlift : x\u271d\nN : Type u_6\ninst\u271d : Group N\nf : (i : \u03b9) \u2192 G i \u2192* N\n\u22a2 \u2a06 i, (f i).range \u2264 sorry"}, {"line": "apply iSup_le _", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Group (G i)\nx\u271d : Sort u_5\nlift : x\u271d\nN : Type u_6\ninst\u271d : Group N\nf : (i : \u03b9) \u2192 G i \u2192* N\n\u22a2 \u2200 (i : \u03b9), (f i).range \u2264 sorry"}, {"line": "rintro i _ \u27e8x, rfl\u27e9", "tactic_state": "case intro\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Group (G i)\nx\u271d : Sort u_5\nlift : x\u271d\nN : Type u_6\ninst\u271d : Group N\nf : (i : \u03b9) \u2192 G i \u2192* N\ni : \u03b9\nx : G i\n\u22a2 (f i) x \u2208 sorry"}, {"line": "exact \u27e8of x, by simp only [lift_of]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fstIdx_cons {i} (m : M i) (w : Word M) (hmw : w.fstIdx \u2260 some i) (h1 : m \u2260 1) :\n    fstIdx (cons m w hmw h1) = some i := by simp [cons, fstIdx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]", "(M)", "{M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\nx\u271d\u00b9 : Sort u_5\nWord : x\u271d\u00b9\nx\u271d : Sort u_6\nfstIdx : x\u271d\ni : \u03b9\nm : M i\nw : sorry\nhmw : sorry \u2260 some i\nh1 : m \u2260 1\n\u22a2 sorry = some i"}, {"line": "simp [cons, fstIdx]", "tactic_state": "\u03b9 : Type u_1\nM : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (M i)\nx\u271d\u00b9 : Sort u_5\nWord : x\u271d\u00b9\nx\u271d : Sort u_6\nfstIdx : x\u271d\ni : \u03b9\nm : M i\nw : sorry\nhmw : sorry \u2260 some i\nh1 : m \u2260 1\n\u22a2 sorry () = some i"}]}
{"declaration": "theorem rcons_eq_smul {i} (p : Pair M i) :\n    rcons p = of p.head \u2022 p.tail := by\n  simp [of_smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]", "(M)", "{M}", "[\u2200 i, DecidableEq (M i)]", "[DecidableEq \u03b9] [\u2200 i, DecidableEq (M i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b2 : Sort u_5\nPair : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_6\nrcons : x\u271d\u00b9\nx\u271d : Sort u_7\nof : x\u271d\ni : ?m.3139\np : sorry\n\u22a2 sorry = sorry \u2022 sorry"}, {"line": "simp [of_smul_def]", "tactic_state": "x\u271d\u00b2 : Sort u_5\nPair : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_6\nrcons : x\u271d\u00b9\nx\u271d : Sort u_7\nof : x\u271d\ni : ?m.3139\np : sorry\n\u22a2 sorry () = sorry () \u2022 sorry ()"}]}
{"declaration": "theorem append_prod {i j k l} {w\u2081 : NeWord M i j} {hne : j \u2260 k} {w\u2082 : NeWord M k l} :\n    (append w\u2081 hne w\u2082).prod = w\u2081.prod * w\u2082.prod := by simp [toWord, prod, Word.prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set", "Word"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]", "(M)", "{M}", "[\u2200 i, DecidableEq (M i)]", "[DecidableEq \u03b9] [\u2200 i, DecidableEq (M i)]", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_5\nNeWord : x\u271d\u00b9\nx\u271d : Sort u_6\nappend : x\u271d\ni : ?m.5498\nj k : ?m.5499\nl : ?m.5500\nw\u2081 : sorry\nhne : j \u2260 k\nw\u2082 : sorry\n\u22a2 sorry = sorry * sorry"}, {"line": "simp [toWord, prod, Word.prod]", "tactic_state": "x\u271d\u00b9 : Sort u_5\nNeWord : x\u271d\u00b9\nx\u271d : Sort u_6\nappend : x\u271d\ni : ?m.5498\nj k : ?m.5499\nl : ?m.5500\nw\u2081 : sorry\nhne : j \u2260 k\nw\u2082 : sorry\n\u22a2 sorry () = sorry () * sorry ()"}]}
{"declaration": "theorem lift_word_prod_nontrivial_of_head_eq_last {i} (w : NeWord H i i) :\n    lift f w.prod \u2260 1 := by\n  obtain \u27e8k, hk\u27e9 := exists_ne i\n  exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hk hk\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set", "Word", "Pointwise", "Cardinal", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]", "(M)", "{M}", "[\u2200 i, DecidableEq (M i)]", "[DecidableEq \u03b9] [\u2200 i, DecidableEq (M i)]", "(M) in", "{G : \u03b9 \u2192 Type*} [\u2200 i, Group (G i)]", "{G : Type*} [Group G]", "{H : \u03b9 \u2192 Type*} [\u2200 i, Group (H i)]", "(f : \u2200 i, H i \u2192* G)", "(hcard : 3 \u2264 #\u03b9 \u2228 \u2203 i, 3 \u2264 #(H i))", "{\u03b1 : Type*} [MulAction G \u03b1]", "(X : \u03b9 \u2192 Set \u03b1)", "(hXnonempty : \u2200 i, (X i).Nonempty)", "(hXdisj : Pairwise (Disjoint on X))", "(hpp : Pairwise fun i j => \u2200 h : H i, h \u2260 1 \u2192 f i h \u2022 X j \u2286 X i)", "[Nontrivial \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nNeWord : x\u271d\ni : ?m.26770\nw : sorry\n\u22a2 sorry \u2260 1"}, {"line": "obtain \u27e8k, hk\u27e9 := exists_ne i", "tactic_state": "case intro\nx\u271d : Sort u_8\nNeWord : x\u271d\ni : ?m.26770\nw : sorry\nk : ?m.26788\nhk : k \u2260 sorry\n\u22a2 sorry \u2260 1"}, {"line": "exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hk hk", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift_word_prod_nontrivial_of_not_empty {i j} (w : NeWord H i j) :\n    lift f w.prod \u2260 1 := by\n  classical\n    rcases hcard with hcard | hcard\n    \u00b7 obtain \u27e8i, h1, h2\u27e9 := Cardinal.three_le hcard i j\n      exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w h1 h2\n    \u00b7 obtain \u27e8k, hcard\u27e9 := hcard\n      by_cases hh : i = k <;> by_cases hl : j = k\n      \u00b7 subst hh\n        subst hl\n        exact lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w\n      \u00b7 subst hh\n        change j \u2260 i at hl\n        exact lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w hcard hl.symm\n      \u00b7 subst hl\n        change i \u2260 j at hh\n        have : lift f w.inv.prod \u2260 1 :=\n          lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w.inv hcard hh.symm\n        intro heq\n        apply this\n        simpa using heq\n      \u00b7 change i \u2260 k at hh\n        change j \u2260 k at hl\n        exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hh.symm hl.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CoprodI.lean", "context": {"open": ["Set", "Word", "Pointwise", "Cardinal", "scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i, Monoid (M i)]", "{M}", "{N : Type*} [Monoid N]", "(G : \u03b9 \u2192 Type*) [\u2200 i, Group (G i)]", "(M)", "{M}", "[\u2200 i, DecidableEq (M i)]", "[DecidableEq \u03b9] [\u2200 i, DecidableEq (M i)]", "(M) in", "{G : \u03b9 \u2192 Type*} [\u2200 i, Group (G i)]", "{G : Type*} [Group G]", "{H : \u03b9 \u2192 Type*} [\u2200 i, Group (H i)]", "(f : \u2200 i, H i \u2192* G)", "(hcard : 3 \u2264 #\u03b9 \u2228 \u2203 i, 3 \u2264 #(H i))", "{\u03b1 : Type*} [MulAction G \u03b1]", "(X : \u03b9 \u2192 Set \u03b1)", "(hXnonempty : \u2200 i, (X i).Nonempty)", "(hXdisj : Pairwise (Disjoint on X))", "(hpp : Pairwise fun i j => \u2200 h : H i, h \u2260 1 \u2192 f i h \u2022 X j \u2286 X i)", "[Nontrivial \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_8\nNeWord : x\u271d\ni : ?m.26776\nj : ?m.26777\nw : sorry\n\u22a2 sorry \u2260 1"}, {"line": "classical\n    rcases hcard with hcard | hcard\n    \u00b7 obtain \u27e8i, h1, h2\u27e9 := Cardinal.three_le hcard i j\n      exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w h1 h2\n    \u00b7 obtain \u27e8k, hcard\u27e9 := hcard\n      by_cases hh : i = k <;> by_cases hl : j = k\n      \u00b7 subst hh\n        subst hl\n        exact lift_word_prod_nontrivial_of_head_eq_last f X hXnonempty hXdisj hpp w\n      \u00b7 subst hh\n        change j \u2260 i at hl\n        exact lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w hcard hl.symm\n      \u00b7 subst hl\n        change i \u2260 j at hh\n        have : lift f w.inv.prod \u2260 1 :=\n          lift_word_prod_nontrivial_of_head_card f X hXnonempty hXdisj hpp w.inv hcard hh.symm\n        intro heq\n        apply this\n        simpa using heq\n      \u00b7 change i \u2260 k at hh\n        change j \u2260 k at hl\n        exact lift_word_prod_nontrivial_of_other_i f X hXnonempty hXdisj hpp w hh.symm hl.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftCoset_cover_const_iff_surjOn :\n    \u22c3 i \u2208 s, g i \u2022 (H : Set G) = Set.univ \u2194 Set.SurjOn (g \u00b7 : \u03b9 \u2192 G \u29f8 H) s Set.univ := by\n  simp [Set.eq_univ_iff_forall, mem_leftCoset_iff, Set.SurjOn,\n    QuotientGroup.forall_mk, QuotientGroup.eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CosetCover.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} [Group G]", "{\u03b9 : Type*} {s : Finset \u03b9} {H : Subgroup G} {g : \u03b9 \u2192 G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\n\u22a2 \u22c3 i \u2208 s, g i \u2022 \u2191H = Set.univ \u2194 Set.SurjOn (fun x => \u2191(g x)) (\u2191s) Set.univ"}, {"line": "simp [Set.eq_univ_iff_forall, mem_leftCoset_iff, Set.SurjOn,\n    QuotientGroup.forall_mk, QuotientGroup.eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwiseDisjoint_leftCoset_cover_const_of_index_eq (hind : H.index = s.card) :\n    Set.PairwiseDisjoint s (g \u00b7 \u2022 (H : Set G)) := by\n  have : Fintype (G \u29f8 H) := fintypeOfIndexNeZero fun h => by\n    rw [hind] at h\n    rw [Finset.card_eq_zero] at h\n    rw [h] at hcovers\n    rw [\u2190 Finset.set_biUnion_coe] at hcovers\n    rw [Finset.coe_empty] at hcovers\n    rw [Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers\n  suffices Function.Bijective (g \u00b7 : s \u2192 G \u29f8 H) by\n    intro i hi j hj h' c hi' hj' x hx\n    specialize hi' hx\n    specialize hj' hx\n    rw [mem_leftCoset_iff] at hi' hj'\n    rw [SetLike.mem_coe] at hi' hj'\n    rw [\u2190 QuotientGroup.eq] at hi' hj'\n    rw [ne_eq] at h'\n    rw [\u2190 Subtype.mk.injEq (p := (\u00b7 \u2208 (s : Set \u03b9))) i hi j hj] at h'\n    exact h' <| this.injective <| by simp only [hi', hj']\n  rw [Fintype.bijective_iff_surjective_and_card]\n  constructor\n  \u00b7 rwa [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers\n  \u00b7 simp only [Fintype.card_coe, \u2190 hind, index_eq_card, Nat.card_eq_fintype_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CosetCover.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} [Group G]", "{\u03b9 : Type*} {s : Finset \u03b9} {H : Subgroup G} {g : \u03b9 \u2192 G}", "(hcovers : \u22c3 i \u2208 s, g i \u2022 (H : Set G) = Set.univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\n\u22a2 (\u2191s).PairwiseDisjoint fun x => g x \u2022 \u2191H"}, {"line": "have : Fintype (G \u29f8 H) := fintypeOfIndexNeZero fun h => by\n    rw [hind] at h\n    rw [Finset.card_eq_zero] at h\n    rw [h] at hcovers\n    rw [\u2190 Finset.set_biUnion_coe] at hcovers\n    rw [Finset.coe_empty] at hcovers\n    rw [Set.biUnion_empty] at hcovers\n    exact Set.empty_ne_univ hcovers", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 (\u2191s).PairwiseDisjoint fun x => g x \u2022 \u2191H"}, {"line": "suffices Function.Bijective (g \u00b7 : s \u2192 G \u29f8 H) by\n    intro i hi j hj h' c hi' hj' x hx\n    specialize hi' hx\n    specialize hj' hx\n    rw [mem_leftCoset_iff] at hi' hj'\n    rw [SetLike.mem_coe] at hi' hj'\n    rw [\u2190 QuotientGroup.eq] at hi' hj'\n    rw [ne_eq] at h'\n    rw [\u2190 Subtype.mk.injEq (p := (\u00b7 \u2208 (s : Set \u03b9))) i hi j hj] at h'\n    exact h' <| this.injective <| by simp only [hi', hj']", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 Function.Bijective fun x => \u2191(g \u2191x)"}, {"line": "rw [Fintype.bijective_iff_surjective_and_card]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 (Function.Surjective fun x => \u2191(g \u2191x)) \u2227 Fintype.card { x // x \u2208 s } = Fintype.card (G \u29f8 H)"}, {"line": "constructor", "tactic_state": "case left\nG : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 Function.Surjective fun x => \u2191(g \u2191x)\n---\ncase right\nG : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 Fintype.card { x // x \u2208 s } = Fintype.card (G \u29f8 H)"}, {"line": "\u00b7 rwa [leftCoset_cover_const_iff_surjOn, Set.surjOn_iff_surjective] at hcovers", "tactic_state": "case right\nG : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nH : Subgroup G\ng : \u03b9 \u2192 G\nhind : H.index = s.card\nthis : Fintype (G \u29f8 H)\n\u22a2 Fintype.card { x // x \u2208 s } = Fintype.card (G \u29f8 H)"}, {"line": "\u00b7 simp only [Fintype.card_coe, \u2190 hind, index_eq_card, Nat.card_eq_fintype_card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subspace.exists_eq_top_of_iUnion_eq_univ {\u03b9} [Finite \u03b9] {p : \u03b9 \u2192 Subspace k E}\n    (hcovers : \u22c3 i, (p i : Set E) = Set.univ) : \u2203 i, p i = \u22a4 := by\n  have := Fintype.ofFinite (Set.range p)\n  simp_rw [\u2190 Set.biUnion_range (f := p), \u2190 Set.mem_toFinset] at hcovers\n  apply Set.mem_toFinset.mp (Subspace.top_mem_of_biUnion_eq_univ hcovers)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/CosetCover.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{G : Type*} [Group G]", "{\u03b9 : Type*} {s : Finset \u03b9} {H : Subgroup G} {g : \u03b9 \u2192 G}", "(hcovers : \u22c3 i \u2208 s, g i \u2022 (H : Set G) = Set.univ)", "{\u03b9 : Type*} {H : \u03b9 \u2192 Subgroup G} {g : \u03b9 \u2192 G} {s : Finset \u03b9}", "{R M \u03b9 : Type*} [Ring R] [AddCommGroup M] [Module R M]", "{k E : Type*} [DivisionRing k] [Infinite k] [AddCommGroup E] [Module k E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : Type u_7\nE : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : Infinite k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\n\u03b9 : Sort u_9\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 Subspace k E\nhcovers : \u22c3 i, \u2191(p i) = Set.univ\n\u22a2 \u2203 i, p i = \u22a4"}, {"line": "have := Fintype.ofFinite (Set.range p)", "tactic_state": "k : Type u_7\nE : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : Infinite k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\n\u03b9 : Sort u_9\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 Subspace k E\nhcovers : \u22c3 i, \u2191(p i) = Set.univ\nthis : Fintype \u2191(Set.range p)\n\u22a2 \u2203 i, p i = \u22a4"}, {"line": "simp_rw [\u2190 Set.biUnion_range (f := p), \u2190 Set.mem_toFinset] at hcovers", "tactic_state": "k : Type u_7\nE : Type u_8\ninst\u271d\u2074 : DivisionRing k\ninst\u271d\u00b3 : Infinite k\ninst\u271d\u00b2 : AddCommGroup E\ninst\u271d\u00b9 : Module k E\n\u03b9 : Sort u_9\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 Subspace k E\nthis : Fintype \u2191(Set.range p)\nhcovers : \u22c3 x \u2208 (Set.range p).toFinset, \u2191x = Set.univ\n\u22a2 \u2203 i, p i = \u22a4"}, {"line": "apply Set.mem_toFinset.mp (Subspace.top_mem_of_biUnion_eq_univ hcovers)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_eq_one_iff : exponent G = 1 \u2194 Subsingleton G := by\n  refine \u27e8fun eq_one => \u27e8fun a b => ?a_eq_b\u27e9, fun h => le_antisymm ?le ?ge\u27e9\n  \u00b7 rw [\u2190 pow_one a, \u2190 pow_one b, \u2190 eq_one, Monoid.pow_exponent_eq_one, Monoid.pow_exponent_eq_one]\n  \u00b7 apply exponent_min' _ Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n  \u00b7 apply Nat.succ_le_of_lt\n    apply exponent_pos_of_exists 1 Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\n\u22a2 sorry = 1 \u2194 Subsingleton G"}, {"line": "refine \u27e8fun eq_one => \u27e8fun a b => ?a_eq_b\u27e9, fun h => le_antisymm ?le ?ge\u27e9", "tactic_state": "case a_eq_b\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\neq_one : sorry = 1\na b : G\n\u22a2 a = b\n---\ncase le\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\nh : Subsingleton G\n\u22a2 sorry \u2264 1\n---\ncase ge\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\nh : Subsingleton G\n\u22a2 1 \u2264 sorry"}, {"line": "\u00b7 rw [\u2190 pow_one a, \u2190 pow_one b, \u2190 eq_one, Monoid.pow_exponent_eq_one, Monoid.pow_exponent_eq_one]", "tactic_state": "case le\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\nh : Subsingleton G\n\u22a2 sorry \u2264 1\n---\ncase ge\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\nh : Subsingleton G\n\u22a2 1 \u2264 sorry"}, {"line": "\u00b7 apply exponent_min' _ Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]", "tactic_state": "case ge\nG : Type u_2\ninst\u271d : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\nh : Subsingleton G\n\u22a2 1 \u2264 sorry"}, {"line": "\u00b7 apply Nat.succ_le_of_lt\n    apply exponent_pos_of_exists 1 Nat.one_pos\n    simp [eq_iff_true_of_subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lcm_orderOf_dvd_exponent [Fintype G] :\n    (Finset.univ : Finset G).lcm orderOf \u2223 exponent G := by\n  apply Finset.lcm_dvd\n  intro g _\n  exact order_dvd_exponent g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 Finset.univ.lcm orderOf \u2223 sorry"}, {"line": "apply Finset.lcm_dvd", "tactic_state": "case a\nG : Type u_2\ninst\u271d\u00b9 : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 \u2200 b \u2208 Finset.univ, orderOf b \u2223 sorry"}, {"line": "intro g _", "tactic_state": "case a\nG : Type u_2\ninst\u271d\u00b9 : Monoid G\nx\u271d : Sort u_1\nexponent : x\u271d\ninst\u271d : Fintype G\ng : G\na\u271d : g \u2208 Finset.univ\n\u22a2 orderOf g \u2223 sorry"}, {"line": "exact order_dvd_exponent g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Commute.exists_orderOf_eq_lcm {x y : G} (h : Commute x y) :\n    \u2203 z \u2208 closure {x, y}, orderOf z = Nat.lcm (orderOf x) (orderOf y) := by\n  by_cases hx : orderOf x = 0 <;> by_cases hy : orderOf y = 0\n  \u00b7 exact \u27e8x, subset_closure (by simp), by simp [hx]\u27e9\n  \u00b7 exact \u27e8x, subset_closure (by simp), by simp [hx]\u27e9\n  \u00b7 exact \u27e8y, subset_closure (by simp), by simp [hy]\u27e9\n  \u00b7 exact \u27e8_, mul_mem (pow_mem (subset_closure (by simp)) _) (pow_mem (subset_closure (by simp)) _),\n      h.orderOf_mul_pow_eq_lcm hx hy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)"}, {"line": "by_cases hx : orderOf x = 0 <;> by_cases hy : orderOf y = 0", "tactic_state": "case pos\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : sorry = 0\nhy : sorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : sorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase pos\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : sorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)"}, {"line": "\u00b7 exact \u27e8x, subset_closure (by simp), by simp [hx]\u27e9", "tactic_state": "case neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : sorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase pos\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : sorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)"}, {"line": "\u00b7 exact \u27e8x, subset_closure (by simp), by simp [hx]\u27e9", "tactic_state": "case pos\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : sorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)\n---\ncase neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)"}, {"line": "\u00b7 exact \u27e8y, subset_closure (by simp), by simp [hy]\u27e9", "tactic_state": "case neg\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhx : \u00acsorry = 0\nhy : \u00acsorry = 0\n\u22a2 \u2203 z \u2208 sorry, orderOf z = (orderOf x).lcm (orderOf y)"}, {"line": "\u00b7 exact \u27e8_, mul_mem (pow_mem (subset_closure (by simp)) _) (pow_mem (subset_closure (by simp)) _),\n      h.orderOf_mul_pow_eq_lcm hx hy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Submonoid.pow_exponent_eq_one {S : Submonoid G} {g : G} (g_in_s : g \u2208 S) :\n    g ^ (Monoid.exponent S) = 1 := by\n  have := Monoid.pow_exponent_eq_one (\u27e8g, g_in_s\u27e9 : S)\n  rwa [SubmonoidClass.mk_pow, \u2190 OneMemClass.coe_eq_one] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in", "{G}", "{H : Type*} [Monoid H]", "[Monoid G]", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 inst\u271d : Monoid G\nS : Submonoid G\ng : G\ng_in_s : g \u2208 S\n\u22a2 g ^ Monoid.exponent \u21a5S = 1"}, {"line": "have := Monoid.pow_exponent_eq_one (\u27e8g, g_in_s\u27e9 : S)", "tactic_state": "G : Type u_2\ninst\u271d\u00b9 inst\u271d : Monoid G\nS : Submonoid G\ng : G\ng_in_s : g \u2208 S\nthis : \u27e8g, g_in_s\u27e9 ^ Monoid.exponent \u21a5S = 1\n\u22a2 g ^ Monoid.exponent \u21a5S = 1"}, {"line": "rwa [SubmonoidClass.mk_pow, \u2190 OneMemClass.coe_eq_one] at this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_lt_exponent [Nontrivial G] : 1 < Monoid.exponent G := by\n  rw [Nat.one_lt_iff_ne_zero_and_ne_one]\n  exact \u27e8exponent_ne_zero_of_finite, mt exp_eq_one_iff.mp (not_subsingleton G)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in", "{G}", "{H : Type*} [Monoid H]", "[Monoid G]", "(G) in", "[LeftCancelMonoid G] [Finite G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : Nontrivial G\n\u22a2 1 < Monoid.exponent G"}, {"line": "rw [Nat.one_lt_iff_ne_zero_and_ne_one]", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : Nontrivial G\n\u22a2 Monoid.exponent G \u2260 0 \u2227 Monoid.exponent G \u2260 1"}, {"line": "exact \u27e8exponent_ne_zero_of_finite, mt exp_eq_one_iff.mp (not_subsingleton G)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exponent_eq_iSup_orderOf (h : \u2200 g : G, 0 < orderOf g) :\n    exponent G = \u2a06 g : G, orderOf g := by\n  rw [iSup]\n  by_cases ExponentExists G\n  case neg he =>\n    rw [\u2190 exponent_eq_zero_iff] at he\n    rw [he]\n    rw [Set.Infinite.Nat.sSup_eq_zero <| (exponent_eq_zero_iff_range_orderOf_infinite h).1 he]\n  case pos he =>\n    rw [csSup_eq_of_forall_le_of_forall_lt_exists_gt (Set.range_nonempty _)]\n    \u00b7 simp_rw [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n      exact orderOf_le_exponent he\n    intro x hx\n    obtain \u27e8g, hg\u27e9 := exists_orderOf_eq_exponent he\n    rw [\u2190 hg] at hx\n    simp_rw [Set.mem_range, exists_exists_eq_and]\n    exact \u27e8g, hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in", "{G}", "{H : Type*} [Monoid H]", "[Monoid G]", "(G) in", "[LeftCancelMonoid G] [Finite G]", "[CommMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : CommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\nh : \u2200 (g : G), 0 < orderOf g\n\u22a2 sorry = \u2a06 g, orderOf g"}, {"line": "rw [iSup]", "tactic_state": "G : Type u_3\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : CommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\nh : \u2200 (g : G), 0 < orderOf g\n\u22a2 sorry = sSup (Set.range fun g => orderOf g)"}, {"line": "by_cases ExponentExists G", "tactic_state": "case pos\nG : Type u_3\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : CommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\nh : \u2200 (g : G), 0 < orderOf g\nh\u271d : sorry\n\u22a2 sorry = sSup (Set.range fun g => orderOf g)\n---\ncase neg\nG : Type u_3\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : CommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\nh : \u2200 (g : G), 0 < orderOf g\nh\u271d : \u00acsorry\n\u22a2 sorry = sSup (Set.range fun g => orderOf g)"}, {"line": "case neg he =>\n    rw [\u2190 exponent_eq_zero_iff] at he\n    rw [he]\n    rw [Set.Infinite.Nat.sSup_eq_zero <| (exponent_eq_zero_iff_range_orderOf_infinite h).1 he]", "tactic_state": "case pos\nG : Type u_3\ninst\u271d\u00b2 inst\u271d\u00b9 : Monoid G\ninst\u271d : CommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\nh : \u2200 (g : G), 0 < orderOf g\nh\u271d : sorry\n\u22a2 sorry = sSup (Set.range fun g => orderOf g)"}, {"line": "case pos he =>\n    rw [csSup_eq_of_forall_le_of_forall_lt_exists_gt (Set.range_nonempty _)]\n    \u00b7 simp_rw [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff]\n      exact orderOf_le_exponent he\n    intro x hx\n    obtain \u27e8g, hg\u27e9 := exists_orderOf_eq_exponent he\n    rw [\u2190 hg] at hx\n    simp_rw [Set.mem_range, exists_exists_eq_and]\n    exact \u27e8g, hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exponent_eq_max'_orderOf [Fintype G] :\n    exponent G = ((@Finset.univ G _).image orderOf).max' \u27e81, by simp\u27e9 := by\n  rw [\u2190 Finset.Nonempty.csSup_eq_max']\n  rw [Finset.coe_image]\n  rw [Finset.coe_univ]\n  rw [Set.image_univ]\n  rw [\u2190 iSup]\n  exact exponent_eq_iSup_orderOf orderOf_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in", "scoped Classical in"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in", "{G}", "{H : Type*} [Monoid H]", "[Monoid G]", "(G) in", "[LeftCancelMonoid G] [Finite G]", "[CommMonoid G]", "[CancelCommMonoid G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = (Finset.image orderOf Finset.univ).max' \u22ef"}, {"line": "rw [\u2190 Finset.Nonempty.csSup_eq_max']", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = sSup \u2191(Finset.image orderOf Finset.univ)"}, {"line": "rw [Finset.coe_image]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = sSup (orderOf '' \u2191Finset.univ)"}, {"line": "rw [Finset.coe_univ]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = sSup (orderOf '' Set.univ)"}, {"line": "rw [Set.image_univ]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = sSup (Set.range orderOf)"}, {"line": "rw [\u2190 iSup]", "tactic_state": "G : Type u_3\ninst\u271d\u2074 inst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : CommMonoid G\ninst\u271d\u00b9 : CancelCommMonoid G\nx\u271d : Sort u_2\nexponent : x\u271d\ninst\u271d : Fintype G\n\u22a2 sorry = iSup orderOf"}, {"line": "exact exponent_eq_iSup_orderOf orderOf_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monoid.exponent_prod {M\u2081 M\u2082 : Type*} [Monoid M\u2081] [Monoid M\u2082] :\n    exponent (M\u2081 \u00d7 M\u2082) = lcm (exponent M\u2081) (exponent M\u2082) := by\n  refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)\n  \u00b7 refine exponent_dvd_of_forall_pow_eq_one fun g \u21a6 ?_\n    ext1\n    \u00b7 rw [Prod.pow_fst, Prod.fst_one, \u2190 orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _\n    \u00b7 rw [Prod.pow_snd, Prod.snd_one, \u2190 orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _\n  \u00b7 exact MonoidHom.exponent_dvd (f := MonoidHom.fst M\u2081 M\u2082) Prod.fst_surjective\n  \u00b7 exact MonoidHom.exponent_dvd (f := MonoidHom.snd M\u2081 M\u2082) Prod.snd_surjective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Exponent.lean", "context": {"open": ["scoped Classical in", "MulOpposite in", "Nat in", "Submonoid in", "scoped Classical in", "Finset Monoid"], "variables": ["{G : Type u}", "(G) [Monoid G]", "{G}", "(G)", "{G} in", "{G}", "{H : Type*} [Monoid H]", "[Monoid G]", "(G) in", "[LeftCancelMonoid G] [Finite G]", "[CommMonoid G]", "[CancelCommMonoid G]", "[Group G] {n m : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent (M\u2081 \u00d7 M\u2082) = lcm (exponent M\u2081) (exponent M\u2082)"}, {"line": "refine dvd_antisymm ?_ (lcm_dvd ?_ ?_)", "tactic_state": "case refine_1\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent (M\u2081 \u00d7 M\u2082) \u2223 lcm (exponent M\u2081) (exponent M\u2082)\n---\ncase refine_2\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent M\u2081 \u2223 exponent (M\u2081 \u00d7 M\u2082)\n---\ncase refine_3\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent M\u2082 \u2223 exponent (M\u2081 \u00d7 M\u2082)"}, {"line": "\u00b7 refine exponent_dvd_of_forall_pow_eq_one fun g \u21a6 ?_\n    ext1\n    \u00b7 rw [Prod.pow_fst, Prod.fst_one, \u2190 orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.1)) <| dvd_lcm_left _ _\n    \u00b7 rw [Prod.pow_snd, Prod.snd_one, \u2190 orderOf_dvd_iff_pow_eq_one]\n      exact dvd_trans (Monoid.order_dvd_exponent (g.2)) <| dvd_lcm_right _ _", "tactic_state": "case refine_2\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent M\u2081 \u2223 exponent (M\u2081 \u00d7 M\u2082)\n---\ncase refine_3\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent M\u2082 \u2223 exponent (M\u2081 \u00d7 M\u2082)"}, {"line": "\u00b7 exact MonoidHom.exponent_dvd (f := MonoidHom.fst M\u2081 M\u2082) Prod.fst_surjective", "tactic_state": "case refine_3\nM\u2081 : Type u_2\nM\u2082 : Type u_3\ninst\u271d\u00b9 : Monoid M\u2081\ninst\u271d : Monoid M\u2082\n\u22a2 exponent M\u2082 \u2223 exponent (M\u2081 \u00d7 M\u2082)"}, {"line": "\u00b7 exact MonoidHom.exponent_dvd (f := MonoidHom.snd M\u2081 M\u2082) Prod.snd_surjective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submonoid.FG.map {M' : Type*} [Monoid M'] {P : Submonoid M} (h : P.FG) (e : M \u2192* M') :\n    (P.map e).FG := by\n  classical\n    obtain \u27e8s, rfl\u27e9 := h\n    exact \u27e8s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Finiteness.lean", "context": {"open": ["Pointwise"], "variables": ["{M N : Type*} [Monoid M]", "[Monoid N] {P : Submonoid M} {Q : Submonoid N}", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b9 : Monoid M\nM' : Type u_3\ninst\u271d : Monoid M'\nP : Submonoid M\nh : P.FG\ne : M \u2192* M'\n\u22a2 (Submonoid.map e P).FG"}, {"line": "classical\n    obtain \u27e8s, rfl\u27e9 := h\n    exact \u27e8s.image e, by rw [Finset.coe_image, MonoidHom.map_mclosure]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Monoid.fg_of_surjective {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M \u2192* M')\n    (hf : Function.Surjective f) : Monoid.FG M' := by\n  classical\n    obtain \u27e8s, hs\u27e9 := Monoid.fg_def.mp \u2039_\u203a\n    use s.image f\n    rwa [Finset.coe_image, \u2190 MonoidHom.map_mclosure, hs, \u2190 MonoidHom.mrange_eq_map,\n      MonoidHom.mrange_eq_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Finiteness.lean", "context": {"open": ["Pointwise"], "variables": ["{M N : Type*} [Monoid M]", "[Monoid N] {P : Submonoid M} {Q : Submonoid N}", "(M) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u00b2 : Monoid M\nM' : Type u_3\ninst\u271d\u00b9 : Monoid M'\ninst\u271d : FG M\nf : M \u2192* M'\nhf : Function.Surjective \u21d1f\n\u22a2 FG M'"}, {"line": "classical\n    obtain \u27e8s, hs\u27e9 := Monoid.fg_def.mp \u2039_\u203a\n    use s.image f\n    rwa [Finset.coe_image, \u2190 MonoidHom.map_mclosure, hs, \u2190 MonoidHom.mrange_eq_map,\n      MonoidHom.mrange_eq_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma frattini_le_comap_frattini_of_surjective (h\u03c6 : Function.Surjective \u03c6) :\n    frattini G \u2264 (frattini H).comap \u03c6 := by\n  simp_rw [frattini, Order.radical, comap_iInf, le_iInf_iff]\n  intro M hM\n  apply biInf_le\n  exact isCoatom_comap_of_surjective h\u03c6 hM\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Frattini.lean", "context": {"open": ["Subgroup"], "variables": ["{G H : Type*} [Group G] [Group H] {\u03c6 : G \u2192* H}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\n\u03c6 : G \u2192* H\nh\u03c6 : Function.Surjective \u21d1\u03c6\n\u22a2 frattini G \u2264 comap \u03c6 (frattini H)"}, {"line": "simp_rw [frattini, Order.radical, comap_iInf, le_iInf_iff]", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\n\u03c6 : G \u2192* H\nh\u03c6 : Function.Surjective \u21d1\u03c6\n\u22a2 \u2200 i \u2208 {H_1 | IsCoatom H_1}, \u2a05 a \u2208 {H | IsCoatom H}, a \u2264 comap \u03c6 i"}, {"line": "intro M hM", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\n\u03c6 : G \u2192* H\nh\u03c6 : Function.Surjective \u21d1\u03c6\nM : Subgroup H\nhM : M \u2208 {H_1 | IsCoatom H_1}\n\u22a2 \u2a05 a \u2208 {H | IsCoatom H}, a \u2264 comap \u03c6 M"}, {"line": "apply biInf_le", "tactic_state": "case hi\nG : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\n\u03c6 : G \u2192* H\nh\u03c6 : Function.Surjective \u21d1\u03c6\nM : Subgroup H\nhM : M \u2208 {H_1 | IsCoatom H_1}\n\u22a2 comap \u03c6 M \u2208 {H | IsCoatom H}"}, {"line": "exact isCoatom_comap_of_surjective h\u03c6 hM", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_ne_zero (x : \u03b1) : of x \u2260 0 := by\n  intro h\n  let f : FreeAbelianGroup \u03b1 \u2192+ \u2124 := lift 1\n  have hfx : f (of x) = 1 := lift.of _ _\n  have hf0 : f (of x) = 0 := by rw [h, map_zero]\n  exact one_ne_zero <| hfx.symm.trans hf0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeAbelianGroup.lean", "context": {"open": ["FreeAbelianGroup", "scoped Classical in"], "variables": ["(\u03b1 : Type u)", "{\u03b1}", "{\u03b2 : Type v} [AddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 of x \u2260 0"}, {"line": "intro h", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nh : of x = 0\n\u22a2 False"}, {"line": "let f : FreeAbelianGroup \u03b1 \u2192+ \u2124 := lift 1", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nh : of x = 0\nf : FreeAbelianGroup \u03b1 \u2192+ \u2124 := lift 1\n\u22a2 False"}, {"line": "have hfx : f (of x) = 1 := lift.of _ _", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nh : of x = 0\nf : FreeAbelianGroup \u03b1 \u2192+ \u2124 := lift 1\nhfx : f (of x) = 1\n\u22a2 False"}, {"line": "have hf0 : f (of x) = 0 := by rw [h, map_zero]", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nh : of x = 0\nf : FreeAbelianGroup \u03b1 \u2192+ \u2124 := lift 1\nhfx : f (of x) = 1\nhf0 : f (of x) = 0\n\u22a2 False"}, {"line": "exact one_ne_zero <| hfx.symm.trans hf0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lift.add' {\u03b1 \u03b2} [AddCommGroup \u03b2] (a : FreeAbelianGroup \u03b1) (f g : \u03b1 \u2192 \u03b2) :\n    lift (f + g) a = lift f a + lift g a := by\n  refine FreeAbelianGroup.induction_on a ?_ ?_ ?_ ?_\n  \u00b7 simp only [(lift _).map_zero, zero_add]\n  \u00b7 intro x\n    simp only [lift.of]\n    simp only [Pi.add_apply]\n  \u00b7 intro x _\n    simp only [map_neg]\n    simp only [lift.of]\n    simp only [Pi.add_apply]\n    simp only [neg_add]\n  \u00b7 intro x y hx hy\n    simp only [(lift _).map_add]\n    simp only [hx]\n    simp only [hy]\n    simp only [add_add_add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeAbelianGroup.lean", "context": {"open": ["FreeAbelianGroup", "scoped Classical in"], "variables": ["(\u03b1 : Type u)", "{\u03b1}", "{\u03b2 : Type v} [AddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 (lift (f + g)) a = (lift f) a + (lift g) a"}, {"line": "refine FreeAbelianGroup.induction_on a ?_ ?_ ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 (lift (f + g)) 0 = (lift f) 0 + (lift g) 0\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b1), (lift (f + g)) (of x) = (lift f) (of x) + (lift g) (of x)\n---\ncase refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b1),\n    (lift (f + g)) (of x) = (lift f) (of x) + (lift g) (of x) \u2192\n      (lift (f + g)) (-of x) = (lift f) (-of x) + (lift g) (-of x)\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x y : FreeAbelianGroup \u03b1),\n    (lift (f + g)) x = (lift f) x + (lift g) x \u2192\n      (lift (f + g)) y = (lift f) y + (lift g) y \u2192 (lift (f + g)) (x + y) = (lift f) (x + y) + (lift g) (x + y)"}, {"line": "\u00b7 simp only [(lift _).map_zero, zero_add]", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b1), (lift (f + g)) (of x) = (lift f) (of x) + (lift g) (of x)\n---\ncase refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b1),\n    (lift (f + g)) (of x) = (lift f) (of x) + (lift g) (of x) \u2192\n      (lift (f + g)) (-of x) = (lift f) (-of x) + (lift g) (-of x)\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x y : FreeAbelianGroup \u03b1),\n    (lift (f + g)) x = (lift f) x + (lift g) x \u2192\n      (lift (f + g)) y = (lift f) y + (lift g) y \u2192 (lift (f + g)) (x + y) = (lift f) (x + y) + (lift g) (x + y)"}, {"line": "\u00b7 intro x\n    simp only [lift.of]\n    simp only [Pi.add_apply]", "tactic_state": "case refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x : \u03b1),\n    (lift (f + g)) (of x) = (lift f) (of x) + (lift g) (of x) \u2192\n      (lift (f + g)) (-of x) = (lift f) (-of x) + (lift g) (-of x)\n---\ncase refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x y : FreeAbelianGroup \u03b1),\n    (lift (f + g)) x = (lift f) x + (lift g) x \u2192\n      (lift (f + g)) y = (lift f) y + (lift g) y \u2192 (lift (f + g)) (x + y) = (lift f) (x + y) + (lift g) (x + y)"}, {"line": "\u00b7 intro x _\n    simp only [map_neg]\n    simp only [lift.of]\n    simp only [Pi.add_apply]\n    simp only [neg_add]", "tactic_state": "case refine_4\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : AddCommGroup \u03b2\na : FreeAbelianGroup \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 \u2200 (x y : FreeAbelianGroup \u03b1),\n    (lift (f + g)) x = (lift f) x + (lift g) x \u2192\n      (lift (f + g)) y = (lift f) y + (lift g) y \u2192 (lift (f + g)) (x + y) = (lift f) (x + y) + (lift g) (x + y)"}, {"line": "\u00b7 intro x y hx hy\n    simp only [(lift _).map_add]\n    simp only [hx]\n    simp only [hy]\n    simp only [add_add_add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_id_apply (x : FreeAbelianGroup \u03b1) : map id x = x := by\n  rw [map_id]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeAbelianGroup.lean", "context": {"open": ["FreeAbelianGroup", "scoped Classical in"], "variables": ["(\u03b1 : Type u)", "{\u03b1}", "{\u03b2 : Type v} [AddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2)", "{\u03b2 : Type u}", "{\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : FreeAbelianGroup \u03b1\n\u22a2 (map id) x = x"}, {"line": "rw [map_id]", "tactic_state": "\u03b1 : Type u_1\nx : FreeAbelianGroup \u03b1\n\u22a2 (AddMonoidHom.id (FreeAbelianGroup \u03b1)) x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comp_apply {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (x : FreeAbelianGroup \u03b1) :\n    map (g \u2218 f) x = (map g) ((map f) x) := by\n  rw [map_comp]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeAbelianGroup.lean", "context": {"open": ["FreeAbelianGroup", "scoped Classical in"], "variables": ["(\u03b1 : Type u)", "{\u03b1}", "{\u03b2 : Type v} [AddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2)", "{\u03b2 : Type u}", "{\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nx : FreeAbelianGroup \u03b1\n\u22a2 (map (g \u2218 f)) x = (map g) ((map f) x)"}, {"line": "rw [map_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type w\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\nx : FreeAbelianGroup \u03b1\n\u22a2 ((map g).comp (map f)) x = (map g) ((map f) x)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_mul_of (x y : \u03b1) : of x * of y = of (x * y) := by\n  rw [mul_def]\n  rw [lift.of]\n  rw [lift.of]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeAbelianGroup.lean", "context": {"open": ["FreeAbelianGroup", "scoped Classical in"], "variables": ["(\u03b1 : Type u)", "{\u03b1}", "{\u03b2 : Type v} [AddCommGroup \u03b2] (f : \u03b1 \u2192 \u03b2)", "{\u03b2 : Type u}", "{\u03b2 : Type v} {\u03b3 : Type w}", "(\u03b1)", "[Mul \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mul \u03b1\nx y : \u03b1\n\u22a2 of x * of y = of (x * y)"}, {"line": "rw [mul_def]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mul \u03b1\nx y : \u03b1\n\u22a2 (lift fun x\u2082 => (lift fun x\u2081 => of (x\u2081 * x\u2082)) (of x)) (of y) = of (x * y)"}, {"line": "rw [lift.of]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Mul \u03b1\nx y : \u03b1\n\u22a2 (lift fun x\u2081 => of (x\u2081 * y)) (of x) = of (x * y)"}, {"line": "rw [lift.of]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_goursatFst {g : G} : g \u2208 I.goursatFst \u2194 (g, 1) \u2208 I := by simp [goursatFst]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Goursat.lean", "context": {"open": ["Function Set"], "variables": ["{G H : Type*} [Group G] [Group H] {I : Subgroup (G \u00d7 H)}", "(I) in", "(I) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\nI : Subgroup (G \u00d7 H)\ng : G\n\u22a2 g \u2208 I.goursatFst \u2194 (g, 1) \u2208 I"}, {"line": "simp [goursatFst]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_goursatSnd {h : H} : h \u2208 I.goursatSnd \u2194 (1, h) \u2208 I := by simp [goursatSnd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Goursat.lean", "context": {"open": ["Function Set"], "variables": ["{G H : Type*} [Group G] [Group H] {I : Subgroup (G \u00d7 H)}", "(I) in", "(I) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nH : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\nI : Subgroup (G \u00d7 H)\nh : H\n\u22a2 h \u2208 I.goursatSnd \u2194 (1, h) \u2208 I"}, {"line": "simp [goursatSnd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_smul_eq_smul (g : G) (w : NormalWord d) :\n    (of g : HNNExtension G A B \u03c6) \u2022 w = g \u2022 w := by\n  simp [instHSMul, SMul.smul, MulAction.toEndHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/HNNExtension.lean", "context": {"open": ["Monoid Coprod Multiplicative Subgroup Function"], "variables": ["{G : Type*} [Group G] {A B : Subgroup G} {\u03c6 : A \u2243* B} {H : Type*}", "(A B \u03c6)", "{A B}", "(G A B)", "{G A B}", "{d : TransversalPair G A B}", "(d)", "{d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "TransversalPair : ?m.6338\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nA\u271d B\u271d : Subgroup G\u271d\n\u03c6\u271d : \u21a5A\u271d \u2243* \u21a5B\u271d\nH : Type u_2\nd : sorry\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nx\u271d\u00b9 : Sort u_3\nNormalWord : x\u271d\u00b9\nx\u271d : Sort u_4\nof : x\u271d\ng : G\nw : sorry\n\u22a2 sorry \u2022 w = g \u2022 w"}, {"line": "simp [instHSMul, SMul.smul, MulAction.toEndHom]", "tactic_state": "TransversalPair : ?m.6338\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nA\u271d B\u271d : Subgroup G\u271d\n\u03c6\u271d : \u21a5A\u271d \u2243* \u21a5B\u271d\nH : Type u_2\nd : sorry\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nx\u271d\u00b9 : Sort u_3\nNormalWord : x\u271d\u00b9\nx\u271d : Sort u_4\nof : x\u271d\ng : G\nw : sorry\n\u22a2 sorry () \u2022 w = g \u2022 w"}]}
{"declaration": "theorem t_smul_eq_unitsSMul (w : NormalWord d) :\n    (t : HNNExtension G A B \u03c6) \u2022 w = unitsSMul \u03c6 1 w := by\n  simp [instHSMul, SMul.smul, MulAction.toEndHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/HNNExtension.lean", "context": {"open": ["Monoid Coprod Multiplicative Subgroup Function"], "variables": ["{G : Type*} [Group G] {A B : Subgroup G} {\u03c6 : A \u2243* B} {H : Type*}", "(A B \u03c6)", "{A B}", "(G A B)", "{G A B}", "{d : TransversalPair G A B}", "(d)", "{d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "TransversalPair : ?m.6338\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nA\u271d B\u271d : Subgroup G\u271d\n\u03c6\u271d : \u21a5A\u271d \u2243* \u21a5B\u271d\nH : Type u_2\nd : sorry\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nx\u271d\u00b9 : Sort u_3\nNormalWord : x\u271d\u00b9\nt : HNNExtension G A B \u03c6\nx\u271d : Sort u_4\nunitsSMul : x\u271d\nw : sorry\n\u22a2 t \u2022 w = sorry"}, {"line": "simp [instHSMul, SMul.smul, MulAction.toEndHom]", "tactic_state": "TransversalPair : ?m.6338\nG\u271d : Type u_1\ninst\u271d\u00b9 : Group G\u271d\nA\u271d B\u271d : Subgroup G\u271d\n\u03c6\u271d : \u21a5A\u271d \u2243* \u21a5B\u271d\nH : Type u_2\nd : sorry\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nx\u271d\u00b9 : Sort u_3\nNormalWord : x\u271d\u00b9\nt : HNNExtension G A B \u03c6\nx\u271d : Sort u_4\nunitsSMul : x\u271d\nw : sorry\n\u22a2 t \u2022 w = sorry ()"}]}
{"declaration": "theorem prod_empty : (empty : NormalWord d).prod \u03c6 = 1 := by\n  simp [ReducedWord.prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/HNNExtension.lean", "context": {"open": ["Monoid Coprod Multiplicative Subgroup Function"], "variables": ["{G : Type*} [Group G] {A B : Subgroup G} {\u03c6 : A \u2243* B} {H : Type*}", "(A B \u03c6)", "{A B}", "(G A B)", "{G A B}", "{d : TransversalPair G A B}", "(d)", "{d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "TransversalPair : ?m.6338\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nH : Type u_2\nd : sorry\nx\u271d : Sort u_3\nNormalWord : x\u271d\nempty : sorry\n\u22a2 sorry = 1"}, {"line": "simp [ReducedWord.prod]", "tactic_state": "TransversalPair : ?m.6338\nG : Type u_1\ninst\u271d : Group G\nA B : Subgroup G\n\u03c6 : \u21a5A \u2243* \u21a5B\nH : Type u_2\nd : sorry\nx\u271d : Sort u_3\nNormalWord : x\u271d\nempty : sorry\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem lowerCentralSeries_isDescendingCentralSeries :\n    IsDescendingCentralSeries (lowerCentralSeries G) := by\n  constructor\n  \u00b7 rfl\n  intro x n hxn g\n  exact commutator_mem_commutator hxn (mem_top g)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Nilpotent.lean", "context": {"open": ["Subgroup", "QuotientGroup", "Group"], "variables": ["{G : Type*} [Group G] (H : Subgroup G) [Normal H]", "(G)", "{G}", "(G) in", "(G) in", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u22a2 IsDescendingCentralSeries (lowerCentralSeries G)"}, {"line": "constructor", "tactic_state": "case left\nG : Type u_1\ninst\u271d : Group G\n\u22a2 lowerCentralSeries G 0 = \u22a4\n---\ncase right\nG : Type u_1\ninst\u271d : Group G\n\u22a2 \u2200 (x : G) (n : \u2115), x \u2208 lowerCentralSeries G n \u2192 \u2200 (g : G), x * g * x\u207b\u00b9 * g\u207b\u00b9 \u2208 lowerCentralSeries G (n + 1)"}, {"line": "\u00b7 rfl", "tactic_state": "case right\nG : Type u_1\ninst\u271d : Group G\n\u22a2 \u2200 (x : G) (n : \u2115), x \u2208 lowerCentralSeries G n \u2192 \u2200 (g : G), x * g * x\u207b\u00b9 * g\u207b\u00b9 \u2208 lowerCentralSeries G (n + 1)"}, {"line": "intro x n hxn g", "tactic_state": "case right\nG : Type u_1\ninst\u271d : Group G\nx : G\nn : \u2115\nhxn : x \u2208 lowerCentralSeries G n\ng : G\n\u22a2 x * g * x\u207b\u00b9 * g\u207b\u00b9 \u2208 lowerCentralSeries G (n + 1)"}, {"line": "exact commutator_mem_commutator hxn (mem_top g)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem derived_le_lower_central (n : \u2115) : derivedSeries G n \u2264 lowerCentralSeries G n := by\n  induction' n with i ih\n  \u00b7 simp\n  \u00b7 apply commutator_mono ih\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Nilpotent.lean", "context": {"open": ["Subgroup", "QuotientGroup", "Group", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{G : Type*} [Group G] (H : Subgroup G) [Normal H]", "(G)", "{G}", "(G) in", "(G) in", "(G)", "{G}", "[hG : IsNilpotent G]", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry \u2264 sorry"}, {"line": "induction' n with i ih", "tactic_state": "case zero\n\u22a2 sorry \u2264 sorry\n---\ncase succ\ni : \u2115\nih : sorry \u2264 sorry\n\u22a2 sorry \u2264 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\ni : \u2115\nih : sorry \u2264 sorry\n\u22a2 sorry \u2264 sorry"}, {"line": "\u00b7 apply commutator_mono ih\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lowerCentralSeries_prod (n : \u2115) :\n    lowerCentralSeries (G\u2081 \u00d7 G\u2082) n = (lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n) := by\n  induction' n with n ih\n  \u00b7 simp\n  \u00b7 calc\n      lowerCentralSeries (G\u2081 \u00d7 G\u2082) n.succ = \u2045lowerCentralSeries (G\u2081 \u00d7 G\u2082) n, \u22a4\u2046 := rfl\n      _ = \u2045(lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n), \u22a4\u2046 := by rw [ih]\n      _ = \u2045(lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n), (\u22a4 : Subgroup G\u2081).prod \u22a4\u2046 := by\n        simp\n      _ = \u2045lowerCentralSeries G\u2081 n, (\u22a4 : Subgroup G\u2081)\u2046.prod \u2045lowerCentralSeries G\u2082 n, \u22a4\u2046 :=\n        (commutator_prod_prod _ _ _ _)\n      _ = (lowerCentralSeries G\u2081 n.succ).prod (lowerCentralSeries G\u2082 n.succ) := rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Nilpotent.lean", "context": {"open": ["Subgroup", "QuotientGroup", "Group", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{G : Type*} [Group G] (H : Subgroup G) [Normal H]", "(G)", "{G}", "(G) in", "(G) in", "(G)", "{G}", "[hG : IsNilpotent G]", "(G) in", "{G\u2081 G\u2082 : Type*} [Group G\u2081] [Group G\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2081 : Type u_1\nG\u2082 : Type u_2\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "induction' n with n ih", "tactic_state": "case zero\nG\u2081 : Type u_1\nG\u2082 : Type u_2\n\u22a2 sorry = sorry\n---\ncase succ\nG\u2081 : Type u_1\nG\u2082 : Type u_2\nn : \u2115\nih : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nG\u2081 : Type u_1\nG\u2082 : Type u_2\nn : \u2115\nih : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "\u00b7 calc\n      lowerCentralSeries (G\u2081 \u00d7 G\u2082) n.succ = \u2045lowerCentralSeries (G\u2081 \u00d7 G\u2082) n, \u22a4\u2046 := rfl\n      _ = \u2045(lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n), \u22a4\u2046 := by rw [ih]\n      _ = \u2045(lowerCentralSeries G\u2081 n).prod (lowerCentralSeries G\u2082 n), (\u22a4 : Subgroup G\u2081).prod \u22a4\u2046 := by\n        simp\n      _ = \u2045lowerCentralSeries G\u2081 n, (\u22a4 : Subgroup G\u2081)\u2046.prod \u2045lowerCentralSeries G\u2082 n, \u22a4\u2046 :=\n        (commutator_prod_prod _ _ _ _)\n      _ = (lowerCentralSeries G\u2081 n.succ).prod (lowerCentralSeries G\u2082 n.succ) := rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isNilpotent_pi_of_bounded_class [\u2200 i, IsNilpotent (Gs i)] (n : \u2115)\n    (h : \u2200 i, Group.nilpotencyClass (Gs i) \u2264 n) : IsNilpotent (\u2200 i, Gs i) := by\n  rw [nilpotent_iff_lowerCentralSeries]\n  refine \u27e8n, ?_\u27e9\n  rw [eq_bot_iff]\n  apply le_trans (lowerCentralSeries_pi_le _)\n  rw [\u2190 eq_bot_iff]\n  rw [pi_eq_bot_iff]\n  intro i\n  apply lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (h i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Nilpotent.lean", "context": {"open": ["Subgroup", "QuotientGroup", "Group", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{G : Type*} [Group G] (H : Subgroup G) [Normal H]", "(G)", "{G}", "(G) in", "(G) in", "(G)", "{G}", "[hG : IsNilpotent G]", "(G) in", "{G\u2081 G\u2082 : Type*} [Group G\u2081] [Group G\u2082]", "{\u03b7 : Type*} {Gs : \u03b7 \u2192 Type*} [\u2200 i, Group (Gs i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 Group.IsNilpotent ((i : \u03b7) \u2192 Gs i)"}, {"line": "rw [nilpotent_iff_lowerCentralSeries]", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 \u2203 n, lowerCentralSeries ((i : \u03b7) \u2192 Gs i) n = \u22a5"}, {"line": "refine \u27e8n, ?_\u27e9", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 lowerCentralSeries ((i : \u03b7) \u2192 Gs i) n = \u22a5"}, {"line": "rw [eq_bot_iff]", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 lowerCentralSeries ((i : \u03b7) \u2192 Gs i) n \u2264 \u22a5"}, {"line": "apply le_trans (lowerCentralSeries_pi_le _)", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 (pi Set.univ fun i => lowerCentralSeries (Gs i) n) \u2264 \u22a5"}, {"line": "rw [\u2190 eq_bot_iff]", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 (pi Set.univ fun i => lowerCentralSeries (Gs i) n) = \u22a5"}, {"line": "rw [pi_eq_bot_iff]", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\n\u22a2 \u2200 (i : \u03b7), lowerCentralSeries (Gs i) n = \u22a5"}, {"line": "intro i", "tactic_state": "\u03b7 : Type u_1\nGs : \u03b7 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b7) \u2192 Group (Gs i)\ninst\u271d : \u2200 (i : \u03b7), Group.IsNilpotent (Gs i)\nn : \u2115\nh : \u2200 (i : \u03b7), Group.nilpotencyClass (Gs i) \u2264 n\ni : \u03b7\n\u22a2 lowerCentralSeries (Gs i) n = \u22a5"}, {"line": "apply lowerCentralSeries_eq_bot_iff_nilpotencyClass_le.mpr (h i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isNilpotent_of_product_of_sylow_group\n    (e : (\u2200 p : (Nat.card G).primeFactors, \u2200 P : Sylow p G, (\u2191P : Subgroup G)) \u2243* G) :\n    IsNilpotent G := by\n  classical\n    let ps := (Nat.card G).primeFactors\n    have : \u2200 (p : ps) (P : Sylow p G), IsNilpotent (\u2191P : Subgroup G) := by\n      intro p P\n      haveI : Fact (Nat.Prime \u2191p) := Fact.mk <| Nat.prime_of_mem_primeFactors p.2\n      exact P.isPGroup'.isNilpotent\n    exact nilpotent_of_mulEquiv e\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Nilpotent.lean", "context": {"open": ["Subgroup", "QuotientGroup", "Group", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "Group Fintype"], "variables": ["{G : Type*} [Group G] (H : Subgroup G) [Normal H]", "(G)", "{G}", "(G) in", "(G) in", "(G)", "{G}", "[hG : IsNilpotent G]", "(G) in", "{G\u2081 G\u2082 : Type*} [Group G\u2081] [Group G\u2082]", "{\u03b7 : Type*} {Gs : \u03b7 \u2192 Type*} [\u2200 i, Group (Gs i)]", "{\u03b7 : Type*} {Gs : \u03b7 \u2192 Type*} [\u2200 i, Group (Gs i)]", "{G : Type*} [hG : Group G]", "[Finite G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\nhG : Group G\ninst\u271d : Finite G\ne : ((p : { x // x \u2208 (Nat.card G).primeFactors }) \u2192 (P : Sylow (\u2191p) G) \u2192 \u21a5\u2191P) \u2243* G\n\u22a2 Group.IsNilpotent G"}, {"line": "classical\n    let ps := (Nat.card G).primeFactors\n    have : \u2200 (p : ps) (P : Sylow p G), IsNilpotent (\u2191P : Subgroup G) := by\n      intro p P\n      haveI : Fact (Nat.Prime \u2191p) := Fact.mk <| Nat.prime_of_mem_primeFactors p.2\n      exact P.isPGroup'.isNilpotent\n    exact nilpotent_of_mulEquiv e", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_of_noncommProd_eq_one_of_iSupIndep {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 G) (comm)\n    (K : \u03b9 \u2192 Subgroup G) (hind : iSupIndep K) (hmem : \u2200 x \u2208 s, f x \u2208 K x)\n    (heq1 : s.noncommProd f comm = 1) : \u2200 i \u2208 s, f i = 1 := by\n  classical\n    revert heq1\n    induction' s using Finset.induction_on with i s hnmem ih\n    \u00b7 simp\n    \u00b7 have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)\n      simp only [Finset.forall_mem_insert] at hmem\n      have hmem_bsupr : s.noncommProd f hcomm \u2208 \u2a06 i \u2208 (s : Set \u03b9), K i := by\n        refine Subgroup.noncommProd_mem _ _ ?_\n        intro x hx\n        have : K x \u2264 \u2a06 i \u2208 (s : Set \u03b9), K i := le_iSup\u2082 (f := fun i _ => K i) x hx\n        exact this (hmem.2 x hx)\n      intro heq1\n      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1\n      have hnmem' : i \u2209 (s : Set \u03b9) := by simpa\n      obtain \u27e8heq1i : f i = 1, heq1S : s.noncommProd f _ = 1\u27e9 :=\n        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1\n      intro i h\n      simp only [Finset.mem_insert] at h\n      rcases h with (rfl | h)\n      \u00b7 exact heq1i\n      \u00b7 refine ih hcomm hmem.2 heq1S _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/NoncommPiCoprod.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\n\u03b9 : Type u_2\ns : Finset \u03b9\nf : \u03b9 \u2192 G\ncomm : (\u2191s).Pairwise (Function.onFun Commute f)\nK : \u03b9 \u2192 Subgroup G\nhind : iSupIndep K\nhmem : \u2200 x \u2208 s, f x \u2208 K x\nheq1 : s.noncommProd f comm = 1\n\u22a2 \u2200 i \u2208 s, f i = 1"}, {"line": "classical\n    revert heq1\n    induction' s using Finset.induction_on with i s hnmem ih\n    \u00b7 simp\n    \u00b7 have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)\n      simp only [Finset.forall_mem_insert] at hmem\n      have hmem_bsupr : s.noncommProd f hcomm \u2208 \u2a06 i \u2208 (s : Set \u03b9), K i := by\n        refine Subgroup.noncommProd_mem _ _ ?_\n        intro x hx\n        have : K x \u2264 \u2a06 i \u2208 (s : Set \u03b9), K i := le_iSup\u2082 (f := fun i _ => K i) x hx\n        exact this (hmem.2 x hx)\n      intro heq1\n      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1\n      have hnmem' : i \u2209 (s : Set \u03b9) := by simpa\n      obtain \u27e8heq1i : f i = 1, heq1S : s.noncommProd f _ = 1\u27e9 :=\n        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1\n      intro i h\n      simp only [Finset.mem_insert] at h\n      rcases h with (rfl | h)\n      \u00b7 exact heq1i\n      \u00b7 refine ih hcomm hmem.2 heq1S _ h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma noncommPiCoprod_apply (h : (i : \u03b9) \u2192 N i) :\n    MonoidHom.noncommPiCoprod \u03d5 hcomm h = Finset.noncommProd Finset.univ (fun i \u21a6 \u03d5 i (h i))\n      (Pairwise.set_pairwise (fun \u2983i j\u2984 a \u21a6 hcomm a (h i) (h j)) _) := by\n  dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/NoncommPiCoprod.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{M : Type*} [Monoid M]", "{\u03b9 : Type*} [Fintype \u03b9]", "{N : \u03b9 \u2192 Type*} [\u2200 i, Monoid (N i)]", "(\u03d5 : \u2200 i : \u03b9, N i \u2192* M)", "(hcomm : Pairwise fun i j => \u2200 x y, Commute (\u03d5 i x) (\u03d5 j y))", "{hcomm}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d\u00b2 : Monoid M\n\u03b9 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\nN : \u03b9 \u2192 Type u_4\ninst\u271d : (i : \u03b9) \u2192 Monoid (N i)\n\u03d5 : (i : \u03b9) \u2192 N i \u2192* M\nhcomm : Pairwise fun i j => \u2200 (x : N i) (y : N j), Commute ((\u03d5 i) x) ((\u03d5 j) y)\nh : (i : \u03b9) \u2192 N i\n\u22a2 (MonoidHom.noncommPiCoprod \u03d5 hcomm) h = Finset.univ.noncommProd (fun i => (\u03d5 i) (h i)) \u22ef"}, {"line": "dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commute_subtype_of_commute\n    (hcomm : Pairwise fun i j : \u03b9 => \u2200 x y : G, x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y) (i j : \u03b9)\n    (hne : i \u2260 j) :\n    \u2200 (x : H i) (y : H j), Commute ((H i).subtype x) ((H j).subtype y) := by\n  rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9\n  exact hcomm hne x y hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/NoncommPiCoprod.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{M : Type*} [Monoid M]", "{\u03b9 : Type*} [Fintype \u03b9]", "{N : \u03b9 \u2192 Type*} [\u2200 i, Monoid (N i)]", "(\u03d5 : \u2200 i : \u03b9, N i \u2192* M)", "(hcomm : Pairwise fun i j => \u2200 x y, Commute (\u03d5 i x) (\u03d5 j y))", "{hcomm}", "{G : Type*} [Group G]", "{\u03b9 : Type*}", "{H : \u03b9 \u2192 Type*} [\u2200 i, Group (H i)]", "(\u03d5 : \u2200 i : \u03b9, H i \u2192* G)", "{G : Type*} [Group G]", "{\u03b9 : Type*} {H : \u03b9 \u2192 Subgroup G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_8\ninst\u271d : Group G\n\u03b9 : Type u_9\nH : \u03b9 \u2192 Subgroup G\nhcomm : Pairwise fun i j => \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y\ni j : \u03b9\nhne : i \u2260 j\n\u22a2 \u2200 (x : \u21a5(H i)) (y : \u21a5(H j)), Commute ((H i).subtype x) ((H j).subtype y)"}, {"line": "rintro \u27e8x, hx\u27e9 \u27e8y, hy\u27e9", "tactic_state": "case mk.mk\nG : Type u_8\ninst\u271d : Group G\n\u03b9 : Type u_9\nH : \u03b9 \u2192 Subgroup G\nhcomm : Pairwise fun i j => \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y\ni j : \u03b9\nhne : i \u2260 j\nx : G\nhx : x \u2208 H i\ny : G\nhy : y \u2208 H j\n\u22a2 Commute ((H i).subtype \u27e8x, hx\u27e9) ((H j).subtype \u27e8y, hy\u27e9)"}, {"line": "exact hcomm hne x y hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem independent_of_coprime_order\n    (hcomm : Pairwise fun i j : \u03b9 => \u2200 x y : G, x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y)\n    [Finite \u03b9] [\u2200 i, Fintype (H i)]\n    (hcoprime : Pairwise fun i j => Nat.Coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    iSupIndep H := by\n  simpa using\n    MonoidHom.independent_range_of_coprime_order (fun i => (H i).subtype)\n      (commute_subtype_of_commute hcomm) hcoprime\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/NoncommPiCoprod.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{M : Type*} [Monoid M]", "{\u03b9 : Type*} [Fintype \u03b9]", "{N : \u03b9 \u2192 Type*} [\u2200 i, Monoid (N i)]", "(\u03d5 : \u2200 i : \u03b9, N i \u2192* M)", "(hcomm : Pairwise fun i j => \u2200 x y, Commute (\u03d5 i x) (\u03d5 j y))", "{hcomm}", "{G : Type*} [Group G]", "{\u03b9 : Type*}", "{H : \u03b9 \u2192 Type*} [\u2200 i, Group (H i)]", "(\u03d5 : \u2200 i : \u03b9, H i \u2192* G)", "{G : Type*} [Group G]", "{\u03b9 : Type*} {H : \u03b9 \u2192 Subgroup G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_8\ninst\u271d\u00b2 : Group G\n\u03b9 : Type u_9\nH : \u03b9 \u2192 Subgroup G\nhcomm : Pairwise fun i j => \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : (i : \u03b9) \u2192 Fintype \u21a5(H i)\nhcoprime : Pairwise fun i j => (Fintype.card \u21a5(H i)).Coprime (Fintype.card \u21a5(H j))\n\u22a2 iSupIndep H"}, {"line": "simpa using\n    MonoidHom.independent_range_of_coprime_order (fun i => (H i).subtype)\n      (commute_subtype_of_commute hcomm) hcoprime", "tactic_state": "No Goals!"}]}
{"declaration": "theorem noncommPiCoprod_range\n    {hcomm : Pairwise fun i j : \u03b9 => \u2200 x y : G, x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y} :\n    (noncommPiCoprod hcomm).range = \u2a06 i : \u03b9, H i := by\n  simp [noncommPiCoprod, MonoidHom.noncommPiCoprod_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/NoncommPiCoprod.lean", "context": {"open": [], "variables": ["{G : Type*} [Group G]", "{M : Type*} [Monoid M]", "{\u03b9 : Type*} [Fintype \u03b9]", "{N : \u03b9 \u2192 Type*} [\u2200 i, Monoid (N i)]", "(\u03d5 : \u2200 i : \u03b9, N i \u2192* M)", "(hcomm : Pairwise fun i j => \u2200 x y, Commute (\u03d5 i x) (\u03d5 j y))", "{hcomm}", "{G : Type*} [Group G]", "{\u03b9 : Type*}", "{H : \u03b9 \u2192 Type*} [\u2200 i, Group (H i)]", "(\u03d5 : \u2200 i : \u03b9, H i \u2192* G)", "{G : Type*} [Group G]", "{\u03b9 : Type*} {H : \u03b9 \u2192 Subgroup G}", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_8\ninst\u271d\u00b9 : Group G\n\u03b9 : Type u_9\nH : \u03b9 \u2192 Subgroup G\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_10\nnoncommPiCoprod : x\u271d\nhcomm : Pairwise fun i j => \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y\n\u22a2 sorry = \u2a06 i, H i"}, {"line": "simp [noncommPiCoprod, MonoidHom.noncommPiCoprod_range]", "tactic_state": "G : Type u_8\ninst\u271d\u00b9 : Group G\n\u03b9 : Type u_9\nH : \u03b9 \u2192 Subgroup G\ninst\u271d : Fintype \u03b9\nx\u271d : Sort u_10\nnoncommPiCoprod : x\u271d\nhcomm : Pairwise fun i j => \u2200 (x y : G), x \u2208 H i \u2192 y \u2208 H j \u2192 Commute x y\n\u22a2 sorry () = \u2a06 i, H i"}]}
{"declaration": "theorem isOfFinOrder_iff_pow_eq_one : IsOfFinOrder x \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1 := by\n  simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 IsOfFinOrder x \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1"}, {"line": "simp [IsOfFinOrder, mem_periodicPts, isPeriodicPt_mul_iff_pow_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOfFinOrder_iff_zpow_eq_one {G} [DivisionMonoid G] {x : G} :\n    IsOfFinOrder x \u2194 \u2203 (n : \u2124), n \u2260 0 \u2227 x ^ n = 1 := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  refine \u27e8fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n \u25b8 hn'\u27e9,\n    fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n.natAbs, Int.natAbs_pos.mpr hn, ?_\u27e9\u27e9\n  rcases (Int.natAbs_eq_iff (a := n)).mp rfl with h | h\n  \u00b7 rwa [h, zpow_natCast] at hn'\n  \u00b7 rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\n\u22a2 IsOfFinOrder x \u2194 \u2203 n, n \u2260 0 \u2227 x ^ n = 1"}, {"line": "rw [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\n\u22a2 (\u2203 n, 0 < n \u2227 x ^ n = 1) \u2194 \u2203 n, n \u2260 0 \u2227 x ^ n = 1"}, {"line": "refine \u27e8fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n, Int.natCast_ne_zero_iff_pos.mpr hn, zpow_natCast x n \u25b8 hn'\u27e9,\n    fun \u27e8n, hn, hn'\u27e9 \u21a6 \u27e8n.natAbs, Int.natAbs_pos.mpr hn, ?_\u27e9\u27e9", "tactic_state": "G : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\nx\u271d : \u2203 n, n \u2260 0 \u2227 x ^ n = 1\nn : \u2124\nhn : n \u2260 0\nhn' : x ^ n = 1\n\u22a2 x ^ n.natAbs = 1"}, {"line": "rcases (Int.natAbs_eq_iff (a := n)).mp rfl with h | h", "tactic_state": "case inl\nG : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\nx\u271d : \u2203 n, n \u2260 0 \u2227 x ^ n = 1\nn : \u2124\nhn : n \u2260 0\nhn' : x ^ n = 1\nh : n = \u2191n.natAbs\n\u22a2 x ^ n.natAbs = 1\n---\ncase inr\nG : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\nx\u271d : \u2203 n, n \u2260 0 \u2227 x ^ n = 1\nn : \u2124\nhn : n \u2260 0\nhn' : x ^ n = 1\nh : n = -\u2191n.natAbs\n\u22a2 x ^ n.natAbs = 1"}, {"line": "\u00b7 rwa [h, zpow_natCast] at hn'", "tactic_state": "case inr\nG : Type u_6\ninst\u271d : DivisionMonoid G\nx : G\nx\u271d : \u2203 n, n \u2260 0 \u2227 x ^ n = 1\nn : \u2124\nhn : n \u2260 0\nhn' : x ^ n = 1\nh : n = -\u2191n.natAbs\n\u22a2 x ^ n.natAbs = 1"}, {"line": "\u00b7 rwa [h, zpow_neg, inv_eq_one, zpow_natCast] at hn'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsOfFinOrder.pow {n : \u2115} : IsOfFinOrder a \u2192 IsOfFinOrder (a ^ n) := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one]\n  rintro \u27e8m, hm, ha\u27e9\n  exact \u27e8m, hm, by simp [pow_right_comm _ n, ha]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\n\u22a2 IsOfFinOrder a \u2192 IsOfFinOrder (a ^ n)"}, {"line": "simp_rw [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\n\u22a2 (\u2203 n, 0 < n \u2227 a ^ n = 1) \u2192 \u2203 n_1, 0 < n_1 \u2227 (a ^ n) ^ n_1 = 1"}, {"line": "rintro \u27e8m, hm, ha\u27e9", "tactic_state": "case intro.intro\nG : Type u_1\ninst\u271d : Monoid G\na : G\nn m : \u2115\nhm : 0 < m\nha : a ^ m = 1\n\u22a2 \u2203 n_1, 0 < n_1 \u2227 (a ^ n) ^ n_1 = 1"}, {"line": "exact \u27e8m, hm, by simp [pow_right_comm _ n, ha]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsOfFinOrder.of_pow {n : \u2115} (h : IsOfFinOrder (a ^ n)) (hn : n \u2260 0) : IsOfFinOrder a := by\n  rw [isOfFinOrder_iff_pow_eq_one] at *\n  rcases h with \u27e8m, hm, ha\u27e9\n  exact \u27e8n * m, mul_pos hn.bot_lt hm, by rwa [pow_mul]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\nh : IsOfFinOrder (a ^ n)\nhn : n \u2260 0\n\u22a2 IsOfFinOrder a"}, {"line": "rw [isOfFinOrder_iff_pow_eq_one] at *", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\nh : \u2203 n_1, 0 < n_1 \u2227 (a ^ n) ^ n_1 = 1\nhn : n \u2260 0\n\u22a2 \u2203 n, 0 < n \u2227 a ^ n = 1"}, {"line": "rcases h with \u27e8m, hm, ha\u27e9", "tactic_state": "case intro.intro\nG : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\nhn : n \u2260 0\nm : \u2115\nhm : 0 < m\nha : (a ^ n) ^ m = 1\n\u22a2 \u2203 n, 0 < n \u2227 a ^ n = 1"}, {"line": "exact \u27e8n * m, mul_pos hn.bot_lt hm, by rwa [pow_mul]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOfFinOrder_pow {n : \u2115} : IsOfFinOrder (a ^ n) \u2194 IsOfFinOrder a \u2228 n = 0 := by\n  rcases Decidable.eq_or_ne n 0 with rfl | hn\n  \u00b7 simp\n  \u00b7 exact \u27e8fun h \u21a6 .inl <| h.of_pow hn, fun h \u21a6 (h.resolve_right hn).pow\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\n\u22a2 IsOfFinOrder (a ^ n) \u2194 IsOfFinOrder a \u2228 n = 0"}, {"line": "rcases Decidable.eq_or_ne n 0 with rfl | hn", "tactic_state": "case inl\nG : Type u_1\ninst\u271d : Monoid G\na : G\n\u22a2 IsOfFinOrder (a ^ 0) \u2194 IsOfFinOrder a \u2228 0 = 0\n---\ncase inr\nG : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\nhn : n \u2260 0\n\u22a2 IsOfFinOrder (a ^ n) \u2194 IsOfFinOrder a \u2228 n = 0"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nG : Type u_1\ninst\u271d : Monoid G\na : G\nn : \u2115\nhn : n \u2260 0\n\u22a2 IsOfFinOrder (a ^ n) \u2194 IsOfFinOrder a \u2228 n = 0"}, {"line": "\u00b7 exact \u27e8fun h \u21a6 .inl <| h.of_pow hn, fun h \u21a6 (h.resolve_right hn).pow\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submonoid.isOfFinOrder_coe {H : Submonoid G} {x : H} :\n    IsOfFinOrder (x : G) \u2194 IsOfFinOrder x := by\n  rw [isOfFinOrder_iff_pow_eq_one]\n  rw [isOfFinOrder_iff_pow_eq_one]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nH : Submonoid G\nx : \u21a5H\n\u22a2 IsOfFinOrder \u2191x \u2194 IsOfFinOrder x"}, {"line": "rw [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nH : Submonoid G\nx : \u21a5H\n\u22a2 (\u2203 n, 0 < n \u2227 \u2191x ^ n = 1) \u2194 IsOfFinOrder x"}, {"line": "rw [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nH : Submonoid G\nx : \u21a5H\n\u22a2 (\u2203 n, 0 < n \u2227 \u2191x ^ n = 1) \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsConj.isOfFinOrder (h : IsConj x y) : IsOfFinOrder x \u2192 IsOfFinOrder y := by\n  simp_rw [isOfFinOrder_iff_pow_eq_one]\n  rintro \u27e8n, n_gt_0, eq'\u27e9\n  exact \u27e8n, n_gt_0, by rw [\u2190 isConj_one_right, \u2190 eq']; exact h.pow n\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : IsConj x y\n\u22a2 IsOfFinOrder x \u2192 IsOfFinOrder y"}, {"line": "simp_rw [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : IsConj x y\n\u22a2 (\u2203 n, 0 < n \u2227 x ^ n = 1) \u2192 \u2203 n, 0 < n \u2227 y ^ n = 1"}, {"line": "rintro \u27e8n, n_gt_0, eq'\u27e9", "tactic_state": "case intro.intro\nG : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : IsConj x y\nn : \u2115\nn_gt_0 : 0 < n\neq' : x ^ n = 1\n\u22a2 \u2203 n, 0 < n \u2227 y ^ n = 1"}, {"line": "exact \u27e8n, n_gt_0, by rw [\u2190 isConj_one_right, \u2190 eq']; exact h.pow n\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_eq_zero (h : \u00acIsOfFinOrder x) : orderOf x = 0 := by\n  rwa [orderOf, minimalPeriod, dif_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nh : \u00acIsOfFinOrder x\n\u22a2 orderOf x = 0"}, {"line": "rwa [orderOf, minimalPeriod, dif_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_eq_zero_iff' : orderOf x = 0 \u2194 \u2200 n : \u2115, 0 < n \u2192 x ^ n \u2260 1 := by\n  simp_rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one, not_exists, not_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 orderOf x = 0 \u2194 \u2200 (n : \u2115), 0 < n \u2192 x ^ n \u2260 1"}, {"line": "simp_rw [orderOf_eq_zero_iff, isOfFinOrder_iff_pow_eq_one, not_exists, not_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_pos_iff : 0 < orderOf x \u2194 IsOfFinOrder x := by\n  rw [iff_not_comm.mp orderOf_eq_zero_iff]\n  rw [pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 0 < orderOf x \u2194 IsOfFinOrder x"}, {"line": "rw [iff_not_comm.mp orderOf_eq_zero_iff]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 0 < orderOf x \u2194 \u00acorderOf x = 0"}, {"line": "rw [pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_eq_one_iff : orderOf x = 1 \u2194 x = 1 := by\n  rw [orderOf]\n  rw [minimalPeriod_eq_one_iff_isFixedPt]\n  rw [IsFixedPt]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 orderOf x = 1 \u2194 x = 1"}, {"line": "rw [orderOf]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 minimalPeriod (fun x_1 => x * x_1) 1 = 1 \u2194 x = 1"}, {"line": "rw [minimalPeriod_eq_one_iff_isFixedPt]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 IsFixedPt (fun x_1 => x * x_1) 1 \u2194 x = 1"}, {"line": "rw [IsFixedPt]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\n\u22a2 x * 1 = 1 \u2194 x = 1"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_pow_dvd (n : \u2115) : orderOf (x ^ n) \u2223 orderOf x := by\n  rw [orderOf_dvd_iff_pow_eq_one]\n  rw [pow_right_comm]\n  rw [pow_orderOf_eq_one]\n  rw [one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 orderOf (x ^ n) \u2223 orderOf x"}, {"line": "rw [orderOf_dvd_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 (x ^ n) ^ orderOf x = 1"}, {"line": "rw [pow_right_comm]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 (x ^ orderOf x) ^ n = 1"}, {"line": "rw [pow_orderOf_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 1 ^ n = 1"}, {"line": "rw [one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_eq_one_iff_modEq : x ^ n = 1 \u2194 n \u2261 0 [MOD orderOf x] := by\n  rw [modEq_zero_iff_dvd]\n  rw [orderOf_dvd_iff_pow_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 x ^ n = 1 \u2194 n \u2261 0 [MOD orderOf x]"}, {"line": "rw [modEq_zero_iff_dvd]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\n\u22a2 x ^ n = 1 \u2194 orderOf x \u2223 n"}, {"line": "rw [orderOf_dvd_iff_pow_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_eq_orderOf_iff {H : Type*} [Monoid H] {y : H} :\n    orderOf x = orderOf y \u2194 \u2200 n : \u2115, x ^ n = 1 \u2194 y ^ n = 1 := by\n  simp_rw [\u2190 isPeriodicPt_mul_iff_pow_eq_one, \u2190 minimalPeriod_eq_minimalPeriod_iff, orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Monoid G\nx : G\nH : Type u_6\ninst\u271d : Monoid H\ny : H\n\u22a2 orderOf x = orderOf y \u2194 \u2200 (n : \u2115), x ^ n = 1 \u2194 y ^ n = 1"}, {"line": "simp_rw [\u2190 isPeriodicPt_mul_iff_pow_eq_one, \u2190 minimalPeriod_eq_minimalPeriod_iff, orderOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma orderOf_pow_of_dvd {x : G} {n : \u2115} (hn : n \u2260 0) (dvd : n \u2223 orderOf x) :\n    orderOf (x ^ n) = orderOf x / n := by rw [orderOf_pow' _ hn, Nat.gcd_eq_right dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\nn : \u2115\nhn : n \u2260 0\ndvd : n \u2223 orderOf x\n\u22a2 orderOf (x ^ n) = orderOf x / n"}, {"line": "rw [orderOf_pow' _ hn, Nat.gcd_eq_right dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.Coprime.orderOf_pow (h : (orderOf y).Coprime m) : orderOf (y ^ m) = orderOf y := by\n  by_cases hg : IsOfFinOrder y\n  \u00b7 rw [hg.orderOf_pow y m , h.gcd_eq_one, Nat.div_one]\n  \u00b7 rw [m.coprime_zero_left.1 (orderOf_eq_zero hg \u25b8 h), pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\ny : G\nm : \u2115\nh : (orderOf y).Coprime m\n\u22a2 orderOf (y ^ m) = orderOf y"}, {"line": "by_cases hg : IsOfFinOrder y", "tactic_state": "case pos\nG : Type u_1\ninst\u271d : Monoid G\ny : G\nm : \u2115\nh : (orderOf y).Coprime m\nhg : sorry\n\u22a2 orderOf (y ^ m) = orderOf y\n---\ncase neg\nG : Type u_1\ninst\u271d : Monoid G\ny : G\nm : \u2115\nh : (orderOf y).Coprime m\nhg : \u00acsorry\n\u22a2 orderOf (y ^ m) = orderOf y"}, {"line": "\u00b7 rw [hg.orderOf_pow y m , h.gcd_eq_one, Nat.div_one]", "tactic_state": "case neg\nG : Type u_1\ninst\u271d : Monoid G\ny : G\nm : \u2115\nh : (orderOf y).Coprime m\nhg : \u00acsorry\n\u22a2 orderOf (y ^ m) = orderOf y"}, {"line": "\u00b7 rw [m.coprime_zero_left.1 (orderOf_eq_zero hg \u25b8 h), pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_mul_dvd_lcm (h : Commute x y) :\n    orderOf (x * y) \u2223 Nat.lcm (orderOf x) (orderOf y) := by\n  rw [orderOf]\n  rw [\u2190 comp_mul_left]\n  exact Function.Commute.minimalPeriod_of_comp_dvd_lcm h.function_commute_mul_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\n\u22a2 orderOf (x * y) \u2223 (orderOf x).lcm (orderOf y)"}, {"line": "rw [orderOf]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\n\u22a2 minimalPeriod (fun x_1 => x * y * x_1) 1 \u2223 (orderOf x).lcm (orderOf y)"}, {"line": "rw [\u2190 comp_mul_left]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\n\u22a2 minimalPeriod ((fun x_1 => x * x_1) \u2218 fun x => y * x) 1 \u2223 (orderOf x).lcm (orderOf y)"}, {"line": "exact Function.Commute.minimalPeriod_of_comp_dvd_lcm h.function_commute_mul_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_mul_eq_mul_orderOf_of_coprime (h : Commute x y)\n    (hco : (orderOf x).Coprime (orderOf y)) : orderOf (x * y) = orderOf x * orderOf y := by\n  rw [orderOf]\n  rw [\u2190 comp_mul_left]\n  exact h.function_commute_mul_left.minimalPeriod_of_comp_eq_mul_of_coprime hco\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhco : (orderOf x).Coprime (orderOf y)\n\u22a2 orderOf (x * y) = orderOf x * orderOf y"}, {"line": "rw [orderOf]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhco : (orderOf x).Coprime (orderOf y)\n\u22a2 minimalPeriod (fun x_1 => x * y * x_1) 1 = orderOf x * orderOf y"}, {"line": "rw [\u2190 comp_mul_left]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx y : G\nh : Commute x y\nhco : (orderOf x).Coprime (orderOf y)\n\u22a2 minimalPeriod ((fun x_1 => x * x_1) \u2218 fun x => y * x) 1 = orderOf x * orderOf y"}, {"line": "exact h.function_commute_mul_left.minimalPeriod_of_comp_eq_mul_of_coprime hco", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_eq_prime_iff : orderOf x = p \u2194 x ^ p = 1 \u2227 x \u2260 1 := by\n  rw [orderOf]\n  rw [minimalPeriod_eq_prime_iff]\n  rw [isPeriodicPt_mul_iff_pow_eq_one]\n  rw [IsFixedPt]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 orderOf x = p \u2194 x ^ p = 1 \u2227 x \u2260 1"}, {"line": "rw [orderOf]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 minimalPeriod (fun x_1 => x * x_1) 1 = p \u2194 x ^ p = 1 \u2227 x \u2260 1"}, {"line": "rw [minimalPeriod_eq_prime_iff]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 IsPeriodicPt (fun x_1 => x * x_1) p 1 \u2227 \u00acIsFixedPt (fun x_1 => x * x_1) 1 \u2194 x ^ p = 1 \u2227 x \u2260 1\n---\nG : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [isPeriodicPt_mul_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 x ^ p = 1 \u2227 \u00acIsFixedPt (fun x_1 => x * x_1) 1 \u2194 x ^ p = 1 \u2227 x \u2260 1\n---\nG : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [IsFixedPt]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 x ^ p = 1 \u2227 \u00acx * 1 = 1 \u2194 x ^ p = 1 \u2227 x \u2260 1\n---\nG : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 Fact (Nat.Prime p)"}, {"line": "rw [mul_one]", "tactic_state": "G : Type u_1\ninst\u271d : Monoid G\nx : G\np : \u2115\n\u22a2 Fact (Nat.Prime p)"}]}
{"declaration": "theorem isOfFinOrder_inv_iff {x : G} : IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x := by\n  simp [isOfFinOrder_iff_pow_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\n\u22a2 IsOfFinOrder x\u207b\u00b9 \u2194 IsOfFinOrder x"}, {"line": "simp [isOfFinOrder_iff_pow_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\n\u22a2 (\u2203 n, 0 < n \u2227 x\u207b\u00b9 ^ n = 1) \u2194 \u2203 n, 0 < n \u2227 x ^ n = 1"}]}
{"declaration": "theorem orderOf_dvd_iff_zpow_eq_one : (orderOf x : \u2124) \u2223 i \u2194 x ^ i = 1 := by\n  rcases Int.eq_nat_or_neg i with \u27e8i, rfl | rfl\u27e9\n  \u00b7 rw [Int.natCast_dvd_natCast, orderOf_dvd_iff_pow_eq_one, zpow_natCast]\n  \u00b7 rw [dvd_neg, Int.natCast_dvd_natCast, zpow_neg, inv_eq_one, zpow_natCast,\n      orderOf_dvd_iff_pow_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2124\n\u22a2 \u2191(orderOf x) \u2223 i \u2194 x ^ i = 1"}, {"line": "rcases Int.eq_nat_or_neg i with \u27e8i, rfl | rfl\u27e9", "tactic_state": "case intro.inl\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2115\n\u22a2 \u2191(orderOf x) \u2223 \u2191i \u2194 x ^ \u2191i = 1\n---\ncase intro.inr\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2115\n\u22a2 \u2191(orderOf x) \u2223 -\u2191i \u2194 x ^ (-\u2191i) = 1"}, {"line": "\u00b7 rw [Int.natCast_dvd_natCast, orderOf_dvd_iff_pow_eq_one, zpow_natCast]", "tactic_state": "case intro.inr\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2115\n\u22a2 \u2191(orderOf x) \u2223 -\u2191i \u2194 x ^ (-\u2191i) = 1"}, {"line": "\u00b7 rw [dvd_neg, Int.natCast_dvd_natCast, zpow_neg, inv_eq_one, zpow_natCast,\n      orderOf_dvd_iff_pow_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orderOf_inv (x : G) : orderOf x\u207b\u00b9 = orderOf x := by simp [orderOf_eq_orderOf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\n\u22a2 orderOf x\u207b\u00b9 = orderOf x"}, {"line": "simp [orderOf_eq_orderOf_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\n\u22a2 \u2200 (n : \u2115), x\u207b\u00b9 ^ n = 1 \u2194 x ^ n = 1"}]}
{"declaration": "theorem zpow_pow_orderOf : (x ^ i) ^ orderOf x = 1 := by\n  by_cases h : IsOfFinOrder x\n  \u00b7 rw [\u2190 zpow_natCast, \u2190 zpow_mul, mul_comm, zpow_mul, zpow_natCast, pow_orderOf_eq_one, one_zpow]\n  \u00b7 rw [orderOf_eq_zero h, _root_.pow_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2124\n\u22a2 (x ^ i) ^ orderOf x = 1"}, {"line": "by_cases h : IsOfFinOrder x", "tactic_state": "case pos\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2124\nh : sorry\n\u22a2 (x ^ i) ^ orderOf x = 1\n---\ncase neg\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2124\nh : \u00acsorry\n\u22a2 (x ^ i) ^ orderOf x = 1"}, {"line": "\u00b7 rw [\u2190 zpow_natCast, \u2190 zpow_mul, mul_comm, zpow_mul, zpow_natCast, pow_orderOf_eq_one, one_zpow]", "tactic_state": "case neg\nG : Type u_1\ninst\u271d\u00b2 : Monoid G\ninst\u271d\u00b9 : LeftCancelMonoid G\ninst\u271d : Group G\nx : G\ni : \u2124\nh : \u00acsorry\n\u22a2 (x ^ i) ^ orderOf x = 1"}, {"line": "\u00b7 rw [orderOf_eq_zero h, _root_.pow_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_card_orderOf_eq_card_pow_eq_one [Fintype G] [DecidableEq G] (hn : n \u2260 0) :\n    \u2211 m \u2208 divisors n, #{x : G | orderOf x = m} = #{x : G | x ^ n = 1} := by\n  refine (Finset.card_biUnion ?_).symm.trans ?_\n  \u00b7 simp +contextual [Set.PairwiseDisjoint, Set.Pairwise, disjoint_iff, Finset.ext_iff]\n  \u00b7 congr; ext; simp [hn, orderOf_dvd_iff_pow_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 \u2211 m \u2208 n.divisors, {x | orderOf x = m}.card = {x | x ^ n = 1}.card"}, {"line": "refine (Finset.card_biUnion ?_).symm.trans ?_", "tactic_state": "case refine_1\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 DecidableEq G\n---\ncase refine_2\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 (\u2191n.divisors).PairwiseDisjoint fun m => {x | orderOf x = m}\n---\ncase refine_3\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 (n.divisors.biUnion fun m => {x | orderOf x = m}).card = {x | x ^ n = 1}.card"}, {"line": "\u00b7 simp +contextual [Set.PairwiseDisjoint, Set.Pairwise, disjoint_iff, Finset.ext_iff]", "tactic_state": "case refine_2\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 (\u2191n.divisors).PairwiseDisjoint fun m => {x | orderOf x = m}\n---\ncase refine_3\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 (n.divisors.biUnion fun m => {x | orderOf x = m}).card = {x | x ^ n = 1}.card"}, {"line": "\u00b7 congr; ext; simp [hn, orderOf_dvd_iff_pow_eq_one]", "tactic_state": "case refine_3\nG : Type u_1\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : CommMonoid G\ninst\u271d\u00b2 : Monoid G\nn : \u2115\ninst\u271d\u00b9 : Fintype G\ninst\u271d : DecidableEq G\nhn : n \u2260 0\n\u22a2 (n.divisors.biUnion fun m => {x | orderOf x = m}).card = {x | x ^ n = 1}.card"}]}
{"declaration": "theorem zpow_eq_zpow_iff_modEq {m n : \u2124} : x ^ m = x ^ n \u2194 m \u2261 n [ZMOD orderOf x] := by\n  rw [\u2190 mul_inv_eq_one]\n  rw [\u2190 zpow_sub]\n  rw [zpow_eq_one_iff_modEq]\n  rw [Int.modEq_iff_dvd]\n  rw [Int.modEq_iff_dvd]\n  rw [zero_sub]\n  rw [neg_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 x ^ m = x ^ n \u2194 m \u2261 n [ZMOD \u2191(orderOf x)]"}, {"line": "rw [\u2190 mul_inv_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 x ^ m * (x ^ n)\u207b\u00b9 = 1 \u2194 m \u2261 n [ZMOD \u2191(orderOf x)]\n---\nG : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 Group G"}, {"line": "rw [\u2190 zpow_sub]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 x ^ (m - n) = 1 \u2194 m \u2261 n [ZMOD \u2191(orderOf x)]"}, {"line": "rw [zpow_eq_one_iff_modEq]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 m - n \u2261 0 [ZMOD \u2191(orderOf x)] \u2194 m \u2261 n [ZMOD \u2191(orderOf x)]"}, {"line": "rw [Int.modEq_iff_dvd]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 \u2191(orderOf x) \u2223 0 - (m - n) \u2194 m \u2261 n [ZMOD \u2191(orderOf x)]"}, {"line": "rw [Int.modEq_iff_dvd]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 \u2191(orderOf x) \u2223 0 - (m - n) \u2194 \u2191(orderOf x) \u2223 n - m"}, {"line": "rw [zero_sub]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 \u2191(orderOf x) \u2223 -(m - n) \u2194 \u2191(orderOf x) \u2223 n - m"}, {"line": "rw [neg_sub]", "tactic_state": "G : Type u_1\ninst\u271d\u2078 : Monoid G\ninst\u271d\u2077 : LeftCancelMonoid G\ninst\u271d\u2076 : Group G\ninst\u271d\u2075 : CommMonoid G\ninst\u271d\u2074 : Monoid G\ninst\u271d\u00b3 : LeftCancelMonoid G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\ninst\u271d : Group G\nx : G\nm n : \u2124\n\u22a2 \u2191(orderOf x) \u2223 n - m \u2194 \u2191(orderOf x) \u2223 n - m"}]}
{"declaration": "theorem orderOf_dvd_natCard {G : Type*} [Group G] (x : G) : orderOf x \u2223 Nat.card G := by\n  obtain h | h := fintypeOrInfinite G\n  \u00b7 simp only [Nat.card_eq_fintype_card, orderOf_dvd_card]\n  \u00b7 simp only [card_eq_zero_of_infinite, dvd_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : Group G\nx : G\n\u22a2 orderOf x \u2223 Nat.card G"}, {"line": "obtain h | h := fintypeOrInfinite G", "tactic_state": "case inl\nG : Type u_6\ninst\u271d : Group G\nx : G\nh : Fintype G\n\u22a2 orderOf x \u2223 Nat.card G\n---\ncase inr\nG : Type u_6\ninst\u271d : Group G\nx : G\nh : Infinite G\n\u22a2 orderOf x \u2223 Nat.card G"}, {"line": "\u00b7 simp only [Nat.card_eq_fintype_card, orderOf_dvd_card]", "tactic_state": "case inr\nG : Type u_6\ninst\u271d : Group G\nx : G\nh : Infinite G\n\u22a2 orderOf x \u2223 Nat.card G"}, {"line": "\u00b7 simp only [card_eq_zero_of_infinite, dvd_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zpow_mod_card (a : G) (n : \u2124) : a ^ (n % Fintype.card G : \u2124) = a ^ n := by\n  rw [eq_comm]\n  rw [\u2190 zpow_mod_orderOf]\n  rw [\u2190 Int.emod_emod_of_dvd n     (Int.natCast_dvd_natCast.2 orderOf_dvd_card)]\n  rw [zpow_mod_orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u2070 : Monoid G\ninst\u271d\u2079 : LeftCancelMonoid G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : CommMonoid G\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Finite G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\ninst\u271d : Fintype G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(card G)) = a ^ n"}, {"line": "rw [eq_comm]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u2070 : Monoid G\ninst\u271d\u2079 : LeftCancelMonoid G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : CommMonoid G\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Finite G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\ninst\u271d : Fintype G\na : G\nn : \u2124\n\u22a2 a ^ n = a ^ (n % \u2191(card G))"}, {"line": "rw [\u2190 zpow_mod_orderOf]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u2070 : Monoid G\ninst\u271d\u2079 : LeftCancelMonoid G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : CommMonoid G\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Finite G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\ninst\u271d : Fintype G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(orderOf a)) = a ^ (n % \u2191(card G))"}, {"line": "rw [\u2190 Int.emod_emod_of_dvd n     (Int.natCast_dvd_natCast.2 orderOf_dvd_card)]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u2070 : Monoid G\ninst\u271d\u2079 : LeftCancelMonoid G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : CommMonoid G\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Finite G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\ninst\u271d : Fintype G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(card G) % \u2191(orderOf a)) = a ^ (n % \u2191(card G))\n---\nG : Type u_1\ninst\u271d\u00b9\u2070 : Monoid G\ninst\u271d\u2079 : LeftCancelMonoid G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : CommMonoid G\ninst\u271d\u2076 : Monoid G\ninst\u271d\u2075 : LeftCancelMonoid G\ninst\u271d\u2074 : Finite G\ninst\u271d\u00b3 : Fintype G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\ninst\u271d : Fintype G\na : G\nn : \u2124\n\u22a2 Fintype G"}, {"line": "rw [zpow_mod_orderOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_mod_natCard {G} [Group G] (a : G) (n : \u2115) : a ^ (n % Nat.card G) = a ^ n := by\n  rw [eq_comm]\n  rw [\u2190 pow_mod_orderOf]\n  rw [\u2190 Nat.mod_mod_of_dvd n <| orderOf_dvd_natCard _]\n  rw [pow_mod_orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ (n % Nat.card G) = a ^ n"}, {"line": "rw [eq_comm]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ n = a ^ (n % Nat.card G)"}, {"line": "rw [\u2190 pow_mod_orderOf]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ (n % orderOf a) = a ^ (n % Nat.card G)"}, {"line": "rw [\u2190 Nat.mod_mod_of_dvd n <| orderOf_dvd_natCard _]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2115\n\u22a2 a ^ (n % Nat.card G % orderOf a) = a ^ (n % Nat.card G)"}, {"line": "rw [pow_mod_orderOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_mod_natCard {G} [Group G] (a : G) (n : \u2124) : a ^ (n % Nat.card G : \u2124) = a ^ n := by\n  rw [eq_comm]\n  rw [\u2190 zpow_mod_orderOf]\n  rw [\u2190 Int.emod_emod_of_dvd n <|     Int.natCast_dvd_natCast.2 <| orderOf_dvd_natCard _]\n  rw [zpow_mod_orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(Nat.card G)) = a ^ n"}, {"line": "rw [eq_comm]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ n = a ^ (n % \u2191(Nat.card G))"}, {"line": "rw [\u2190 zpow_mod_orderOf]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(orderOf a)) = a ^ (n % \u2191(Nat.card G))"}, {"line": "rw [\u2190 Int.emod_emod_of_dvd n <|     Int.natCast_dvd_natCast.2 <| orderOf_dvd_natCard _]", "tactic_state": "G : Type u_6\ninst\u271d : Group G\na : G\nn : \u2124\n\u22a2 a ^ (n % \u2191(Nat.card G) % \u2191(orderOf a)) = a ^ (n % \u2191(Nat.card G))"}, {"line": "rw [zpow_mod_orderOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_range_orderOf [DecidableEq G] :\n    letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n    Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (zpowers x : Set G).toFinset := by\n  letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred\n  ext x\n  rw [Set.mem_toFinset]\n  rw [SetLike.mem_coe]\n  rw [mem_zpowers_iff_mem_range_orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx : G\ninst\u271d : DecidableEq G\n\u22a2 Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (\u2191(zpowers x)).toFinset"}, {"line": "letI : Fintype (zpowers x) := (Subgroup.zpowers x).instFintypeSubtypeMemOfDecidablePred", "tactic_state": "G : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\n\u22a2 Finset.image (fun i => x ^ i) (Finset.range (orderOf x)) = (\u2191(zpowers x)).toFinset"}, {"line": "ext x", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 x \u2208 Finset.image (fun i => x\u271d ^ i) (Finset.range (orderOf x\u271d)) \u2194 x \u2208 (\u2191(zpowers x\u271d)).toFinset"}, {"line": "rw [Set.mem_toFinset]", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 x \u2208 Finset.image (fun i => x\u271d ^ i) (Finset.range (orderOf x\u271d)) \u2194 x \u2208 \u2191(zpowers x\u271d)"}, {"line": "rw [SetLike.mem_coe]", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 x \u2208 Finset.image (fun i => x\u271d ^ i) (Finset.range (orderOf x\u271d)) \u2194 x \u2208 zpowers x\u271d"}, {"line": "rw [mem_zpowers_iff_mem_range_orderOf]", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 x \u2208 Finset.image (fun i => x\u271d ^ i) (Finset.range (orderOf x\u271d)) \u2194\n    x \u2208 Finset.image (fun x => x\u271d ^ x) (Finset.range (orderOf x\u271d))\n---\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 Finite G\n---\nG : Type u_1\ninst\u271d\u00b9\u00b9 : Monoid G\ninst\u271d\u00b9\u2070 : LeftCancelMonoid G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : CommMonoid G\ninst\u271d\u2077 : Monoid G\ninst\u271d\u2076 : LeftCancelMonoid G\ninst\u271d\u2075 : Finite G\ninst\u271d\u2074 : Fintype G\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : Finite G\ninst\u271d\u00b9 : Fintype G\nx\u271d : G\ninst\u271d : DecidableEq G\nthis : Fintype sorry := sorry\nx : G\n\u22a2 DecidableEq G"}]}
{"declaration": "lemma smul_eq_of_le_smul\n    {G : Type*} [Group G] [Finite G] {\u03b1 : Type*} [PartialOrder \u03b1] {g : G} {a : \u03b1}\n    [MulAction G \u03b1] [CovariantClass G \u03b1 HSMul.hSMul LE.le] (h : a \u2264 g \u2022 a) : g \u2022 a = a := by\n  have key := smul_mono_right g (le_pow_smul h (Nat.card G - 1))\n  rw [smul_smul] at key\n  rw [\u2190 _root_.pow_succ'] at key\n  rw [Nat.sub_one_add_one_eq_of_pos Nat.card_pos] at key\n  rw [pow_card_eq_one'] at key\n  rw [one_smul] at key\n  exact le_antisymm key h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a"}, {"line": "have key := smul_mono_right g (le_pow_smul h (Nat.card G - 1))", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g \u2022 g ^ (Nat.card G - 1) \u2022 a\n\u22a2 g \u2022 a = a\n---\ncase refine_1\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\n\u22a2 SMul G \u03b1"}, {"line": "rw [smul_smul] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 (g * g ^ (Nat.card G - 1)) \u2022 a\n\u22a2 g \u2022 a = a"}, {"line": "rw [\u2190 _root_.pow_succ'] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 g \u2022 a = a"}, {"line": "rw [Nat.sub_one_add_one_eq_of_pos Nat.card_pos] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ Nat.card G \u2022 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Finite G"}, {"line": "rw [pow_card_eq_one'] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 1 \u2022 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Finite G"}, {"line": "rw [one_smul] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Finite G"}, {"line": "exact le_antisymm key h", "tactic_state": "G : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : a \u2264 g \u2022 a\nkey : g \u2022 a \u2264 g ^ (Nat.card G - 1 + 1) \u2022 a\n\u22a2 Finite G"}]}
{"declaration": "lemma smul_eq_of_smul_le\n    {G : Type*} [Group G] [Finite G] {\u03b1 : Type*} [PartialOrder \u03b1] {g : G} {a : \u03b1}\n    [MulAction G \u03b1] [CovariantClass G \u03b1 HSMul.hSMul LE.le] (h : g \u2022 a \u2264 a) : g \u2022 a = a := by\n  have key := smul_mono_right g (pow_smul_le h (Nat.card G - 1))\n  rw [smul_smul] at key\n  rw [\u2190 _root_.pow_succ'] at key\n  rw [Nat.sub_one_add_one_eq_of_pos Nat.card_pos] at key\n  rw [pow_card_eq_one'] at key\n  rw [one_smul] at key\n  exact le_antisymm h key\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\n\u22a2 g \u2022 a = a"}, {"line": "have key := smul_mono_right g (pow_smul_le h (Nat.card G - 1))", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g \u2022 g ^ (Nat.card G - 1) \u2022 a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a\n---\ncase refine_1\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\n\u22a2 SMul G \u03b1"}, {"line": "rw [smul_smul] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : (g * g ^ (Nat.card G - 1)) \u2022 a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a"}, {"line": "rw [\u2190 _root_.pow_succ'] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a"}, {"line": "rw [Nat.sub_one_add_one_eq_of_pos Nat.card_pos] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ Nat.card G \u2022 a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Finite G"}, {"line": "rw [pow_card_eq_one'] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : 1 \u2022 a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Finite G"}, {"line": "rw [one_smul] at key", "tactic_state": "case refine_2\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : a \u2264 g \u2022 a\n\u22a2 g \u2022 a = a\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Finite G"}, {"line": "exact le_antisymm h key", "tactic_state": "G : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Nonempty G\n---\nG : Type u_6\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Finite G\n\u03b1 : Type u_7\ninst\u271d\u00b2 : PartialOrder \u03b1\ng : G\na : \u03b1\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : CovariantClass G \u03b1 HSMul.hSMul LE.le\nh : g \u2022 a \u2264 a\nkey : g ^ (Nat.card G - 1 + 1) \u2022 a \u2264 g \u2022 a\n\u22a2 Finite G"}]}
{"declaration": "theorem IsOfFinOrder.prod_mk : IsOfFinOrder a \u2192 IsOfFinOrder b \u2192 IsOfFinOrder (a, b) := by\n  simpa only [\u2190 orderOf_pos_iff,Prod.orderOf] using Nat.lcm_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OrderOfElement.lean", "context": {"open": ["Function Fintype Nat Pointwise Subgroup Submonoid", "scoped Finset", "QuotientGroup"], "variables": ["{G H A \u03b1 \u03b2 : Type*}", "[Monoid G] {a b x y : G} {n m : \u2115}", "(x)", "(n)", "{x}", "{x n} {p : \u2115} [hp : Fact p.Prime]", "{x n} (hx : IsOfFinOrder x)", "[LeftCancelMonoid G] {x y : G} {a : G} {m n : \u2115}", "[Group G] {x y : G} {i : \u2124}", "{H : Subgroup G}", "[CommMonoid G] {x y : G}", "[Monoid G] {x : G} {n : \u2115}", "[LeftCancelMonoid G]", "[Finite G] {x y : G} {n : \u2115}", "[Fintype G] {x : G}", "[Group G] {x y : G}", "[Finite G]", "[Fintype G] {x : G} {n : \u2115}", "[Semiring G] [LinearOrder G] [IsStrictOrderedRing G] {a : G}", "[Ring G] [LinearOrder G] [IsStrictOrderedRing G] {a x : G}", "[Monoid \u03b1] [Monoid \u03b2] {x : \u03b1 \u00d7 \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : Monoid \u03b1\ninst\u271d : Monoid \u03b2\na : \u03b1\nb : \u03b2\n\u22a2 IsOfFinOrder a \u2192 IsOfFinOrder b \u2192 IsOfFinOrder (a, b)"}, {"line": "simpa only [\u2190 orderOf_pos_iff,Prod.orderOf] using Nat.lcm_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_range_of (rels : Set (FreeGroup \u03b1)) :\n    Subgroup.closure (Set.range (PresentedGroup.of : \u03b1 \u2192 PresentedGroup rels)) = \u22a4 := by\n  have : (PresentedGroup.of : \u03b1 \u2192 PresentedGroup rels) = QuotientGroup.mk' _ \u2218 FreeGroup.of := rfl\n  rw [this]\n  rw [Set.range_comp]\n  rw [\u2190 MonoidHom.map_closure (QuotientGroup.mk' _)]\n  rw [FreeGroup.closure_range_of]\n  rw [\u2190 MonoidHom.range_eq_map]\n  exact MonoidHom.range_eq_top.2 (QuotientGroup.mk'_surjective _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PresentedGroup.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\n\u22a2 Subgroup.closure (Set.range PresentedGroup.of) = \u22a4"}, {"line": "have : (PresentedGroup.of : \u03b1 \u2192 PresentedGroup rels) = QuotientGroup.mk' _ \u2218 FreeGroup.of := rfl", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 Subgroup.closure (Set.range PresentedGroup.of) = \u22a4"}, {"line": "rw [this]", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 Subgroup.closure (Set.range (\u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of)) = \u22a4"}, {"line": "rw [Set.range_comp]", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 Subgroup.closure (\u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) '' Set.range FreeGroup.of) = \u22a4"}, {"line": "rw [\u2190 MonoidHom.map_closure (QuotientGroup.mk' _)]", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 Subgroup.map (QuotientGroup.mk' (Subgroup.normalClosure rels)) (Subgroup.closure (Set.range FreeGroup.of)) = \u22a4"}, {"line": "rw [FreeGroup.closure_range_of]", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 Subgroup.map (QuotientGroup.mk' (Subgroup.normalClosure rels)) \u22a4 = \u22a4"}, {"line": "rw [\u2190 MonoidHom.range_eq_map]", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nthis : PresentedGroup.of = \u21d1(QuotientGroup.mk' (Subgroup.normalClosure rels)) \u2218 FreeGroup.of\n\u22a2 (QuotientGroup.mk' (Subgroup.normalClosure rels)).range = \u22a4"}, {"line": "exact MonoidHom.range_eq_top.2 (QuotientGroup.mk'_surjective _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem generated_by (rels : Set (FreeGroup \u03b1)) (H : Subgroup (PresentedGroup rels))\n    (h : \u2200 j : \u03b1, PresentedGroup.of j \u2208 H) (x : PresentedGroup rels) : x \u2208 H := by\n  induction' x with z\n  induction z\n  \u00b7 exact one_mem H\n  \u00b7 exact h _\n  \u00b7 exact (Subgroup.inv_mem_iff H).mpr (by assumption)\n  rename_i h1 h2\n  change QuotientGroup.mk _ \u2208 H.carrier\n  rw [QuotientGroup.mk_mul]\n  exact Subgroup.mul_mem _ h1 h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PresentedGroup.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx : PresentedGroup rels\n\u22a2 x \u2208 H"}, {"line": "induction' x with z", "tactic_state": "case H\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nz : FreeGroup \u03b1\n\u22a2 (PresentedGroup.mk rels) z \u2208 H"}, {"line": "induction z", "tactic_state": "case H.C1\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\n\u22a2 (PresentedGroup.mk rels) 1 \u2208 H\n---\ncase H.Cp\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d : \u03b1\n\u22a2 (PresentedGroup.mk rels) (pure x\u271d) \u2208 H\n---\ncase H.Ci\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d : \u03b1\na\u271d : (PresentedGroup.mk rels) (pure x\u271d) \u2208 H\n\u22a2 (PresentedGroup.mk rels) (pure x\u271d)\u207b\u00b9 \u2208 H\n---\ncase H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\na\u271d\u00b9 : (PresentedGroup.mk rels) x\u271d \u2208 H\na\u271d : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 (PresentedGroup.mk rels) (x\u271d * y\u271d) \u2208 H"}, {"line": "\u00b7 exact one_mem H", "tactic_state": "case H.Cp\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d : \u03b1\n\u22a2 (PresentedGroup.mk rels) (pure x\u271d) \u2208 H\n---\ncase H.Ci\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d : \u03b1\na\u271d : (PresentedGroup.mk rels) (pure x\u271d) \u2208 H\n\u22a2 (PresentedGroup.mk rels) (pure x\u271d)\u207b\u00b9 \u2208 H\n---\ncase H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\na\u271d\u00b9 : (PresentedGroup.mk rels) x\u271d \u2208 H\na\u271d : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 (PresentedGroup.mk rels) (x\u271d * y\u271d) \u2208 H"}, {"line": "\u00b7 exact h _", "tactic_state": "case H.Ci\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d : \u03b1\na\u271d : (PresentedGroup.mk rels) (pure x\u271d) \u2208 H\n\u22a2 (PresentedGroup.mk rels) (pure x\u271d)\u207b\u00b9 \u2208 H\n---\ncase H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\na\u271d\u00b9 : (PresentedGroup.mk rels) x\u271d \u2208 H\na\u271d : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 (PresentedGroup.mk rels) (x\u271d * y\u271d) \u2208 H"}, {"line": "\u00b7 exact (Subgroup.inv_mem_iff H).mpr (by assumption)", "tactic_state": "case H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\na\u271d\u00b9 : (PresentedGroup.mk rels) x\u271d \u2208 H\na\u271d : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 (PresentedGroup.mk rels) (x\u271d * y\u271d) \u2208 H"}, {"line": "rename_i h1 h2", "tactic_state": "case H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\nh1 : (PresentedGroup.mk rels) x\u271d \u2208 H\nh2 : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 (PresentedGroup.mk rels) (x\u271d * y\u271d) \u2208 H"}, {"line": "change QuotientGroup.mk _ \u2208 H.carrier", "tactic_state": "case H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\nh1 : (PresentedGroup.mk rels) x\u271d \u2208 H\nh2 : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 \u2191(x\u271d * y\u271d) \u2208 H.carrier"}, {"line": "rw [QuotientGroup.mk_mul]", "tactic_state": "case H.Cm\n\u03b1 : Type u_1\nrels : Set (FreeGroup \u03b1)\nH : Subgroup (PresentedGroup rels)\nh : \u2200 (j : \u03b1), PresentedGroup.of j \u2208 H\nx\u271d y\u271d : FreeGroup \u03b1\nh1 : (PresentedGroup.mk rels) x\u271d \u2208 H\nh2 : (PresentedGroup.mk rels) y\u271d \u2208 H\n\u22a2 \u2191x\u271d * \u2191y\u271d \u2208 H.carrier"}, {"line": "exact Subgroup.mul_mem _ h1 h2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofCoprodI_of (i : \u03b9) (g : G i) :\n    (ofCoprodI (CoprodI.of g) : PushoutI \u03c6) = of i g := by\n  simp [ofCoprodI]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PushoutI.lean", "context": {"open": ["CoprodI Subgroup Coprod Function List"], "variables": ["{\u03b9 : Type*} {G : \u03b9 \u2192 Type*} {H : Type*} {K : Type*} [Monoid K]", "[\u2200 i, Monoid (G i)] [Monoid H] {\u03c6 : \u2200 i, H \u2192* G i}", "(\u03c6) in", "(\u03c6) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\ninst\u271d : (i : \u03b9) \u2192 Monoid (G i)\nx\u271d\u00b2 : Sort u_5\nPushoutI : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_6\nofCoprodI : x\u271d\u00b9\nx\u271d : Sort u_7\nof : x\u271d\ni : \u03b9\ng : G i\n\u22a2 sorry = sorry"}, {"line": "simp [ofCoprodI]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_empty : (empty : NormalWord d).prod = 1 := by\n  simp [prod, empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PushoutI.lean", "context": {"open": ["CoprodI Subgroup Coprod Function List", "Subgroup.IsComplement"], "variables": ["{\u03b9 : Type*} {G : \u03b9 \u2192 Type*} {H : Type*} {K : Type*} [Monoid K]", "[\u2200 i, Monoid (G i)] [Monoid H] {\u03c6 : \u2200 i, H \u2192* G i}", "(\u03c6) in", "(\u03c6) in", "[\u2200 i, Group (G i)] [Group H] {\u03c6 : \u2200 i, H \u2192* G i}", "(\u03c6)", "{\u03c6}", "{d : Transversal \u03c6}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Transversal : ?m.5680\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\nH : Type u_3\nK : Type u_4\ninst\u271d\u00b2 : Monoid K\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (G i)\ninst\u271d : Monoid H\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : sorry\nx\u271d : Sort u_5\nNormalWord : x\u271d\nempty : sorry\n\u22a2 sorry = 1"}, {"line": "simp [prod, empty]", "tactic_state": "Transversal : ?m.5680\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_2\nH : Type u_3\nK : Type u_4\ninst\u271d\u00b2 : Monoid K\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Monoid (G i)\ninst\u271d : Monoid H\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : sorry\nx\u271d : Sort u_5\nNormalWord : x\u271d\nempty : sorry\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem prod_injective {\u03b9 : Type*} {G : \u03b9 \u2192 Type*} [(i : \u03b9) \u2192 Group (G i)] {\u03c6 : (i : \u03b9) \u2192 H \u2192* G i}\n    {d : Transversal \u03c6} : Function.Injective (prod : NormalWord d \u2192 PushoutI \u03c6) := by\n  letI := Classical.decEq \u03b9\n  letI := fun i => Classical.decEq (G i)\n  classical exact equiv.symm.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/PushoutI.lean", "context": {"open": ["CoprodI Subgroup Coprod Function List", "Subgroup.IsComplement"], "variables": ["{\u03b9 : Type*} {G : \u03b9 \u2192 Type*} {H : Type*} {K : Type*} [Monoid K]", "[\u2200 i, Monoid (G i)] [Monoid H] {\u03c6 : \u2200 i, H \u2192* G i}", "(\u03c6) in", "(\u03c6) in", "[\u2200 i, Group (G i)] [Group H] {\u03c6 : \u2200 i, H \u2192* G i}", "(\u03c6)", "{\u03c6}", "{d : Transversal \u03c6}", "[DecidableEq \u03b9] [\u2200 i, DecidableEq (G i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Transversal : ?m.7350\n\u03b9\u271d : Type u_1\nG\u271d : \u03b9\u271d \u2192 Type u_2\nH\u271d : Type u_3\nK : Type u_4\ninst\u271d\u2076 : Monoid K\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 Monoid (G\u271d i)\ninst\u271d\u2074 : Monoid H\u271d\n\u03c6\u271d : (i : \u03b9\u271d) \u2192 H\u271d \u2192* G\u271d i\nd\u271d : sorry\ninst\u271d\u00b3 : DecidableEq \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 DecidableEq (G\u271d i)\nH : Type u_3\ninst\u271d\u00b9 : Monoid H\nx\u271d\u00b9 : Sort u_7\nNormalWord : x\u271d\u00b9\nx\u271d : Sort u_8\nPushoutI : x\u271d\nprod : sorry \u2192 sorry\n\u03b9 : Type u_5\nG : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 Group (G i)\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : sorry\n\u22a2 Function.Injective prod"}, {"line": "letI := Classical.decEq \u03b9", "tactic_state": "Transversal : ?m.7350\n\u03b9\u271d : Type u_1\nG\u271d : \u03b9\u271d \u2192 Type u_2\nH\u271d : Type u_3\nK : Type u_4\ninst\u271d\u2076 : Monoid K\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 Monoid (G\u271d i)\ninst\u271d\u2074 : Monoid H\u271d\n\u03c6\u271d : (i : \u03b9\u271d) \u2192 H\u271d \u2192* G\u271d i\nd\u271d : sorry\ninst\u271d\u00b3 : DecidableEq \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 DecidableEq (G\u271d i)\nH : Type u_3\ninst\u271d\u00b9 : Monoid H\nx\u271d\u00b9 : Sort u_7\nNormalWord : x\u271d\u00b9\nx\u271d : Sort u_8\nPushoutI : x\u271d\nprod : sorry \u2192 sorry\n\u03b9 : Type u_5\nG : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 Group (G i)\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : sorry\nthis : DecidableEq \u03b9 := Classical.decEq \u03b9\n\u22a2 Function.Injective prod"}, {"line": "letI := fun i => Classical.decEq (G i)", "tactic_state": "Transversal : ?m.7350\n\u03b9\u271d : Type u_1\nG\u271d : \u03b9\u271d \u2192 Type u_2\nH\u271d : Type u_3\nK : Type u_4\ninst\u271d\u2076 : Monoid K\ninst\u271d\u2075 : (i : \u03b9\u271d) \u2192 Monoid (G\u271d i)\ninst\u271d\u2074 : Monoid H\u271d\n\u03c6\u271d : (i : \u03b9\u271d) \u2192 H\u271d \u2192* G\u271d i\nd\u271d : sorry\ninst\u271d\u00b3 : DecidableEq \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 DecidableEq (G\u271d i)\nH : Type u_3\ninst\u271d\u00b9 : Monoid H\nx\u271d\u00b9 : Sort u_7\nNormalWord : x\u271d\u00b9\nx\u271d : Sort u_8\nPushoutI : x\u271d\nprod : sorry \u2192 sorry\n\u03b9 : Type u_5\nG : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 Group (G i)\n\u03c6 : (i : \u03b9) \u2192 H \u2192* G i\nd : sorry\nthis\u271d : DecidableEq \u03b9 := Classical.decEq \u03b9\nthis : (i : \u03b9) \u2192 DecidableEq (G i) := fun i => Classical.decEq (G i)\n\u22a2 Function.Injective prod"}, {"line": "classical exact equiv.symm.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_inl_mul_inr (g : G) (n : N) : (\u27e8n, g\u27e9 : N \u22ca[\u03c6] G) = inl n * inr g := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\ng : G\nn : N\n\u22a2 { left := n, right := g } = sorry * sorry"}, {"line": "ext <;> simp", "tactic_state": "case left\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\ng : G\nn : N\n\u22a2 n = (sorry ()).left * (\u03c6 (sorry ()).right) (sorry ()).left\n---\ncase right\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\ng : G\nn : N\n\u22a2 g = (sorry ()).right * (sorry ()).right"}]}
{"declaration": "theorem inl_left_mul_inr_right (x : N \u22ca[\u03c6] G) : inl x.left * inr x.right = x := by ext <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\nx : N \u22ca[\u03c6] G\n\u22a2 sorry * sorry = x"}, {"line": "ext <;> simp", "tactic_state": "case left\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\nx : N \u22ca[\u03c6] G\n\u22a2 (sorry ()).left * (\u03c6 (sorry ()).right) (sorry ()).left = x.left\n---\ncase right\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b9 : Group N\ninst\u271d : Group G\n\u03c6 : G \u2192* MulAut N\nx\u271d\u00b9 : Sort u_4\ninl : x\u271d\u00b9\nx\u271d : Sort u_5\ninr : x\u271d\nx : N \u22ca[\u03c6] G\n\u22a2 (sorry ()).right * (sorry ()).right = x.right"}]}
{"declaration": "theorem rightHom_inl (n : N) : rightHom (inl n : N \u22ca[\u03c6] G) = 1 := by simp [rightHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\ninst\u271d : Group N\nx\u271d : Sort u_4\nrightHom : x\u271d\nn : N\n\u22a2 sorry = 1"}, {"line": "simp [rightHom]", "tactic_state": "N : Type u_1\ninst\u271d : Group N\nx\u271d : Sort u_4\nrightHom : x\u271d\nn : N\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem rightHom_inr (g : G) : rightHom (inr g : N \u22ca[\u03c6] G) = g := by simp [rightHom]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nx\u271d : Sort u_4\nrightHom : x\u271d\ng : G\n\u22a2 sorry = g"}, {"line": "simp [rightHom]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nx\u271d : Sort u_4\nrightHom : x\u271d\ng : G\n\u22a2 sorry () = g"}]}
{"declaration": "theorem lift_inl (n : N) : lift fn fg h (inl n) = fn n := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}", "(fn : N \u2192* H) (fg : G \u2192* H)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\nH : Type u_3\ninst\u271d\u00b9 : Group N\ninst\u271d : Group H\nfn : N \u2192* H\nx\u271d : Sort u_4\nlift : x\u271d\nn : N\n\u22a2 sorry = fn n"}, {"line": "simp [lift]", "tactic_state": "N : Type u_1\nH : Type u_3\ninst\u271d\u00b9 : Group N\ninst\u271d : Group H\nfn : N \u2192* H\nx\u271d : Sort u_4\nlift : x\u271d\nn : N\n\u22a2 sorry () = fn n"}]}
{"declaration": "theorem lift_inr (g : G) : lift fn fg h (inr g) = fg g := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}", "(fn : N \u2192* H) (fg : G \u2192* H)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\nH : Type u_3\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\nfg : G \u2192* H\nx\u271d : Sort u_4\nlift : x\u271d\ng : G\n\u22a2 sorry = fg g"}, {"line": "simp [lift]", "tactic_state": "G : Type u_2\nH : Type u_3\ninst\u271d\u00b9 : Group G\ninst\u271d : Group H\nfg : G \u2192* H\nx\u271d : Sort u_4\nlift : x\u271d\ng : G\n\u22a2 sorry () = fg g"}]}
{"declaration": "theorem map_inl (n : N\u2081) : map fn fg h (inl n) = inl (fn n) := by simp [map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}", "(fn : N \u2192* H) (fg : G \u2192* H)", "{N\u2081 G\u2081 N\u2082 G\u2082 : Type*} [Group N\u2081] [Group G\u2081] [Group N\u2082] [Group G\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N\u2081 : Type u_4\ninst\u271d : Group N\u2081\nx\u271d : Sort u_8\ninl : x\u271d\nn : N\u2081\n\u22a2 sorry = sorry"}, {"line": "simp [map]", "tactic_state": "N\u2081 : Type u_4\ninst\u271d : Group N\u2081\nx\u271d : Sort u_8\ninl : x\u271d\nn : N\u2081\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem map_inr (g : G\u2081) : map fn fg h (inr g) = inr (fg g) := by simp [map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SemidirectProduct.lean", "context": {"open": ["Subgroup"], "variables": ["(N : Type*) (G : Type*) {H : Type*} [Group N] [Group G] [Group H]", "{N G}", "{\u03c6 : G \u2192* MulAut N}", "(fn : N \u2192* H) (fg : G \u2192* H)", "{N\u2081 G\u2081 N\u2082 G\u2082 : Type*} [Group N\u2081] [Group G\u2081] [Group N\u2082] [Group G\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G\u2081 : Type u_5\ninst\u271d : Group G\u2081\nx\u271d : Sort u_8\ninr : x\u271d\ng : G\u2081\n\u22a2 sorry = sorry"}, {"line": "simp [map]", "tactic_state": "G\u2081 : Type u_5\ninst\u271d : Group G\u2081\nx\u271d : Sort u_8\ninr : x\u271d\ng : G\u2081\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem isSolvable_of_comm {G : Type*} [hG : Group G] (h : \u2200 a b : G, a * b = b * a) :\n    IsSolvable G := by\n  letI hG' : CommGroup G := { hG with mul_comm := h }\n  cases hG\n  exact CommGroup.isSolvable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Solvable.lean", "context": {"open": ["Subgroup"], "variables": ["{G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'}", "(G)", "(f) in", "(G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nhG : Group G\nh : \u2200 (a b : G), a * b = b * a\n\u22a2 IsSolvable G"}, {"line": "letI hG' : CommGroup G := { hG with mul_comm := h }", "tactic_state": "G : Type u_3\nhG : Group G\nh : \u2200 (a b : G), a * b = b * a\nhG' : CommGroup G := { toGroup := hG, mul_comm := h }\n\u22a2 IsSolvable G"}, {"line": "cases hG", "tactic_state": "case mk\nG : Type u_3\ntoDivInvMonoid\u271d : DivInvMonoid G\ninv_mul_cancel\u271d : \u2200 (a : G), a\u207b\u00b9 * a = 1\nh : \u2200 (a b : G), a * b = b * a\nhG' : CommGroup G := { toDivInvMonoid := toDivInvMonoid\u271d, inv_mul_cancel := inv_mul_cancel\u271d, mul_comm := h }\n\u22a2 IsSolvable G"}, {"line": "exact CommGroup.isSolvable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSolvable.commutator_lt_top_of_nontrivial [hG : IsSolvable G] [Nontrivial G] :\n    commutator G < \u22a4 := by\n  rw [lt_top_iff_ne_top]\n  obtain \u27e8n, hn\u27e9 := hG\n  contrapose! hn\n  refine ne_of_eq_of_ne ?_ top_ne_bot\n  induction' n with n h\n  \u00b7 exact derivedSeries_zero G\n  \u00b7 rwa [derivedSeries_succ, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Solvable.lean", "context": {"open": ["Subgroup"], "variables": ["{G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'}", "(G)", "(f) in", "(G)", "{G}", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nhG : IsSolvable G\ninst\u271d : Nontrivial G\n\u22a2 _root_.commutator G < \u22a4"}, {"line": "rw [lt_top_iff_ne_top]", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : Group G\nhG : IsSolvable G\ninst\u271d : Nontrivial G\n\u22a2 _root_.commutator G \u2260 \u22a4"}, {"line": "obtain \u27e8n, hn\u27e9 := hG", "tactic_state": "case mk.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nn : \u2115\nhn : derivedSeries G n = \u22a5\n\u22a2 _root_.commutator G \u2260 \u22a4"}, {"line": "contrapose! hn", "tactic_state": "case mk.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nn : \u2115\nhn : _root_.commutator G = \u22a4\n\u22a2 derivedSeries G n \u2260 \u22a5"}, {"line": "refine ne_of_eq_of_ne ?_ top_ne_bot", "tactic_state": "case mk.intro\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nn : \u2115\nhn : _root_.commutator G = \u22a4\n\u22a2 derivedSeries G n = \u22a4"}, {"line": "induction' n with n h", "tactic_state": "case mk.intro.zero\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nhn : _root_.commutator G = \u22a4\n\u22a2 derivedSeries G 0 = \u22a4\n---\ncase mk.intro.succ\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nhn : _root_.commutator G = \u22a4\nn : \u2115\nh : derivedSeries G n = \u22a4\n\u22a2 derivedSeries G (n + 1) = \u22a4"}, {"line": "\u00b7 exact derivedSeries_zero G", "tactic_state": "case mk.intro.succ\nG : Type u_1\ninst\u271d\u00b9 : Group G\ninst\u271d : Nontrivial G\nhn : _root_.commutator G = \u22a4\nn : \u2115\nh : derivedSeries G n = \u22a4\n\u22a2 derivedSeries G (n + 1) = \u22a4"}, {"line": "\u00b7 rwa [derivedSeries_succ, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.not_solvable (X : Type*) (hX : 5 \u2264 Cardinal.mk X) :\n    \u00acIsSolvable (Equiv.Perm X) := by\n  intro h\n  have key : Nonempty (Fin 5 \u21aa X) := by\n    rwa [\u2190 Cardinal.lift_mk_le, Cardinal.mk_fin, Cardinal.lift_natCast, Cardinal.lift_id]\n  exact\n    Equiv.Perm.fin_5_not_solvable\n      (solvable_of_solvable_injective (Equiv.Perm.viaEmbeddingHom_injective (Nonempty.some key)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Solvable.lean", "context": {"open": ["Subgroup"], "variables": ["{G G' : Type*} [Group G] [Group G'] {f : G \u2192* G'}", "(G)", "(f) in", "(G)", "{G}", "(G) in", "[IsSimpleGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nhX : 5 \u2264 Cardinal.mk X\n\u22a2 \u00acIsSolvable (Perm X)"}, {"line": "intro h", "tactic_state": "X : Type u_3\nhX : 5 \u2264 Cardinal.mk X\nh : IsSolvable (Perm X)\n\u22a2 False"}, {"line": "have key : Nonempty (Fin 5 \u21aa X) := sorry", "tactic_state": "X : Type u_3\nhX : 5 \u2264 Cardinal.mk X\nh : IsSolvable (Perm X)\nkey : Nonempty (Fin 5 \u21aa X)\n\u22a2 False"}, {"line": "exact\n    Equiv.Perm.fin_5_not_solvable\n      (solvable_of_solvable_injective (Equiv.Perm.viaEmbeddingHom_injective (Nonempty.some key)))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subtype_injective {P Q : Sylow p G} {hP : P \u2264 N} {hQ : Q \u2264 N}\n    (h : P.subtype hP = Q.subtype hQ) : P = Q := by\n  rw [SetLike.ext_iff] at h \u22a2\n  exact fun g => \u27e8fun hg => (h \u27e8g, hP hg\u27e9).mp hg, fun hg => (h \u27e8g, hQ hg\u27e9).mpr hg\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Sylow.lean", "context": {"open": ["MulAction Subgroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(P : Sylow p G)", "{K : Type*} [Group K] (\u03d5 : K \u2192* G) {N : Subgroup G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d : Group G\nN : Subgroup G\nP Q : Sylow p G\nhP : \u2191P \u2264 N\nhQ : \u2191Q \u2264 N\nh : P.subtype hP = Q.subtype hQ\n\u22a2 P = Q"}, {"line": "rw [SetLike.ext_iff] at h \u22a2", "tactic_state": "p : \u2115\nG : Type u_1\ninst\u271d : Group G\nN : Subgroup G\nP Q : Sylow p G\nhP : \u2191P \u2264 N\nhQ : \u2191Q \u2264 N\nh : \u2200 (x : \u21a5N), x \u2208 P.subtype hP \u2194 x \u2208 Q.subtype hQ\n\u22a2 \u2200 (x : G), x \u2208 P \u2194 x \u2208 Q"}, {"line": "exact fun g => \u27e8fun hg => (h \u27e8g, hP hg\u27e9).mp hg, fun hg => (h \u27e8g, hQ hg\u27e9).mpr hg\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem QuotientGroup.card_preimage_mk (s : Subgroup G) (t : Set (G \u29f8 s)) :\n    Nat.card (QuotientGroup.mk \u207b\u00b9' t) = Nat.card s * Nat.card t := by\n  rw [\u2190 Nat.card_prod]\n  rw [Nat.card_congr (preimageMkEquivSubgroupProdSet _ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Sylow.lean", "context": {"open": ["MulAction Subgroup", "Pointwise", "Equiv Equiv.Perm Finset Function List QuotientGroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(P : Sylow p G)", "{K : Type*} [Group K] (\u03d5 : K \u2192* G) {N : Subgroup G}", "(p) (G)", "{p} {G}", "[Finite G] {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : Function.Surjective f)", "{G : Type u} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d : Group G\ns : Subgroup G\nt : Set (G \u29f8 s)\n\u22a2 Nat.card \u2191(mk \u207b\u00b9' t) = Nat.card \u21a5s * Nat.card \u2191t"}, {"line": "rw [\u2190 Nat.card_prod]", "tactic_state": "G : Type u\ninst\u271d : Group G\ns : Subgroup G\nt : Set (G \u29f8 s)\n\u22a2 Nat.card \u2191(mk \u207b\u00b9' t) = Nat.card (\u21a5s \u00d7 \u2191t)"}, {"line": "rw [Nat.card_congr (preimageMkEquivSubgroupProdSet _ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_card_of_dvd_card [Finite G] {p : \u2115} [Fact p.Prime] (P : Sylow p G)\n    (hdvd : p \u2223 Nat.card G) : p \u2223 Nat.card P := by\n  rw [\u2190 pow_one p] at hdvd\n  have key := P.pow_dvd_card_of_pow_dvd_card hdvd\n  rwa [pow_one] at key\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Sylow.lean", "context": {"open": ["MulAction Subgroup", "Pointwise", "Equiv Equiv.Perm Finset Function List QuotientGroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(P : Sylow p G)", "{K : Type*} [Group K] (\u03d5 : K \u2192* G) {N : Subgroup G}", "(p) (G)", "{p} {G}", "[Finite G] {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : Function.Surjective f)", "{G : Type u} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p \u2223 Nat.card G\n\u22a2 p \u2223 Nat.card \u21a5\u2191P"}, {"line": "rw [\u2190 pow_one p] at hdvd", "tactic_state": "G : Type u\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p ^ 1 \u2223 Nat.card G\n\u22a2 p \u2223 Nat.card \u21a5\u2191P"}, {"line": "have key := P.pow_dvd_card_of_pow_dvd_card hdvd", "tactic_state": "G : Type u\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : Finite G\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p ^ 1 \u2223 Nat.card G\nkey : p ^ 1 \u2223 Nat.card \u21a5\u2191P\n\u22a2 p \u2223 Nat.card \u21a5\u2191P"}, {"line": "rwa [pow_one] at key", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_bot_of_dvd_card [Finite G] {p : \u2115} [hp : Fact p.Prime] (P : Sylow p G)\n    (hdvd : p \u2223 Nat.card G) : (P : Subgroup G) \u2260 \u22a5 := by\n  refine fun h => hp.out.not_dvd_one ?_\n  have key : p \u2223 Nat.card P := P.dvd_card_of_dvd_card hdvd\n  rwa [h, card_bot] at key\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Sylow.lean", "context": {"open": ["MulAction Subgroup", "Pointwise", "Equiv Equiv.Perm Finset Function List QuotientGroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(P : Sylow p G)", "{K : Type*} [Group K] (\u03d5 : K \u2192* G) {N : Subgroup G}", "(p) (G)", "{p} {G}", "[Finite G] {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : Function.Surjective f)", "{G : Type u} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p \u2223 Nat.card G\n\u22a2 \u2191P \u2260 \u22a5"}, {"line": "refine fun h => hp.out.not_dvd_one ?_", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p \u2223 Nat.card G\nh : \u2191P = \u22a5\n\u22a2 p \u2223 1"}, {"line": "have key : p \u2223 Nat.card P := P.dvd_card_of_dvd_card hdvd", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nhdvd : p \u2223 Nat.card G\nh : \u2191P = \u22a5\nkey : p \u2223 Nat.card \u21a5\u2191P\n\u22a2 p \u2223 1"}, {"line": "rwa [h, card_bot] at key", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_eq_multiplicity [Finite G] {p : \u2115} [hp : Fact p.Prime] (P : Sylow p G) :\n    Nat.card P = p ^ Nat.factorization (Nat.card G) p := by\n  obtain \u27e8n, heq : Nat.card P = _\u27e9 := IsPGroup.iff_card.mp P.isPGroup'\n  refine Nat.dvd_antisymm ?_ (P.pow_dvd_card_of_pow_dvd_card (Nat.ordProj_dvd _ p))\n  rw [heq]\n  rw [\u2190 hp.out.pow_dvd_iff_dvd_ordProj (show Nat.card G \u2260 0 from Nat.card_pos.ne')]\n  rw [\u2190 heq]\n  exact P.1.card_subgroup_dvd_card\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Sylow.lean", "context": {"open": ["MulAction Subgroup", "Pointwise", "Equiv Equiv.Perm Finset Function List QuotientGroup"], "variables": ["(p : \u2115) (G : Type*) [Group G]", "{p} {G}", "(P : Sylow p G)", "{K : Type*} [Group K] (\u03d5 : K \u2192* G) {N : Subgroup G}", "(p) (G)", "{p} {G}", "[Finite G] {G' : Type*} [Group G'] {f : G \u2192* G'} (hf : Function.Surjective f)", "{G : Type u} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\n\u22a2 Nat.card \u21a5\u2191P = p ^ (Nat.card G).factorization p"}, {"line": "obtain \u27e8n, heq : Nat.card P = _\u27e9 := IsPGroup.iff_card.mp P.isPGroup'", "tactic_state": "case intro\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nat.card \u21a5\u2191P = p ^ (Nat.card G).factorization p"}, {"line": "refine Nat.dvd_antisymm ?_ (P.pow_dvd_card_of_pow_dvd_card (Nat.ordProj_dvd _ p))", "tactic_state": "case intro\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nat.card \u21a5\u2191P \u2223 p ^ (Nat.card G).factorization p"}, {"line": "rw [heq]", "tactic_state": "case intro\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 p ^ n \u2223 p ^ (Nat.card G).factorization p"}, {"line": "rw [\u2190 hp.out.pow_dvd_iff_dvd_ordProj (show Nat.card G \u2260 0 from Nat.card_pos.ne')]", "tactic_state": "case intro\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 p ^ n \u2223 Nat.card G\n---\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nonempty G\n---\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Finite G"}, {"line": "rw [\u2190 heq]", "tactic_state": "case intro\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nat.card \u21a5\u2191P \u2223 Nat.card G\n---\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nonempty G\n---\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Finite G"}, {"line": "exact P.1.card_subgroup_dvd_card", "tactic_state": "G : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Nonempty G\n---\nG : Type u\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nP : Sylow p G\nn : \u2115\nheq : Nat.card \u21a5\u2191P = p ^ n\n\u22a2 Finite G"}]}
{"declaration": "theorem not_isTorsionFree_iff : \u00acIsTorsionFree G \u2194 \u2203 g : G, g \u2260 1 \u2227 IsOfFinOrder g := by\n  simp_rw [IsTorsionFree, Ne, not_forall, Classical.not_not, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Torsion.lean", "context": {"open": ["Monoid", "CommMonoid (torsion)"], "variables": ["{G H : Type*}", "(G) [Monoid G]", "[Group G] {N : Subgroup G} [Group H]", "(R M : Type*) [AddCommMonoid M]", "(G) [CommMonoid G]", "{G}", "(G) (p : \u2115) [hp : Fact p.Prime]", "{G} {p}", "{G}", "(G) [CommGroup G]", "(p : \u2115) [hp : Fact p.Prime]", "{G} {p}", "(G) [Monoid G]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : CommGroup G\ninst\u271d : Monoid G\n\u22a2 \u00acIsTorsionFree G \u2194 \u2203 g, g \u2260 1 \u2227 IsOfFinOrder g"}, {"line": "simp_rw [IsTorsionFree, Ne, not_forall, Classical.not_not, exists_prop]", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Monoid G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : CommGroup G\ninst\u271d : Monoid G\n\u22a2 (\u2203 x, \u00acx = 1 \u2227 IsOfFinOrder x) \u2194 \u2203 g, \u00acg = 1 \u2227 IsOfFinOrder g"}]}
{"declaration": "lemma isTorsionFree_iff_torsion_eq_bot {G} [CommGroup G] :\n    IsTorsionFree G \u2194 CommGroup.torsion G = \u22a5 := by\n  rw [IsTorsionFree]\n  rw [eq_bot_iff]\n  rw [SetLike.le_def]\n  simp [not_imp_not, CommGroup.mem_torsion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Torsion.lean", "context": {"open": ["Monoid", "CommMonoid (torsion)"], "variables": ["{G H : Type*}", "(G) [Monoid G]", "[Group G] {N : Subgroup G} [Group H]", "(R M : Type*) [AddCommMonoid M]", "(G) [CommMonoid G]", "{G}", "(G) (p : \u2115) [hp : Fact p.Prime]", "{G} {p}", "{G}", "(G) [CommGroup G]", "(p : \u2115) [hp : Fact p.Prime]", "{G} {p}", "(G) [Monoid G]", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_5\ninst\u271d : CommGroup G\n\u22a2 IsTorsionFree G \u2194 CommGroup.torsion G = \u22a5"}, {"line": "rw [IsTorsionFree]", "tactic_state": "G : Type u_5\ninst\u271d : CommGroup G\n\u22a2 (\u2200 (g : G), g \u2260 1 \u2192 \u00acIsOfFinOrder g) \u2194 CommGroup.torsion G = \u22a5"}, {"line": "rw [eq_bot_iff]", "tactic_state": "G : Type u_5\ninst\u271d : CommGroup G\n\u22a2 (\u2200 (g : G), g \u2260 1 \u2192 \u00acIsOfFinOrder g) \u2194 CommGroup.torsion G \u2264 \u22a5"}, {"line": "rw [SetLike.le_def]", "tactic_state": "G : Type u_5\ninst\u271d : CommGroup G\n\u22a2 (\u2200 (g : G), g \u2260 1 \u2192 \u00acIsOfFinOrder g) \u2194 \u2200 \u2983x : G\u2984, x \u2208 CommGroup.torsion G \u2192 x \u2208 \u22a5"}, {"line": "simp [not_imp_not, CommGroup.mem_torsion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commutatorElement_eq_one_iff_mul_comm : \u2045g\u2081, g\u2082\u2046 = 1 \u2194 g\u2081 * g\u2082 = g\u2082 * g\u2081 := by\n  rw [commutatorElement_def]\n  rw [mul_inv_eq_one]\n  rw [mul_inv_eq_iff_eq_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Commutator/Basic.lean", "context": {"open": [], "variables": ["{G G' F : Type*} [Group G] [Group G'] [FunLike F G G'] [MonoidHomClass F G G']", "(f : F) {g\u2081 g\u2082 g\u2083 g : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\ng\u2081 g\u2082 : G\n\u22a2 \u2045g\u2081, g\u2082\u2046 = 1 \u2194 g\u2081 * g\u2082 = g\u2082 * g\u2081"}, {"line": "rw [commutatorElement_def]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\ng\u2081 g\u2082 : G\n\u22a2 g\u2081 * g\u2082 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9 = 1 \u2194 g\u2081 * g\u2082 = g\u2082 * g\u2081"}, {"line": "rw [mul_inv_eq_one]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\ng\u2081 g\u2082 : G\n\u22a2 g\u2081 * g\u2082 * g\u2081\u207b\u00b9 = g\u2082 \u2194 g\u2081 * g\u2082 = g\u2082 * g\u2081"}, {"line": "rw [mul_inv_eq_iff_eq_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_comap_conGen {M N : Type*} [Mul M] [Mul N] (f : M \u2192 N)\n    (H : \u2200 (x y : M), f (x * y) = f x * f y) (rel : N \u2192 N \u2192 Prop) :\n    conGen (fun x y \u21a6 rel (f x) (f y)) \u2264 Con.comap f H (conGen rel) := by\n  intro x y h\n  simp only [Con.comap_rel]\n  exact .rec (fun x y h \u21a6 .of (f x) (f y) h) (fun x \u21a6 .refl (f x))\n    (fun _ h \u21a6 .symm h) (fun _ _ h1 h2 \u21a6 h1.trans h2) (fun {w x y z} _ _ h1 h2 \u21a6\n    (congrArg (fun a \u21a6 conGen rel a (f (x * z))) (H w y)).mpr\n    (((congrArg (fun a \u21a6 conGen rel (f w * f y) a) (H x z))).mpr\n    (.mul h1 h2))) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Congruence/Basic.lean", "context": {"open": ["Function Setoid"], "variables": ["(M : Type*) {N : Type*} {P : Type*}", "{M}", "[Mul M] [Mul N] [Mul P] (c : Con M)", "{c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192 N\nH : \u2200 (x y : M), f (x * y) = f x * f y\nrel : N \u2192 N \u2192 Prop\n\u22a2 (conGen fun x y => rel (f x) (f y)) \u2264 Con.comap f H (conGen rel)"}, {"line": "intro x y h", "tactic_state": "M : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192 N\nH : \u2200 (x y : M), f (x * y) = f x * f y\nrel : N \u2192 N \u2192 Prop\nx y : M\nh : (conGen fun x y => rel (f x) (f y)) x y\n\u22a2 (Con.comap f H (conGen rel)) x y"}, {"line": "simp only [Con.comap_rel]", "tactic_state": "M : Type u_4\nN : Type u_5\ninst\u271d\u00b9 : Mul M\ninst\u271d : Mul N\nf : M \u2192 N\nH : \u2200 (x y : M), f (x * y) = f x * f y\nrel : N \u2192 N \u2192 Prop\nx y : M\nh : (conGen fun x y => rel (f x) (f y)) x y\n\u22a2 (conGen rel) (f x) (f y)"}, {"line": "exact .rec (fun x y h \u21a6 .of (f x) (f y) h) (fun x \u21a6 .refl (f x))\n    (fun _ h \u21a6 .symm h) (fun _ _ h1 h2 \u21a6 h1.trans h2) (fun {w x y z} _ _ h1 h2 \u21a6\n    (congrArg (fun a \u21a6 conGen rel a (f (x * z))) (H w y)).mpr\n    (((congrArg (fun a \u21a6 conGen rel (f w * f y) a) (H x z))).mpr\n    (.mul h1 h2))) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul {\u03b1 M : Type*} [MulOneClass M] [SMul \u03b1 M] [IsScalarTower \u03b1 M M] (c : Con M) (a : \u03b1)\n    {w x : M} (h : c w x) : c (a \u2022 w) (a \u2022 x) := by\n  simpa only [smul_one_mul] using c.mul (c.refl' (a \u2022 (1 : M) : M)) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Congruence/Basic.lean", "context": {"open": ["Function Setoid"], "variables": ["(M : Type*) {N : Type*} {P : Type*}", "{M}", "[Mul M] [Mul N] [Mul P] (c : Con M)", "{c}", "[MulOneClass M] [MulOneClass N] [MulOneClass P] (c : Con M)", "{c}", "(x y : M)", "{f : M \u2192* P}", "(c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\nM : Type u_5\ninst\u271d\u00b2 : MulOneClass M\ninst\u271d\u00b9 : SMul \u03b1 M\ninst\u271d : IsScalarTower \u03b1 M M\nc : Con M\na : \u03b1\nw x : M\nh : c w x\n\u22a2 c (a \u2022 w) (a \u2022 x)"}, {"line": "simpa only [smul_one_mul] using c.mul (c.refl' (a \u2022 (1 : M) : M)) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_sInf (S : Set (Con M)) :\n    \u21d1(sInf S) = sInf ((\u21d1) '' S) := by\n  ext\n  simp only [sInf_image]\n  simp only [iInf_apply]\n  simp only [iInf_Prop_eq]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Congruence/Defs.lean", "context": {"open": ["Function Setoid"], "variables": ["(M : Type*) {N : Type*} {P : Type*}", "{M}", "[Mul M] [Mul N] [Mul P] (c : Con M)", "{c}", "(c)", "{c}", "(c)", "{c}", "(c)", "{c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Mul M\nS : Set (Con M)\n\u22a2 \u21d1(sInf S) = sInf (DFunLike.coe '' S)"}, {"line": "ext", "tactic_state": "case h.h.a\nM : Type u_1\ninst\u271d : Mul M\nS : Set (Con M)\nx\u271d\u00b9 x\u271d : M\n\u22a2 (sInf S) x\u271d\u00b9 x\u271d \u2194 sInf (DFunLike.coe '' S) x\u271d\u00b9 x\u271d"}, {"line": "simp only [sInf_image]", "tactic_state": "case h.h.a\nM : Type u_1\ninst\u271d : Mul M\nS : Set (Con M)\nx\u271d\u00b9 x\u271d : M\n\u22a2 (sInf S) x\u271d\u00b9 x\u271d \u2194 (\u2a05 a \u2208 S, \u21d1a) x\u271d\u00b9 x\u271d"}, {"line": "simp only [iInf_apply]", "tactic_state": "case h.h.a\nM : Type u_1\ninst\u271d : Mul M\nS : Set (Con M)\nx\u271d\u00b9 x\u271d : M\n\u22a2 (sInf S) x\u271d\u00b9 x\u271d \u2194 \u2a05 i \u2208 S, i x\u271d\u00b9 x\u271d"}, {"line": "simp only [iInf_Prop_eq]", "tactic_state": "case h.h.a\nM : Type u_1\ninst\u271d : Mul M\nS : Set (Con M)\nx\u271d\u00b9 x\u271d : M\n\u22a2 (sInf S) x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 S, i x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conGen_idem (r : M \u2192 M \u2192 Prop) : conGen (conGen r) = conGen r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Congruence/Defs.lean", "context": {"open": ["Function Setoid"], "variables": ["(M : Type*) {N : Type*} {P : Type*}", "{M}", "[Mul M] [Mul N] [Mul P] (c : Con M)", "{c}", "(c)", "{c}", "(c)", "{c}", "(c)", "{c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d : Mul M\nr : M \u2192 M \u2192 Prop\n\u22a2 conGen \u21d1(conGen r) = conGen r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem leftCoset_assoc (s : Set \u03b1) (a b : \u03b1) : a \u2022 (b \u2022 s) = (a * b) \u2022 s := by\n  simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coset/Basic.lean", "context": {"open": ["Function MulOpposite Set", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1]", "[Semigroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 a \u2022 b \u2022 s = (a * b) \u2022 s"}, {"line": "simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 (fun a_1 => a * (b * a_1)) '' s = (fun a_1 => a * b * a_1) '' s"}]}
{"declaration": "theorem rightCoset_assoc (s : Set \u03b1) (a b : \u03b1) : op b \u2022 op a \u2022 s = op (a * b) \u2022 s := by\n  simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coset/Basic.lean", "context": {"open": ["Function MulOpposite Set", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1]", "[Semigroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 op b \u2022 op a \u2022 s = op (a * b) \u2022 s"}, {"line": "simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 (fun a_1 => a_1 * a * b) '' s = (fun a_1 => a_1 * (a * b)) '' s"}]}
{"declaration": "theorem leftCoset_rightCoset (s : Set \u03b1) (a b : \u03b1) : op b \u2022 a \u2022 s = a \u2022 (op b \u2022 s) := by\n  simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coset/Basic.lean", "context": {"open": ["Function MulOpposite Set", "scoped Pointwise"], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1]", "[Semigroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 op b \u2022 a \u2022 s = a \u2022 op b \u2022 s"}, {"line": "simp [\u2190 image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : Semigroup \u03b1\ns : Set \u03b1\na b : \u03b1\n\u22a2 (fun a_1 => a * a_1 * b) '' s = (fun a_1 => a * (a_1 * b)) '' s"}]}
{"declaration": "theorem card_dvd_of_injective (f : \u03b1 \u2192* H) (hf : Function.Injective f) :\n    Nat.card \u03b1 \u2223 Nat.card H := by\n  classical calc\n      Nat.card \u03b1 = Nat.card (f.range : Subgroup H) := Nat.card_congr (Equiv.ofInjective f hf)\n      _ \u2223 Nat.card H := card_subgroup_dvd_card _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coset/Card.lean", "context": {"open": ["scoped Pointwise"], "variables": ["{\u03b1 : Type*} [Group \u03b1]", "{H : Type*} [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\nH : Type u_2\ninst\u271d : Group H\nf : \u03b1 \u2192* H\nhf : Function.Injective \u21d1f\n\u22a2 Nat.card \u03b1 \u2223 Nat.card H"}, {"line": "classical calc\n      Nat.card \u03b1 = Nat.card (f.range : Subgroup H) := Nat.card_congr (Equiv.ofInjective f hf)\n      _ \u2223 Nat.card H := card_subgroup_dvd_card _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem simple_mul_simple_cancel_right {w : W} (i : B) : w * s i * s i = w := by\n  simp [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Basic.lean", "context": {"open": ["Function Set List", "CoxeterMatrix"], "variables": ["{B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')", "{B : Type*} (M : CoxeterMatrix B)", "{B B' : Type*} (e : B \u2243 B')", "{W H : Type*} [Group W] [Group H]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_4\nW : Type u_6\ninst\u271d : Group W\nx\u271d : Sort u_8\ns : x\u271d\nw : W\ni : B\n\u22a2 w * sorry * sorry = w"}, {"line": "simp [mul_assoc]", "tactic_state": "B : Type u_4\nW : Type u_6\ninst\u271d : Group W\nx\u271d : Sort u_8\ns : x\u271d\nw : W\ni : B\n\u22a2 w * (sorry () * sorry ()) = w"}]}
{"declaration": "theorem simple_mul_simple_cancel_left {w : W} (i : B) : s i * (s i * w) = w := by\n  simp [\u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Basic.lean", "context": {"open": ["Function Set List", "CoxeterMatrix"], "variables": ["{B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')", "{B : Type*} (M : CoxeterMatrix B)", "{B B' : Type*} (e : B \u2243 B')", "{W H : Type*} [Group W] [Group H]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_4\nW : Type u_6\ninst\u271d : Group W\nx\u271d : Sort u_8\ns : x\u271d\nw : W\ni : B\n\u22a2 sorry * (sorry * w) = w"}, {"line": "simp [\u2190 mul_assoc]", "tactic_state": "B : Type u_4\nW : Type u_6\ninst\u271d : Group W\nx\u271d : Sort u_8\ns : x\u271d\nw : W\ni : B\n\u22a2 sorry () * sorry () * w = w"}]}
{"declaration": "private theorem relations_liftable {G : Type*} [Group G] {f : B \u2192 G} (hf : IsLiftable M f)\n    (r : FreeGroup B) (hr : r \u2208 M.relationsSet) : (FreeGroup.lift f) r = 1 := by\n  rcases hr with \u27e8\u27e8i, i'\u27e9, rfl\u27e9\n  rw [uncurry]\n  rw [relation]\n  rw [map_pow]\n  rw [map_mul]\n  rw [FreeGroup.lift.of]\n  rw [FreeGroup.lift.of]\n  exact hf i i'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Basic.lean", "context": {"open": ["Function Set List", "CoxeterMatrix"], "variables": ["{B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')", "{B : Type*} (M : CoxeterMatrix B)", "{B B' : Type*} (e : B \u2243 B')", "{W H : Type*} [Group W] [Group H]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\nr : FreeGroup B\nhr : r \u2208 M.relationsSet\n\u22a2 (FreeGroup.lift f) r = 1"}, {"line": "rcases hr with \u27e8\u27e8i, i'\u27e9, rfl\u27e9", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (FreeGroup.lift f) (uncurry M.relation (i, i')) = 1"}, {"line": "rw [uncurry]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (FreeGroup.lift f) (M.relation (i, i').1 (i, i').2) = 1"}, {"line": "rw [relation]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (FreeGroup.lift f) ((FreeGroup.of (i, i').1 * FreeGroup.of (i, i').2) ^ M.M (i, i').1 (i, i').2) = 1"}, {"line": "rw [map_pow]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (FreeGroup.lift f) (FreeGroup.of (i, i').1 * FreeGroup.of (i, i').2) ^ M.M (i, i').1 (i, i').2 = 1"}, {"line": "rw [map_mul]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 ((FreeGroup.lift f) (FreeGroup.of (i, i').1) * (FreeGroup.lift f) (FreeGroup.of (i, i').2)) ^\n      M.M (i, i').1 (i, i').2 =\n    1"}, {"line": "rw [FreeGroup.lift.of]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (f (i, i').1 * (FreeGroup.lift f) (FreeGroup.of (i, i').2)) ^ M.M (i, i').1 (i, i').2 = 1"}, {"line": "rw [FreeGroup.lift.of]", "tactic_state": "case intro.mk\nB : Type u_4\nM : CoxeterMatrix B\nG : Type u_8\ninst\u271d : Group G\nf : B \u2192 G\nhf : M.IsLiftable f\ni i' : B\n\u22a2 (f (i, i').1 * f (i, i').2) ^ M.M (i, i').1 (i, i').2 = 1"}, {"line": "exact hf i i'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_alternatingWord (i i' : B) (m : \u2115) :\n    List.length (alternatingWord i i' m) = m := by\n  induction' m with m ih generalizing i i'\n  \u00b7 dsimp [alternatingWord]\n  \u00b7 simpa [alternatingWord] using ih i' i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Basic.lean", "context": {"open": ["Function Set List", "CoxeterMatrix"], "variables": ["{B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')", "{B : Type*} (M : CoxeterMatrix B)", "{B B' : Type*} (e : B \u2243 B')", "{W H : Type*} [Group W] [Group H]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_4\nx\u271d : Sort u_8\nalternatingWord : x\u271d\ni i' : B\nm : \u2115\n\u22a2 sorry.length = m"}, {"line": "induction' m with m ih generalizing i i'", "tactic_state": "case zero\nB : Type u_4\nx\u271d : Sort u_8\nalternatingWord : x\u271d\ni i' : B\n\u22a2 sorry.length = 0\n---\ncase succ\nB : Type u_4\nx\u271d : Sort u_8\nalternatingWord : x\u271d\nm : \u2115\nih : \u2200 (i i' : B), sorry.length = m\ni i' : B\n\u22a2 sorry.length = m + 1"}, {"line": "\u00b7 dsimp [alternatingWord]", "tactic_state": "case succ\nB : Type u_4\nx\u271d : Sort u_8\nalternatingWord : x\u271d\nm : \u2115\nih : \u2200 (i i' : B), sorry.length = m\ni i' : B\n\u22a2 sorry.length = m + 1"}, {"line": "\u00b7 simpa [alternatingWord] using ih i' i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma listTake_alternatingWord (i j : B) (p k : \u2115) (h : k < 2 * p) :\n    List.take k (alternatingWord i j (2 * p)) =\n    if Even k then alternatingWord i j k else alternatingWord j i k := by\n  induction k with\n    | zero =>\n      simp only [take_zero]\n      simp only [Even.zero]\n      simp only [\u2193reduceIte]\n      simp only [alternatingWord]\n    | succ k h' =>\n      have hk : k < 2 * p := by omega\n      apply h' at hk\n      by_cases h_even : Even k\n      \u00b7 simp only [h_even, \u2193reduceIte] at hk\n        simp only [Nat.not_even_iff_odd.mpr (Even.add_one h_even)]\n        simp only [\u2193reduceIte]\n        rw [\u2190 List.take_concat_get (by simp [h]; omega), alternatingWord_succ, \u2190 hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.even_add.mpr; simp [h_even] : Even (2 * p + k))]\n      \u00b7 simp only [h_even, \u2193reduceIte] at hk\n        simp only [(by simp at h_even; exact Odd.add_one h_even : Even (k + 1))]\n        simp only [\u2193reduceIte]\n        rw [\u2190 List.take_concat_get (by simp [h]; omega), alternatingWord_succ, hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.odd_add.mpr; simp [h_even] : Odd (2 * p + k))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Basic.lean", "context": {"open": ["Function Set List", "CoxeterMatrix"], "variables": ["{B B' : Type*} (M : CoxeterMatrix B) (e : B \u2243 B')", "{B : Type*} (M : CoxeterMatrix B)", "{B B' : Type*} (e : B \u2243 B')", "{W H : Type*} [Group W] [Group H]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_4\nx\u271d : Sort u_8\nalternatingWord : x\u271d\ni j : B\np k : \u2115\nh : k < 2 * p\n\u22a2 take k sorry = if Even k then sorry else sorry"}, {"line": "induction k with\n    | zero =>\n      simp only [take_zero]\n      simp only [Even.zero]\n      simp only [\u2193reduceIte]\n      simp only [alternatingWord]\n    | succ k h' =>\n      have hk : k < 2 * p := by omega\n      apply h' at hk\n      by_cases h_even : Even k\n      \u00b7 simp only [h_even, \u2193reduceIte] at hk\n        simp only [Nat.not_even_iff_odd.mpr (Even.add_one h_even)]\n        simp only [\u2193reduceIte]\n        rw [\u2190 List.take_concat_get (by simp [h]; omega), alternatingWord_succ, \u2190 hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.even_add.mpr; simp [h_even] : Even (2 * p + k))]\n      \u00b7 simp only [h_even, \u2193reduceIte] at hk\n        simp only [(by simp at h_even; exact Odd.add_one h_even : Even (k + 1))]\n        simp only [\u2193reduceIte]\n        rw [\u2190 List.take_concat_get (by simp [h]; omega), alternatingWord_succ, hk]\n        apply congr_arg\n        rw [getElem_alternatingWord i j (2*p) k (by omega)]\n        simp [(by apply Nat.odd_add.mpr; simp [h_even] : Odd (2 * p + k))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRightInversion_simple_iff_isRightDescent (w : W) (i : B) :\n    cs.IsRightInversion w (s i) \u2194 cs.IsRightDescent w i := by\n  simp [IsRightInversion, IsRightDescent, cs.isReflection_simple i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Inversion.lean", "context": {"open": ["List Matrix Function"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)", "{cs}", "{t : W} (ht : cs.IsReflection t)", "{cs}", "{t : W} (ht : cs.IsReflection t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_3\ns : x\u271d\nw : W\ni : B\n\u22a2 cs.IsRightInversion w sorry \u2194 cs.IsRightDescent w i"}, {"line": "simp [IsRightInversion, IsRightDescent, cs.isReflection_simple i]", "tactic_state": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_3\ns : x\u271d\nw : W\ni : B\n\u22a2 cs.IsRightInversion w (sorry ()) \u2194 cs.IsRightDescent w i"}]}
{"declaration": "theorem isLeftInversion_simple_iff_isLeftDescent (w : W) (i : B) :\n    cs.IsLeftInversion w (s i) \u2194 cs.IsLeftDescent w i := by\n  simp [IsLeftInversion, IsLeftDescent, cs.isReflection_simple i]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Inversion.lean", "context": {"open": ["List Matrix Function"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)", "{cs}", "{t : W} (ht : cs.IsReflection t)", "{cs}", "{t : W} (ht : cs.IsReflection t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_3\ns : x\u271d\nw : W\ni : B\n\u22a2 cs.IsLeftInversion w sorry \u2194 cs.IsLeftDescent w i"}, {"line": "simp [IsLeftInversion, IsLeftDescent, cs.isReflection_simple i]", "tactic_state": "B : Type u_1\nW : Type u_2\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_3\ns : x\u271d\nw : W\ni : B\n\u22a2 cs.IsLeftInversion w (sorry ()) \u2194 cs.IsLeftDescent w i"}]}
{"declaration": "theorem prod_rightInvSeq (\u03c9 : List B) : prod (ris \u03c9) = (\u03c0 \u03c9)\u207b\u00b9 := by\n  induction' \u03c9 with i \u03c9 ih\n  \u00b7 simp\n  \u00b7 simp [rightInvSeq, ih, wordProd_cons]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Inversion.lean", "context": {"open": ["List Matrix Function"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)", "{cs}", "{t : W} (ht : cs.IsReflection t)", "{cs}", "{t : W} (ht : cs.IsReflection t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nx\u271d\u00b9 : Sort u_3\nris : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03c0 : x\u271d\n\u03c9 : List B\n\u22a2 sorry.prod = sorry\u207b\u00b9"}, {"line": "induction' \u03c9 with i \u03c9 ih", "tactic_state": "case nil\nB : Type u_1\nx\u271d\u00b9 : Sort u_3\nris : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03c0 : x\u271d\n\u22a2 sorry.prod = sorry\u207b\u00b9\n---\ncase cons\nB : Type u_1\nx\u271d\u00b9 : Sort u_3\nris : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03c0 : x\u271d\ni : B\n\u03c9 : List B\nih : sorry.prod = sorry\u207b\u00b9\n\u22a2 sorry.prod = sorry\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case cons\nB : Type u_1\nx\u271d\u00b9 : Sort u_3\nris : x\u271d\u00b9\nx\u271d : Sort u_4\n\u03c0 : x\u271d\ni : B\n\u03c9 : List B\nih : sorry.prod = sorry\u207b\u00b9\n\u22a2 sorry.prod = sorry\u207b\u00b9"}, {"line": "\u00b7 simp [rightInvSeq, ih, wordProd_cons]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_mul_mod_two (w\u2081 w\u2082 : W) : \u2113 (w\u2081 * w\u2082) % 2 = (\u2113 w\u2081 + \u2113 w\u2082) % 2 := by\n  rw [\u2190 ZMod.natCast_eq_natCast_iff']\n  rw [Nat.cast_add]\n  simpa only [lengthParity_eq_ofAdd_length,ofAdd_add] using map_mul cs.lengthParity w\u2081 w\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Length.lean", "context": {"open": ["List Matrix Function", "scoped Classical in", "scoped Classical in"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "W : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw\u2081 w\u2082 : W\n\u22a2 sorry % 2 = (sorry + sorry) % 2"}, {"line": "rw [\u2190 ZMod.natCast_eq_natCast_iff']", "tactic_state": "W : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw\u2081 w\u2082 : W\n\u22a2 \u2191sorry = \u2191(sorry + sorry)"}, {"line": "rw [Nat.cast_add]", "tactic_state": "W : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw\u2081 w\u2082 : W\n\u22a2 \u2191sorry = \u2191sorry + \u2191sorry"}, {"line": "simpa only [lengthParity_eq_ofAdd_length,ofAdd_add] using map_mul cs.lengthParity w\u2081 w\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_mul_simple (w : W) (i : B) :\n    \u2113 (w * s i) = \u2113 w + 1 \u2228 \u2113 (w * s i) + 1 = \u2113 w := by\n  rcases Nat.lt_or_gt_of_ne (cs.length_mul_simple_ne w i) with lt | gt\n  \u00b7 -- lt : \u2113 (w * s i) < \u2113 w\n    right\n    have length_ge := cs.length_mul_ge_length_sub_length w (s i)\n    simp only [length_simple] at length_ge\n    simp only [tsub_le_iff_right] at length_ge\n    -- length_ge : \u2113 w \u2264 \u2113 (w * s i) + 1\n    omega\n  \u00b7 -- gt : \u2113 w < \u2113 (w * s i)\n    left\n    have length_le := cs.length_mul_le w (s i)\n    simp only [length_simple] at length_le\n    -- length_le : \u2113 (w * s i) \u2264 \u2113 w + 1\n    omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Length.lean", "context": {"open": ["List Matrix Function", "scoped Classical in", "scoped Classical in"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_3\nW : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw : W\ni : B\n\u22a2 sorry = sorry + 1 \u2228 sorry + 1 = sorry"}, {"line": "rcases Nat.lt_or_gt_of_ne (cs.length_mul_simple_ne w i) with lt | gt", "tactic_state": "case inl\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw : W\ni : B\nlt : ?m.6133 < ?m.6134\n\u22a2 sorry = sorry + 1 \u2228 sorry + 1 = sorry\n---\ncase inr\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw : W\ni : B\ngt : ?m.6133 > ?m.6134\n\u22a2 sorry = sorry + 1 \u2228 sorry + 1 = sorry"}, {"line": "\u00b7 -- lt : \u2113 (w * s i) < \u2113 w\n    right\n    have length_ge := cs.length_mul_ge_length_sub_length w (s i)\n    simp only [length_simple] at length_ge\n    simp only [tsub_le_iff_right] at length_ge\n    omega", "tactic_state": "case inr\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nx\u271d : Sort u_2\n\u2113 : x\u271d\nw : W\ni : B\ngt : ?m.6133 > ?m.6134\n\u22a2 sorry = sorry + 1 \u2228 sorry + 1 = sorry"}, {"line": "\u00b7 -- gt : \u2113 w < \u2113 (w * s i)\n    left\n    have length_le := cs.length_mul_le w (s i)\n    simp only [length_simple] at length_le\n    omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isReduced_reverse_iff (\u03c9 : List B) : cs.IsReduced (\u03c9.reverse) \u2194 cs.IsReduced \u03c9 := by\n  simp [IsReduced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Length.lean", "context": {"open": ["List Matrix Function", "scoped Classical in", "scoped Classical in"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\n\u03c9 : List B\n\u22a2 cs.IsReduced \u03c9.reverse \u2194 cs.IsReduced \u03c9"}, {"line": "simp [IsReduced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_isReduced_alternatingWord (i i' : B) {m : \u2115} (hM : M i i' \u2260 0) (hm : m > M i i') :\n    \u00accs.IsReduced (alternatingWord i i' m) := by\n  induction' hm with m _ ih\n  \u00b7 -- Base case; m = M i i' + 1\n    suffices h : \u2113 (\u03c0 (alternatingWord i i' (M i i' + 1))) < M i i' + 1 by\n      unfold IsReduced\n      rw [Nat.succ_eq_add_one]\n      rw [length_alternatingWord]\n      omega\n    have : M i i' + 1 \u2264 M i i' * 2 := by linarith [Nat.one_le_iff_ne_zero.mpr hM]\n    rw [cs.prod_alternatingWord_eq_prod_alternatingWord_sub i i' _ this]\n    have : M i i' * 2 - (M i i' + 1) = M i i' - 1 := by omega\n    rw [this]\n    calc\n      \u2113 (\u03c0 (alternatingWord i' i (M i i' - 1)))\n      _ \u2264 (alternatingWord i' i (M i i' - 1)).length  := cs.length_wordProd_le _\n      _ = M i i' - 1                                  := length_alternatingWord _ _ _\n      _ \u2264 M i i'                                      := Nat.sub_le _ _\n      _ < M i i' + 1                                  := Nat.lt_succ_self _\n  \u00b7 -- Inductive step\n    contrapose! ih\n    rw [alternatingWord_succ'] at ih\n    apply IsReduced.drop (j := 1) at ih\n    simpa using ih\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Length.lean", "context": {"open": ["List Matrix Function", "scoped Classical in", "scoped Classical in"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_3\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_2\nalternatingWord : x\u271d\ni i' : B\nm : \u2115\nhM : M.M i i' \u2260 0\nhm : m > M.M i i'\n\u22a2 \u00accs.IsReduced sorry"}, {"line": "induction' hm with m _ ih", "tactic_state": "case refl\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_2\nalternatingWord : x\u271d\ni i' : B\nm : \u2115\nhM : M.M i i' \u2260 0\n\u22a2 \u00accs.IsReduced sorry\n---\ncase step\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_2\nalternatingWord : x\u271d\ni i' : B\nm\u271d : \u2115\nhM : M.M i i' \u2260 0\nm : \u2115\na\u271d : (M.M i i').succ.le m\nih : \u00accs.IsReduced sorry\n\u22a2 \u00accs.IsReduced sorry"}, {"line": "\u00b7 -- Base case; m = M i i' + 1\n    suffices h : \u2113 (\u03c0 (alternatingWord i i' (M i i' + 1))) < M i i' + 1 by\n      unfold IsReduced\n      rw [Nat.succ_eq_add_one]\n      rw [length_alternatingWord]\n      omega\n    have : M i i' + 1 \u2264 M i i' * 2 := by linarith [Nat.one_le_iff_ne_zero.mpr hM]\n    rw [cs.prod_alternatingWord_eq_prod_alternatingWord_sub i i' _ this]\n    have : M i i' * 2 - (M i i' + 1) = M i i' - 1 := by omega\n    rw [this]\n    calc\n      \u2113 (\u03c0 (alternatingWord i' i (M i i' - 1)))\n      _ \u2264 (alternatingWord i' i (M i i' - 1)).length  := cs.length_wordProd_le _\n      _ = M i i' - 1                                  := length_alternatingWord _ _ _\n      _ \u2264 M i i'                                      := Nat.sub_le _ _\n      _ < M i i' + 1                                  := Nat.lt_succ_self _", "tactic_state": "case step\nB : Type u_3\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nx\u271d : Sort u_2\nalternatingWord : x\u271d\ni i' : B\nm\u271d : \u2115\nhM : M.M i i' \u2260 0\nm : \u2115\na\u271d : (M.M i i').succ.le m\nih : \u00accs.IsReduced sorry\n\u22a2 \u00accs.IsReduced sorry"}, {"line": "\u00b7 -- Inductive step\n    contrapose! ih\n    rw [alternatingWord_succ'] at ih\n    apply IsReduced.drop (j := 1) at ih\n    simpa using ih", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isRightDescent_inv_iff {w : W} {i : B} :\n    cs.IsRightDescent w\u207b\u00b9 i \u2194 cs.IsLeftDescent w i := by\n  simpa using (cs.isLeftDescent_inv_iff (w := w\u207b\u00b9)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Coxeter/Length.lean", "context": {"open": ["List Matrix Function", "scoped Classical in", "scoped Classical in"], "variables": ["{B : Type*}", "{W : Type*} [Group W]", "{M : CoxeterMatrix B} (cs : CoxeterSystem M W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nW : Type u_1\ninst\u271d : Group W\nM : CoxeterMatrix B\ncs : CoxeterSystem M W\nw : W\ni : B\n\u22a2 cs.IsRightDescent w\u207b\u00b9 i \u2194 cs.IsLeftDescent w i"}, {"line": "simpa using (cs.isLeftDescent_inv_iff (w := w\u207b\u00b9)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Step.cons_cons_iff : \u2200 {p : \u03b1 \u00d7 Bool}, Step (p :: L\u2081) (p :: L\u2082) \u2194 Step L\u2081 L\u2082 := by\n  simp +contextual [Step.cons_left_iff, iff_def, or_imp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeGroup/Basic.lean", "context": {"open": ["Relation", "scoped List"], "variables": ["{\u03b1 : Type u}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nStep : x\u271d\np\u271d : \u03b1 \u00d7 Bool\n\u22a2 sorry \u2194 sorry"}, {"line": "simp +contextual [Step.cons_left_iff, iff_def, or_imp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invRev_invRev : invRev (invRev L\u2081) = L\u2081 := by\n  simp [invRev, List.map_reverse, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeGroup/Basic.lean", "context": {"open": ["Relation", "scoped List", "List -- for <+ notation", "scoped Relator in"], "variables": ["{\u03b1 : Type u}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nL\u2081 : List (\u03b1 \u00d7 Bool)\nx\u271d : Sort u_1\ninvRev : x\u271d\n\u22a2 sorry = L\u2081"}, {"line": "simp [invRev, List.map_reverse, Function.comp_def]", "tactic_state": "\u03b1 : Type u_2\nL\u2081 : List (\u03b1 \u00d7 Bool)\nx\u271d : Sort u_1\ninvRev : x\u271d\n\u22a2 sorry () = L\u2081"}]}
{"declaration": "theorem invRev_append : invRev (L\u2081 ++ L\u2082) = invRev L\u2082 ++ invRev L\u2081 := by simp [invRev]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeGroup/Basic.lean", "context": {"open": ["Relation", "scoped List", "List -- for <+ notation", "scoped Relator in"], "variables": ["{\u03b1 : Type u}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ninvRev : x\u271d\n\u22a2 sorry = sorry ++ sorry"}, {"line": "simp [invRev]", "tactic_state": "x\u271d : Sort u_1\ninvRev : x\u271d\n\u22a2 sorry () = sorry () ++ sorry ()"}]}
{"declaration": "theorem lift.range_eq_closure : (lift f).range = Subgroup.closure (Set.range f) := by\n  apply le_antisymm (lift.range_le Subgroup.subset_closure)\n  rw [Subgroup.closure_le]\n  rintro _ \u27e8a, rfl\u27e9\n  exact \u27e8FreeGroup.of a, by simp only [lift.of]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeGroup/Basic.lean", "context": {"open": ["Relation", "scoped List", "List -- for <+ notation", "scoped Relator in"], "variables": ["{\u03b1 : Type u}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}", "{L L\u2081 L\u2082 L\u2083 L\u2084 : List (\u03b1 \u00d7 Bool)}", "{\u03b2 : Type v} [Group \u03b2] (f : \u03b1 \u2192 \u03b2) {x y : FreeGroup \u03b1}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type v\ninst\u271d : Group \u03b2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_1\nlift : x\u271d\n\u22a2 sorry = Subgroup.closure (Set.range f)"}, {"line": "apply le_antisymm (lift.range_le Subgroup.subset_closure)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type v\ninst\u271d : Group \u03b2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_1\nlift : x\u271d\n\u22a2 Subgroup.closure (Set.range f) \u2264 sorry"}, {"line": "rw [Subgroup.closure_le]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type v\ninst\u271d : Group \u03b2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_1\nlift : x\u271d\n\u22a2 Set.range f \u2286 \u2191sorry"}, {"line": "rintro _ \u27e8a, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_2\n\u03b2 : Type v\ninst\u271d : Group \u03b2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_1\nlift : x\u271d\na : \u03b1\n\u22a2 f a \u2208 \u2191sorry"}, {"line": "exact \u27e8FreeGroup.of a, by simp only [lift.of]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unique_lift (f : Generators G \u2192 H) : \u2203! F : G \u2192* H, \u2200 a, F (of a) = f a := by\n  simpa only [funext_iff] using lift.symm.bijective.existsUnique f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/FreeGroup/IsFreeGroup.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b9 \u03b9' G H : Type*} [Group G] [Group H]", "(G : Type*) [Group G] [IsFreeGroup G]", "{G}", "{H : Type*} [Group H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_5\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : IsFreeGroup G\nH : Type u_6\ninst\u271d : Group H\nx\u271d\u00b9 : Sort u_7\nGenerators : x\u271d\u00b9\nx\u271d : Sort u_8\nof : x\u271d\nf : sorry \u2192 H\n\u22a2 \u2203! F, \u2200 (a : sorry), F sorry = f a"}, {"line": "simpa only [funext_iff] using lift.symm.bijective.existsUnique f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma univ_eq_iUnion_orbit :\n    Set.univ (\u03b1 := \u03b1) = \u22c3 x : \u03a9, x.orbit := by\n  ext x\n  simp only [Set.mem_univ]\n  simp only [Set.mem_iUnion]\n  simp only [true_iff]\n  exact \u27e8Quotient.mk'' x, by simp\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Defs.lean", "context": {"open": ["Pointwise", "Function"], "variables": ["(M : Type u) [Monoid M] (\u03b1 : Type v) [MulAction M \u03b1] {\u03b2 : Type*} [MulAction M \u03b2]", "{\u03b1}", "{M}", "{M} in", "{M \u03b1}", "{\u03b1}", "{M}", "(M : Type u) (\u03b1 : Type v) [Monoid M]", "[Monoid \u03b1] [MulDistribMulAction M \u03b1]", "[Group \u03b1] [MulDistribMulAction M \u03b1]", "{G \u03b1 \u03b2 : Type*} [Group G] [MulAction G \u03b1] [MulAction G \u03b2]", "(G \u03b1)", "{G \u03b1}", "(G \u03b1)", "{G \u03b1}", "(G) (\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03a9 : Sort u_5\n\u22a2 Set.univ = \u22c3 x, sorry"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03a9 : Sort u_5\nx : \u03b1\n\u22a2 x \u2208 Set.univ \u2194 x \u2208 \u22c3 x, sorry"}, {"line": "simp only [Set.mem_univ]", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03a9 : Sort u_5\nx : \u03b1\n\u22a2 True \u2194 x \u2208 \u22c3 x, sorry"}, {"line": "simp only [Set.mem_iUnion]", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03a9 : Sort u_5\nx : \u03b1\n\u22a2 True \u2194 \u2203 i, x \u2208 sorry"}, {"line": "simp only [true_iff]", "tactic_state": "case h\n\u03b1 : Type u_3\n\u03a9 : Sort u_5\nx : \u03b1\n\u22a2 \u2203 i, x \u2208 sorry"}, {"line": "exact \u27e8Quotient.mk'' x, by simp\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma snd_mem_orbit_of_mem_orbit {x y : \u03b1 \u00d7 \u03b2} (h : x \u2208 MulAction.orbit M y) :\n    x.2 \u2208 MulAction.orbit M y.2 := by\n  rcases h with \u27e8g, rfl\u27e9\n  exact mem_orbit _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Basic.lean", "context": {"open": ["Pointwise", "Function"], "variables": ["(M : Type u) [Monoid M] (\u03b1 : Type v) [MulAction M \u03b1] {\u03b2 : Type*} [MulAction M \u03b2]", "{\u03b1 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u\ninst\u271d\u00b2 : Monoid M\n\u03b1 : Type v\ninst\u271d\u00b9 : MulAction M \u03b1\n\u03b2 : Type u_1\ninst\u271d : MulAction M \u03b2\nx y : \u03b1 \u00d7 \u03b2\nh : x \u2208 MulAction.orbit M y\n\u22a2 x.2 \u2208 MulAction.orbit M y.2"}, {"line": "rcases h with \u27e8g, rfl\u27e9", "tactic_state": "case intro\nM : Type u\ninst\u271d\u00b2 : Monoid M\n\u03b1 : Type v\ninst\u271d\u00b9 : MulAction M \u03b1\n\u03b2 : Type u_1\ninst\u271d : MulAction M \u03b2\ny : \u03b1 \u00d7 \u03b2\ng : M\n\u22a2 ((fun m => m \u2022 y) g).2 \u2208 MulAction.orbit M y.2"}, {"line": "exact mem_orbit _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_cancel_of_non_zero_divisor {M G : Type*} [Monoid M] [AddGroup G]\n    [DistribMulAction M G] (k : M) (h : \u2200 x : G, k \u2022 x = 0 \u2192 x = 0) {a b : G} (h' : k \u2022 a = k \u2022 b) :\n    a = b := by\n  rw [\u2190 sub_eq_zero]\n  refine h _ ?_\n  rw [smul_sub]\n  rw [h']\n  rw [sub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Basic.lean", "context": {"open": ["Pointwise", "Function"], "variables": ["(M : Type u) [Monoid M] (\u03b1 : Type v) [MulAction M \u03b1] {\u03b2 : Type*} [MulAction M \u03b2]", "{\u03b1 M}", "(M)", "{M \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 a = b"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "M : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 a - b = 0\n---\nM : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 AddGroup G"}, {"line": "refine h _ ?_", "tactic_state": "M : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 k \u2022 (a - b) = 0"}, {"line": "rw [smul_sub]", "tactic_state": "M : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 k \u2022 a - k \u2022 b = 0"}, {"line": "rw [h']", "tactic_state": "M : Type u_2\nG : Type u_3\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : AddGroup G\ninst\u271d : DistribMulAction M G\nk : M\nh : \u2200 (x : G), k \u2022 x = 0 \u2192 x = 0\na b : G\nh' : k \u2022 a = k \u2022 b\n\u22a2 k \u2022 b - k \u2022 b = 0"}, {"line": "rw [sub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.swap_mem_stabilizer {\u03b1 : Type*} [DecidableEq \u03b1] {S : Set \u03b1} {a b : \u03b1} :\n    Equiv.swap a b \u2208 MulAction.stabilizer (Equiv.Perm \u03b1) S \u2194 (a \u2208 S \u2194 b \u2208 S) := by\n  rw [MulAction.mem_stabilizer_iff]\n  rw [Set.ext_iff]\n  rw [\u2190 swap_inv]\n  simp_rw [Set.mem_inv_smul_set_iff, Perm.smul_def, swap_apply_def]\n  exact \u27e8fun h \u21a6 by simpa [Iff.comm] using h a, by intros; split_ifs <;> simp [*]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Basic.lean", "context": {"open": ["Pointwise", "Function"], "variables": ["(M : Type u) [Monoid M] (\u03b1 : Type v) [MulAction M \u03b1] {\u03b2 : Type*} [MulAction M \u03b2]", "{\u03b1 M}", "(M)", "{M \u03b1}", "{G \u03b1 \u03b2 : Type*} [Group G] [MulAction G \u03b1] [MulAction G \u03b2]", "(G \u03b1)", "{G \u03b1}", "(G) (\u03b1)", "(\u03b2)", "(G)", "{G}", "{G \u03b1 : Type*} [AddGroup G] [AddAction G \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : DecidableEq \u03b1\nS : Set \u03b1\na b : \u03b1\n\u22a2 swap a b \u2208 MulAction.stabilizer (Perm \u03b1) S \u2194 (a \u2208 S \u2194 b \u2208 S)"}, {"line": "rw [MulAction.mem_stabilizer_iff]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : DecidableEq \u03b1\nS : Set \u03b1\na b : \u03b1\n\u22a2 swap a b \u2022 S = S \u2194 (a \u2208 S \u2194 b \u2208 S)"}, {"line": "rw [Set.ext_iff]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : DecidableEq \u03b1\nS : Set \u03b1\na b : \u03b1\n\u22a2 (\u2200 (x : \u03b1), x \u2208 swap a b \u2022 S \u2194 x \u2208 S) \u2194 (a \u2208 S \u2194 b \u2208 S)"}, {"line": "rw [\u2190 swap_inv]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : DecidableEq \u03b1\nS : Set \u03b1\na b : \u03b1\n\u22a2 (\u2200 (x : \u03b1), x \u2208 (swap a b)\u207b\u00b9 \u2022 S \u2194 x \u2208 S) \u2194 (a \u2208 S \u2194 b \u2208 S)"}, {"line": "simp_rw [Set.mem_inv_smul_set_iff, Perm.smul_def, swap_apply_def]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : DecidableEq \u03b1\nS : Set \u03b1\na b : \u03b1\n\u22a2 (\u2200 (x : \u03b1), (if x = a then b else if x = b then a else x) \u2208 S \u2194 x \u2208 S) \u2194 (a \u2208 S \u2194 b \u2208 S)"}, {"line": "exact \u27e8fun h \u21a6 by simpa [Iff.comm] using h a, by intros; split_ifs <;> simp [*]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTrivialBlock.smul_iff {B : Set \u03b1} (g : M) :\n    IsTrivialBlock (g \u2022 B) \u2194 IsTrivialBlock B := by\n  constructor\n  \u00b7 intro H\n    convert IsTrivialBlock.smul H g\u207b\u00b9\n    simp only [inv_smul_smul]\n  \u00b7 intro H\n    exact IsTrivialBlock.smul H g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_5\n\u03b1 : Type u_6\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M \u03b1\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\nx\u271d : Sort u_9\nIsTrivialBlock : x\u271d\nB : Set \u03b1\ng : M\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nM : Type u_5\n\u03b1 : Type u_6\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M \u03b1\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\nx\u271d : Sort u_9\nIsTrivialBlock : x\u271d\nB : Set \u03b1\ng : M\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nM : Type u_5\n\u03b1 : Type u_6\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M \u03b1\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\nx\u271d : Sort u_9\nIsTrivialBlock : x\u271d\nB : Set \u03b1\ng : M\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro H\n    convert IsTrivialBlock.smul H g\u207b\u00b9\n    simp only [inv_smul_smul]", "tactic_state": "case mpr\nM : Type u_5\n\u03b1 : Type u_6\ninst\u271d\u00b3 : Monoid M\ninst\u271d\u00b2 : MulAction M \u03b1\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\nx\u271d : Sort u_9\nIsTrivialBlock : x\u271d\nB : Set \u03b1\ng : M\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro H\n    exact IsTrivialBlock.smul H g", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBlock.smul_eq_smul_of_subset (hB : IsBlock G B) (hg : g\u2081 \u2022 B \u2286 g\u2082 \u2022 B) :\n    g\u2081 \u2022 B = g\u2082 \u2022 B := by\n  by_contra! hg'\n  obtain rfl : B = \u2205 := by simpa using (hB hg').eq_bot_of_le hg\n  simp at hg'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\nB : Set X\ng\u2081 g\u2082 : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhg : g\u2081 \u2022 B \u2286 g\u2082 \u2022 B\n\u22a2 g\u2081 \u2022 B = g\u2082 \u2022 B"}, {"line": "by_contra! hg'", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\nB : Set X\ng\u2081 g\u2082 : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhg : g\u2081 \u2022 B \u2286 g\u2082 \u2022 B\nhg' : g\u2081 \u2022 B \u2260 g\u2082 \u2022 B\n\u22a2 False"}, {"line": "obtain rfl : B = \u2205 := by simpa using (hB hg').eq_bot_of_le hg", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\ng\u2081 g\u2082 : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhg : g\u2081 \u2022 \u2205 \u2286 g\u2082 \u2022 \u2205\nhg' : g\u2081 \u2022 \u2205 \u2260 g\u2082 \u2022 \u2205\n\u22a2 False"}, {"line": "simp at hg'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsBlock.disjoint_smul_set_smul (hB : IsBlock G B) (hgs : \u00ac g \u2022 B \u2286 s \u2022 B) :\n    Disjoint (g \u2022 B) (s \u2022 B) := by\n  rw [\u2190 iUnion_smul_set]\n  rw [disjoint_iUnion\u2082_right]\n  exact fun b hb \u21a6 hB fun h \u21a6 hgs <| h.trans_subset <| smul_set_subset_smul hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\nB : Set X\ns : Set G\ng : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhgs : \u00acg \u2022 B \u2286 s \u2022 B\n\u22a2 Disjoint (g \u2022 B) (s \u2022 B)"}, {"line": "rw [\u2190 iUnion_smul_set]", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\nB : Set X\ns : Set G\ng : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhgs : \u00acg \u2022 B \u2286 s \u2022 B\n\u22a2 Disjoint (g \u2022 B) (\u22c3 a \u2208 s, a \u2022 B)"}, {"line": "rw [disjoint_iUnion\u2082_right]", "tactic_state": "G : Type u_3\nX : Type u_4\ninst\u271d : SMul G X\nB : Set X\ns : Set G\ng : G\nx\u271d : Sort u_9\nIsBlock : x\u271d\nhB : sorry\nhgs : \u00acg \u2022 B \u2286 s \u2022 B\n\u22a2 \u2200 i \u2208 s, Disjoint (g \u2022 B) (i \u2022 B)"}, {"line": "exact fun b hb \u21a6 hB fun h \u21a6 hgs <| h.trans_subset <| smul_set_subset_smul hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsFixedBlock.isBlock (hfB : IsFixedBlock G B) : IsBlock G B := by simp [IsBlock, hfB _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_9\nIsFixedBlock : x\u271d\u00b9\nx\u271d : Sort u_10\nIsBlock : x\u271d\nhfB : sorry\n\u22a2 sorry"}, {"line": "simp [IsBlock, hfB _]", "tactic_state": "x\u271d\u00b9 : Sort u_9\nIsFixedBlock : x\u271d\u00b9\nx\u271d : Sort u_10\nIsBlock : x\u271d\nhfB : sorry\n\u22a2 sorry ()"}]}
{"declaration": "lemma IsBlock.empty : IsBlock G (\u2205 : Set X) := by simp [IsBlock]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_9\nIsBlock : x\u271d\n\u22a2 sorry"}, {"line": "simp [IsBlock]", "tactic_state": "x\u271d : Sort u_9\nIsBlock : x\u271d\n\u22a2 sorry ()"}]}
{"declaration": "lemma IsBlock.singleton : IsBlock G ({a} : Set X) := by simp [IsBlock]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_9\nIsBlock : x\u271d\n\u22a2 sorry"}, {"line": "simp [IsBlock]", "tactic_state": "x\u271d : Sort u_9\nIsBlock : x\u271d\n\u22a2 sorry ()"}]}
{"declaration": "lemma IsBlock.disjoint_smul_right (hB : IsBlock M B) (hs : \u00ac B \u2286 s \u2022 B) : Disjoint B (s \u2022 B) := by\n  simpa using hB.disjoint_smul_set_smul (g := 1) (by simpa using hs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}", "{M X : Type*} [Monoid M] [MulAction M X] {B : Set X} {s : Set M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\nX : Type u_10\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulAction M X\nB : Set X\ns : Set M\nx\u271d : Sort u_11\nIsBlock : x\u271d\nhB : sorry\nhs : \u00acB \u2286 s \u2022 B\n\u22a2 Disjoint B (s \u2022 B)"}, {"line": "simpa using hB.disjoint_smul_set_smul (g := 1) (by simpa using hs)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBlock_iff_smul_eq_of_mem :\n    IsBlock G B \u2194 \u2200 \u2983g : G\u2984 \u2983a : X\u2984, a \u2208 B \u2192 g \u2022 a \u2208 B \u2192 g \u2022 B = B := by\n  simp [isBlock_iff_smul_eq_of_nonempty, Set.Nonempty, mem_smul_set]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Blocks.lean", "context": {"open": ["Set", "scoped Pointwise"], "variables": ["{G : Type*} [Group G] {X : Type*} [MulAction G X]", "(G : Type*) {X : Type*} [SMul G X] {B : Set X} {a : X}", "{M \u03b1 N \u03b2 : Type*}", "[Monoid M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "[Group M] [MulAction M \u03b1] [Monoid N] [MulAction N \u03b2]", "{G} {s : Set G} {g g\u2081 g\u2082 : G}", "{M X : Type*} [Monoid M] [MulAction M X] {B : Set X} {s : Set M}", "{G : Type*} [Group G] {X : Type*} [MulAction G X] {B : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_11\ninst\u271d\u00b9 : Group G\nX : Type u_12\ninst\u271d : MulAction G X\nB : Set X\nx\u271d : Sort u_13\nIsBlock : x\u271d\n\u22a2 sorry \u2194 \u2200 \u2983g : G\u2984 \u2983a : X\u2984, a \u2208 B \u2192 g \u2022 a \u2208 B \u2192 g \u2022 B = B"}, {"line": "simp [isBlock_iff_smul_eq_of_nonempty, Set.Nonempty, mem_smul_set]", "tactic_state": "G : Type u_11\ninst\u271d\u00b9 : Group G\nX : Type u_12\ninst\u271d : MulAction G X\nB : Set X\nx\u271d : Sort u_13\nIsBlock : x\u271d\n\u22a2 sorry () \u2194 \u2200 \u2983g : G\u2984 \u2983a : X\u2984, a \u2208 B \u2192 g \u2022 a \u2208 B \u2192 g \u2022 B = B"}]}
{"declaration": "theorem mem_fixingSubgroup_iff_subset_fixedBy {s : Set \u03b1} {m : M} :\n    m \u2208 fixingSubgroup M s \u2194 s \u2286 fixedBy \u03b1 m := by\n  simp_rw [mem_fixingSubgroup_iff, Set.subset_def, mem_fixedBy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/FixingSubgroup.lean", "context": {"open": ["MulAction", "MulAction"], "variables": ["(M : Type*) {\u03b1 : Type*} [Monoid M] [MulAction M \u03b1]", "(\u03b1)", "(M : Type*) {\u03b1 : Type*} [Group M] [MulAction M \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\ns : Set \u03b1\nm : M\n\u22a2 m \u2208 fixingSubgroup M s \u2194 s \u2286 fixedBy \u03b1 m"}, {"line": "simp_rw [mem_fixingSubgroup_iff, Set.subset_def, mem_fixedBy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_fixingSubgroup_compl_iff_movedBy_subset {s : Set \u03b1} {m : M} :\n    m \u2208 fixingSubgroup M s\u1d9c \u2194 (fixedBy \u03b1 m)\u1d9c \u2286 s := by\n  rw [mem_fixingSubgroup_iff_subset_fixedBy]\n  rw [Set.compl_subset_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/FixingSubgroup.lean", "context": {"open": ["MulAction", "MulAction"], "variables": ["(M : Type*) {\u03b1 : Type*} [Monoid M] [MulAction M \u03b1]", "(\u03b1)", "(M : Type*) {\u03b1 : Type*} [Group M] [MulAction M \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\ns : Set \u03b1\nm : M\n\u22a2 m \u2208 fixingSubgroup M s\u1d9c \u2194 (fixedBy \u03b1 m)\u1d9c \u2286 s"}, {"line": "rw [mem_fixingSubgroup_iff_subset_fixedBy]", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Group M\ninst\u271d : MulAction M \u03b1\ns : Set \u03b1\nm : M\n\u22a2 s\u1d9c \u2286 fixedBy \u03b1 m \u2194 (fixedBy \u03b1 m)\u1d9c \u2286 s"}, {"line": "rw [Set.compl_subset_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inverse_eq_inverse' (f : X \u2192[M] Y\u2081) (g : Y\u2081 \u2192 X)\n    (h\u2081 : Function.LeftInverse g f) (h\u2082 : Function.RightInverse g f) :\n  inverse f g h\u2081 h\u2082 = inverse' f g (congrFun rfl) h\u2081 h\u2082 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Hom.lean", "context": {"open": ["MulActionHom"], "variables": ["{M' : Type*}", "{M : Type*} {N : Type*} {P : Type*}", "(\u03c6 : M \u2192 N) (\u03c8 : N \u2192 P) (\u03c7 : M \u2192 P)", "(X : Type*) [SMul M X] [SMul M' X]", "(Y : Type*) [SMul N Y] [SMul M' Y]", "(Z : Type*) [SMul P Z]", "{\u03c6 X Y}", "{F : Type*} [FunLike F X Y]", "(M' X Y F) in", "{\u03c8 \u03c7} (M N)", "{M N Z}", "{\u03c6 \u03c8 \u03c7 X Y Z}", "{\u03c6' : N \u2192 M}", "{Y\u2081 : Type*} [SMul M Y\u2081]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\nX : Type u_5\ninst\u271d\u00b9 : SMul M X\nY\u2081 : Type u_9\ninst\u271d : SMul M Y\u2081\nf : X \u2192\u2091[id] Y\u2081\ng : Y\u2081 \u2192 X\nh\u2081 : Function.LeftInverse g \u21d1f\nh\u2082 : Function.RightInverse g \u21d1f\n\u22a2 f.inverse g h\u2081 h\u2082 = f.inverse' g \u22ef h\u2081 h\u2082"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem id_apply (x : A) : DistribMulActionHom.id M x = x := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Hom.lean", "context": {"open": ["MulActionHom"], "variables": ["{M' : Type*}", "{M : Type*} {N : Type*} {P : Type*}", "(\u03c6 : M \u2192 N) (\u03c8 : N \u2192 P) (\u03c7 : M \u2192 P)", "(X : Type*) [SMul M X] [SMul M' X]", "(Y : Type*) [SMul N Y] [SMul M' Y]", "(Z : Type*) [SMul P Z]", "{\u03c6 X Y}", "{F : Type*} [FunLike F X Y]", "(M' X Y F) in", "{\u03c8 \u03c7} (M N)", "{M N Z}", "{\u03c6 \u03c8 \u03c7 X Y Z}", "{\u03c6' : N \u2192 M}", "{Y\u2081 : Type*} [SMul M Y\u2081]", "{M \u03b1 \u03b2 : Type*} [SMul M \u03b1] [SMul M \u03b2]", "(M \u03b1 \u03b2) in", "(M \u03b1 \u03b2) in", "{M N \u03b1 \u03b2 \u03b3 \u03b4 : Type*} [SMul M \u03b1] [SMul M \u03b2] [SMul N \u03b3] [SMul N \u03b4] {\u03c3 : M \u2192 N}", "{M : Type*} [Monoid M]", "{N : Type*} [Monoid N]", "{P : Type*} [Monoid P]", "(\u03c6 : M \u2192* N) (\u03c6' : N \u2192* M) (\u03c8 : N \u2192* P) (\u03c7 : M \u2192* P)", "(A : Type*) [AddMonoid A] [DistribMulAction M A]", "(B : Type*) [AddMonoid B] [DistribMulAction N B]", "(B\u2081 : Type*) [AddMonoid B\u2081] [DistribMulAction M B\u2081]", "(C : Type*) [AddMonoid C] [DistribMulAction P C]", "(A' : Type*) [AddGroup A'] [DistribMulAction M A']", "(B' : Type*) [AddGroup B'] [DistribMulAction N B']", "{\u03c6 \u03c6' A B B\u2081}", "{F : Type*} [FunLike F A B]", "(M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_13\ninst\u271d\u00b2 : Monoid M\nA : Type u_16\ninst\u271d\u00b9 : AddMonoid A\ninst\u271d : DistribMulAction M A\nx : A\n\u22a2 (DistribMulActionHom.id M) x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPreprimitive_congr (h\u03c6 : Function.Surjective \u03c6) (hf : Function.Bijective f) :\n    IsPreprimitive M \u03b1 \u2194 IsPreprimitive N \u03b2 := by\n  constructor\n  \u00b7 intro _\n    apply IsPreprimitive.of_surjective hf.surjective\n  \u00b7 intro _\n    haveI := (isPretransitive_congr h\u03c6 hf).mpr toIsPretransitive\n    exact {\n      isTrivialBlock_of_isBlock {B} hB := by\n        rw [\u2190 Set.preimage_image_eq B hf.injective]\n        exact IsTrivialBlock.preimage hf.injective\n          (isTrivialBlock_of_isBlock (hB.image f h\u03c6 hf.injective)) }\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Primitive.lean", "context": {"open": ["Pointwise", "IsPreprimitive", "scoped BigOperators Pointwise"], "variables": ["(G : Type*) (X : Type*)", "{G X}", "[Group G] [MulAction G X]", "{M : Type*} [Group M] {\u03b1 : Type*} [MulAction M \u03b1]", "{N \u03b2 : Type*} [Group N] [MulAction N \u03b2]", "{\u03c6 : M \u2192* N} {f : \u03b1 \u2192\u2091[\u03c6] \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b3 : Group M\n\u03b1 : Type u_4\ninst\u271d\u00b2 : MulAction M \u03b1\nN : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : MulAction N \u03b2\n\u03c6 : M \u2192* N\nf : \u03b1 \u2192\u2091[\u21d1\u03c6] \u03b2\nx\u271d : Sort u_7\nIsPreprimitive : x\u271d\nh\u03c6 : Function.Surjective \u21d1\u03c6\nhf : Function.Bijective \u21d1f\n\u22a2 sorry \u2194 sorry"}, {"line": "constructor", "tactic_state": "case mp\nM : Type u_3\ninst\u271d\u00b3 : Group M\n\u03b1 : Type u_4\ninst\u271d\u00b2 : MulAction M \u03b1\nN : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : MulAction N \u03b2\n\u03c6 : M \u2192* N\nf : \u03b1 \u2192\u2091[\u21d1\u03c6] \u03b2\nx\u271d : Sort u_7\nIsPreprimitive : x\u271d\nh\u03c6 : Function.Surjective \u21d1\u03c6\nhf : Function.Bijective \u21d1f\n\u22a2 sorry \u2192 sorry\n---\ncase mpr\nM : Type u_3\ninst\u271d\u00b3 : Group M\n\u03b1 : Type u_4\ninst\u271d\u00b2 : MulAction M \u03b1\nN : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : MulAction N \u03b2\n\u03c6 : M \u2192* N\nf : \u03b1 \u2192\u2091[\u21d1\u03c6] \u03b2\nx\u271d : Sort u_7\nIsPreprimitive : x\u271d\nh\u03c6 : Function.Surjective \u21d1\u03c6\nhf : Function.Bijective \u21d1f\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro _\n    apply IsPreprimitive.of_surjective hf.surjective", "tactic_state": "case mpr\nM : Type u_3\ninst\u271d\u00b3 : Group M\n\u03b1 : Type u_4\ninst\u271d\u00b2 : MulAction M \u03b1\nN : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : Group N\ninst\u271d : MulAction N \u03b2\n\u03c6 : M \u2192* N\nf : \u03b1 \u2192\u2091[\u21d1\u03c6] \u03b2\nx\u271d : Sort u_7\nIsPreprimitive : x\u271d\nh\u03c6 : Function.Surjective \u21d1\u03c6\nhf : Function.Bijective \u21d1f\n\u22a2 sorry \u2192 sorry"}, {"line": "\u00b7 intro _\n    haveI := (isPretransitive_congr h\u03c6 hf).mpr toIsPretransitive\n    exact {\n      isTrivialBlock_of_isBlock {B} hB := by\n        rw [\u2190 Set.preimage_image_eq B hf.injective]\n        exact IsTrivialBlock.preimage hf.injective\n          (isTrivialBlock_of_isBlock (hB.image f h\u03c6 hf.injective)) }", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalCore_eq_ker : H.normalCore = (MulAction.toPermHom G (G \u29f8 H)).ker := by\n  apply le_antisymm\n  \u00b7 intro g hg\n    apply Equiv.Perm.ext\n    refine fun q \u21a6 QuotientGroup.induction_on q ?_\n    refine fun g' => (MulAction.Quotient.smul_mk H g g').trans (QuotientGroup.eq.mpr ?_)\n    rw [smul_eq_mul]\n    rw [mul_inv_rev]\n    rw [\u2190 inv_inv g']\n    rw [inv_inv]\n    exact H.normalCore.inv_mem hg g'\u207b\u00b9\n  \u00b7 refine (Subgroup.normal_le_normalCore.mpr fun g hg => ?_)\n    rw [\u2190 H.inv_mem_iff]\n    rw [\u2190 mul_one g\u207b\u00b9]\n    rw [\u2190 QuotientGroup.eq]\n    rw [\u2190 mul_one g]\n    exact (MulAction.Quotient.smul_mk H g 1).symm.trans (Equiv.Perm.ext_iff.mp hg (1 : G))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/Quotient.lean", "context": {"open": ["Function", "Subgroup MulOpposite QuotientGroup", "QuotientGroup"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[Group \u03b1]", "(\u03b2) [Monoid \u03b2] [MulAction \u03b2 \u03b1] (H : Subgroup \u03b1)", "{\u03b2}", "(\u03b1)", "[MulAction \u03b1 \u03b2] (x : \u03b2)", "(\u03b2)", "{\u03b1}", "{\u03b2} in", "{\u03b2}", "{G : Type*} [Group G] (H : Subgroup G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 H.normalCore = (MulAction.toPermHom G (G \u29f8 H)).ker"}, {"line": "apply le_antisymm", "tactic_state": "case a\nG : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 H.normalCore \u2264 (MulAction.toPermHom G (G \u29f8 H)).ker\n---\ncase a\nG : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 (MulAction.toPermHom G (G \u29f8 H)).ker \u2264 H.normalCore"}, {"line": "\u00b7 intro g hg\n    apply Equiv.Perm.ext\n    refine fun q \u21a6 QuotientGroup.induction_on q ?_\n    refine fun g' => (MulAction.Quotient.smul_mk H g g').trans (QuotientGroup.eq.mpr ?_)\n    rw [smul_eq_mul]\n    rw [mul_inv_rev]\n    rw [\u2190 inv_inv g']\n    rw [inv_inv]\n    exact H.normalCore.inv_mem hg g'\u207b\u00b9", "tactic_state": "case a\nG : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 (MulAction.toPermHom G (G \u29f8 H)).ker \u2264 H.normalCore"}, {"line": "\u00b7 refine (Subgroup.normal_le_normalCore.mpr fun g hg => ?_)\n    rw [\u2190 H.inv_mem_iff]\n    rw [\u2190 mul_one g\u207b\u00b9]\n    rw [\u2190 QuotientGroup.eq]\n    rw [\u2190 mul_one g]\n    exact (MulAction.Quotient.smul_mk H g 1).symm.trans (Equiv.Perm.ext_iff.mp hg (1 : G))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem stabilizer_of_subMul {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizer R m = MulAction.stabilizer R (m : M) := by\n  rw [\u2190 Subgroup.toSubmonoid_inj]\n  exact stabilizer_of_subMul.submonoid m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "context": {"open": ["Function", "SMulMemClass"], "variables": ["{S : Type u'} {T : Type u''} {R : Type u} {M : Type v}", "[SMul R M] [SetLike S M] [hS : SMulMemClass S R M] (s : S)", "{N \u03b1 : Type*} [SetLike S \u03b1] [SMul M N] [SMul M \u03b1] [Monoid N]", "[SMul R M]", "[SMul R M]", "(p : SubMulAction R M)", "{r : R} {x : M}", "{p} in", "{p} in", "[Monoid R] [MulAction R M] {A : Type*} [SetLike A M]", "[hA : SMulMemClass A R M] (S' : A)", "{S'} in", "[Monoid R] [MulAction R M]", "[SMul S R] [SMul S M] [IsScalarTower S R M]", "(p : SubMulAction R M)", "[Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]", "(p : SubMulAction R M)", "[Group R] [MulAction R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Group R\ninst\u271d : MulAction R M\np : SubMulAction R M\nm : \u21a5p\n\u22a2 sorry = MulAction.stabilizer R \u2191m"}, {"line": "rw [\u2190 Subgroup.toSubmonoid_inj]", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : Group R\ninst\u271d : MulAction R M\np : SubMulAction R M\nm : \u21a5p\n\u22a2 sorry.toSubmonoid = (MulAction.stabilizer R \u2191m).toSubmonoid"}, {"line": "exact stabilizer_of_subMul.submonoid m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symm {s\u2081 s\u2082 : S.Splitting} (h : S.IsConj s\u2081 s\u2082) : S.IsConj s\u2082 s\u2081 := by\n  obtain \u27e8n, hn\u27e9 := h\n  exact \u27e8n\u207b\u00b9, by simp only [hn, map_inv]; group\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupExtension/Basic.lean", "context": {"open": [], "variables": ["{N G : Type*} [Group N] [Group G]", "{E : Type*} [Group E] (S : GroupExtension N E G)", "{S}", "{E' : Type*} [Group E'] {S' : GroupExtension N E' G} (\u03c3 \u03c3' : S.Section) (g g\u2081 g\u2082 : G)", "{S}", "{E' : Type*} [Group E'] {S' : GroupExtension N E' G}", "{S}", "(s : S.Splitting)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group G\nE : Type u_3\ninst\u271d : Group E\nS : GroupExtension N E G\ns\u2081 s\u2082 : S.Splitting\nh : S.IsConj s\u2081 s\u2082\n\u22a2 S.IsConj s\u2082 s\u2081"}, {"line": "obtain \u27e8n, hn\u27e9 := h", "tactic_state": "case intro\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group G\nE : Type u_3\ninst\u271d : Group E\nS : GroupExtension N E G\ns\u2081 s\u2082 : S.Splitting\nn : N\nhn : \u21d1s\u2081 = fun g => S.inl n * s\u2082 g * (S.inl n)\u207b\u00b9\n\u22a2 S.IsConj s\u2082 s\u2081"}, {"line": "exact \u27e8n\u207b\u00b9, by simp only [hn, map_inv]; group\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem trans {s\u2081 s\u2082 s\u2083 : S.Splitting} (h\u2081 : S.IsConj s\u2081 s\u2082) (h\u2082 : S.IsConj s\u2082 s\u2083) :\n    S.IsConj s\u2081 s\u2083 := by\n  obtain \u27e8n\u2081, hn\u2081\u27e9 := h\u2081\n  obtain \u27e8n\u2082, hn\u2082\u27e9 := h\u2082\n  exact \u27e8n\u2081 * n\u2082, by simp only [hn\u2081, hn\u2082, map_mul]; group\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/GroupExtension/Basic.lean", "context": {"open": [], "variables": ["{N G : Type*} [Group N] [Group G]", "{E : Type*} [Group E] (S : GroupExtension N E G)", "{S}", "{E' : Type*} [Group E'] {S' : GroupExtension N E' G} (\u03c3 \u03c3' : S.Section) (g g\u2081 g\u2082 : G)", "{S}", "{E' : Type*} [Group E'] {S' : GroupExtension N E' G}", "{S}", "(s : S.Splitting)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group G\nE : Type u_3\ninst\u271d : Group E\nS : GroupExtension N E G\ns\u2081 s\u2082 s\u2083 : S.Splitting\nh\u2081 : S.IsConj s\u2081 s\u2082\nh\u2082 : S.IsConj s\u2082 s\u2083\n\u22a2 S.IsConj s\u2081 s\u2083"}, {"line": "obtain \u27e8n\u2081, hn\u2081\u27e9 := h\u2081", "tactic_state": "case intro\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group G\nE : Type u_3\ninst\u271d : Group E\nS : GroupExtension N E G\ns\u2081 s\u2082 s\u2083 : S.Splitting\nh\u2082 : S.IsConj s\u2082 s\u2083\nn\u2081 : N\nhn\u2081 : \u21d1s\u2081 = fun g => S.inl n\u2081 * s\u2082 g * (S.inl n\u2081)\u207b\u00b9\n\u22a2 S.IsConj s\u2081 s\u2083"}, {"line": "obtain \u27e8n\u2082, hn\u2082\u27e9 := h\u2082", "tactic_state": "case intro.intro\nN : Type u_1\nG : Type u_2\ninst\u271d\u00b2 : Group N\ninst\u271d\u00b9 : Group G\nE : Type u_3\ninst\u271d : Group E\nS : GroupExtension N E G\ns\u2081 s\u2082 s\u2083 : S.Splitting\nn\u2081 : N\nhn\u2081 : \u21d1s\u2081 = fun g => S.inl n\u2081 * s\u2082 g * (S.inl n\u2081)\u207b\u00b9\nn\u2082 : N\nhn\u2082 : \u21d1s\u2082 = fun g => S.inl n\u2082 * s\u2083 g * (S.inl n\u2082)\u207b\u00b9\n\u22a2 S.IsConj s\u2081 s\u2083"}, {"line": "exact \u27e8n\u2081 * n\u2082, by simp only [hn\u2081, hn\u2082, map_mul]; group\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Away.mk_eq_monoidOf_mk' : mk = (Away.monoidOf x).mk' := by\n  simp [Localization.mk_eq_monoidOf_mk']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/MonoidLocalization/Away.lean", "context": {"open": ["Function"], "variables": ["{M : Type*} [CommMonoid M] {S : Submonoid M} {N : Type*} [CommMonoid N] {P : Type*}", "{g : M \u2192* P} (hg : \u2200 y : S, IsUnit (g y))", "(x : M)", "(F : AwayMap x N)", "{A : Type*} [AddCommMonoid A] (x : A) {B : Type*} [AddCommMonoid B] (F : AwayMap x B)", "(x : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "AwayMap : ?m.22611\nM : Type u_1\ninst\u271d\u00b3 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b2 : CommMonoid N\nP : Type u_3\ng : sorry\nhg : \u2200 (y : \u21a5S), IsUnit sorry\nx\u271d\u00b9 : M\nF\u271d : sorry\nA : Type u_4\ninst\u271d\u00b9 : AddCommMonoid A\nx\u271d : A\nB : Type u_5\ninst\u271d : AddCommMonoid B\nF : sorry\nx : M\n\u03b1\u271d : Sort u_6\nmk : \u03b1\u271d\n\u22a2 mk = sorry"}, {"line": "simp [Localization.mk_eq_monoidOf_mk']", "tactic_state": "AwayMap : ?m.22611\nM : Type u_1\ninst\u271d\u00b3 : CommMonoid M\nS : Submonoid M\nN : Type u_2\ninst\u271d\u00b2 : CommMonoid N\nP : Type u_3\ng : sorry\nhg : \u2200 (y : \u21a5S), IsUnit sorry\nx\u271d\u00b9 : M\nF\u271d : sorry\nA : Type u_4\ninst\u271d\u00b9 : AddCommMonoid A\nx\u271d : A\nB : Type u_5\ninst\u271d : AddCommMonoid B\nF : sorry\nx : M\n\u03b1\u271d : Sort u_6\nmk : \u03b1\u271d\n\u22a2 mk = sorry ()"}]}
{"declaration": "theorem mk_pow (n : \u2115) (a : M) (b : S) : mk a b ^ n = mk (a ^ n) (b ^ n) := by\n  induction n <;> simp [pow_succ, *, \u2190 mk_mul, \u2190 mk_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/MonoidLocalization/Basic.lean", "context": {"open": ["Function"], "variables": ["{M : Type*} [AddCommMonoid M] (S : AddSubmonoid M) (N : Type*) [AddCommMonoid N]", "{M : Type*} [CommMonoid M] (S : Submonoid M) (N : Type*) [CommMonoid N] {P : Type*}", "{S}", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d : CommMonoid M\nS : Submonoid M\nx\u271d : Sort u_6\nmk : x\u271d\nn : \u2115\na : M\nb : \u21a5S\n\u22a2 sorry ^ n = sorry"}, {"line": "induction n <;> simp [pow_succ, *, \u2190 mk_mul, \u2190 mk_one]", "tactic_state": "case zero\nM : Type u_3\ninst\u271d : CommMonoid M\nS : Submonoid M\nx\u271d : Sort u_6\nmk : x\u271d\na : M\nb : \u21a5S\n\u22a2 sorry () ^ 0 = sorry ()\n---\ncase succ\nM : Type u_3\ninst\u271d : CommMonoid M\nS : Submonoid M\nx\u271d : Sort u_6\nmk : x\u271d\na : M\nb : \u21a5S\nn\u271d : \u2115\na\u271d : sorry ^ n\u271d = sorry\n\u22a2 sorry () ^ (n\u271d + 1) = sorry ()"}]}
{"declaration": "theorem mulEquivOfQuotient_monoidOf (x) :\n    mulEquivOfQuotient f ((monoidOf S).toMap x) = f.toMap x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/MonoidLocalization/Basic.lean", "context": {"open": ["Function"], "variables": ["{M : Type*} [AddCommMonoid M] (S : AddSubmonoid M) (N : Type*) [AddCommMonoid N]", "{M : Type*} [CommMonoid M] (S : Submonoid M) (N : Type*) [CommMonoid N] {P : Type*}", "{S}", "{S}", "{R R\u2081 R\u2082 : Type*}", "{S N}", "(f : LocalizationMap S N)", "{g : M \u2192* P}", "(hg : \u2200 y : S, IsUnit (g y))", "{T : Submonoid P} (hy : \u2200 y : S, g y \u2208 T) {Q : Type*} [CommMonoid Q]", "{k}", "(f : S.LocalizationMap N) {g : M \u2192* P} (hg : \u2200 y : S, IsUnit (g y)) {T : Submonoid P}", "(S) in", "(f : Submonoid.LocalizationMap S N)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "LocalizationMap : ?m.45386\nM\u271d\u00b9 : Type u_1\ninst\u271d\u2076 : AddCommMonoid M\u271d\u00b9\nS\u271d\u00b9 : AddSubmonoid M\u271d\u00b9\nN\u271d\u00b9 : Type u_2\ninst\u271d\u2075 : AddCommMonoid N\u271d\u00b9\nM\u271d : Type u_3\ninst\u271d\u2074 : CommMonoid M\u271d\nS\u271d : Submonoid M\u271d\nN\u271d : Type u_4\ninst\u271d\u00b3 : CommMonoid N\u271d\nP : Type u_5\nR : Type u_6\nR\u2081 : Type u_7\nR\u2082 : Type u_8\nf\u271d\u00b9 : sorry\ng\u271d : sorry\nT\u271d : sorry\nhy : \u21a5S\u271d \u2192 sorry\nQ : Type u_9\ninst\u271d\u00b2 : CommMonoid Q\nk : ?m.50495 S\u271d\u00b9 N\u271d\u00b9 N\u271d f\u271d\u00b9 hy\nf\u271d : S\u271d.LocalizationMap N\u271d\ng : sorry\nhg : \u2200 (y : \u21a5S\u271d), IsUnit sorry\nT : sorry\nM : Type u_3\ninst\u271d\u00b9 : CommMonoid M\nS : Submonoid M\nN : Type u_4\ninst\u271d : CommMonoid N\nf : S.LocalizationMap N\nx\u271d : Sort u_10\nmulEquivOfQuotient : x\u271d\nx : M\n\u22a2 sorry = f.toMap x"}, {"line": "simp", "tactic_state": "LocalizationMap : ?m.45386\nM\u271d\u00b9 : Type u_1\ninst\u271d\u2076 : AddCommMonoid M\u271d\u00b9\nS\u271d\u00b9 : AddSubmonoid M\u271d\u00b9\nN\u271d\u00b9 : Type u_2\ninst\u271d\u2075 : AddCommMonoid N\u271d\u00b9\nM\u271d : Type u_3\ninst\u271d\u2074 : CommMonoid M\u271d\nS\u271d : Submonoid M\u271d\nN\u271d : Type u_4\ninst\u271d\u00b3 : CommMonoid N\u271d\nP : Type u_5\nR : Type u_6\nR\u2081 : Type u_7\nR\u2082 : Type u_8\nf\u271d\u00b9 : sorry\ng\u271d : sorry\nT\u271d : sorry\nhy : \u21a5S\u271d \u2192 sorry\nQ : Type u_9\ninst\u271d\u00b2 : CommMonoid Q\nk : ?m.50495 S\u271d\u00b9 N\u271d\u00b9 N\u271d f\u271d\u00b9 hy\nf\u271d : S\u271d.LocalizationMap N\u271d\ng : sorry\nhg : \u2200 (y : \u21a5S\u271d), IsUnit sorry\nT : sorry\nM : Type u_3\ninst\u271d\u00b9 : CommMonoid M\nS : Submonoid M\nN : Type u_4\ninst\u271d : CommMonoid N\nf : S.LocalizationMap N\nx\u271d : Sort u_10\nmulEquivOfQuotient : x\u271d\nx : M\n\u22a2 sorry () = f.toMap x"}]}
{"declaration": "lemma minOrder_eq_top : minOrder \u03b1 = \u22a4 \u2194 IsTorsionFree \u03b1 := by simp [minOrder, IsTorsionFree]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Order/Min.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 : Type*}", "(\u03b1) [Monoid \u03b1]", "{\u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nminOrder : x\u271d\u00b9\nx\u271d : Sort u_3\nIsTorsionFree : x\u271d\n\u22a2 sorry = \u22a4 \u2194 sorry"}, {"line": "simp [minOrder, IsTorsionFree]", "tactic_state": "x\u271d\u00b9 : Sort u_2\nminOrder : x\u271d\u00b9\nx\u271d : Sort u_3\nIsTorsionFree : x\u271d\n\u22a2 sorry () = \u22a4 \u2194 sorry ()"}]}
{"declaration": "lemma le_minOrder {n : \u2115\u221e} :\n    n \u2264 minOrder \u03b1 \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2260 1 \u2192 IsOfFinOrder a \u2192 n \u2264 orderOf a := by simp [minOrder]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Order/Min.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 : Type*}", "(\u03b1) [Monoid \u03b1]", "{\u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nx\u271d : Sort u_2\nminOrder : x\u271d\nn : \u2115\u221e\n\u22a2 n \u2264 sorry \u2194 \u2200 \u2983a : \u03b1\u2984, a \u2260 1 \u2192 IsOfFinOrder a \u2192 n \u2264 \u2191(orderOf a)"}, {"line": "simp [minOrder]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Monoid \u03b1\nx\u271d : Sort u_2\nminOrder : x\u271d\nn : \u2115\u221e\n\u22a2 n \u2264 sorry () \u2194 \u2200 \u2983a : \u03b1\u2984, \u00aca = 1 \u2192 IsOfFinOrder a \u2192 n \u2264 \u2191(orderOf a)"}]}
{"declaration": "lemma minOrder_of_prime {p : \u2115} (hp : p.Prime) : minOrder (ZMod p) = p := by\n  rw [ZMod.minOrder hp.ne_zero hp.ne_one]\n  rw [hp.minFac_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Order/Min.lean", "context": {"open": ["Subgroup", "AddMonoid AddSubgroup Nat Set"], "variables": ["{\u03b1 : Type*}", "(\u03b1) [Monoid \u03b1]", "{\u03b1} {a : \u03b1}", "[Group \u03b1] {s : Subgroup \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Nat.Prime p\n\u22a2 minOrder (ZMod p) = \u2191p"}, {"line": "rw [ZMod.minOrder hp.ne_zero hp.ne_one]", "tactic_state": "p : \u2115\nhp : Nat.Prime p\n\u22a2 \u2191p.minFac = \u2191p"}, {"line": "rw [hp.minFac_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_smul_oreDiv {r\u2081 : R} {r\u2082 : X} {s\u2081 s\u2082 : S} :\n    (r\u2081 /\u2092 s\u2081) \u2022 (r\u2082 /\u2092 s\u2082) = oreNum r\u2081 s\u2082 \u2022 r\u2082 /\u2092 (oreDenom r\u2081 s\u2082 * s\u2081) := by\n  with_unfolding_all rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nR : Type u_2\ninst\u271d\u00b2 : Monoid R\nS : Submonoid R\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction R X\nr\u2081 : R\nr\u2082 : X\ns\u2081 s\u2082 : \u21a5S\n\u22a2 (r\u2081 /\u2092 s\u2081) \u2022 (r\u2082 /\u2092 s\u2082) = oreNum r\u2081 s\u2082 \u2022 r\u2082 /\u2092 (oreDenom r\u2081 s\u2082 * s\u2081)"}, {"line": "with_unfolding_all rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_mul_oreDiv {r\u2081 : R} {r\u2082 : R} {s\u2081 s\u2082 : S} :\n    (r\u2081 /\u2092 s\u2081) * (r\u2082 /\u2092 s\u2082) = oreNum r\u2081 s\u2082 * r\u2082 /\u2092 (oreDenom r\u2081 s\u2082 * s\u2081) := by\n  with_unfolding_all rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Monoid R\nS : Submonoid R\ninst\u271d : OreSet S\nr\u2081 r\u2082 : R\ns\u2081 s\u2082 : \u21a5S\n\u22a2 r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = oreNum r\u2081 s\u2082 * r\u2082 /\u2092 (oreDenom r\u2081 s\u2082 * s\u2081)"}, {"line": "with_unfolding_all rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_smul_char (r\u2081 : R) (r\u2082 : X) (s\u2081 s\u2082 : S) (r' : R) (s' : S) (huv : s' * r\u2081 = r' * s\u2082) :\n    (r\u2081 /\u2092 s\u2081) \u2022 (r\u2082 /\u2092 s\u2082) = r' \u2022 r\u2082 /\u2092 (s' * s\u2081) := by\n  with_unfolding_all exact smul'_char r\u2081 r\u2082 s\u2081 s\u2082 s' r' huv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nR : Type u_2\ninst\u271d\u00b2 : Monoid R\nS : Submonoid R\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction R X\nr\u2081 : R\nr\u2082 : X\ns\u2081 s\u2082 : \u21a5S\nr' : R\ns' : \u21a5S\nhuv : \u2191s' * r\u2081 = r' * \u2191s\u2082\n\u22a2 (r\u2081 /\u2092 s\u2081) \u2022 (r\u2082 /\u2092 s\u2082) = r' \u2022 r\u2082 /\u2092 (s' * s\u2081)"}, {"line": "with_unfolding_all exact smul'_char r\u2081 r\u2082 s\u2081 s\u2082 s' r' huv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_mul_char (r\u2081 r\u2082 : R) (s\u2081 s\u2082 : S) (r' : R) (s' : S) (huv : s' * r\u2081 = r' * s\u2082) :\n    r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r' * r\u2082 /\u2092 (s' * s\u2081) := by\n  with_unfolding_all exact smul'_char r\u2081 r\u2082 s\u2081 s\u2082 s' r' huv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Monoid R\nS : Submonoid R\ninst\u271d : OreSet S\nr\u2081 r\u2082 : R\ns\u2081 s\u2082 : \u21a5S\nr' : R\ns' : \u21a5S\nhuv : \u2191s' * r\u2081 = r' * \u2191s\u2082\n\u22a2 r\u2081 /\u2092 s\u2081 * (r\u2082 /\u2092 s\u2082) = r' * r\u2082 /\u2092 (s' * s\u2081)"}, {"line": "with_unfolding_all exact smul'_char r\u2081 r\u2082 s\u2081 s\u2082 s' r' huv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_div_one {p : R} {r : X} {s : S} : (p /\u2092 s) \u2022 (r /\u2092 1) = (p \u2022 r) /\u2092 s := by\n  simp [oreDiv_smul_char p r s 1 p 1 (by simp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nR : Type u_2\ninst\u271d\u00b2 : Monoid R\nS : Submonoid R\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction R X\np : R\nr : X\ns : \u21a5S\n\u22a2 (p /\u2092 s) \u2022 (r /\u2092 1) = p \u2022 r /\u2092 s"}, {"line": "simp [oreDiv_smul_char p r s 1 p 1 (by simp)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_div_one {p r : R} {s : S} : (p /\u2092 s) * (r /\u2092 1) = (p * r) /\u2092 s := by\n  --TODO use coercion r \u21a6 r /\u2092 1\n  simp [oreDiv_mul_char p r s 1 p 1 (by simp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b9 : Monoid R\nS : Submonoid R\ninst\u271d : OreSet S\np r : R\ns : \u21a5S\n\u22a2 p /\u2092 s * (r /\u2092 1) = p * r /\u2092 s"}, {"line": "simp [oreDiv_mul_char p r s 1 p 1 (by simp)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem universalMulHom_commutes {r : R} : universalMulHom f fS hf (numeratorHom r) = f r := by\n  simp [numeratorHom_apply, universalMulHom_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]", "{T : Type*} [Monoid T]", "(f : R \u2192* T) (fS : S \u2192* Units T)", "(hf : \u2200 s : S, f s = fS s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\ninst\u271d\u00b2 : Monoid R\nS : Submonoid R\ninst\u271d\u00b9 : OreSet S\nT : Type u_3\ninst\u271d : Monoid T\nf : R \u2192* T\nfS : \u21a5S \u2192* T\u02e3\nhf : \u2200 (s : \u21a5S), f \u2191s = \u2191(fS s)\nr : R\n\u22a2 (universalMulHom f fS hf) (numeratorHom r) = f r"}, {"line": "simp [numeratorHom_apply, universalMulHom_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_oreDiv (r : R) (x : X) (s : S) :\n    r \u2022 (x /\u2092 s) = oreNum (r \u2022 1) s \u2022 x /\u2092 oreDenom (r \u2022 1) s := by with_unfolding_all rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]", "{T : Type*} [Monoid T]", "(f : R \u2192* T) (fS : S \u2192* Units T)", "(hf : \u2200 s : S, f s = fS s)", "{R R' M X : Type*} [Monoid M] {S : Submonoid M} [OreSet S] [MulAction M X]", "[SMul R X] [SMul R M] [IsScalarTower R M M] [IsScalarTower R M X]", "[SMul R' X] [SMul R' M] [IsScalarTower R' M M] [IsScalarTower R' M X]", "[SMul R R'] [IsScalarTower R R' M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\ns : \u21a5S\n\u22a2 r \u2022 (x /\u2092 s) = oreNum (r \u2022 1) s \u2022 x /\u2092 oreDenom (r \u2022 1) s"}, {"line": "with_unfolding_all rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oreDiv_one_smul (r : M) (x : X[S\u207b\u00b9]) : (r /\u2092 (1 : S)) \u2022 x = r \u2022 x := by\n  induction' x using OreLocalization.ind with r' s\n  rw [smul_oreDiv]\n  rw [oreDiv_smul_oreDiv]\n  rw [mul_one]\n  rw [smul_eq_mul]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]", "{T : Type*} [Monoid T]", "(f : R \u2192* T) (fS : S \u2192* Units T)", "(hf : \u2200 s : S, f s = fS s)", "{R R' M X : Type*} [Monoid M] {S : Submonoid M} [OreSet S] [MulAction M X]", "[SMul R X] [SMul R M] [IsScalarTower R M M] [IsScalarTower R M X]", "[SMul R' X] [SMul R' M] [IsScalarTower R' M M] [IsScalarTower R' M X]", "[SMul R R'] [IsScalarTower R R' M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nx : OreLocalization S X\n\u22a2 (r /\u2092 1) \u2022 x = r \u2022 x"}, {"line": "induction' x using OreLocalization.ind with r' s", "tactic_state": "case c\nM : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nr' : X\ns : \u21a5S\n\u22a2 (r /\u2092 1) \u2022 (r' /\u2092 s) = r \u2022 (r' /\u2092 s)"}, {"line": "rw [smul_oreDiv]", "tactic_state": "case c\nM : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nr' : X\ns : \u21a5S\n\u22a2 (r /\u2092 1) \u2022 (r' /\u2092 s) = oreNum (r \u2022 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1) s"}, {"line": "rw [oreDiv_smul_oreDiv]", "tactic_state": "case c\nM : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nr' : X\ns : \u21a5S\n\u22a2 oreNum r s \u2022 r' /\u2092 (oreDenom r s * 1) = oreNum (r \u2022 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1) s"}, {"line": "rw [mul_one]", "tactic_state": "case c\nM : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nr' : X\ns : \u21a5S\n\u22a2 oreNum r s \u2022 r' /\u2092 oreDenom r s = oreNum (r \u2022 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1) s"}, {"line": "rw [smul_eq_mul]", "tactic_state": "case c\nM : Type u_6\nX : Type u_7\ninst\u271d\u00b2 : Monoid M\nS : Submonoid M\ninst\u271d\u00b9 : OreSet S\ninst\u271d : MulAction M X\nr : M\nr' : X\ns : \u21a5S\n\u22a2 oreNum r s \u2022 r' /\u2092 oreDenom r s = oreNum (r * 1) s \u2022 r' /\u2092 oreDenom (r * 1) s"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_one_smul (r : R) (x : X[S\u207b\u00b9]) : (r \u2022 1 : M) \u2022 x = r \u2022 x := by\n  induction' x using OreLocalization.ind with r' s\n  simp only [smul_oreDiv]\n  simp only [smul_eq_mul]\n  simp only [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]", "{T : Type*} [Monoid T]", "(f : R \u2192* T) (fS : S \u2192* Units T)", "(hf : \u2200 s : S, f s = fS s)", "{R R' M X : Type*} [Monoid M] {S : Submonoid M} [OreSet S] [MulAction M X]", "[SMul R X] [SMul R M] [IsScalarTower R M M] [IsScalarTower R M X]", "[SMul R' X] [SMul R' M] [IsScalarTower R' M M] [IsScalarTower R' M X]", "[SMul R R'] [IsScalarTower R R' M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : OreLocalization S X\n\u22a2 (r \u2022 1) \u2022 x = r \u2022 x"}, {"line": "induction' x using OreLocalization.ind with r' s", "tactic_state": "case c\nR : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nr' : X\ns : \u21a5S\n\u22a2 (r \u2022 1) \u2022 (r' /\u2092 s) = r \u2022 (r' /\u2092 s)"}, {"line": "simp only [smul_oreDiv]", "tactic_state": "case c\nR : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nr' : X\ns : \u21a5S\n\u22a2 oreNum ((r \u2022 1) \u2022 1) s \u2022 r' /\u2092 oreDenom ((r \u2022 1) \u2022 1) s = oreNum (r \u2022 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1) s"}, {"line": "simp only [smul_eq_mul]", "tactic_state": "case c\nR : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nr' : X\ns : \u21a5S\n\u22a2 oreNum (r \u2022 1 * 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1 * 1) s = oreNum (r \u2022 1) s \u2022 r' /\u2092 oreDenom (r \u2022 1) s"}, {"line": "simp only [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_oreDiv_one (r : R) (x : X) : r \u2022 (x /\u2092 (1 : S)) = (r \u2022 x) /\u2092 (1 : S) := by\n  rw [\u2190 smul_one_oreDiv_one_smul]\n  rw [smul_div_one]\n  rw [smul_assoc]\n  rw [one_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/OreLocalization/Basic.lean", "context": {"open": ["OreLocalization"], "variables": ["{R : Type*} [Monoid R] (S : Submonoid R) [OreSet S] (X) [MulAction R X]", "(R : Type*) [Monoid R] (S : Submonoid R) [OreSet S]", "{R S}", "{X} [MulAction R X]", "{T : Type*} [Monoid T]", "(f : R \u2192* T) (fS : S \u2192* Units T)", "(hf : \u2200 s : S, f s = fS s)", "{R R' M X : Type*} [Monoid M] {S : Submonoid M} [OreSet S] [MulAction M X]", "[SMul R X] [SMul R M] [IsScalarTower R M M] [IsScalarTower R M X]", "[SMul R' X] [SMul R' M] [IsScalarTower R' M M] [IsScalarTower R' M X]", "[SMul R R'] [IsScalarTower R R' M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 r \u2022 (x /\u2092 1) = r \u2022 x /\u2092 1"}, {"line": "rw [\u2190 smul_one_oreDiv_one_smul]", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 (r \u2022 1 /\u2092 1) \u2022 (x /\u2092 1) = r \u2022 x /\u2092 1"}, {"line": "rw [smul_div_one]", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 (r \u2022 1) \u2022 x /\u2092 1 = r \u2022 x /\u2092 1"}, {"line": "rw [smul_assoc]", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 r \u2022 1 \u2022 x /\u2092 1 = r \u2022 x /\u2092 1\n---\nR : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 SMul R X\n---\nR : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 IsScalarTower R M X"}, {"line": "rw [one_smul]", "tactic_state": "R : Type u_4\nM : Type u_6\nX : Type u_7\ninst\u271d\u2076 : Monoid M\nS : Submonoid M\ninst\u271d\u2075 : OreSet S\ninst\u271d\u2074 : MulAction M X\ninst\u271d\u00b3 : SMul R X\ninst\u271d\u00b2 : SMul R M\ninst\u271d\u00b9 : IsScalarTower R M M\ninst\u271d : IsScalarTower R M X\nr : R\nx : X\n\u22a2 IsScalarTower R M X"}]}
{"declaration": "theorem swap_smul_self_smul [MulAction (Perm \u03b1) \u03b2] (i j : \u03b1) (x : \u03b2) :\n    swap i j \u2022 swap i j \u2022 x = x := by simp [smul_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_1\nPerm : x\u271d\u00b9\nx\u271d : Sort u_2\nswap : x\u271d\ninst\u271d : MulAction sorry \u03b2\ni j : \u03b1\nx : \u03b2\n\u22a2 sorry \u2022 sorry \u2022 x = x"}, {"line": "simp [smul_smul]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_1\nPerm : x\u271d\u00b9\nx\u271d : Sort u_2\nswap : x\u271d\ninst\u271d : MulAction sorry \u03b2\ni j : \u03b1\nx : \u03b2\n\u22a2 sorry () \u2022 sorry () \u2022 x = x"}]}
{"declaration": "theorem nonempty (g : Perm \u03b1) : Nonempty (Basis g) := by\n  have (c : g.cycleFactorsFinset) : c.val.support.Nonempty :=\n    IsCycle.nonempty_support (mem_cycleFactorsFinset_iff.mp c.prop).1\n  exact \u27e8fun c \u21a6 (this c).choose, fun c \u21a6 (this c).choose_spec\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Centralizer.lean", "context": {"open": ["scoped Finset Pointwise", "MulAction Equiv Subgroup", "OnCycleFactors Subgroup"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {g : Equiv.Perm \u03b1}", "(g)", "{g} in", "{g} in", "(k : centralizer {g})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng : Perm \u03b1\n\u22a2 Nonempty sorry"}, {"line": "have (c : g.cycleFactorsFinset) : c.val.support.Nonempty :=\n    IsCycle.nonempty_support (mem_cycleFactorsFinset_iff.mp c.prop).1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng : Perm \u03b1\nthis : sorry \u2192 sorry\n\u22a2 Nonempty sorry"}, {"line": "exact \u27e8fun c \u21a6 (this c).choose, fun c \u21a6 (this c).choose_spec\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_of_cycleType (m : Multiset \u2115) :\n    #({g | g.cycleType = m} : Finset (Perm \u03b1)) =\n      if m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a then\n        (Fintype.card \u03b1)! /\n          ((Fintype.card \u03b1 - m.sum)! * m.prod * (\u220f n \u2208 m.toFinset, (m.count n)!))\n      else 0 := by\n  split_ifs with hm\n  \u00b7 -- nonempty case\n    apply symm\n    apply Nat.div_eq_of_eq_mul_left\n    \u00b7 have : 0 < m.prod := Multiset.prod_pos <| fun a ha => zero_lt_two.trans_le (hm.2 a ha)\n      positivity\n    rw [card_of_cycleType_mul_eq]\n    rw [if_pos hm]\n  \u00b7 -- empty case\n    exact (card_of_cycleType_eq_zero_iff \u03b1).mpr hm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Centralizer.lean", "context": {"open": ["scoped Finset Pointwise", "MulAction Equiv Subgroup", "OnCycleFactors Subgroup", "Basis BigOperators Nat Equiv.Perm Equiv Subgroup", "BigOperators Nat OnCycleFactors Subgroup", "Equiv Function MulAction Finset", "Nat"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] {g : Equiv.Perm \u03b1}", "(g)", "{g} in", "{g} in", "(k : centralizer {g})", "(a : Basis g) (c : g.cycleFactorsFinset)", "(\u03c4 : range_toPermHom' g)", "(g) in", "{a : Type*} (g : Perm \u03b1) (k : Perm (fixedPoints g))", "(g : Perm \u03b1)", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\n\u22a2 {g | g.cycleType = m}.card =\n    if m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a then\n      (Fintype.card \u03b1).factorial /\n        ((Fintype.card \u03b1 - m.sum).factorial * m.prod * \u220f n \u2208 m.toFinset, (Multiset.count n m).factorial)\n    else 0"}, {"line": "split_ifs with hm", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\nhm : m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a\n\u22a2 {g | g.cycleType = m}.card =\n    (Fintype.card \u03b1).factorial /\n      ((Fintype.card \u03b1 - m.sum).factorial * m.prod * \u220f n \u2208 m.toFinset, (Multiset.count n m).factorial)\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\nhm : \u00ac(m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a)\n\u22a2 {g | g.cycleType = m}.card = 0"}, {"line": "\u00b7 -- nonempty case\n    apply symm\n    apply Nat.div_eq_of_eq_mul_left\n    \u00b7 have : 0 < m.prod := Multiset.prod_pos <| fun a ha => zero_lt_two.trans_le (hm.2 a ha)\n      positivity\n    rw [card_of_cycleType_mul_eq]\n    rw [if_pos hm]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nm : Multiset \u2115\nhm : \u00ac(m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a)\n\u22a2 {g | g.cycleType = m}.card = 0"}, {"line": "\u00b7 -- empty case\n    exact (card_of_cycleType_eq_zero_iff \u03b1).mpr hm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.IsSwap.finite_compl_fixedBy {\u03c3 : Perm \u03b1} (h : \u03c3.IsSwap) :\n    (fixedBy \u03b1 \u03c3)\u1d9c.Finite := by\n  obtain \u27e8x, y, -, rfl\u27e9 := h\n  exact finite_compl_fixedBy_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/ClosureSwap.lean", "context": {"open": ["Equiv List MulAction Pointwise Set Subgroup"], "variables": ["{G \u03b1 : Type*} [Group G] [MulAction G \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Perm \u03b1\nh : \u03c3.IsSwap\n\u22a2 (fixedBy \u03b1 \u03c3)\u1d9c.Finite"}, {"line": "obtain \u27e8x, y, -, rfl\u27e9 := h", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 (fixedBy \u03b1 (swap x y))\u1d9c.Finite"}, {"line": "exact finite_compl_fixedBy_swap", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_of_isSwap_of_isPretransitive [Finite \u03b1] {S : Set (Perm \u03b1)} (hS : \u2200 \u03c3 \u2208 S, \u03c3.IsSwap)\n    [MulAction.IsPretransitive (Subgroup.closure S) \u03b1] : Subgroup.closure S = \u22a4 := by\n  simp [eq_top_iff', mem_closure_isSwap hS, orbit_eq_univ, Set.toFinite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/ClosureSwap.lean", "context": {"open": ["Equiv List MulAction Pointwise Set Subgroup"], "variables": ["{G \u03b1 : Type*} [Group G] [MulAction G \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Finite \u03b1\nS : Set (Equiv.Perm \u03b1)\nhS : \u2200 \u03c3 \u2208 S, \u03c3.IsSwap\ninst\u271d : IsPretransitive (\u21a5(Subgroup.closure S)) \u03b1\n\u22a2 Subgroup.closure S = \u22a4"}, {"line": "simp [eq_top_iff', mem_closure_isSwap hS, orbit_eq_univ, Set.toFinite]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Finite \u03b1\nS : Set (Equiv.Perm \u03b1)\nhS : \u2200 \u03c3 \u2208 S, \u03c3.IsSwap\ninst\u271d : IsPretransitive (\u21a5(Subgroup.closure S)) \u03b1\n\u22a2 \u2200 (x : Equiv.Perm \u03b1), x \u2208 Subgroup.closure S"}]}
{"declaration": "theorem Equiv.Perm.decomposeFin_symm_of_refl {n : \u2115} (p : Fin (n + 1)) :\n    Equiv.Perm.decomposeFin.symm (p, Equiv.refl _) = swap 0 p := by\n  simp [Equiv.Perm.decomposeFin, Equiv.permCongr_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\n\u22a2 decomposeFin.symm (p, Equiv.refl (Fin n)) = swap 0 p"}, {"line": "simp [Equiv.Perm.decomposeFin, Equiv.permCongr_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.decomposeFin_symm_apply_zero {n : \u2115} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 0 = p := by simp [Equiv.Perm.decomposeFin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ne : Perm (Fin n)\n\u22a2 (decomposeFin.symm (p, e)) 0 = p"}, {"line": "simp [Equiv.Perm.decomposeFin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.decomposeFin_symm_apply_one {n : \u2115} (e : Perm (Fin (n + 1))) (p : Fin (n + 2)) :\n    Equiv.Perm.decomposeFin.symm (p, e) 1 = swap 0 p (e 0).succ := by\n  rw [\u2190 Fin.succ_zero_eq_one]\n  rw [Equiv.Perm.decomposeFin_symm_apply_succ e p 0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ne : Perm (Fin (n + 1))\np : Fin (n + 2)\n\u22a2 (decomposeFin.symm (p, e)) 1 = (swap 0 p) (e 0).succ"}, {"line": "rw [\u2190 Fin.succ_zero_eq_one]", "tactic_state": "n : \u2115\ne : Perm (Fin (n + 1))\np : Fin (n + 2)\n\u22a2 (decomposeFin.symm (p, e)) (Fin.succ 0) = (swap 0 p) (e 0).succ"}, {"line": "rw [Equiv.Perm.decomposeFin_symm_apply_succ e p 0]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.decomposeFin.symm_sign {n : \u2115} (p : Fin (n + 1)) (e : Perm (Fin n)) :\n    Perm.sign (Equiv.Perm.decomposeFin.symm (p, e)) = ite (p = 0) 1 (-1) * Perm.sign e := by\n  refine Fin.cases ?_ ?_ p <;> simp [Equiv.Perm.decomposeFin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : Fin (n + 1)\ne : Perm (Fin n)\n\u22a2 sign (decomposeFin.symm (p, e)) = (if p = 0 then 1 else -1) * sign e"}, {"line": "refine Fin.cases ?_ ?_ p <;> simp [Equiv.Perm.decomposeFin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_finRotate {n : \u2115} : support (finRotate (n + 2)) = Finset.univ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (finRotate (n + 2)).support = Finset.univ"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\na\u271d : Fin (n + 2)\n\u22a2 a\u271d \u2208 (finRotate (n + 2)).support \u2194 a\u271d \u2208 Finset.univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : support (finRotate n) = Finset.univ := by\n  obtain \u27e8m, rfl\u27e9 := exists_add_of_le h\n  rw [add_comm]\n  rw [support_finRotate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 2 \u2264 n\n\u22a2 (finRotate n).support = Finset.univ"}, {"line": "obtain \u27e8m, rfl\u27e9 := exists_add_of_le h", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (2 + m)).support = Finset.univ"}, {"line": "rw [add_comm]", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (m + 2)).support = Finset.univ"}, {"line": "rw [support_finRotate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCycle_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : IsCycle (finRotate n) := by\n  obtain \u27e8m, rfl\u27e9 := exists_add_of_le h\n  rw [add_comm]\n  exact isCycle_finRotate\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 2 \u2264 n\n\u22a2 (finRotate n).IsCycle"}, {"line": "obtain \u27e8m, rfl\u27e9 := exists_add_of_le h", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (2 + m)).IsCycle"}, {"line": "rw [add_comm]", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (m + 2)).IsCycle"}, {"line": "exact isCycle_finRotate", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleType_finRotate {n : \u2115} : cycleType (finRotate (n + 2)) = {n + 2} := by\n  rw [isCycle_finRotate.cycleType]\n  rw [support_finRotate]\n  rw [\u2190 Fintype.card]\n  rw [Fintype.card_fin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (finRotate (n + 2)).cycleType = {n + 2}"}, {"line": "rw [isCycle_finRotate.cycleType]", "tactic_state": "n : \u2115\n\u22a2 {(finRotate (n + 2)).support.card} = {n + 2}"}, {"line": "rw [support_finRotate]", "tactic_state": "n : \u2115\n\u22a2 {Finset.univ.card} = {n + 2}"}, {"line": "rw [\u2190 Fintype.card]", "tactic_state": "n : \u2115\n\u22a2 {Fintype.card (Fin (n + 2))} = {n + 2}"}, {"line": "rw [Fintype.card_fin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleType_finRotate_of_le {n : \u2115} (h : 2 \u2264 n) : cycleType (finRotate n) = {n} := by\n  obtain \u27e8m, rfl\u27e9 := exists_add_of_le h\n  rw [add_comm]\n  rw [cycleType_finRotate]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 2 \u2264 n\n\u22a2 (finRotate n).cycleType = {n}"}, {"line": "obtain \u27e8m, rfl\u27e9 := exists_add_of_le h", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (2 + m)).cycleType = {2 + m}"}, {"line": "rw [add_comm]", "tactic_state": "case intro\nm : \u2115\nh : 2 \u2264 2 + m\n\u22a2 (finRotate (m + 2)).cycleType = {m + 2}"}, {"line": "rw [cycleType_finRotate]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_cycleRange {n : \u2115} (i : Fin n) : Perm.sign (cycleRange i) = (-1) ^ (i : \u2115) := by\n  simp [cycleRange]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncycleRange : x\u271d\nn : \u2115\ni : Fin n\n\u22a2 sign sorry = (-1) ^ \u2191i"}, {"line": "simp [cycleRange]", "tactic_state": "x\u271d : Sort u_1\ncycleRange : x\u271d\nn : \u2115\ni : Fin n\n\u22a2 sign (sorry ()) = (-1) ^ \u2191i"}]}
{"declaration": "theorem cycleRange_succAbove {n : \u2115} (i : Fin (n + 1)) (j : Fin n) :\n    i.cycleRange (i.succAbove j) = j.succ := by\n  rcases lt_or_ge (castSucc j) i with h | h\n  \u00b7 rw [Fin.succAbove_of_castSucc_lt _ _ h, Fin.cycleRange_of_lt h, Fin.coeSucc_eq_succ]\n  \u00b7 rw [Fin.succAbove_of_le_castSucc _ _ h, Fin.cycleRange_of_gt (Fin.le_castSucc_iff.mp h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ni : Fin (n + 1)\nj : Fin n\n\u22a2 i.cycleRange (i.succAbove j) = j.succ"}, {"line": "rcases lt_or_ge (castSucc j) i with h | h", "tactic_state": "case inl\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : sorry < i\n\u22a2 i.cycleRange (i.succAbove j) = j.succ\n---\ncase inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : sorry \u2265 i\n\u22a2 i.cycleRange (i.succAbove j) = j.succ"}, {"line": "\u00b7 rw [Fin.succAbove_of_castSucc_lt _ _ h, Fin.cycleRange_of_lt h, Fin.coeSucc_eq_succ]", "tactic_state": "case inr\nn : \u2115\ni : Fin (n + 1)\nj : Fin n\nh : sorry \u2265 i\n\u22a2 i.cycleRange (i.succAbove j) = j.succ"}, {"line": "\u00b7 rw [Fin.succAbove_of_le_castSucc _ _ h, Fin.cycleRange_of_gt (Fin.le_castSucc_iff.mp h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.sign_eq_prod_prod_Iio (\u03c3 : Equiv.Perm (Fin n)) :\n    \u03c3.sign = \u220f j, \u220f i \u2208 Finset.Iio j, (if \u03c3 i < \u03c3 j then 1 else -1) := by\n  suffices h : \u03c3.sign = \u03c3.signAux by\n    rw [h]\n    rw [Finset.prod_sigma']\n    rw [Equiv.Perm.signAux]\n    convert rfl using 2 with x hx\n    \u00b7 simp [Finset.ext_iff, Equiv.Perm.mem_finPairsLT]\n    simp [not_lt, \u2190 ite_not (p := _ \u2264 _)]\n  refine \u03c3.swap_induction_on (by simp) fun \u03c0 i j hne h_eq \u21a6 ?_\n  rw [Equiv.Perm.signAux_mul]\n  rw [Equiv.Perm.sign_mul]\n  rw [h_eq]\n  rw [Equiv.Perm.sign_swap hne]\n  rw [Equiv.Perm.signAux_swap hne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 sign \u03c3 = \u220f j, \u220f i \u2208 Finset.Iio j, if \u03c3 i < \u03c3 j then 1 else -1"}, {"line": "suffices h : \u03c3.sign = \u03c3.signAux by\n    rw [h]\n    rw [Finset.prod_sigma']\n    rw [Equiv.Perm.signAux]\n    convert rfl using 2 with x hx\n    \u00b7 simp [Finset.ext_iff, Equiv.Perm.mem_finPairsLT]\n    simp [not_lt, \u2190 ite_not (p := _ \u2264 _)]", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 sign \u03c3 = \u03c3.signAux"}, {"line": "refine \u03c3.swap_induction_on (by simp) fun \u03c0 i j hne h_eq \u21a6 ?_", "tactic_state": "n : \u2115\n\u03c3 \u03c0 : Perm (Fin n)\ni j : Fin n\nhne : i \u2260 j\nh_eq : sign \u03c0 = \u03c0.signAux\n\u22a2 sign (swap i j * \u03c0) = (swap i j * \u03c0).signAux"}, {"line": "rw [Equiv.Perm.signAux_mul]", "tactic_state": "n : \u2115\n\u03c3 \u03c0 : Perm (Fin n)\ni j : Fin n\nhne : i \u2260 j\nh_eq : sign \u03c0 = \u03c0.signAux\n\u22a2 sign (swap i j * \u03c0) = (swap i j).signAux * \u03c0.signAux"}, {"line": "rw [Equiv.Perm.sign_mul]", "tactic_state": "n : \u2115\n\u03c3 \u03c0 : Perm (Fin n)\ni j : Fin n\nhne : i \u2260 j\nh_eq : sign \u03c0 = \u03c0.signAux\n\u22a2 sign (swap i j) * sign \u03c0 = (swap i j).signAux * \u03c0.signAux"}, {"line": "rw [h_eq]", "tactic_state": "n : \u2115\n\u03c3 \u03c0 : Perm (Fin n)\ni j : Fin n\nhne : i \u2260 j\nh_eq : sign \u03c0 = \u03c0.signAux\n\u22a2 sign (swap i j) * \u03c0.signAux = (swap i j).signAux * \u03c0.signAux"}, {"line": "rw [Equiv.Perm.sign_swap hne]", "tactic_state": "n : \u2115\n\u03c3 \u03c0 : Perm (Fin n)\ni j : Fin n\nhne : i \u2260 j\nh_eq : sign \u03c0 = \u03c0.signAux\n\u22a2 -1 * \u03c0.signAux = (swap i j).signAux * \u03c0.signAux"}, {"line": "rw [Equiv.Perm.signAux_swap hne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.sign_eq_prod_prod_Ioi (\u03c3 : Equiv.Perm (Fin n)) :\n    \u03c3.sign = \u220f i, \u220f j \u2208 Finset.Ioi i, (if \u03c3 i < \u03c3 j then 1 else -1) := by\n  rw [\u03c3.sign_eq_prod_prod_Iio]\n  apply Finset.prod_comm' (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 sign \u03c3 = \u220f i, \u220f j \u2208 Finset.Ioi i, if \u03c3 i < \u03c3 j then 1 else -1"}, {"line": "rw [\u03c3.sign_eq_prod_prod_Iio]", "tactic_state": "n : \u2115\n\u03c3 : Perm (Fin n)\n\u22a2 (\u220f j, \u220f i \u2208 Finset.Iio j, if \u03c3 i < \u03c3 j then 1 else -1) = \u220f i, \u220f j \u2208 Finset.Ioi i, if \u03c3 i < \u03c3 j then 1 else -1"}, {"line": "apply Finset.prod_comm' (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.prod_Ioi_comp_eq_sign_mul_prod {R : Type*} [CommRing R]\n    (\u03c3 : Equiv.Perm (Fin n)) {f : Fin n \u2192 Fin n \u2192 R} (hf : \u2200 i j, f i j = -f j i) :\n    \u220f i, \u220f j \u2208 Finset.Ioi i, f (\u03c3 i) (\u03c3 j) = \u03c3.sign * \u220f i, \u220f j \u2208 Finset.Ioi i, f i j := by\n  convert \u03c3.prod_Iio_comp_eq_sign_mul_prod hf using 1\n  \u00b7 apply Finset.prod_comm' (by simp)\n  convert rfl using 2\n  apply Finset.prod_comm' (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Fin.lean", "context": {"open": ["Equiv", "Equiv.Perm"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d : CommRing R\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 Fin n \u2192 R\nhf : \u2200 (i j : Fin n), f i j = -f j i\n\u22a2 \u220f i, \u220f j \u2208 Finset.Ioi i, f (\u03c3 i) (\u03c3 j) = \u2191\u2191(sign \u03c3) * \u220f i, \u220f j \u2208 Finset.Ioi i, f i j"}, {"line": "convert \u03c3.prod_Iio_comp_eq_sign_mul_prod hf using 1", "tactic_state": "case h.e'_2\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 Fin n \u2192 R\nhf : \u2200 (i j : Fin n), f i j = -f j i\n\u22a2 \u220f i, \u220f j \u2208 Finset.Ioi i, f (\u03c3 i) (\u03c3 j) = \u220f j, \u220f i \u2208 Finset.Iio j, f (\u03c3 i) (\u03c3 j)\n---\ncase h.e'_3\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 Fin n \u2192 R\nhf : \u2200 (i j : Fin n), f i j = -f j i\n\u22a2 \u2191\u2191(sign \u03c3) * \u220f i, \u220f j \u2208 Finset.Ioi i, f i j = \u2191\u2191(sign \u03c3) * \u220f j, \u220f i \u2208 Finset.Iio j, f i j"}, {"line": "\u00b7 apply Finset.prod_comm' (by simp)", "tactic_state": "case h.e'_3\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 Fin n \u2192 R\nhf : \u2200 (i j : Fin n), f i j = -f j i\n\u22a2 \u2191\u2191(sign \u03c3) * \u220f i, \u220f j \u2208 Finset.Ioi i, f i j = \u2191\u2191(sign \u03c3) * \u220f j, \u220f i \u2208 Finset.Iio j, f i j"}, {"line": "convert rfl using 2", "tactic_state": "case h.e'_3.h.e'_6\nn : \u2115\nR : Type u_1\ninst\u271d : CommRing R\n\u03c3 : Perm (Fin n)\nf : Fin n \u2192 Fin n \u2192 R\nhf : \u2200 (i j : Fin n), f i j = -f j i\n\u22a2 \u220f j, \u220f i \u2208 Finset.Iio j, f i j = \u220f i, \u220f j \u2208 Finset.Ioi i, f i j"}, {"line": "apply Finset.prod_comm' (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem perm_inv_on_of_perm_on_finset {s : Finset \u03b1} {f : Perm \u03b1} (h : \u2200 x \u2208 s, f x \u2208 s) {y : \u03b1}\n    (hy : y \u2208 s) : f\u207b\u00b9 y \u2208 s := by\n  have h0 : \u2200 y \u2208 s, \u2203 (x : _) (hx : x \u2208 s), y = (fun i (_ : i \u2208 s) => f i) x hx :=\n    Finset.surj_on_of_inj_on_of_card_le (fun x hx => (fun i _ => f i) x hx) (fun a ha => h a ha)\n      (fun a\u2081 a\u2082 ha\u2081 ha\u2082 heq => (Equiv.apply_eq_iff_eq f).mp heq) rfl.ge\n  obtain \u27e8y2, hy2, heq\u27e9 := h0 y hy\n  convert hy2\n  rw [heq]\n  simp only [inv_apply_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Finite.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03c3 \u03c4 : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\n\u22a2 f\u207b\u00b9 y \u2208 s"}, {"line": "have h0 : \u2200 y \u2208 s, \u2203 (x : _) (hx : x \u2208 s), y = (fun i (_ : i \u2208 s) => f i) x hx :=\n    Finset.surj_on_of_inj_on_of_card_le (fun x hx => (fun i _ => f i) x hx) (fun a ha => h a ha)\n      (fun a\u2081 a\u2082 ha\u2081 ha\u2082 heq => (Equiv.apply_eq_iff_eq f).mp heq) rfl.ge", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\n\u22a2 f\u207b\u00b9 y \u2208 s"}, {"line": "obtain \u27e8y2, hy2, heq\u27e9 := h0 y hy", "tactic_state": "case intro.intro\n\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y \u2208 s"}, {"line": "convert hy2", "tactic_state": "case h.e'_5\n\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 y = y2"}, {"line": "rw [heq]", "tactic_state": "case h.e'_5\n\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 ((fun i x => f i) y2 hy2) = y2"}, {"line": "simp only [inv_apply_self]", "tactic_state": "case h.e'_5\n\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\nf : Perm \u03b1\nh : \u2200 x \u2208 s, f x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nh0 : \u2200 y \u2208 s, \u2203 x, \u2203 (hx : x \u2208 s), y = (fun i x => f i) x hx\ny2 : \u03b1\nhy2 : y2 \u2208 s\nheq : y = (fun i x => f i) y2 hy2\n\u22a2 f\u207b\u00b9 (f y2) = y2"}]}
{"declaration": "lemma support_closure_subset_union (S : Set (Perm \u03b1)) :\n    \u2200 a \u2208 closure S, (a.support : Set \u03b1) \u2286 \u22c3 b \u2208 S, b.support := by\n  apply closure_induction\n  \u00b7 exact fun x hx \u21a6 Set.subset_iUnion\u2082_of_subset x hx subset_rfl\n  \u00b7 simp only [support_one, Finset.coe_empty, Set.empty_subset]\n  \u00b7 intro a b ha hb hc hd\n    refine (Finset.coe_subset.mpr (support_mul_le a b)).trans ?_\n    rw [Finset.sup_eq_union]\n    rw [Finset.coe_union]\n    rw [Set.union_subset_iff]\n    exact \u27e8hc, hd\u27e9\n  \u00b7 simp only [support_inv, imp_self, implies_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Finite.lean", "context": {"open": ["Equiv Function Fintype Finset", "Subgroup"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v}", "[DecidableEq \u03b1] [Fintype \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "[DecidableEq \u03b1]", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 a \u2208 Subgroup.closure S, \u2191a.support \u2286 \u22c3 b \u2208 S, \u2191b.support"}, {"line": "apply closure_induction", "tactic_state": "case mem\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 x \u2208 S, \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase one\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2191(Perm.support 1) \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase mul\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 (x y : Perm \u03b1),\n    x \u2208 Subgroup.closure S \u2192\n      y \u2208 Subgroup.closure S \u2192\n        \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191y.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191(x * y).support \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase inv\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 x \u2208 Subgroup.closure S, \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191x\u207b\u00b9.support \u2286 \u22c3 b \u2208 S, \u2191b.support"}, {"line": "\u00b7 exact fun x hx \u21a6 Set.subset_iUnion\u2082_of_subset x hx subset_rfl", "tactic_state": "case one\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2191(Perm.support 1) \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase mul\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 (x y : Perm \u03b1),\n    x \u2208 Subgroup.closure S \u2192\n      y \u2208 Subgroup.closure S \u2192\n        \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191y.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191(x * y).support \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase inv\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 x \u2208 Subgroup.closure S, \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191x\u207b\u00b9.support \u2286 \u22c3 b \u2208 S, \u2191b.support"}, {"line": "\u00b7 simp only [support_one, Finset.coe_empty, Set.empty_subset]", "tactic_state": "case mul\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 (x y : Perm \u03b1),\n    x \u2208 Subgroup.closure S \u2192\n      y \u2208 Subgroup.closure S \u2192\n        \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191y.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191(x * y).support \u2286 \u22c3 b \u2208 S, \u2191b.support\n---\ncase inv\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 x \u2208 Subgroup.closure S, \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191x\u207b\u00b9.support \u2286 \u22c3 b \u2208 S, \u2191b.support"}, {"line": "\u00b7 intro a b ha hb hc hd\n    refine (Finset.coe_subset.mpr (support_mul_le a b)).trans ?_\n    rw [Finset.sup_eq_union]\n    rw [Finset.coe_union]\n    rw [Set.union_subset_iff]\n    exact \u27e8hc, hd\u27e9", "tactic_state": "case inv\n\u03b1 : Type u\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nS : Set (Perm \u03b1)\n\u22a2 \u2200 x \u2208 Subgroup.closure S, \u2191x.support \u2286 \u22c3 b \u2208 S, \u2191b.support \u2192 \u2191x\u207b\u00b9.support \u2286 \u22c3 b \u2208 S, \u2191b.support"}, {"line": "\u00b7 simp only [support_inv, imp_self, implies_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_formPerm_apply_ne (h : l.formPerm x \u2260 x) : x \u2208 l := by\n  simpa [or_iff_left_of_imp mem_of_mem_tail] using mem_or_mem_of_zipWith_swap_prod_ne h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : List \u03b1\nx : \u03b1\nh : l.formPerm x \u2260 x\n\u22a2 x \u2208 l"}, {"line": "simpa [or_iff_left_of_imp mem_of_mem_tail] using mem_or_mem_of_zipWith_swap_prod_ne h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem formPerm_cons_concat_apply_last (x y : \u03b1) (xs : List \u03b1) :\n    formPerm (x :: (xs ++ [y])) y = x := by\n  induction' xs with z xs IH generalizing x y\n  \u00b7 simp\n  \u00b7 simp [IH]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nx y : \u03b1\nxs : List \u03b1\n\u22a2 sorry = x"}, {"line": "induction' xs with z xs IH generalizing x y", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nx y : \u03b1\n\u22a2 sorry = x\n---\ncase cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nz : \u03b1\nxs : List \u03b1\nIH : \u2200 (x : \u03b1), \u03b1 \u2192 sorry = x\nx y : \u03b1\n\u22a2 sorry = x"}, {"line": "\u00b7 simp", "tactic_state": "case cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nz : \u03b1\nxs : List \u03b1\nIH : \u2200 (x : \u03b1), \u03b1 \u2192 sorry = x\nx y : \u03b1\n\u22a2 sorry = x"}, {"line": "\u00b7 simp [IH]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem formPerm_apply_getLast (x : \u03b1) (xs : List \u03b1) :\n    formPerm (x :: xs) ((x :: xs).getLast (cons_ne_nil x xs)) = x := by\n  induction' xs using List.reverseRecOn with xs y _ generalizing x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nx : \u03b1\nxs : List \u03b1\n\u22a2 sorry = x"}, {"line": "induction' xs using List.reverseRecOn with xs y _ generalizing x <;> simp", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nx : \u03b1\n\u22a2 sorry () = x\n---\ncase append_singleton\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nxs : List \u03b1\ny : \u03b1\na\u271d : \u2200 (x : \u03b1), sorry = x\nx : \u03b1\n\u22a2 sorry () = x"}]}
{"declaration": "theorem formPerm_apply_head (x y : \u03b1) (xs : List \u03b1) (h : Nodup (x :: y :: xs)) :\n    formPerm (x :: y :: xs) x = y := by simp [formPerm_apply_of_not_mem h.not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nx y : \u03b1\nxs : List \u03b1\nh : sorry\n\u22a2 sorry = y"}, {"line": "simp [formPerm_apply_of_not_mem h.not_mem]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nx y : \u03b1\nxs : List \u03b1\nh : sorry\n\u22a2 sorry () = y"}]}
{"declaration": "theorem formPerm_apply_getElem_zero (l : List \u03b1) (h : Nodup l) (hl : 1 < l.length) :\n    formPerm l l[0] = l[1] := by\n  rcases l with (_ | \u27e8x, _ | \u27e8y, tl\u27e9\u27e9)\n  \u00b7 simp at hl\n  \u00b7 simp at hl\n  \u00b7 rw [getElem_cons_zero, formPerm_apply_head _ _ _ h, getElem_cons_succ, getElem_cons_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nl : List \u03b1\nh : sorry\nhl : 1 < l.length\n\u22a2 sorry = l[1]"}, {"line": "rcases l with (_ | \u27e8x, _ | \u27e8y, tl\u27e9\u27e9)", "tactic_state": "case nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nhl : 1 < [].length\n\u22a2 sorry = [][1]\n---\ncase cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nx : \u03b1\nhl : 1 < [x].length\n\u22a2 sorry = [x][1]\n---\ncase cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nx y : \u03b1\ntl : List \u03b1\nhl : 1 < (x :: y :: tl).length\n\u22a2 sorry = (x :: y :: tl)[1]"}, {"line": "\u00b7 simp at hl", "tactic_state": "case cons.nil\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nx : \u03b1\nhl : 1 < [x].length\n\u22a2 sorry = [x][1]\n---\ncase cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nx y : \u03b1\ntl : List \u03b1\nhl : 1 < (x :: y :: tl).length\n\u22a2 sorry = (x :: y :: tl)[1]"}, {"line": "\u00b7 simp at hl", "tactic_state": "case cons.cons\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d\u00b9 : Sort u_3\nNodup : x\u271d\u00b9\nx\u271d : Sort u_4\nformPerm : x\u271d\nh : sorry\nx y : \u03b1\ntl : List \u03b1\nhl : 1 < (x :: y :: tl).length\n\u22a2 sorry = (x :: y :: tl)[1]"}, {"line": "\u00b7 rw [getElem_cons_zero, formPerm_apply_head _ _ _ h, getElem_cons_succ, getElem_cons_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_of_formPerm_ne_self (l : List \u03b1) (x : \u03b1) (h : formPerm l x \u2260 x) : x \u2208 l := by\n  suffices x \u2208 { y | formPerm l y \u2260 y } by\n    rw [\u2190 mem_toFinset]\n    exact support_formPerm_le' _ this\n  simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/List.lean", "context": {"open": ["Equiv Equiv.Perm"], "variables": ["{\u03b1 \u03b2 : Type*}", "[DecidableEq \u03b1] (l : List \u03b1)", "{l} {x : \u03b1}", "(l)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nl : List \u03b1\nx : \u03b1\nh : sorry \u2260 x\n\u22a2 x \u2208 l"}, {"line": "suffices x \u2208 { y | formPerm l y \u2260 y } by\n    rw [\u2190 mem_toFinset]\n    exact support_formPerm_le' _ this", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\nformPerm : x\u271d\nl : List \u03b1\nx : \u03b1\nh : sorry \u2260 x\n\u22a2 x \u2208 {y | sorry \u2260 y}"}, {"line": "simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.decomposeOption_symm_of_none_apply {\u03b1 : Type*} [DecidableEq \u03b1] (e : Perm \u03b1)\n    (i : Option \u03b1) : Equiv.Perm.decomposeOption.symm (none, e) i = i.map e := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Option.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ne : Perm \u03b1\ni : Option \u03b1\n\u22a2 (decomposeOption.symm (none, e)) i = Option.map (\u21d1e) i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.Perm.decomposeOption_symm_sign {\u03b1 : Type*} [DecidableEq \u03b1] [Fintype \u03b1] (e : Perm \u03b1) :\n    Perm.sign (Equiv.Perm.decomposeOption.symm (none, e)) = Perm.sign e := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Option.lean", "context": {"open": ["Equiv"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ne : Perm \u03b1\n\u22a2 sign (decomposeOption.symm (none, e)) = sign e"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem signAux_swap_zero_one {n : \u2115} (hn : 2 \u2264 n) :\n    signAux (swap (\u27e80, lt_of_lt_of_le (by decide) hn\u27e9 : Fin n) \u27e81, lt_of_lt_of_le (by decide) hn\u27e9) =\n      -1 := by\n  rcases n with (_ | _ | n)\n  \u00b7 norm_num at hn\n  \u00b7 norm_num at hn\n  \u00b7 exact signAux_swap_zero_one' n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Sign.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} [DecidableEq \u03b1] {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsignAux : x\u271d\nn : \u2115\nhn : 2 \u2264 n\n\u22a2 sorry = -1"}, {"line": "rcases n with (_ | _ | n)", "tactic_state": "case zero\nx\u271d : Sort u_1\nsignAux : x\u271d\nhn : 2 \u2264 0\n\u22a2 sorry = -1\n---\ncase succ.zero\nx\u271d : Sort u_1\nsignAux : x\u271d\nhn : 2 \u2264 0 + 1\n\u22a2 sorry = -1\n---\ncase succ.succ\nx\u271d : Sort u_1\nsignAux : x\u271d\nn : \u2115\nhn : 2 \u2264 n + 1 + 1\n\u22a2 sorry = -1"}, {"line": "\u00b7 norm_num at hn", "tactic_state": "case succ.zero\nx\u271d : Sort u_1\nsignAux : x\u271d\nhn : 2 \u2264 0 + 1\n\u22a2 sorry = -1\n---\ncase succ.succ\nx\u271d : Sort u_1\nsignAux : x\u271d\nn : \u2115\nhn : 2 \u2264 n + 1 + 1\n\u22a2 sorry = -1"}, {"line": "\u00b7 norm_num at hn", "tactic_state": "case succ.succ\nx\u271d : Sort u_1\nsignAux : x\u271d\nn : \u2115\nhn : 2 \u2264 n + 1 + 1\n\u22a2 sorry = -1"}, {"line": "\u00b7 exact signAux_swap_zero_one' n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem signAux_swap : \u2200 {n : \u2115} {x y : Fin n} (_hxy : x \u2260 y), signAux (swap x y) = -1\n  | 0, x, y => by intro; exact Fin.elim0 x\n  | 1, x, y => by\n    dsimp [signAux, swap, swapCore]\n    simp only [eq_iff_true_of_subsingleton]\n    simp only [not_true]\n    simp only [ite_true]\n    simp only [le_refl]\n    simp only [prod_const]\n    simp only [IsEmpty.forall_iff]\n  | n + 2, x, y => fun hxy => by\n    have h2n : 2 \u2264 n + 2 := by exact le_add_self\n    rw [\u2190 isConj_iff_eq]\n    rw [\u2190 signAux_swap_zero_one h2n]\n    exact (MonoidHom.mk' signAux signAux_mul).map_isConj\n      (isConj_swap hxy (by exact of_decide_eq_true rfl))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Sign.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} [DecidableEq \u03b1] {\u03b2 : Type v}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsignAux : x\u271d\nn : \u2115\nx y : Fin (n + 2)\nhxy : x \u2260 y\n\u22a2 2 \u2264 n + 2"}, {"line": "exact le_add_self\n    rw [\u2190 isConj_iff_eq]\n    rw [\u2190 signAux_swap_zero_one h2n]\n    exact (MonoidHom.mk' signAux signAux_mul).map_isConj\n      (isConj_swap hxy (by exact of_decide_eq_true rfl))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_abs (f : Perm \u03b1) :\n    |(Equiv.Perm.sign f : \u2124)| = 1 := by\n  rw [Int.abs_eq_natAbs]\n  rw [Int.units_natAbs]\n  rw [Nat.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Sign.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} [DecidableEq \u03b1] {\u03b2 : Type v}", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 |\u2191(Perm.sign f)| = 1"}, {"line": "rw [Int.abs_eq_natAbs]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 \u2191(\u2191(Perm.sign f)).natAbs = 1"}, {"line": "rw [Int.units_natAbs]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 \u21911 = 1"}, {"line": "rw [Nat.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_subtypeCongr {p : \u03b1 \u2192 Prop} [DecidablePred p] (ep : Perm { a // p a })\n    (en : Perm { a // \u00acp a }) : sign (ep.subtypeCongr en) = sign ep * sign en := by\n  simp [subtypeCongr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Sign.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} [DecidableEq \u03b1] {\u03b2 : Type v}", "[Fintype \u03b1]", "(\u03b1) in", "[DecidableEq \u03b2] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_1\nsign : x\u271d\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nep : Perm { a // p a }\nen : Perm { a // \u00acp a }\n\u22a2 sorry = sorry * sorry"}, {"line": "simp [subtypeCongr]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\nx\u271d : Sort u_1\nsign : x\u271d\np : \u03b1 \u2192 Prop\ninst\u271d : DecidablePred p\nep : Perm { a // p a }\nen : Perm { a // \u00acp a }\n\u22a2 sorry () = sorry () * sorry ()"}]}
{"declaration": "theorem viaFintypeEmbedding_sign\n    [Fintype \u03b1] [Fintype \u03b2] [DecidableEq \u03b2] (e : Equiv.Perm \u03b1) (f : \u03b1 \u21aa \u03b2) :\n    sign (e.viaFintypeEmbedding f) = sign e := by\n  simp [viaFintypeEmbedding]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Sign.lean", "context": {"open": ["Equiv Function Fintype Finset"], "variables": ["{\u03b1 : Type u} [DecidableEq \u03b1] {\u03b2 : Type v}", "[Fintype \u03b1]", "(\u03b1) in", "[DecidableEq \u03b2] [Fintype \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2074 : DecidableEq \u03b1\n\u03b2 : Type v\ninst\u271d\u00b3 : Fintype \u03b1\nx\u271d : Sort u_1\nsign : x\u271d\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : Fintype \u03b2\ninst\u271d : DecidableEq \u03b2\ne : Perm \u03b1\nf : \u03b1 \u21aa \u03b2\n\u22a2 sorry = sorry"}, {"line": "simp [viaFintypeEmbedding]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Disjoint.symm : Disjoint f g \u2192 Disjoint g f := by simp only [Disjoint, or_comm, imp_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2192 sorry"}, {"line": "simp only [Disjoint, or_comm, imp_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_inv_left_iff : Disjoint f\u207b\u00b9 g \u2194 Disjoint f g := by\n  refine \u27e8fun h => ?_, Disjoint.inv_left\u27e9\n  convert h.inv_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "refine \u27e8fun h => ?_, Disjoint.inv_left\u27e9", "tactic_state": "h : sorry\n\u22a2 sorry"}, {"line": "convert h.inv_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_support_apply_mem {p : Perm \u03b1} {a : \u03b1} :\n    p a \u2208 { x | p x \u2260 x } \u2194 a \u2208 { x | p x \u2260 x } := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np : Perm \u03b1\na : \u03b1\n\u22a2 p a \u2208 {x | p x \u2260 x} \u2194 a \u2208 {x | p x \u2260 x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem set_support_mul_subset : { x | (p * q) x \u2260 x } \u2286 { x | p x \u2260 x } \u222a { x | q x \u2260 x } := by\n  intro x\n  simp only [Perm.coe_mul]\n  simp only [Function.comp_apply]\n  simp only [Ne]\n  simp only [Set.mem_union]\n  simp only [Set.mem_setOf_eq]\n  by_cases hq : q x = x <;> simp [hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\n\u22a2 {x | (p * q) x \u2260 x} \u2286 {x | p x \u2260 x} \u222a {x | q x \u2260 x}"}, {"line": "intro x", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | (p * q) x \u2260 x} \u2192 x \u2208 {x | p x \u2260 x} \u222a {x | q x \u2260 x}"}, {"line": "simp only [Perm.coe_mul]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | (\u21d1p \u2218 \u21d1q) x \u2260 x} \u2192 x \u2208 {x | p x \u2260 x} \u222a {x | q x \u2260 x}"}, {"line": "simp only [Function.comp_apply]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | p (q x) \u2260 x} \u2192 x \u2208 {x | p x \u2260 x} \u222a {x | q x \u2260 x}"}, {"line": "simp only [Ne]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | \u00acp (q x) = x} \u2192 x \u2208 {x | \u00acp x = x} \u222a {x | \u00acq x = x}"}, {"line": "simp only [Set.mem_union]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | \u00acp (q x) = x} \u2192 x \u2208 {x | \u00acp x = x} \u2228 x \u2208 {x | \u00acq x = x}"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np q : Perm \u03b1\nx : \u03b1\n\u22a2 \u00acp (q x) = x \u2192 \u00acp x = x \u2228 \u00acq x = x"}, {"line": "by_cases hq : q x = x <;> simp [hq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_support {x : \u03b1} : x \u2209 f.support \u2194 f x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\n\u22a2 x \u2209 f.support \u2194 f x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_support_eq_set_support (f : Perm \u03b1) : (f.support : Set \u03b1) = { x | f x \u2260 x } := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 \u2191f.support = {x | f x \u2260 x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u2191f.support \u2194 x\u271d \u2208 {x | f x \u2260 x}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInvariant_of_support_le {c : Perm \u03b1} {s : Finset \u03b1} (hcs : c.support \u2264 s) (x : \u03b1) :\n    x \u2208 s \u2194 c x \u2208 s := by\n  by_cases hx' : x \u2208 c.support\n  \u00b7 simp only [hcs hx', true_iff, hcs (apply_mem_support.mpr hx')]\n  \u00b7 rw [not_mem_support.mp hx']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nc : Perm \u03b1\ns : Finset \u03b1\nhcs : c.support \u2264 s\nx : \u03b1\n\u22a2 x \u2208 s \u2194 c x \u2208 s"}, {"line": "by_cases hx' : x \u2208 c.support", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nc : Perm \u03b1\ns : Finset \u03b1\nhcs : c.support \u2264 s\nx : \u03b1\nhx' : x \u2208 sorry\n\u22a2 x \u2208 s \u2194 c x \u2208 s\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nc : Perm \u03b1\ns : Finset \u03b1\nhcs : c.support \u2264 s\nx : \u03b1\nhx' : x \u2209 sorry\n\u22a2 x \u2208 s \u2194 c x \u2208 s"}, {"line": "\u00b7 simp only [hcs hx', true_iff, hcs (apply_mem_support.mpr hx')]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nc : Perm \u03b1\ns : Finset \u03b1\nhcs : c.support \u2264 s\nx : \u03b1\nhx' : x \u2209 sorry\n\u22a2 x \u2208 s \u2194 c x \u2208 s"}, {"line": "\u00b7 rw [not_mem_support.mp hx']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_eq_on_of_mem_support (h : \u2200 x \u2208 f.support \u2229 g.support, f x = g x) (k : \u2115) :\n    \u2200 x \u2208 f.support \u2229 g.support, (f ^ k) x = (g ^ k) x := by\n  induction' k with k hk\n  \u00b7 simp\n  \u00b7 intro x hx\n    rw [pow_succ]\n    rw [mul_apply]\n    rw [pow_succ]\n    rw [mul_apply]\n    rw [h _ hx]\n    rw [hk]\n    rwa [mem_inter, apply_mem_support, \u2190 h _ hx, apply_mem_support, \u2190 mem_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : \u2200 x \u2208 f.support \u2229 g.support, f x = g x\nk : \u2115\n\u22a2 \u2200 x \u2208 f.support \u2229 g.support, (f ^ k) x = (g ^ k) x"}, {"line": "induction' k with k hk", "tactic_state": "case zero\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : \u2200 x \u2208 f.support \u2229 g.support, f x = g x\n\u22a2 \u2200 x \u2208 f.support \u2229 g.support, (f ^ 0) x = (g ^ 0) x\n---\ncase succ\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : \u2200 x \u2208 f.support \u2229 g.support, f x = g x\nk : \u2115\nhk : \u2200 x \u2208 f.support \u2229 g.support, (f ^ k) x = (g ^ k) x\n\u22a2 \u2200 x \u2208 f.support \u2229 g.support, (f ^ (k + 1)) x = (g ^ (k + 1)) x"}, {"line": "\u00b7 simp", "tactic_state": "case succ\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\nh : \u2200 x \u2208 f.support \u2229 g.support, f x = g x\nk : \u2115\nhk : \u2200 x \u2208 f.support \u2229 g.support, (f ^ k) x = (g ^ k) x\n\u22a2 \u2200 x \u2208 f.support \u2229 g.support, (f ^ (k + 1)) x = (g ^ (k + 1)) x"}, {"line": "\u00b7 intro x hx\n    rw [pow_succ]\n    rw [mul_apply]\n    rw [pow_succ]\n    rw [mul_apply]\n    rw [h _ hx]\n    rw [hk]\n    rwa [mem_inter, apply_mem_support, \u2190 h _ hx, apply_mem_support, \u2190 mem_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_iff_disjoint_support : Disjoint f g \u2194 _root_.Disjoint f.support g.support := by\n  simp [disjoint_iff_eq_or_eq, disjoint_iff, disjoint_iff, Finset.ext_iff, not_and_or,\n    imp_iff_not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\n\u22a2 sorry \u2194 Disjoint f.support g.support"}, {"line": "simp [disjoint_iff_eq_or_eq, disjoint_iff, disjoint_iff, Finset.ext_iff, not_and_or,\n    imp_iff_not_or]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\n\u22a2 sorry () \u2194 Disjoint f.support g.support"}]}
{"declaration": "theorem support_swap_mul_eq (f : Perm \u03b1) (x : \u03b1) (h : f (f x) \u2260 x) :\n    (swap x (f x) * f).support = f.support \\ {x} := by\n  by_cases hx : f x = x\n  \u00b7 simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem]\n  ext z\n  by_cases hzx : z = x\n  \u00b7 simp [hzx]\n  by_cases hzf : z = f x\n  \u00b7 simp [hzf, hx, h, swap_apply_of_ne_of_ne]\n  by_cases hzfx : f z = x\n  \u00b7 simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx]\n  \u00b7 simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\n\u22a2 (Equiv.swap x (f x) * f).support = f.support \\ {x}"}, {"line": "by_cases hx : f x = x", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : f x = x\n\u22a2 (Equiv.swap x (f x) * f).support = f.support \\ {x}\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\n\u22a2 (Equiv.swap x (f x) * f).support = f.support \\ {x}"}, {"line": "\u00b7 simp [hx, sdiff_singleton_eq_erase, not_mem_support.mpr hx, erase_eq_of_not_mem]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\n\u22a2 (Equiv.swap x (f x) * f).support = f.support \\ {x}"}, {"line": "ext z", "tactic_state": "case neg.h\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "by_cases hzx : z = x", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : z = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "\u00b7 simp [hzx]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "by_cases hzf : z = f x", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : z = f x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : \u00acz = f x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "\u00b7 simp [hzf, hx, h, swap_apply_of_ne_of_ne]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : \u00acz = f x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "by_cases hzfx : f z = x", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : \u00acz = f x\nhzfx : f z = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : \u00acz = f x\nhzfx : \u00acf z = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "\u00b7 simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx : \u03b1\nh : f (f x) \u2260 x\nhx : \u00acf x = x\nz : \u03b1\nhzx : \u00acz = x\nhzf : \u00acz = f x\nhzfx : \u00acf z = x\n\u22a2 z \u2208 (Equiv.swap x (f x) * f).support \u2194 z \u2208 f.support \\ {x}"}, {"line": "\u00b7 simp [Ne.symm hzx, hzx, Ne.symm hzf, hzfx, f.injective.ne hzx, swap_apply_of_ne_of_ne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_ne_one (f : Perm \u03b1) : #f.support \u2260 1 := by\n  by_cases h : f = 1\n  \u00b7 exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one\n  \u00b7 exact ne_of_gt (one_lt_card_support_of_ne_one h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}", "{\u03b2 : Type*} [DecidableEq \u03b2] [Fintype \u03b2] {p : \u03b2 \u2192 Prop} [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 f.support.card \u2260 1"}, {"line": "by_cases h : f = 1", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nh : f = 1\n\u22a2 f.support.card \u2260 1\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nh : \u00acf = 1\n\u22a2 f.support.card \u2260 1"}, {"line": "\u00b7 exact ne_of_eq_of_ne (card_support_eq_zero.mpr h) zero_ne_one", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nh : \u00acf = 1\n\u22a2 f.support.card \u2260 1"}, {"line": "\u00b7 exact ne_of_gt (one_lt_card_support_of_ne_one h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_support_conj : #(\u03c3 * \u03c4 * \u03c3\u207b\u00b9).support = #\u03c4.support := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Support.lean", "context": {"open": ["Equiv Finset Function", "scoped List in"], "variables": ["{\u03b1 : Type*}", "{f g h : Perm \u03b1}", "[DecidableEq \u03b1]", "(p q : Perm \u03b1)", "[DecidableEq \u03b1] [Fintype \u03b1] {f g : Perm \u03b1}", "{\u03b2 : Type*} [DecidableEq \u03b2] [Fintype \u03b2] {p : \u03b2 \u2192 Prop} [DecidablePred p]", "{\u03b1 : Type*}", "{\u03b1 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 \u03c4 : Perm \u03b1\n\u22a2 (\u03c3 * \u03c4 * \u03c3\u207b\u00b9).support.card = \u03c4.support.card"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem _root_.Eq.sameCycle (h : x = y) (f : Perm \u03b1) : f.SameCycle x y := by rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx y : \u03b1\nh : x = y\nf : Perm \u03b1\n\u22a2 f.SameCycle x y"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sameCycle_one : SameCycle 1 x y \u2194 x = y := by simp [SameCycle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx y : \u03b1\nx\u271d : Sort u_4\nSameCycle : x\u271d\n\u22a2 sorry \u2194 x = y"}, {"line": "simp [SameCycle]", "tactic_state": "\u03b1 : Type u_2\nx y : \u03b1\nx\u271d : Sort u_4\nSameCycle : x\u271d\n\u22a2 sorry () \u2194 x = y"}]}
{"declaration": "theorem SameCycle.conj : SameCycle f x y \u2192 SameCycle (g * f * g\u207b\u00b9) (g x) (g y) := by\n  simp [sameCycle_conj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_4\nSameCycle : x\u271d\n\u22a2 sorry \u2192 sorry"}, {"line": "simp [sameCycle_conj]", "tactic_state": "x\u271d : Sort u_4\nSameCycle : x\u271d\n\u22a2 sorry () \u2192 sorry ()"}]}
{"declaration": "protected theorem IsCycle.orderOf (hf : IsCycle f) : orderOf f = #f.support := by\n  rw [\u2190 Fintype.card_zpowers]\n  rw [\u2190 Fintype.card_coe]\n  convert Fintype.card_congr (IsCycle.zpowersEquivSupport hf)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 orderOf f = f.support.card"}, {"line": "rw [\u2190 Fintype.card_zpowers]", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 Fintype.card \u21a5(Subgroup.zpowers f) = f.support.card\n---\n\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 Fintype (Perm \u03b1)"}, {"line": "rw [\u2190 Fintype.card_coe]", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 Fintype.card \u21a5(Subgroup.zpowers f) = Fintype.card { x // x \u2208 f.support }\n---\n\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 Fintype (Perm \u03b1)"}, {"line": "convert Fintype.card_congr (IsCycle.zpowersEquivSupport hf)", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\ninst\u271d\u00b2 : Finite \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nx\u271d : Sort u_4\nIsCycle : x\u271d\nhf : sorry\n\u22a2 Fintype (Perm \u03b1)"}]}
{"declaration": "theorem isCycleOn_empty : f.IsCycleOn \u2205 := by simp [IsCycleOn, Set.bijOn_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\n\u22a2 f.IsCycleOn \u2205"}, {"line": "simp [IsCycleOn, Set.bijOn_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCycleOn_one : (1 : Perm \u03b1).IsCycleOn s \u2194 s.Subsingleton := by\n  simp [IsCycleOn, Set.bijOn_id, Set.Subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ns : Set \u03b1\n\u22a2 Perm.IsCycleOn 1 s \u2194 s.Subsingleton"}, {"line": "simp [IsCycleOn, Set.bijOn_id, Set.Subsingleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCycleOn_singleton : f.IsCycleOn {a} \u2194 f a = a := by simp [IsCycleOn, SameCycle.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\n\u22a2 f.IsCycleOn {a} \u2194 f a = a"}, {"line": "simp [IsCycleOn, SameCycle.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsCycleOn.apply_ne (hf : f.IsCycleOn s) (hs : s.Nontrivial) (ha : a \u2208 s) :\n    f a \u2260 a := by\n  obtain \u27e8b, hb, hba\u27e9 := hs.exists_ne a\n  obtain \u27e8n, rfl\u27e9 := hf.2 ha hb\n  exact fun h => hba (IsFixedPt.perm_zpow h n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\na : \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\nha : a \u2208 s\n\u22a2 f a \u2260 a"}, {"line": "obtain \u27e8b, hb, hba\u27e9 := hs.exists_ne a", "tactic_state": "case intro.intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\na : \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhba : b \u2260 a\n\u22a2 f a \u2260 a"}, {"line": "obtain \u27e8n, rfl\u27e9 := hf.2 ha hb", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\na : \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\nha : a \u2208 s\nn : \u2124\nhb : (f ^ n) a \u2208 s\nhba : (f ^ n) a \u2260 a\n\u22a2 f a \u2260 a"}, {"line": "exact fun h => hba (IsFixedPt.perm_zpow h n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCycleOn.isCycle_subtypePerm (hf : f.IsCycleOn s) (hs : s.Nontrivial) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycle := by\n  obtain \u27e8a, ha\u27e9 := hs.nonempty\n  exact\n    \u27e8\u27e8a, ha\u27e9, ne_of_apply_ne ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs ha), fun b _ =>\n      (hf.2 (\u27e8a, ha\u27e9 : s).2 b.2).subtypePerm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 (f.subtypePerm \u22ef).IsCycle"}, {"line": "obtain \u27e8a, ha\u27e9 := hs.nonempty", "tactic_state": "case intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\na : \u03b1\nha : a \u2208 s\n\u22a2 (f.subtypePerm \u22ef).IsCycle"}, {"line": "exact\n    \u27e8\u27e8a, ha\u27e9, ne_of_apply_ne ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs ha), fun b _ =>\n      (hf.2 (\u27e8a, ha\u27e9 : s).2 b.2).subtypePerm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsCycleOn.subtypePerm (hf : f.IsCycleOn s) :\n    (f.subtypePerm fun _ => hf.apply_mem_iff.symm : Perm s).IsCycleOn _root_.Set.univ := by\n  obtain hs | hs := s.subsingleton_or_nontrivial\n  \u00b7 haveI := hs.coe_sort\n    exact isCycleOn_of_subsingleton _ _\n  convert (hf.isCycle_subtypePerm hs).isCycleOn\n  rw [eq_comm]\n  rw [Set.eq_univ_iff_forall]\n  exact fun x => ne_of_apply_ne ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs x.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\n\u22a2 (f.subtypePerm \u22ef).IsCycleOn Set.univ"}, {"line": "obtain hs | hs := s.subsingleton_or_nontrivial", "tactic_state": "case inl\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Subsingleton\n\u22a2 (f.subtypePerm \u22ef).IsCycleOn Set.univ\n---\ncase inr\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 (f.subtypePerm \u22ef).IsCycleOn Set.univ"}, {"line": "\u00b7 haveI := hs.coe_sort\n    exact isCycleOn_of_subsingleton _ _", "tactic_state": "case inr\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 (f.subtypePerm \u22ef).IsCycleOn Set.univ"}, {"line": "convert (hf.isCycle_subtypePerm hs).isCycleOn", "tactic_state": "case h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 Set.univ = {x | (f.subtypePerm \u22ef) x \u2260 x}"}, {"line": "rw [eq_comm]", "tactic_state": "case h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 {x | (f.subtypePerm \u22ef) x \u2260 x} = Set.univ"}, {"line": "rw [Set.eq_univ_iff_forall]", "tactic_state": "case h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhf : f.IsCycleOn s\nhs : s.Nontrivial\n\u22a2 \u2200 (x : { x // x \u2208 s }), x \u2208 {x | (f.subtypePerm \u22ef) x \u2260 x}"}, {"line": "exact fun x => ne_of_apply_ne ((\u2191) : s \u2192 \u03b1) (hf.apply_ne hs x.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCycleOn.pow_apply_eq_pow_apply {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s)\n    {m n : \u2115} : (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [MOD #s] := by\n  rw [Nat.modEq_iff_dvd]\n  rw [\u2190 hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2115\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [MOD s.card]"}, {"line": "rw [Nat.modEq_iff_dvd]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2115\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 \u2191s.card \u2223 \u2191n - \u2191m"}, {"line": "rw [\u2190 hf.zpow_apply_eq ha]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2115\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 (f ^ (\u2191n - \u2191m)) a = a"}, {"line": "simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2115\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 a = (f ^ m)\u207b\u00b9 ((f ^ n) a)"}]}
{"declaration": "theorem IsCycleOn.zpow_apply_eq_zpow_apply {s : Finset \u03b1} (hf : f.IsCycleOn s) (ha : a \u2208 s)\n    {m n : \u2124} : (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [ZMOD #s] := by\n  rw [Int.modEq_iff_dvd]\n  rw [\u2190 hf.zpow_apply_eq ha]\n  simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2124\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 m \u2261 n [ZMOD \u2191s.card]"}, {"line": "rw [Int.modEq_iff_dvd]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2124\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 \u2191s.card \u2223 n - m"}, {"line": "rw [\u2190 hf.zpow_apply_eq ha]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2124\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 (f ^ (n - m)) a = a"}, {"line": "simp [sub_eq_neg_add, zpow_add, eq_inv_iff_eq, eq_comm]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na : \u03b1\ns : Finset \u03b1\nhf : f.IsCycleOn \u2191s\nha : a \u2208 s\nm n : \u2124\n\u22a2 (f ^ m) a = (f ^ n) a \u2194 a = (f ^ m)\u207b\u00b9 ((f ^ n) a)"}]}
{"declaration": "theorem IsCycleOn.exists_pow_eq' (hs : s.Finite) (hf : f.IsCycleOn s) (ha : a \u2208 s) (hb : b \u2208 s) :\n    \u2203 n : \u2115, (f ^ n) a = b := by\n  lift s to Finset \u03b1 using id hs\n  obtain \u27e8n, -, hn\u27e9 := hf.exists_pow_eq ha hb\n  exact \u27e8n, hn\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\na b : \u03b1\nhs : s.Finite\nhf : f.IsCycleOn s\nha : a \u2208 s\nhb : b \u2208 s\n\u22a2 \u2203 n, (f ^ n) a = b"}, {"line": "lift s to Finset \u03b1 using id hs", "tactic_state": "case intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na b : \u03b1\ns : Finset \u03b1\nhs : (\u2191s).Finite\nhf : f.IsCycleOn \u2191s\nha : a \u2208 \u2191s\nhb : b \u2208 \u2191s\n\u22a2 \u2203 n, (f ^ n) a = b"}, {"line": "obtain \u27e8n, -, hn\u27e9 := hf.exists_pow_eq ha hb", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\na b : \u03b1\ns : Finset \u03b1\nhs : (\u2191s).Finite\nhf : f.IsCycleOn \u2191s\nha : a \u2208 \u2191s\nhb : b \u2208 \u2191s\nn : \u2115\nhn : (f ^ n) a = b\n\u22a2 \u2203 n, (f ^ n) a = b"}, {"line": "exact \u27e8n, hn\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsCycleOn.countable (hs : f.IsCycleOn s) : s.Countable := by\n  obtain rfl | \u27e8a, ha\u27e9 := s.eq_empty_or_nonempty\n  \u00b7 exact Set.countable_empty\n  \u00b7 exact (Set.countable_range fun n : \u2124 => (\u21d1(f ^ n) : \u03b1 \u2192 \u03b1) a).mono (hs.2 ha)\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhs : f.IsCycleOn s\n\u22a2 s.Countable"}, {"line": "obtain rfl | \u27e8a, ha\u27e9 := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\nhs : f.IsCycleOn \u2205\n\u22a2 \u2205.Countable\n---\ncase inr.intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhs : f.IsCycleOn s\na : \u03b1\nha : a \u2208 s\n\u22a2 s.Countable"}, {"line": "\u00b7 exact Set.countable_empty", "tactic_state": "case inr.intro\n\u03b1 : Type u_2\ninst\u271d\u2074 : Finite \u03b1\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nf : Perm \u03b1\ns : Set \u03b1\nhs : f.IsCycleOn s\na : \u03b1\nha : a \u2208 s\n\u22a2 s.Countable"}, {"line": "\u00b7 exact (Set.countable_range fun n : \u2124 => (\u21d1(f ^ n) : \u03b1 \u2192 \u03b1) a).mono (hs.2 ha)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_cycleOn (s : Finset \u03b1) :\n    \u2203 f : Perm \u03b1, f.IsCycleOn s \u2227 f.support \u2286 s := by\n  refine \u27e8s.toList.formPerm, ?_, fun x hx => by\n    simpa using List.mem_of_formPerm_apply_ne (Perm.mem_support.1 hx)\u27e9\n  convert s.nodup_toList.isCycleOn_formPerm\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}", "[DecidableEq \u03b1] {l : List \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 \u2203 f, f.IsCycleOn \u2191s \u2227 f.support \u2286 s"}, {"line": "refine \u27e8s.toList.formPerm, ?_, fun x hx => by\n    simpa using List.mem_of_formPerm_apply_ne (Perm.mem_support.1 hx)\u27e9", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 sorry.IsCycleOn \u2191s"}, {"line": "convert s.nodup_toList.isCycleOn_formPerm", "tactic_state": "case h.e'_2\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 sorry = s.toList.formPerm\n---\ncase h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 \u2191s = {a | a \u2208 s.toList}\n---\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}, {"line": "simp", "tactic_state": "case h.e'_2\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 sorry () = s.toList.formPerm\n---\ncase h.e'_3\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 \u2191s = {a | a \u2208 s.toList}\n---\n\u03b1 : Type u_2\ninst\u271d\u2077 : Finite \u03b1\ninst\u271d\u2076 : DecidableEq \u03b1\ninst\u271d\u2075 inst\u271d\u2074 : Fintype \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}]}
{"declaration": "theorem sum_smul_sum_eq_sum_perm (h\u03c3 : \u03c3.IsCycleOn s) (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) :\n    (\u2211 i \u2208 s, f i) \u2022 \u2211 i \u2208 s, g i = \u2211 k \u2208 range #s, \u2211 i \u2208 s, f i \u2022 g ((\u03c3 ^ k) i) := by\n  rw [sum_smul_sum]\n  rw [\u2190 sum_product']\n  simp_rw [product_self_eq_disjiUnion_perm h\u03c3, sum_disjiUnion, sum_map, Embedding.coeFn_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Basic.lean", "context": {"open": ["Equiv Function Finset", "Equiv"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {p : \u03b1 \u2192 Prop} {x y z : \u03b1}", "(f) in", "{f g : Perm \u03b1} {x y : \u03b1}", "[Finite \u03b1]", "[DecidableEq \u03b1]", "[Fintype \u03b1]", "[Fintype \u03b1] [DecidableEq \u03b1] {\u03c3 \u03c4 : Perm \u03b1}", "{f g : Perm \u03b1} {s t : Set \u03b1} {a b x y : \u03b1}", "[DecidableEq \u03b1] {l : List \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1]", "{f : Perm \u03b1} {s : Set \u03b1}", "{f : Perm \u03b1} {s : Finset \u03b1}", "[Semiring \u03b1] [AddCommMonoid \u03b2] [Module \u03b1 \u03b2] {s : Finset \u03b9} {\u03c3 : Perm \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2070 : Finite \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 inst\u271d\u2077 : Fintype \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : Module \u03b1 \u03b2\ns : Finset \u03b9\n\u03c3 : Perm \u03b9\nh\u03c3 : \u03c3.IsCycleOn \u2191s\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 (\u2211 i \u2208 s, f i) \u2022 \u2211 i \u2208 s, g i = \u2211 k \u2208 range s.card, \u2211 i \u2208 s, f i \u2022 g ((\u03c3 ^ k) i)"}, {"line": "rw [sum_smul_sum]", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2070 : Finite \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 inst\u271d\u2077 : Fintype \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : Module \u03b1 \u03b2\ns : Finset \u03b9\n\u03c3 : Perm \u03b9\nh\u03c3 : \u03c3.IsCycleOn \u2191s\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 \u2211 i \u2208 s, \u2211 j \u2208 s, f i \u2022 g j = \u2211 k \u2208 range s.card, \u2211 i \u2208 s, f i \u2022 g ((\u03c3 ^ k) i)"}, {"line": "rw [\u2190 sum_product']", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u00b9\u2070 : Finite \u03b1\ninst\u271d\u2079 : DecidableEq \u03b1\ninst\u271d\u2078 inst\u271d\u2077 : Fintype \u03b1\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b1\ninst\u271d\u00b3 : Fintype \u03b1\ninst\u271d\u00b2 : Semiring \u03b1\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : Module \u03b1 \u03b2\ns : Finset \u03b9\n\u03c3 : Perm \u03b9\nh\u03c3 : \u03c3.IsCycleOn \u2191s\nf : \u03b9 \u2192 \u03b1\ng : \u03b9 \u2192 \u03b2\n\u22a2 \u2211 x \u2208 s \u00d7\u02e2 s, f x.1 \u2022 g x.2 = \u2211 k \u2208 range s.card, \u2211 i \u2208 s, f i \u2022 g ((\u03c3 ^ k) i)"}, {"line": "simp_rw [product_self_eq_disjiUnion_perm h\u03c3, sum_disjiUnion, sum_map, Embedding.coeFn_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_one : toList (1 : Perm \u03b1) x = [] := by simp [toList, cycleOf_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\n\u22a2 toList 1 x = []"}, {"line": "simp [toList, cycleOf_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_eq_nil_iff {p : Perm \u03b1} {x} : toList p x = [] \u2194 x \u2209 p.support := by simp [toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\n\u22a2 p.toList x = [] \u2194 x \u2209 p.support"}, {"line": "simp [toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem length_toList : length (toList p x) = (cycleOf p x).support.card := by simp [toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\n\u22a2 (p.toList x).length = (p.cycleOf x).support.card"}, {"line": "simp [toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_ne_singleton (y : \u03b1) : toList p x \u2260 [y] := by\n  intro H\n  simpa [card_support_ne_one] using congr_arg length H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx y : \u03b1\n\u22a2 p.toList x \u2260 [y]"}, {"line": "intro H", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx y : \u03b1\nH : p.toList x = [y]\n\u22a2 False"}, {"line": "simpa [card_support_ne_one] using congr_arg length H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_le_length_toList_iff_mem_support {p : Perm \u03b1} {x : \u03b1} :\n    2 \u2264 length (toList p x) \u2194 x \u2208 p.support := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\n\u22a2 2 \u2264 (p.toList x).length \u2194 x \u2208 p.support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_toList (n : \u2115) (hn : n < length (toList p x)) :\n    (toList p x).get \u27e8n, hn\u27e9 = (p ^ n) x := by simp [toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nn : \u2115\nhn : n < (p.toList x).length\n\u22a2 (p.toList x).get \u27e8n, hn\u27e9 = (p ^ n) x"}, {"line": "simp [toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_getElem_zero (h : x \u2208 p.support) :\n    (toList p x)[0]'(length_toList_pos_of_mem_support _ _ h) = x := by simp [toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nh : x \u2208 p.support\n\u22a2 (p.toList x)[0] = x"}, {"line": "simp [toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_get_zero (h : x \u2208 p.support) :\n    (toList p x).get \u27e80, (length_toList_pos_of_mem_support _ _ h)\u27e9 = x := by simp [toList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nh : x \u2208 p.support\n\u22a2 (p.toList x).get \u27e80, \u22ef\u27e9 = x"}, {"line": "simp [toList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_pow_apply_eq_rotate (p : Perm \u03b1) (x : \u03b1) (k : \u2115) :\n    p.toList ((p ^ k) x) = (p.toList x).rotate k := by\n  apply ext_getElem\n  \u00b7 simp only [length_toList, cycleOf_self_apply_pow, length_rotate]\n  \u00b7 intro n hn hn'\n    rw [getElem_toList]\n    rw [getElem_rotate]\n    rw [getElem_toList]\n    rw [length_toList]\n    rw [pow_mod_card_support_cycleOf_self_apply]\n    rw [pow_add]\n    rw [mul_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)", "{p} {x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nk : \u2115\n\u22a2 p.toList ((p ^ k) x) = (p.toList x).rotate k"}, {"line": "apply ext_getElem", "tactic_state": "case hl\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nk : \u2115\n\u22a2 (p.toList ((p ^ k) x)).length = ((p.toList x).rotate k).length\n---\ncase h\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nk : \u2115\n\u22a2 \u2200 (i : \u2115) (h\u2081 : i < (p.toList ((p ^ k) x)).length) (h\u2082 : i < ((p.toList x).rotate k).length),\n    (p.toList ((p ^ k) x))[i] = ((p.toList x).rotate k)[i]"}, {"line": "\u00b7 simp only [length_toList, cycleOf_self_apply_pow, length_rotate]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nk : \u2115\n\u22a2 \u2200 (i : \u2115) (h\u2081 : i < (p.toList ((p ^ k) x)).length) (h\u2082 : i < ((p.toList x).rotate k).length),\n    (p.toList ((p ^ k) x))[i] = ((p.toList x).rotate k)[i]"}, {"line": "\u00b7 intro n hn hn'\n    rw [getElem_toList]\n    rw [getElem_rotate]\n    rw [getElem_toList]\n    rw [length_toList]\n    rw [pow_mod_card_support_cycleOf_self_apply]\n    rw [pow_add]\n    rw [mul_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_apply_mem_toList_iff_mem_support {n : \u2115} : (p ^ n) x \u2208 p.toList x \u2194 x \u2208 p.support := by\n  rw [mem_toList_iff]\n  rw [and_iff_right_iff_imp]\n  refine fun _ => SameCycle.symm ?_\n  rw [sameCycle_pow_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)", "{p} {x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 (p ^ n) x \u2208 p.toList x \u2194 x \u2208 p.support"}, {"line": "rw [mem_toList_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 p.SameCycle x ((p ^ n) x) \u2227 x \u2208 p.support \u2194 x \u2208 p.support"}, {"line": "rw [and_iff_right_iff_imp]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nn : \u2115\n\u22a2 x \u2208 p.support \u2192 p.SameCycle x ((p ^ n) x)"}, {"line": "refine fun _ => SameCycle.symm ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\np : Equiv.Perm \u03b1\nx : \u03b1\nn : \u2115\nx\u271d : x \u2208 p.support\n\u22a2 p.SameCycle ((p ^ n) x) x"}, {"line": "rw [sameCycle_pow_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_formPerm_nil (x : \u03b1) : toList (formPerm ([] : List \u03b1)) x = [] := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)", "{p} {x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nx : \u03b1\n\u22a2 [].formPerm.toList x = []"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toList_formPerm_singleton (x y : \u03b1) : toList (formPerm [x]) y = [] := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Concrete.lean", "context": {"open": ["Equiv Equiv.Perm List"], "variables": ["{\u03b1 : Type*}", "[DecidableEq \u03b1] {l l' : List \u03b1}", "[DecidableEq \u03b1] (s : Cycle \u03b1)", "[Fintype \u03b1] [DecidableEq \u03b1] (p : Equiv.Perm \u03b1) (x : \u03b1)", "{p} {x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 inst\u271d\u00b2 : DecidableEq \u03b1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nx y : \u03b1\n\u22a2 [x].formPerm.toList y = []"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleOf_apply_apply_pow_self (f : Perm \u03b1) [DecidableRel f.SameCycle] (x : \u03b1) (k : \u2115) :\n    cycleOf f x ((f ^ k) x) = (f ^ (k + 1) : Perm \u03b1) x := by\n  convert cycleOf_apply_apply_zpow_self f x k using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_4\ncycleOf : x\u271d\nf : Perm \u03b1\ninst\u271d : DecidableRel f.SameCycle\nx : \u03b1\nk : \u2115\n\u22a2 sorry = (f ^ (k + 1)) x"}, {"line": "convert cycleOf_apply_apply_zpow_self f x k using 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleOf_apply_apply_self (f : Perm \u03b1) [DecidableRel f.SameCycle] (x : \u03b1) :\n    cycleOf f x (f x) = f (f x) := by\n  convert cycleOf_apply_apply_pow_self f x 1 using 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nx\u271d : Sort u_4\ncycleOf : x\u271d\nf : Perm \u03b1\ninst\u271d : DecidableRel f.SameCycle\nx : \u03b1\n\u22a2 sorry = f (f x)"}, {"line": "convert cycleOf_apply_apply_pow_self f x 1 using 1", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsCycle.cycleOf [DecidableRel f.SameCycle] [DecidableEq \u03b1]\n    (hf : IsCycle f) : cycleOf f x = if f x = x then 1 else f := by\n  by_cases hx : f x = x\n  \u00b7 rwa [if_pos hx, cycleOf_eq_one_iff]\n  \u00b7 rwa [if_neg hx, hf.cycleOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\nx\u271d\u00b9 : Sort u_4\nIsCycle : x\u271d\u00b9\nx\u271d : Sort u_5\ncycleOf : x\u271d\ninst\u271d\u00b9 : DecidableRel f.SameCycle\ninst\u271d : DecidableEq \u03b1\nhf : sorry\n\u22a2 sorry = if f x = x then 1 else f"}, {"line": "by_cases hx : f x = x", "tactic_state": "case pos\n\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\nx\u271d\u00b9 : Sort u_4\nIsCycle : x\u271d\u00b9\nx\u271d : Sort u_5\ncycleOf : x\u271d\ninst\u271d\u00b9 : DecidableRel f.SameCycle\ninst\u271d : DecidableEq \u03b1\nhf : sorry\nhx : f x = x\n\u22a2 sorry = if f x = x then 1 else f\n---\ncase neg\n\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\nx\u271d\u00b9 : Sort u_4\nIsCycle : x\u271d\u00b9\nx\u271d : Sort u_5\ncycleOf : x\u271d\ninst\u271d\u00b9 : DecidableRel f.SameCycle\ninst\u271d : DecidableEq \u03b1\nhf : sorry\nhx : \u00acf x = x\n\u22a2 sorry = if f x = x then 1 else f"}, {"line": "\u00b7 rwa [if_pos hx, cycleOf_eq_one_iff]", "tactic_state": "case neg\n\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\nx\u271d\u00b9 : Sort u_4\nIsCycle : x\u271d\u00b9\nx\u271d : Sort u_5\ncycleOf : x\u271d\ninst\u271d\u00b9 : DecidableRel f.SameCycle\ninst\u271d : DecidableEq \u03b1\nhf : sorry\nhx : \u00acf x = x\n\u22a2 sorry = if f x = x then 1 else f"}, {"line": "\u00b7 rwa [if_neg hx, hf.cycleOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_cycleOf_eq_nil_iff [DecidableEq \u03b1] [Fintype \u03b1] :\n    (f.cycleOf x).support = \u2205 \u2194 x \u2209 f.support := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nf : Perm \u03b1\nx : \u03b1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\n\u22a2 (f.cycleOf x).support = \u2205 \u2194 x \u2209 f.support"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_mod_card_support_cycleOf_self_apply [DecidableEq \u03b1] [Fintype \u03b1]\n    (f : Perm \u03b1) (n : \u2115) (x : \u03b1) : (f ^ (n % #(f.cycleOf x).support)) x = (f ^ n) x := by\n  by_cases hx : f x = x\n  \u00b7 rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]\n  \u00b7 rw [\u2190 cycleOf_pow_apply_self, \u2190 cycleOf_pow_apply_self f, \u2190 (isCycle_cycleOf f hx).orderOf,\n      pow_mod_orderOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nn : \u2115\nx : \u03b1\n\u22a2 (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x"}, {"line": "by_cases hx : f x = x", "tactic_state": "case pos\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nn : \u2115\nx : \u03b1\nhx : f x = x\n\u22a2 (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x\n---\ncase neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nn : \u2115\nx : \u03b1\nhx : \u00acf x = x\n\u22a2 (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x"}, {"line": "\u00b7 rw [pow_apply_eq_self_of_apply_eq_self hx, pow_apply_eq_self_of_apply_eq_self hx]", "tactic_state": "case neg\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nn : \u2115\nx : \u03b1\nhx : \u00acf x = x\n\u22a2 (f ^ (n % (f.cycleOf x).support.card)) x = (f ^ n) x"}, {"line": "\u00b7 rw [\u2190 cycleOf_pow_apply_self, \u2190 cycleOf_pow_apply_self f, \u2190 (isCycle_cycleOf f hx).orderOf,\n      pow_mod_orderOf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleFactorsFinset_mem_commute' {g1 g2 : Perm \u03b1}\n    (h1 : g1 \u2208 f.cycleFactorsFinset) (h2 : g2 \u2208 f.cycleFactorsFinset) :\n    Commute g1 g2 := by\n  rcases eq_or_ne g1 g2 with rfl | h\n  \u00b7 apply Commute.refl\n  \u00b7 exact Equiv.Perm.cycleFactorsFinset_mem_commute f h1 h2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g1 g2 : Perm \u03b1\nh1 : g1 \u2208 f.cycleFactorsFinset\nh2 : g2 \u2208 f.cycleFactorsFinset\n\u22a2 Commute g1 g2"}, {"line": "rcases eq_or_ne g1 g2 with rfl | h", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g1 : Perm \u03b1\nh1 h2 : g1 \u2208 f.cycleFactorsFinset\n\u22a2 Commute g1 g1\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g1 g2 : Perm \u03b1\nh1 : g1 \u2208 f.cycleFactorsFinset\nh2 : g2 \u2208 f.cycleFactorsFinset\nh : g1 \u2260 g2\n\u22a2 Commute g1 g2"}, {"line": "\u00b7 apply Commute.refl", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g1 g2 : Perm \u03b1\nh1 : g1 \u2208 f.cycleFactorsFinset\nh2 : g2 \u2208 f.cycleFactorsFinset\nh : g1 \u2260 g2\n\u22a2 Commute g1 g2"}, {"line": "\u00b7 exact Equiv.Perm.cycleFactorsFinset_mem_commute f h1 h2 h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_ofSubtype_noncommPiCoprod (u : Perm (Function.fixedPoints f))\n    (v : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 (Subgroup.zpowers (c : Perm \u03b1))) :\n    Disjoint (ofSubtype u) ((Subgroup.noncommPiCoprod f.pairwise_commute_of_mem_zpowers) v) := by\n  apply Finset.noncommProd_induction\n  \u00b7 intro a _ b _ h\n    apply f.pairwise_commute_of_mem_zpowers h <;> simp only [Subgroup.coe_subtype, SetLike.coe_mem]\n  \u00b7 intro x y\n    exact Disjoint.mul_right\n  \u00b7 exact disjoint_one_right _\n  \u00b7 intro c _\n    simp only [Subgroup.coe_subtype]\n    exact Disjoint.mono (disjoint_ofSubtype_of_memFixedPoints_self u)\n      le_rfl (support_zpowers_of_mem_cycleFactorsFinset_le (v c))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 sorry"}, {"line": "apply Finset.noncommProd_induction", "tactic_state": "case comm\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 (\u2191?s).Pairwise (onFun Commute ?f)\n---\ncase hom\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 (a b : PUnit.{1}), sorry a \u2192 sorry b \u2192 sorry (a * b)\n---\ncase unit\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 sorry 1\n---\ncase base\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 x \u2208 ?s, sorry (?f x)\n---\ncase \u03b1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Type ?u.3158\n---\ncase s\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Finset ?\u03b1\n---\ncase f\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 ?\u03b1 \u2192 PUnit.{1}"}, {"line": "\u00b7 intro a _ b _ h\n    apply f.pairwise_commute_of_mem_zpowers h <;> simp only [Subgroup.coe_subtype, SetLike.coe_mem]", "tactic_state": "case hom\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 (a b : PUnit.{1}), sorry a \u2192 sorry b \u2192 sorry (a * b)\n---\ncase unit\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 sorry 1\n---\ncase base\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 x \u2208 ?s, sorry (?f x)\n---\ncase \u03b1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Type ?u.3158\n---\ncase s\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Finset ?\u03b1\n---\ncase f\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 ?\u03b1 \u2192 PUnit.{1}"}, {"line": "\u00b7 intro x y\n    exact Disjoint.mul_right", "tactic_state": "case unit\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 sorry 1\n---\ncase base\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 x \u2208 ?s, sorry (?f x)\n---\ncase \u03b1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Type ?u.3158\n---\ncase s\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Finset ?\u03b1\n---\ncase f\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 ?\u03b1 \u2192 PUnit.{1}"}, {"line": "\u00b7 exact disjoint_one_right _", "tactic_state": "case base\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 \u2200 x \u2208 ?s, sorry (?f x)\n---\ncase \u03b1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Type ?u.3158\n---\ncase s\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Finset ?\u03b1\n---\ncase f\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 ?\u03b1 \u2192 PUnit.{1}"}, {"line": "\u00b7 intro c _\n    simp only [Subgroup.coe_subtype]\n    exact Disjoint.mono (disjoint_ofSubtype_of_memFixedPoints_self u)\n      le_rfl (support_zpowers_of_mem_cycleFactorsFinset_le (v c))", "tactic_state": "case \u03b1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Type ?u.3158\n---\ncase s\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 Finset ?\u03b1\n---\ncase f\n\u03b1 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\nu : Perm \u2191(fixedPoints \u21d1f)\nv : (c : { x // x \u2208 f.cycleFactorsFinset }) \u2192 \u21a5(Subgroup.zpowers \u2191c)\n\u22a2 ?\u03b1 \u2192 PUnit.{1}"}]}
{"declaration": "theorem cycleFactorsFinset_one : cycleFactorsFinset (1 : Perm \u03b1) = \u2205 := by\n  simp [cycleFactorsFinset_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncycleFactorsFinset : x\u271d\n\u22a2 sorry = \u2205"}, {"line": "simp [cycleFactorsFinset_eq_empty_iff]", "tactic_state": "x\u271d : Sort u_1\ncycleFactorsFinset : x\u271d\n\u22a2 sorry () = \u2205"}]}
{"declaration": "theorem cycleFactorsFinset_eq_singleton_self_iff {f : Perm \u03b1} :\n    f.cycleFactorsFinset = {f} \u2194 f.IsCycle := by simp [cycleFactorsFinset_eq_finset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 f.cycleFactorsFinset = {f} \u2194 f.IsCycle"}, {"line": "simp [cycleFactorsFinset_eq_finset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleFactorsFinset_eq_singleton_iff {f g : Perm \u03b1} :\n    f.cycleFactorsFinset = {g} \u2194 f.IsCycle \u2227 f = g := by\n  suffices f = g \u2192 (g.IsCycle \u2194 f.IsCycle) by\n    rw [cycleFactorsFinset_eq_finset]\n    simpa [eq_comm]\n  rintro rfl\n  exact Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\n\u22a2 f.cycleFactorsFinset = {g} \u2194 f.IsCycle \u2227 f = g"}, {"line": "suffices f = g \u2192 (g.IsCycle \u2194 f.IsCycle) by\n    rw [cycleFactorsFinset_eq_finset]\n    simpa [eq_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf g : Perm \u03b1\n\u22a2 f = g \u2192 (g.IsCycle \u2194 f.IsCycle)"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nf : Perm \u03b1\n\u22a2 f.IsCycle \u2194 f.IsCycle"}, {"line": "exact Iff.rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCycle.forall_commute_iff [DecidableEq \u03b1] [Fintype \u03b1] (g z : Perm \u03b1) :\n    (\u2200 c \u2208 g.cycleFactorsFinset, Commute z c) \u2194\n      \u2200 c \u2208 g.cycleFactorsFinset,\n      \u2203 (hc : \u2200 x : \u03b1, x \u2208 c.support \u2194 z x \u2208 c.support),\n        ofSubtype (subtypePerm z hc) \u2208 Subgroup.zpowers c := by\n  apply forall_congr'\n  intro c\n  apply imp_congr_right\n  intro hc\n  exact IsCycle.commute_iff (mem_cycleFactorsFinset_iff.mp hc).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Factors.lean", "context": {"open": ["Equiv Function Finset", "scoped List in", "scoped List in", "scoped List in"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{f g : Perm \u03b1} {x y : \u03b1}", "[DecidableEq \u03b1] [Fintype \u03b1] (f : Perm \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng z : Perm \u03b1\n\u22a2 (\u2200 c \u2208 g.cycleFactorsFinset, Commute z c) \u2194\n    \u2200 c \u2208 g.cycleFactorsFinset, \u2203 (_ : \u2200 (x : \u03b1), x \u2208 c.support \u2194 z x \u2208 c.support), sorry \u2208 Subgroup.zpowers c"}, {"line": "apply forall_congr'", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng z : Perm \u03b1\n\u22a2 \u2200 (a : Perm \u03b1),\n    a \u2208 g.cycleFactorsFinset \u2192 Commute z a \u2194\n      a \u2208 g.cycleFactorsFinset \u2192 \u2203 (_ : \u2200 (x : \u03b1), x \u2208 a.support \u2194 z x \u2208 a.support), sorry \u2208 Subgroup.zpowers a"}, {"line": "intro c", "tactic_state": "case h\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng z c : Perm \u03b1\n\u22a2 c \u2208 g.cycleFactorsFinset \u2192 Commute z c \u2194\n    c \u2208 g.cycleFactorsFinset \u2192 \u2203 (_ : \u2200 (x : \u03b1), x \u2208 c.support \u2194 z x \u2208 c.support), sorry \u2208 Subgroup.zpowers c"}, {"line": "apply imp_congr_right", "tactic_state": "case h.h\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng z c : Perm \u03b1\n\u22a2 c \u2208 g.cycleFactorsFinset \u2192\n    (Commute z c \u2194 \u2203 (_ : \u2200 (x : \u03b1), x \u2208 c.support \u2194 z x \u2208 c.support), sorry \u2208 Subgroup.zpowers c)"}, {"line": "intro hc", "tactic_state": "case h.h\n\u03b1 : Type u_2\ninst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\nx\u271d : Sort u_1\nofSubtype : x\u271d\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\ng z c : Perm \u03b1\nhc : c \u2208 g.cycleFactorsFinset\n\u22a2 Commute z c \u2194 \u2203 (_ : \u2200 (x : \u03b1), x \u2208 c.support \u2194 z x \u2208 c.support), sorry \u2208 Subgroup.zpowers c"}, {"line": "exact IsCycle.commute_iff (mem_cycleFactorsFinset_iff.mp hc).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cycleType_eq_zero {\u03c3 : Perm \u03b1} : \u03c3.cycleType = 0 \u2194 \u03c3 = 1 := by\n  simp [cycleType_def, cycleFactorsFinset_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "context": {"open": ["scoped Finset", "List (Vector)", "Equiv List Multiset"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Equiv.Perm \u03b1\n\u22a2 \u03c3.cycleType = 0 \u2194 \u03c3 = 1"}, {"line": "simp [cycleType_def, cycleFactorsFinset_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fixedPoints_modEq [DecidableEq \u03b1] {f : Function.End \u03b1} {p n : \u2115}\n    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :\n    Fintype.card \u03b1 \u2261 Fintype.card f.fixedPoints [MOD p] := by\n  let \u03c3 : \u03b1 \u2243 \u03b1 := \u27e8f, f ^ (p ^ n - 1),\n    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),\n    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)\u27e9\n  have h\u03c3 : \u03c3 ^ p ^ n = 1 := by\n    rw [DFunLike.ext'_iff]\n    rw [coe_pow]\n    exact (hom_coe_pow (fun g : Function.End \u03b1 \u21a6 g) rfl (fun g h \u21a6 rfl) f (p ^ n)).symm.trans hf\n  suffices Fintype.card f.fixedPoints = (support \u03c3)\u1d9c.card from\n    this \u25b8 (card_compl_support_modEq h\u03c3).symm\n  suffices f.fixedPoints = (support \u03c3)\u1d9c by\n    simp only [this]; apply Fintype.card_coe\n  simp [\u03c3, Set.ext_iff, IsFixedPt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "context": {"open": ["scoped Finset", "List (Vector)", "Equiv List Multiset", "Function in"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u22a2 sorry \u2261 sorry [MOD p]"}, {"line": "let \u03c3 : \u03b1 \u2243 \u03b1 := \u27e8f, f ^ (p ^ n - 1),\n    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),\n    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u03c3 : \u03b1 \u2243 \u03b1 := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := \u22ef, right_inv := \u22ef }\n\u22a2 sorry \u2261 sorry [MOD p]"}, {"line": "have h\u03c3 : \u03c3 ^ p ^ n = 1 := by\n    rw [DFunLike.ext'_iff]\n    rw [coe_pow]\n    exact (hom_coe_pow (fun g : Function.End \u03b1 \u21a6 g) rfl (fun g h \u21a6 rfl) f (p ^ n)).symm.trans hf", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u03c3 : \u03b1 \u2243 \u03b1 := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := \u22ef, right_inv := \u22ef }\nh\u03c3 : \u03c3 ^ p ^ n = 1\n\u22a2 sorry \u2261 sorry [MOD p]"}, {"line": "suffices Fintype.card f.fixedPoints = (support \u03c3)\u1d9c.card from\n    this \u25b8 (card_compl_support_modEq h\u03c3).symm", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u03c3 : \u03b1 \u2243 \u03b1 := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := \u22ef, right_inv := \u22ef }\nh\u03c3 : \u03c3 ^ p ^ n = 1\n\u22a2 sorry = sorry"}, {"line": "suffices f.fixedPoints = (support \u03c3)\u1d9c by\n    simp only [this]; apply Fintype.card_coe", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u03c3 : \u03b1 \u2243 \u03b1 := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := \u22ef, right_inv := \u22ef }\nh\u03c3 : \u03c3 ^ p ^ n = 1\n\u22a2 Function.fixedPoints f = sorry\u1d9c"}, {"line": "simp [\u03c3, Set.ext_iff, IsFixedPt]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : Function.End \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nhf : f ^ p ^ n = 1\n\u03c3 : \u03b1 \u2243 \u03b1 := { toFun := f, invFun := f ^ (p ^ n - 1), left_inv := \u22ef, right_inv := \u22ef }\nh\u03c3 : \u03c3 ^ p ^ n = 1\n\u22a2 \u2200 (x : \u03b1), Function.IsFixedPt f x \u2194 x \u2209 sorry ()"}]}
{"declaration": "theorem exists_fixed_point_of_prime' {p n : \u2115} [hp : Fact p.Prime] (h\u03b1 : p \u2223 Fintype.card \u03b1)\n    {\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ p ^ n = 1) {a : \u03b1} (ha : \u03c3 a = a) : \u2203 b : \u03b1, \u03c3 b = b \u2227 b \u2260 a := by\n  classical\n    have h : \u2200 b : \u03b1, b \u2208 \u03c3.support\u1d9c \u2194 \u03c3 b = b := fun b => by\n      rw [Finset.mem_compl]\n      rw [mem_support]\n      rw [Classical.not_not]\n    obtain \u27e8b, hb1, hb2\u27e9 := Finset.exists_ne_of_one_lt_card (hp.out.one_lt.trans_le\n      (Nat.le_of_dvd (Finset.card_pos.mpr \u27e8a, (h a).mpr ha\u27e9) (Nat.modEq_zero_iff_dvd.mp\n        ((card_compl_support_modEq h\u03c3).trans (Nat.modEq_zero_iff_dvd.mpr h\u03b1))))) a\n    exact \u27e8b, (h b).mp hb1, hb2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "context": {"open": ["scoped Finset", "List (Vector)", "Equiv List Multiset", "Function in"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\np n : \u2115\nhp : Fact (Nat.Prime p)\nh\u03b1 : p \u2223 sorry\n\u03c3 : Equiv.Perm \u03b1\nh\u03c3 : \u03c3 ^ p ^ n = 1\na : \u03b1\nha : \u03c3 a = a\n\u22a2 \u2203 b, \u03c3 b = b \u2227 b \u2260 a"}, {"line": "classical\n    have h : \u2200 b : \u03b1, b \u2208 \u03c3.support\u1d9c \u2194 \u03c3 b = b := fun b => by\n      rw [Finset.mem_compl]\n      rw [mem_support]\n      rw [Classical.not_not]\n    obtain \u27e8b, hb1, hb2\u27e9 := Finset.exists_ne_of_one_lt_card (hp.out.one_lt.trans_le\n      (Nat.le_of_dvd (Finset.card_pos.mpr \u27e8a, (h a).mpr ha\u27e9) (Nat.modEq_zero_iff_dvd.mp\n        ((card_compl_support_modEq h\u03c3).trans (Nat.modEq_zero_iff_dvd.mpr h\u03b1))))) a\n    exact \u27e8b, (h b).mp hb1, hb2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCycle_of_prime_order' {\u03c3 : Perm \u03b1} (h1 : (orderOf \u03c3).Prime)\n    (h2 : Fintype.card \u03b1 < 2 * orderOf \u03c3) : \u03c3.IsCycle := by\n  classical exact isCycle_of_prime_order h1 (lt_of_le_of_lt \u03c3.support.card_le_univ h2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "context": {"open": ["scoped Finset", "List (Vector)", "Equiv List Multiset", "Function in"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1]", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03c3 : Equiv.Perm \u03b1\nh1 : Nat.Prime (orderOf \u03c3)\nh2 : sorry < 2 * orderOf \u03c3\n\u22a2 \u03c3.IsCycle"}, {"line": "classical exact isCycle_of_prime_order h1 (lt_of_le_of_lt \u03c3.support.card_le_univ h2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.exists_prime_orderOf_dvd_card' {G : Type*} [Group G] [Finite G] (p : \u2115)\n    [hp : Fact p.Prime] (hdvd : p \u2223 Nat.card G) : \u2203 x : G, orderOf x = p := by\n  have := Fintype.ofFinite G\n  rw [Nat.card_eq_fintype_card] at hdvd\n  exact exists_prime_orderOf_dvd_card p hdvd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Perm/Cycle/Type.lean", "context": {"open": ["scoped Finset", "List (Vector)", "Equiv List Multiset", "Function in"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1]", "[DecidableEq \u03b1]", "(G : Type*) [Group G] (n : \u2115)", "{G n} {g : G}", "(v : vectorsProdEqOne G n) (j k : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort ?u.536\nvectorsProdEqOne : ?m.533\ninst\u271d\u00b3 : DecidableEq \u03b1\nG\u271d : Type u_1\ninst\u271d\u00b2 : Group G\u271d\nn : \u2115\ng : G\u271d\nv : sorry\nj k : \u2115\nG : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nhdvd : p \u2223 Nat.card G\n\u22a2 \u2203 x, orderOf x = p"}, {"line": "have := Fintype.ofFinite G", "tactic_state": "\u03b1 : Sort ?u.536\nvectorsProdEqOne : ?m.533\ninst\u271d\u00b3 : DecidableEq \u03b1\nG\u271d : Type u_1\ninst\u271d\u00b2 : Group G\u271d\nn : \u2115\ng : G\u271d\nv : sorry\nj k : \u2115\nG : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nhdvd : p \u2223 Nat.card G\nthis : Fintype G\n\u22a2 \u2203 x, orderOf x = p"}, {"line": "rw [Nat.card_eq_fintype_card] at hdvd", "tactic_state": "\u03b1 : Sort ?u.536\nvectorsProdEqOne : ?m.533\ninst\u271d\u00b3 : DecidableEq \u03b1\nG\u271d : Type u_1\ninst\u271d\u00b2 : Group G\u271d\nn : \u2115\ng : G\u271d\nv : sorry\nj k : \u2115\nG : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Finite G\np : \u2115\nhp : Fact (Nat.Prime p)\nthis : Fintype G\nhdvd : p \u2223 Fintype.card G\n\u22a2 \u2203 x, orderOf x = p"}, {"line": "exact exists_prime_orderOf_dvd_card p hdvd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finRotate_bit1_mem_alternatingGroup {n : \u2115} :\n    finRotate (2 * n + 1) \u2208 alternatingGroup (Fin (2 * n + 1)) := by\n  rw [mem_alternatingGroup]\n  rw [sign_finRotate]\n  rw [pow_mul]\n  rw [pow_two]\n  rw [Int.units_mul_self]\n  rw [one_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "context": {"open": ["Equiv Equiv.Perm Subgroup Fintype"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 finRotate (2 * n + 1) \u2208 alternatingGroup (Fin (2 * n + 1))"}, {"line": "rw [mem_alternatingGroup]", "tactic_state": "n : \u2115\n\u22a2 sign (finRotate (2 * n + 1)) = 1"}, {"line": "rw [sign_finRotate]", "tactic_state": "n : \u2115\n\u22a2 (-1) ^ (2 * n) = 1"}, {"line": "rw [pow_mul]", "tactic_state": "n : \u2115\n\u22a2 ((-1) ^ 2) ^ n = 1"}, {"line": "rw [pow_two]", "tactic_state": "n : \u2115\n\u22a2 (-1 * -1) ^ n = 1"}, {"line": "rw [Int.units_mul_self]", "tactic_state": "n : \u2115\n\u22a2 1 ^ n = 1"}, {"line": "rw [one_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isThreeCycle_sq_of_three_mem_cycleType_five {g : Perm (Fin 5)} (h : 3 \u2208 cycleType g) :\n    IsThreeCycle (g * g) := by\n  obtain \u27e8c, g', rfl, hd, _, h3\u27e9 := mem_cycleType_iff.1 h\n  simp only [mul_assoc]\n  rw [hd.commute.eq]\n  rw [\u2190 mul_assoc g']\n  suffices hg' : orderOf g' \u2223 2 by\n    rw [\u2190 pow_two]\n    rw [orderOf_dvd_iff_pow_eq_one.1 hg']\n    rw [one_mul]\n    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq\n  rw [\u2190 lcm_cycleType]\n  rw [Multiset.lcm_dvd]\n  intro n hn\n  rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]\n  apply le_of_add_le_add_left\n  rw [\u2190 hd.card_support_mul]\n  rw [h3]\n  exact (c * g').support.card_le_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "context": {"open": ["Equiv Equiv.Perm Subgroup Fintype", "Equiv.Perm", "alternatingGroup"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "g : Perm (Fin 5)\nh : 3 \u2208 g.cycleType\n\u22a2 (g * g).IsThreeCycle"}, {"line": "obtain \u27e8c, g', rfl, hd, _, h3\u27e9 := mem_cycleType_iff.1 h", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 (c * g' * (c * g')).IsThreeCycle"}, {"line": "simp only [mul_assoc]", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 (c * (g' * (c * g'))).IsThreeCycle"}, {"line": "rw [hd.commute.eq]", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 (c * (g' * (g' * c))).IsThreeCycle"}, {"line": "rw [\u2190 mul_assoc g']", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 (c * (g' * g' * c)).IsThreeCycle"}, {"line": "suffices hg' : orderOf g' \u2223 2 by\n    rw [\u2190 pow_two]\n    rw [orderOf_dvd_iff_pow_eq_one.1 hg']\n    rw [one_mul]\n    exact (card_support_eq_three_iff.1 h3).isThreeCycle_sq", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 orderOf g' \u2223 2"}, {"line": "rw [\u2190 lcm_cycleType]", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 g'.cycleType.lcm \u2223 2"}, {"line": "rw [Multiset.lcm_dvd]", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\n\u22a2 \u2200 b \u2208 g'.cycleType, b \u2223 2"}, {"line": "intro n hn", "tactic_state": "case intro.intro.intro.intro.intro\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 n \u2223 2"}, {"line": "rw [le_antisymm (two_le_of_mem_cycleType hn) (le_trans (le_card_support_of_mem_cycleType hn) _)]", "tactic_state": "c g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 g'.support.card \u2264 2"}, {"line": "apply le_of_add_le_add_left", "tactic_state": "case bc\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 ?a + g'.support.card \u2264 ?a + 2\n---\ncase a\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 \u2115"}, {"line": "rw [\u2190 hd.card_support_mul]", "tactic_state": "case bc\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 (c * g').support.card \u2264 c.support.card + 2"}, {"line": "rw [h3]", "tactic_state": "case bc\nc g' : Perm (Fin 5)\nh : 3 \u2208 (c * g').cycleType\nhd : c.Disjoint g'\nleft\u271d : c.IsCycle\nh3 : c.support.card = 3\nn : \u2115\nhn : n \u2208 g'.cycleType\n\u22a2 (c * g').support.card \u2264 3 + 2"}, {"line": "exact (c * g').support.card_le_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_of_three_le_card (h3 : 3 \u2264 card \u03b1) : Nontrivial (alternatingGroup \u03b1) := by\n  haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)\n  rw [\u2190 Fintype.one_lt_card_iff_nontrivial]\n  refine lt_of_mul_lt_mul_left ?_ (le_of_lt Nat.prime_two.pos)\n  rw [two_mul_card_alternatingGroup]\n  rw [card_perm]\n  rw [\u2190 Nat.succ_le_iff]\n  exact le_trans h3 (card \u03b1).self_le_factorial\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "context": {"open": ["Equiv Equiv.Perm Subgroup Fintype", "Equiv.Perm", "alternatingGroup", "Equiv.Perm"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\n\u22a2 Nontrivial \u21a5(alternatingGroup \u03b1)"}, {"line": "haveI := Fintype.one_lt_card_iff_nontrivial.1 (lt_trans (by decide) h3)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 Nontrivial \u21a5(alternatingGroup \u03b1)"}, {"line": "rw [\u2190 Fintype.one_lt_card_iff_nontrivial]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 1 < card \u21a5(alternatingGroup \u03b1)"}, {"line": "refine lt_of_mul_lt_mul_left ?_ (le_of_lt Nat.prime_two.pos)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 2 * 1 < 2 * card \u21a5(alternatingGroup \u03b1)"}, {"line": "rw [two_mul_card_alternatingGroup]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 2 * 1 < card (Perm \u03b1)"}, {"line": "rw [card_perm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 2 * 1 < (card \u03b1).factorial"}, {"line": "rw [\u2190 Nat.succ_le_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nh3 : 3 \u2264 card \u03b1\nthis : Nontrivial \u03b1\n\u22a2 (2 * 1).succ \u2264 (card \u03b1).factorial"}, {"line": "exact le_trans h3 (card \u03b1).self_le_factorial", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalClosure_swap_mul_swap_five :\n    normalClosure\n        ({\u27e8swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)\u27e9} :\n          Set (alternatingGroup (Fin 5))) =\n      \u22a4 := by\n  let g1 := (\u27e8swap 0 2 * swap 0 1, mem_alternatingGroup.2 (by decide)\u27e9 : alternatingGroup (Fin 5))\n  let g2 := (\u27e8swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)\u27e9 : alternatingGroup (Fin 5))\n  have h5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 =\n      \u27e8finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)\u27e9 := by\n    rw [Subtype.ext_iff]\n    simp only [Fin.val_mk]\n    simp only [Subgroup.coe_mul]\n    simp only [Subgroup.coe_inv]\n    simp only [Fin.val_mk]\n    decide\n  rw [eq_top_iff]\n  rw [\u2190 normalClosure_finRotate_five]\n  refine normalClosure_le_normal ?_\n  rw [Set.singleton_subset_iff]\n  rw [SetLike.mem_coe]\n  rw [\u2190 h5]\n  have h : g2 \u2208 normalClosure {g2} :=\n    SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))\n  exact mul_mem (Subgroup.normalClosure_normal.conj_mem _ h g1) (inv_mem h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating.lean", "context": {"open": ["Equiv Equiv.Perm Subgroup Fintype", "Equiv.Perm", "alternatingGroup", "Equiv.Perm"], "variables": ["(\u03b1 : Type*) [Fintype \u03b1] [DecidableEq \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9} = \u22a4"}, {"line": "let g1 := (\u27e8swap 0 2 * swap 0 1, mem_alternatingGroup.2 (by decide)\u27e9 : alternatingGroup (Fin 5))", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\n\u22a2 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9} = \u22a4"}, {"line": "let g2 := (\u27e8swap 0 4 * swap 1 3, mem_alternatingGroup.2 (by decide)\u27e9 : alternatingGroup (Fin 5))", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\n\u22a2 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9} = \u22a4"}, {"line": "have h5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 =\n      \u27e8finRotate 5, finRotate_bit1_mem_alternatingGroup (n := 2)\u27e9 := by\n    rw [Subtype.ext_iff]\n    simp only [Fin.val_mk]\n    simp only [Subgroup.coe_mul]\n    simp only [Subgroup.coe_inv]\n    simp only [Fin.val_mk]\n    decide", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9} = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 \u22a4 \u2264 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9}"}, {"line": "rw [\u2190 normalClosure_finRotate_five]", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 normalClosure {\u27e8finRotate 5, \u22ef\u27e9} \u2264 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9}"}, {"line": "refine normalClosure_le_normal ?_", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 {\u27e8finRotate 5, \u22ef\u27e9} \u2286 \u2191(normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9})"}, {"line": "rw [Set.singleton_subset_iff]", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 \u27e8finRotate 5, \u22ef\u27e9 \u2208 \u2191(normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9})"}, {"line": "rw [SetLike.mem_coe]", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 \u27e8finRotate 5, \u22ef\u27e9 \u2208 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9}"}, {"line": "rw [\u2190 h5]", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\n\u22a2 g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 \u2208 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9}"}, {"line": "have h : g2 \u2208 normalClosure {g2} :=\n    SetLike.mem_coe.1 (subset_normalClosure (Set.mem_singleton _))", "tactic_state": "g1 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 2 * swap 0 1, \u22ef\u27e9\ng2 : \u21a5(alternatingGroup (Fin 5)) := \u27e8swap 0 4 * swap 1 3, \u22ef\u27e9\nh5 : g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 = \u27e8finRotate 5, \u22ef\u27e9\nh : g2 \u2208 normalClosure {g2}\n\u22a2 g1 * g2 * g1\u207b\u00b9 * g2\u207b\u00b9 \u2208 normalClosure {\u27e8swap 0 4 * swap 1 3, \u22ef\u27e9}"}, {"line": "exact mul_mem (Subgroup.normalClosure_normal.conj_mem _ h g1) (inv_mem h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCyclic_iff_exists_zpowers_eq_top [Group \u03b1] : IsCyclic \u03b1 \u2194 \u2203 g : \u03b1, zpowers g = \u22a4 := by\n  simp only [eq_top_iff']\n  simp only [mem_zpowers_iff]\n  exact \u27e8fun \u27e8h\u27e9 \u21a6 h, fun h \u21a6 \u27e8h\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\n\u22a2 IsCyclic \u03b1 \u2194 \u2203 g, zpowers g = \u22a4"}, {"line": "simp only [eq_top_iff']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\n\u22a2 IsCyclic \u03b1 \u2194 \u2203 g, \u2200 (x : \u03b1), x \u2208 zpowers g"}, {"line": "simp only [mem_zpowers_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\n\u22a2 IsCyclic \u03b1 \u2194 \u2203 g, \u2200 (x : \u03b1), \u2203 k, g ^ k = x"}, {"line": "exact \u27e8fun \u27e8h\u27e9 \u21a6 h, fun h \u21a6 \u27e8h\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nontrivial.of_not_isCyclic (nc : \u00acIsCyclic \u03b1) : Nontrivial \u03b1 := by\n  contrapose! nc\n  exact @isCyclic_of_subsingleton _ _ (not_nontrivial_iff_subsingleton.mp nc)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\nnc : \u00acIsCyclic \u03b1\n\u22a2 Nontrivial \u03b1"}, {"line": "contrapose! nc", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\nnc : \u00acNontrivial \u03b1\n\u22a2 IsCyclic \u03b1"}, {"line": "exact @isCyclic_of_subsingleton _ _ (not_nontrivial_iff_subsingleton.mp nc)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isCyclic_iff_exists_natCard_le_orderOf [Finite \u03b1] :\n    IsCyclic \u03b1 \u2194 \u2203 g : \u03b1, Nat.card \u03b1 \u2264 orderOf g := by\n  rw [isCyclic_iff_exists_orderOf_eq_natCard]\n  apply exists_congr\n  intro g\n  exact \u27e8Eq.ge, le_antisymm orderOf_le_card\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 IsCyclic \u03b1 \u2194 \u2203 g, Nat.card \u03b1 \u2264 orderOf g"}, {"line": "rw [isCyclic_iff_exists_orderOf_eq_natCard]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 (\u2203 g, orderOf g = Nat.card \u03b1) \u2194 \u2203 g, Nat.card \u03b1 \u2264 orderOf g\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Finite \u03b1"}, {"line": "apply exists_congr", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 \u2200 (a : \u03b1), orderOf a = Nat.card \u03b1 \u2194 Nat.card \u03b1 \u2264 orderOf a\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Finite \u03b1"}, {"line": "intro g", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\ng : \u03b1\n\u22a2 orderOf g = Nat.card \u03b1 \u2194 Nat.card \u03b1 \u2264 orderOf g\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Finite \u03b1"}, {"line": "exact \u27e8Eq.ge, le_antisymm orderOf_le_card\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : Finite \u03b1\n\u22a2 Finite \u03b1"}]}
{"declaration": "theorem Subgroup.eq_bot_or_eq_top_of_prime_card\n    (H : Subgroup G) [hp : Fact (Nat.card G).Prime] : H = \u22a5 \u2228 H = \u22a4 := by\n  have : Finite G := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have := card_subgroup_dvd_card H\n  rwa [Nat.dvd_prime hp.1, \u2190 eq_bot_iff_card, card_eq_iff_eq_top] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nhp : Fact (Nat.Prime (Nat.card G))\n\u22a2 H = \u22a5 \u2228 H = \u22a4"}, {"line": "have : Finite G := Nat.finite_of_card_ne_zero hp.1.ne_zero", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nhp : Fact (Nat.Prime (Nat.card G))\nthis : Finite G\n\u22a2 H = \u22a5 \u2228 H = \u22a4"}, {"line": "have := card_subgroup_dvd_card H", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nH : Subgroup G\nhp : Fact (Nat.Prime (Nat.card G))\nthis\u271d : Finite G\nthis : Nat.card \u21a5H \u2223 Nat.card G\n\u22a2 H = \u22a5 \u2228 H = \u22a4"}, {"line": "rwa [Nat.dvd_prime hp.1, \u2190 eq_bot_iff_card, card_eq_iff_eq_top] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_powers_of_prime_card {p : \u2115} [hp : Fact p.Prime]\n    (h : Nat.card G = p) {g g' : G} (hg : g \u2260 1) : g' \u2208 Submonoid.powers g := by\n  have : Finite G := Nat.finite_of_card_ne_zero (h \u25b8 hp.1.ne_zero)\n  rw [mem_powers_iff_mem_zpowers]\n  exact mem_zpowers_of_prime_card h hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\np : \u2115\nhp : Fact (Nat.Prime p)\nh : Nat.card G = p\ng g' : G\nhg : g \u2260 1\n\u22a2 g' \u2208 Submonoid.powers g"}, {"line": "have : Finite G := Nat.finite_of_card_ne_zero (h \u25b8 hp.1.ne_zero)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\np : \u2115\nhp : Fact (Nat.Prime p)\nh : Nat.card G = p\ng g' : G\nhg : g \u2260 1\nthis : Finite G\n\u22a2 g' \u2208 Submonoid.powers g"}, {"line": "rw [mem_powers_iff_mem_zpowers]", "tactic_state": "G : Type u_2\ninst\u271d : Group G\np : \u2115\nhp : Fact (Nat.Prime p)\nh : Nat.card G = p\ng g' : G\nhg : g \u2260 1\nthis : Finite G\n\u22a2 g' \u2208 zpowers g"}, {"line": "exact mem_zpowers_of_prime_card h hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCyclic_of_card_dvd_prime {p : \u2115} [hp : Fact p.Prime]\n    (h : Nat.card \u03b1 \u2223 p) : IsCyclic \u03b1 := by\n  rcases (Nat.dvd_prime hp.out).mp h with h | h\n  \u00b7 exact @isCyclic_of_subsingleton \u03b1 _ (Nat.card_eq_one_iff_unique.mp h).1\n  \u00b7 exact isCyclic_of_prime_card h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Fact (Nat.Prime p)\nh : Nat.card \u03b1 \u2223 p\n\u22a2 IsCyclic \u03b1"}, {"line": "rcases (Nat.dvd_prime hp.out).mp h with h | h", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Fact (Nat.Prime p)\nh\u271d : Nat.card \u03b1 \u2223 p\nh : Nat.card \u03b1 = 1\n\u22a2 IsCyclic \u03b1\n---\ncase inr\n\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Fact (Nat.Prime p)\nh\u271d : Nat.card \u03b1 \u2223 p\nh : Nat.card \u03b1 = p\n\u22a2 IsCyclic \u03b1"}, {"line": "\u00b7 exact @isCyclic_of_subsingleton \u03b1 _ (Nat.card_eq_one_iff_unique.mp h).1", "tactic_state": "case inr\n\u03b1 : Type u_1\ninst\u271d : Group \u03b1\np : \u2115\nhp : Fact (Nat.Prime p)\nh\u271d : Nat.card \u03b1 \u2223 p\nh : Nat.card \u03b1 = p\n\u22a2 IsCyclic \u03b1"}, {"line": "\u00b7 exact isCyclic_of_prime_card h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_pow_ne_one_of_isCyclic [G_cyclic : IsCyclic G]\n    {k : \u2115} (k_pos : k \u2260 0) (k_lt_card_G : k < Nat.card G) : \u2203 a : G, a ^ k \u2260 1 := by\n  have : Finite G := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt k_lt_card_G)\n  rcases G_cyclic with \u27e8a, ha\u27e9\n  use a\n  contrapose! k_lt_card_G\n  convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G\n  rw [\u2190 Nat.card_zpowers]\n  rw [eq_comm]\n  rw [card_eq_iff_eq_top]\n  rw [eq_top_iff]\n  exact fun x _ \u21a6 ha x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nG_cyclic : IsCyclic G\nk : \u2115\nk_pos : k \u2260 0\nk_lt_card_G : k < Nat.card G\n\u22a2 \u2203 a, a ^ k \u2260 1"}, {"line": "have : Finite G := Nat.finite_of_card_ne_zero (Nat.ne_zero_of_lt k_lt_card_G)", "tactic_state": "G : Type u_2\ninst\u271d : Group G\nG_cyclic : IsCyclic G\nk : \u2115\nk_pos : k \u2260 0\nk_lt_card_G : k < Nat.card G\nthis : Finite G\n\u22a2 \u2203 a, a ^ k \u2260 1"}, {"line": "rcases G_cyclic with \u27e8a, ha\u27e9", "tactic_state": "case mk.intro\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nk_lt_card_G : k < Nat.card G\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\n\u22a2 \u2203 a, a ^ k \u2260 1"}, {"line": "use a", "tactic_state": "case h\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nk_lt_card_G : k < Nat.card G\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\n\u22a2 a ^ k \u2260 1"}, {"line": "contrapose! k_lt_card_G", "tactic_state": "case h\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 Nat.card G \u2264 k"}, {"line": "convert orderOf_le_of_pow_eq_one k_pos.bot_lt k_lt_card_G", "tactic_state": "case h.e'_3\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 Nat.card G = orderOf a"}, {"line": "rw [\u2190 Nat.card_zpowers]", "tactic_state": "case h.e'_3\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 Nat.card G = Nat.card \u21a5(zpowers a)"}, {"line": "rw [eq_comm]", "tactic_state": "case h.e'_3\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 Nat.card \u21a5(zpowers a) = Nat.card G"}, {"line": "rw [card_eq_iff_eq_top]", "tactic_state": "case h.e'_3\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 zpowers a = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "case h.e'_3\nG : Type u_2\ninst\u271d : Group G\nk : \u2115\nk_pos : k \u2260 0\nthis : Finite G\na : G\nha : Function.Surjective fun x => a ^ x\nk_lt_card_G : a ^ k = 1\n\u22a2 \u22a4 \u2264 zpowers a"}, {"line": "exact fun x _ \u21a6 ha x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCyclic.card_orderOf_eq_totient [IsCyclic \u03b1] [Fintype \u03b1] {d : \u2115} (hd : d \u2223 Fintype.card \u03b1) :\n    #{a : \u03b1 | orderOf a = d} = totient d := by\n  classical apply card_orderOf_eq_totient_aux\u2082 (fun n => IsCyclic.card_pow_eq_one_le) hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup", "Finset Nat", "scoped Classical in", "Nat"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']", "(G) in", "[Fintype \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] [Fintype \u03b1] (hn : \u2200 n : \u2115, 0 < n \u2192 #{a : \u03b1 | a ^ n = 1} \u2264 n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : Group \u03b1\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b1\ninst\u271d\u00b2 : Fintype \u03b1\ninst\u271d\u00b9 : IsCyclic \u03b1\ninst\u271d : Fintype \u03b1\nd : \u2115\nhd : d \u2223 Fintype.card \u03b1\n\u22a2 {a | orderOf a = d}.card = d.totient"}, {"line": "classical apply card_orderOf_eq_totient_aux\u2082 (fun n => IsCyclic.card_pow_eq_one_le) hd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSimpleGroup_of_prime_card {p : \u2115} [hp : Fact p.Prime]\n    (h : Nat.card \u03b1 = p) : IsSimpleGroup \u03b1 := by\n  subst h\n  have : Finite \u03b1 := Nat.finite_of_card_ne_zero hp.1.ne_zero\n  have : Nontrivial \u03b1 := Finite.one_lt_card_iff_nontrivial.mp hp.1.one_lt\n  exact \u27e8fun H _ => H.eq_bot_or_eq_top_of_prime_card\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup", "Finset Nat", "scoped Classical in", "Nat"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']", "(G) in", "[Fintype \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] [Fintype \u03b1] (hn : \u2200 n : \u2115, 0 < n \u2192 #{a : \u03b1 | a ^ n = 1} \u2264 n)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\np : \u2115\nhp : Fact (Nat.Prime p)\nh : Nat.card \u03b1 = p\n\u22a2 IsSimpleGroup \u03b1"}, {"line": "subst h", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhp : Fact (Nat.Prime (Nat.card \u03b1))\n\u22a2 IsSimpleGroup \u03b1"}, {"line": "have : Finite \u03b1 := Nat.finite_of_card_ne_zero hp.1.ne_zero", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhp : Fact (Nat.Prime (Nat.card \u03b1))\nthis : Finite \u03b1\n\u22a2 IsSimpleGroup \u03b1"}, {"line": "have : Nontrivial \u03b1 := Finite.one_lt_card_iff_nontrivial.mp hp.1.one_lt", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 inst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : Fintype \u03b1\nhp : Fact (Nat.Prime (Nat.card \u03b1))\nthis\u271d : Finite \u03b1\nthis : Nontrivial \u03b1\n\u22a2 IsSimpleGroup \u03b1"}, {"line": "exact \u27e8fun H _ => H.eq_bot_or_eq_top_of_prime_card\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem ZMod.exponent (n : \u2115) : AddMonoid.exponent (ZMod n) = n := by\n  rw [IsAddCyclic.exponent_eq_card]\n  rw [Nat.card_zmod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup", "Finset Nat", "scoped Classical in", "Nat", "Subgroup", "Monoid"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']", "(G) in", "[Fintype \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] [Fintype \u03b1] (hn : \u2200 n : \u2115, 0 < n \u2192 #{a : \u03b1 | a ^ n = 1} \u2264 n)", "[Group G] [Group G']", "[CommGroup \u03b1] [IsSimpleGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 AddMonoid.exponent (ZMod n) = n"}, {"line": "rw [IsAddCyclic.exponent_eq_card]", "tactic_state": "n : \u2115\n\u22a2 Nat.card (ZMod n) = n"}, {"line": "rw [Nat.card_zmod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zmultiplesHom_ker_eq [AddGroup G] (g : G) :\n    (zmultiplesHom G g).ker = zmultiples \u2191(addOrderOf g) := by\n  ext\n  simp_rw [AddMonoidHom.mem_ker, mem_zmultiples_iff, zmultiplesHom_apply,\n    \u2190 addOrderOf_dvd_iff_zsmul_eq_zero, zsmul_eq_mul', Int.cast_id, dvd_def, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup", "Finset Nat", "scoped Classical in", "Nat", "Subgroup", "Monoid", "Subgroup AddSubgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']", "(G) in", "[Fintype \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] [Fintype \u03b1] (hn : \u2200 n : \u2115, 0 < n \u2192 #{a : \u03b1 | a ^ n = 1} \u2264 n)", "[Group G] [Group G']", "[CommGroup \u03b1] [IsSimpleGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : AddGroup G\ng : G\n\u22a2 ((zmultiplesHom G) g).ker = zmultiples \u2191(addOrderOf g)"}, {"line": "ext", "tactic_state": "case h\nG : Type u_2\ninst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : AddGroup G\ng : G\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 ((zmultiplesHom G) g).ker \u2194 x\u271d \u2208 zmultiples \u2191(addOrderOf g)"}, {"line": "simp_rw [AddMonoidHom.mem_ker, mem_zmultiples_iff, zmultiplesHom_apply,\n    \u2190 addOrderOf_dvd_iff_zsmul_eq_zero, zsmul_eq_mul', Int.cast_id, dvd_def, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCyclic.card_mulAut [Group G] [Finite G] [h : IsCyclic G] :\n    Nat.card (MulAut G) = Nat.totient (Nat.card G) := by\n  have : NeZero (Nat.card G) := \u27e8Nat.card_pos.ne'\u27e9\n  rw [\u2190 ZMod.card_units_eq_totient]\n  rw [\u2190 Nat.card_eq_fintype_card]\n  exact Nat.card_congr (mulAutMulEquiv G)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Cyclic.lean", "context": {"open": ["Subgroup", "Finset Nat", "scoped Classical in", "Nat", "Subgroup", "Monoid", "Subgroup AddSubgroup"], "variables": ["{\u03b1 G G' : Type*} {a : \u03b1}", "[Group \u03b1] [Group G] [Group G']", "(G) in", "[Fintype \u03b1]", "[DecidableEq \u03b1]", "[DecidableEq \u03b1] [Fintype \u03b1] (hn : \u2200 n : \u2115, 0 < n \u2192 #{a : \u03b1 | a ^ n = 1} \u2264 n)", "[Group G] [Group G']", "[CommGroup \u03b1] [IsSimpleGroup \u03b1]", "(G) in", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Nat.card (MulAut G) = (Nat.card G).totient"}, {"line": "have : NeZero (Nat.card G) := \u27e8Nat.card_pos.ne'\u27e9", "tactic_state": "case refine_3\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\nthis : NeZero (Nat.card G)\n\u22a2 Nat.card (MulAut G) = (Nat.card G).totient\n---\ncase refine_1\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Nonempty G\n---\ncase refine_2\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Finite G"}, {"line": "rw [\u2190 ZMod.card_units_eq_totient]", "tactic_state": "case refine_3\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\nthis : NeZero (Nat.card G)\n\u22a2 Nat.card (MulAut G) = Fintype.card (ZMod (Nat.card G))\u02e3\n---\ncase refine_1\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Nonempty G\n---\ncase refine_2\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Finite G"}, {"line": "rw [\u2190 Nat.card_eq_fintype_card]", "tactic_state": "case refine_3\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\nthis : NeZero (Nat.card G)\n\u22a2 Nat.card (MulAut G) = Nat.card (ZMod (Nat.card G))\u02e3\n---\ncase refine_1\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Nonempty G\n---\ncase refine_2\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Finite G"}, {"line": "exact Nat.card_congr (mulAutMulEquiv G)", "tactic_state": "case refine_1\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Nonempty G\n---\ncase refine_2\nG : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : Group G\ninst\u271d : Finite G\nh : IsCyclic G\n\u22a2 Finite G"}]}
{"declaration": "theorem r_zpow (i : ZMod n) (k : \u2124) : (r i)^k = r (i * k : ZMod n) := by\n  cases k <;> simp [r_pow, neg_mul_eq_mul_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nr : x\u271d\ni : ZMod n\nk : \u2124\n\u22a2 sorry ^ k = sorry"}, {"line": "cases k <;> simp [r_pow, neg_mul_eq_mul_neg]", "tactic_state": "case ofNat\nn : \u2115\nx\u271d : Sort u_1\nr : x\u271d\ni : ZMod n\na\u271d : \u2115\n\u22a2 sorry () ^ \u2191a\u271d = sorry ()\n---\ncase negSucc\nn : \u2115\nx\u271d : Sort u_1\nr : x\u271d\ni : ZMod n\na\u271d : \u2115\n\u22a2 sorry () ^ Int.negSucc a\u271d = sorry ()"}]}
{"declaration": "theorem nat_card : Nat.card (DihedralGroup n) = 2 * n := by\n  cases n\n  \u00b7 rw [Nat.card_eq_zero_of_infinite]\n  \u00b7 rw [Nat.card_eq_fintype_card, card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Nat.card (DihedralGroup n) = 2 * n"}, {"line": "cases n", "tactic_state": "case zero\n\u22a2 Nat.card (DihedralGroup 0) = 2 * 0\n---\ncase succ\nn\u271d : \u2115\n\u22a2 Nat.card (DihedralGroup (n\u271d + 1)) = 2 * (n\u271d + 1)"}, {"line": "\u00b7 rw [Nat.card_eq_zero_of_infinite]", "tactic_state": "case succ\nn\u271d : \u2115\n\u22a2 Nat.card (DihedralGroup (n\u271d + 1)) = 2 * (n\u271d + 1)"}, {"line": "\u00b7 rw [Nat.card_eq_fintype_card, card]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem r_one_pow_n : r (1 : ZMod n) ^ n = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nr : x\u271d\n\u22a2 sorry ^ n = 1"}, {"line": "simp", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nr : x\u271d\n\u22a2 sorry () = 1 \u2228 n = 0"}]}
{"declaration": "theorem sr_mul_self (i : ZMod n) : sr i * sr i = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Dihedral.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsr : x\u271d\ni : ZMod n\n\u22a2 sorry * sorry = 1"}, {"line": "simp", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nsr : x\u271d\ni : ZMod n\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem a_one_pow_n : (a 1 : QuaternionGroup n) ^ (2 * n) = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Quaternion.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\na : x\u271d\n\u22a2 sorry ^ (2 * n) = 1"}, {"line": "simp", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\na : x\u271d\n\u22a2 sorry () ^ (2 * n) = 1"}]}
{"declaration": "theorem xa_sq (i : ZMod (2 * n)) : xa i ^ 2 = a n := by simp [sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Quaternion.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nxa : x\u271d\u00b9\nx\u271d : Sort u_2\na : x\u271d\ni : ZMod (2 * n)\n\u22a2 sorry ^ 2 = sorry"}, {"line": "simp [sq]", "tactic_state": "n : \u2115\nx\u271d\u00b9 : Sort u_1\nxa : x\u271d\u00b9\nx\u271d : Sort u_2\na : x\u271d\ni : ZMod (2 * n)\n\u22a2 sorry () ^ 2 = sorry ()"}]}
{"declaration": "theorem xa_pow_four (i : ZMod (2 * n)) : xa i ^ 4 = 1 := by\n  calc xa i ^ 4\n      = a (n + n)  := by simp [pow_succ, add_sub_assoc, sub_sub_cancel]\n    _ = a \u2191(2 * n) := by simp [Nat.cast_add, two_mul]\n    _ = 1          := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Quaternion.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_1\nxa : x\u271d\ni : ZMod (2 * n)\n\u22a2 sorry ^ 4 = 1"}, {"line": "calc xa i ^ 4\n      = a (n + n)  := by simp [pow_succ, add_sub_assoc, sub_sub_cancel]\n    _ = a \u2191(2 * n) := by simp [Nat.cast_add, two_mul]\n    _ = 1          := by simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_of_cycleType (m : Multiset \u2115) :\n    #{g : alternatingGroup \u03b1 | (g : Equiv.Perm \u03b1).cycleType = m} =\n      if (m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) \u2227 Even (m.sum + Multiset.card m) then\n        (Fintype.card \u03b1)! /\n          ((Fintype.card \u03b1 - m.sum)! *\n            (m.prod * (\u220f n \u2208 m.toFinset, (m.count n)!)))\n      else 0 := by\n  split_ifs with hm\n  \u00b7 -- m is an even cycle_type\n    rw [\u2190 Finset.card_map]\n    rw [map_subtype_of_cycleType]\n    rw [if_pos hm.2]\n    rw [Equiv.Perm.card_of_cycleType \u03b1 m]\n    rw [if_pos hm.1]\n    rw [mul_assoc]\n  \u00b7 -- m does not correspond to a permutation, or to an odd one,\n    rw [\u2190 Finset.card_map]\n    rw [map_subtype_of_cycleType]\n    rw [apply_ite Finset.card]\n    rw [Finset.card_empty]\n    split_ifs with hm'\n    \u00b7 rw [Equiv.Perm.card_of_cycleType, if_neg]\n      obtain hm | hm := not_and_or.mp hm\n      \u00b7 exact hm\n      \u00b7 contradiction\n    \u00b7 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating/Centralizer.lean", "context": {"open": ["Equiv Finset Function MulAction", "Nat Equiv.Perm.OnCycleFactors Equiv.Perm"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] {g : Perm \u03b1}", "(\u03b1) in", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u2115\n\u22a2 {g | (\u2191g).cycleType = m}.card =\n    if (m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) \u2227 Even (m.sum + m.card) then\n      (Fintype.card \u03b1).factorial /\n        ((Fintype.card \u03b1 - m.sum).factorial * (m.prod * \u220f n \u2208 m.toFinset, (Multiset.count n m).factorial))\n    else 0"}, {"line": "split_ifs with hm", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u2115\nhm : (m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) \u2227 Even (m.sum + m.card)\n\u22a2 {g | (\u2191g).cycleType = m}.card =\n    (Fintype.card \u03b1).factorial /\n      ((Fintype.card \u03b1 - m.sum).factorial * (m.prod * \u220f n \u2208 m.toFinset, (Multiset.count n m).factorial))\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u2115\nhm : \u00ac((m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) \u2227 Even (m.sum + m.card))\n\u22a2 {g | (\u2191g).cycleType = m}.card = 0"}, {"line": "\u00b7 -- m is an even cycle_type\n    rw [\u2190 Finset.card_map]\n    rw [map_subtype_of_cycleType]\n    rw [if_pos hm.2]\n    rw [Equiv.Perm.card_of_cycleType \u03b1 m]\n    rw [if_pos hm.1]\n    rw [mul_assoc]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u2115\nhm : \u00ac((m.sum \u2264 Fintype.card \u03b1 \u2227 \u2200 a \u2208 m, 2 \u2264 a) \u2227 Even (m.sum + m.card))\n\u22a2 {g | (\u2191g).cycleType = m}.card = 0"}, {"line": "\u00b7 -- m does not correspond to a permutation, or to an odd one,\n    rw [\u2190 Finset.card_map]\n    rw [map_subtype_of_cycleType]\n    rw [apply_ite Finset.card]\n    rw [Finset.card_empty]\n    split_ifs with hm'\n    \u00b7 rw [Equiv.Perm.card_of_cycleType, if_neg]\n      obtain hm | hm := not_and_or.mp hm\n      \u00b7 exact hm\n      \u00b7 contradiction\n    \u00b7 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem OnCycleFactors.kerParam_range_eq_centralizer_of_count_le_one\n    (h_count : \u2200 i, g.cycleType.count i \u2264 1) :\n    (kerParam g).range = Subgroup.centralizer {g} := by\n  ext x\n  refine \u27e8fun hx \u21a6 kerParam_range_le_centralizer hx, fun hx \u21a6 ?_\u27e9\n  simp_rw [kerParam_range_eq, Subgroup.mem_map, MonoidHom.mem_ker, Subgroup.coe_subtype,\n    Subtype.exists, exists_and_right, exists_eq_right]\n  use hx\n  ext c : 2\n  rw [\u2190 Multiset.nodup_iff_count_le_one] at h_count\n  rw [cycleType_def] at h_count\n  rw [Multiset.nodup_map_iff_inj_on (cycleFactorsFinset g).nodup] at h_count\n  exact h_count _ (by simp) _ c.prop ((mem_range_toPermHom_iff).mp (by simp) c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/SpecificGroups/Alternating/Centralizer.lean", "context": {"open": ["Equiv Finset Function MulAction", "Nat Equiv.Perm.OnCycleFactors Equiv.Perm", "Fintype in", "Basis OnCycleFactors"], "variables": ["{\u03b1 : Type*} [Fintype \u03b1] [DecidableEq \u03b1] {g : Perm \u03b1}", "(\u03b1) in", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\n\u22a2 (kerParam g).range = Subgroup.centralizer {g}"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\nx : Perm \u03b1\n\u22a2 x \u2208 (kerParam g).range \u2194 x \u2208 Subgroup.centralizer {g}"}, {"line": "refine \u27e8fun hx \u21a6 kerParam_range_le_centralizer hx, fun hx \u21a6 ?_\u27e9", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\n\u22a2 x \u2208 (kerParam g).range"}, {"line": "simp_rw [kerParam_range_eq, Subgroup.mem_map, MonoidHom.mem_ker, Subgroup.coe_subtype,\n    Subtype.exists, exists_and_right, exists_eq_right]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\n\u22a2 \u2203 (x_1 : x \u2208 Subgroup.centralizer {g}), (OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9 = 1"}, {"line": "use hx", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\n\u22a2 (OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9 = 1"}, {"line": "ext c : 2", "tactic_state": "case h.H.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : \u2200 (i : \u2115), Multiset.count i g.cycleType \u2264 1\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\nc : { x // x \u2208 g.cycleFactorsFinset }\n\u22a2 \u2191(((OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9) c) = \u2191(1 c)"}, {"line": "rw [\u2190 Multiset.nodup_iff_count_le_one] at h_count", "tactic_state": "case h.H.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : g.cycleType.Nodup\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\nc : { x // x \u2208 g.cycleFactorsFinset }\n\u22a2 \u2191(((OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9) c) = \u2191(1 c)"}, {"line": "rw [cycleType_def] at h_count", "tactic_state": "case h.H.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count : (Multiset.map (card \u2218 Perm.support) g.cycleFactorsFinset.val).Nodup\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\nc : { x // x \u2208 g.cycleFactorsFinset }\n\u22a2 \u2191(((OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9) c) = \u2191(1 c)"}, {"line": "rw [Multiset.nodup_map_iff_inj_on (cycleFactorsFinset g).nodup] at h_count", "tactic_state": "case h.H.a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : DecidableEq \u03b1\ng : Perm \u03b1\nh_count :\n  \u2200 x \u2208 g.cycleFactorsFinset.val,\n    \u2200 y \u2208 g.cycleFactorsFinset.val, (card \u2218 Perm.support) x = (card \u2218 Perm.support) y \u2192 x = y\nx : Perm \u03b1\nhx : x \u2208 Subgroup.centralizer {g}\nc : { x // x \u2208 g.cycleFactorsFinset }\n\u22a2 \u2191(((OnCycleFactors.toPermHom g) \u27e8x, \u22ef\u27e9) c) = \u2191(1 c)"}, {"line": "exact h_count _ (by simp) _ c.prop ((mem_range_toPermHom_iff).mp (by simp) c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_centralizer_le_centralizer_image (s : Set G) (f : G \u2192* G') :\n    (Subgroup.centralizer s).map f \u2264 Subgroup.centralizer (f '' s) := by\n  rintro - \u27e8g, hg, rfl\u27e9 - \u27e8h, hh, rfl\u27e9\n  rw [\u2190 map_mul]\n  rw [\u2190 map_mul]\n  rw [hg h hh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Subgroup/Centralizer.lean", "context": {"open": [], "variables": ["{G G' : Type*} [Group G] [Group G']", "{H K : Subgroup G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\ns : Set G\nf : G \u2192* G'\n\u22a2 Subgroup.map f (Subgroup.centralizer s) \u2264 Subgroup.centralizer (\u21d1f '' s)"}, {"line": "rintro - \u27e8g, hg, rfl\u27e9 - \u27e8h, hh, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\ns : Set G\nf : G \u2192* G'\ng : G\nhg : g \u2208 \u2191(Subgroup.centralizer s)\nh : G\nhh : h \u2208 s\n\u22a2 f h * f g = f g * f h"}, {"line": "rw [\u2190 map_mul]", "tactic_state": "case intro.intro.intro.intro\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\ns : Set G\nf : G \u2192* G'\ng : G\nhg : g \u2208 \u2191(Subgroup.centralizer s)\nh : G\nhh : h \u2208 s\n\u22a2 f (h * g) = f g * f h"}, {"line": "rw [\u2190 map_mul]", "tactic_state": "case intro.intro.intro.intro\nG : Type u_1\nG' : Type u_2\ninst\u271d\u00b9 : Group G\ninst\u271d : Group G'\ns : Set G\nf : G \u2192* G'\ng : G\nhg : g \u2208 \u2191(Subgroup.centralizer s)\nh : G\nhh : h \u2208 s\n\u22a2 f (h * g) = f (g * h)"}, {"line": "rw [hg h hh]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalizerMonoidHom_ker :\n    H.normalizerMonoidHom.ker = (Subgroup.centralizer H).subgroupOf H.normalizer := by\n  simp [Subgroup.ext_iff, DFunLike.ext_iff, Subtype.ext_iff,\n    mem_subgroupOf, mem_centralizer_iff, eq_mul_inv_iff_mul_eq, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/GroupTheory/Subgroup/Centralizer.lean", "context": {"open": [], "variables": ["{G G' : Type*} [Group G] [Group G']", "{H K : Subgroup G}", "(H)", "{H} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 H.normalizerMonoidHom.ker = (Subgroup.centralizer \u2191H).subgroupOf H.normalizer"}, {"line": "simp [Subgroup.ext_iff, DFunLike.ext_iff, Subtype.ext_iff,\n    mem_subgroupOf, mem_centralizer_iff, eq_mul_inv_iff_mul_eq, eq_comm]", "tactic_state": "G : Type u_1\ninst\u271d : Group G\nH : Subgroup G\n\u22a2 \u2200 (a : G) (b : a \u2208 H.normalizer),\n    (\u2200 a_1 \u2208 H, a * a_1 = a_1 * a) \u2194 \u27e8a, b\u27e9 \u2208 (Subgroup.centralizer \u2191H).subgroupOf H.normalizer"}]}
{"declaration": "theorem hammingDist_self (x : \u2200 i, \u03b2 i) : hammingDist x x = 0 := by\n  rw [hammingDist]\n  rw [card_eq_zero]\n  rw [filter_eq_empty_iff]\n  exact fun _ _ H => H rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x x = 0"}, {"line": "rw [hammingDist]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 {i | x i \u2260 x i}.card = 0"}, {"line": "rw [card_eq_zero]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 {i | x i \u2260 x i} = \u2205"}, {"line": "rw [filter_eq_empty_iff]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 \u2200 \u2983x_1 : \u03b9\u2984, x_1 \u2208 univ \u2192 \u00acx x_1 \u2260 x x_1"}, {"line": "exact fun _ _ H => H rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hammingDist_triangle (x y z : \u2200 i, \u03b2 i) :\n    hammingDist x z \u2264 hammingDist x y + hammingDist y z := by\n  classical\n    unfold hammingDist\n    refine le_trans (card_mono ?_) (card_union_le _ _)\n    rw [\u2190 filter_or]\n    exact monotone_filter_right _ fun i h \u21a6 (h.ne_or_ne _).imp_right Ne.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y z : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x z \u2264 hammingDist x y + hammingDist y z"}, {"line": "classical\n    unfold hammingDist\n    refine le_trans (card_mono ?_) (card_union_le _ _)\n    rw [\u2190 filter_or]\n    exact monotone_filter_right _ fun i h \u21a6 (h.ne_or_ne _).imp_right Ne.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem swap_hammingDist : swap (@hammingDist _ \u03b2 _ _) = hammingDist := by\n  funext x y\n  exact hammingDist_comm _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\n\u22a2 swap hammingDist = hammingDist"}, {"line": "funext x y", "tactic_state": "case h.h\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 swap hammingDist x y = hammingDist x y"}, {"line": "exact hammingDist_comm _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_hammingDist_eq_zero {x y : \u2200 i, \u03b2 i} : hammingDist x y = 0 \u2192 x = y := by\n  simp_rw [hammingDist, card_eq_zero, filter_eq_empty_iff, Classical.not_not, funext_iff, mem_univ,\n    forall_true_left, imp_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y = 0 \u2192 x = y"}, {"line": "simp_rw [hammingDist, card_eq_zero, filter_eq_empty_iff, Classical.not_not, funext_iff, mem_univ,\n    forall_true_left, imp_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hamming_zero_eq_dist {x y : \u2200 i, \u03b2 i} : 0 = hammingDist x y \u2194 x = y := by\n  rw [eq_comm]\n  rw [hammingDist_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 0 = hammingDist x y \u2194 x = y"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y = 0 \u2194 x = y"}, {"line": "rw [hammingDist_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hammingDist_pos {x y : \u2200 i, \u03b2 i} : 0 < hammingDist x y \u2194 x \u2260 y := by\n  rw [\u2190 hammingDist_ne_zero]\n  rw [iff_not_comm]\n  rw [not_lt]\n  rw [Nat.le_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 0 < hammingDist x y \u2194 x \u2260 y"}, {"line": "rw [\u2190 hammingDist_ne_zero]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 0 < hammingDist x y \u2194 hammingDist x y \u2260 0\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b2 i)"}, {"line": "rw [iff_not_comm]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y = 0 \u2194 \u00ac0 < hammingDist x y\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b2 i)"}, {"line": "rw [not_lt]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y = 0 \u2194 hammingDist x y \u2264 0\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 Fintype \u03b9\n---\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 (i : \u03b9) \u2192 DecidableEq (\u03b2 i)"}, {"line": "rw [Nat.le_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hammingDist_lt_one {x y : \u2200 i, \u03b2 i} : hammingDist x y < 1 \u2194 x = y := by\n  rw [Nat.lt_one_iff]\n  rw [hammingDist_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y < 1 \u2194 x = y"}, {"line": "rw [Nat.lt_one_iff]", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\nx y : (i : \u03b9) \u2192 \u03b2 i\n\u22a2 hammingDist x y = 0 \u2194 x = y"}, {"line": "rw [hammingDist_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hammingNorm_comp_le_hammingNorm (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x : \u2200 i, \u03b3 i} (hf : \u2200 i, f i 0 = 0) :\n    (hammingNorm fun i => f i (x i)) \u2264 hammingNorm x := by\n  simpa only [\u2190 hammingDist_zero_right,hf] using hammingDist_comp_le_hammingDist f (y := fun _ \u21a6 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\n\u03b3 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 DecidableEq (\u03b3 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b3 i)\nf : (i : \u03b9) \u2192 \u03b3 i \u2192 \u03b2 i\nx : (i : \u03b9) \u2192 \u03b3 i\nhf : \u2200 (i : \u03b9), f i 0 = 0\n\u22a2 (hammingNorm fun i => f i (x i)) \u2264 hammingNorm x"}, {"line": "simpa only [\u2190 hammingDist_zero_right,hf] using hammingDist_comp_le_hammingDist f (y := fun _ \u21a6 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hammingNorm_comp (f : \u2200 i, \u03b3 i \u2192 \u03b2 i) {x : \u2200 i, \u03b3 i} (hf\u2081 : \u2200 i, Injective (f i))\n    (hf\u2082 : \u2200 i, f i 0 = 0) : (hammingNorm fun i => f i (x i)) = hammingNorm x := by\n  simpa only [\u2190 hammingDist_zero_right,hf\u2082] using hammingDist_comp f hf\u2081 (y := fun _ \u21a6 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/Hamming.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 \u03b9 : Type*} {\u03b2 : \u03b9 \u2192 Type*} [Fintype \u03b9] [\u2200 i, DecidableEq (\u03b2 i)]", "{\u03b3 : \u03b9 \u2192 Type*} [\u2200 i, DecidableEq (\u03b3 i)]", "[\u2200 i, Zero (\u03b2 i)] [\u2200 i, Zero (\u03b3 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_3\ninst\u271d\u2074 : Fintype \u03b9\ninst\u271d\u00b3 : (i : \u03b9) \u2192 DecidableEq (\u03b2 i)\n\u03b3 : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : (i : \u03b9) \u2192 DecidableEq (\u03b3 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Zero (\u03b2 i)\ninst\u271d : (i : \u03b9) \u2192 Zero (\u03b3 i)\nf : (i : \u03b9) \u2192 \u03b3 i \u2192 \u03b2 i\nx : (i : \u03b9) \u2192 \u03b3 i\nhf\u2081 : \u2200 (i : \u03b9), Injective (f i)\nhf\u2082 : \u2200 (i : \u03b9), f i 0 = 0\n\u22a2 (hammingNorm fun i => f i (x i)) = hammingNorm x"}, {"line": "simpa only [\u2190 hammingDist_zero_right,hf\u2082] using hammingDist_comp f hf\u2081 (y := fun _ \u21a6 0)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma klDiv_ne_top_iff : klDiv \u03bc \u03bd \u2260 \u221e \u2194 \u03bc \u226a \u03bd \u2227 Integrable (llr \u03bc \u03bd) \u03bc := by\n  simp [ne_eq, klDiv_eq_top_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/Basic.lean", "context": {"open": ["Real MeasureTheory Set", "scoped ENNReal", "Classical in"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nklDiv : x\u271d\n\u03b1\u271d : Type u_2\ninst\u271d : MeasurableSpace \u03b1\u271d\n\u03bc \u03bd : Measure \u03b1\u271d\n\u22a2 sorry \u2260 \u22a4 \u2194 \u03bc.AbsolutelyContinuous \u03bd \u2227 Integrable (llr \u03bc \u03bd) \u03bc"}, {"line": "simp [ne_eq, klDiv_eq_top_iff]", "tactic_state": "x\u271d : Sort u_1\nklDiv : x\u271d\n\u03b1\u271d : Type u_2\ninst\u271d : MeasurableSpace \u03b1\u271d\n\u03bc \u03bd : Measure \u03b1\u271d\n\u22a2 \u00acsorry () = \u22a4 \u2194 \u03bc.AbsolutelyContinuous \u03bd \u2227 Integrable (llr \u03bc \u03bd) \u03bc"}]}
{"declaration": "lemma toReal_klDiv_of_measure_eq (h : \u03bc \u226a \u03bd) (h_eq : \u03bc univ = \u03bd univ) :\n    (klDiv \u03bc \u03bd).toReal = \u222b a, llr \u03bc \u03bd a \u2202\u03bc := by\n  by_cases h_int : Integrable (llr \u03bc \u03bd) \u03bc\n  \u00b7 simp [toReal_klDiv h h_int, h_eq, measureReal_def]\n  \u00b7 rw [klDiv_of_not_integrable h_int, integral_undef h_int, ENNReal.toReal_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/Basic.lean", "context": {"open": ["Real MeasureTheory Set", "scoped ENNReal", "Classical in", "Classical in", "Classical in"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1}", "[IsFiniteMeasure \u03bc] [IsFiniteMeasure \u03bd]", "[IsFiniteMeasure \u03bc] [IsFiniteMeasure \u03bd]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03bc\u271d : Measure ?m.156\n\u03bd\u271d : Measure ?m.165\ninst\u271d\u2077 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2076 : IsFiniteMeasure \u03bd\u271d\ninst\u271d\u2075 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2074 : IsFiniteMeasure \u03bd\u271d\nx\u271d\u2074 : Type u_2\nx\u271d\u00b3 : MeasurableSpace x\u271d\u2074\n\u03bc : Measure x\u271d\u2074\nx\u271d\u00b2 : Type u_3\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b2\n\u03bd : Measure x\u271d\u00b2\ninst\u271d\u00b3 : IsFiniteMeasure \u03bc\ninst\u271d\u00b2 : IsFiniteMeasure \u03bd\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nx\u271d : Sort u_1\nklDiv : x\u271d\nh : \u03bc.AbsolutelyContinuous sorry\nh_eq : \u03bc univ = \u03bd univ\n\u22a2 sorry = \u222b (a : x\u271d\u2074), llr \u03bc sorry a \u2202\u03bc"}, {"line": "by_cases h_int : Integrable (llr \u03bc \u03bd) \u03bc", "tactic_state": "case pos\n\u03bc\u271d : Measure ?m.156\n\u03bd\u271d : Measure ?m.165\ninst\u271d\u2077 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2076 : IsFiniteMeasure \u03bd\u271d\ninst\u271d\u2075 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2074 : IsFiniteMeasure \u03bd\u271d\nx\u271d\u2074 : Type u_2\nx\u271d\u00b3 : MeasurableSpace x\u271d\u2074\n\u03bc : Measure x\u271d\u2074\nx\u271d\u00b2 : Type u_3\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b2\n\u03bd : Measure x\u271d\u00b2\ninst\u271d\u00b3 : IsFiniteMeasure \u03bc\ninst\u271d\u00b2 : IsFiniteMeasure \u03bd\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nx\u271d : Sort u_1\nklDiv : x\u271d\nh : \u03bc.AbsolutelyContinuous sorry\nh_eq : \u03bc univ = \u03bd univ\nh_int : Integrable (llr \u03bc sorry) \u03bc\n\u22a2 sorry = \u222b (a : x\u271d\u2074), llr \u03bc sorry a \u2202\u03bc\n---\ncase neg\n\u03bc\u271d : Measure ?m.156\n\u03bd\u271d : Measure ?m.165\ninst\u271d\u2077 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2076 : IsFiniteMeasure \u03bd\u271d\ninst\u271d\u2075 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2074 : IsFiniteMeasure \u03bd\u271d\nx\u271d\u2074 : Type u_2\nx\u271d\u00b3 : MeasurableSpace x\u271d\u2074\n\u03bc : Measure x\u271d\u2074\nx\u271d\u00b2 : Type u_3\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b2\n\u03bd : Measure x\u271d\u00b2\ninst\u271d\u00b3 : IsFiniteMeasure \u03bc\ninst\u271d\u00b2 : IsFiniteMeasure \u03bd\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nx\u271d : Sort u_1\nklDiv : x\u271d\nh : \u03bc.AbsolutelyContinuous sorry\nh_eq : \u03bc univ = \u03bd univ\nh_int : \u00acIntegrable (llr \u03bc sorry) \u03bc\n\u22a2 sorry = \u222b (a : x\u271d\u2074), llr \u03bc sorry a \u2202\u03bc"}, {"line": "\u00b7 simp [toReal_klDiv h h_int, h_eq, measureReal_def]", "tactic_state": "case neg\n\u03bc\u271d : Measure ?m.156\n\u03bd\u271d : Measure ?m.165\ninst\u271d\u2077 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2076 : IsFiniteMeasure \u03bd\u271d\ninst\u271d\u2075 : IsFiniteMeasure \u03bc\u271d\ninst\u271d\u2074 : IsFiniteMeasure \u03bd\u271d\nx\u271d\u2074 : Type u_2\nx\u271d\u00b3 : MeasurableSpace x\u271d\u2074\n\u03bc : Measure x\u271d\u2074\nx\u271d\u00b2 : Type u_3\nx\u271d\u00b9 : MeasurableSpace x\u271d\u00b2\n\u03bd : Measure x\u271d\u00b2\ninst\u271d\u00b3 : IsFiniteMeasure \u03bc\ninst\u271d\u00b2 : IsFiniteMeasure \u03bd\ninst\u271d\u00b9 : IsFiniteMeasure \u03bc\ninst\u271d : IsFiniteMeasure \u03bd\nx\u271d : Sort u_1\nklDiv : x\u271d\nh : \u03bc.AbsolutelyContinuous sorry\nh_eq : \u03bc univ = \u03bd univ\nh_int : \u00acIntegrable (llr \u03bc sorry) \u03bc\n\u22a2 sorry = \u222b (a : x\u271d\u2074), llr \u03bc sorry a \u2202\u03bc"}, {"line": "\u00b7 rw [klDiv_of_not_integrable h_int, integral_undef h_int, ENNReal.toReal_top]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma klFun_zero : klFun 0 = 1 := by simp [klFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/KLFun.lean", "context": {"open": ["Real MeasureTheory Filter Set"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nklFun : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [klFun]", "tactic_state": "x\u271d : Sort u_2\nklFun : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma klFun_one : klFun 1 = 0 := by simp [klFun]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/KLFun.lean", "context": {"open": ["Real MeasureTheory Filter Set"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nklFun : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [klFun]", "tactic_state": "x\u271d : Sort u_2\nklFun : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma hasDerivAt_klFun (hx : x \u2260 0) : HasDerivAt klFun (log x) x := by\n  convert ((hasDerivAt_mul_log hx).add (hasDerivAt_const x 1)).sub (hasDerivAt_id x) using 1\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/KLFun.lean", "context": {"open": ["Real MeasureTheory Filter Set"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nklFun : \u211d \u2192 \u211d\nhx : x \u2260 0\n\u22a2 HasDerivAt klFun (log x) x"}, {"line": "convert ((hasDerivAt_mul_log hx).add (hasDerivAt_const x 1)).sub (hasDerivAt_id x) using 1", "tactic_state": "case h.e'_8\nx : \u211d\nklFun : \u211d \u2192 \u211d\nhx : x \u2260 0\n\u22a2 klFun = fun x => x * log x + 1 - id x\n---\ncase h.e'_9\nx : \u211d\nklFun : \u211d \u2192 \u211d\nhx : x \u2260 0\n\u22a2 log x = log x + 1 + 0 - 1"}, {"line": "ring", "tactic_state": "case h.e'_8\nx : \u211d\nklFun : \u211d \u2192 \u211d\nhx : x \u2260 0\n\u22a2 klFun = fun x => 1 + (x * log x - id x)\n---\ncase h.e'_9\nx : \u211d\nklFun : \u211d \u2192 \u211d\nhx : x \u2260 0\n\u22a2 log x = log x + 1 + 0 - 1"}]}
{"declaration": "lemma klFun_eq_zero_iff (hx : 0 \u2264 x) : klFun x = 0 \u2194 x = 1 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by simp [klFun_apply, h]\u27e9\n  exact strictConvexOn_klFun.eq_of_isMinOn (isMinOn_iff.mpr fun y hy \u21a6 h \u25b8 klFun_nonneg hy)\n    isMinOn_klFun hx (zero_le_one' \u211d)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/InformationTheory/KullbackLeibler/KLFun.lean", "context": {"open": ["Real MeasureTheory Filter Set"], "variables": ["{\u03b1 : Type*} {m\u03b1 : MeasurableSpace \u03b1} {\u03bc \u03bd : Measure \u03b1} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_2\nklFun : x\u271d\nhx : 0 \u2264 x\n\u22a2 sorry = 0 \u2194 x = 1"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by simp [klFun_apply, h]\u27e9", "tactic_state": "x : \u211d\nx\u271d : Sort u_2\nklFun : x\u271d\nhx : 0 \u2264 x\nh : sorry = 0\n\u22a2 x = 1"}, {"line": "exact strictConvexOn_klFun.eq_of_isMinOn (isMinOn_iff.mpr fun y hy \u21a6 h \u25b8 klFun_nonneg hy)\n    isMinOn_klFun hx (zero_le_one' \u211d)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_basis_right {\u03b9 : Type*} (n : Basis \u03b9 R N)\n    (H : LinearMap.ker (mulRightMap M n) = \u22a5) : M.LinearDisjoint N := by\n  -- need this instance otherwise `LinearMap.ker_eq_bot` does not work\n  letI : AddCommGroup (\u03b9 \u2192\u2080 M) := Finsupp.instAddCommGroup\n  exact of_basis_right' M N n (LinearMap.ker_eq_bot.1 H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{R : Type u} {S : Type v}", "[CommSemiring R] [Semiring S] [Algebra R S]", "(M N : Submodule R S)", "{M N}", "(M N)", "[CommSemiring R] [CommSemiring S] [Algebra R S]", "{M N : Submodule R S}", "[CommRing R] [Ring S] [Algebra R S]", "(M N : Submodule R S)", "{M N} in", "{M N} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmulRightMap : x\u271d\n\u03b9 : Type u_1\nn : sorry\nH : LinearMap.ker sorry = \u22a5\n\u22a2 sorry"}, {"line": "letI : AddCommGroup (\u03b9 \u2192\u2080 M) := Finsupp.instAddCommGroup", "tactic_state": "x\u271d : Sort u_2\nmulRightMap : x\u271d\n\u03b9 : Type u_1\nn : sorry\nH : LinearMap.ker sorry = \u22a5\nthis : AddCommGroup sorry := sorry\n\u22a2 sorry"}, {"line": "exact of_basis_right' M N n (LinearMap.ker_eq_bot.1 H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_mem : x \u2261 y [SMOD U] \u2194 x - y \u2208 U := by rw [SModEq.def, Submodule.Quotient.eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx y : M\n\u22a2 x \u2261 y [SMOD U] \u2194 x - y \u2208 U"}, {"line": "rw [SModEq.def, Submodule.Quotient.eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bot : x \u2261 y [SMOD (\u22a5 : Submodule R M)] \u2194 x = y := by\n  rw [SModEq.def]\n  rw [Submodule.Quotient.eq]\n  rw [mem_bot]\n  rw [sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\n\u22a2 x \u2261 y [SMOD \u22a5] \u2194 x = y"}, {"line": "rw [SModEq.def]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\n\u22a2 Submodule.Quotient.mk x = Submodule.Quotient.mk y \u2194 x = y"}, {"line": "rw [Submodule.Quotient.eq]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\n\u22a2 x - y \u2208 \u22a5 \u2194 x = y"}, {"line": "rw [mem_bot]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nx y : M\n\u22a2 x - y = 0 \u2194 x = y"}, {"line": "rw [sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]) (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]) : x\u2081 + x\u2082 \u2261 y\u2081 + y\u2082 [SMOD U] := by\n  rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2\n  simp_rw [Quotient.mk_add, hxy\u2081, hxy\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]\n\u22a2 x\u2081 + x\u2082 \u2261 y\u2081 + y\u2082 [SMOD U]"}, {"line": "rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : Submodule.Quotient.mk x\u2081 = Submodule.Quotient.mk y\u2081\nhxy\u2082 : Submodule.Quotient.mk x\u2082 = Submodule.Quotient.mk y\u2082\n\u22a2 Submodule.Quotient.mk (x\u2081 + x\u2082) = Submodule.Quotient.mk (y\u2081 + y\u2082)"}, {"line": "simp_rw [Quotient.mk_add, hxy\u2081, hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul {I : Ideal A} {x\u2081 x\u2082 y\u2081 y\u2082 : A} (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD I])\n    (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD I]) : x\u2081 * x\u2082 \u2261 y\u2081 * y\u2082 [SMOD I] := by\n  simp only [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2\n  simp only [Ideal.Quotient.mk_eq_mk] at hxy\u2081 hxy\u2082 \u22a2\n  simp only [map_mul] at hxy\u2081 hxy\u2082 \u22a2\n  rw [hxy\u2081]\n  rw [hxy\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD I]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD I]\n\u22a2 x\u2081 * x\u2082 \u2261 y\u2081 * y\u2082 [SMOD I]"}, {"line": "simp only [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : Submodule.Quotient.mk x\u2081 = Submodule.Quotient.mk y\u2081\nhxy\u2082 : Submodule.Quotient.mk x\u2082 = Submodule.Quotient.mk y\u2082\n\u22a2 Submodule.Quotient.mk (x\u2081 * x\u2082) = Submodule.Quotient.mk (y\u2081 * y\u2082)"}, {"line": "simp only [Ideal.Quotient.mk_eq_mk] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : (Ideal.Quotient.mk I) x\u2081 = (Ideal.Quotient.mk I) y\u2081\nhxy\u2082 : (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2082\n\u22a2 (Ideal.Quotient.mk I) (x\u2081 * x\u2082) = (Ideal.Quotient.mk I) (y\u2081 * y\u2082)"}, {"line": "simp only [map_mul] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : (Ideal.Quotient.mk I) x\u2081 = (Ideal.Quotient.mk I) y\u2081\nhxy\u2082 : (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2082\n\u22a2 (Ideal.Quotient.mk I) x\u2081 * (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2081 * (Ideal.Quotient.mk I) y\u2082"}, {"line": "rw [hxy\u2081]", "tactic_state": "A : Type u_2\ninst\u271d : CommRing A\nI : Ideal A\nx\u2081 x\u2082 y\u2081 y\u2082 : A\nhxy\u2081 : (Ideal.Quotient.mk I) x\u2081 = (Ideal.Quotient.mk I) y\u2081\nhxy\u2082 : (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2082\n\u22a2 (Ideal.Quotient.mk I) y\u2081 * (Ideal.Quotient.mk I) x\u2082 = (Ideal.Quotient.mk I) y\u2081 * (Ideal.Quotient.mk I) y\u2082"}, {"line": "rw [hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma neg (hxy : x \u2261 y [SMOD U]) : - x \u2261 - y [SMOD U] := by\n  simpa only [SModEq.def,Quotient.mk_neg,neg_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx y : M\nhxy : x \u2261 y [SMOD U]\n\u22a2 -x \u2261 -y [SMOD U]"}, {"line": "simpa only [SModEq.def,Quotient.mk_neg,neg_inj]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub (hxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]) (hxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]) : x\u2081 - x\u2082 \u2261 y\u2081 - y\u2082 [SMOD U] := by\n  rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2\n  simp_rw [Quotient.mk_sub, hxy\u2081, hxy\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : x\u2081 \u2261 y\u2081 [SMOD U]\nhxy\u2082 : x\u2082 \u2261 y\u2082 [SMOD U]\n\u22a2 x\u2081 - x\u2082 \u2261 y\u2081 - y\u2082 [SMOD U]"}, {"line": "rw [SModEq.def] at hxy\u2081 hxy\u2082 \u22a2", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx\u2081 x\u2082 y\u2081 y\u2082 : M\nhxy\u2081 : Submodule.Quotient.mk x\u2081 = Submodule.Quotient.mk y\u2081\nhxy\u2082 : Submodule.Quotient.mk x\u2082 = Submodule.Quotient.mk y\u2082\n\u22a2 Submodule.Quotient.mk (x\u2081 - x\u2082) = Submodule.Quotient.mk (y\u2081 - y\u2082)"}, {"line": "simp_rw [Quotient.mk_sub, hxy\u2081, hxy\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero : x \u2261 0 [SMOD U] \u2194 x \u2208 U := by rw [SModEq.def, Submodule.Quotient.eq, sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx : M\n\u22a2 x \u2261 0 [SMOD U] \u2194 x \u2208 U"}, {"line": "rw [SModEq.def, Submodule.Quotient.eq, sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.sub_smodEq_zero : x - y \u2261 0 [SMOD U] \u2194 x \u2261 y [SMOD U] := by\n  simp only [SModEq.sub_mem]\n  simp only [sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SModEq.lean", "context": {"open": ["Submodule", "Polynomial"], "variables": ["{R : Type*} [Ring R]", "{A : Type*} [CommRing A]", "{M : Type*} [AddCommGroup M] [Module R M] (U U\u2081 U\u2082 : Submodule R M)", "{x x\u2081 x\u2082 y y\u2081 y\u2082 z z\u2081 z\u2082 : M}", "{N : Type*} [AddCommGroup N] [Module R N] (V V\u2081 V\u2082 : Submodule R N)", "{U U\u2081 U\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx y : M\n\u22a2 x - y \u2261 0 [SMOD U] \u2194 x \u2261 y [SMOD U]"}, {"line": "simp only [SModEq.sub_mem]", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : Ring R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\nU : Submodule R M\nx y : M\n\u22a2 x - y - 0 \u2208 U \u2194 x - y \u2208 U"}, {"line": "simp only [sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iff {A : Matrix (l \u2295 l) (l \u2295 l) R} :\n    A \u2208 symplecticGroup l R \u2194 A * J l R * A\u1d40 = J l R := by simp [symplecticGroup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/SymplecticGroup.lean", "context": {"open": ["Matrix", "Matrix"], "variables": ["{l R : Type*}", "(l) [DecidableEq l] (R) [CommRing R]", "[Fintype l]", "[Fintype l]", "[DecidableEq l] [Fintype l] [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Type u_1\nR : Type u_2\ninst\u271d\u2076 : DecidableEq l\ninst\u271d\u2075 : CommRing R\ninst\u271d\u2074 inst\u271d\u00b3 : Fintype l\ninst\u271d\u00b2 : DecidableEq l\ninst\u271d\u00b9 : Fintype l\ninst\u271d : CommRing R\nA : Matrix (l \u2295 l) (l \u2295 l) R\n\u22a2 A \u2208 symplecticGroup l R \u2194 A * J l R * A.transpose = J l R"}, {"line": "simp [symplecticGroup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl\u2081\u2082_inj {f\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097} {g : Q\u2097 \u2192\u2097[R] M\u2097} {g' : Q\u2097' \u2192\u2097[R] N\u2097}\n    (h\u2097 : Function.Surjective g) (h\u1d63 : Function.Surjective g') :\n    f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g' \u2194 f\u2081 = f\u2082 := by\n  constructor <;> intro h\n  \u00b7 -- B\u2081.comp l r = B\u2082.comp l r \u2192 B\u2081 = B\u2082\n    ext x y\n    obtain \u27e8x', hx\u27e9 := h\u2097 x\n    subst hx\n    obtain \u27e8y', hy\u27e9 := h\u1d63 y\n    subst hy\n    convert LinearMap.congr_fun\u2082 h x' y' using 0\n  \u00b7 -- B\u2081 = B\u2082 \u2192 B\u2081.comp l r = B\u2082.comp l r\n    subst h; rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/BilinearMap.lean", "context": {"open": ["Function"], "variables": ["{R : Type*} [Semiring R] {S : Type*} [Semiring S]", "{R\u2082 : Type*} [Semiring R\u2082] {S\u2082 : Type*} [Semiring S\u2082]", "{M : Type*} {N : Type*} {P : Type*}", "{M\u2082 : Type*} {N\u2082 : Type*} {P\u2082 : Type*}", "{P\u2097 : Type*}", "{M' : Type*} {P' : Type*}", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]", "[AddCommMonoid M\u2082] [AddCommMonoid N\u2082] [AddCommMonoid P\u2082] [AddCommMonoid P\u2097]", "[AddCommGroup M'] [AddCommGroup P']", "[Module R M] [Module S N] [Module R\u2082 P] [Module S\u2082 P]", "[Module R M\u2082] [Module S N\u2082] [Module R P\u2082] [Module S\u2082 P\u2082]", "[Module R P\u2097] [Module S P\u2097]", "[Module R M'] [Module R\u2082 P'] [Module S\u2082 P']", "[SMulCommClass S\u2082 R\u2082 P] [SMulCommClass S R P\u2097] [SMulCommClass S\u2082 R\u2082 P']", "[SMulCommClass S\u2082 R P\u2082]", "{\u03c1\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2081\u2082 : S \u2192+* S\u2082}", "(\u03c1\u2081\u2082 \u03c3\u2081\u2082)", "{\u03c1\u2081\u2082 \u03c3\u2081\u2082}", "(R S)", "{R S}", "(R' S' : Type*)", "[Semiring R'] [Semiring S'] [Module R' M] [Module S' N] [Module R' P\u2097] [Module S' P\u2097]", "[SMulCommClass S' R' P\u2097]", "[SMul S' S] [IsScalarTower S' S N] [IsScalarTower S' S P\u2097]", "[SMul R' R] [IsScalarTower R' R M] [IsScalarTower R' R P\u2097]", "{R : Type*} [CommSemiring R] {R\u2082 : Type*} [CommSemiring R\u2082]", "{R\u2083 : Type*} [CommSemiring R\u2083] {R\u2084 : Type*} [CommSemiring R\u2084]", "{M : Type*} {N : Type*} {P : Type*} {Q : Type*}", "{M\u2097 : Type*} {N\u2097 : Type*} {P\u2097 : Type*} {Q\u2097 Q\u2097' : Type*}", "[AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] [AddCommMonoid Q]", "[AddCommMonoid M\u2097] [AddCommMonoid N\u2097] [AddCommMonoid P\u2097]", "[AddCommMonoid Q\u2097] [AddCommMonoid Q\u2097']", "[Module R M] [Module R\u2082 N] [Module R\u2083 P] [Module R\u2084 Q]", "[Module R M\u2097] [Module R N\u2097] [Module R P\u2097] [Module R Q\u2097] [Module R Q\u2097']", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R \u2192+* R\u2083}", "{\u03c3\u2084\u2082 : R\u2084 \u2192+* R\u2082} {\u03c3\u2084\u2083 : R\u2084 \u2192+* R\u2083}", "[RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [RingHomCompTriple \u03c3\u2084\u2082 \u03c3\u2082\u2083 \u03c3\u2084\u2083]", "(R)", "{R}", "(f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] N \u2192\u209b\u2097[\u03c3\u2082\u2083] P)", "(R P\u2097)", "{R P\u2097}", "(P \u03c3\u2082\u2083)", "{P \u03c3\u2082\u2083}", "(R M N\u2097 P\u2097)", "{R M N\u2097 P\u2097}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_16\ninst\u271d\u00b9\u2070 : CommSemiring R\nM\u2097 : Type u_24\nN\u2097 : Type u_25\nP\u2097 : Type u_26\nQ\u2097 : Type u_27\nQ\u2097' : Type u_28\ninst\u271d\u2079 : AddCommMonoid M\u2097\ninst\u271d\u2078 : AddCommMonoid N\u2097\ninst\u271d\u2077 : AddCommMonoid P\u2097\ninst\u271d\u2076 : AddCommMonoid Q\u2097\ninst\u271d\u2075 : AddCommMonoid Q\u2097'\ninst\u271d\u2074 : Module R M\u2097\ninst\u271d\u00b3 : Module R N\u2097\ninst\u271d\u00b2 : Module R P\u2097\ninst\u271d\u00b9 : Module R Q\u2097\ninst\u271d : Module R Q\u2097'\nf\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\ng : Q\u2097 \u2192\u2097[R] M\u2097\ng' : Q\u2097' \u2192\u2097[R] N\u2097\nh\u2097 : Surjective \u21d1g\nh\u1d63 : Surjective \u21d1g'\n\u22a2 f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g' \u2194 f\u2081 = f\u2082"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nR : Type u_16\ninst\u271d\u00b9\u2070 : CommSemiring R\nM\u2097 : Type u_24\nN\u2097 : Type u_25\nP\u2097 : Type u_26\nQ\u2097 : Type u_27\nQ\u2097' : Type u_28\ninst\u271d\u2079 : AddCommMonoid M\u2097\ninst\u271d\u2078 : AddCommMonoid N\u2097\ninst\u271d\u2077 : AddCommMonoid P\u2097\ninst\u271d\u2076 : AddCommMonoid Q\u2097\ninst\u271d\u2075 : AddCommMonoid Q\u2097'\ninst\u271d\u2074 : Module R M\u2097\ninst\u271d\u00b3 : Module R N\u2097\ninst\u271d\u00b2 : Module R P\u2097\ninst\u271d\u00b9 : Module R Q\u2097\ninst\u271d : Module R Q\u2097'\nf\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\ng : Q\u2097 \u2192\u2097[R] M\u2097\ng' : Q\u2097' \u2192\u2097[R] N\u2097\nh\u2097 : Surjective \u21d1g\nh\u1d63 : Surjective \u21d1g'\nh : f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g'\n\u22a2 f\u2081 = f\u2082\n---\ncase mpr\nR : Type u_16\ninst\u271d\u00b9\u2070 : CommSemiring R\nM\u2097 : Type u_24\nN\u2097 : Type u_25\nP\u2097 : Type u_26\nQ\u2097 : Type u_27\nQ\u2097' : Type u_28\ninst\u271d\u2079 : AddCommMonoid M\u2097\ninst\u271d\u2078 : AddCommMonoid N\u2097\ninst\u271d\u2077 : AddCommMonoid P\u2097\ninst\u271d\u2076 : AddCommMonoid Q\u2097\ninst\u271d\u2075 : AddCommMonoid Q\u2097'\ninst\u271d\u2074 : Module R M\u2097\ninst\u271d\u00b3 : Module R N\u2097\ninst\u271d\u00b2 : Module R P\u2097\ninst\u271d\u00b9 : Module R Q\u2097\ninst\u271d : Module R Q\u2097'\nf\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\ng : Q\u2097 \u2192\u2097[R] M\u2097\ng' : Q\u2097' \u2192\u2097[R] N\u2097\nh\u2097 : Surjective \u21d1g\nh\u1d63 : Surjective \u21d1g'\nh : f\u2081 = f\u2082\n\u22a2 f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g'"}, {"line": "\u00b7 -- B\u2081.comp l r = B\u2082.comp l r \u2192 B\u2081 = B\u2082\n    ext x y\n    obtain \u27e8x', hx\u27e9 := h\u2097 x\n    subst hx\n    obtain \u27e8y', hy\u27e9 := h\u1d63 y\n    subst hy\n    convert LinearMap.congr_fun\u2082 h x' y' using 0", "tactic_state": "case mpr\nR : Type u_16\ninst\u271d\u00b9\u2070 : CommSemiring R\nM\u2097 : Type u_24\nN\u2097 : Type u_25\nP\u2097 : Type u_26\nQ\u2097 : Type u_27\nQ\u2097' : Type u_28\ninst\u271d\u2079 : AddCommMonoid M\u2097\ninst\u271d\u2078 : AddCommMonoid N\u2097\ninst\u271d\u2077 : AddCommMonoid P\u2097\ninst\u271d\u2076 : AddCommMonoid Q\u2097\ninst\u271d\u2075 : AddCommMonoid Q\u2097'\ninst\u271d\u2074 : Module R M\u2097\ninst\u271d\u00b3 : Module R N\u2097\ninst\u271d\u00b2 : Module R P\u2097\ninst\u271d\u00b9 : Module R Q\u2097\ninst\u271d : Module R Q\u2097'\nf\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097\ng : Q\u2097 \u2192\u2097[R] M\u2097\ng' : Q\u2097' \u2192\u2097[R] N\u2097\nh\u2097 : Surjective \u21d1g\nh\u1d63 : Surjective \u21d1g'\nh : f\u2081 = f\u2082\n\u22a2 f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g'"}, {"line": "\u00b7 -- B\u2081 = B\u2082 \u2192 B\u2081.comp l r = B\u2082.comp l r\n    subst h; rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cross_anticomm (v w : Fin 3 \u2192 R) : -(v \u00d7\u2083 w) = w \u00d7\u2083 v := by\n  simp [cross_apply, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 -(crossProduct v) w = (crossProduct w) v"}, {"line": "simp [cross_apply, mul_comm]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 ![-(v 1 * w 2 - v 2 * w 1), -(v 2 * w 0 - v 0 * w 2), -(v 0 * w 1 - v 1 * w 0)] =\n    ![w 1 * v 2 - w 2 * v 1, w 2 * v 0 - w 0 * v 2, w 0 * v 1 - w 1 * v 0]"}]}
{"declaration": "theorem cross_self (v : Fin 3 \u2192 R) : v \u00d7\u2083 v = 0 := by\n  simp [cross_apply, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv : Fin 3 \u2192 R\n\u22a2 (crossProduct v) v = 0"}, {"line": "simp [cross_apply, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dot_self_cross (v w : Fin 3 \u2192 R) : v \u2b1d\u1d65 v \u00d7\u2083 w = 0 := by\n  rw [cross_apply]\n  rw [vec3_dotProduct]\n  dsimp only [Matrix.cons_val]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 v \u2b1d\u1d65 (crossProduct v) w = 0"}, {"line": "rw [cross_apply]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 v \u2b1d\u1d65 ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] = 0"}, {"line": "rw [vec3_dotProduct]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 v 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0 +\n        v 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1 +\n      v 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2 =\n    0"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 v 0 * (v 1 * w 2 - v 2 * w 1) + v 1 * (v 2 * w 0 - v 0 * w 2) + v 2 * (v 0 * w 1 - v 1 * w 0) = 0"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nv w : Fin 3 \u2192 R\n\u22a2 v 0 * (v 1 * w 2 - v 2 * w 1) + v 1 * (v 2 * w 0 - v 0 * w 2) + v 2 * (v 0 * w 1 - v 1 * w 0) = 0"}]}
{"declaration": "theorem triple_product_permutation (u v w : Fin 3 \u2192 R) : u \u2b1d\u1d65 v \u00d7\u2083 w = v \u2b1d\u1d65 w \u00d7\u2083 u := by\n  simp_rw [cross_apply, vec3_dotProduct]\n  dsimp only [Matrix.cons_val]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u \u2b1d\u1d65 (crossProduct v) w = v \u2b1d\u1d65 (crossProduct w) u"}, {"line": "simp_rw [cross_apply, vec3_dotProduct]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0 +\n        u 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1 +\n      u 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2 =\n    v 0 * ![w 1 * u 2 - w 2 * u 1, w 2 * u 0 - w 0 * u 2, w 0 * u 1 - w 1 * u 0] 0 +\n        v 1 * ![w 1 * u 2 - w 2 * u 1, w 2 * u 0 - w 0 * u 2, w 0 * u 1 - w 1 * u 0] 1 +\n      v 2 * ![w 1 * u 2 - w 2 * u 1, w 2 * u 0 - w 0 * u 2, w 0 * u 1 - w 1 * u 0] 2"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (v 1 * w 2 - v 2 * w 1) + u 1 * (v 2 * w 0 - v 0 * w 2) + u 2 * (v 0 * w 1 - v 1 * w 0) =\n    v 0 * (w 1 * u 2 - w 2 * u 1) + v 1 * (w 2 * u 0 - w 0 * u 2) + v 2 * (w 0 * u 1 - w 1 * u 0)"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (v 1 * w 2 - v 2 * w 1) + u 1 * (v 2 * w 0 - v 0 * w 2) + u 2 * (v 0 * w 1 - v 1 * w 0) =\n    v 0 * (w 1 * u 2 - w 2 * u 1) + v 1 * (w 2 * u 0 - w 0 * u 2) + v 2 * (w 0 * u 1 - w 1 * u 0)"}]}
{"declaration": "theorem triple_product_eq_det (u v w : Fin 3 \u2192 R) : u \u2b1d\u1d65 v \u00d7\u2083 w = Matrix.det ![u, v, w] := by\n  rw [vec3_dotProduct]\n  rw [cross_apply]\n  rw [det_fin_three]\n  dsimp only [Matrix.cons_val]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u \u2b1d\u1d65 (crossProduct v) w = det ![u, v, w]"}, {"line": "rw [vec3_dotProduct]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (crossProduct v) w 0 + u 1 * (crossProduct v) w 1 + u 2 * (crossProduct v) w 2 = det ![u, v, w]"}, {"line": "rw [cross_apply]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0 +\n        u 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1 +\n      u 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2 =\n    det ![u, v, w]"}, {"line": "rw [det_fin_three]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0 +\n        u 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1 +\n      u 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2 =\n    ![u, v, w] 0 0 * ![u, v, w] 1 1 * ![u, v, w] 2 2 - ![u, v, w] 0 0 * ![u, v, w] 1 2 * ![u, v, w] 2 1 -\n            ![u, v, w] 0 1 * ![u, v, w] 1 0 * ![u, v, w] 2 2 +\n          ![u, v, w] 0 1 * ![u, v, w] 1 2 * ![u, v, w] 2 0 +\n        ![u, v, w] 0 2 * ![u, v, w] 1 0 * ![u, v, w] 2 1 -\n      ![u, v, w] 0 2 * ![u, v, w] 1 1 * ![u, v, w] 2 0"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (v 1 * w 2 - v 2 * w 1) + u 1 * (v 2 * w 0 - v 0 * w 2) + u 2 * (v 0 * w 1 - v 1 * w 0) =\n    u 0 * v 1 * w 2 - u 0 * v 2 * w 1 - u 1 * v 0 * w 2 + u 1 * v 2 * w 0 + u 2 * v 0 * w 1 - u 2 * v 1 * w 0"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (v 1 * w 2 - v 2 * w 1) + u 1 * (v 2 * w 0 - v 0 * w 2) + u 2 * (v 0 * w 1 - v 1 * w 0) =\n    u 0 * v 1 * w 2 - u 0 * v 2 * w 1 - u 1 * v 0 * w 2 + u 1 * v 2 * w 0 + u 2 * v 0 * w 1 - u 2 * v 1 * w 0"}]}
{"declaration": "theorem cross_dot_cross (u v w x : Fin 3 \u2192 R) :\n    u \u00d7\u2083 v \u2b1d\u1d65 w \u00d7\u2083 x = u \u2b1d\u1d65 w * v \u2b1d\u1d65 x - u \u2b1d\u1d65 x * v \u2b1d\u1d65 w := by\n  simp_rw [cross_apply, vec3_dotProduct]\n  dsimp only [Matrix.cons_val]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w x : Fin 3 \u2192 R\n\u22a2 (crossProduct u) v \u2b1d\u1d65 (crossProduct w) x = u \u2b1d\u1d65 w * v \u2b1d\u1d65 x - u \u2b1d\u1d65 x * v \u2b1d\u1d65 w"}, {"line": "simp_rw [cross_apply, vec3_dotProduct]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w x : Fin 3 \u2192 R\n\u22a2 ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 0 *\n          ![w 1 * x 2 - w 2 * x 1, w 2 * x 0 - w 0 * x 2, w 0 * x 1 - w 1 * x 0] 0 +\n        ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 1 *\n          ![w 1 * x 2 - w 2 * x 1, w 2 * x 0 - w 0 * x 2, w 0 * x 1 - w 1 * x 0] 1 +\n      ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 2 *\n        ![w 1 * x 2 - w 2 * x 1, w 2 * x 0 - w 0 * x 2, w 0 * x 1 - w 1 * x 0] 2 =\n    (u 0 * w 0 + u 1 * w 1 + u 2 * w 2) * (v 0 * x 0 + v 1 * x 1 + v 2 * x 2) -\n      (u 0 * x 0 + u 1 * x 1 + u 2 * x 2) * (v 0 * w 0 + v 1 * w 1 + v 2 * w 2)"}, {"line": "dsimp only [Matrix.cons_val]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w x : Fin 3 \u2192 R\n\u22a2 (u 1 * v 2 - u 2 * v 1) * (w 1 * x 2 - w 2 * x 1) + (u 2 * v 0 - u 0 * v 2) * (w 2 * x 0 - w 0 * x 2) +\n      (u 0 * v 1 - u 1 * v 0) * (w 0 * x 1 - w 1 * x 0) =\n    (u 0 * w 0 + u 1 * w 1 + u 2 * w 2) * (v 0 * x 0 + v 1 * x 1 + v 2 * x 2) -\n      (u 0 * x 0 + u 1 * x 1 + u 2 * x 2) * (v 0 * w 0 + v 1 * w 1 + v 2 * w 2)"}, {"line": "ring", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w x : Fin 3 \u2192 R\n\u22a2 (u 1 * v 2 - u 2 * v 1) * (w 1 * x 2 - w 2 * x 1) + (u 2 * v 0 - u 0 * v 2) * (w 2 * x 0 - w 0 * x 2) +\n      (u 0 * v 1 - u 1 * v 0) * (w 0 * x 1 - w 1 * x 0) =\n    (u 0 * w 0 + u 1 * w 1 + u 2 * w 2) * (v 0 * x 0 + v 1 * x 1 + v 2 * x 2) -\n      (u 0 * x 0 + u 1 * x 1 + u 2 * x 2) * (v 0 * w 0 + v 1 * w 1 + v 2 * w 2)"}]}
{"declaration": "theorem leibniz_cross (u v w : Fin 3 \u2192 R) : u \u00d7\u2083 (v \u00d7\u2083 w) = u \u00d7\u2083 v \u00d7\u2083 w + v \u00d7\u2083 (u \u00d7\u2083 w) := by\n  simp_rw [cross_apply, vec3_add]\n  apply vec3_eq <;> dsimp <;> ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/CrossProduct.lean", "context": {"open": ["Matrix"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 (crossProduct u) ((crossProduct v) w) = (crossProduct ((crossProduct u) v)) w + (crossProduct v) ((crossProduct u) w)"}, {"line": "simp_rw [cross_apply, vec3_add]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 ![u 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2 -\n        u 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1,\n      u 2 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0 -\n        u 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 2,\n      u 0 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 1 -\n        u 1 * ![v 1 * w 2 - v 2 * w 1, v 2 * w 0 - v 0 * w 2, v 0 * w 1 - v 1 * w 0] 0] =\n    ![![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 1 * w 2 -\n          ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 2 * w 1 +\n        (v 1 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 2 -\n          v 2 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 1),\n      ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 2 * w 0 -\n          ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 0 * w 2 +\n        (v 2 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 0 -\n          v 0 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 2),\n      ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 0 * w 1 -\n          ![u 1 * v 2 - u 2 * v 1, u 2 * v 0 - u 0 * v 2, u 0 * v 1 - u 1 * v 0] 1 * w 0 +\n        (v 0 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 1 -\n          v 1 * ![u 1 * w 2 - u 2 * w 1, u 2 * w 0 - u 0 * w 2, u 0 * w 1 - u 1 * w 0] 0)]"}, {"line": "apply vec3_eq <;> dsimp <;> ring", "tactic_state": "case h\u2080\nR : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 1 * (v 0 * w 1 - v 1 * w 0) - u 2 * (v 2 * w 0 - v 0 * w 2) =\n    (u 2 * v 0 - u 0 * v 2) * w 2 - (u 0 * v 1 - u 1 * v 0) * w 1 +\n      (v 1 * (u 0 * w 1 - u 1 * w 0) - v 2 * (u 2 * w 0 - u 0 * w 2))\n---\ncase h\u2081\nR : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 2 * (v 1 * w 2 - v 2 * w 1) - u 0 * (v 0 * w 1 - v 1 * w 0) =\n    (u 0 * v 1 - u 1 * v 0) * w 0 - (u 1 * v 2 - u 2 * v 1) * w 2 +\n      (v 2 * (u 1 * w 2 - u 2 * w 1) - v 0 * (u 0 * w 1 - u 1 * w 0))\n---\ncase h\u2082\nR : Type u_1\ninst\u271d : CommRing R\nu v w : Fin 3 \u2192 R\n\u22a2 u 0 * (v 2 * w 0 - v 0 * w 2) - u 1 * (v 1 * w 2 - v 2 * w 1) =\n    (u 1 * v 2 - u 2 * v 1) * w 1 - (u 2 * v 0 - u 0 * v 2) * w 0 +\n      (v 0 * (u 2 * w 0 - u 0 * w 2) - v 1 * (u 1 * w 2 - u 2 * w 1))"}]}
{"declaration": "theorem lsum_single [Semiring S] [Module S N] [SMulCommClass R S N] (F : \u2200 i, M i \u2192\u2097[R] N) (i)\n    (x : M i) : lsum S F (single i x) = F i x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\nx\u271d : Sort u_6\nlsum : x\u271d\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S N\ninst\u271d : SMulCommClass R S N\nF : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry = (F i) x"}, {"line": "simp", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nS : Type u_3\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2076 : AddCommMonoid N\ninst\u271d\u2075 : Module R N\ninst\u271d\u2074 inst\u271d\u00b3 : DecidableEq \u03b9\nx\u271d : Sort u_6\nlsum : x\u271d\ninst\u271d\u00b2 : Semiring S\ninst\u271d\u00b9 : Module S N\ninst\u271d : SMulCommClass R S N\nF : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry () = (F i) x"}]}
{"declaration": "theorem sum_mapRange_index.linearMap [DecidableEq \u03b9] {f : \u2200 i, \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i}\n    {h : \u2200 i, \u03b2\u2082 i \u2192\u2097[R] N} {l : \u03a0\u2080 i, \u03b2\u2081 i} :\n    DFinsupp.lsum \u2115 h (mapRange.linearMap f l) = DFinsupp.lsum \u2115 (fun i => (h i).comp (f i)) l := by\n  classical simpa [DFinsupp.sumAddHom_apply] using sum_mapRange_index fun i => by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]", "{\u03b2 \u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, AddCommMonoid (\u03b2\u2081 i)] [\u2200 i, AddCommMonoid (\u03b2\u2082 i)]", "[\u2200 i, Module R (\u03b2 i)] [\u2200 i, Module R (\u03b2\u2081 i)] [\u2200 i, Module R (\u03b2\u2082 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R N\ninst\u271d\u2076 inst\u271d\u2075 : DecidableEq \u03b9\n\u03b2\u2081 : \u03b9 \u2192 Type u_7\n\u03b2\u2082 : \u03b9 \u2192 Type u_8\ninst\u271d\u2074 : (i : \u03b9) \u2192 AddCommMonoid (\u03b2\u2081 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 AddCommMonoid (\u03b2\u2082 i)\ninst\u271d\u00b2 : (i : \u03b9) \u2192 Module R (\u03b2\u2081 i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 Module R (\u03b2\u2082 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i\nh : (i : \u03b9) \u2192 \u03b2\u2082 i \u2192\u2097[R] N\nl : \u03a0\u2080 (i : \u03b9), \u03b2\u2081 i\n\u22a2 ((DFinsupp.lsum \u2115) h) sorry = ((DFinsupp.lsum \u2115) fun i => h i \u2218\u2097 f i) l"}, {"line": "classical simpa [DFinsupp.sumAddHom_apply] using sum_mapRange_index fun i => by simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprodMap_apply_single (f : \u2200 i : \u03b9, M i \u2192\u2097[R] N) (i : \u03b9) (x : M i) :\n    coprodMap f (single i x) = f i x := by\n  simp [coprodMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]", "{\u03b2 \u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, AddCommMonoid (\u03b2\u2081 i)] [\u2200 i, AddCommMonoid (\u03b2\u2082 i)]", "[\u2200 i, Module R (\u03b2 i)] [\u2200 i, Module R (\u03b2\u2081 i)] [\u2200 i, Module R (\u03b2\u2082 i)]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_9\ncoprodMap : x\u271d\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry = (f i) x"}, {"line": "simp [coprodMap]", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nM : \u03b9 \u2192 Type u_4\nN : Type u_5\ninst\u271d\u2077 : Semiring R\ninst\u271d\u2076 : (i : \u03b9) \u2192 AddCommMonoid (M i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Module R (M i)\ninst\u271d\u2074 : AddCommMonoid N\ninst\u271d\u00b3 : Module R N\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : DecidableEq \u03b9\nx\u271d : Sort u_9\ncoprodMap : x\u271d\nf : (i : \u03b9) \u2192 M i \u2192\u2097[R] N\ni : \u03b9\nx : M i\n\u22a2 sorry () = (f i) x"}]}
{"declaration": "theorem mem_iSup_finset_iff_exists_sum {s : Finset \u03b9} (p : \u03b9 \u2192 Submodule R N) (a : N) :\n    (a \u2208 \u2a06 i \u2208 s, p i) \u2194 \u2203 \u03bc : \u2200 i, p i, (\u2211 i \u2208 s, (\u03bc i : N)) = a := by\n  classical\n    rw [Submodule.mem_iSup_iff_exists_dfinsupp']\n    constructor <;> rintro \u27e8\u03bc, h\u03bc\u27e9\n    \u00b7 use fun i => \u27e8\u03bc i, (iSup_const_le : _ \u2264 p i) (coe_mem <| \u03bc i)\u27e9\n      rw [\u2190 h\u03bc]\n      symm\n      apply Finset.sum_subset\n      \u00b7 intro x\n        contrapose\n        intro hx\n        rw [mem_support_iff]\n        rw [not_ne_iff]\n        ext\n        rw [coe_zero]\n        rw [\u2190 mem_bot R]\n        suffices \u22a5 = \u2a06 (_ : x \u2208 s), p x from this.symm \u25b8 coe_mem (\u03bc x)\n        exact (iSup_neg hx).symm\n      \u00b7 intro x _ hx\n        rw [mem_support_iff] at hx\n        rw [not_ne_iff] at hx\n        rw [hx]\n        rfl\n    \u00b7 refine \u27e8DFinsupp.mk s ?_, ?_\u27e9\n      \u00b7 rintro \u27e8i, hi\u27e9\n        refine \u27e8\u03bc i, ?_\u27e9\n        rw [iSup_pos]\n        \u00b7 exact coe_mem _\n        \u00b7 exact hi\n      simp only [DFinsupp.sum]\n      rw [Finset.sum_subset support_mk_subset]\n      rw [\u2190 h\u03bc]\n      \u00b7 exact Finset.sum_congr rfl fun x hx => by rw [mk_of_mem hx]\n      \u00b7 intro x _ hx\n        rw [mem_support_iff] at hx\n        rw [not_ne_iff] at hx\n        rw [hx]\n        rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/DFinsupp.lean", "context": {"open": ["DFinsupp"], "variables": ["{\u03b9 : Type*} {R : Type*} {S : Type*} {M : \u03b9 \u2192 Type*} {N : Type*}", "[Semiring R] [\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)]", "[AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]", "(S)", "[DecidableEq \u03b9]", "{\u03b2 \u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*}", "[\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, AddCommMonoid (\u03b2\u2081 i)] [\u2200 i, AddCommMonoid (\u03b2\u2082 i)]", "[\u2200 i, Module R (\u03b2 i)] [\u2200 i, Module R (\u03b2\u2081 i)] [\u2200 i, Module R (\u03b2\u2082 i)]", "[DecidableEq \u03b9]", "[Semiring R] [AddCommMonoid N] [Module R N]", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nR : Type u_2\nN : Type u_5\ninst\u271d\u2079 : Semiring R\ninst\u271d\u2078 : AddCommMonoid N\ninst\u271d\u2077 : Module R N\ninst\u271d\u2076 inst\u271d\u2075 inst\u271d\u2074 : DecidableEq \u03b9\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : AddCommMonoid N\ninst\u271d\u00b9 : Module R N\ninst\u271d : DecidableEq \u03b9\ns : Finset \u03b9\np : \u03b9 \u2192 Submodule R N\na : N\n\u22a2 a \u2208 \u2a06 i \u2208 s, p i \u2194 \u2203 \u03bc, \u2211 i \u2208 s, \u2191(\u03bc i) = a"}, {"line": "classical\n    rw [Submodule.mem_iSup_iff_exists_dfinsupp']\n    constructor <;> rintro \u27e8\u03bc, h\u03bc\u27e9\n    \u00b7 use fun i => \u27e8\u03bc i, (iSup_const_le : _ \u2264 p i) (coe_mem <| \u03bc i)\u27e9\n      rw [\u2190 h\u03bc]\n      symm\n      apply Finset.sum_subset\n      \u00b7 intro x\n        contrapose\n        intro hx\n        rw [mem_support_iff]\n        rw [not_ne_iff]\n        ext\n        rw [coe_zero]\n        rw [\u2190 mem_bot R]\n        suffices \u22a5 = \u2a06 (_ : x \u2208 s), p x from this.symm \u25b8 coe_mem (\u03bc x)\n        exact (iSup_neg hx).symm\n      \u00b7 intro x _ hx\n        rw [mem_support_iff] at hx\n        rw [not_ne_iff] at hx\n        rw [hx]\n        rfl\n    \u00b7 refine \u27e8DFinsupp.mk s ?_, ?_\u27e9\n      \u00b7 rintro \u27e8i, hi\u27e9\n        refine \u27e8\u03bc i, ?_\u27e9\n        rw [iSup_pos]\n        \u00b7 exact coe_mem _\n        \u00b7 exact hi\n      simp only [DFinsupp.sum]\n      rw [Finset.sum_subset support_mk_subset]\n      rw [\u2190 h\u03bc]\n      \u00b7 exact Finset.sum_congr rfl fun x hx => by rw [mk_of_mem hx]\n      \u00b7 intro x _ hx\n        rw [mem_support_iff] at hx\n        rw [not_ne_iff] at hx\n        rw [hx]\n        rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem detAux_def' (b : Basis \u03b9 A M) (f : M \u2192\u2097[A] M) :\n    LinearMap.detAux (Trunc.mk b) f = Matrix.det (LinearMap.toMatrix b b f) := by\n  rw [detAux]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d\u2074 : AddCommGroup M\n\u03b9 : Type u_4\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\nA : Type u_8\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Module A M\nb : Basis \u03b9 A M\nf : M \u2192\u2097[A] M\n\u22a2 (detAux (Trunc.mk b)) f = ((toMatrix b b) f).det"}, {"line": "rw [detAux]", "tactic_state": "M : Type u_2\ninst\u271d\u2074 : AddCommGroup M\n\u03b9 : Type u_4\ninst\u271d\u00b3 : DecidableEq \u03b9\ninst\u271d\u00b2 : Fintype \u03b9\nA : Type u_8\ninst\u271d\u00b9 : CommRing A\ninst\u271d : Module A M\nb : Basis \u03b9 A M\nf : M \u2192\u2097[A] M\n\u22a2 (Trunc.lift (fun b => detMonoidHom.comp \u2191(toMatrixAlgEquiv b)) \u22ef (Trunc.mk b)) f = ((toMatrix b b) f).det"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem det_toMatrix' {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] (f : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A) :\n    Matrix.det (LinearMap.toMatrix' f) = LinearMap.det f := by simp [\u2190 toMatrix_eq_toMatrix']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\n\u03b9 : Type u_6\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A\n\u22a2 (toMatrix' f).det = LinearMap.det f"}, {"line": "simp [\u2190 toMatrix_eq_toMatrix']", "tactic_state": "A : Type u_2\ninst\u271d\u00b2 : CommRing A\n\u03b9 : Type u_6\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\nf : (\u03b9 \u2192 A) \u2192\u2097[A] \u03b9 \u2192 A\n\u22a2 ((toMatrix (Pi.basisFun A \u03b9) (Pi.basisFun A \u03b9)) f).det = LinearMap.det f"}]}
{"declaration": "lemma det_mulLeft (a : R) : (mulLeft R a).det = a := by simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry () = a"}]}
{"declaration": "lemma det_mulRight (a : R) : (mulRight R a).det = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "R : Type u_6\na : R\n\u22a2 sorry () = a"}]}
{"declaration": "theorem Basis.det_self : e.det e = 1 := by simp [e.det_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 1"}, {"line": "simp [e.det_apply]", "tactic_state": "\u22a2 sorry () = 1"}]}
{"declaration": "theorem Basis.det_unitsSMul_self (w : \u03b9 \u2192 R\u02e3) : e.det (e.unitsSMul w) = \u220f i, (w i : R) := by\n  simp [Basis.det_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Determinant.lean", "context": {"open": ["Matrix LinearMap Submodule Set Function", "scoped Classical in", "scoped Classical in"], "variables": ["{R : Type*} [CommRing R]", "{M : Type*} [AddCommGroup M] [Module R M]", "{M' : Type*} [AddCommGroup M'] [Module R M']", "{\u03b9 : Type*} [DecidableEq \u03b9] [Fintype \u03b9]", "(e : Basis \u03b9 R M)", "{A : Type*} [CommRing A]", "{m n : Type*}", "[Fintype m] [Fintype n]", "{A : Type*} [CommRing A] [Module A M]", "{\u03ba : Type*} [Fintype \u03ba]", "{A : Type*} [CommRing A] [Module A M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nw : \u03b9 \u2192 sorry\n\u22a2 sorry = \u220f i, sorry"}, {"line": "simp [Basis.det_apply]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : Fintype \u03b9\nw : \u03b9 \u2192 sorry\n\u22a2 sorry () = \u220f i, sorry ()"}]}
{"declaration": "theorem card_le_of_injective [StrongRankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R) (i : Injective f) : Fintype.card \u03b1 \u2264 Fintype.card \u03b2 := by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b1)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b2)\n  exact\n    le_of_fin_injective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).injective.comp i).comp (LinearEquiv.injective P))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "context": {"open": ["Function"], "variables": ["(R : Type u) [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Fintype.card \u03b1 \u2264 Fintype.card \u03b2"}, {"line": "let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b1)", "tactic_state": "case refine_5\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype.card \u03b1 \u2264 Fintype.card \u03b2\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Fintype \u03b1"}, {"line": "let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b2)", "tactic_state": "case refine_5.refine_5\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\nQ : (Fin (Fintype.card \u03b2) \u2192 R) \u2243\u2097[R] \u03b2 \u2192 R := sorry\n\u22a2 Fintype.card \u03b1 \u2264 Fintype.card \u03b2\n---\ncase refine_5.refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Semiring R\n---\ncase refine_5.refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 AddCommMonoid R\n---\ncase refine_5.refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Module R R\n---\ncase refine_5.refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype \u03b2\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Fintype \u03b1"}, {"line": "exact\n    le_of_fin_injective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).injective.comp i).comp (LinearEquiv.injective P))", "tactic_state": "case refine_5.refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 AddCommMonoid R\n---\ncase refine_5.refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Module R R\n---\ncase refine_5.refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype \u03b2\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : StrongRankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Injective \u21d1f\n\u22a2 Fintype \u03b1"}]}
{"declaration": "theorem card_le_of_surjective [RankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R) (i : Surjective f) : Fintype.card \u03b2 \u2264 Fintype.card \u03b1 := by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b1)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b2)\n  exact\n    le_of_fin_surjective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).surjective.comp i).comp (LinearEquiv.surjective P))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "context": {"open": ["Function"], "variables": ["(R : Type u) [Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Fintype.card \u03b2 \u2264 Fintype.card \u03b1"}, {"line": "let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b1)", "tactic_state": "case refine_5\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype.card \u03b2 \u2264 Fintype.card \u03b1\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Fintype \u03b1"}, {"line": "let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin \u03b2)", "tactic_state": "case refine_5.refine_5\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\nQ : (Fin (Fintype.card \u03b2) \u2192 R) \u2243\u2097[R] \u03b2 \u2192 R := sorry\n\u22a2 Fintype.card \u03b2 \u2264 Fintype.card \u03b1\n---\ncase refine_5.refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Semiring R\n---\ncase refine_5.refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 AddCommMonoid R\n---\ncase refine_5.refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Module R R\n---\ncase refine_5.refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype \u03b2\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Fintype \u03b1"}, {"line": "exact\n    le_of_fin_surjective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).surjective.comp i).comp (LinearEquiv.surjective P))", "tactic_state": "case refine_5.refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 AddCommMonoid R\n---\ncase refine_5.refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Module R R\n---\ncase refine_5.refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\nP : (Fin (Fintype.card \u03b1) \u2192 R) \u2243\u2097[R] \u03b1 \u2192 R := sorry\n\u22a2 Fintype \u03b2\n---\ncase refine_1\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Semiring R\n---\ncase refine_2\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 AddCommMonoid R\n---\ncase refine_3\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Module R R\n---\ncase refine_4\nR : Type u\ninst\u271d\u00b3 : Semiring R\ninst\u271d\u00b2 : RankCondition R\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Fintype \u03b1\ninst\u271d : Fintype \u03b2\nf : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R\ni : Surjective \u21d1f\n\u22a2 Fintype \u03b1"}]}
{"declaration": "theorem eq_of_degree_le_of_eval_finset_eq\n    (h_deg_le : f.degree \u2264 #s)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : \u2200 x \u2208 s, f.eval x = g.eval x) :\n    f = g := by\n  rcases eq_or_ne f 0 with rfl | hf\n  \u00b7 rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq\n  \u00b7 exact eq_of_degree_sub_lt_of_eval_finset_eq s\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le) h_eval\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\ns : Finset R\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 x \u2208 s, Polynomial.eval x f = Polynomial.eval x g\n\u22a2 f = g"}, {"line": "rcases eq_or_ne f 0 with rfl | hf", "tactic_state": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\ng : Polynomial R\ns : Finset R\nh_deg_le : degree 0 \u2264 \u2191s.card\nh_deg_eq : degree 0 = g.degree\nhlc : leadingCoeff 0 = g.leadingCoeff\nh_eval : \u2200 x \u2208 s, Polynomial.eval x 0 = Polynomial.eval x g\n\u22a2 0 = g\n---\ncase inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\ns : Finset R\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 x \u2208 s, Polynomial.eval x f = Polynomial.eval x g\nhf : f \u2260 0\n\u22a2 f = g"}, {"line": "\u00b7 rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq", "tactic_state": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\ns : Finset R\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 x \u2208 s, Polynomial.eval x f = Polynomial.eval x g\nhf : f \u2260 0\n\u22a2 f = g"}, {"line": "\u00b7 exact eq_of_degree_sub_lt_of_eval_finset_eq s\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le) h_eval", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_degree_le_of_eval_index_eq (hvs : Set.InjOn v s)\n    (h_deg_le : f.degree \u2264 #s)\n    (h_deg_eq : f.degree = g.degree)\n    (hlc : f.leadingCoeff = g.leadingCoeff)\n    (h_eval : \u2200 i \u2208 s, f.eval (v i) = g.eval (v i)) : f = g := by\n  rcases eq_or_ne f 0 with rfl | hf\n  \u00b7 rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq\n  \u00b7 exact eq_of_degree_sub_lt_of_eval_index_eq s hvs\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le)\n      h_eval\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset", "Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)", "{\u03b9 : Type*} {v : \u03b9 \u2192 R} (s : Finset \u03b9)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\n\u03b9 : Type u_2\nv : \u03b9 \u2192 R\ns : Finset \u03b9\nhvs : Set.InjOn v \u2191s\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 i \u2208 s, Polynomial.eval (v i) f = Polynomial.eval (v i) g\n\u22a2 f = g"}, {"line": "rcases eq_or_ne f 0 with rfl | hf", "tactic_state": "case inl\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\ng : Polynomial R\n\u03b9 : Type u_2\nv : \u03b9 \u2192 R\ns : Finset \u03b9\nhvs : Set.InjOn v \u2191s\nh_deg_le : degree 0 \u2264 \u2191s.card\nh_deg_eq : degree 0 = g.degree\nhlc : leadingCoeff 0 = g.leadingCoeff\nh_eval : \u2200 i \u2208 s, Polynomial.eval (v i) 0 = Polynomial.eval (v i) g\n\u22a2 0 = g\n---\ncase inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\n\u03b9 : Type u_2\nv : \u03b9 \u2192 R\ns : Finset \u03b9\nhvs : Set.InjOn v \u2191s\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 i \u2208 s, Polynomial.eval (v i) f = Polynomial.eval (v i) g\nhf : f \u2260 0\n\u22a2 f = g"}, {"line": "\u00b7 rwa [degree_zero, eq_comm, degree_eq_bot, eq_comm] at h_deg_eq", "tactic_state": "case inr\nR : Type u_1\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsDomain R\nf g : Polynomial R\n\u03b9 : Type u_2\nv : \u03b9 \u2192 R\ns : Finset \u03b9\nhvs : Set.InjOn v \u2191s\nh_deg_le : f.degree \u2264 \u2191s.card\nh_deg_eq : f.degree = g.degree\nhlc : f.leadingCoeff = g.leadingCoeff\nh_eval : \u2200 i \u2208 s, Polynomial.eval (v i) f = Polynomial.eval (v i) g\nhf : f \u2260 0\n\u22a2 f = g"}, {"line": "\u00b7 exact eq_of_degree_sub_lt_of_eval_index_eq s hvs\n      (lt_of_lt_of_le (degree_sub_lt h_deg_eq hf hlc) h_deg_le)\n      h_eval", "tactic_state": "No Goals!"}]}
{"declaration": "theorem basis_pair_right (hij : i \u2260 j) : Lagrange.basis {i, j} v j = basisDivisor (v j) (v i) := by\n  rw [pair_comm]\n  exact basis_pair_left hij.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset", "Finset", "Polynomial", "Finset"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)", "{\u03b9 : Type*} {v : \u03b9 \u2192 R} (s : Finset \u03b9)", "{F : Type*} [Field F]", "{x y : F}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s : Finset \u03b9} {v : \u03b9 \u2192 F} {i j : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_4\ninst\u271d\u00b9 : Field F\n\u03b9 : Type u_5\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 F\ni j : \u03b9\nx\u271d : Sort u_6\nbasisDivisor : x\u271d\nhij : i \u2260 j\n\u22a2 Lagrange.basis {i, j} v j = sorry"}, {"line": "rw [pair_comm]", "tactic_state": "F : Type u_4\ninst\u271d\u00b9 : Field F\n\u03b9 : Type u_5\ninst\u271d : DecidableEq \u03b9\nv : \u03b9 \u2192 F\ni j : \u03b9\nx\u271d : Sort u_6\nbasisDivisor : x\u271d\nhij : i \u2260 j\n\u22a2 Lagrange.basis {j, i} v j = sorry"}, {"line": "exact basis_pair_left hij.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodal_ne_zero [Nontrivial R] : nodal s v \u2260 0 := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Lagrange.lean", "context": {"open": ["Polynomial", "Function Fintype", "scoped Finset", "Finset", "Polynomial", "Finset", "Finset", "Finset Polynomial"], "variables": ["{R : Type*} [CommRing R] [IsDomain R] {f g : R[X]}", "(s : Finset R)", "{\u03b9 : Type*} {v : \u03b9 \u2192 R} (s : Finset \u03b9)", "{F : Type*} [Field F]", "{x y : F}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s : Finset \u03b9} {v : \u03b9 \u2192 F} {i j : \u03b9}", "{F : Type*} [Field F] {\u03b9 : Type*} [DecidableEq \u03b9]", "{s t : Finset \u03b9} {i j : \u03b9} {v : \u03b9 \u2192 F} (r r' : \u03b9 \u2192 F)", "{R : Type*} [CommRing R] {\u03b9 : Type*}", "{s : Finset \u03b9} {v : \u03b9 \u2192 R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_8\ninst\u271d\u00b9 : CommRing R\nx\u271d : Sort u_10\nnodal : x\u271d\ninst\u271d : Nontrivial R\n\u22a2 sorry \u2260 0"}]}
{"declaration": "theorem mem_graph_snd_inj' (f : E \u2192\u2097.[R] F) {x y : E \u00d7 F} (hx : x \u2208 f.graph) (hy : y \u2208 f.graph)\n    (hxy : x.1 = y.1) : x.2 = y.2 := by\n  cases x\n  cases y\n  exact f.mem_graph_snd_inj hx hy hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/LinearPMap.lean", "context": {"open": ["Submodule"], "variables": ["{R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E] {F : Type*}", "{M N : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F]", "[Monoid N] [DistribMulAction N F] [SMulCommClass R N F]", "{K : Type*} [DivisionRing K] [Module K E] [Module K F]", "{M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F] (y : M)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\nx y : E \u00d7 F\nhx : x \u2208 sorry\nhy : y \u2208 sorry\nhxy : x.1 = y.1\n\u22a2 x.2 = y.2"}, {"line": "cases x", "tactic_state": "case mk\nE : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\ny : E \u00d7 F\nfst\u271d : E\nsnd\u271d : F\nhx : (fst\u271d, snd\u271d) \u2208 sorry\nhy : y \u2208 sorry\nhxy : (fst\u271d, snd\u271d).1 = y.1\n\u22a2 (fst\u271d, snd\u271d).2 = y.2"}, {"line": "cases y", "tactic_state": "case mk.mk\nE : Type u_2\ninst\u271d : AddCommGroup E\nF : Type u_3\nf : sorry\nfst\u271d\u00b9 : E\nsnd\u271d\u00b9 : F\nfst\u271d : E\nsnd\u271d : F\nhx : (fst\u271d\u00b9, snd\u271d\u00b9) \u2208 sorry\nhy : (fst\u271d, snd\u271d) \u2208 sorry\nhxy : (fst\u271d\u00b9, snd\u271d\u00b9).1 = (fst\u271d, snd\u271d).1\n\u22a2 (fst\u271d\u00b9, snd\u271d\u00b9).2 = (fst\u271d, snd\u271d).2"}, {"line": "exact f.mem_graph_snd_inj hx hy hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Orientation.map_refl : (Orientation.map \u03b9 <| LinearEquiv.refl R M) = Equiv.refl _ := by\n  rw [Orientation.map]\n  rw [AlternatingMap.domLCongr_refl]\n  rw [Module.Ray.map_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 map \u03b9 (LinearEquiv.refl R M) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [Orientation.map]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 Module.Ray.map (AlternatingMap.domLCongr R R \u03b9 R (LinearEquiv.refl R M)) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [AlternatingMap.domLCongr_refl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 Module.Ray.map (LinearEquiv.refl R (M [\u22c0^\u03b9]\u2192\u2097[R] R)) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [Module.Ray.map_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Orientation.reindex_refl : (Orientation.reindex R M <| Equiv.refl \u03b9) = Equiv.refl _ := by\n  rw [Orientation.reindex]\n  rw [AlternatingMap.domDomCongr\u2097_refl]\n  rw [Module.Ray.map_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}", "(R M) {\u03b9 \u03b9'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 reindex R M (Equiv.refl \u03b9) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [Orientation.reindex]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 Module.Ray.map (AlternatingMap.domDomCongr\u2097 R (Equiv.refl \u03b9)) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [AlternatingMap.domDomCongr\u2097_refl]", "tactic_state": "R : Type u_1\ninst\u271d\u2074 : CommSemiring R\ninst\u271d\u00b3 : PartialOrder R\ninst\u271d\u00b2 : IsStrictOrderedRing R\nM : Type u_2\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\n\u03b9 : Type u_4\n\u22a2 Module.Ray.map (LinearEquiv.refl R (M [\u22c0^\u03b9]\u2192\u2097[R] R)) = Equiv.refl (Orientation R M \u03b9)"}, {"line": "rw [Module.Ray.map_refl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orientation_map (e : Basis \u03b9 R M) (f : M \u2243\u2097[R] N) :\n    (e.map f).orientation = Orientation.map \u03b9 f e.orientation := by\n  simp_rw [Basis.orientation, Orientation.map_apply, Basis.det_map']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}", "(R M) {\u03b9 \u03b9'}", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{\u03b9 \u03b9' : Type*}", "[Fintype \u03b9] [DecidableEq \u03b9] [Fintype \u03b9'] [DecidableEq \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u2078 : CommRing R\ninst\u271d\u2077 : PartialOrder R\ninst\u271d\u2076 : IsStrictOrderedRing R\nM : Type u_7\nN : Type u_8\ninst\u271d\u2075 : AddCommGroup M\ninst\u271d\u2074 : AddCommGroup N\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : Module R N\n\u03b9 : Type u_9\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : DecidableEq \u03b9\ne : Basis \u03b9 R M\nf : M \u2243\u2097[R] N\n\u22a2 (e.map f).orientation = (Orientation.map \u03b9 f) e.orientation"}, {"line": "simp_rw [Basis.orientation, Orientation.map_apply, Basis.det_map']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orientation_isEmpty [IsEmpty \u03b9] (b : Basis \u03b9 R M) :\n    b.orientation = positiveOrientation := by\n  rw [Basis.orientation]\n  congr\n  exact b.det_isEmpty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/LinearAlgebra/Orientation.lean", "context": {"open": [], "variables": ["(R : Type*) [CommSemiring R] [PartialOrder R] [IsStrictOrderedRing R]", "(M : Type*) [AddCommMonoid M] [Module R M]", "{N : Type*} [AddCommMonoid N] [Module R N]", "(\u03b9 \u03b9' : Type*)", "{R M}", "(R M) {\u03b9 \u03b9'}", "{R : Type*} [CommRing R] [PartialOrder R] [IsStrictOrderedRing R]", "{M N : Type*} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]", "{\u03b9 \u03b9' : Type*}", "[Fintype \u03b9] [DecidableEq \u03b9] [Fintype \u03b9'] [DecidableEq \u03b9']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 b.orientation = positiveOrientation"}, {"line": "rw [Basis.orientation]", "tactic_state": "R : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 rayOfNeZero R b.det \u22ef = positiveOrientation"}, {"line": "congr", "tactic_state": "case e_v\nR : Type u_6\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : PartialOrder R\ninst\u271d\u2075 : IsStrictOrderedRing R\nM : Type u_7\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\n\u03b9 : Type u_9\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : IsEmpty \u03b9\nb : Basis \u03b9 R M\n\u22a2 b.det = AlternatingMap.constLinearEquivOfIsEmpty 1"}, {"line": "exact b.det_isEmpty", "tactic_state": "No Goals!"}]}
