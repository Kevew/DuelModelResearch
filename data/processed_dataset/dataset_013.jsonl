{"declaration": "theorem countable_pi {\u03c0 : \u03b1 \u2192 Type*} [Finite \u03b1] {s : \u2200 a, Set (\u03c0 a)} (hs : \u2200 a, (s a).Countable) :\n    { f : \u2200 a, \u03c0 a | \u2200 a, f a \u2208 s a }.Countable := by\n  simpa only [\u2190 mem_univ_pi] using countable_univ_pi hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03c0 : \u03b1 \u2192 Type u_1\ninst\u271d : Finite \u03b1\ns : (a : \u03b1) \u2192 Set (\u03c0 a)\nhs : \u2200 (a : \u03b1), (s a).Countable\n\u22a2 {f | \u2200 (a : \u03b1), f a \u2208 s a}.Countable"}, {"line": "simpa only [\u2190 mem_univ_pi] using countable_univ_pi hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Countable.image2 {s : Set \u03b1} {t : Set \u03b2} (hs : s.Countable) (ht : t.Countable)\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : (image2 f s t).Countable := by\n  rw [\u2190 image_prod]\n  exact (hs.prod ht).image _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Set \u03b1\nt : Set \u03b2\nhs : s.Countable\nht : t.Countable\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 (Set.image2 f s t).Countable"}, {"line": "rw [\u2190 image_prod]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ns : Set \u03b1\nt : Set \u03b2\nhs : s.Countable\nht : t.Countable\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 ((fun x => f x.1 x.2) '' s \u00d7\u02e2 t).Countable"}, {"line": "exact (hs.prod ht).image _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equitableOn_iff_exists_le_le_add_one {s : Set \u03b1} {f : \u03b1 \u2192 \u2115} :\n    s.EquitableOn f \u2194 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1 := by\n  refine \u27e8?_, fun \u27e8b, hb\u27e9 x y hx hy => (hb x hx).2.trans (add_le_add_right (hb y hy).1 _)\u27e9\n  obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty\n  \u00b7 simp\n  intro hs\n  by_cases h : \u2200 y \u2208 s, f x \u2264 f y\n  \u00b7 exact \u27e8f x, fun y hy => \u27e8h _ hy, hs hy hx\u27e9\u27e9\n  push_neg at h\n  obtain \u27e8w, hw, hwx\u27e9 := h\n  refine \u27e8f w, fun y hy => \u27e8Nat.le_of_succ_le_succ ?_, hs hy hw\u27e9\u27e9\n  rw [(Nat.succ_le_of_lt hwx).antisymm (hs hx hw)]\n  exact hs hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Equitable.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 s.EquitableOn f \u2194 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "refine \u27e8?_, fun \u27e8b, hb\u27e9 x y hx hy => (hb x hx).2.trans (add_le_add_right (hb y hy).1 _)\u27e9", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 s.EquitableOn f \u2192 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\n\u22a2 \u2205.EquitableOn f \u2192 \u2203 b, \u2200 a \u2208 \u2205, b \u2264 f a \u2227 f a \u2264 b + 1\n---\ncase inr.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s.EquitableOn f \u2192 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "\u00b7 simp", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s.EquitableOn f \u2192 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "intro hs", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "by_cases h : \u2200 y \u2208 s, f x \u2264 f y", "tactic_state": "case pos\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nh : \u2200 y \u2208 s, f x \u2264 f y\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1\n---\ncase neg\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nh : \u00ac\u2200 y \u2208 s, f x \u2264 f y\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "\u00b7 exact \u27e8f x, fun y hy => \u27e8h _ hy, hs hy hx\u27e9\u27e9", "tactic_state": "case neg\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nh : \u00ac\u2200 y \u2208 s, f x \u2264 f y\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "push_neg at h", "tactic_state": "case neg\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nh : \u2203 y \u2208 s, f y < f x\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "obtain \u27e8w, hw, hwx\u27e9 := h", "tactic_state": "case neg.intro.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nw : \u03b1\nhw : w \u2208 s\nhwx : f w < f x\n\u22a2 \u2203 b, \u2200 a \u2208 s, b \u2264 f a \u2227 f a \u2264 b + 1"}, {"line": "refine \u27e8f w, fun y hy => \u27e8Nat.le_of_succ_le_succ ?_, hs hy hw\u27e9\u27e9", "tactic_state": "case neg.intro.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nw : \u03b1\nhw : w \u2208 s\nhwx : f w < f x\ny : \u03b1\nhy : y \u2208 s\n\u22a2 (f w).succ \u2264 (f y).succ"}, {"line": "rw [(Nat.succ_le_of_lt hwx).antisymm (hs hx hw)]", "tactic_state": "case neg.intro.intro\n\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u2115\nx : \u03b1\nhx : x \u2208 s\nhs : s.EquitableOn f\nw : \u03b1\nhw : w \u2208 s\nhwx : f w < f x\ny : \u03b1\nhy : y \u2208 s\n\u22a2 f x \u2264 (f y).succ"}, {"line": "exact hs hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_equitableOn : \u00acs.EquitableOn f \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, f b + 1 < f a := by\n  simp [EquitableOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Equitable.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[LinearOrder \u03b2] [Add \u03b2] [One \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : LinearOrder \u03b2\ninst\u271d\u00b9 : Add \u03b2\ninst\u271d : One \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acs.EquitableOn f \u2194 \u2203 a \u2208 s, \u2203 b \u2208 s, f b + 1 < f a"}, {"line": "simp [EquitableOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqOn_singleton : Set.EqOn f\u2081 f\u2082 {a} \u2194 f\u2081 a = f\u2082 a := by\n  simp [Set.EqOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 Set.EqOn f\u2081 f\u2082 {a} \u2194 f\u2081 a = f\u2082 a"}, {"line": "simp [Set.EqOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqOn_univ (f\u2081 f\u2082 : \u03b1 \u2192 \u03b2) : EqOn f\u2081 f\u2082 univ \u2194 f\u2081 = f\u2082 := by\n  simp [EqOn, funext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nEqOn : x\u271d\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\n\u22a2 sorry \u2194 f\u2081 = f\u2082"}, {"line": "simp [EqOn, funext_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_7\nEqOn : x\u271d\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\n\u22a2 sorry () \u2194 \u2200 (x : \u03b1), f\u2081 x = f\u2082 x"}]}
{"declaration": "lemma MapsTo.insert (h : MapsTo f s t) (x : \u03b1) : MapsTo f (insert x s) (insert (f x) t) := by\n  simpa [\u2190 singleton_union] using h.mono_right subset_union_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_7\nMapsTo : x\u271d\nh : sorry\nx : \u03b1\n\u22a2 sorry"}, {"line": "simpa [\u2190 singleton_union] using h.mono_right subset_union_right", "tactic_state": "No Goals!"}]}
{"declaration": "lemma InjOn.image_subset_image_iff (h : s.InjOn f) (h\u2081 : s\u2081 \u2286 s) (h\u2082 : s\u2082 \u2286 s) :\n    f '' s\u2081 \u2286 f '' s\u2082 \u2194 s\u2081 \u2286 s\u2082 := by\n  refine \u27e8fun h' \u21a6 ?_, image_subset _\u27e9\n  rw [\u2190 h.preimage_image_inter h\u2081]\n  rw [\u2190 h.preimage_image_inter h\u2082]\n  exact inter_subset_inter_left _ (preimage_mono h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 s\u2082 : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.InjOn f s\nh\u2081 : s\u2081 \u2286 s\nh\u2082 : s\u2082 \u2286 s\n\u22a2 f '' s\u2081 \u2286 f '' s\u2082 \u2194 s\u2081 \u2286 s\u2082"}, {"line": "refine \u27e8fun h' \u21a6 ?_, image_subset _\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 s\u2082 : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.InjOn f s\nh\u2081 : s\u2081 \u2286 s\nh\u2082 : s\u2082 \u2286 s\nh' : f '' s\u2081 \u2286 f '' s\u2082\n\u22a2 s\u2081 \u2286 s\u2082"}, {"line": "rw [\u2190 h.preimage_image_inter h\u2081]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 s\u2082 : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.InjOn f s\nh\u2081 : s\u2081 \u2286 s\nh\u2082 : s\u2082 \u2286 s\nh' : f '' s\u2081 \u2286 f '' s\u2082\n\u22a2 f \u207b\u00b9' (f '' s\u2081) \u2229 s \u2286 s\u2082"}, {"line": "rw [\u2190 h.preimage_image_inter h\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 s\u2082 : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : Set.InjOn f s\nh\u2081 : s\u2081 \u2286 s\nh\u2082 : s\u2082 \u2286 s\nh' : f '' s\u2081 \u2286 f '' s\u2082\n\u22a2 f \u207b\u00b9' (f '' s\u2081) \u2229 s \u2286 f \u207b\u00b9' (f '' s\u2082) \u2229 s"}, {"line": "exact inter_subset_inter_left _ (preimage_mono h')", "tactic_state": "No Goals!"}]}
{"declaration": "lemma surjOn_id (s : Set \u03b1) : SurjOn id s s := by simp [SurjOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_7\nSurjOn : x\u271d\ns : Set \u03b1\n\u22a2 sorry"}, {"line": "simp [SurjOn]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_7\nSurjOn : x\u271d\ns : Set \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem surjective_iff_surjOn_univ : Surjective f \u2194 SurjOn f univ univ := by\n  simp [Surjective, SurjOn, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_7\nSurjOn : x\u271d\n\u22a2 Surjective f \u2194 sorry"}, {"line": "simp [Surjective, SurjOn, subset_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx\u271d : Sort u_7\nSurjOn : x\u271d\n\u22a2 (\u2200 (b : \u03b2), \u2203 a, f a = b) \u2194 sorry ()"}]}
{"declaration": "theorem image_eq_iff_surjOn_mapsTo : f '' s = t \u2194 s.SurjOn f t \u2227 s.MapsTo f t := by\n  refine \u27e8?_, fun h => h.1.image_eq_of_mapsTo h.2\u27e9\n  rintro rfl\n  exact \u27e8s.surjOn_image f, s.mapsTo_image f\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' s = t \u2194 Set.SurjOn f s t \u2227 Set.MapsTo f s t"}, {"line": "refine \u27e8?_, fun h => h.1.image_eq_of_mapsTo h.2\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' s = t \u2192 Set.SurjOn f s t \u2227 Set.MapsTo f s t"}, {"line": "rintro rfl", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Set.SurjOn f s (f '' s) \u2227 Set.MapsTo f s (f '' s)"}, {"line": "exact \u27e8s.surjOn_image f, s.mapsTo_image f\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EqOn.cancel_right (hf : s.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f)) (hf' : s.SurjOn f t) : t.EqOn g\u2081 g\u2082 := by\n  intro b hb\n  obtain \u27e8a, ha, rfl\u27e9 := hf' hb\n  exact hf ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nhf : Set.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s\nhf' : Set.SurjOn f s t\n\u22a2 Set.EqOn g\u2081 g\u2082 t"}, {"line": "intro b hb", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nhf : Set.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s\nhf' : Set.SurjOn f s t\nb : \u03b2\nhb : b \u2208 t\n\u22a2 g\u2081 b = g\u2082 b"}, {"line": "obtain \u27e8a, ha, rfl\u27e9 := hf' hb", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\ng\u2081 g\u2082 : \u03b2 \u2192 \u03b3\nhf : Set.EqOn (g\u2081 \u2218 f) (g\u2082 \u2218 f) s\nhf' : Set.SurjOn f s t\na : \u03b1\nha : a \u2208 s\nhb : f a \u2208 t\n\u22a2 g\u2081 (f a) = g\u2082 (f a)"}, {"line": "exact hf ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invFunOn_pos (h : \u2203 a \u2208 s, f a = b) : invFunOn f s b \u2208 s \u2227 f (invFunOn f s b) = b := by\n  rw [invFunOn]\n  rw [dif_pos h]\n  exact Classical.choose_spec h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ninst\u271d : Nonempty \u03b1\nh : \u2203 a \u2208 s, f a = b\n\u22a2 invFunOn f s b \u2208 s \u2227 f (invFunOn f s b) = b"}, {"line": "rw [invFunOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ninst\u271d : Nonempty \u03b1\nh : \u2203 a \u2208 s, f a = b\n\u22a2 (if h : \u2203 a \u2208 s, f a = b then Classical.choose h else Classical.choice inst\u271d) \u2208 s \u2227\n    f (if h : \u2203 a \u2208 s, f a = b then Classical.choose h else Classical.choice inst\u271d) = b"}, {"line": "rw [dif_pos h]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ninst\u271d : Nonempty \u03b1\nh : \u2203 a \u2208 s, f a = b\n\u22a2 Classical.choose h \u2208 s \u2227 f (Classical.choose h) = b"}, {"line": "exact Classical.choose_spec h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem invFunOn_neg (h : \u00ac\u2203 a \u2208 s, f a = b) : invFunOn f s b = Classical.choice \u2039Nonempty \u03b1\u203a := by\n  rw [invFunOn]\n  rw [dif_neg h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ninst\u271d : Nonempty \u03b1\nh : \u00ac\u2203 a \u2208 s, f a = b\n\u22a2 invFunOn f s b = Classical.choice inst\u271d"}, {"line": "rw [invFunOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\ninst\u271d : Nonempty \u03b1\nh : \u00ac\u2203 a \u2208 s, f a = b\n\u22a2 (if h : \u2203 a \u2208 s, f a = b then Classical.choose h else Classical.choice inst\u271d) = Classical.choice inst\u271d"}, {"line": "rw [dif_neg h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem BijOn.exists_extend {t' : Set \u03b2} (h : BijOn f s t) (htt' : t \u2286 t') (ht' : t' \u2286 range f) :\n    \u2203 s', s \u2286 s' \u2227 BijOn f s' t' := by\n  simpa using h.exists_extend_of_subset (subset_univ s) htt' (by simpa [SurjOn])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\ns : Set \u03b1\nt : Set \u03b2\nx\u271d\u00b9 : Sort u_7\nBijOn : x\u271d\u00b9\nx\u271d : Sort u_8\nrange : x\u271d\nt' : Set \u03b2\nh : sorry\nhtt' : t \u2286 t'\nht' : t' \u2286 sorry\n\u22a2 \u2203 s', s \u2286 s' \u2227 sorry"}, {"line": "simpa using h.exists_extend_of_subset (subset_univ s) htt' (by simpa [SurjOn])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_image (h : Semiconj f fa fb) (ha : SurjOn fa s t) : SurjOn fb (f '' s) (f '' t) := by\n  rintro y \u27e8x, hxt, rfl\u27e9\n  rcases ha hxt with \u27e8x, hxs, rfl\u27e9\n  rw [h x]\n  exact mem_image_of_mem _ (mem_image_of_mem _ hxs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nh : Semiconj f fa fb\nha : SurjOn fa s t\n\u22a2 SurjOn fb (f '' s) (f '' t)"}, {"line": "rintro y \u27e8x, hxt, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nh : Semiconj f fa fb\nha : SurjOn fa s t\nx : \u03b1\nhxt : x \u2208 t\n\u22a2 f x \u2208 fb '' (f '' s)"}, {"line": "rcases ha hxt with \u27e8x, hxs, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nh : Semiconj f fa fb\nha : SurjOn fa s t\nx : \u03b1\nhxs : x \u2208 s\nhxt : fa x \u2208 t\n\u22a2 f (fa x) \u2208 fb '' (f '' s)"}, {"line": "rw [h x]", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\nh : Semiconj f fa fb\nha : SurjOn fa s t\nx : \u03b1\nhxs : x \u2208 s\nhxt : fa x \u2208 t\n\u22a2 fb (f x) \u2208 fb '' (f '' s)"}, {"line": "exact mem_image_of_mem _ (mem_image_of_mem _ hxs)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_range (h : Semiconj f fa fb) (ha : Surjective fa) :\n    SurjOn fb (range f) (range f) := by\n  rw [\u2190 image_univ]\n  exact h.surjOn_image (ha.surjOn univ)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Surjective fa\n\u22a2 SurjOn fb (range f) (range f)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Surjective fa\n\u22a2 SurjOn fb (f '' univ) (f '' univ)"}, {"line": "exact h.surjOn_image (ha.surjOn univ)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injOn_image (h : Semiconj f fa fb) (ha : InjOn fa s) (hf : InjOn f (fa '' s)) :\n    InjOn fb (f '' s) := by\n  rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9 H\n  simp only [\u2190 h.eq] at H\n  exact congr_arg f (ha hx hy <| hf (mem_image_of_mem fa hx) (mem_image_of_mem fa hy) H)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : Semiconj f fa fb\nha : InjOn fa s\nhf : InjOn f (fa '' s)\n\u22a2 InjOn fb (f '' s)"}, {"line": "rintro _ \u27e8x, hx, rfl\u27e9 _ \u27e8y, hy, rfl\u27e9 H", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : Semiconj f fa fb\nha : InjOn fa s\nhf : InjOn f (fa '' s)\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nH : fb (f x) = fb (f y)\n\u22a2 f x = f y"}, {"line": "simp only [\u2190 h.eq] at H", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : Semiconj f fa fb\nha : InjOn fa s\nhf : InjOn f (fa '' s)\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nH : f (fa x) = f (fa y)\n\u22a2 f x = f y"}, {"line": "exact congr_arg f (ha hx hy <| hf (mem_image_of_mem fa hx) (mem_image_of_mem fa hy) H)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injOn_range (h : Semiconj f fa fb) (ha : Injective fa) (hf : InjOn f (range fa)) :\n    InjOn fb (range f) := by\n  rw [\u2190 image_univ] at *\n  exact h.injOn_image ha.injOn hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Injective fa\nhf : InjOn f (range fa)\n\u22a2 InjOn fb (range f)"}, {"line": "rw [\u2190 image_univ] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Injective fa\nhf : InjOn f (fa '' univ)\n\u22a2 InjOn fb (f '' univ)"}, {"line": "exact h.injOn_image ha.injOn hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bijOn_range (h : Semiconj f fa fb) (ha : Bijective fa) (hf : Injective f) :\n    BijOn fb (range f) (range f) := by\n  rw [\u2190 image_univ]\n  exact h.bijOn_image (bijective_iff_bijOn_univ.1 ha) hf.injOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Bijective fa\nhf : Injective f\n\u22a2 BijOn fb (range f) (range f)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\nha : Bijective fa\nhf : Injective f\n\u22a2 BijOn fb (f '' univ) (f '' univ)"}, {"line": "exact h.bijOn_image (bijective_iff_bijOn_univ.1 ha) hf.injOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injOn_preimage (h : Semiconj f fa fb) {s : Set \u03b2} (hb : InjOn fb s)\n    (hf : InjOn f (f \u207b\u00b9' s)) : InjOn fa (f \u207b\u00b9' s) := by\n  intro x hx y hy H\n  have := congr_arg f H\n  rw [h.eq] at this\n  rw [h.eq] at this\n  exact hf hx hy (hb hx hy this)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\ns : Set \u03b2\nhb : InjOn fb s\nhf : InjOn f (f \u207b\u00b9' s)\n\u22a2 InjOn fa (f \u207b\u00b9' s)"}, {"line": "intro x hx y hy H", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\ns : Set \u03b2\nhb : InjOn fb s\nhf : InjOn f (f \u207b\u00b9' s)\nx : \u03b1\nhx : x \u2208 f \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 f \u207b\u00b9' s\nH : fa x = fa y\n\u22a2 x = y"}, {"line": "have := congr_arg f H", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\ns : Set \u03b2\nhb : InjOn fb s\nhf : InjOn f (f \u207b\u00b9' s)\nx : \u03b1\nhx : x \u2208 f \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 f \u207b\u00b9' s\nH : fa x = fa y\nthis : f (fa x) = f (fa y)\n\u22a2 x = y"}, {"line": "rw [h.eq] at this", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\ns : Set \u03b2\nhb : InjOn fb s\nhf : InjOn f (f \u207b\u00b9' s)\nx : \u03b1\nhx : x \u2208 f \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 f \u207b\u00b9' s\nH : fa x = fa y\nthis : fb (f x) = f (fa y)\n\u22a2 x = y"}, {"line": "rw [h.eq] at this", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nfa : \u03b1 \u2192 \u03b1\nfb : \u03b2 \u2192 \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Semiconj f fa fb\ns : Set \u03b2\nhb : InjOn fb s\nhf : InjOn f (f \u207b\u00b9' s)\nx : \u03b1\nhx : x \u2208 f \u207b\u00b9' s\ny : \u03b1\nhy : y \u2208 f \u207b\u00b9' s\nH : fa x = fa y\nthis : fb (f x) = fb (f y)\n\u22a2 x = y"}, {"line": "exact hf hx hy (hb hx hy this)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma apply_eq_of_range_eq_singleton {f : \u03b1 \u2192 \u03b2} {b : \u03b2} (h : range f = {b}) (a : \u03b1) :\n    f a = b := by\n  simpa only [h,mem_singleton_iff] using mem_range_self (f := f) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Nonempty \u03b1\nf : \u03b1 \u2192 \u03b2\nb : \u03b2\nh : range f = {b}\na : \u03b1\n\u22a2 f a = b"}, {"line": "simpa only [h,mem_singleton_iff] using mem_range_self (f := f) a", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma SurjOn.extendDomain (h : SurjOn g s t) :\n    SurjOn (g.extendDomain f) ((\u2191) \u2218 f '' s) ((\u2191) \u2218 f '' t) := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  obtain \u27e8b, hb, rfl\u27e9 := h ha\n  exact \u27e8_, \u27e8_, hb, rfl\u27e9, by simp_rw [Function.comp_apply, extendDomain_apply_image]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Function.lean", "context": {"open": ["Equiv Equiv.Perm Function", "scoped Classical in", "Function", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s s\u2081 s\u2082 : Set \u03b1} {f\u2081 f\u2082 f\u2083 : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : \u03b1}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "{x : \u03b1 \u00d7 \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}", "[Nonempty \u03b1]", "{s s\u2081 s\u2082 : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "(f s)", "{f s}", "{fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {s t : Set \u03b1}", "{p : \u03b2 \u2192 Prop} [DecidablePred p] {f : \u03b1 \u2243 Subtype p} {g g\u2081 g\u2082 : Perm \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nonempty \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\ng : Perm \u03b1\ns t : Set \u03b1\nh : SurjOn (\u21d1g) s t\n\u22a2 SurjOn (\u21d1(g.extendDomain f)) (Subtype.val \u2218 \u21d1f '' s) (Subtype.val \u2218 \u21d1f '' t)"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nonempty \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\ng : Perm \u03b1\ns t : Set \u03b1\nh : SurjOn (\u21d1g) s t\na : \u03b1\nha : a \u2208 t\n\u22a2 (Subtype.val \u2218 \u21d1f) a \u2208 \u21d1(g.extendDomain f) '' (Subtype.val \u2218 \u21d1f '' s)"}, {"line": "obtain \u27e8b, hb, rfl\u27e9 := h ha", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Nonempty \u03b1\np : \u03b2 \u2192 Prop\ninst\u271d : DecidablePred p\nf : \u03b1 \u2243 Subtype p\ng : Perm \u03b1\ns t : Set \u03b1\nh : SurjOn (\u21d1g) s t\nb : \u03b1\nhb : b \u2208 s\nha : g b \u2208 t\n\u22a2 (Subtype.val \u2218 \u21d1f) (g b) \u2208 \u21d1(g.extendDomain f) '' (Subtype.val \u2218 \u21d1f '' s)"}, {"line": "exact \u27e8_, \u27e8_, hb, rfl\u27e9, by simp_rw [Function.comp_apply, extendDomain_apply_image]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : \u2200 x : \u03b1, f x = g x) : f \u207b\u00b9' s = g \u207b\u00b9' s := by\n  congr with x\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), f x = g x\n\u22a2 f \u207b\u00b9' s = g \u207b\u00b9' s"}, {"line": "congr with x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : \u2200 (x : \u03b1), f x = g x\nx : \u03b1\n\u22a2 x \u2208 f \u207b\u00b9' s \u2194 x \u2208 g \u207b\u00b9' s"}, {"line": "simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_const (b : \u03b2) (s : Set \u03b2) [Decidable (b \u2208 s)] :\n    (fun _ : \u03b1 => b) \u207b\u00b9' s = if b \u2208 s then univ else \u2205 := by\n  split_ifs with hb\n  exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\n\u22a2 (fun x => b) \u207b\u00b9' s = if b \u2208 s then univ else \u2205"}, {"line": "split_ifs with hb", "tactic_state": "case pos\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2208 s\n\u22a2 (fun x => b) \u207b\u00b9' s = univ\n---\ncase neg\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nb : \u03b2\ns : Set \u03b2\ninst\u271d : Decidable (b \u2208 s)\nhb : b \u2209 s\n\u22a2 (fun x => b) \u207b\u00b9' s = \u2205"}, {"line": "exacts [preimage_const_of_mem hb, preimage_const_of_not_mem hb]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_const_of_preimage_singleton [Nonempty \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 b : \u03b2, f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ) : \u2203 b, f = const \u03b1 b := by\n  rcases em (\u2203 b, f \u207b\u00b9' {b} = univ) with \u27e8b, hb\u27e9 | hf'\n  \u00b7 exact \u27e8b, funext fun x \u21a6 eq_univ_iff_forall.1 hb x\u27e9\n  \u00b7 have : \u2200 x b, f x \u2260 b := fun x b \u21a6\n      eq_empty_iff_forall_not_mem.1 ((hf b).resolve_right fun h \u21a6 hf' \u27e8b, h\u27e9) x\n    exact \u27e8Classical.arbitrary \u03b2, funext fun x \u21a6 absurd rfl (this x _)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (b : \u03b2), f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ\n\u22a2 \u2203 b, f = const \u03b1 b"}, {"line": "rcases em (\u2203 b, f \u207b\u00b9' {b} = univ) with \u27e8b, hb\u27e9 | hf'", "tactic_state": "case inl.intro\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (b : \u03b2), f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ\nb : \u03b2\nhb : f \u207b\u00b9' {b} = univ\n\u22a2 \u2203 b, f = const \u03b1 b\n---\ncase inr\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (b : \u03b2), f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ\nhf' : \u00ac\u2203 b, f \u207b\u00b9' {b} = univ\n\u22a2 \u2203 b, f = const \u03b1 b"}, {"line": "\u00b7 exact \u27e8b, funext fun x \u21a6 eq_univ_iff_forall.1 hb x\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d : Nonempty \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (b : \u03b2), f \u207b\u00b9' {b} = \u2205 \u2228 f \u207b\u00b9' {b} = univ\nhf' : \u00ac\u2203 b, f \u207b\u00b9' {b} = univ\n\u22a2 \u2203 b, f = const \u03b1 b"}, {"line": "\u00b7 have : \u2200 x b, f x \u2260 b := fun x b \u21a6\n      eq_empty_iff_forall_not_mem.1 ((hf b).resolve_right fun h \u21a6 hf' \u27e8b, h\u27e9) x\n    exact \u27e8Classical.arbitrary \u03b2, funext fun x \u21a6 absurd rfl (this x _)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_subtype_coe_eq_compl {s u v : Set \u03b1} (hsuv : s \u2286 u \u222a v)\n    (H : s \u2229 (u \u2229 v) = \u2205) : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' u = ((\u2191) \u207b\u00b9' v)\u1d9c := by\n  ext \u27e8x, x_in_s\u27e9\n  constructor\n  \u00b7 intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x \u27e8x_in_s, \u27e8x_in_u, x_in_v\u27e9\u27e9\n  \u00b7 intro hx\n    exact Or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns u v : Set \u03b1\nhsuv : s \u2286 u \u222a v\nH : s \u2229 (u \u2229 v) = \u2205\n\u22a2 Subtype.val \u207b\u00b9' u = (Subtype.val \u207b\u00b9' v)\u1d9c"}, {"line": "ext \u27e8x, x_in_s\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\ns u v : Set \u03b1\nhsuv : s \u2286 u \u222a v\nH : s \u2229 (u \u2229 v) = \u2205\nx : \u03b1\nx_in_s : x \u2208 s\n\u22a2 \u27e8x, x_in_s\u27e9 \u2208 Subtype.val \u207b\u00b9' u \u2194 \u27e8x, x_in_s\u27e9 \u2208 (Subtype.val \u207b\u00b9' v)\u1d9c"}, {"line": "constructor", "tactic_state": "case h.mk.mp\n\u03b1 : Type u_1\ns u v : Set \u03b1\nhsuv : s \u2286 u \u222a v\nH : s \u2229 (u \u2229 v) = \u2205\nx : \u03b1\nx_in_s : x \u2208 s\n\u22a2 \u27e8x, x_in_s\u27e9 \u2208 Subtype.val \u207b\u00b9' u \u2192 \u27e8x, x_in_s\u27e9 \u2208 (Subtype.val \u207b\u00b9' v)\u1d9c\n---\ncase h.mk.mpr\n\u03b1 : Type u_1\ns u v : Set \u03b1\nhsuv : s \u2286 u \u222a v\nH : s \u2229 (u \u2229 v) = \u2205\nx : \u03b1\nx_in_s : x \u2208 s\n\u22a2 \u27e8x, x_in_s\u27e9 \u2208 (Subtype.val \u207b\u00b9' v)\u1d9c \u2192 \u27e8x, x_in_s\u27e9 \u2208 Subtype.val \u207b\u00b9' u"}, {"line": "\u00b7 intro x_in_u x_in_v\n    exact eq_empty_iff_forall_not_mem.mp H x \u27e8x_in_s, \u27e8x_in_u, x_in_v\u27e9\u27e9", "tactic_state": "case h.mk.mpr\n\u03b1 : Type u_1\ns u v : Set \u03b1\nhsuv : s \u2286 u \u222a v\nH : s \u2229 (u \u2229 v) = \u2205\nx : \u03b1\nx_in_s : x \u2208 s\n\u22a2 \u27e8x, x_in_s\u27e9 \u2208 (Subtype.val \u207b\u00b9' v)\u1d9c \u2192 \u27e8x, x_in_s\u27e9 \u2208 Subtype.val \u207b\u00b9' u"}, {"line": "\u00b7 intro hx\n    exact Or.elim (hsuv x_in_s) id fun hx' => hx.elim hx'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_subset {s t} (hs : s \u2286 f '' t) (hf : Set.InjOn f (f \u207b\u00b9' s)) : f \u207b\u00b9' s \u2286 t := by\n  rintro a ha\n  obtain \u27e8b, hb, hba\u27e9 := hs ha\n  rwa [hf ha _ hba.symm]\n  simpa [hba]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Set \u03b1\nhs : s \u2286 f '' t\nhf : InjOn f (f \u207b\u00b9' s)\n\u22a2 f \u207b\u00b9' s \u2286 t"}, {"line": "rintro a ha", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Set \u03b1\nhs : s \u2286 f '' t\nhf : InjOn f (f \u207b\u00b9' s)\na : \u03b1\nha : a \u2208 f \u207b\u00b9' s\n\u22a2 a \u2208 t"}, {"line": "obtain \u27e8b, hb, hba\u27e9 := hs ha", "tactic_state": "case intro.intro\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Set \u03b1\nhs : s \u2286 f '' t\nhf : InjOn f (f \u207b\u00b9' s)\na : \u03b1\nha : a \u2208 f \u207b\u00b9' s\nb : \u03b1\nhb : b \u2208 t\nhba : f b = f a\n\u22a2 a \u2208 t"}, {"line": "rwa [hf ha _ hba.symm]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nt : Set \u03b1\nhs : s \u2286 f '' t\nhf : InjOn f (f \u207b\u00b9' s)\na : \u03b1\nha : a \u2208 f \u207b\u00b9' s\nb : \u03b1\nhb : b \u2208 t\nhba : f b = f a\n\u22a2 b \u2208 f \u207b\u00b9' s"}, {"line": "simpa [hba]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_mem_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 p (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 f '' s, p y) \u2194 \u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 p (f x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_mem_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2203 y \u2208 f '' s, p y) \u2194 \u2203 x \u2208 s, p (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2203 y \u2208 f '' s, p y) \u2194 \u2203 x \u2208 s, p (f x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : \u2200 a \u2208 s, f a = g a) : f '' s = g '' s := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf g : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh : \u2200 a \u2208 s, f a = g a\n\u22a2 f '' s = g '' s"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) (a : Set \u03b1) : f \u2218 g '' a = f '' (g '' a) := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_2\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\na : Set \u03b1\n\u22a2 f \u2218 g '' a = f '' (g '' a)"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_comm {\u03b2'} {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {f' : \u03b1 \u2192 \u03b2'} {g' : \u03b2' \u2192 \u03b3}\n    (h_comm : \u2200 a, f (g a) = g' (f' a)) : (s.image g).image f = (s.image f').image g' := by\n  simp_rw [image_image, h_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_3\n\u03b3 : Type u_2\ns : Set \u03b1\n\u03b2' : Type u_1\nf : \u03b2 \u2192 \u03b3\ng : \u03b1 \u2192 \u03b2\nf' : \u03b1 \u2192 \u03b2'\ng' : \u03b2' \u2192 \u03b3\nh_comm : \u2200 (a : \u03b1), f (g a) = g' (f' a)\n\u22a2 f '' (g '' s) = g' '' (f' '' s)"}, {"line": "simp_rw [image_image, h_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_subset {a b : Set \u03b1} (f : \u03b1 \u2192 \u03b2) (h : a \u2286 b) : f '' a \u2286 f '' b := by\n  simp only [subset_def]\n  simp only [mem_image]\n  exact fun x => fun \u27e8w, h1, h2\u27e9 => \u27e8w, h h1, h2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : a \u2286 b\n\u22a2 f '' a \u2286 f '' b"}, {"line": "simp only [subset_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : a \u2286 b\n\u22a2 \u2200 x \u2208 f '' a, x \u2208 f '' b"}, {"line": "simp only [mem_image]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nh : a \u2286 b\n\u22a2 \u2200 (x : \u03b2), (\u2203 x_1 \u2208 a, f x_1 = x) \u2192 \u2203 x_1 \u2208 b, f x_1 = x"}, {"line": "exact fun x => fun \u27e8w, h1, h2\u27e9 => \u27e8w, h h1, h2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_empty (f : \u03b1 \u2192 \u03b2) : f '' \u2205 = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u2205 = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' \u2205 \u2194 x\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_singleton {f : \u03b1 \u2192 \u03b2} {a : \u03b1} : f '' {a} = {f a} := by\n  ext\n  simp [image, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\n\u22a2 f '' {a} = {f a}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' {a} \u2194 x\u271d \u2208 {f a}"}, {"line": "simp [image, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_eq_empty {\u03b1 \u03b2} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : f '' s = \u2205 \u2194 s = \u2205 := by\n  simp only [eq_empty_iff_forall_not_mem]\n  exact \u27e8fun H a ha => H _ \u27e8_, ha, rfl\u27e9, fun H b \u27e8_, ha, _\u27e9 => H _ ha\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s = \u2205 \u2194 s = \u2205"}, {"line": "simp only [eq_empty_iff_forall_not_mem]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 (\u2200 (x : \u03b2), x \u2209 f '' s) \u2194 \u2200 (x : \u03b1), x \u2209 s"}, {"line": "exact \u27e8fun H a ha => H _ \u27e8_, ha, rfl\u27e9, fun H b \u27e8_, ha, _\u27e9 => H _ ha\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_compl_image [BooleanAlgebra \u03b1] (t : \u03b1) (S : Set \u03b1) :\n    t \u2208 HasCompl.compl '' S \u2194 t\u1d9c \u2208 S := by\n  simp [\u2190 preimage_compl_eq_image_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : BooleanAlgebra \u03b1\nt : \u03b1\nS : Set \u03b1\n\u22a2 t \u2208 compl '' S \u2194 t\u1d9c \u2208 S"}, {"line": "simp [\u2190 preimage_compl_eq_image_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_id' (s : Set \u03b1) : (fun x => x) '' s = s := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 (fun x => x) '' s = s"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 (fun x => x) '' s \u2194 x\u271d \u2208 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_id (s : Set \u03b1) : id '' s = s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 id '' s = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_compl_image [BooleanAlgebra \u03b1] (S : Set \u03b1) :\n    HasCompl.compl '' (HasCompl.compl '' S) = S := by\n  rw [\u2190 image_comp]\n  rw [compl_comp_compl]\n  rw [image_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : BooleanAlgebra \u03b1\nS : Set \u03b1\n\u22a2 compl '' (compl '' S) = S"}, {"line": "rw [\u2190 image_comp]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : BooleanAlgebra \u03b1\nS : Set \u03b1\n\u22a2 compl \u2218 compl '' S = S"}, {"line": "rw [compl_comp_compl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : BooleanAlgebra \u03b1\nS : Set \u03b1\n\u22a2 id '' S = S"}, {"line": "rw [image_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_insert_eq {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} :\n    f '' insert a s = insert (f a) (f '' s) := by\n  ext\n  simp [and_or_left, exists_or, eq_comm, or_comm, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\n\u22a2 f '' insert a s = insert (f a) (f '' s)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\na : \u03b1\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' insert a s \u2194 x\u271d \u2208 insert (f a) (f '' s)"}, {"line": "simp [and_or_left, exists_or, eq_comm, or_comm, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_pair (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) : f '' {a, b} = {f a, f b} := by\n  simp only [image_insert_eq]\n  simp only [image_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 f '' {a, b} = {f a, f b}"}, {"line": "simp only [image_insert_eq]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\na b : \u03b1\n\u22a2 insert (f a) (f '' {b}) = {f a, f b}"}, {"line": "simp only [image_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_inter_ssubset_iff_preimage_ssubset {f : \u03b1 \u2192 \u03b2} {S S' : Set \u03b2} :\n  range f \u2229 S \u2282 range f \u2229 S' \u2194 f \u207b\u00b9' S \u2282 f \u207b\u00b9' S' := by\n    simp only [Set.ssubset_iff_exists]\n    apply and_congr ?_ (by aesop)\n    constructor\n    all_goals\n      intro r x hx\n      simp_all only [subset_inter_iff, inter_subset_left, true_and, mem_preimage,\n        mem_inter_iff, mem_range, true_and]\n      aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 range f \u2229 S \u2282 range f \u2229 S' \u2194 f \u207b\u00b9' S \u2282 f \u207b\u00b9' S'"}, {"line": "simp only [Set.ssubset_iff_exists]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 (range f \u2229 S \u2286 range f \u2229 S' \u2227 \u2203 x \u2208 range f \u2229 S', x \u2209 range f \u2229 S) \u2194 f \u207b\u00b9' S \u2286 f \u207b\u00b9' S' \u2227 \u2203 x \u2208 f \u207b\u00b9' S', x \u2209 f \u207b\u00b9' S"}, {"line": "apply and_congr ?_ (by aesop)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 range f \u2229 S \u2286 range f \u2229 S' \u2194 f \u207b\u00b9' S \u2286 f \u207b\u00b9' S'"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 range f \u2229 S \u2286 range f \u2229 S' \u2192 f \u207b\u00b9' S \u2286 f \u207b\u00b9' S'\n---\ncase mpr\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nS S' : Set \u03b2\n\u22a2 f \u207b\u00b9' S \u2286 f \u207b\u00b9' S' \u2192 range f \u2229 S \u2286 range f \u2229 S'"}, {"line": "all_goals\n      intro r x hx\n      simp_all only [subset_inter_iff, inter_subset_left, true_and, mem_preimage,\n        mem_inter_iff, mem_range, true_and]\n      aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_image_diff (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' s \\ f '' t \u2286 f '' (s \\ t) := by\n  rw [diff_subset_iff]\n  rw [\u2190 image_union]\n  rw [union_diff_self]\n  exact image_subset f subset_union_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\n\u22a2 f '' s \\ f '' t \u2286 f '' (s \\ t)"}, {"line": "rw [diff_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\n\u22a2 f '' s \u2286 f '' t \u222a f '' (s \\ t)"}, {"line": "rw [\u2190 image_union]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\n\u22a2 f '' s \u2286 f '' (t \u222a s \\ t)"}, {"line": "rw [union_diff_self]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b1\n\u22a2 f '' s \u2286 f '' (t \u222a s)"}, {"line": "exact image_subset f subset_union_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nonempty.subset_preimage_const {s : Set \u03b1} (hs : Set.Nonempty s) (t : Set \u03b2) (a : \u03b2) :\n    s \u2286 (fun _ => a) \u207b\u00b9' t \u2194 a \u2208 t := by\n  rw [\u2190 image_subset_iff]\n  rw [hs.image_const]\n  rw [singleton_subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nhs : s.Nonempty\nt : Set \u03b2\na : \u03b2\n\u22a2 s \u2286 (fun x => a) \u207b\u00b9' t \u2194 a \u2208 t"}, {"line": "rw [\u2190 image_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nhs : s.Nonempty\nt : Set \u03b2\na : \u03b2\n\u22a2 (fun x => a) '' s \u2286 t \u2194 a \u2208 t"}, {"line": "rw [hs.image_const]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nhs : s.Nonempty\nt : Set \u03b2\na : \u03b2\n\u22a2 {a} \u2286 t \u2194 a \u2208 t"}, {"line": "rw [singleton_subset_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_preimage_inter (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    f '' (f \u207b\u00b9' t \u2229 s) = t \u2229 f '' s := by simp only [inter_comm, image_inter_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' t \u2229 s) = t \u2229 f '' s"}, {"line": "simp only [inter_comm, image_inter_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_inter_nonempty_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} :\n    (f '' s \u2229 t).Nonempty \u2194 (s \u2229 f \u207b\u00b9' t).Nonempty := by\n  rw [\u2190 image_inter_preimage]\n  rw [image_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' s \u2229 t).Nonempty \u2194 (s \u2229 f \u207b\u00b9' t).Nonempty"}, {"line": "rw [\u2190 image_inter_preimage]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' (s \u2229 f \u207b\u00b9' t)).Nonempty \u2194 (s \u2229 f \u207b\u00b9' t).Nonempty"}, {"line": "rw [image_nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_diff_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} :\n    f '' (s \\ f \u207b\u00b9' t) = f '' s \\ t := by simp_rw [diff_eq, \u2190 preimage_compl, image_inter_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 f '' (s \\ f \u207b\u00b9' t) = f '' s \\ t"}, {"line": "simp_rw [diff_eq, \u2190 preimage_compl, image_inter_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_image_iff {t : Set \u03b2} :\n    t \u2286 f '' s \u2194 \u2203 u, u \u2286 s \u2227 f '' u = t := by\n  refine \u27e8fun h \u21a6 \u27e8f \u207b\u00b9' t \u2229 s, inter_subset_right, ?_\u27e9,\n    fun \u27e8u, hu, hu'\u27e9 \u21a6 hu'.symm \u25b8 image_mono hu\u27e9\n  rwa [image_preimage_inter, inter_eq_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 t \u2286 f '' s \u2194 \u2203 u \u2286 s, f '' u = t"}, {"line": "refine \u27e8fun h \u21a6 \u27e8f \u207b\u00b9' t \u2229 s, inter_subset_right, ?_\u27e9,\n    fun \u27e8u, hu, hu'\u27e9 \u21a6 hu'.symm \u25b8 image_mono hu\u27e9", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\nh : t \u2286 f '' s\n\u22a2 f '' (f \u207b\u00b9' t \u2229 s) = t"}, {"line": "rwa [image_preimage_inter, inter_eq_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_subset_image_iff {p : Set \u03b2 \u2192 Prop} : (\u2203 t \u2286 f '' s, p t) \u2194 \u2203 t \u2286 s, p (f '' t) := by\n  simp [subset_image_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Set \u03b2 \u2192 Prop\n\u22a2 (\u2203 t \u2286 f '' s, p t) \u2194 \u2203 t \u2286 s, p (f '' t)"}, {"line": "simp [subset_image_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_subset_image_iff {p : Set \u03b2 \u2192 Prop} : (\u2200 t \u2286 f '' s, p t) \u2194 \u2200 t \u2286 s, p (f '' t) := by\n  simp [subset_image_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\np : Set \u03b2 \u2192 Prop\n\u22a2 (\u2200 t \u2286 f '' s, p t) \u2194 \u2200 t \u2286 s, p (f '' t)"}, {"line": "simp [subset_image_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_subset_image_iff {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : f '' s \u2286 f '' t \u2194 s \u2286 t := by\n  refine Iff.symm <| (Iff.intro (image_subset f)) fun h => ?_\n  rw [\u2190 preimage_image_eq s hf]\n  rw [\u2190 preimage_image_eq t hf]\n  exact preimage_mono h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 f '' s \u2286 f '' t \u2194 s \u2286 t"}, {"line": "refine Iff.symm <| (Iff.intro (image_subset f)) fun h => ?_", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nh : f '' s \u2286 f '' t\n\u22a2 s \u2286 t"}, {"line": "rw [\u2190 preimage_image_eq s hf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nh : f '' s \u2286 f '' t\n\u22a2 f \u207b\u00b9' (f '' s) \u2286 t"}, {"line": "rw [\u2190 preimage_image_eq t hf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nh : f '' s \u2286 f '' t\n\u22a2 f \u207b\u00b9' (f '' s) \u2286 f \u207b\u00b9' (f '' t)"}, {"line": "exact preimage_mono h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_perm {s : Set \u03b1} {\u03c3 : Equiv.Perm \u03b1} (hs : { a : \u03b1 | \u03c3 a \u2260 a } \u2286 s) : \u03c3 '' s = s := by\n  ext i\n  obtain hi | hi := eq_or_ne (\u03c3 i) i\n  \u00b7 refine \u27e8?_, fun h => \u27e8i, h, hi\u27e9\u27e9\n    rintro \u27e8j, hj, h\u27e9\n    rwa [\u03c3.injective (hi.trans h.symm)]\n  \u00b7 refine iff_of_true \u27e8\u03c3.symm i, hs fun h => hi ?_, \u03c3.apply_symm_apply _\u27e9 (hs hi)\n    convert congr_arg \u03c3 h <;> exact (\u03c3.apply_symm_apply _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u03c3 : Equiv.Perm \u03b1\nhs : {a | \u03c3 a \u2260 a} \u2286 s\n\u22a2 \u21d1\u03c3 '' s = s"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u_1\ns : Set \u03b1\n\u03c3 : Equiv.Perm \u03b1\nhs : {a | \u03c3 a \u2260 a} \u2286 s\ni : \u03b1\n\u22a2 i \u2208 \u21d1\u03c3 '' s \u2194 i \u2208 s"}, {"line": "obtain hi | hi := eq_or_ne (\u03c3 i) i", "tactic_state": "case h.inl\n\u03b1 : Type u_1\ns : Set \u03b1\n\u03c3 : Equiv.Perm \u03b1\nhs : {a | \u03c3 a \u2260 a} \u2286 s\ni : \u03b1\nhi : \u03c3 i = i\n\u22a2 i \u2208 \u21d1\u03c3 '' s \u2194 i \u2208 s\n---\ncase h.inr\n\u03b1 : Type u_1\ns : Set \u03b1\n\u03c3 : Equiv.Perm \u03b1\nhs : {a | \u03c3 a \u2260 a} \u2286 s\ni : \u03b1\nhi : \u03c3 i \u2260 i\n\u22a2 i \u2208 \u21d1\u03c3 '' s \u2194 i \u2208 s"}, {"line": "\u00b7 refine \u27e8?_, fun h => \u27e8i, h, hi\u27e9\u27e9\n    rintro \u27e8j, hj, h\u27e9\n    rwa [\u03c3.injective (hi.trans h.symm)]", "tactic_state": "case h.inr\n\u03b1 : Type u_1\ns : Set \u03b1\n\u03c3 : Equiv.Perm \u03b1\nhs : {a | \u03c3 a \u2260 a} \u2286 s\ni : \u03b1\nhi : \u03c3 i \u2260 i\n\u22a2 i \u2208 \u21d1\u03c3 '' s \u2194 i \u2208 s"}, {"line": "\u00b7 refine iff_of_true \u27e8\u03c3.symm i, hs fun h => hi ?_, \u03c3.apply_symm_apply _\u27e9 (hs hi)\n    convert congr_arg \u03c3 h <;> exact (\u03c3.apply_symm_apply _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_mem_range {p : \u03b1 \u2192 Prop} : (\u2200 a \u2208 range f, p a) \u2194 \u2200 i, p (f i) := by simp\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200 a \u2208 range f, p a) \u2194 \u2200 (i : \u03b9), p (f i)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_range_iff {p : \u03b1 \u2192 Prop} : (\u2203 a \u2208 range f, p a) \u2194 \u2203 i, p (f i) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203 a \u2208 range f, p a) \u2194 \u2203 i, p (f i)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_univ {f : \u03b1 \u2192 \u03b2} : f '' univ = range f := by\n  ext\n  simp [image, range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' univ = range f"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' univ \u2194 x\u271d \u2208 range f"}, {"line": "simp [image, range]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_compl_eq_range_diff_image {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (s : Set \u03b1) :\n    f '' s\u1d9c = range f \\ f '' s := by rw [\u2190 image_univ, \u2190 image_diff hf, compl_eq_univ_diff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\n\u22a2 f '' s\u1d9c = range f \\ f '' s"}, {"line": "rw [\u2190 image_univ, \u2190 image_diff hf, compl_eq_univ_diff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma range_diff_image {f : \u03b1 \u2192 \u03b2} (hf : Injective f) (s : Set \u03b1) : range f \\ f '' s = f '' s\u1d9c := by\n  rw [image_compl_eq_range_diff_image hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns : Set \u03b1\n\u22a2 range f \\ f '' s = f '' s\u1d9c"}, {"line": "rw [image_compl_eq_range_diff_image hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_eq_univ_iff {f : \u03b1 \u2192 \u03b2} {s} : f \u207b\u00b9' s = univ \u2194 range f \u2286 s := by\n  rw [\u2190 univ_subset_iff]\n  rw [\u2190 image_subset_iff]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' s = univ \u2194 range f \u2286 s"}, {"line": "rw [\u2190 univ_subset_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 univ \u2286 f \u207b\u00b9' s \u2194 range f \u2286 s"}, {"line": "rw [\u2190 image_subset_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' univ \u2286 s \u2194 range f \u2286 s"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_comp (g : \u03b1 \u2192 \u03b2) (f : \u03b9 \u2192 \u03b1) : range (g \u2218 f) = g '' range f := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_1\n\u03b9 : Sort u_2\ng : \u03b1 \u2192 \u03b2\nf : \u03b9 \u2192 \u03b1\n\u22a2 range (g \u2218 f) = g '' range f"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_subset_range_iff_exists_comp {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} :\n    range f \u2286 range g \u2194 \u2203 h : \u03b1 \u2192 \u03b2, f = g \u2218 h := by\n  simp only [range_subset_iff]\n  simp only [mem_range]\n  simp only [Classical.skolem]\n  simp only [funext_iff]\n  simp only [(\u00b7 \u2218 \u00b7)]\n  simp only [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 range f \u2286 range g \u2194 \u2203 h, f = g \u2218 h"}, {"line": "simp only [range_subset_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b1), f y \u2208 range g) \u2194 \u2203 h, f = g \u2218 h"}, {"line": "simp only [mem_range]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 (\u2200 (y : \u03b1), \u2203 y_1, g y_1 = f y) \u2194 \u2203 h, f = g \u2218 h"}, {"line": "simp only [Classical.skolem]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 (\u2203 f_1, \u2200 (x : \u03b1), g (f_1 x) = f x) \u2194 \u2203 h, f = g \u2218 h"}, {"line": "simp only [funext_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 (\u2203 f_1, \u2200 (x : \u03b1), g (f_1 x) = f x) \u2194 \u2203 h, \u2200 (x : \u03b1), f x = (g \u2218 h) x"}, {"line": "simp only [(\u00b7 \u2218 \u00b7)]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Sort u_3\n\u03b3 : Type u_1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\n\u22a2 (\u2203 f_1, \u2200 (x : \u03b1), g (f_1 x) = f x) \u2194 \u2203 h, \u2200 (x : \u03b1), f x = g (h x)"}, {"line": "simp only [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_eq_iff (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) :\n    range f = s \u2194 (\u2200 a, f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b := by\n  rw [\u2190 range_subset_iff]\n  exact le_antisymm_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 range f = s \u2194 (\u2200 (a : \u03b1), f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b"}, {"line": "rw [\u2190 range_subset_iff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 range f = s \u2194 range f \u2286 s \u2227 \u2200 b \u2208 s, \u2203 a, f a = b"}, {"line": "exact le_antisymm_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_eq_empty_iff {f : \u03b9 \u2192 \u03b1} : range f = \u2205 \u2194 IsEmpty \u03b9 := by\n  rw [\u2190 not_nonempty_iff]\n  rw [\u2190 range_nonempty_iff_nonempty]\n  rw [not_nonempty_iff_eq_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\n\u22a2 range f = \u2205 \u2194 IsEmpty \u03b9"}, {"line": "rw [\u2190 not_nonempty_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\n\u22a2 range f = \u2205 \u2194 \u00acNonempty \u03b9"}, {"line": "rw [\u2190 range_nonempty_iff_nonempty]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\n\u22a2 range f = \u2205 \u2194 \u00ac(range ?m.412).Nonempty\n---\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\n\u22a2 Type ?u.409\n---\n\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u03b9 \u2192 ?m.410"}, {"line": "rw [not_nonempty_iff_eq_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_union_image_compl_eq_range (f : \u03b1 \u2192 \u03b2) : f '' s \u222a f '' s\u1d9c = range f := by\n  rw [\u2190 image_union]\n  rw [\u2190 image_univ]\n  rw [\u2190 union_compl_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' s \u222a f '' s\u1d9c = range f"}, {"line": "rw [\u2190 image_union]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' (s \u222a s\u1d9c) = range f"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' (s \u222a s\u1d9c) = f '' univ"}, {"line": "rw [\u2190 union_compl_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_image_compl_eq_range (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : insert (f x) (f '' {x}\u1d9c) = range f := by\n  rw [\u2190 image_insert_eq]\n  rw [insert_eq]\n  rw [union_compl_self]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 insert (f x) (f '' {x}\u1d9c) = range f"}, {"line": "rw [\u2190 image_insert_eq]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 f '' insert x {x}\u1d9c = range f"}, {"line": "rw [insert_eq]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 f '' ({x} \u222a {x}\u1d9c) = range f"}, {"line": "rw [union_compl_self]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 f '' univ = range f"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_preimage_eq_inter_range {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2} : f '' (f \u207b\u00b9' t) = t \u2229 range f := by\n  rw [image_preimage_eq_range_inter]\n  rw [inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nt : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' t) = t \u2229 range f"}, {"line": "rw [image_preimage_eq_range_inter]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\nt : Set \u03b2\n\u22a2 range f \u2229 t = t \u2229 range f"}, {"line": "rw [inter_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_preimage_eq_of_subset {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hs : s \u2286 range f) :\n    f '' (f \u207b\u00b9' s) = s := by rw [image_preimage_eq_range_inter, inter_eq_self_of_subset_right hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhs : s \u2286 range f\n\u22a2 f '' (f \u207b\u00b9' s) = s"}, {"line": "rw [image_preimage_eq_range_inter, inter_eq_self_of_subset_right hs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_range_inter {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f \u207b\u00b9' (range f \u2229 s) = f \u207b\u00b9' s := by\n  rw [inter_comm]\n  rw [preimage_inter_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' (range f \u2229 s) = f \u207b\u00b9' s"}, {"line": "rw [inter_comm]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' (s \u2229 range f) = f \u207b\u00b9' s"}, {"line": "rw [preimage_inter_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_image_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f \u207b\u00b9' (f '' (f \u207b\u00b9' s)) = f \u207b\u00b9' s := by\n  rw [image_preimage_eq_range_inter]\n  rw [preimage_range_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' (f '' (f \u207b\u00b9' s)) = f \u207b\u00b9' s"}, {"line": "rw [image_preimage_eq_range_inter]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' (range f \u2229 s) = f \u207b\u00b9' s"}, {"line": "rw [preimage_range_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_inl : range (@Sum.inl \u03b1 \u03b2) = {x | Sum.isLeft x} := by ext (_|_) <;> simp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 range Sum.inl = {x | x.isLeft = true}"}, {"line": "ext (_|_) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_inr : range (@Sum.inr \u03b1 \u03b2) = {x | Sum.isRight x} := by ext (_|_) <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 range Sum.inr = {x | x.isRight = true}"}, {"line": "ext (_|_) <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_inl_image_inr (s : Set \u03b2) : Sum.inl \u207b\u00b9' (@Sum.inr \u03b1 \u03b2 '' s) = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set \u03b2\n\u22a2 Sum.inl \u207b\u00b9' (Sum.inr '' s) = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set \u03b2\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 Sum.inl \u207b\u00b9' (Sum.inr '' s) \u2194 x\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_inr_image_inl (s : Set \u03b1) : Sum.inr \u207b\u00b9' (@Sum.inl \u03b1 \u03b2 '' s) = \u2205 := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\n\u22a2 Sum.inr \u207b\u00b9' (Sum.inl '' s) = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 Sum.inr \u207b\u00b9' (Sum.inl '' s) \u2194 x\u271d \u2208 \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_inl_range_inr : Sum.inl \u207b\u00b9' range (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2) = \u2205 := by\n  rw [\u2190 image_univ]\n  rw [preimage_inl_image_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 Sum.inl \u207b\u00b9' range Sum.inr = \u2205"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 Sum.inl \u207b\u00b9' (Sum.inr '' univ) = \u2205"}, {"line": "rw [preimage_inl_image_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_inr_range_inl : Sum.inr \u207b\u00b9' range (Sum.inl : \u03b1 \u2192 \u03b1 \u2295 \u03b2) = \u2205 := by\n  rw [\u2190 image_univ]\n  rw [preimage_inr_image_inl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\n\u22a2 Sum.inr \u207b\u00b9' range Sum.inl = \u2205"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\n\u22a2 Sum.inr \u207b\u00b9' (Sum.inl '' univ) = \u2205"}, {"line": "rw [preimage_inr_image_inl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_preimage_inl_union_image_preimage_inr (s : Set (\u03b1 \u2295 \u03b2)) :\n    Sum.inl '' (Sum.inl \u207b\u00b9' s) \u222a Sum.inr '' (Sum.inr \u207b\u00b9' s) = s := by\n  rw [image_preimage_eq_inter_range]\n  rw [image_preimage_eq_inter_range]\n  rw [\u2190 inter_union_distrib_left]\n  rw [range_inl_union_range_inr]\n  rw [inter_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set (\u03b1 \u2295 \u03b2)\n\u22a2 Sum.inl '' (Sum.inl \u207b\u00b9' s) \u222a Sum.inr '' (Sum.inr \u207b\u00b9' s) = s"}, {"line": "rw [image_preimage_eq_inter_range]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set (\u03b1 \u2295 \u03b2)\n\u22a2 s \u2229 range Sum.inl \u222a Sum.inr '' (Sum.inr \u207b\u00b9' s) = s"}, {"line": "rw [image_preimage_eq_inter_range]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set (\u03b1 \u2295 \u03b2)\n\u22a2 s \u2229 range Sum.inl \u222a s \u2229 range Sum.inr = s"}, {"line": "rw [\u2190 inter_union_distrib_left]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set (\u03b1 \u2295 \u03b2)\n\u22a2 s \u2229 (range Sum.inl \u222a range Sum.inr) = s"}, {"line": "rw [range_inl_union_range_inr]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ns : Set (\u03b1 \u2295 \u03b2)\n\u22a2 s \u2229 univ = s"}, {"line": "rw [inter_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_subtype_map {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2192 \u03b2) (h : \u2200 x, p x \u2192 q (f x)) :\n    range (Subtype.map f h) = (\u2191) \u207b\u00b9' (f '' { x | p x }) := by\n  ext \u27e8x, hx\u27e9\n  simp_rw [mem_preimage, mem_range, mem_image, Subtype.exists, Subtype.map]\n  simp only [Subtype.mk.injEq]\n  simp only [exists_prop]\n  simp only [mem_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\n\u22a2 range (Subtype.map f h) = Subtype.val \u207b\u00b9' (f '' {x | p x})"}, {"line": "ext \u27e8x, hx\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 \u27e8x, hx\u27e9 \u2208 range (Subtype.map f h) \u2194 \u27e8x, hx\u27e9 \u2208 Subtype.val \u207b\u00b9' (f '' {x | p x})"}, {"line": "simp_rw [mem_preimage, mem_range, mem_image, Subtype.exists, Subtype.map]", "tactic_state": "case h.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (h_1 : p a), \u27e8f a, \u22ef\u27e9 = \u27e8x, hx\u27e9) \u2194 \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"line": "simp only [Subtype.mk.injEq]", "tactic_state": "case h.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, \u2203 (_ : p a), f a = x) \u2194 \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"line": "simp only [exists_prop]", "tactic_state": "case h.mk\n\u03b1 : Type u_2\n\u03b2 : Type u_1\np : \u03b1 \u2192 Prop\nq : \u03b2 \u2192 Prop\nf : \u03b1 \u2192 \u03b2\nh : \u2200 (x : \u03b1), p x \u2192 q (f x)\nx : \u03b2\nhx : q x\n\u22a2 (\u2203 a, p a \u2227 f a = x) \u2194 \u2203 x_1 \u2208 {x | p x}, f x_1 = x"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_subset_singleton {f : \u03b9 \u2192 \u03b1} {x : \u03b1} : range f \u2286 {x} \u2194 f = const \u03b9 x := by\n  simp [range_subset_iff, funext_iff, mem_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_2\nf : \u03b9 \u2192 \u03b1\nx : \u03b1\n\u22a2 range f \u2286 {x} \u2194 f = const \u03b9 x"}, {"line": "simp [range_subset_iff, funext_iff, mem_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_compl_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} : f '' (f \u207b\u00b9' s)\u1d9c = range f \\ s := by\n  rw [compl_eq_univ_diff]\n  rw [image_diff_preimage]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' s)\u1d9c = range f \\ s"}, {"line": "rw [compl_eq_univ_diff]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' (univ \\ f \u207b\u00b9' s) = range f \\ s"}, {"line": "rw [image_diff_preimage]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' univ \\ s = range f \\ s"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_eq_range (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : f '' s = range fun x : s => f x := by\n  ext\n  constructor\n  \u00b7 rintro \u27e8x, h1, h2\u27e9\n    exact \u27e8\u27e8x, h1\u27e9, h2\u27e9\n  \u00b7 rintro \u27e8\u27e8x, h1\u27e9, h2\u27e9\n    exact \u27e8x, h1, h2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 f '' s = range fun x => f \u2191x"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' s \u2194 x\u271d \u2208 range fun x => f \u2191x"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 x\u271d \u2208 f '' s \u2192 x\u271d \u2208 range fun x => f \u2191x\n---\ncase h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 (x\u271d \u2208 range fun x => f \u2191x) \u2192 x\u271d \u2208 f '' s"}, {"line": "\u00b7 rintro \u27e8x, h1, h2\u27e9\n    exact \u27e8\u27e8x, h1\u27e9, h2\u27e9", "tactic_state": "case h.mpr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nx\u271d : \u03b2\n\u22a2 (x\u271d \u2208 range fun x => f \u2191x) \u2192 x\u271d \u2208 f '' s"}, {"line": "\u00b7 rintro \u27e8\u27e8x, h1\u27e9, h2\u27e9\n    exact \u27e8x, h1, h2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_inclusion (h : s \u2286 t) : range (inclusion h) = { x : t | (x : \u03b1) \u2208 s } := by\n  ext \u27e8x, hx\u27e9\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nh : s \u2286 t\n\u22a2 range (inclusion h) = {x | \u2191x \u2208 s}"}, {"line": "ext \u27e8x, hx\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\ns t : Set \u03b1\nh : s \u2286 t\nx : \u03b1\nhx : x \u2208 t\n\u22a2 \u27e8x, hx\u27e9 \u2208 range (inclusion h) \u2194 \u27e8x, hx\u27e9 \u2208 {x | \u2191x \u2208 s}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_of_range_union_range_eq_univ {\u03b1 \u03b2 \u03b3 \u03b3' \u03b4 \u03b4' : Type*}\n    {h : \u03b2 \u2192 \u03b1} {f : \u03b3 \u2192 \u03b2} {f\u2081 : \u03b3' \u2192 \u03b1} {f\u2082 : \u03b3 \u2192 \u03b3'} {g : \u03b4 \u2192 \u03b2} {g\u2081 : \u03b4' \u2192 \u03b1} {g\u2082 : \u03b4 \u2192 \u03b4'}\n    (hf : h \u2218 f = f\u2081 \u2218 f\u2082) (hg : h \u2218 g = g\u2081 \u2218 g\u2082) (hfg : range f \u222a range g = univ) (s : Set \u03b2) :\n    h '' s = f\u2081 '' (f\u2082 '' (f \u207b\u00b9' s)) \u222a g\u2081 '' (g\u2082 '' (g \u207b\u00b9' s)) := by\n  rw [\u2190 image_comp]\n  rw [\u2190 image_comp]\n  rw [\u2190 hf]\n  rw [\u2190 hg]\n  rw [image_comp]\n  rw [image_comp]\n  rw [image_preimage_eq_inter_range]\n  rw [image_preimage_eq_inter_range]\n  rw [\u2190 image_union]\n  rw [\u2190 inter_union_distrib_left]\n  rw [hfg]\n  rw [inter_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = f\u2081 '' (f\u2082 '' (f \u207b\u00b9' s)) \u222a g\u2081 '' (g\u2082 '' (g \u207b\u00b9' s))"}, {"line": "rw [\u2190 image_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = f\u2081 \u2218 f\u2082 '' (f \u207b\u00b9' s) \u222a g\u2081 '' (g\u2082 '' (g \u207b\u00b9' s))"}, {"line": "rw [\u2190 image_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = f\u2081 \u2218 f\u2082 '' (f \u207b\u00b9' s) \u222a g\u2081 \u2218 g\u2082 '' (g \u207b\u00b9' s)"}, {"line": "rw [\u2190 hf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h \u2218 f '' (f \u207b\u00b9' s) \u222a g\u2081 \u2218 g\u2082 '' (g \u207b\u00b9' s)"}, {"line": "rw [\u2190 hg]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h \u2218 f '' (f \u207b\u00b9' s) \u222a h \u2218 g '' (g \u207b\u00b9' s)"}, {"line": "rw [image_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (f '' (f \u207b\u00b9' s)) \u222a h \u2218 g '' (g \u207b\u00b9' s)"}, {"line": "rw [image_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (f '' (f \u207b\u00b9' s)) \u222a h '' (g '' (g \u207b\u00b9' s))"}, {"line": "rw [image_preimage_eq_inter_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (s \u2229 range f) \u222a h '' (g '' (g \u207b\u00b9' s))"}, {"line": "rw [image_preimage_eq_inter_range]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (s \u2229 range f) \u222a h '' (s \u2229 range g)"}, {"line": "rw [\u2190 image_union]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (s \u2229 range f \u222a s \u2229 range g)"}, {"line": "rw [\u2190 inter_union_distrib_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (s \u2229 (range f \u222a range g))"}, {"line": "rw [hfg]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b3' : Type u_4\n\u03b4 : Type u_5\n\u03b4' : Type u_6\nh : \u03b2 \u2192 \u03b1\nf : \u03b3 \u2192 \u03b2\nf\u2081 : \u03b3' \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b3'\ng : \u03b4 \u2192 \u03b2\ng\u2081 : \u03b4' \u2192 \u03b1\ng\u2082 : \u03b4 \u2192 \u03b4'\nhf : h \u2218 f = f\u2081 \u2218 f\u2082\nhg : h \u2218 g = g\u2081 \u2218 g\u2082\nhfg : range f \u222a range g = univ\ns : Set \u03b2\n\u22a2 h '' s = h '' (s \u2229 univ)"}, {"line": "rw [inter_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nontrivial.preimage {s : Set \u03b2} (hs : s.Nontrivial)\n    (hf : Function.Surjective f) : (f \u207b\u00b9' s).Nontrivial := by\n  rcases hs with \u27e8fx, hx, fy, hy, hxy\u27e9\n  rcases hf fx, hf fy with \u27e8\u27e8x, rfl\u27e9, \u27e8y, rfl\u27e9\u27e9\n  exact \u27e8x, hx, y, hy, mt (congr_arg f) hxy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhs : s.Nontrivial\nhf : Surjective f\n\u22a2 (f \u207b\u00b9' s).Nontrivial"}, {"line": "rcases hs with \u27e8fx, hx, fy, hy, hxy\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhf : Surjective f\nfx : \u03b2\nhx : fx \u2208 s\nfy : \u03b2\nhy : fy \u2208 s\nhxy : fx \u2260 fy\n\u22a2 (f \u207b\u00b9' s).Nontrivial"}, {"line": "rcases hf fx, hf fy with \u27e8\u27e8x, rfl\u27e9, \u27e8y, rfl\u27e9\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_2\n\u03b2 : Type u_1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nhf : Surjective f\nx : \u03b1\nhx : f x \u2208 s\ny : \u03b1\nhy : f y \u2208 s\nhxy : f x \u2260 f y\n\u22a2 (f \u207b\u00b9' s).Nontrivial"}, {"line": "exact \u27e8x, hx, y, hy, mt (congr_arg f) hxy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nontrivial.image_of_injOn (hs : s.Nontrivial) (hf : s.InjOn f) :\n    (f '' s).Nontrivial := by\n  obtain \u27e8x, hx, y, hy, hxy\u27e9 := hs\n  exact \u27e8f x, mem_image_of_mem _ hx, f y, mem_image_of_mem _ hy, (hxy <| hf hx hy \u00b7)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhs : s.Nontrivial\nhf : InjOn f s\n\u22a2 (f '' s).Nontrivial"}, {"line": "obtain \u27e8x, hx, y, hy, hxy\u27e9 := hs", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nhf : InjOn f s\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\n\u22a2 (f '' s).Nontrivial"}, {"line": "exact \u27e8f x, mem_image_of_mem _ hx, f y, mem_image_of_mem _ hy, (hxy <| hf hx hy \u00b7)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Surjective.image_surjective (hf : Surjective f) : Surjective (image f) := by\n  intro s\n  use f \u207b\u00b9' s\n  rw [hf.image_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\n\u22a2 Surjective (image f)"}, {"line": "intro s", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 \u2203 a, f '' a = s"}, {"line": "use f \u207b\u00b9' s", "tactic_state": "case h\n\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' s) = s"}, {"line": "rw [hf.image_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Surjective.nonempty_preimage (hf : Surjective f) {s : Set \u03b2} :\n    (f \u207b\u00b9' s).Nonempty \u2194 s.Nonempty := by rw [\u2190 image_nonempty, hf.image_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns : Set \u03b2\n\u22a2 (f \u207b\u00b9' s).Nonempty \u2194 s.Nonempty"}, {"line": "rw [\u2190 image_nonempty, hf.image_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Injective.image_injective (hf : Injective f) : Injective (image f) := by\n  intro s t h\n  rw [\u2190 preimage_image_eq s hf]\n  rw [\u2190 preimage_image_eq t hf]\n  rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\n\u22a2 Injective (image f)"}, {"line": "intro s t h", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns t : Set \u03b1\nh : f '' s = f '' t\n\u22a2 s = t"}, {"line": "rw [\u2190 preimage_image_eq s hf]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns t : Set \u03b1\nh : f '' s = f '' t\n\u22a2 f \u207b\u00b9' (f '' s) = t"}, {"line": "rw [\u2190 preimage_image_eq t hf]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\ns t : Set \u03b1\nh : f '' s = f '' t\n\u22a2 f \u207b\u00b9' (f '' s) = f \u207b\u00b9' (f '' t)"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Surjective.preimage_subset_preimage_iff {s t : Set \u03b2} (hf : Surjective f) :\n    f \u207b\u00b9' s \u2286 f \u207b\u00b9' t \u2194 s \u2286 t := by\n  apply Set.preimage_subset_preimage_iff\n  rw [hf.range_eq]\n  apply subset_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b2\nhf : Surjective f\n\u22a2 f \u207b\u00b9' s \u2286 f \u207b\u00b9' t \u2194 s \u2286 t"}, {"line": "apply Set.preimage_subset_preimage_iff", "tactic_state": "case hs\n\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b2\nhf : Surjective f\n\u22a2 s \u2286 range f"}, {"line": "rw [hf.range_eq]", "tactic_state": "case hs\n\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\ns t : Set \u03b2\nhf : Surjective f\n\u22a2 s \u2286 univ"}, {"line": "apply subset_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LeftInverse.image_image {g : \u03b2 \u2192 \u03b1} (h : LeftInverse g f) (s : Set \u03b1) :\n    g '' (f '' s) = s := by rw [\u2190 image_comp, h.comp_eq_id, image_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nh : LeftInverse g f\ns : Set \u03b1\n\u22a2 g '' (f '' s) = s"}, {"line": "rw [\u2190 image_comp, h.comp_eq_id, image_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LeftInverse.preimage_preimage {g : \u03b2 \u2192 \u03b1} (h : LeftInverse g f) (s : Set \u03b1) :\n    f \u207b\u00b9' (g \u207b\u00b9' s) = s := by rw [\u2190 preimage_comp, h.comp_eq_id, preimage_id]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nh : LeftInverse g f\ns : Set \u03b1\n\u22a2 f \u207b\u00b9' (g \u207b\u00b9' s) = s"}, {"line": "rw [\u2190 preimage_comp, h.comp_eq_id, preimage_id]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_image_of_subset {s t : Set \u03b1} (h : t \u2286 s) : (\u2191) '' { x : \u21a5s | \u2191x \u2208 t } = t := by\n  ext x\n  rw [mem_image]\n  exact \u27e8fun \u27e8_, hx', hx\u27e9 => hx \u25b8 hx', fun hx => \u27e8\u27e8x, h hx\u27e9, hx, rfl\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ns t : Set \u03b1\nh : t \u2286 s\n\u22a2 Subtype.val '' {x | \u2191x \u2208 t} = t"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_11\ns t : Set \u03b1\nh : t \u2286 s\nx : \u03b1\n\u22a2 x \u2208 Subtype.val '' {x | \u2191x \u2208 t} \u2194 x \u2208 t"}, {"line": "rw [mem_image]", "tactic_state": "case h\n\u03b1 : Type u_11\ns t : Set \u03b1\nh : t \u2286 s\nx : \u03b1\n\u22a2 (\u2203 x_1 \u2208 {x | \u2191x \u2208 t}, \u2191x_1 = x) \u2194 x \u2208 t"}, {"line": "exact \u27e8fun \u27e8_, hx', hx\u27e9 => hx \u25b8 hx', fun hx => \u27e8\u27e8x, h hx\u27e9, hx, rfl\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_coe_eq_empty {s t : Set \u03b1} : ((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t = \u2205 \u2194 s \u2229 t = \u2205 := by\n  simp [\u2190 not_nonempty_iff_eq_empty, preimage_coe_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_11\ns t : Set \u03b1\n\u22a2 Subtype.val \u207b\u00b9' t = \u2205 \u2194 s \u2229 t = \u2205"}, {"line": "simp [\u2190 not_nonempty_iff_eq_empty, preimage_coe_nonempty]", "tactic_state": "\u03b1 : Type u_11\ns t : Set \u03b1\n\u22a2 \u00ac(Subtype.val \u207b\u00b9' t).Nonempty \u2194 \u00ac(s \u2229 t).Nonempty"}]}
{"declaration": "theorem injective_iff {\u03b1 \u03b2} {f : Option \u03b1 \u2192 \u03b2} :\n    Injective f \u2194 Injective (f \u2218 some) \u2227 f none \u2209 range (f \u2218 some) := by\n  simp only [mem_range]\n  simp only [not_exists]\n  simp only [(\u00b7 \u2218 \u00b7)]\n  refine\n    \u27e8fun hf => \u27e8hf.comp (Option.some_injective _), fun x => hf.ne <| Option.some_ne_none _\u27e9, ?_\u27e9\n  rintro \u27e8h_some, h_none\u27e9 (_ | a) (_ | b) hab\n  exacts [rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\n\u22a2 Injective f \u2194 Injective (f \u2218 some) \u2227 f none \u2209 range (f \u2218 some)"}, {"line": "simp only [mem_range]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\n\u22a2 Injective f \u2194 Injective (f \u2218 some) \u2227 \u00ac\u2203 y, (f \u2218 some) y = f none"}, {"line": "simp only [not_exists]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\n\u22a2 Injective f \u2194 Injective (f \u2218 some) \u2227 \u2200 (x : \u03b1), \u00ac(f \u2218 some) x = f none"}, {"line": "simp only [(\u00b7 \u2218 \u00b7)]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\n\u22a2 Injective f \u2194 Injective (f \u2218 some) \u2227 \u2200 (x : \u03b1), \u00acf (some x) = f none"}, {"line": "refine\n    \u27e8fun hf => \u27e8hf.comp (Option.some_injective _), fun x => hf.ne <| Option.some_ne_none _\u27e9, ?_\u27e9", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\n\u22a2 (Injective (f \u2218 some) \u2227 \u2200 (x : \u03b1), \u00acf (some x) = f none) \u2192 Injective f"}, {"line": "rintro \u27e8h_some, h_none\u27e9 (_ | a) (_ | b) hab", "tactic_state": "case intro.none.none\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\nh_some : Injective (f \u2218 some)\nh_none : \u2200 (x : \u03b1), \u00acf (some x) = f none\nhab : f none = f none\n\u22a2 none = none\n---\ncase intro.none.some\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\nh_some : Injective (f \u2218 some)\nh_none : \u2200 (x : \u03b1), \u00acf (some x) = f none\nb : \u03b1\nhab : f none = f (some b)\n\u22a2 none = some b\n---\ncase intro.some.none\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\nh_some : Injective (f \u2218 some)\nh_none : \u2200 (x : \u03b1), \u00acf (some x) = f none\na : \u03b1\nhab : f (some a) = f none\n\u22a2 some a = none\n---\ncase intro.some.some\n\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : Option \u03b1 \u2192 \u03b2\nh_some : Injective (f \u2218 some)\nh_none : \u2200 (x : \u03b1), \u00acf (some x) = f none\na b : \u03b1\nhab : f (some a) = f (some b)\n\u22a2 some a = some b"}, {"line": "exacts [rfl, (h_none _ hab.symm).elim, (h_none _ hab).elim, congr_arg some (h_some hab)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_eq_iff_eq_image {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} :\n    f \u207b\u00b9' s = t \u2194 s = f '' t := by rw [\u2190 image_eq_image hf.1, hf.2.image_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : Set \u03b2\nt : Set \u03b1\n\u22a2 f \u207b\u00b9' s = t \u2194 s = f '' t"}, {"line": "rw [\u2190 image_eq_image hf.1, hf.2.image_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_preimage_iff_image_eq {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} :\n    s = f \u207b\u00b9' t \u2194 f '' s = t := by rw [\u2190 image_eq_image hf.1, hf.2.image_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s = f \u207b\u00b9' t \u2194 f '' s = t"}, {"line": "rw [\u2190 image_eq_image hf.1, hf.2.image_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Disjoint.of_preimage (hf : Surjective f) {s t : Set \u03b2}\n    (h : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)) : Disjoint s t := by\n  rw [disjoint_iff_inter_eq_empty]\n  rw [\u2190 image_preimage_eq (_ \u2229 _) hf]\n  rw [preimage_inter]\n  rw [h.inter_eq]\n  rw [image_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns t : Set \u03b2\nh : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)\n\u22a2 Disjoint s t"}, {"line": "rw [disjoint_iff_inter_eq_empty]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns t : Set \u03b2\nh : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)\n\u22a2 s \u2229 t = \u2205"}, {"line": "rw [\u2190 image_preimage_eq (_ \u2229 _) hf]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns t : Set \u03b2\nh : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)\n\u22a2 f '' (f \u207b\u00b9' (s \u2229 t)) = \u2205"}, {"line": "rw [preimage_inter]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns t : Set \u03b2\nh : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)\n\u22a2 f '' (f \u207b\u00b9' s \u2229 f \u207b\u00b9' t) = \u2205"}, {"line": "rw [h.inter_eq]", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\nhf : Surjective f\ns t : Set \u03b2\nh : Disjoint (f \u207b\u00b9' s) (f \u207b\u00b9' t)\n\u22a2 f '' \u2205 = \u2205"}, {"line": "rw [image_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_eq_empty {s : Set \u03b2} (h : Disjoint s (range f)) :\n    f \u207b\u00b9' s = \u2205 := by\n  simpa using h.preimage f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u03b2 : Type u_13\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : Disjoint s (range f)\n\u22a2 f \u207b\u00b9' s = \u2205"}, {"line": "simpa using h.preimage f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sigma_mk_preimage_image' (h : i \u2260 j) : Sigma.mk j \u207b\u00b9' (Sigma.mk i '' s) = \u2205 := by\n  simp [image, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {i j : \u03b1} {s : Set (\u03b2 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_15\n\u03b2 : \u03b1 \u2192 Type u_16\ni j : \u03b1\ns : Set (\u03b2 i)\nh : i \u2260 j\n\u22a2 Sigma.mk j \u207b\u00b9' (Sigma.mk i '' s) = \u2205"}, {"line": "simp [image, h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sigma_mk_preimage_image_eq_self : Sigma.mk i \u207b\u00b9' (Sigma.mk i '' s) = s := by\n  simp [image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Image.lean", "context": {"open": ["Function Set", "scoped symmDiff in", "scoped symmDiff in", "scoped symmDiff in", "Set", "Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {\u03b9 : Sort*}", "{f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}", "{f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{f : \u03b9 \u2192 \u03b1} {s t : Set \u03b1}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 : Type*} {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2}", "{\u03b9 \u03b9' : Sort*} {E : Type*} [EquivLike E \u03b9 \u03b9']", "{\u03b1 : Type*}", "{\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2}", "{\u03b1 \u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1}", "{\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {i j : \u03b1} {s : Set (\u03b2 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_15\n\u03b2 : \u03b1 \u2192 Type u_16\ni : \u03b1\ns : Set (\u03b2 i)\n\u22a2 Sigma.mk i \u207b\u00b9' (Sigma.mk i '' s) = s"}, {"line": "simp [image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_mem_insert {P : \u03b1 \u2192 Prop} {a : \u03b1} {s : Set \u03b1} :\n    (\u2203 x \u2208 insert a s, P x) \u2194 (P a \u2228 \u2203 x \u2208 s, P x) := by\n  simp [mem_insert_iff, or_and_right, exists_and_left, exists_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nP : \u03b1 \u2192 Prop\na : \u03b1\ns : Set \u03b1\n\u22a2 (\u2203 x \u2208 insert a s, P x) \u2194 P a \u2228 \u2203 x \u2208 s, P x"}, {"line": "simp [mem_insert_iff, or_and_right, exists_and_left, exists_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_subset_singleton : ({a} : Set \u03b1) \u2286 {b} \u2194 a = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na b : \u03b1\n\u22a2 {a} \u2286 {b} \u2194 a = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setOf_mem_list_eq_replicate {l : List \u03b1} {a : \u03b1} :\n    { x | x \u2208 l } = {a} \u2194 \u2203 n > 0, l = List.replicate n a := by\n  simpa +contextual [Set.ext_iff, iff_iff_implies_and_implies, forall_and, List.eq_replicate_iff,\n    List.length_pos_iff_exists_mem] using \u27e8fun _ _ \u21a6 \u27e8_, \u2039_\u203a\u27e9, fun x hx h \u21a6 h _ hx \u25b8 hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nl : List \u03b1\na : \u03b1\n\u22a2 {x | x \u2208 l} = {a} \u2194 \u2203 n > 0, l = List.replicate n a"}, {"line": "simpa +contextual [Set.ext_iff, iff_iff_implies_and_implies, forall_and, List.eq_replicate_iff,\n    List.length_pos_iff_exists_mem] using \u27e8fun _ _ \u21a6 \u27e8_, \u2039_\u203a\u27e9, fun x hx h \u21a6 h _ hx \u25b8 hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_singleton_iff_eq {s : Set \u03b1} {x : \u03b1} : s \u2286 {x} \u2194 s = \u2205 \u2228 s = {x} := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  \u00b7 exact \u27e8fun _ => Or.inl rfl, fun _ => empty_subset _\u27e9\n  \u00b7 simp [eq_singleton_iff_nonempty_unique_mem, hs, hs.ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nx : \u03b1\n\u22a2 s \u2286 {x} \u2194 s = \u2205 \u2228 s = {x}"}, {"line": "obtain rfl | hs := s.eq_empty_or_nonempty", "tactic_state": "case inl\n\u03b1 : Type u\nx : \u03b1\n\u22a2 \u2205 \u2286 {x} \u2194 \u2205 = \u2205 \u2228 \u2205 = {x}\n---\ncase inr\n\u03b1 : Type u\ns : Set \u03b1\nx : \u03b1\nhs : s.Nonempty\n\u22a2 s \u2286 {x} \u2194 s = \u2205 \u2228 s = {x}"}, {"line": "\u00b7 exact \u27e8fun _ => Or.inl rfl, fun _ => empty_subset _\u27e9", "tactic_state": "case inr\n\u03b1 : Type u\ns : Set \u03b1\nx : \u03b1\nhs : s.Nonempty\n\u22a2 s \u2286 {x} \u2194 s = \u2205 \u2228 s = {x}"}, {"line": "\u00b7 simp [eq_singleton_iff_nonempty_unique_mem, hs, hs.ne_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_singleton_left : Disjoint {a} s \u2194 a \u2209 s := by simp [Set.disjoint_iff, subset_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 Disjoint {a} s \u2194 a \u2209 s"}, {"line": "simp [Set.disjoint_iff, subset_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_singleton : Disjoint ({a} : Set \u03b1) {b} \u2194 a \u2260 b := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na b : \u03b1\n\u22a2 Disjoint {a} {b} \u2194 a \u2260 b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_insert_left : Disjoint (insert a s) t \u2194 a \u2209 t \u2227 Disjoint s t := by\n  simp only [Set.disjoint_left]\n  simp only [Set.mem_insert_iff]\n  simp only [forall_eq_or_imp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\na : \u03b1\n\u22a2 Disjoint (insert a s) t \u2194 a \u2209 t \u2227 Disjoint s t"}, {"line": "simp only [Set.disjoint_left]", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\na : \u03b1\n\u22a2 (\u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 insert a s \u2192 a_1 \u2209 t) \u2194 a \u2209 t \u2227 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 a \u2209 t"}, {"line": "simp only [Set.mem_insert_iff]", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\na : \u03b1\n\u22a2 (\u2200 \u2983a_1 : \u03b1\u2984, a_1 = a \u2228 a_1 \u2208 s \u2192 a_1 \u2209 t) \u2194 a \u2209 t \u2227 \u2200 \u2983a : \u03b1\u2984, a \u2208 s \u2192 a \u2209 t"}, {"line": "simp only [forall_eq_or_imp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_diff_of_mem (s) (h : a \u2208 t) : insert a s \\ t = s \\ t := by\n  ext\n  constructor <;> simp +contextual [or_imp, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\na : \u03b1\ns : Set \u03b1\nh : a \u2208 t\n\u22a2 insert a s \\ t = s \\ t"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u\nt : Set \u03b1\na : \u03b1\ns : Set \u03b1\nh : a \u2208 t\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 insert a s \\ t \u2194 x\u271d \u2208 s \\ t"}, {"line": "constructor <;> simp +contextual [or_imp, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_diff_of_not_mem (s) (h : a \u2209 t) : insert a s \\ t = insert a (s \\ t) := by\n  classical\n    ext x\n    by_cases h' : x \u2208 t\n    \u00b7 simp [h, h', ne_of_mem_of_not_mem h' h]\n    \u00b7 simp [h, h']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\na : \u03b1\ns : Set \u03b1\nh : a \u2209 t\n\u22a2 insert a s \\ t = insert a (s \\ t)"}, {"line": "classical\n    ext x\n    by_cases h' : x \u2208 t\n    \u00b7 simp [h, h', ne_of_mem_of_not_mem h' h]\n    \u00b7 simp [h, h']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_diff_self_of_not_mem {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : insert a s \\ {a} = s := by\n  ext x\n  simp [and_iff_left_of_imp (ne_of_mem_of_not_mem \u00b7 h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\n\u22a2 insert a s \\ {a} = s"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx : \u03b1\n\u22a2 x \u2208 insert a s \\ {a} \u2194 x \u2208 s"}, {"line": "simp [and_iff_left_of_imp (ne_of_mem_of_not_mem \u00b7 h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_diff_eq_singleton {a : \u03b1} {s : Set \u03b1} (h : a \u2209 s) : insert a s \\ s = {a} := by\n  ext\n  rw [Set.mem_diff]\n  rw [Set.mem_insert_iff]\n  rw [Set.mem_singleton_iff]\n  rw [or_and_right]\n  rw [and_not_self_iff]\n  rw [or_false]\n  rw [and_iff_left_iff_imp]\n  rintro rfl\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\n\u22a2 insert a s \\ s = {a}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 insert a s \\ s \u2194 x\u271d \u2208 {a}"}, {"line": "rw [Set.mem_diff]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 insert a s \u2227 x\u271d \u2209 s \u2194 x\u271d \u2208 {a}"}, {"line": "rw [Set.mem_insert_iff]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 (x\u271d = a \u2228 x\u271d \u2208 s) \u2227 x\u271d \u2209 s \u2194 x\u271d \u2208 {a}"}, {"line": "rw [Set.mem_singleton_iff]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 (x\u271d = a \u2228 x\u271d \u2208 s) \u2227 x\u271d \u2209 s \u2194 x\u271d = a"}, {"line": "rw [or_and_right]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d = a \u2227 x\u271d \u2209 s \u2228 x\u271d \u2208 s \u2227 x\u271d \u2209 s \u2194 x\u271d = a"}, {"line": "rw [and_not_self_iff]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d = a \u2227 x\u271d \u2209 s \u2228 False \u2194 x\u271d = a"}, {"line": "rw [or_false]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d = a \u2227 x\u271d \u2209 s \u2194 x\u271d = a"}, {"line": "rw [and_iff_left_iff_imp]", "tactic_state": "case h\n\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\nh : a \u2209 s\nx\u271d : \u03b1\n\u22a2 x\u271d = a \u2192 x\u271d \u2209 s"}, {"line": "rintro rfl", "tactic_state": "case h\n\u03b1 : Type u\ns : Set \u03b1\nx\u271d : \u03b1\nh : x\u271d \u2209 s\n\u22a2 x\u271d \u2209 s"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diff_singleton_ssubset {s : Set \u03b1} {a : \u03b1} : s \\ {a} \u2282 s \u2194 a \u2208 s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 s \\ {a} \u2282 s \u2194 a \u2208 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_diff_singleton {a : \u03b1} {s : Set \u03b1} : insert a (s \\ {a}) = insert a s := by\n  simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : \u03b1\ns : Set \u03b1\n\u22a2 insert a (s \\ {a}) = insert a s"}, {"line": "simp [insert_eq, union_diff_self, -union_singleton, -singleton_union]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_fst_singleton_eq_range : (Prod.fst \u207b\u00b9' {a} : Set (\u03b1 \u00d7 \u03b2)) = range (a, \u00b7) := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Insert.lean", "context": {"open": ["Function", "Set", "Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1} {a b : \u03b1}", "{\u03b1 \u03b2 : Type*} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\n\u22a2 Prod.fst \u207b\u00b9' {a} = range fun x => (a, x)"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iUnion\u2082 {x : \u03b3} {s : \u2200 i, \u03ba i \u2192 Set \u03b3} : (x \u2208 \u22c3 (i) (j), s i j) \u2194 \u2203 i j, x \u2208 s i j := by\n  simp_rw [mem_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nx : \u03b3\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b3\n\u22a2 x \u2208 \u22c3 i, \u22c3 j, s i j \u2194 \u2203 i j, x \u2208 s i j"}, {"line": "simp_rw [mem_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_iInter\u2082 {x : \u03b3} {s : \u2200 i, \u03ba i \u2192 Set \u03b3} : (x \u2208 \u22c2 (i) (j), s i j) \u2194 \u2200 i j, x \u2208 s i j := by\n  simp_rw [mem_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nx : \u03b3\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b3\n\u22a2 x \u2208 \u22c2 i, \u22c2 j, s i j \u2194 \u2200 (i : \u03b9) (j : \u03ba i), x \u2208 s i j"}, {"line": "simp_rw [mem_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_set_mem_of_union_eq_top {\u03b9 : Type*} (t : Set \u03b9) (s : \u03b9 \u2192 Set \u03b2)\n    (w : \u22c3 i \u2208 t, s i = \u22a4) (x : \u03b2) : \u2203 i \u2208 t, x \u2208 s i := by\n  have p : x \u2208 \u22a4 := Set.mem_univ x\n  rw [\u2190 w] at p\n  rw [Set.mem_iUnion] at p\n  simpa using p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b2\nw : \u22c3 i \u2208 t, s i = \u22a4\nx : \u03b2\n\u22a2 \u2203 i \u2208 t, x \u2208 s i"}, {"line": "have p : x \u2208 \u22a4 := Set.mem_univ x", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b2\nw : \u22c3 i \u2208 t, s i = \u22a4\nx : \u03b2\np : x \u2208 \u22a4\n\u22a2 \u2203 i \u2208 t, x \u2208 s i"}, {"line": "rw [\u2190 w] at p", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b2\nw : \u22c3 i \u2208 t, s i = \u22a4\nx : \u03b2\np : x \u2208 \u22c3 i \u2208 t, s i\n\u22a2 \u2203 i \u2208 t, x \u2208 s i"}, {"line": "rw [Set.mem_iUnion] at p", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b2\nw : \u22c3 i \u2208 t, s i = \u22a4\nx : \u03b2\np : \u2203 i, x \u2208 \u22c3 (_ : i \u2208 t), s i\n\u22a2 \u2203 i \u2208 t, x \u2208 s i"}, {"line": "simpa using p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_of_union_eq_top_of_nonempty {\u03b9 : Type*} (t : Set \u03b9) (s : \u03b9 \u2192 Set \u03b1)\n    (H : Nonempty \u03b1) (w : \u22c3 i \u2208 t, s i = \u22a4) : t.Nonempty := by\n  obtain \u27e8x, m, -\u27e9 := exists_set_mem_of_union_eq_top t s w H.some\n  exact \u27e8x, m\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b1\nH : Nonempty \u03b1\nw : \u22c3 i \u2208 t, s i = \u22a4\n\u22a2 t.Nonempty"}, {"line": "obtain \u27e8x, m, -\u27e9 := exists_set_mem_of_union_eq_top t s w H.some", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_12\nt : Set \u03b9\ns : \u03b9 \u2192 Set \u03b1\nH : Nonempty \u03b1\nw : \u22c3 i \u2208 t, s i = \u22a4\nx : \u03b9\nm : x \u2208 t\n\u22a2 t.Nonempty"}, {"line": "exact \u27e8x, m\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_of_nonempty_iUnion\n    {s : \u03b9 \u2192 Set \u03b1} (h_Union : (\u22c3 i, s i).Nonempty) : Nonempty \u03b9 := by\n  obtain \u27e8x, hx\u27e9 := h_Union\n  exact \u27e8Classical.choose <| mem_iUnion.mp hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nh_Union : (\u22c3 i, s i).Nonempty\n\u22a2 Nonempty \u03b9"}, {"line": "obtain \u27e8x, hx\u27e9 := h_Union", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nx : \u03b1\nhx : x \u2208 \u22c3 i, s i\n\u22a2 Nonempty \u03b9"}, {"line": "exact \u27e8Classical.choose <| mem_iUnion.mp hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion\u2082_subset_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b1} :\n    \u22c3 (i) (j), s i j \u2286 t \u2194 \u2200 i j, s i j \u2286 t := by simp_rw [iUnion_subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 \u22c3 i, \u22c3 j, s i j \u2286 t \u2194 \u2200 (i : \u03b9) (j : \u03ba i), s i j \u2286 t"}, {"line": "simp_rw [iUnion_subset_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_iInter\u2082_iff {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    (s \u2286 \u22c2 (i) (j), t i j) \u2194 \u2200 i j, s \u2286 t i j := by simp_rw [subset_iInter_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 s \u2286 \u22c2 i, \u22c2 j, t i j \u2194 \u2200 (i : \u03b9) (j : \u03ba i), s \u2286 t i j"}, {"line": "simp_rw [subset_iInter_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_setOf (P : \u03b9 \u2192 \u03b1 \u2192 Prop) : \u22c3 i, { x : \u03b1 | P i x } = { x : \u03b1 | \u2203 i, P i x } := by\n  ext\n  exact mem_iUnion\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\nP : \u03b9 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u22c3 i, {x | P i x} = {x | \u2203 i, P i x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Sort u_5\nP : \u03b9 \u2192 \u03b1 \u2192 Prop\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 i, {x | P i x} \u2194 x\u271d \u2208 {x | \u2203 i, P i x}"}, {"line": "exact mem_iUnion", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter_setOf (P : \u03b9 \u2192 \u03b1 \u2192 Prop) : \u22c2 i, { x : \u03b1 | P i x } = { x : \u03b1 | \u2200 i, P i x } := by\n  ext\n  exact mem_iInter\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\nP : \u03b9 \u2192 \u03b1 \u2192 Prop\n\u22a2 \u22c2 i, {x | P i x} = {x | \u2200 (i : \u03b9), P i x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Sort u_5\nP : \u03b9 \u2192 \u03b1 \u2192 Prop\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c2 i, {x | P i x} \u2194 x\u271d \u2208 {x | \u2200 (i : \u03b9), P i x}"}, {"line": "exact mem_iInter", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_iUnion\u2082 (s : \u2200 i, \u03ba i \u2192 Set \u03b1) : (\u22c3 (i) (j), s i j)\u1d9c = \u22c2 (i) (j), (s i j)\u1d9c := by\n  simp_rw [compl_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u22c3 i, \u22c3 j, s i j)\u1d9c = \u22c2 i, \u22c2 j, (s i j)\u1d9c"}, {"line": "simp_rw [compl_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_iInter\u2082 (s : \u2200 i, \u03ba i \u2192 Set \u03b1) : (\u22c2 (i) (j), s i j)\u1d9c = \u22c3 (i) (j), (s i j)\u1d9c := by\n  simp_rw [compl_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 j, s i j)\u1d9c = \u22c3 i, \u22c3 j, (s i j)\u1d9c"}, {"line": "simp_rw [compl_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_eq_compl_iInter_compl (s : \u03b9 \u2192 Set \u03b2) : \u22c3 i, s i = (\u22c2 i, (s i)\u1d9c)\u1d9c := by\n  simp only [compl_iInter]\n  simp only [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s i = (\u22c2 i, (s i)\u1d9c)\u1d9c"}, {"line": "simp only [compl_iInter]", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s i = \u22c3 i, (s i)\u1d9c\u1d9c"}, {"line": "simp only [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter_eq_compl_iUnion_compl (s : \u03b9 \u2192 Set \u03b2) : \u22c2 i, s i = (\u22c3 i, (s i)\u1d9c)\u1d9c := by\n  simp only [compl_iUnion]\n  simp only [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c2 i, s i = (\u22c3 i, (s i)\u1d9c)\u1d9c"}, {"line": "simp only [compl_iUnion]", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c2 i, s i = \u22c2 i, (s i)\u1d9c\u1d9c"}, {"line": "simp only [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_iInter (x : \u03b2) (t : \u03b9 \u2192 Set \u03b2) : insert x (\u22c2 i, t i) = \u22c2 i, insert x (t i) := by\n  simp_rw [\u2190 union_singleton, iInter_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nx : \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 insert x (\u22c2 i, t i) = \u22c2 i, insert x (t i)"}, {"line": "simp_rw [\u2190 union_singleton, iInter_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_biUnion {t : Set \u03b1} {s : \u03b1 \u2192 Set \u03b2} :\n    (\u22c3 i \u2208 t, s i).Nonempty \u2194 \u2203 i \u2208 t, (s i).Nonempty := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 (\u22c3 i \u2208 t, s i).Nonempty \u2194 \u2203 i \u2208 t, (s i).Nonempty"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_and (p : \u03b9 \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p x \u2227 q x y \u2192 Set \u03b1) :\n    \u22c3 (x : \u03b9) (y : \u03b9') (h : p x \u2227 q x y), s x y h =\n      \u22c3 (x : \u03b9) (hx : p x) (y : \u03b9') (hy : q x y), s x y \u27e8hx, hy\u27e9 := by\n  simp only [iUnion_and]\n  simp only [@iUnion_comm _ \u03b9']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9 \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p x \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c3 x, \u22c3 y, \u22c3 (h : p x \u2227 q x y), s x y h = \u22c3 x, \u22c3 (hx : p x), \u22c3 y, \u22c3 (hy : q x y), s x y \u22ef"}, {"line": "simp only [iUnion_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9 \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p x \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c3 x, \u22c3 y, \u22c3 (hp : p x), \u22c3 (hq : q x y), s x y \u22ef = \u22c3 x, \u22c3 (hx : p x), \u22c3 y, \u22c3 (hy : q x y), s x y \u22ef"}, {"line": "simp only [@iUnion_comm _ \u03b9']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_and' (p : \u03b9' \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p y \u2227 q x y \u2192 Set \u03b1) :\n    \u22c3 (x : \u03b9) (y : \u03b9') (h : p y \u2227 q x y), s x y h =\n      \u22c3 (y : \u03b9') (hy : p y) (x : \u03b9) (hx : q x y), s x y \u27e8hy, hx\u27e9 := by\n  simp only [iUnion_and]\n  simp only [@iUnion_comm _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9' \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p y \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c3 x, \u22c3 y, \u22c3 (h : p y \u2227 q x y), s x y h = \u22c3 y, \u22c3 (hy : p y), \u22c3 x, \u22c3 (hx : q x y), s x y \u22ef"}, {"line": "simp only [iUnion_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9' \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p y \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c3 x, \u22c3 y, \u22c3 (hp : p y), \u22c3 (hq : q x y), s x y \u22ef = \u22c3 y, \u22c3 (hy : p y), \u22c3 x, \u22c3 (hx : q x y), s x y \u22ef"}, {"line": "simp only [@iUnion_comm _ \u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_and (p : \u03b9 \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p x \u2227 q x y \u2192 Set \u03b1) :\n    \u22c2 (x : \u03b9) (y : \u03b9') (h : p x \u2227 q x y), s x y h =\n      \u22c2 (x : \u03b9) (hx : p x) (y : \u03b9') (hy : q x y), s x y \u27e8hx, hy\u27e9 := by\n  simp only [iInter_and]\n  simp only [@iInter_comm _ \u03b9']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9 \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p x \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c2 x, \u22c2 y, \u22c2 (h : p x \u2227 q x y), s x y h = \u22c2 x, \u22c2 (hx : p x), \u22c2 y, \u22c2 (hy : q x y), s x y \u22ef"}, {"line": "simp only [iInter_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9 \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p x \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c2 x, \u22c2 y, \u22c2 (hp : p x), \u22c2 (hq : q x y), s x y \u22ef = \u22c2 x, \u22c2 (hx : p x), \u22c2 y, \u22c2 (hy : q x y), s x y \u22ef"}, {"line": "simp only [@iInter_comm _ \u03b9']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_and' (p : \u03b9' \u2192 Prop) (q : \u03b9 \u2192 \u03b9' \u2192 Prop) (s : \u2200 x y, p y \u2227 q x y \u2192 Set \u03b1) :\n    \u22c2 (x : \u03b9) (y : \u03b9') (h : p y \u2227 q x y), s x y h =\n      \u22c2 (y : \u03b9') (hy : p y) (x : \u03b9) (hx : q x y), s x y \u27e8hy, hx\u27e9 := by\n  simp only [iInter_and]\n  simp only [@iInter_comm _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9' \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p y \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c2 x, \u22c2 y, \u22c2 (h : p y \u2227 q x y), s x y h = \u22c2 y, \u22c2 (hy : p y), \u22c2 x, \u22c2 (hx : q x y), s x y \u22ef"}, {"line": "simp only [iInter_and]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03b9' : Sort u_6\ninst\u271d : Nonempty \u03b9\np : \u03b9' \u2192 Prop\nq : \u03b9 \u2192 \u03b9' \u2192 Prop\ns : (x : \u03b9) \u2192 (y : \u03b9') \u2192 p y \u2227 q x y \u2192 Set \u03b1\n\u22a2 \u22c2 x, \u22c2 y, \u22c2 (hp : p y), \u22c2 (hq : q x y), s x y \u22ef = \u22c2 y, \u22c2 (hy : p y), \u22c2 x, \u22c2 (hx : q x y), s x y \u22ef"}, {"line": "simp only [@iInter_comm _ \u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_iUnion_eq_or_left {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u2200 x : \u03b2, x = b \u2228 p x \u2192 Set \u03b1} :\n    \u22c3 (x) (h), s x h = s b (Or.inl rfl) \u222a \u22c3 (x) (h : p x), s x (Or.inr h) := by\n  simp only [iUnion_or]\n  simp only [iUnion_union_distrib]\n  simp only [iUnion_iUnion_eq_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 \u22c3 x, \u22c3 (h : x = b \u2228 p x), s x h = s b \u22ef \u222a \u22c3 x, \u22c3 (h : p x), s x \u22ef"}, {"line": "simp only [iUnion_or]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 \u22c3 x, (\u22c3 (i : x = b), s x \u22ef) \u222a \u22c3 (j : p x), s x \u22ef = s b \u22ef \u222a \u22c3 x, \u22c3 (h : p x), s x \u22ef"}, {"line": "simp only [iUnion_union_distrib]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 (\u22c3 i, \u22c3 (i_1 : i = b), s i \u22ef) \u222a \u22c3 i, \u22c3 (j : p i), s i \u22ef = s b \u22ef \u222a \u22c3 i, \u22c3 (j : p i), s i \u22ef"}, {"line": "simp only [iUnion_iUnion_eq_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter_iInter_eq_or_left {b : \u03b2} {p : \u03b2 \u2192 Prop} {s : \u2200 x : \u03b2, x = b \u2228 p x \u2192 Set \u03b1} :\n    \u22c2 (x) (h), s x h = s b (Or.inl rfl) \u2229 \u22c2 (x) (h : p x), s x (Or.inr h) := by\n  simp only [iInter_or]\n  simp only [iInter_inter_distrib]\n  simp only [iInter_iInter_eq_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 \u22c2 x, \u22c2 (h : x = b \u2228 p x), s x h = s b \u22ef \u2229 \u22c2 x, \u22c2 (h : p x), s x \u22ef"}, {"line": "simp only [iInter_or]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 \u22c2 x, (\u22c2 (h : x = b), s x \u22ef) \u2229 \u22c2 (h : p x), s x \u22ef = s b \u22ef \u2229 \u22c2 x, \u22c2 (h : p x), s x \u22ef"}, {"line": "simp only [iInter_inter_distrib]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\np : \u03b2 \u2192 Prop\ns : (x : \u03b2) \u2192 x = b \u2228 p x \u2192 Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 (h : i = b), s i \u22ef) \u2229 \u22c2 i, \u22c2 (h : p i), s i \u22ef = s b \u22ef \u2229 \u22c2 i, \u22c2 (h : p i), s i \u22ef"}, {"line": "simp only [iInter_iInter_eq_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_nonempty_self (s : Set \u03b1) : \u22c3 _ : s.Nonempty, s = s := by\n  rw [iUnion_nonempty_index]\n  rw [biUnion_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 \u22c3 (_ : s.Nonempty), s = s"}, {"line": "rw [iUnion_nonempty_index]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 \u22c3 x \u2208 s, s = s"}, {"line": "rw [biUnion_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_insert (a : \u03b1) (s : Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 insert a s, t x = t a \u2229 \u22c2 x \u2208 s, t x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\ns : Set \u03b1\nt : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c2 x \u2208 insert a s, t x = t a \u2229 \u22c2 x \u2208 s, t x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_pair (a b : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c2 x \u2208 ({a, b} : Set \u03b1), s x = s a \u2229 s b := by\n  rw [biInter_insert]\n  rw [biInter_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c2 x \u2208 {a, b}, s x = s a \u2229 s b"}, {"line": "rw [biInter_insert]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 s a \u2229 \u22c2 x \u2208 {b}, s x = s a \u2229 s b"}, {"line": "rw [biInter_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inter_biInter {\u03b9 \u03b1 : Type*} {s : Set \u03b9} (hs : s.Nonempty) (f : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) :\n    \u22c2 i \u2208 s, t \u2229 f i = t \u2229 \u22c2 i \u2208 s, f i := by\n  rw [inter_comm]\n  rw [\u2190 biInter_inter hs]\n  simp [inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_12\n\u03b1 : Type u_13\ns : Set \u03b9\nhs : s.Nonempty\nf : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 \u22c2 i \u2208 s, t \u2229 f i = t \u2229 \u22c2 i \u2208 s, f i"}, {"line": "rw [inter_comm]", "tactic_state": "\u03b9 : Type u_12\n\u03b1 : Type u_13\ns : Set \u03b9\nhs : s.Nonempty\nf : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 \u22c2 i \u2208 s, t \u2229 f i = (\u22c2 i \u2208 s, f i) \u2229 t"}, {"line": "rw [\u2190 biInter_inter hs]", "tactic_state": "\u03b9 : Type u_12\n\u03b1 : Type u_13\ns : Set \u03b9\nhs : s.Nonempty\nf : \u03b9 \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 \u22c2 i \u2208 s, t \u2229 f i = \u22c2 i \u2208 s, f i \u2229 t"}, {"line": "simp [inter_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_insert (a : \u03b1) (s : Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 insert a s, t x = t a \u222a \u22c3 x \u2208 s, t x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na : \u03b1\ns : Set \u03b1\nt : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c3 x \u2208 insert a s, t x = t a \u222a \u22c3 x \u2208 s, t x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_pair (a b : \u03b1) (s : \u03b1 \u2192 Set \u03b2) : \u22c3 x \u2208 ({a, b} : Set \u03b1), s x = s a \u222a s b := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na b : \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c3 x \u2208 {a, b}, s x = s a \u222a s b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inter_iUnion\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u2229 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s \u2229 t i j := by simp only [inter_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 s \u2229 \u22c3 i, \u22c3 j, t i j = \u22c3 i, \u22c3 j, s \u2229 t i j"}, {"line": "simp only [inter_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion\u2082_inter (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c3 (i) (j), s i j) \u2229 t = \u22c3 (i) (j), s i j \u2229 t := by simp_rw [iUnion_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 (\u22c3 i, \u22c3 j, s i j) \u2229 t = \u22c3 i, \u22c3 j, s i j \u2229 t"}, {"line": "simp_rw [iUnion_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_iInter\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u222a \u22c2 (i) (j), t i j) = \u22c2 (i) (j), s \u222a t i j := by simp_rw [union_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 s \u222a \u22c2 i, \u22c2 j, t i j = \u22c2 i, \u22c2 j, s \u222a t i j"}, {"line": "simp_rw [union_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter\u2082_union (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) \u222a t = \u22c2 (i) (j), s i j \u222a t := by simp_rw [iInter_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 j, s i j) \u222a t = \u22c2 i, \u22c2 j, s i j \u222a t"}, {"line": "simp_rw [iInter_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_mem_empty_univ {S : Set (Set \u03b1)} (h : S \u2286 {\u2205, univ}) :\n    \u22c3\u2080 S \u2208 ({\u2205, univ} : Set (Set \u03b1)) := by\n  simp only [mem_insert_iff]\n  simp only [mem_singleton_iff]\n  simp only [or_iff_not_imp_left]\n  simp only [sUnion_eq_empty]\n  simp only [not_forall]\n  rintro \u27e8s, hs, hne\u27e9\n  obtain rfl : s = univ := (h hs).resolve_left hne\n  exact univ_subset_iff.1 <| subset_sUnion_of_mem hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 \u22c3\u2080 S \u2208 {\u2205, univ}"}, {"line": "simp only [mem_insert_iff]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 \u22c3\u2080 S = \u2205 \u2228 \u22c3\u2080 S \u2208 {univ}"}, {"line": "simp only [mem_singleton_iff]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 \u22c3\u2080 S = \u2205 \u2228 \u22c3\u2080 S = univ"}, {"line": "simp only [or_iff_not_imp_left]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 \u00ac\u22c3\u2080 S = \u2205 \u2192 \u22c3\u2080 S = univ"}, {"line": "simp only [sUnion_eq_empty]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 (\u00ac\u2200 s \u2208 S, s = \u2205) \u2192 \u22c3\u2080 S = univ"}, {"line": "simp only [not_forall]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\n\u22a2 (\u2203 x, \u2203 (_ : x \u2208 S), \u00acx = \u2205) \u2192 \u22c3\u2080 S = univ"}, {"line": "rintro \u27e8s, hs, hne\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\ns : Set \u03b1\nhs : s \u2208 S\nhne : \u00acs = \u2205\n\u22a2 \u22c3\u2080 S = univ"}, {"line": "obtain rfl : s = univ := (h hs).resolve_left hne", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : S \u2286 {\u2205, univ}\nhs : univ \u2208 S\nhne : \u00acuniv = \u2205\n\u22a2 \u22c3\u2080 S = univ"}, {"line": "exact univ_subset_iff.1 <| subset_sUnion_of_mem hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_sUnion {S : Set (Set \u03b1)} : (\u22c3\u2080 S).Nonempty \u2194 \u2203 s \u2208 S, Set.Nonempty s := by\n  simp [nonempty_iff_ne_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 (\u22c3\u2080 S).Nonempty \u2194 \u2203 s \u2208 S, s.Nonempty"}, {"line": "simp [nonempty_iff_ne_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion\u2082_eq_univ_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    \u22c3 (i) (j), s i j = univ \u2194 \u2200 a, \u2203 i j, a \u2208 s i j := by\n  simp only [iUnion_eq_univ_iff]\n  simp only [mem_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c3 i, \u22c3 j, s i j = univ \u2194 \u2200 (a : \u03b1), \u2203 i j, a \u2208 s i j"}, {"line": "simp only [iUnion_eq_univ_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2203 i, x \u2208 \u22c3 j, s i j) \u2194 \u2200 (a : \u03b1), \u2203 i j, a \u2208 s i j"}, {"line": "simp only [mem_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_eq_univ_iff {c : Set (Set \u03b1)} : \u22c3\u2080 c = univ \u2194 \u2200 a, \u2203 b \u2208 c, a \u2208 b := by\n  simp only [eq_univ_iff_forall]\n  simp only [mem_sUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nc : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 c = univ \u2194 \u2200 (a : \u03b1), \u2203 b \u2208 c, a \u2208 b"}, {"line": "simp only [eq_univ_iff_forall]", "tactic_state": "\u03b1 : Type u_1\nc : Set (Set \u03b1)\n\u22a2 (\u2200 (x : \u03b1), x \u2208 \u22c3\u2080 c) \u2194 \u2200 (a : \u03b1), \u2203 b \u2208 c, a \u2208 b"}, {"line": "simp only [mem_sUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter_eq_empty_iff {f : \u03b9 \u2192 Set \u03b1} : \u22c2 i, f i = \u2205 \u2194 \u2200 x, \u2203 i, x \u2209 f i := by\n  simp [Set.eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Set \u03b1\n\u22a2 \u22c2 i, f i = \u2205 \u2194 \u2200 (x : \u03b1), \u2203 i, x \u2209 f i"}, {"line": "simp [Set.eq_empty_iff_forall_not_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter\u2082_eq_empty_iff {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    \u22c2 (i) (j), s i j = \u2205 \u2194 \u2200 a, \u2203 i j, a \u2209 s i j := by\n  simp only [eq_empty_iff_forall_not_mem]\n  simp only [mem_iInter]\n  simp only [not_forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 \u22c2 i, \u22c2 j, s i j = \u2205 \u2194 \u2200 (a : \u03b1), \u2203 i j, a \u2209 s i j"}, {"line": "simp only [eq_empty_iff_forall_not_mem]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u2200 (x : \u03b1), x \u2209 \u22c2 i, \u22c2 j, s i j) \u2194 \u2200 (a : \u03b1), \u2203 i j, a \u2209 s i j"}, {"line": "simp only [mem_iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u00ac\u2200 (i : \u03b9) (i_1 : \u03ba i), x \u2208 s i i_1) \u2194 \u2200 (a : \u03b1), \u2203 i j, a \u2209 s i j"}, {"line": "simp only [not_forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_eq_empty_iff {c : Set (Set \u03b1)} : \u22c2\u2080 c = \u2205 \u2194 \u2200 a, \u2203 b \u2208 c, a \u2209 b := by\n  simp [Set.eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nc : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 c = \u2205 \u2194 \u2200 (a : \u03b1), \u2203 b \u2208 c, a \u2209 b"}, {"line": "simp [Set.eq_empty_iff_forall_not_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_iInter {f : \u03b9 \u2192 Set \u03b1} : (\u22c2 i, f i).Nonempty \u2194 \u2203 x, \u2200 i, x \u2208 f i := by\n  simp [nonempty_iff_ne_empty, iInter_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nf : \u03b9 \u2192 Set \u03b1\n\u22a2 (\u22c2 i, f i).Nonempty \u2194 \u2203 x, \u2200 (i : \u03b9), x \u2208 f i"}, {"line": "simp [nonempty_iff_ne_empty, iInter_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_iInter\u2082 {s : \u2200 i, \u03ba i \u2192 Set \u03b1} :\n    (\u22c2 (i) (j), s i j).Nonempty \u2194 \u2203 a, \u2200 i j, a \u2208 s i j := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 j, s i j).Nonempty \u2194 \u2203 a, \u2200 (i : \u03b9) (j : \u03ba i), a \u2208 s i j"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_sInter {c : Set (Set \u03b1)} : (\u22c2\u2080 c).Nonempty \u2194 \u2203 a, \u2200 b \u2208 c, a \u2208 b := by\n  simp [nonempty_iff_ne_empty, sInter_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nc : Set (Set \u03b1)\n\u22a2 (\u22c2\u2080 c).Nonempty \u2194 \u2203 a, \u2200 b \u2208 c, a \u2208 b"}, {"line": "simp [nonempty_iff_ne_empty, sInter_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_eq_compl_sInter_compl (S : Set (Set \u03b1)) : \u22c3\u2080 S = (\u22c2\u2080 (compl '' S))\u1d9c := by\n  rw [\u2190 compl_compl (\u22c3\u2080 S)]\n  rw [compl_sUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 S = (\u22c2\u2080 (compl '' S))\u1d9c"}, {"line": "rw [\u2190 compl_compl (\u22c3\u2080 S)]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 (\u22c3\u2080 S)\u1d9c\u1d9c = (\u22c2\u2080 (compl '' S))\u1d9c"}, {"line": "rw [compl_sUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_sInter (S : Set (Set \u03b1)) : (\u22c2\u2080 S)\u1d9c = \u22c3\u2080 (compl '' S) := by\n  rw [sUnion_eq_compl_sInter_compl]\n  rw [compl_compl_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 (\u22c2\u2080 S)\u1d9c = \u22c3\u2080 (compl '' S)"}, {"line": "rw [sUnion_eq_compl_sInter_compl]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 (\u22c2\u2080 S)\u1d9c = (\u22c2\u2080 (compl '' (compl '' S)))\u1d9c"}, {"line": "rw [compl_compl_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_eq_compl_sUnion_compl (S : Set (Set \u03b1)) : \u22c2\u2080 S = (\u22c3\u2080 (compl '' S))\u1d9c := by\n  rw [\u2190 compl_compl (\u22c2\u2080 S)]\n  rw [compl_sInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 S = (\u22c3\u2080 (compl '' S))\u1d9c"}, {"line": "rw [\u2190 compl_compl (\u22c2\u2080 S)]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\n\u22a2 (\u22c2\u2080 S)\u1d9c\u1d9c = (\u22c3\u2080 (compl '' S))\u1d9c"}, {"line": "rw [compl_sInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_eq_range_sigma (s : \u03b1 \u2192 Set \u03b2) : \u22c3 i, s i = range fun a : \u03a3i, s i => a.2 := by\n  simp [Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s i = range fun a => \u2191a.snd"}, {"line": "simp [Set.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_eq_range_psigma (s : \u03b9 \u2192 Set \u03b2) : \u22c3 i, s i = range fun a : \u03a3'i, s i => a.2 := by\n  simp [Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, s i = range fun a => \u2191a.snd"}, {"line": "simp [Set.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_singleton_eq_range (f : \u03b1 \u2192 \u03b2) : \u22c3 x : \u03b1, {f x} = range f := by\n  ext x\n  simp [@eq_comm _ x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u22c3 x, {f x} = range f"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b2\n\u22a2 x \u2208 \u22c3 x, {f x} \u2194 x \u2208 range f"}, {"line": "simp [@eq_comm _ x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_insert_eq_range_union_iUnion {\u03b9 : Type*} (x : \u03b9 \u2192 \u03b2) (t : \u03b9 \u2192 Set \u03b2) :\n    \u22c3 i, insert (x i) (t i) = range x \u222a \u22c3 i, t i := by\n  simp_rw [\u2190 union_singleton, iUnion_union_distrib, union_comm, iUnion_singleton_eq_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\nx : \u03b9 \u2192 \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u22c3 i, insert (x i) (t i) = range x \u222a \u22c3 i, t i"}, {"line": "simp_rw [\u2190 union_singleton, iUnion_union_distrib, union_comm, iUnion_singleton_eq_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_of_singleton (\u03b1 : Type*) : (\u22c3 x, {x} : Set \u03b1) = univ := by simp [Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_12\n\u22a2 \u22c3 x, {x} = univ"}, {"line": "simp [Set.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_of_singleton_coe (s : Set \u03b1) : \u22c3 i : s, ({(i : \u03b1)} : Set \u03b1) = s := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 \u22c3 i, {\u2191i} = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_eq_biUnion {s : Set (Set \u03b1)} : \u22c3\u2080 s = \u22c3 (i : Set \u03b1) (_ : i \u2208 s), i := by\n  rw [\u2190 sUnion_image]\n  rw [image_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 s = \u22c3 i \u2208 s, i"}, {"line": "rw [\u2190 sUnion_image]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 s = \u22c3\u2080 ((fun i => i) '' s)"}, {"line": "rw [image_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_eq_biInter {s : Set (Set \u03b1)} : \u22c2\u2080 s = \u22c2 (i : Set \u03b1) (_ : i \u2208 s), i := by\n  rw [\u2190 sInter_image]\n  rw [image_id']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 s = \u22c2 i \u2208 s, i"}, {"line": "rw [\u2190 sInter_image]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 s = \u22c2\u2080 ((fun i => i) '' s)"}, {"line": "rw [image_id']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_eq_iUnion {s : Set (Set \u03b1)} : \u22c3\u2080 s = \u22c3 i : s, i := by\n  simp only [\u2190 sUnion_range]\n  simp only [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 s = \u22c3 i, \u2191i"}, {"line": "simp only [\u2190 sUnion_range]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c3\u2080 s = \u22c3\u2080 range Subtype.val"}, {"line": "simp only [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_eq_iInter {s : Set (Set \u03b1)} : \u22c2\u2080 s = \u22c2 i : s, i := by\n  simp only [\u2190 sInter_range]\n  simp only [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 s = \u22c2 i, \u2191i"}, {"line": "simp only [\u2190 sInter_range]", "tactic_state": "\u03b1 : Type u_1\ns : Set (Set \u03b1)\n\u22a2 \u22c2\u2080 s = \u22c2\u2080 range Subtype.val"}, {"line": "simp only [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_iUnion (s : \u03b9 \u2192 Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c3 x \u2208 \u22c3 i, s i, t x = \u22c3 (i) (x \u2208 s i), t x := by simp [@iUnion_comm _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b1\nt : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c3 x \u2208 \u22c3 i, s i, t x = \u22c3 i, \u22c3 x \u2208 s i, t x"}, {"line": "simp [@iUnion_comm _ \u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biInter_iUnion (s : \u03b9 \u2192 Set \u03b1) (t : \u03b1 \u2192 Set \u03b2) :\n    \u22c2 x \u2208 \u22c3 i, s i, t x = \u22c2 (i) (x \u2208 s i), t x := by simp [@iInter_comm _ \u03b9]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set \u03b1\nt : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c2 x \u2208 \u22c3 i, s i, t x = \u22c2 i, \u22c2 x \u2208 s i, t x"}, {"line": "simp [@iInter_comm _ \u03b9]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_iUnion (s : \u03b9 \u2192 Set (Set \u03b1)) : \u22c3\u2080 \u22c3 i, s i = \u22c3 i, \u22c3\u2080 s i := by\n  simp only [sUnion_eq_biUnion]\n  simp only [biUnion_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set (Set \u03b1)\n\u22a2 \u22c3\u2080 \u22c3 i, s i = \u22c3 i, \u22c3\u2080 s i"}, {"line": "simp only [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set (Set \u03b1)\n\u22a2 \u22c3 i \u2208 \u22c3 i, s i, i = \u22c3 i, \u22c3 i_1 \u2208 s i, i_1"}, {"line": "simp only [biUnion_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_iUnion (s : \u03b9 \u2192 Set (Set \u03b1)) : \u22c2\u2080 \u22c3 i, s i = \u22c2 i, \u22c2\u2080 s i := by\n  simp only [sInter_eq_biInter]\n  simp only [biInter_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set (Set \u03b1)\n\u22a2 \u22c2\u2080 \u22c3 i, s i = \u22c2 i, \u22c2\u2080 s i"}, {"line": "simp only [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\ns : \u03b9 \u2192 Set (Set \u03b1)\n\u22a2 \u22c2 i \u2208 \u22c3 i, s i, i = \u22c2 i, \u22c2 i_1 \u2208 s i, i_1"}, {"line": "simp only [biInter_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_distrib_iInter\u2082_left (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s \u222a \u22c2 (i) (j), t i j) = \u22c2 (i) (j), s \u222a t i j := by simp_rw [union_distrib_iInter_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 s \u222a \u22c2 i, \u22c2 j, t i j = \u22c2 i, \u22c2 j, s \u222a t i j"}, {"line": "simp_rw [union_distrib_iInter_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_distrib_iInter\u2082_right (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) \u222a t = \u22c2 (i) (j), s i j \u222a t := by simp_rw [union_distrib_iInter_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d : Nonempty \u03b9\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b1\n\u22a2 (\u22c2 i, \u22c2 j, s i j) \u222a t = \u22c2 i, \u22c2 j, s i j \u222a t"}, {"line": "simp_rw [union_distrib_iInter_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_def (i : Set \u03b1) (s : \u2200 a, Set (\u03c0 a)) : pi i s = \u22c2 a \u2208 i, eval a \u207b\u00b9' s a := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03c0 : \u03b1 \u2192 Type u_13\ni : Set \u03b1\ns : (a : \u03b1) \u2192 Set (\u03c0 a)\n\u22a2 i.pi s = \u22c2 a \u2208 i, eval a \u207b\u00b9' s a"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03c0 : \u03b1 \u2192 Type u_13\ni : Set \u03b1\ns : (a : \u03b1) \u2192 Set (\u03c0 a)\nx\u271d : (i : \u03b1) \u2192 \u03c0 i\n\u22a2 x\u271d \u2208 i.pi s \u2194 x\u271d \u2208 \u22c2 a \u2208 i, eval a \u207b\u00b9' s a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_univ_pi {\u03b9 : \u03b1 \u2192 Type*} (t : (a : \u03b1) \u2192 \u03b9 a \u2192 Set (\u03c0 a)) :\n    \u22c3 x : (a : \u03b1) \u2192 \u03b9 a, pi univ (fun a => t a (x a)) = pi univ fun a => \u22c3 j : \u03b9 a, t a j := by\n  ext\n  simp [Classical.skolem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03c0 : \u03b1 \u2192 Type u_13\n\u03b9 : \u03b1 \u2192 Type u_14\nt : (a : \u03b1) \u2192 \u03b9 a \u2192 Set (\u03c0 a)\n\u22a2 (\u22c3 x, univ.pi fun a => t a (x a)) = univ.pi fun a => \u22c3 j, t a j"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03c0 : \u03b1 \u2192 Type u_13\n\u03b9 : \u03b1 \u2192 Type u_14\nt : (a : \u03b1) \u2192 \u03b9 a \u2192 Set (\u03c0 a)\nx\u271d : (i : \u03b1) \u2192 \u03c0 i\n\u22a2 (x\u271d \u2208 \u22c3 x, univ.pi fun a => t a (x a)) \u2194 x\u271d \u2208 univ.pi fun a => \u22c3 j, t a j"}, {"line": "simp [Classical.skolem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem directedOn_sUnion {r} {S : Set (Set \u03b1)} (hd : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (h : \u2200 x \u2208 S, DirectedOn r x) : DirectedOn r (\u22c3\u2080 S) := by\n  rw [sUnion_eq_iUnion]\n  exact directedOn_iUnion (directedOn_iff_directed.mp hd) (fun i \u21a6 h i.1 i.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nh : \u2200 x \u2208 S, DirectedOn r x\n\u22a2 DirectedOn r (\u22c3\u2080 S)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nh : \u2200 x \u2208 S, DirectedOn r x\n\u22a2 DirectedOn r (\u22c3 i, \u2191i)"}, {"line": "exact directedOn_iUnion (directedOn_iff_directed.mp hd) (fun i \u21a6 h i.1 i.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_iUnion\u2082 {S : Set (Set \u03b1)} (hd : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 s \u2208 S, s.Pairwise r) : (\u22c3 s \u2208 S, s).Pairwise r := by\n  simp only [Set.Pairwise]\n  simp only [Set.mem_iUnion]\n  simp only [exists_prop]\n  simp only [forall_exists_index]\n  simp only [and_imp]\n  intro x S hS hx y T hT hy hne\n  obtain \u27e8U, hU, hSU, hTU\u27e9 := hd S hS T hT\n  exact h U hU (hSU hx) (hTU hy) hne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 (\u22c3 s \u2208 S, s).Pairwise r"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 \u2200 \u2983x : \u03b1\u2984, x \u2208 \u22c3 s \u2208 S, s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 \u22c3 s \u2208 S, s \u2192 x \u2260 y \u2192 r x y"}, {"line": "simp only [Set.mem_iUnion]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 \u2200 \u2983x : \u03b1\u2984, (\u2203 i, \u2203 (_ : i \u2208 S), x \u2208 i) \u2192 \u2200 \u2983y : \u03b1\u2984, (\u2203 i, \u2203 (_ : i \u2208 S), y \u2208 i) \u2192 x \u2260 y \u2192 r x y"}, {"line": "simp only [exists_prop]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 \u2200 \u2983x : \u03b1\u2984, (\u2203 i \u2208 S, x \u2208 i) \u2192 \u2200 \u2983y : \u03b1\u2984, (\u2203 i \u2208 S, y \u2208 i) \u2192 x \u2260 y \u2192 r x y"}, {"line": "simp only [forall_exists_index]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 \u2200 \u2983x : \u03b1\u2984 (x_1 : Set \u03b1), x_1 \u2208 S \u2227 x \u2208 x_1 \u2192 \u2200 \u2983y : \u03b1\u2984 (x_2 : Set \u03b1), x_2 \u2208 S \u2227 y \u2208 x_2 \u2192 x \u2260 y \u2192 r x y"}, {"line": "simp only [and_imp]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S, s.Pairwise r\n\u22a2 \u2200 \u2983x : \u03b1\u2984, \u2200 x_1 \u2208 S, x \u2208 x_1 \u2192 \u2200 \u2983y : \u03b1\u2984, \u2200 x_2 \u2208 S, y \u2208 x_2 \u2192 x \u2260 y \u2192 r x y"}, {"line": "intro x S hS hx y T hT hy hne", "tactic_state": "\u03b1 : Type u_1\nS\u271d : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S\u271d, s.Pairwise r\nx : \u03b1\nS : Set \u03b1\nhS : S \u2208 S\u271d\nhx : x \u2208 S\ny : \u03b1\nT : Set \u03b1\nhT : T \u2208 S\u271d\nhy : y \u2208 T\nhne : x \u2260 y\n\u22a2 r x y"}, {"line": "obtain \u27e8U, hU, hSU, hTU\u27e9 := hd S hS T hT", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\nS\u271d : Set (Set \u03b1)\nhd : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\u271d\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nh : \u2200 s \u2208 S\u271d, s.Pairwise r\nx : \u03b1\nS : Set \u03b1\nhS : S \u2208 S\u271d\nhx : x \u2208 S\ny : \u03b1\nT : Set \u03b1\nhT : T \u2208 S\u271d\nhy : y \u2208 T\nhne : x \u2260 y\nU : Set \u03b1\nhU : U \u2208 S\u271d\nhSU : S \u2286 U\nhTU : T \u2286 U\n\u22a2 r x y"}, {"line": "exact h U hU (hSU hx) (hTU hy) hne", "tactic_state": "No Goals!"}]}
{"declaration": "lemma biUnion_compl_eq_of_pairwise_disjoint_of_iUnion_eq_univ {\u03b9 : Type*} {Es : \u03b9 \u2192 Set \u03b1}\n    (Es_union : \u22c3 i, Es i = univ) (Es_disj : Pairwise fun i j \u21a6 Disjoint (Es i) (Es j))\n    (I : Set \u03b9) :\n    (\u22c3 i \u2208 I, Es i)\u1d9c = \u22c3 i \u2208 I\u1d9c, Es i := by\n  ext x\n  obtain \u27e8i, hix\u27e9 : \u2203 i, x \u2208 Es i := by simp [\u2190 mem_iUnion, Es_union]\n  have obs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J := by\n    refine fun J \u21a6 \u27e8?_, fun i_in_J \u21a6 by simpa only [mem_iUnion, exists_prop] using \u27e8i, i_in_J, hix\u27e9\u27e9\n    intro x_in_U\n    simp only [mem_iUnion] at x_in_U\n    simp only [exists_prop] at x_in_U\n    obtain \u27e8j, j_in_J, hjx\u27e9 := x_in_U\n    rwa [show i = j by by_contra i_ne_j; exact Disjoint.ne_of_mem (Es_disj i_ne_j) hix hjx rfl]\n  have obs' : \u2200 (J : Set \u03b9), x \u2208 (\u22c3 j \u2208 J, Es j)\u1d9c \u2194 i \u2209 J :=\n    fun J \u21a6 by simpa only [mem_compl_iff, not_iff_not] using obs J\n  rw [obs]\n  rw [obs']\n  rw [mem_compl_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\n\u22a2 (\u22c3 i \u2208 I, Es i)\u1d9c = \u22c3 i \u2208 I\u1d9c, Es i"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\n\u22a2 x \u2208 (\u22c3 i \u2208 I, Es i)\u1d9c \u2194 x \u2208 \u22c3 i \u2208 I\u1d9c, Es i"}, {"line": "obtain \u27e8i, hix\u27e9 : \u2203 i, x \u2208 Es i := by simp [\u2190 mem_iUnion, Es_union]", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\ni : \u03b9\nhix : x \u2208 Es i\n\u22a2 x \u2208 (\u22c3 i \u2208 I, Es i)\u1d9c \u2194 x \u2208 \u22c3 i \u2208 I\u1d9c, Es i"}, {"line": "have obs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J := sorry", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\ni : \u03b9\nhix : x \u2208 Es i\nobs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J\n\u22a2 x \u2208 (\u22c3 i \u2208 I, Es i)\u1d9c \u2194 x \u2208 \u22c3 i \u2208 I\u1d9c, Es i"}, {"line": "have obs' : \u2200 (J : Set \u03b9), x \u2208 (\u22c3 j \u2208 J, Es j)\u1d9c \u2194 i \u2209 J :=\n    fun J \u21a6 by simpa only [mem_compl_iff, not_iff_not] using obs J", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\ni : \u03b9\nhix : x \u2208 Es i\nobs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J\nobs' : \u2200 (J : Set \u03b9), x \u2208 (\u22c3 j \u2208 J, Es j)\u1d9c \u2194 i \u2209 J\n\u22a2 x \u2208 (\u22c3 i \u2208 I, Es i)\u1d9c \u2194 x \u2208 \u22c3 i \u2208 I\u1d9c, Es i"}, {"line": "rw [obs]", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\ni : \u03b9\nhix : x \u2208 Es i\nobs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J\nobs' : \u2200 (J : Set \u03b9), x \u2208 (\u22c3 j \u2208 J, Es j)\u1d9c \u2194 i \u2209 J\n\u22a2 x \u2208 (\u22c3 i \u2208 I, Es i)\u1d9c \u2194 i \u2208 I\u1d9c"}, {"line": "rw [obs']", "tactic_state": "case h.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_14\nEs : \u03b9 \u2192 Set \u03b1\nEs_union : \u22c3 i, Es i = univ\nEs_disj : Pairwise fun i j => Disjoint (Es i) (Es j)\nI : Set \u03b9\nx : \u03b1\ni : \u03b9\nhix : x \u2208 Es i\nobs : \u2200 (J : Set \u03b9), x \u2208 \u22c3 j \u2208 J, Es j \u2194 i \u2208 J\nobs' : \u2200 (J : Set \u03b9), x \u2208 (\u22c3 j \u2208 J, Es j)\u1d9c \u2194 i \u2209 J\n\u22a2 i \u2209 I \u2194 i \u2208 I\u1d9c"}, {"line": "rw [mem_compl_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nonempty_iInter_Iic_iff [Preorder \u03b1] {f : \u03b9 \u2192 \u03b1} :\n    (\u22c2 i, Iic (f i)).Nonempty \u2194 BddBelow (range f) := by\n  have : (\u22c2 (i : \u03b9), Iic (f i)) = lowerBounds (range f) := by\n    ext c; simp [lowerBounds]\n  simp [this, BddBelow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_12\ninst\u271d\u00b9 : PartialOrder \u03b9\ninst\u271d : Preorder \u03b1\nf : \u03b9 \u2192 \u03b1\n\u22a2 (\u22c2 i, Iic (f i)).Nonempty \u2194 BddBelow (range f)"}, {"line": "have : (\u22c2 (i : \u03b9), Iic (f i)) = lowerBounds (range f) := by\n    ext c; simp [lowerBounds]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_12\ninst\u271d\u00b9 : PartialOrder \u03b9\ninst\u271d : Preorder \u03b1\nf : \u03b9 \u2192 \u03b1\nthis : \u22c2 i, sorry = sorry\n\u22a2 (\u22c2 i, Iic (f i)).Nonempty \u2194 BddBelow (range f)"}, {"line": "simp [this, BddBelow]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_12\ninst\u271d\u00b9 : PartialOrder \u03b9\ninst\u271d : Preorder \u03b1\nf : \u03b9 \u2192 \u03b1\nthis : \u22c2 i, sorry = sorry\n\u22a2 (\u2203 x, \u2200 (i : \u03b9), x \u2264 f i) \u2194 (lowerBounds (range f)).Nonempty"}]}
{"declaration": "theorem Ici_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Ici (\u2a06 (i) (j), f i j) = \u22c2 (i) (j), Ici (f i j) := by\n  simp_rw [Ici_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : CompleteLattice \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Ici (\u2a06 i, \u2a06 j, f i j) = \u22c2 i, \u22c2 j, Ici (f i j)"}, {"line": "simp_rw [Ici_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Iic_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Iic (\u2a05 (i) (j), f i j) = \u22c2 (i) (j), Iic (f i j) := by\n  simp_rw [Iic_iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ninst\u271d\u00b9 : Nonempty \u03b9\ninst\u271d : CompleteLattice \u03b1\nf : (i : \u03b9) \u2192 \u03ba i \u2192 \u03b1\n\u22a2 Iic (\u2a05 i, \u2a05 j, f i j) = \u22c2 i, \u22c2 j, Iic (f i j)"}, {"line": "simp_rw [Iic_iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ici_sSup (s : Set \u03b1) : Ici (sSup s) = \u22c2 a \u2208 s, Ici a := by rw [sSup_eq_iSup, Ici_iSup\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 Ici (sSup s) = \u22c2 a \u2208 s, Ici a"}, {"line": "rw [sSup_eq_iSup, Ici_iSup\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Iic_sInf (s : Set \u03b1) : Iic (sInf s) = \u22c2 a \u2208 s, Iic a := by rw [sInf_eq_iInf, Iic_iInf\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b1\n\u22a2 Iic (sInf s) = \u22c2 a \u2208 s, Iic a"}, {"line": "rw [sInf_eq_iInf, Iic_iInf\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_diff_biUnion_subset (s\u2081 s\u2082 : Set \u03b1) :\n    ((\u22c3 x \u2208 s\u2081, t x) \\ \u22c3 x \u2208 s\u2082, t x) \u2286 \u22c3 x \u2208 s\u2081 \\ s\u2082, t x := by\n  simp only [diff_subset_iff]\n  simp only [\u2190 biUnion_union]\n  apply biUnion_subset_biUnion_left\n  rw [union_diff_self]\n  apply subset_union_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nt : \u03b1 \u2192 Set \u03b2\ns\u2081 s\u2082 : Set \u03b1\n\u22a2 (\u22c3 x \u2208 s\u2081, t x) \\ \u22c3 x \u2208 s\u2082, t x \u2286 \u22c3 x \u2208 s\u2081 \\ s\u2082, t x"}, {"line": "simp only [diff_subset_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nt : \u03b1 \u2192 Set \u03b2\ns\u2081 s\u2082 : Set \u03b1\n\u22a2 \u22c3 x \u2208 s\u2081, t x \u2286 (\u22c3 x \u2208 s\u2082, t x) \u222a \u22c3 x \u2208 s\u2081 \\ s\u2082, t x"}, {"line": "simp only [\u2190 biUnion_union]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nt : \u03b1 \u2192 Set \u03b2\ns\u2081 s\u2082 : Set \u03b1\n\u22a2 \u22c3 x \u2208 s\u2081, t x \u2286 \u22c3 x \u2208 s\u2082 \u222a s\u2081 \\ s\u2082, t x"}, {"line": "apply biUnion_subset_biUnion_left", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nt : \u03b1 \u2192 Set \u03b2\ns\u2081 s\u2082 : Set \u03b1\n\u22a2 s\u2081 \u2286 s\u2082 \u222a s\u2081 \\ s\u2082"}, {"line": "rw [union_diff_self]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b1\nt : \u03b1 \u2192 Set \u03b2\ns\u2081 s\u2082 : Set \u03b1\n\u22a2 s\u2081 \u2286 s\u2082 \u222a s\u2081"}, {"line": "apply subset_union_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_iUnion (t : \u03b9 \u2192 Set \u03b2) : sSup (\u22c3 i, t i) = \u2a06 i, sSup (t i) := by\n  simp_rw [sSup_eq_iSup, iSup_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_12\ninst\u271d\u00b9 : PartialOrder \u03b9\ninst\u271d : CompleteLattice \u03b2\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 sSup (\u22c3 i, t i) = \u2a06 i, sSup (t i)"}, {"line": "simp_rw [sSup_eq_iSup, iSup_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_sUnion (s : Set (Set \u03b2)) : sSup (\u22c3\u2080 s) = \u2a06 t \u2208 s, sSup t := by\n  simp only [sUnion_eq_biUnion]\n  simp only [sSup_eq_iSup]\n  simp only [iSup_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b2\ns : Set (Set \u03b2)\n\u22a2 sSup (\u22c3\u2080 s) = \u2a06 t \u2208 s, sSup t"}, {"line": "simp only [sUnion_eq_biUnion]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b2\ns : Set (Set \u03b2)\n\u22a2 sSup (\u22c3 i \u2208 s, i) = \u2a06 t \u2208 s, sSup t"}, {"line": "simp only [sSup_eq_iSup]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : CompleteLattice \u03b2\ns : Set (Set \u03b2)\n\u22a2 \u2a06 a \u2208 \u22c3 i \u2208 s, i, a = \u2a06 t \u2208 s, \u2a06 a \u2208 t, a"}, {"line": "simp only [iSup_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iSup_sUnion (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) :\n    (\u2a06 x \u2208 \u22c3\u2080 S, f x) = \u2a06 (s \u2208 S) (x \u2208 s), f x := by\n  rw [sUnion_eq_iUnion]\n  rw [iSup_iUnion]\n  rw [\u2190 iSup_subtype'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 x \u2208 \u22c3\u2080 S, f x = \u2a06 s \u2208 S, \u2a06 x \u2208 s, f x"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 x \u2208 \u22c3 i, \u2191i, f x = \u2a06 s \u2208 S, \u2a06 x \u2208 s, f x"}, {"line": "rw [iSup_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a06 i, \u2a06 a \u2208 \u2191i, f a = \u2a06 s \u2208 S, \u2a06 x \u2208 s, f x"}, {"line": "rw [\u2190 iSup_subtype'']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iInf_sUnion (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) :\n    (\u2a05 x \u2208 \u22c3\u2080 S, f x) = \u2a05 (s \u2208 S) (x \u2208 s), f x := by\n  rw [sUnion_eq_iUnion]\n  rw [iInf_iUnion]\n  rw [\u2190 iInf_subtype'']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a05 x \u2208 \u22c3\u2080 S, f x = \u2a05 s \u2208 S, \u2a05 x \u2208 s, f x"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a05 x \u2208 \u22c3 i, \u2191i, f x = \u2a05 s \u2208 S, \u2a05 x \u2208 s, f x"}, {"line": "rw [iInf_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : CompleteLattice \u03b2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u2a05 i, \u2a05 a \u2208 \u2191i, f a = \u2a05 s \u2208 S, \u2a05 x \u2208 s, f x"}, {"line": "rw [\u2190 iInf_subtype'']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_sUnion {S : Set (Set \u03b1)} {p : \u03b1 \u2192 Prop} :\n    (\u2200 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2200 s \u2208 S, \u2200 x \u2208 s, p x := by\n  simp_rw [\u2190 iInf_Prop_eq, iInf_sUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nS : Set (Set \u03b1)\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2200 s \u2208 S, \u2200 x \u2208 s, p x"}, {"line": "simp_rw [\u2190 iInf_Prop_eq, iInf_sUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_sUnion {S : Set (Set \u03b1)} {p : \u03b1 \u2192 Prop} :\n    (\u2203 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2203 s \u2208 S, \u2203 x \u2208 s, p x := by\n  simp_rw [\u2190 exists_prop, \u2190 iSup_Prop_eq, iSup_sUnion]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice.lean", "context": {"open": ["Function Set", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba \u03ba\u2081 \u03ba\u2082 : \u03b9 \u2192 Sort*} {\u03ba' : \u03b9' \u2192 Sort*}", "[Nonempty \u03b9] {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1}", "(p : \u03b9 \u2192 Prop) [DecidablePred p]", "{s : \u03b9 \u2192 Set \u03b1}", "{\u03b9 : Type*} [PartialOrder \u03b9] (s : \u03b9 \u2192 Set \u03b1) (i : \u03b9)", "{\u03c0 : \u03b1 \u2192 Type*}", "{s t : Set \u03b1}", "[CompleteLattice \u03b1]", "(t : \u03b1 \u2192 Set \u03b2)", "[CompleteLattice \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CompleteLattice \u03b1\nS : Set (Set \u03b1)\np : \u03b1 \u2192 Prop\n\u22a2 (\u2203 x \u2208 \u22c3\u2080 S, p x) \u2194 \u2203 s \u2208 S, \u2203 x \u2208 s, p x"}, {"line": "simp_rw [\u2190 exists_prop, \u2190 iSup_Prop_eq, iSup_sUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.MonotoneOn.congr (h\u2081 : MonotoneOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) : MonotoneOn f\u2082 s := by\n  intro a ha b hb hab\n  rw [\u2190 h ha]\n  rw [\u2190 h hb]\n  exact h\u2081 ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Monotone.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\n\u22a2 MonotoneOn f\u2082 s"}, {"line": "intro a ha b hb hab", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2082 a \u2264 f\u2082 b"}, {"line": "rw [\u2190 h ha]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2081 a \u2264 f\u2082 b"}, {"line": "rw [\u2190 h hb]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : MonotoneOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a \u2264 b\n\u22a2 f\u2081 a \u2264 f\u2081 b"}, {"line": "exact h\u2081 ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.StrictMonoOn.congr (h\u2081 : StrictMonoOn f\u2081 s) (h : s.EqOn f\u2081 f\u2082) :\n    StrictMonoOn f\u2082 s := by\n  intro a ha b hb hab\n  rw [\u2190 h ha]\n  rw [\u2190 h hb]\n  exact h\u2081 ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Monotone.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : StrictMonoOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\n\u22a2 StrictMonoOn f\u2082 s"}, {"line": "intro a ha b hb hab", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : StrictMonoOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a < b\n\u22a2 f\u2082 a < f\u2082 b"}, {"line": "rw [\u2190 h ha]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : StrictMonoOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a < b\n\u22a2 f\u2081 a < f\u2082 b"}, {"line": "rw [\u2190 h hb]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nf\u2081 f\u2082 : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nh\u2081 : StrictMonoOn f\u2081 s\nh : Set.EqOn f\u2081 f\u2082 s\na : \u03b1\nha : a \u2208 s\nb : \u03b1\nhb : b \u2208 s\nhab : a < b\n\u22a2 f\u2081 a < f\u2081 b"}, {"line": "exact h\u2081 ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma MonotoneOn_insert_iff {a : \u03b1} :\n    MonotoneOn f (insert a s) \u2194\n      (\u2200 b \u2208 s, b \u2264 a \u2192 f b \u2264 f a) \u2227 (\u2200 b \u2208 s, a \u2264 b \u2192 f a \u2264 f b) \u2227 MonotoneOn f s := by\n  simp [MonotoneOn, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Monotone.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]", "{s s\u2082 : Set \u03b1} {f : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\na : \u03b1\n\u22a2 MonotoneOn f (insert a s) \u2194 (\u2200 b \u2208 s, b \u2264 a \u2192 f b \u2264 f a) \u2227 (\u2200 b \u2208 s, a \u2264 b \u2192 f a \u2264 f b) \u2227 MonotoneOn f s"}, {"line": "simp [MonotoneOn, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMono_restrict [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    StrictMono (s.restrict f) \u2194 StrictMonoOn f s := by simp [Set.restrict, StrictMono, StrictMonoOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Monotone.lean", "context": {"open": ["Equiv Equiv.Perm Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]", "{s s\u2082 : Set \u03b1} {f : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 StrictMono (s.restrict f) \u2194 StrictMonoOn f s"}, {"line": "simp [Set.restrict, StrictMono, StrictMonoOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMonoOn_insert_iff [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} :\n    StrictMonoOn f (insert a s) \u2194\n       (\u2200 b \u2208 s, b < a \u2192 f b < f a) \u2227 (\u2200 b \u2208 s, a < b \u2192 f a < f b) \u2227 StrictMonoOn f s := by\n  simp [StrictMonoOn, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Monotone.lean", "context": {"open": ["Equiv Equiv.Perm Function", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]", "{s s\u2082 : Set \u03b1} {f : \u03b1 \u2192 \u03b2} [Preorder \u03b1] [Preorder \u03b2]", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2077 : Preorder \u03b1\ninst\u271d\u2076 : Preorder \u03b2\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : Preorder \u03b2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\na : \u03b1\n\u22a2 StrictMonoOn f (insert a s) \u2194 (\u2200 b \u2208 s, b < a \u2192 f b < f a) \u2227 (\u2200 b \u2208 s, a < b \u2192 f a < f b) \u2227 StrictMonoOn f s"}, {"line": "simp [StrictMonoOn, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piecewise_empty [\u2200 i : \u03b1, Decidable (i \u2208 (\u2205 : Set \u03b1))] : piecewise \u2205 f g = g := by\n  ext i\n  simp [piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ng : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 \u2205)\n\u22a2 sorry = g"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ng : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 \u2205)\ni : \u03b1\n\u22a2 sorry i = g i"}, {"line": "simp [piecewise]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ng : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 \u2205)\ni : \u03b1\n\u22a2 sorry () i = g i"}]}
{"declaration": "theorem piecewise_univ [\u2200 i : \u03b1, Decidable (i \u2208 (Set.univ : Set \u03b1))] :\n    piecewise Set.univ f g = f := by\n  ext i\n  simp [piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\nf : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 Set.univ)\n\u22a2 sorry = f"}, {"line": "ext i", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\nf : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 Set.univ)\ni : \u03b1\n\u22a2 sorry i = f i"}, {"line": "simp [piecewise]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\nf : (i : \u03b1) \u2192 \u03b4 i\nx\u271d : Sort u_8\npiecewise : x\u271d\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 Set.univ)\ni : \u03b1\n\u22a2 sorry () i = f i"}]}
{"declaration": "theorem piecewise_insert_self {j : \u03b1} [\u2200 i, Decidable (i \u2208 insert j s)] :\n    (insert j s).piecewise f g j = f j := by simp [piecewise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ns : Set \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\nj : \u03b1\ninst\u271d : (i : \u03b1) \u2192 Decidable (i \u2208 insert j s)\n\u22a2 (insert j s).piecewise f g j = f j"}, {"line": "simp [piecewise]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piecewise_singleton (x : \u03b1) [\u2200 y, Decidable (y \u2208 ({x} : Set \u03b1))] [DecidableEq \u03b1]\n    (f g : \u03b1 \u2192 \u03b2) : piecewise {x} f g = Function.update g x (f x) := by\n  ext y\n  by_cases hy : y = x\n  \u00b7 subst y\n    simp\n  \u00b7 simp [hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\npiecewise : x\u271d\nx : \u03b1\ninst\u271d\u00b9 : (y : \u03b1) \u2192 Decidable (y \u2208 {x})\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\n\u22a2 sorry = update g x (f x)"}, {"line": "ext y", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\npiecewise : x\u271d\nx : \u03b1\ninst\u271d\u00b9 : (y : \u03b1) \u2192 Decidable (y \u2208 {x})\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ny : \u03b1\n\u22a2 sorry y = update g x (f x) y"}, {"line": "by_cases hy : y = x", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\npiecewise : x\u271d\nx : \u03b1\ninst\u271d\u00b9 : (y : \u03b1) \u2192 Decidable (y \u2208 {x})\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ny : \u03b1\nhy : y = x\n\u22a2 sorry y = update g x (f x) y\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\npiecewise : x\u271d\nx : \u03b1\ninst\u271d\u00b9 : (y : \u03b1) \u2192 Decidable (y \u2208 {x})\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ny : \u03b1\nhy : \u00acy = x\n\u22a2 sorry y = update g x (f x) y"}, {"line": "\u00b7 subst y\n    simp", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\npiecewise : x\u271d\nx : \u03b1\ninst\u271d\u00b9 : (y : \u03b1) \u2192 Decidable (y \u2208 {x})\ninst\u271d : DecidableEq \u03b1\nf g : \u03b1 \u2192 \u03b2\ny : \u03b1\nhy : \u00acy = x\n\u22a2 sorry y = update g x (f x) y"}, {"line": "\u00b7 simp [hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piecewise_mono {\u03b4 : \u03b1 \u2192 Type*} [\u2200 i, Preorder (\u03b4 i)] {s : Set \u03b1}\n    [\u2200 j, Decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, \u03b4 i} (h\u2081 : \u2200 i \u2208 s, f\u2081 i \u2264 g\u2081 i)\n    (h\u2082 : \u2200 i \u2209 s, f\u2082 i \u2264 g\u2082 i) : s.piecewise f\u2081 f\u2082 \u2264 s.piecewise g\u2081 g\u2082 := by\n  apply piecewise_le <;> intros <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Type u_8\ninst\u271d\u00b9 : (i : \u03b1) \u2192 Preorder (\u03b4 i)\ns : Set \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\nf\u2081 f\u2082 g\u2081 g\u2082 : (i : \u03b1) \u2192 \u03b4 i\nh\u2081 : \u2200 i \u2208 s, f\u2081 i \u2264 g\u2081 i\nh\u2082 : \u2200 i \u2209 s, f\u2082 i \u2264 g\u2082 i\n\u22a2 s.piecewise f\u2081 f\u2082 \u2264 s.piecewise g\u2081 g\u2082"}, {"line": "apply piecewise_le <;> intros <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma piecewise_comp (f g : \u03b1 \u2192 \u03b3) (h : \u03b2 \u2192 \u03b1) :\n    letI : DecidablePred (\u00b7 \u2208 h \u207b\u00b9' s) := @instDecidablePredComp _ (\u00b7 \u2208 s) _ h _;\n    (s.piecewise f g) \u2218 h = (h\u207b\u00b9' s).piecewise (f \u2218 h) (g \u2218 h) := by\n  ext x\n  by_cases hx : h x \u2208 s <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\nf g : \u03b1 \u2192 \u03b3\nh : \u03b2 \u2192 \u03b1\n\u22a2 s.piecewise f g \u2218 h = (h \u207b\u00b9' s).piecewise (f \u2218 h) (g \u2218 h)"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set \u03b1\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\nf g : \u03b1 \u2192 \u03b3\nh : \u03b2 \u2192 \u03b1\nx : \u03b2\n\u22a2 (s.piecewise f g \u2218 h) x = (h \u207b\u00b9' s).piecewise (f \u2218 h) (g \u2218 h) x"}, {"line": "by_cases hx : h x \u2208 s <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem EqOn.piecewise_ite' {f f' g : \u03b1 \u2192 \u03b2} {t t'} (h : EqOn f g (t \u2229 s))\n    (h' : EqOn f' g (t' \u2229 s\u1d9c)) : EqOn (s.piecewise f f') g (s.ite t t') := by\n  simp [eqOn_piecewise, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\nEqOn : x\u271d\nf f' g : \u03b1 \u2192 \u03b2\nt : ?m.1482 _fvar.157 _fvar.163 _fvar.169\nt' : ?m.1483 _fvar.157 _fvar.163 _fvar.169\nh : sorry\nh' : sorry\n\u22a2 sorry"}, {"line": "simp [eqOn_piecewise, *]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_8\nEqOn : x\u271d\nf f' g : \u03b1 \u2192 \u03b2\nt : ?m.1482 _fvar.157 _fvar.163 _fvar.169\nt' : ?m.1483 _fvar.157 _fvar.163 _fvar.169\nh : sorry\nh' : sorry\n\u22a2 sorry ()"}]}
{"declaration": "theorem apply_piecewise {\u03b4' : \u03b1 \u2192 Sort*} (h : \u2200 i, \u03b4 i \u2192 \u03b4' i) {x : \u03b1} :\n    h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x := by\n  by_cases hx : x \u2208 s <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ns : Set \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\n\u03b4' : \u03b1 \u2192 Sort u_8\nh : (i : \u03b1) \u2192 \u03b4 i \u2192 \u03b4' i\nx : \u03b1\n\u22a2 h x (s.piecewise f g x) = s.piecewise (fun x => h x (f x)) (fun x => h x (g x)) x"}, {"line": "by_cases hx : x \u2208 s <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply_piecewise\u2082 {\u03b4' \u03b4'' : \u03b1 \u2192 Sort*} (f' g' : \u2200 i, \u03b4' i) (h : \u2200 i, \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i)\n    {x : \u03b1} :\n    h x (s.piecewise f g x) (s.piecewise f' g' x) =\n      s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x := by\n  by_cases hx : x \u2208 s <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ns : Set \u03b1\nf g : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\n\u03b4' : \u03b1 \u2192 Sort u_8\n\u03b4'' : \u03b1 \u2192 Sort u_9\nf' g' : (i : \u03b1) \u2192 \u03b4' i\nh : (i : \u03b1) \u2192 \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i\nx : \u03b1\n\u22a2 h x (s.piecewise f g x) (s.piecewise f' g' x) = s.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x"}, {"line": "by_cases hx : x \u2208 s <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piecewise_same : s.piecewise f f = f := by\n  ext x\n  by_cases hx : x \u2208 s <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ns : Set \u03b1\nf : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\n\u22a2 s.piecewise f f = f"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b4 : \u03b1 \u2192 Sort u_7\ns : Set \u03b1\nf : (i : \u03b1) \u2192 \u03b4 i\ninst\u271d : (j : \u03b1) \u2192 Decidable (j \u2208 s)\nx : \u03b1\n\u22a2 s.piecewise f f x = f x"}, {"line": "by_cases hx : x \u2208 s <;> simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_piecewise {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} (s : Set \u03b9) (t t' : \u2200 i, Set (\u03b1 i))\n    [\u2200 x, Decidable (x \u2208 s)] : pi univ (s.piecewise t t') = pi s t \u2229 pi s\u1d9c t' := by\n  simp [compl_eq_univ_diff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_10\npi : x\u271d\n\u03b9 : Type u_8\n\u03b1 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\nt t' : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (x : \u03b9) \u2192 Decidable (x \u2208 s)\n\u22a2 sorry = sorry \u2229 sorry"}, {"line": "simp [compl_eq_univ_diff]", "tactic_state": "x\u271d : Sort u_10\npi : x\u271d\n\u03b9 : Type u_8\n\u03b1 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\nt t' : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (x : \u03b9) \u2192 Decidable (x \u2208 s)\n\u22a2 sorry () = sorry () \u2229 sorry ()"}]}
{"declaration": "theorem univ_pi_piecewise_univ {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i))\n    [\u2200 x, Decidable (x \u2208 s)] : pi univ (s.piecewise t fun _ => univ) = pi s t := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Piecewise.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{\u03b4 : \u03b1 \u2192 Sort*} (s : Set \u03b1) (f g : \u2200 i, \u03b4 i)", "[\u2200 j, Decidable (j \u2208 s)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_10\npi : x\u271d\n\u03b9 : Type u_8\n\u03b1 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (x : \u03b9) \u2192 Decidable (x \u2208 s)\n\u22a2 sorry = sorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_10\npi : x\u271d\n\u03b9 : Type u_8\n\u03b1 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (x : \u03b9) \u2192 Decidable (x \u2208 s)\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem exists_prod_set {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} : (\u2203 x \u2208 s \u00d7\u02e2 t, p x) \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, p (x, y) := by\n  simp [and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\np : \u03b1 \u00d7 \u03b2 \u2192 Prop\n\u22a2 (\u2203 x \u2208 s \u00d7\u02e2 t, p x) \u2194 \u2203 x \u2208 s, \u2203 y \u2208 t, p (x, y)"}, {"line": "simp [and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_empty : s \u00d7\u02e2 (\u2205 : Set \u03b2) = \u2205 := by\n  ext\n  exact iff_of_eq (and_false _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\n\u22a2 s \u00d7\u02e2 \u2205 = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 s \u00d7\u02e2 \u2205 \u2194 x\u271d \u2208 \u2205"}, {"line": "exact iff_of_eq (and_false _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_prod : (\u2205 : Set \u03b1) \u00d7\u02e2 t = \u2205 := by\n  ext\n  exact iff_of_eq (false_and _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\n\u22a2 \u2205 \u00d7\u02e2 t = \u2205"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 \u2205 \u00d7\u02e2 t \u2194 x\u271d \u2208 \u2205"}, {"line": "exact iff_of_eq (false_and _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_prod : ({a} : Set \u03b1) \u00d7\u02e2 t = Prod.mk a '' t := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\na : \u03b1\n\u22a2 {a} \u00d7\u02e2 t = Prod.mk a '' t"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\na x : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 {a} \u00d7\u02e2 t \u2194 (x, y) \u2208 Prod.mk a '' t"}, {"line": "simp [and_left_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_singleton : s \u00d7\u02e2 ({b} : Set \u03b2) = (fun a => (a, b)) '' s := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nb : \u03b2\n\u22a2 s \u00d7\u02e2 {b} = (fun a => (a, b)) '' s"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nb : \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 {b} \u2194 (x, y) \u2208 (fun a => (a, b)) '' s"}, {"line": "simp [and_left_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_prod : (s\u2081 \u222a s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u222a s\u2082 \u00d7\u02e2 t := by\n  ext \u27e8x, y\u27e9\n  simp [or_and_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\n\u22a2 (s\u2081 \u222a s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u222a s\u2082 \u00d7\u02e2 t"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Set \u03b1\nt : Set \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 (s\u2081 \u222a s\u2082) \u00d7\u02e2 t \u2194 (x, y) \u2208 s\u2081 \u00d7\u02e2 t \u222a s\u2082 \u00d7\u02e2 t"}, {"line": "simp [or_and_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_union : s \u00d7\u02e2 (t\u2081 \u222a t\u2082) = s \u00d7\u02e2 t\u2081 \u222a s \u00d7\u02e2 t\u2082 := by\n  ext \u27e8x, y\u27e9\n  simp [and_or_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt\u2081 t\u2082 : Set \u03b2\n\u22a2 s \u00d7\u02e2 (t\u2081 \u222a t\u2082) = s \u00d7\u02e2 t\u2081 \u222a s \u00d7\u02e2 t\u2082"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt\u2081 t\u2082 : Set \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s \u00d7\u02e2 (t\u2081 \u222a t\u2082) \u2194 (x, y) \u2208 s \u00d7\u02e2 t\u2081 \u222a s \u00d7\u02e2 t\u2082"}, {"line": "simp [and_or_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_inter_prod : s\u2081 \u00d7\u02e2 t\u2081 \u2229 s\u2082 \u00d7\u02e2 t\u2082 = (s\u2081 \u2229 s\u2082) \u00d7\u02e2 (t\u2081 \u2229 t\u2082) := by\n  ext \u27e8x, y\u27e9\n  simp [and_assoc, and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Set \u03b1\nt\u2081 t\u2082 : Set \u03b2\n\u22a2 s\u2081 \u00d7\u02e2 t\u2081 \u2229 s\u2082 \u00d7\u02e2 t\u2082 = (s\u2081 \u2229 s\u2082) \u00d7\u02e2 (t\u2081 \u2229 t\u2082)"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns\u2081 s\u2082 : Set \u03b1\nt\u2081 t\u2082 : Set \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 (x, y) \u2208 s\u2081 \u00d7\u02e2 t\u2081 \u2229 s\u2082 \u00d7\u02e2 t\u2082 \u2194 (x, y) \u2208 (s\u2081 \u2229 s\u2082) \u00d7\u02e2 (t\u2081 \u2229 t\u2082)"}, {"line": "simp [and_assoc, and_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prodMap_image_prod (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) (s : Set \u03b1) (t : Set \u03b3) :\n    (Prod.map f g) '' (s \u00d7\u02e2 t) = (f '' s) \u00d7\u02e2 (g '' t) := by\n  ext\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b4\ns : Set \u03b1\nt : Set \u03b3\n\u22a2 Prod.map f g '' s \u00d7\u02e2 t = (f '' s) \u00d7\u02e2 (g '' t)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\nf : \u03b1 \u2192 \u03b2\ng : \u03b3 \u2192 \u03b4\ns : Set \u03b1\nt : Set \u03b3\nx\u271d : \u03b2 \u00d7 \u03b4\n\u22a2 x\u271d \u2208 Prod.map f g '' s \u00d7\u02e2 t \u2194 x\u271d \u2208 (f '' s) \u00d7\u02e2 (g '' t)"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_left (hb : b \u2208 t) : (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = s := by\n  ext a\n  simp [hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2208 t\n\u22a2 (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = s"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2208 t\na : \u03b1\n\u22a2 a \u2208 (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t \u2194 a \u2208 s"}, {"line": "simp [hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_right (ha : a \u2208 s) : Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = t := by\n  ext b\n  simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 s\n\u22a2 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = t"}, {"line": "ext b", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 s\nb : \u03b2\n\u22a2 b \u2208 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t \u2194 b \u2208 t"}, {"line": "simp [ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_left_eq_empty (hb : b \u2209 t) : (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = \u2205 := by\n  ext a\n  simp [hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2209 t\n\u22a2 (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = \u2205"}, {"line": "ext a", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2209 t\na : \u03b1\n\u22a2 a \u2208 (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t \u2194 a \u2208 \u2205"}, {"line": "simp [hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_right_eq_empty (ha : a \u2209 s) : Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = \u2205 := by\n  ext b\n  simp [ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2209 s\n\u22a2 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = \u2205"}, {"line": "ext b", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2209 s\nb : \u03b2\n\u22a2 b \u2208 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t \u2194 b \u2208 \u2205"}, {"line": "simp [ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_left_eq_if [DecidablePred (\u00b7 \u2208 t)] :\n    (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then s else \u2205 := by split_ifs with h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\ninst\u271d : DecidablePred fun x => x \u2208 t\n\u22a2 (fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then s else \u2205"}, {"line": "split_ifs with h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_prod_right_eq_if [DecidablePred (\u00b7 \u2208 s)] :\n    Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then t else \u2205 := by split_ifs with h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 Prod.mk a \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then t else \u2205"}, {"line": "split_ifs with h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_swap_prod (s : Set \u03b1) (t : Set \u03b2) : Prod.swap \u207b\u00b9' s \u00d7\u02e2 t = t \u00d7\u02e2 s := by\n  ext \u27e8x, y\u27e9\n  simp [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 Prod.swap \u207b\u00b9' s \u00d7\u02e2 t = t \u00d7\u02e2 s"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nx : \u03b2\ny : \u03b1\n\u22a2 (x, y) \u2208 Prod.swap \u207b\u00b9' s \u00d7\u02e2 t \u2194 (x, y) \u2208 t \u00d7\u02e2 s"}, {"line": "simp [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_prodMk_subset_prod {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} :\n    (fun x => (f x, g x)) '' s \u2286 (f '' s) \u00d7\u02e2 (g '' s) := by\n  rintro _ \u27e8x, hx, rfl\u27e9\n  exact mk_mem_prod (mem_image_of_mem f hx) (mem_image_of_mem g hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ns : Set \u03b1\n\u22a2 (fun x => (f x, g x)) '' s \u2286 (f '' s) \u00d7\u02e2 (g '' s)"}, {"line": "rintro _ \u27e8x, hx, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2\ng : \u03b1 \u2192 \u03b3\ns : Set \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 (fun x => (f x, g x)) x \u2208 (f '' s) \u00d7\u02e2 (g '' s)"}, {"line": "exact mk_mem_prod (mem_image_of_mem f hx) (mem_image_of_mem g hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_prodMk_subset_prod_left (hb : b \u2208 t) : (fun a => (a, b)) '' s \u2286 s \u00d7\u02e2 t := by\n  rintro _ \u27e8a, ha, rfl\u27e9\n  exact \u27e8ha, hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2208 t\n\u22a2 (fun a => (a, b)) '' s \u2286 s \u00d7\u02e2 t"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\nb : \u03b2\nhb : b \u2208 t\na : \u03b1\nha : a \u2208 s\n\u22a2 (fun a => (a, b)) a \u2208 s \u00d7\u02e2 t"}, {"line": "exact \u27e8ha, hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_prodMk_subset_prod_right (ha : a \u2208 s) : Prod.mk a '' t \u2286 s \u00d7\u02e2 t := by\n  rintro _ \u27e8b, hb, rfl\u27e9\n  exact \u27e8ha, hb\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 s\n\u22a2 Prod.mk a '' t \u2286 s \u00d7\u02e2 t"}, {"line": "rintro _ \u27e8b, hb, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\na : \u03b1\nha : a \u2208 s\nb : \u03b2\nhb : b \u2208 t\n\u22a2 (a, b) \u2208 s \u00d7\u02e2 t"}, {"line": "exact \u27e8ha, hb\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_diff_prod : s \u00d7\u02e2 t \\ s\u2081 \u00d7\u02e2 t\u2081 = s \u00d7\u02e2 (t \\ t\u2081) \u222a (s \\ s\u2081) \u00d7\u02e2 t := by\n  ext x\n  by_cases h\u2081 : x.1 \u2208 s\u2081 <;> by_cases h\u2082 : x.2 \u2208 t\u2081 <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 : Set \u03b1\nt t\u2081 : Set \u03b2\n\u22a2 s \u00d7\u02e2 t \\ s\u2081 \u00d7\u02e2 t\u2081 = s \u00d7\u02e2 (t \\ t\u2081) \u222a (s \\ s\u2081) \u00d7\u02e2 t"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ns s\u2081 : Set \u03b1\nt t\u2081 : Set \u03b2\nx : \u03b1 \u00d7 \u03b2\n\u22a2 x \u2208 s \u00d7\u02e2 t \\ s\u2081 \u00d7\u02e2 t\u2081 \u2194 x \u2208 s \u00d7\u02e2 (t \\ t\u2081) \u222a (s \\ s\u2081) \u00d7\u02e2 t"}, {"line": "by_cases h\u2081 : x.1 \u2208 s\u2081 <;> by_cases h\u2082 : x.2 \u2208 t\u2081 <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_coe_coe_diagonal (s : Set \u03b1) :\n    Prod.map (fun x : s => (x : \u03b1)) (fun x : s => (x : \u03b1)) \u207b\u00b9' diagonal \u03b1 = diagonal s := by\n  ext \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9\n  simp [Set.diagonal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nx\u271d : Sort u_6\ndiagonal : x\u271d\ns : Set \u03b1\n\u22a2 (Prod.map (fun x => \u2191x) fun x => \u2191x) \u207b\u00b9' sorry = sorry"}, {"line": "ext \u27e8\u27e8x, hx\u27e9, \u27e8y, hy\u27e9\u27e9", "tactic_state": "case h.mk.mk.mk\n\u03b1 : Type u_5\nx\u271d : Sort u_6\ndiagonal : x\u271d\ns : Set \u03b1\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\n\u22a2 (\u27e8x, hx\u27e9, \u27e8y, hy\u27e9) \u2208 (Prod.map (fun x => \u2191x) fun x => \u2191x) \u207b\u00b9' sorry \u2194 (\u27e8x, hx\u27e9, \u27e8y, hy\u27e9) \u2208 sorry"}, {"line": "simp [Set.diagonal]", "tactic_state": "case h.mk.mk.mk\n\u03b1 : Type u_5\nx\u271d : Sort u_6\ndiagonal : x\u271d\ns : Set \u03b1\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\n\u22a2 (x, y) \u2208 sorry () \u2194 (\u27e8x, hx\u27e9, \u27e8y, hy\u27e9) \u2208 sorry ()"}]}
{"declaration": "theorem range_toPullbackDiag (f : X \u2192 Y) : range (toPullbackDiag f) = pullbackDiagonal f := by\n  rw [\u2190 image_univ]\n  rw [image_toPullbackDiag]\n  rw [univ_prod_univ]\n  rw [preimage_univ]\n  rw [inter_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_6\nY : Sort u_7\nf : X \u2192 Y\n\u22a2 range (toPullbackDiag f) = pullbackDiagonal f"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "X : Type u_6\nY : Sort u_7\nf : X \u2192 Y\n\u22a2 toPullbackDiag f '' univ = pullbackDiagonal f"}, {"line": "rw [image_toPullbackDiag]", "tactic_state": "X : Type u_6\nY : Sort u_7\nf : X \u2192 Y\n\u22a2 pullbackDiagonal f \u2229 Subtype.val \u207b\u00b9' univ \u00d7\u02e2 univ = pullbackDiagonal f"}, {"line": "rw [univ_prod_univ]", "tactic_state": "X : Type u_6\nY : Sort u_7\nf : X \u2192 Y\n\u22a2 pullbackDiagonal f \u2229 Subtype.val \u207b\u00b9' univ = pullbackDiagonal f"}, {"line": "rw [preimage_univ]", "tactic_state": "X : Type u_6\nY : Sort u_7\nf : X \u2192 Y\n\u22a2 pullbackDiagonal f \u2229 univ = pullbackDiagonal f"}, {"line": "rw [inter_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem offDiag_eq_empty : s.offDiag = \u2205 \u2194 s.Subsingleton := by\n  rw [\u2190 not_nonempty_iff_eq_empty]\n  rw [\u2190 not_nontrivial_iff]\n  rw [offDiag_nonempty.not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\n\u22a2 s.offDiag = \u2205 \u2194 s.Subsingleton"}, {"line": "rw [\u2190 not_nonempty_iff_eq_empty]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\n\u22a2 \u00acs.offDiag.Nonempty \u2194 s.Subsingleton"}, {"line": "rw [\u2190 not_nontrivial_iff]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\n\u22a2 \u00acs.offDiag.Nonempty \u2194 \u00acs.Nontrivial"}, {"line": "rw [offDiag_nonempty.not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem offDiag_empty : (\u2205 : Set \u03b1).offDiag = \u2205 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u22a2 \u2205.offDiag = \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem offDiag_singleton (a : \u03b1) : ({a} : Set \u03b1).offDiag = \u2205 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\na : \u03b1\n\u22a2 {a}.offDiag = \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem offDiag_insert (ha : a \u2209 s) : (insert a s).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a} := by\n  rw [insert_eq]\n  rw [union_comm]\n  rw [offDiag_union]\n  rw [offDiag_singleton]\n  rw [union_empty]\n  rw [union_right_comm]\n  rw [disjoint_left]\n  rintro b hb (rfl : b = a)\n  exact ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 (insert a s).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}"}, {"line": "rw [insert_eq]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 ({a} \u222a s).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}"}, {"line": "rw [union_comm]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 (s \u222a {a}).offDiag = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}"}, {"line": "rw [offDiag_union]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 s.offDiag \u222a {a}.offDiag \u222a s \u00d7\u02e2 {a} \u222a {a} \u00d7\u02e2 s = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}\n---\n\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"line": "rw [offDiag_singleton]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 s.offDiag \u222a \u2205 \u222a s \u00d7\u02e2 {a} \u222a {a} \u00d7\u02e2 s = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}\n---\n\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"line": "rw [union_empty]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 s.offDiag \u222a s \u00d7\u02e2 {a} \u222a {a} \u00d7\u02e2 s = s.offDiag \u222a {a} \u00d7\u02e2 s \u222a s \u00d7\u02e2 {a}\n---\n\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"line": "rw [union_right_comm]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 Disjoint s {a}"}, {"line": "rw [disjoint_left]", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983a_1 : \u03b1\u2984, a_1 \u2208 s \u2192 a_1 \u2209 {a}"}, {"line": "rintro b hb (rfl : b = a)", "tactic_state": "\u03b1 : Type u_6\ns : Set \u03b1\nb : \u03b1\nhb : b \u2208 s\nha : b \u2209 s\n\u22a2 False"}, {"line": "exact ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_pi (s : \u2200 i, Set (\u03b1 i)) : pi \u2205 s = univ := by\n  ext\n  simp [pi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u2205.pi s = univ"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 x\u271d \u2208 \u2205.pi s \u2194 x\u271d \u2208 univ"}, {"line": "simp [pi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_nonempty_iff : (s.pi t).Nonempty \u2194 \u2200 i, \u2203 x, i \u2208 s \u2192 x \u2208 t i := by\n  simp [Classical.skolem, Set.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (s.pi t).Nonempty \u2194 \u2200 (i : \u03b9), \u2203 x, i \u2208 s \u2192 x \u2208 t i"}, {"line": "simp [Classical.skolem, Set.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_nonempty_iff : (pi univ t).Nonempty \u2194 \u2200 i, (t i).Nonempty := by\n  simp [Classical.skolem, Set.Nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (univ.pi t).Nonempty \u2194 \u2200 (i : \u03b9), (t i).Nonempty"}, {"line": "simp [Classical.skolem, Set.Nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_eq_empty_iff : s.pi t = \u2205 \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205 := by\n  rw [\u2190 not_nonempty_iff_eq_empty]\n  rw [pi_nonempty_iff]\n  push_neg\n  refine exists_congr fun i => ?_\n  cases isEmpty_or_nonempty (\u03b1 i) <;> simp [*, forall_and, eq_empty_iff_forall_not_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 s.pi t = \u2205 \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205"}, {"line": "rw [\u2190 not_nonempty_iff_eq_empty]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u00ac(s.pi t).Nonempty \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205"}, {"line": "rw [pi_nonempty_iff]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (\u00ac\u2200 (i : \u03b9), \u2203 x, i \u2208 s \u2192 x \u2208 t i) \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205"}, {"line": "push_neg", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (\u2203 i, \u2200 (x : \u03b1 i), i \u2208 s \u2227 x \u2209 t i) \u2194 \u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205"}, {"line": "refine exists_congr fun i => ?_", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\n\u22a2 (\u2200 (x : \u03b1 i), i \u2208 s \u2227 x \u2209 t i) \u2194 IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205"}, {"line": "cases isEmpty_or_nonempty (\u03b1 i) <;> simp [*, forall_and, eq_empty_iff_forall_not_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_eq_empty_iff : pi univ t = \u2205 \u2194 \u2203 i, t i = \u2205 := by\n  simp [\u2190 not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 univ.pi t = \u2205 \u2194 \u2203 i, t i = \u2205"}, {"line": "simp [\u2190 not_nonempty_iff_eq_empty, univ_pi_nonempty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_univ_pi : Disjoint (pi univ t\u2081) (pi univ t\u2082) \u2194 \u2203 i, Disjoint (t\u2081 i) (t\u2082 i) := by\n  simp only [disjoint_iff_inter_eq_empty]\n  simp only [\u2190 pi_inter_distrib]\n  simp only [univ_pi_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 Disjoint (univ.pi t\u2081) (univ.pi t\u2082) \u2194 \u2203 i, Disjoint (t\u2081 i) (t\u2082 i)"}, {"line": "simp only [disjoint_iff_inter_eq_empty]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 univ.pi t\u2081 \u2229 univ.pi t\u2082 = \u2205 \u2194 \u2203 i, t\u2081 i \u2229 t\u2082 i = \u2205"}, {"line": "simp only [\u2190 pi_inter_distrib]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (univ.pi fun i => t\u2081 i \u2229 t\u2082 i) = \u2205 \u2194 \u2203 i, t\u2081 i \u2229 t\u2082 i = \u2205"}, {"line": "simp only [univ_pi_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_eq_empty_iff' : s.pi t = \u2205 \u2194 \u2203 i \u2208 s, t i = \u2205 := by simp [pi_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 s.pi t = \u2205 \u2194 \u2203 i \u2208 s, t i = \u2205"}, {"line": "simp [pi_eq_empty_iff]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 (\u2203 i, IsEmpty (\u03b1 i) \u2228 i \u2208 s \u2227 t i = \u2205) \u2194 \u2203 i \u2208 s, t i = \u2205"}]}
{"declaration": "theorem insert_pi (i : \u03b9) (s : Set \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    pi (insert i s) t = eval i \u207b\u00b9' t i \u2229 pi s t := by\n  ext\n  simp [pi, or_imp, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ni : \u03b9\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (insert i s).pi t = eval i \u207b\u00b9' t i \u2229 s.pi t"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ni : \u03b9\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 x\u271d \u2208 (insert i s).pi t \u2194 x\u271d \u2208 eval i \u207b\u00b9' t i \u2229 s.pi t"}, {"line": "simp [pi, or_imp, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_pi (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = eval i \u207b\u00b9' t i := by\n  ext\n  simp [pi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ni : \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 {i}.pi t = eval i \u207b\u00b9' t i"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ni : \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 x\u271d \u2208 {i}.pi t \u2194 x\u271d \u2208 eval i \u207b\u00b9' t i"}, {"line": "simp [pi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_if {p : \u03b9 \u2192 Prop} [h : DecidablePred p] (s : Set \u03b9) (t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)) :\n    (pi s fun i => if p i then t\u2081 i else t\u2082 i) =\n      pi ({ i \u2208 s | p i }) t\u2081 \u2229 pi ({ i \u2208 s | \u00acp i }) t\u2082 := by\n  ext f\n  refine \u27e8fun h => ?_, ?_\u27e9\n  \u00b7 constructor <;>\n      \u00b7 rintro i \u27e8his, hpi\u27e9\n        simpa [*] using h i\n  \u00b7 rintro \u27e8ht\u2081, ht\u2082\u27e9 i his\n    by_cases p i <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nh : DecidablePred p\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (s.pi fun i => if p i then t\u2081 i else t\u2082 i) = {i | i \u2208 s \u2227 p i}.pi t\u2081 \u2229 {i | i \u2208 s \u2227 \u00acp i}.pi t\u2082"}, {"line": "ext f", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nh : DecidablePred p\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (f \u2208 s.pi fun i => if p i then t\u2081 i else t\u2082 i) \u2194 f \u2208 {i | i \u2208 s \u2227 p i}.pi t\u2081 \u2229 {i | i \u2208 s \u2227 \u00acp i}.pi t\u2082"}, {"line": "refine \u27e8fun h => ?_, ?_\u27e9", "tactic_state": "case h.refine_1\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nh\u271d : DecidablePred p\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i\nh : f \u2208 s.pi fun i => if p i then t\u2081 i else t\u2082 i\n\u22a2 f \u2208 {i | i \u2208 s \u2227 p i}.pi t\u2081 \u2229 {i | i \u2208 s \u2227 \u00acp i}.pi t\u2082\n---\ncase h.refine_2\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nh : DecidablePred p\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 f \u2208 {i | i \u2208 s \u2227 p i}.pi t\u2081 \u2229 {i | i \u2208 s \u2227 \u00acp i}.pi t\u2082 \u2192 f \u2208 s.pi fun i => if p i then t\u2081 i else t\u2082 i"}, {"line": "\u00b7 constructor <;>\n      \u00b7 rintro i \u27e8his, hpi\u27e9\n        simpa [*] using h i", "tactic_state": "case h.refine_2\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\np : \u03b9 \u2192 Prop\nh : DecidablePred p\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 f \u2208 {i | i \u2208 s \u2227 p i}.pi t\u2081 \u2229 {i | i \u2208 s \u2227 \u00acp i}.pi t\u2082 \u2192 f \u2208 s.pi fun i => if p i then t\u2081 i else t\u2082 i"}, {"line": "\u00b7 rintro \u27e8ht\u2081, ht\u2082\u27e9 i his\n    by_cases p i <;> simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_pi : (s\u2081 \u222a s\u2082).pi t = s\u2081.pi t \u2229 s\u2082.pi t := by\n  simp [pi, or_imp, forall_and, setOf_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 (s\u2081 \u222a s\u2082).pi t = s\u2081.pi t \u2229 s\u2082.pi t"}, {"line": "simp [pi, or_imp, forall_and, setOf_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_pi_inter\n    (ht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ) (ht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ) :\n    (s\u2081 \u222a s\u2082).pi (fun i \u21a6 t\u2081 i \u2229 t\u2082 i) = s\u2081.pi t\u2081 \u2229 s\u2082.pi t\u2082 := by\n  ext x\n  simp only [mem_pi]\n  simp only [mem_union]\n  simp only [mem_inter_iff]\n  refine \u27e8fun h \u21a6 \u27e8fun i his\u2081 \u21a6 (h i (Or.inl his\u2081)).1, fun i his\u2082 \u21a6 (h i (Or.inr his\u2082)).2\u27e9,\n    fun h i hi \u21a6 ?_\u27e9\n  rcases hi with hi | hi\n  \u00b7 by_cases hi2 : i \u2208 s\u2082\n    \u00b7 exact \u27e8h.1 i hi, h.2 i hi2\u27e9\n    \u00b7 refine \u27e8h.1 i hi, ?_\u27e9\n      rw [ht\u2082 i hi2]\n      exact mem_univ _\n  \u00b7 by_cases hi1 : i \u2208 s\u2081\n    \u00b7 exact \u27e8h.1 i hi1, h.2 i hi\u27e9\n    \u00b7 refine \u27e8?_, h.2 i hi\u27e9\n      rw [ht\u2081 i hi1]\n      exact mem_univ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\n\u22a2 ((s\u2081 \u222a s\u2082).pi fun i => t\u2081 i \u2229 t\u2082 i) = s\u2081.pi t\u2081 \u2229 s\u2082.pi t\u2082"}, {"line": "ext x", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (x \u2208 (s\u2081 \u222a s\u2082).pi fun i => t\u2081 i \u2229 t\u2082 i) \u2194 x \u2208 s\u2081.pi t\u2081 \u2229 s\u2082.pi t\u2082"}, {"line": "simp only [mem_pi]", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 i \u2208 s\u2081 \u222a s\u2082, x i \u2208 t\u2081 i \u2229 t\u2082 i) \u2194 x \u2208 s\u2081.pi t\u2081 \u2229 s\u2082.pi t\u2082"}, {"line": "simp only [mem_union]", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 (i : \u03b9), i \u2208 s\u2081 \u2228 i \u2208 s\u2082 \u2192 x i \u2208 t\u2081 i \u2229 t\u2082 i) \u2194 x \u2208 s\u2081.pi t\u2081 \u2229 s\u2082.pi t\u2082"}, {"line": "simp only [mem_inter_iff]", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 (i : \u03b9), i \u2208 s\u2081 \u2228 i \u2208 s\u2082 \u2192 x i \u2208 t\u2081 i \u2227 x i \u2208 t\u2082 i) \u2194 x \u2208 s\u2081.pi t\u2081 \u2227 x \u2208 s\u2082.pi t\u2082"}, {"line": "refine \u27e8fun h \u21a6 \u27e8fun i his\u2081 \u21a6 (h i (Or.inl his\u2081)).1, fun i his\u2082 \u21a6 (h i (Or.inr his\u2082)).2\u27e9,\n    fun h i hi \u21a6 ?_\u27e9", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\nh : x \u2208 s\u2081.pi t\u2081 \u2227 x \u2208 s\u2082.pi t\u2082\ni : \u03b9\nhi : i \u2208 s\u2081 \u2228 i \u2208 s\u2082\n\u22a2 x i \u2208 t\u2081 i \u2227 x i \u2208 t\u2082 i"}, {"line": "rcases hi with hi | hi", "tactic_state": "case h.inl\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\nh : x \u2208 s\u2081.pi t\u2081 \u2227 x \u2208 s\u2082.pi t\u2082\ni : \u03b9\nhi : i \u2208 s\u2081\n\u22a2 x i \u2208 t\u2081 i \u2227 x i \u2208 t\u2082 i\n---\ncase h.inr\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\nh : x \u2208 s\u2081.pi t\u2081 \u2227 x \u2208 s\u2082.pi t\u2082\ni : \u03b9\nhi : i \u2208 s\u2082\n\u22a2 x i \u2208 t\u2081 i \u2227 x i \u2208 t\u2082 i"}, {"line": "\u00b7 by_cases hi2 : i \u2208 s\u2082\n    \u00b7 exact \u27e8h.1 i hi, h.2 i hi2\u27e9\n    \u00b7 refine \u27e8h.1 i hi, ?_\u27e9\n      rw [ht\u2082 i hi2]\n      exact mem_univ _", "tactic_state": "case h.inr\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nht\u2081 : \u2200 i \u2209 s\u2081, t\u2081 i = univ\nht\u2082 : \u2200 i \u2209 s\u2082, t\u2082 i = univ\nx : (i : \u03b9) \u2192 \u03b1 i\nh : x \u2208 s\u2081.pi t\u2081 \u2227 x \u2208 s\u2082.pi t\u2082\ni : \u03b9\nhi : i \u2208 s\u2082\n\u22a2 x i \u2208 t\u2081 i \u2227 x i \u2208 t\u2082 i"}, {"line": "\u00b7 by_cases hi1 : i \u2208 s\u2081\n    \u00b7 exact \u27e8h.1 i hi1, h.2 i hi\u27e9\n    \u00b7 refine \u27e8?_, h.2 i hi\u27e9\n      rw [ht\u2081 i hi1]\n      exact mem_univ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_inter_compl (s : Set \u03b9) : pi s t \u2229 pi s\u1d9c t = pi univ t := by\n  rw [\u2190 union_pi]\n  rw [union_compl_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\n\u22a2 s.pi t \u2229 s\u1d9c.pi t = univ.pi t"}, {"line": "rw [\u2190 union_pi]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\n\u22a2 (s \u222a s\u1d9c).pi t = univ.pi t"}, {"line": "rw [union_compl_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_update [DecidableEq \u03b9] {\u03b2 : \u03b9 \u2192 Type*} (i : \u03b9) (f : \u2200 j, \u03b1 j) (a : \u03b1 i)\n    (t : \u2200 j, \u03b1 j \u2192 Set (\u03b2 j)) :\n    (pi univ fun j => t j (update f i a j)) = { x | x i \u2208 t i a } \u2229 pi {i}\u1d9c fun j => t j (f j) := by\n  rw [compl_eq_univ_diff]\n  rw [\u2190 pi_update_of_mem (mem_univ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type u_10\ni : \u03b9\nf : (j : \u03b9) \u2192 \u03b1 j\na : \u03b1 i\nt : (j : \u03b9) \u2192 \u03b1 j \u2192 Set (\u03b2 j)\n\u22a2 (univ.pi fun j => t j (update f i a j)) = {x | x i \u2208 t i a} \u2229 {i}\u1d9c.pi fun j => t j (f j)"}, {"line": "rw [compl_eq_univ_diff]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\n\u03b2 : \u03b9 \u2192 Type u_10\ni : \u03b9\nf : (j : \u03b9) \u2192 \u03b1 j\na : \u03b1 i\nt : (j : \u03b9) \u2192 \u03b1 j \u2192 Set (\u03b2 j)\n\u22a2 (univ.pi fun j => t j (update f i a j)) = {x | x i \u2208 t i a} \u2229 (univ \\ {i}).pi fun j => t j (f j)"}, {"line": "rw [\u2190 pi_update_of_mem (mem_univ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piMap_image_pi {f : \u2200 i, \u03b1 i \u2192 \u03b2 i} (hf : \u2200 i \u2209 s, Surjective (f i)) (t : \u2200 i, Set (\u03b1 i)) :\n    Pi.map f '' s.pi t = s.pi fun i \u21a6 f i '' t i := by\n  refine Subset.antisymm (piMap_image_pi_subset _) fun b hb => ?_\n  have (i : \u03b9) : \u2203 a, f i a = b i \u2227 (i \u2208 s \u2192 a \u2208 t i) := by\n    if hi : i \u2208 s then\n      exact (hb i hi).imp fun a \u27e8hat, hab\u27e9 \u21a6 \u27e8hab, fun _ \u21a6 hat\u27e9\n    else\n      exact (hf i hi (b i)).imp fun a ha \u21a6 \u27e8ha, (absurd \u00b7 hi)\u27e9\n  choose a hab hat using this\n  exact \u27e8a, hat, funext hab\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\nhf : \u2200 i \u2209 s, Surjective (f i)\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 Pi.map f '' s.pi t = s.pi fun i => f i '' t i"}, {"line": "refine Subset.antisymm (piMap_image_pi_subset _) fun b hb => ?_", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\nhf : \u2200 i \u2209 s, Surjective (f i)\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nb : (i : \u03b9) \u2192 \u03b2 i\nhb : b \u2208 s.pi fun i => f i '' t i\n\u22a2 b \u2208 Pi.map f '' s.pi t"}, {"line": "have (i : \u03b9) : \u2203 a, f i a = b i \u2227 (i \u2208 s \u2192 a \u2208 t i) := by\n    if hi : i \u2208 s then\n      exact (hb i hi).imp fun a \u27e8hat, hab\u27e9 \u21a6 \u27e8hab, fun _ \u21a6 hat\u27e9\n    else\n      exact (hf i hi (b i)).imp fun a ha \u21a6 \u27e8ha, (absurd \u00b7 hi)\u27e9", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\nhf : \u2200 i \u2209 s, Surjective (f i)\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nb : (i : \u03b9) \u2192 \u03b2 i\nhb : b \u2208 s.pi fun i => f i '' t i\nthis : \u2200 (i : \u03b9), \u2203 a, f i a = b i \u2227 (i \u2208 s \u2192 a \u2208 t i)\n\u22a2 b \u2208 Pi.map f '' s.pi t"}, {"line": "choose a hab hat using this", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ns : Set \u03b9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\nhf : \u2200 i \u2209 s, Surjective (f i)\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nb : (i : \u03b9) \u2192 \u03b2 i\nhb : b \u2208 s.pi fun i => f i '' t i\na : (i : \u03b9) \u2192 \u03b1 i\nhab : \u2200 (i : \u03b9), f i (a i) = b i\nhat : \u2200 i \u2208 s, a i \u2208 t i\n\u22a2 b \u2208 Pi.map f '' s.pi t"}, {"line": "exact \u27e8a, hat, funext hab\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_piMap (f : \u2200 i, \u03b1 i \u2192 \u03b2 i) : range (Pi.map f) = pi univ fun i \u21a6 range (f i) := by\n  simp only [\u2190 image_univ]\n  simp only [\u2190 piMap_image_univ_pi]\n  simp only [pi_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 range (Pi.map f) = univ.pi fun i => range (f i)"}, {"line": "simp only [\u2190 image_univ]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 Pi.map f '' univ = univ.pi fun i => f i '' univ"}, {"line": "simp only [\u2190 piMap_image_univ_pi]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\n\u03b2 : \u03b9 \u2192 Type u_9\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nf : (i : \u03b9) \u2192 \u03b1 i \u2192 \u03b2 i\n\u22a2 Pi.map f '' univ = Pi.map f '' univ.pi fun i => univ"}, {"line": "simp only [pi_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_subset_pi_iff : pi s t\u2081 \u2286 pi s t\u2082 \u2194 (\u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) \u2228 pi s t\u2081 = \u2205 := by\n  refine\n    \u27e8fun h => or_iff_not_imp_right.2 ?_, fun h => h.elim pi_mono fun h' => h'.symm \u25b8 empty_subset _\u27e9\n  rw [\u2190 Ne]\n  rw [\u2190 nonempty_iff_ne_empty]\n  intro hne i hi\n  simpa only [eval_image_pi hi hne,eval_image_pi hi (hne.mono h)] using\n    image_subset (fun f : \u2200 i, \u03b1 i => f i) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 s.pi t\u2081 \u2286 s.pi t\u2082 \u2194 (\u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i) \u2228 s.pi t\u2081 = \u2205"}, {"line": "refine\n    \u27e8fun h => or_iff_not_imp_right.2 ?_, fun h => h.elim pi_mono fun h' => h'.symm \u25b8 empty_subset _\u27e9", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nh : s.pi t\u2081 \u2286 s.pi t\u2082\n\u22a2 \u00acs.pi t\u2081 = \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"line": "rw [\u2190 Ne]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nh : s.pi t\u2081 \u2286 s.pi t\u2082\n\u22a2 s.pi t\u2081 \u2260 \u2205 \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"line": "rw [\u2190 nonempty_iff_ne_empty]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nh : s.pi t\u2081 \u2286 s.pi t\u2082\n\u22a2 (s.pi t\u2081).Nonempty \u2192 \u2200 i \u2208 s, t\u2081 i \u2286 t\u2082 i"}, {"line": "intro hne i hi", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\nh : s.pi t\u2081 \u2286 s.pi t\u2082\nhne : (s.pi t\u2081).Nonempty\ni : \u03b9\nhi : i \u2208 s\n\u22a2 t\u2081 i \u2286 t\u2082 i"}, {"line": "simpa only [eval_image_pi hi hne,eval_image_pi hi (hne.mono h)] using\n    image_subset (fun f : \u2200 i, \u03b1 i => f i) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_subset_univ_pi_iff :\n    pi univ t\u2081 \u2286 pi univ t\u2082 \u2194 (\u2200 i, t\u2081 i \u2286 t\u2082 i) \u2228 \u2203 i, t\u2081 i = \u2205 := by simp [pi_subset_pi_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\n\u22a2 univ.pi t\u2081 \u2286 univ.pi t\u2082 \u2194 (\u2200 (i : \u03b9), t\u2081 i \u2286 t\u2082 i) \u2228 \u2203 i, t\u2081 i = \u2205"}, {"line": "simp [pi_subset_pi_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_preimage [DecidableEq \u03b9] {s : Set (\u03b1 i)} :\n    eval i \u207b\u00b9' s = pi univ (update (fun _ => univ) i s) := by\n  ext x\n  simp [@forall_update_iff _ (fun i => Set (\u03b1 i)) _ _ _ _ fun i' y => x i' \u2208 y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\n\u22a2 eval i \u207b\u00b9' s = univ.pi (update (fun x => univ) i s)"}, {"line": "ext x", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\nx : (x : \u03b9) \u2192 \u03b1 x\n\u22a2 x \u2208 eval i \u207b\u00b9' s \u2194 x \u2208 univ.pi (update (fun x => univ) i s)"}, {"line": "simp [@forall_update_iff _ (fun i => Set (\u03b1 i)) _ _ _ _ fun i' y => x i' \u2208 y]", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\nx : (x : \u03b9) \u2192 \u03b1 x\n\u22a2 x i \u2208 s \u2194 \u2200 (i_1 : \u03b9), x i_1 \u2208 update (fun x => univ) i s i_1"}]}
{"declaration": "theorem eval_preimage' [DecidableEq \u03b9] {s : Set (\u03b1 i)} :\n    eval i \u207b\u00b9' s = pi {i} (update (fun _ => univ) i s) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\n\u22a2 eval i \u207b\u00b9' s = {i}.pi (update (fun x => univ) i s)"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\ns : Set (\u03b1 i)\nx\u271d : (x : \u03b9) \u2192 \u03b1 x\n\u22a2 x\u271d \u2208 eval i \u207b\u00b9' s \u2194 x\u271d \u2208 {i}.pi (update (fun x => univ) i s)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem update_preimage_pi [DecidableEq \u03b9] {f : \u2200 i, \u03b1 i} (hi : i \u2208 s)\n    (hf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j) : update f i \u207b\u00b9' s.pi t = t i := by\n  ext x\n  refine \u27e8fun h => ?_, fun hx j hj => ?_\u27e9\n  \u00b7 convert h i hi\n    simp\n  \u00b7 obtain rfl | h := eq_or_ne j i\n    \u00b7 simpa\n    \u00b7 rw [update_of_ne h]\n      exact hf j hj h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\n\u22a2 update f i \u207b\u00b9' s.pi t = t i"}, {"line": "ext x", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\nx : \u03b1 i\n\u22a2 x \u2208 update f i \u207b\u00b9' s.pi t \u2194 x \u2208 t i"}, {"line": "refine \u27e8fun h => ?_, fun hx j hj => ?_\u27e9", "tactic_state": "case h.refine_1\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\nx : \u03b1 i\nh : x \u2208 update f i \u207b\u00b9' s.pi t\n\u22a2 x \u2208 t i\n---\ncase h.refine_2\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\nx : \u03b1 i\nhx : x \u2208 t i\nj : \u03b9\nhj : j \u2208 s\n\u22a2 update f i x j \u2208 t j"}, {"line": "\u00b7 convert h i hi\n    simp", "tactic_state": "case h.refine_2\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ninst\u271d : DecidableEq \u03b9\nf : (i : \u03b9) \u2192 \u03b1 i\nhi : i \u2208 s\nhf : \u2200 j \u2208 s, j \u2260 i \u2192 f j \u2208 t j\nx : \u03b1 i\nhx : x \u2208 t i\nj : \u03b9\nhj : j \u2208 s\n\u22a2 update f i x j \u2208 t j"}, {"line": "\u00b7 obtain rfl | h := eq_or_ne j i\n    \u00b7 simpa\n    \u00b7 rw [update_of_ne h]\n      exact hf j hj h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem univ_pi_ite (s : Set \u03b9) [DecidablePred (\u00b7 \u2208 s)] (t : \u2200 i, Set (\u03b1 i)) :\n    (pi univ fun i => if i \u2208 s then t i else univ) = s.pi t := by\n  ext\n  simp_rw [mem_univ_pi]\n  refine forall_congr' fun i => ?_\n  split_ifs with h <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\ninst\u271d : DecidablePred fun x => x \u2208 s\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (univ.pi fun i => if i \u2208 s then t i else univ) = s.pi t"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\ninst\u271d : DecidablePred fun x => x \u2208 s\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (x\u271d \u2208 univ.pi fun i => if i \u2208 s then t i else univ) \u2194 x\u271d \u2208 s.pi t"}, {"line": "simp_rw [mem_univ_pi]", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\ninst\u271d : DecidablePred fun x => x \u2208 s\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (\u2200 (i : \u03b9), x\u271d i \u2208 if i \u2208 s then t i else univ) \u2194 x\u271d \u2208 s.pi t"}, {"line": "refine forall_congr' fun i => ?_", "tactic_state": "case h\n\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d\u00b9 : \u2200 (i : \u03b9), Nonempty (\u03b1 i)\ns : Set \u03b9\ninst\u271d : DecidablePred fun x => x \u2208 s\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\nx\u271d : (i : \u03b9) \u2192 \u03b1 i\ni : \u03b9\n\u22a2 (x\u271d i \u2208 if i \u2208 s then t i else univ) \u2194 i \u2208 s \u2192 x\u271d i \u2208 t i"}, {"line": "split_ifs with h <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piCongrLeft_symm_preimage_univ_pi (f : \u03b9' \u2243 \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    (f.piCongrLeft \u03b1).symm \u207b\u00b9' univ.pi (fun i' => t <| f i') = univ.pi t := by\n  simpa [f.surjective.range_eq] using piCongrLeft_symm_preimage_pi f univ t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 (\u21d1(Equiv.piCongrLeft \u03b1 f).symm \u207b\u00b9' univ.pi fun i' => t (f i')) = univ.pi t"}, {"line": "simpa [f.surjective.range_eq] using piCongrLeft_symm_preimage_pi f univ t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piCongrLeft_preimage_pi (f : \u03b9' \u2243 \u03b9) (s : Set \u03b9') (t : \u2200 i, Set (\u03b1 i)) :\n    f.piCongrLeft \u03b1 \u207b\u00b9' (f '' s).pi t = s.pi fun i => t (f i) := by\n  apply Set.ext\n  rw [\u2190 (f.piCongrLeft \u03b1).symm.forall_congr_right]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\ns : Set \u03b9'\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u21d1(Equiv.piCongrLeft \u03b1 f) \u207b\u00b9' (\u21d1f '' s).pi t = s.pi fun i => t (f i)"}, {"line": "apply Set.ext", "tactic_state": "case h\n\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\ns : Set \u03b9'\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u2200 (x : (a : \u03b9') \u2192 \u03b1 (f a)), x \u2208 \u21d1(Equiv.piCongrLeft \u03b1 f) \u207b\u00b9' (\u21d1f '' s).pi t \u2194 x \u2208 s.pi fun i => t (f i)"}, {"line": "rw [\u2190 (f.piCongrLeft \u03b1).symm.forall_congr_right]", "tactic_state": "case h\n\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\ns : Set \u03b9'\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u2200 (a : (b : \u03b9) \u2192 \u03b1 b),\n    (Equiv.piCongrLeft \u03b1 f).symm a \u2208 \u21d1(Equiv.piCongrLeft \u03b1 f) \u207b\u00b9' (\u21d1f '' s).pi t \u2194\n      (Equiv.piCongrLeft \u03b1 f).symm a \u2208 s.pi fun i => t (f i)"}, {"line": "simp", "tactic_state": "case h\n\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\ns : Set \u03b9'\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u2200 (a : (b : \u03b9) \u2192 \u03b1 b), (\u2200 (i : \u03b9), f.symm i \u2208 s \u2192 a i \u2208 t i) \u2194 \u2200 i \u2208 s, a (f i) \u2208 t (f i)"}]}
{"declaration": "theorem piCongrLeft_preimage_univ_pi (f : \u03b9' \u2243 \u03b9) (t : \u2200 i, Set (\u03b1 i)) :\n    f.piCongrLeft \u03b1 \u207b\u00b9' univ.pi t = univ.pi fun i => t (f i) := by\n  simpa [f.surjective.range_eq] using piCongrLeft_preimage_pi f univ t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_10\n\u03b9' : Type u_11\n\u03b1 : \u03b9 \u2192 Type u_12\nf : \u03b9' \u2243 \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 \u21d1(Equiv.piCongrLeft \u03b1 f) \u207b\u00b9' univ.pi t = univ.pi fun i => t (f i)"}, {"line": "simpa [f.surjective.range_eq] using piCongrLeft_preimage_pi f univ t", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_fst_graphOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prod.fst '' graphOn f s = s := by\n  simp [graphOn, image_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 Prod.fst '' graphOn f s = s"}, {"line": "simp [graphOn, image_image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fst_injOn_graph : (s.graphOn f).InjOn Prod.fst := by aesop (add simp InjOn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 InjOn Prod.fst (graphOn f s)"}, {"line": "aesop (add simp InjOn)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma graphOn_comp (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b3) :\n    s.graphOn (g \u2218 f) = (fun x \u21a6 (x.1, g x.2)) '' s.graphOn f := by\n  simpa using image_comp (fun x \u21a6 (x.1, g x.2)) (fun x \u21a6 (x, f x)) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b3\n\u22a2 graphOn (g \u2218 f) s = (fun x => (x.1, g x.2)) '' graphOn f s"}, {"line": "simpa using image_comp (fun x \u21a6 (x.1, g x.2)) (fun x \u21a6 (x, f x)) _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma graphOn_prod_graphOn (s : Set \u03b1) (t : Set \u03b2) (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) :\n    s.graphOn f \u00d7\u02e2 t.graphOn g = Equiv.prodProdProdComm .. \u207b\u00b9' (s \u00d7\u02e2 t).graphOn (Prod.map f g) := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\n\u03b4 : Type u_16\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\n\u22a2 graphOn f s \u00d7\u02e2 graphOn g t = \u21d1(Equiv.prodProdProdComm \u03b1 \u03b3 \u03b2 \u03b4) \u207b\u00b9' graphOn (Prod.map f g) (s \u00d7\u02e2 t)"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma graphOn_prod_prodMap (s : Set \u03b1) (t : Set \u03b2) (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b4) :\n    (s \u00d7\u02e2 t).graphOn (Prod.map f g) = Equiv.prodProdProdComm .. \u207b\u00b9' s.graphOn f \u00d7\u02e2 t.graphOn g := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\n\u03b4 : Type u_16\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b4\n\u22a2 graphOn (Prod.map f g) (s \u00d7\u02e2 t) = \u21d1(Equiv.prodProdProdComm \u03b1 \u03b2 \u03b3 \u03b4) \u207b\u00b9' graphOn f s \u00d7\u02e2 graphOn g t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_range_eq_graphOn_univ {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf\u2081 : Surjective (Prod.fst \u2218 f))\n    (hf : \u2200 g\u2081 g\u2082, (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2) :\n    \u2203 f' : \u03b2 \u2192 \u03b3, range f = univ.graphOn f' := by\n  refine \u27e8fun h \u21a6 (f (hf\u2081 h).choose).snd, ?_\u27e9\n  ext x\n  simp only [mem_range]\n  simp only [comp_apply]\n  simp only [mem_graphOn]\n  simp only [mem_univ]\n  simp only [true_and]\n  refine \u27e8?_, fun hi \u21a6 \u27e8(hf\u2081 x.1).choose, Prod.ext (hf\u2081 x.1).choose_spec hi\u27e9\u27e9\n  rintro \u27e8g, rfl\u27e9\n  exact hf _ _ (hf\u2081 (f g).1).choose_spec\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\n\u22a2 \u2203 f', range f = graphOn f' univ"}, {"line": "refine \u27e8fun h \u21a6 (f (hf\u2081 h).choose).snd, ?_\u27e9", "tactic_state": "\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\n\u22a2 range f = graphOn (fun h => (f \u22ef.choose).2) univ"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 x \u2208 range f \u2194 x \u2208 graphOn (fun h => (f \u22ef.choose).2) univ"}, {"line": "simp only [mem_range]", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2194 x \u2208 graphOn (fun h => (f \u22ef.choose).2) univ"}, {"line": "simp only [comp_apply]", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2194 x \u2208 graphOn (fun h => (f \u22ef.choose).2) univ"}, {"line": "simp only [mem_graphOn]", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2194 x.1 \u2208 univ \u2227 (f \u22ef.choose).2 = x.2"}, {"line": "simp only [mem_univ]", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2194 True \u2227 (f \u22ef.choose).2 = x.2"}, {"line": "simp only [true_and]", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2194 (f \u22ef.choose).2 = x.2"}, {"line": "refine \u27e8?_, fun hi \u21a6 \u27e8(hf\u2081 x.1).choose, Prod.ext (hf\u2081 x.1).choose_spec hi\u27e9\u27e9", "tactic_state": "case h\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\nx : \u03b2 \u00d7 \u03b3\n\u22a2 (\u2203 y, f y = x) \u2192 (f \u22ef.choose).2 = x.2"}, {"line": "rintro \u27e8g, rfl\u27e9", "tactic_state": "case h.intro\n\u03b1 : Type u_13\n\u03b2 : Type u_14\n\u03b3 : Type u_15\nf : \u03b1 \u2192 \u03b2 \u00d7 \u03b3\nhf\u2081 : Surjective (Prod.fst \u2218 f)\nhf : \u2200 (g\u2081 g\u2082 : \u03b1), (f g\u2081).1 = (f g\u2082).1 \u2192 (f g\u2081).2 = (f g\u2082).2\ng : \u03b1\n\u22a2 (f \u22ef.choose).2 = (f g).2"}, {"line": "exact hf _ _ (hf\u2081 (f g).1).choose_spec", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_eq_mgraphOn_univ {s : Set (\u03b2 \u00d7 \u03b3)}\n    (hs\u2081 : Bijective (Prod.fst \u2218 (Subtype.val : s \u2192 \u03b2 \u00d7 \u03b3))) : \u2203 f : \u03b2 \u2192 \u03b3, s = univ.graphOn f := by\n  simpa using exists_range_eq_graphOn_univ hs\u2081.surjective\n    fun a b h \u21a6 congr_arg (Prod.snd \u2218 (Subtype.val : s \u2192 \u03b2 \u00d7 \u03b3)) (hs\u2081.injective h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Prod.lean", "context": {"open": ["Function", "Set", "Function.Pullback in", "Function.Pullback in", "Function.Pullback in", "Function.PullbackSelf Function.Pullback", "Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {a : \u03b1} {b : \u03b2}", "[Preorder \u03b1] {f : \u03b1 \u2192 Set \u03b2} {g : \u03b1 \u2192 Set \u03b3}", "{\u03b1 : Type*} {s t : Set \u03b1}", "{X Y Z}", "{\u03b1 : Type*} {s t : Set \u03b1} {a : \u03b1}", "(s t)", "{s t}", "{\u03b9 : Type*} {\u03b1 \u03b2 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)} {i : \u03b9}", "[\u2200 i, Nonempty (\u03b1 i)]", "{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*}", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "{x : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_14\n\u03b3 : Type u_15\ns : Set (\u03b2 \u00d7 \u03b3)\nhs\u2081 : Bijective (Prod.fst \u2218 Subtype.val)\n\u22a2 \u2203 f, s = graphOn f univ"}, {"line": "simpa using exists_range_eq_graphOn_univ hs\u2081.surjective\n    fun a b h \u21a6 congr_arg (Prod.snd \u2218 (Subtype.val : s \u2192 \u03b2 \u00d7 \u03b3)) (hs\u2081.injective h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_image_sigmaMk_of_ne (h : i \u2260 j) (s : Set (\u03b1 j)) :\n    Sigma.mk i \u207b\u00b9' (Sigma.mk j '' s) = \u2205 := by\n  ext x\n  simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sigma.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ni j : \u03b9\nh : i \u2260 j\ns : Set (\u03b1 j)\n\u22a2 Sigma.mk i \u207b\u00b9' (Sigma.mk j '' s) = \u2205"}, {"line": "ext x", "tactic_state": "case h\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ni j : \u03b9\nh : i \u2260 j\ns : Set (\u03b1 j)\nx : \u03b1 i\n\u22a2 x \u2208 Sigma.mk i \u207b\u00b9' (Sigma.mk j '' s) \u2194 x \u2208 \u2205"}, {"line": "simp [h.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_singleton {a : \u2200 i, \u03b1 i} :\n    s.sigma (fun i \u21a6 ({a i} : Set (\u03b1 i))) = (fun i \u21a6 Sigma.mk i <| a i) '' s := by\n  ext \u27e8x, y\u27e9\n  simp [and_left_comm, eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sigma.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ns : Set \u03b9\na : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (s.sigma fun i => {a i}) = (fun i => \u27e8i, a i\u27e9) '' s"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ns : Set \u03b9\na : (i : \u03b9) \u2192 \u03b1 i\nx : \u03b9\ny : \u03b1 x\n\u22a2 (\u27e8x, y\u27e9 \u2208 s.sigma fun i => {a i}) \u2194 \u27e8x, y\u27e9 \u2208 (fun i => \u27e8i, a i\u27e9) '' s"}, {"line": "simp [and_left_comm, eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sigma_inter_sigma : s\u2081.sigma t\u2081 \u2229 s\u2082.sigma t\u2082 = (s\u2081 \u2229 s\u2082).sigma fun i \u21a6 t\u2081 i \u2229 t\u2082 i := by\n  ext \u27e8x, y\u27e9\n  simp [and_assoc, and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sigma.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\n\u22a2 s\u2081.sigma t\u2081 \u2229 s\u2082.sigma t\u2082 = (s\u2081 \u2229 s\u2082).sigma fun i => t\u2081 i \u2229 t\u2082 i"}, {"line": "ext \u27e8x, y\u27e9", "tactic_state": "case h.mk\n\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ns\u2081 s\u2082 : Set \u03b9\nt\u2081 t\u2082 : (i : \u03b9) \u2192 Set (\u03b1 i)\nx : \u03b9\ny : \u03b1 x\n\u22a2 \u27e8x, y\u27e9 \u2208 s\u2081.sigma t\u2081 \u2229 s\u2082.sigma t\u2082 \u2194 \u27e8x, y\u27e9 \u2208 (s\u2081 \u2229 s\u2082).sigma fun i => t\u2081 i \u2229 t\u2082 i"}, {"line": "simp [and_assoc, and_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_preimage_sigma_eq_if [DecidablePred (\u00b7 \u2208 s)] :\n    Sigma.mk i \u207b\u00b9' s.sigma t = if i \u2208 s then t i else \u2205 := by split_ifs <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sigma.lean", "context": {"open": [], "variables": ["{\u03b9 \u03b9' : Type*} {\u03b1 : \u03b9 \u2192 Type*} {s s\u2081 s\u2082 : Set \u03b9} {t t\u2081 t\u2082 : \u2200 i, Set (\u03b1 i)}", "{\u03b2 : Type*} [CompleteLattice \u03b2]", "{\u03b2 : Type*}", "{\u03b2 : \u03b9 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : \u03b9 \u2192 Type u_3\ns : Set \u03b9\nt : (i : \u03b9) \u2192 Set (\u03b1 i)\ni : \u03b9\ninst\u271d : DecidablePred fun x => x \u2208 s\n\u22a2 Sigma.mk i \u207b\u00b9' s.sigma t = if i \u2208 s then t i else \u2205"}, {"line": "split_ifs <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_val_eq_univ_of_subset (h : A \u2286 B) : A \u2193\u2229 B = univ := by\n  rw [eq_univ_iff_forall]\n  rw [Subtype.forall]\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA B : Set \u03b1\nh : A \u2286 B\n\u22a2 Subtype.val \u207b\u00b9' B = univ"}, {"line": "rw [eq_univ_iff_forall]", "tactic_state": "\u03b1 : Type u_2\nA B : Set \u03b1\nh : A \u2286 B\n\u22a2 \u2200 (x : \u2191A), x \u2208 Subtype.val \u207b\u00b9' B"}, {"line": "rw [Subtype.forall]", "tactic_state": "\u03b1 : Type u_2\nA B : Set \u03b1\nh : A \u2286 B\n\u22a2 \u2200 (a : \u03b1) (b : a \u2208 A), \u27e8a, b\u27e9 \u2208 Subtype.val \u207b\u00b9' B"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_val_sUnion : A \u2193\u2229 (\u22c3\u2080 S) = \u22c3\u2080 { (A \u2193\u2229 B) | B \u2208 S } := by\n  rw [\u2190 Set.image]\n  rw [sUnion_image]\n  simp_rw [sUnion_eq_biUnion, preimage_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c3\u2080 S = \u22c3\u2080 {x | \u2203 B \u2208 S, Subtype.val \u207b\u00b9' B = x}"}, {"line": "rw [\u2190 Set.image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c3\u2080 S = \u22c3\u2080 (preimage Subtype.val '' S)"}, {"line": "rw [sUnion_image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c3\u2080 S = \u22c3 a \u2208 S, Subtype.val \u207b\u00b9' a"}, {"line": "simp_rw [sUnion_eq_biUnion, preimage_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_val_sInter : A \u2193\u2229 (\u22c2\u2080 S) = \u22c2\u2080 { (A \u2193\u2229 B) | B \u2208 S } := by\n  rw [\u2190 Set.image]\n  rw [sInter_image]\n  simp_rw [sInter_eq_biInter, preimage_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c2\u2080 S = \u22c2\u2080 {x | \u2203 B \u2208 S, Subtype.val \u207b\u00b9' B = x}"}, {"line": "rw [\u2190 Set.image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c2\u2080 S = \u22c2\u2080 (preimage Subtype.val '' S)"}, {"line": "rw [sInter_image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c2\u2080 S = \u22c2 a \u2208 S, Subtype.val \u207b\u00b9' a"}, {"line": "simp_rw [sInter_eq_biInter, preimage_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma preimage_val_sInter_eq_sInter : A \u2193\u2229 (\u22c2\u2080 S) = \u22c2\u2080 ((A \u2193\u2229 \u00b7) '' S) := by\n  simp only [preimage_sInter]\n  simp only [sInter_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 Subtype.val \u207b\u00b9' \u22c2\u2080 S = \u22c2\u2080 ((fun x => Subtype.val \u207b\u00b9' x) '' S)"}, {"line": "simp only [preimage_sInter]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nS : Set (Set \u03b1)\n\u22a2 \u22c2 t \u2208 S, Subtype.val \u207b\u00b9' t = \u22c2\u2080 ((fun x => Subtype.val \u207b\u00b9' x) '' S)"}, {"line": "simp only [sInter_image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_preimage_val_eq_of_subset (hB : B \u2286 A) (hC : C \u2286 A) (h : A \u2193\u2229 B = A \u2193\u2229 C) : B = C := by\n  simp only [\u2190 inter_eq_right] at hB hC\n  simp only [Subtype.preimage_val_eq_preimage_val_iff] at h\n  simp only [hB] at h\n  simp only [hC] at h\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA B C : Set \u03b1\nhB : B \u2286 A\nhC : C \u2286 A\nh : Subtype.val \u207b\u00b9' B = Subtype.val \u207b\u00b9' C\n\u22a2 B = C"}, {"line": "simp only [\u2190 inter_eq_right] at hB hC", "tactic_state": "\u03b1 : Type u_2\nA B C : Set \u03b1\nh : Subtype.val \u207b\u00b9' B = Subtype.val \u207b\u00b9' C\nhB : A \u2229 B = B\nhC : A \u2229 C = C\n\u22a2 B = C"}, {"line": "simp only [Subtype.preimage_val_eq_preimage_val_iff] at h", "tactic_state": "\u03b1 : Type u_2\nA B C : Set \u03b1\nhB : A \u2229 B = B\nhC : A \u2229 C = C\nh : A \u2229 B = A \u2229 C\n\u22a2 B = C"}, {"line": "simp only [hB] at h", "tactic_state": "\u03b1 : Type u_2\nA B C : Set \u03b1\nhB : A \u2229 B = B\nhC : A \u2229 C = C\nh : B = A \u2229 C\n\u22a2 B = C"}, {"line": "simp only [hC] at h", "tactic_state": "\u03b1 : Type u_2\nA B C : Set \u03b1\nhB : A \u2229 B = B\nhC : A \u2229 C = C\nh : B = C\n\u22a2 B = C"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_val_compl : \u2191(D\u1d9c) = A \\ \u2191D := by\n  rw [compl_eq_univ_diff]\n  rw [image_val_diff]\n  rw [image_univ]\n  rw [Subtype.range_coe_subtype]\n  rw [setOf_mem_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD : Set \u2191A\n\u22a2 Subtype.val '' D\u1d9c = A \\ Subtype.val '' D"}, {"line": "rw [compl_eq_univ_diff]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD : Set \u2191A\n\u22a2 Subtype.val '' (univ \\ D) = A \\ Subtype.val '' D"}, {"line": "rw [image_val_diff]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD : Set \u2191A\n\u22a2 Subtype.val '' univ \\ Subtype.val '' D = A \\ Subtype.val '' D"}, {"line": "rw [image_univ]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD : Set \u2191A\n\u22a2 range Subtype.val \\ Subtype.val '' D = A \\ Subtype.val '' D"}, {"line": "rw [Subtype.range_coe_subtype]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD : Set \u2191A\n\u22a2 {x | x \u2208 A} \\ Subtype.val '' D = A \\ Subtype.val '' D"}, {"line": "rw [setOf_mem_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_val_sUnion : \u2191(\u22c3\u2080 T) = \u22c3\u2080 { (B : Set \u03b1) | B \u2208 T} := by\n  rw [image_sUnion]\n  rw [image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\n\u22a2 Subtype.val '' \u22c3\u2080 T = \u22c3\u2080 {x | \u2203 B \u2208 T, Subtype.val '' B = x}"}, {"line": "rw [image_sUnion]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\n\u22a2 \u22c3\u2080 (image Subtype.val '' T) = \u22c3\u2080 {x | \u2203 B \u2208 T, Subtype.val '' B = x}"}, {"line": "rw [image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma image_val_sInter (hT : T.Nonempty) : (\u2191(\u22c2\u2080 T) : Set \u03b1) = \u22c2\u2080 { (\u2191B : Set \u03b1) | B \u2208 T } := by\n  rw [\u2190 Set.image]\n  rw [sInter_image]\n  rw [sInter_eq_biInter]\n  rw [Subtype.val_injective.injOn.image_biInter_eq hT]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\nhT : T.Nonempty\n\u22a2 Subtype.val '' \u22c2\u2080 T = \u22c2\u2080 {x | \u2203 B \u2208 T, Subtype.val '' B = x}"}, {"line": "rw [\u2190 Set.image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\nhT : T.Nonempty\n\u22a2 Subtype.val '' \u22c2\u2080 T = \u22c2\u2080 (image Subtype.val '' T)"}, {"line": "rw [sInter_image]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\nhT : T.Nonempty\n\u22a2 Subtype.val '' \u22c2\u2080 T = \u22c2 a \u2208 T, Subtype.val '' a"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nT : Set (Set \u2191A)\nhT : T.Nonempty\n\u22a2 Subtype.val '' \u22c2 i \u2208 T, i = \u22c2 a \u2208 T, Subtype.val '' a"}, {"line": "rw [Subtype.val_injective.injOn.image_biInter_eq hT]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_preimage_val_image_val_iff : D \u2286 A \u2193\u2229 \u2191E \u2194 D \u2286 E := by\n  rw [preimage_image_eq _ Subtype.val_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subset.lean", "context": {"open": ["Set", "Notation"], "variables": ["{\u03b9 : Sort*} {\u03b1 : Type*} {A B C : Set \u03b1} {D E : Set A}", "{S : Set (Set \u03b1)} {T : Set (Set A)} {s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nA : Set \u03b1\nD E : Set \u2191A\n\u22a2 D \u2286 Subtype.val \u207b\u00b9' (Subtype.val '' E) \u2194 D \u2286 E"}, {"line": "rw [preimage_image_eq _ Subtype.val_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Infinite.exists_union_disjoint_cardinal_eq_of_infinite (h : s.Infinite) :\n    \u2203 (t u : Set \u03b1), t \u222a u = s \u2227 Disjoint t u \u2227 #t = #u := by\n  have := h.to_subtype\n  obtain \u27e8f\u27e9 : Nonempty (s \u2243 s \u2295 s) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 add_def]\n    rw [add_mk_eq_self]\n  refine \u27e8Subtype.val '' (f \u207b\u00b9' (range .inl)), Subtype.val '' (f \u207b\u00b9' (range .inr)), ?_, ?_, ?_\u27e9\n  \u00b7 simp [\u2190 image_union, \u2190 preimage_union]\n  \u00b7 exact disjoint_image_of_injective Subtype.val_injective\n      (isCompl_range_inl_range_inr.disjoint.preimage f)\n  \u00b7 simp [mk_image_eq Subtype.val_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card/Arithmetic.lean", "context": {"open": ["scoped Finset", "Cardinal"], "variables": ["{\u03b1 : Type*}", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\n\u22a2 \u2203 t u, t \u222a u = s \u2227 Disjoint t u \u2227 Cardinal.mk \u2191t = Cardinal.mk \u2191u"}, {"line": "have := h.to_subtype", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\n\u22a2 \u2203 t u, t \u222a u = s \u2227 Disjoint t u \u2227 Cardinal.mk \u2191t = Cardinal.mk \u2191u"}, {"line": "obtain \u27e8f\u27e9 : Nonempty (s \u2243 s \u2295 s) := by\n    rw [\u2190 Cardinal.eq]\n    rw [\u2190 add_def]\n    rw [add_mk_eq_self]", "tactic_state": "case intro\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 \u2203 t u, t \u222a u = s \u2227 Disjoint t u \u2227 Cardinal.mk \u2191t = Cardinal.mk \u2191u"}, {"line": "refine \u27e8Subtype.val '' (f \u207b\u00b9' (range .inl)), Subtype.val '' (f \u207b\u00b9' (range .inr)), ?_, ?_, ?_\u27e9", "tactic_state": "case intro.refine_1\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Subtype.val '' (\u21d1f \u207b\u00b9' sorry) \u222a Subtype.val '' (\u21d1f \u207b\u00b9' sorry) = s\n---\ncase intro.refine_2\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Disjoint (Subtype.val '' (\u21d1f \u207b\u00b9' sorry)) (Subtype.val '' (\u21d1f \u207b\u00b9' sorry))\n---\ncase intro.refine_3\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry)) = Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry))"}, {"line": "\u00b7 simp [\u2190 image_union, \u2190 preimage_union]", "tactic_state": "case intro.refine_2\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Disjoint (Subtype.val '' (\u21d1f \u207b\u00b9' sorry)) (Subtype.val '' (\u21d1f \u207b\u00b9' sorry))\n---\ncase intro.refine_3\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry)) = Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry))"}, {"line": "\u00b7 exact disjoint_image_of_injective Subtype.val_injective\n      (isCompl_range_inl_range_inr.disjoint.preimage f)", "tactic_state": "case intro.refine_3\n\u03b1 : Type u_1\ns : Set \u03b1\nh : s.Infinite\nthis : Infinite \u2191s\nf : \u2191s \u2243 \u2191s \u2295 \u2191s\n\u22a2 Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry)) = Cardinal.mk \u2191(Subtype.val '' (\u21d1f \u207b\u00b9' sorry))"}, {"line": "\u00b7 simp [mk_image_eq Subtype.val_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toFinset_iUnion [Fintype \u03b2] [DecidableEq \u03b1] (f : \u03b2 \u2192 Set \u03b1)\n    [\u2200 w, Fintype (f w)] :\n    Set.toFinset (\u22c3 (x : \u03b2), f x) =\n    Finset.biUnion (Finset.univ : Finset \u03b2) (fun x => (f x).toFinset) := by\n  ext v\n  simp only [mem_toFinset]\n  simp only [mem_iUnion]\n  simp only [Finset.mem_biUnion]\n  simp only [Finset.mem_univ]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\n\u22a2 (\u22c3 x, f x).toFinset = Finset.univ.biUnion fun x => (f x).toFinset"}, {"line": "ext v", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 v \u2208 (\u22c3 x, f x).toFinset \u2194 v \u2208 Finset.univ.biUnion fun x => (f x).toFinset"}, {"line": "simp only [mem_toFinset]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 v \u2208 \u22c3 x, f x \u2194 v \u2208 Finset.univ.biUnion fun x => (f x).toFinset"}, {"line": "simp only [mem_iUnion]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 (\u2203 i, v \u2208 f i) \u2194 v \u2208 Finset.univ.biUnion fun x => (f x).toFinset"}, {"line": "simp only [Finset.mem_biUnion]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 (\u2203 i, v \u2208 f i) \u2194 \u2203 a \u2208 Finset.univ, v \u2208 (f a).toFinset"}, {"line": "simp only [Finset.mem_univ]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 (\u2203 i, v \u2208 f i) \u2194 \u2203 a, True \u2227 v \u2208 (f a).toFinset"}, {"line": "simp only [true_and]", "tactic_state": "case h\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b2 : Fintype \u03b2\ninst\u271d\u00b9 : DecidableEq \u03b1\nf : \u03b2 \u2192 Set \u03b1\ninst\u271d : (w : \u03b2) \u2192 Fintype \u2191(f w)\nv : \u03b1\n\u22a2 (\u2203 i, v \u2208 f i) \u2194 \u2203 a, v \u2208 (f a).toFinset"}]}
{"declaration": "theorem finite_biUnion {\u03b9 : Type*} (s : Set \u03b9) [Finite s] (t : \u03b9 \u2192 Set \u03b1)\n    (H : \u2200 i \u2208 s, Finite (t i)) : Finite (\u22c3 x \u2208 s, t x) := by\n  rw [biUnion_eq_iUnion]\n  haveI : \u2200 i : s, Finite (t i) := fun i => H i i.property\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\ninst\u271d : Finite \u2191s\nt : \u03b9 \u2192 Set \u03b1\nH : \u2200 i \u2208 s, Finite \u2191(t i)\n\u22a2 Finite \u2191(\u22c3 x \u2208 s, t x)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\ninst\u271d : Finite \u2191s\nt : \u03b9 \u2192 Set \u03b1\nH : \u2200 i \u2208 s, Finite \u2191(t i)\n\u22a2 Finite \u2191(\u22c3 x, t \u2191x)"}, {"line": "haveI : \u2200 i : s, Finite (t i) := fun i => H i i.property", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\ninst\u271d : Finite \u2191s\nt : \u03b9 \u2192 Set \u03b1\nH : \u2200 i \u2208 s, Finite \u2191(t i)\nthis : \u2200 (i : \u2191s), Finite \u2191(t \u2191i)\n\u22a2 Finite \u2191(\u22c3 x, t \u2191x)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.biUnion' {\u03b9} {s : Set \u03b9} (hs : s.Finite) {t : \u2200 i \u2208 s, Set \u03b1}\n    (ht : \u2200 i (hi : i \u2208 s), (t i hi).Finite) : (\u22c3 i \u2208 s, t i \u2039_\u203a).Finite := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion]\n  apply finite_iUnion fun i : s => ht i.1 i.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\nhs : s.Finite\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set \u03b1\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), (t i hi).Finite\n\u22a2 (\u22c3 i, \u22c3 (h : i \u2208 s), t i h).Finite"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\nhs : s.Finite\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set \u03b1\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), (t i hi).Finite\nthis : Finite \u2191s\n\u22a2 (\u22c3 i, \u22c3 (h : i \u2208 s), t i h).Finite"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : Set \u03b9\nhs : s.Finite\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set \u03b1\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), (t i hi).Finite\nthis : Finite \u2191s\n\u22a2 (\u22c3 x, t \u2191x \u22ef).Finite"}, {"line": "apply finite_iUnion fun i : s => ht i.1 i.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.sUnion {s : Set (Set \u03b1)} (hs : s.Finite) (H : \u2200 t \u2208 s, Set.Finite t) :\n    (\u22c3\u2080 s).Finite := by\n  simpa only [sUnion_eq_biUnion] using hs.biUnion H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set (Set \u03b1)\nhs : s.Finite\nH : \u2200 t \u2208 s, t.Finite\n\u22a2 (\u22c3\u2080 s).Finite"}, {"line": "simpa only [sUnion_eq_biUnion] using hs.biUnion H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.preimage' (h : s.Finite) (hf : \u2200 b \u2208 s, (f \u207b\u00b9' {b}).Finite) :\n    (f \u207b\u00b9' s).Finite := by\n  rw [\u2190 Set.biUnion_preimage_singleton]\n  exact Set.Finite.biUnion h hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : s.Finite\nhf : \u2200 b \u2208 s, (f \u207b\u00b9' {b}).Finite\n\u22a2 (f \u207b\u00b9' s).Finite"}, {"line": "rw [\u2190 Set.biUnion_preimage_singleton]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : s.Finite\nhf : \u2200 b \u2208 s, (f \u207b\u00b9' {b}).Finite\n\u22a2 (\u22c3 y \u2208 s, f \u207b\u00b9' {y}).Finite"}, {"line": "exact Set.Finite.biUnion h hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem union_finset_finite_of_range_finite (f : \u03b1 \u2192 Finset \u03b2) (h : (range f).Finite) :\n    (\u22c3 a, (f a : Set \u03b2)).Finite := by\n  rw [\u2190 biUnion_range]\n  exact h.biUnion fun y _ => y.finite_toSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 Finset \u03b2\nh : (range f).Finite\n\u22a2 (\u22c3 a, \u2191(f a)).Finite"}, {"line": "rw [\u2190 biUnion_range]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nf : \u03b1 \u2192 Finset \u03b2\nh : (range f).Finite\n\u22a2 (\u22c3 x \u2208 range f, \u2191x).Finite"}, {"line": "exact h.biUnion fun y _ => y.finite_toSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_subset_iUnion {s : Set \u03b1} (hs : s.Finite) {\u03b9} {t : \u03b9 \u2192 Set \u03b1} (h : s \u2286 \u22c3 i, t i) :\n    \u2203 I : Set \u03b9, I.Finite \u2227 s \u2286 \u22c3 i \u2208 I, t i := by\n  have := hs.to_subtype\n  choose f hf using show \u2200 x : s, \u2203 i, x.1 \u2208 t i by simpa [subset_def] using h\n  refine \u27e8range f, finite_range f, fun x hx => ?_\u27e9\n  rw [biUnion_range]\n  rw [mem_iUnion]\n  exact \u27e8\u27e8x, hx\u27e9, hf _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\n\u22a2 \u2203 I, I.Finite \u2227 s \u2286 \u22c3 i \u2208 I, t i"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\nthis : Finite \u2191s\n\u22a2 \u2203 I, I.Finite \u2227 s \u2286 \u22c3 i \u2208 I, t i"}, {"line": "choose f hf using show \u2200 x : s, \u2203 i, x.1 \u2208 t i by simpa [subset_def] using h", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\nthis : Finite \u2191s\nf : \u2191s \u2192 \u03b9\nhf : \u2200 (x : \u2191s), \u2191x \u2208 t (f x)\n\u22a2 \u2203 I, I.Finite \u2227 s \u2286 \u22c3 i \u2208 I, t i"}, {"line": "refine \u27e8range f, finite_range f, fun x hx => ?_\u27e9", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\nthis : Finite \u2191s\nf : \u2191s \u2192 \u03b9\nhf : \u2200 (x : \u2191s), \u2191x \u2208 t (f x)\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2208 \u22c3 i \u2208 range f, t i"}, {"line": "rw [biUnion_range]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\nthis : Finite \u2191s\nf : \u2191s \u2192 \u03b9\nhf : \u2200 (x : \u2191s), \u2191x \u2208 t (f x)\nx : \u03b1\nhx : x \u2208 s\n\u22a2 x \u2208 \u22c3 y, t (f y)"}, {"line": "rw [mem_iUnion]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Set \u03b1\nh : s \u2286 \u22c3 i, t i\nthis : Finite \u2191s\nf : \u2191s \u2192 \u03b9\nhf : \u2200 (x : \u2191s), \u2191x \u2208 t (f x)\nx : \u03b1\nhx : x \u2208 s\n\u22a2 \u2203 i, x \u2208 t (f i)"}, {"line": "exact \u27e8\u27e8x, hx\u27e9, hf _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Infinite.biUnion {\u03b9 : Type*} {s : \u03b9 \u2192 Set \u03b1} {a : Set \u03b9} (ha : a.Infinite)\n    (hs : a.InjOn s) : (\u22c3 i \u2208 a, s i).Infinite := by\n  rw [biUnion_eq_iUnion]\n  have _ := ha.to_subtype\n  exact infinite_iUnion fun \u27e8i,hi\u27e9 \u27e8j,hj\u27e9 hij \u21a6 by simp [hs hi hj hij]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\na : Set \u03b9\nha : a.Infinite\nhs : InjOn s a\n\u22a2 (\u22c3 i \u2208 a, s i).Infinite"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\na : Set \u03b9\nha : a.Infinite\nhs : InjOn s a\n\u22a2 (\u22c3 x, s \u2191x).Infinite"}, {"line": "have _ := ha.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\ns : \u03b9 \u2192 Set \u03b1\na : Set \u03b9\nha : a.Infinite\nhs : InjOn s a\nx\u271d : Infinite \u2191a\n\u22a2 (\u22c3 x, s \u2191x).Infinite"}, {"line": "exact infinite_iUnion fun \u27e8i,hi\u27e9 \u27e8j,hj\u27e9 hij \u21a6 by simp [hs hi hj hij]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Infinite.sUnion {s : Set (Set \u03b1)} (hs : s.Infinite) : (\u22c3\u2080 s).Infinite := by\n  rw [sUnion_eq_iUnion]\n  have _ := hs.to_subtype\n  exact infinite_iUnion Subtype.coe_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set (Set \u03b1)\nhs : s.Infinite\n\u22a2 (\u22c3\u2080 s).Infinite"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\ns : Set (Set \u03b1)\nhs : s.Infinite\n\u22a2 (\u22c3 i, \u2191i).Infinite"}, {"line": "have _ := hs.to_subtype", "tactic_state": "\u03b1 : Type u\ns : Set (Set \u03b1)\nhs : s.Infinite\nx\u271d : Infinite \u2191s\n\u22a2 (\u22c3 i, \u2191i).Infinite"}, {"line": "exact infinite_iUnion Subtype.coe_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_iInf_of_monotone {\u03b9 \u03b9' \u03b1 : Type*} [Finite \u03b9] [Preorder \u03b9'] [Nonempty \u03b9']\n    [IsDirected \u03b9' (\u00b7 \u2264 \u00b7)] [Order.Frame \u03b1] {f : \u03b9 \u2192 \u03b9' \u2192 \u03b1} (hf : \u2200 i, Monotone (f i)) :\n    \u2a06 j, \u2a05 i, f i j = \u2a05 i, \u2a06 j, f i j := by\n  simpa only [iInf_univ] using finite_univ.iSup_biInf_of_monotone fun i _ => hf i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b9' : Type u_2\n\u03b1 : Type u_3\ninst\u271d\u2074 : Finite \u03b9\ninst\u271d\u00b3 : Preorder \u03b9'\ninst\u271d\u00b2 : Nonempty \u03b9'\ninst\u271d\u00b9 : IsDirected \u03b9' fun x1 x2 => x1 \u2264 x2\ninst\u271d : Order.Frame \u03b1\nf : \u03b9 \u2192 \u03b9' \u2192 \u03b1\nhf : \u2200 (i : \u03b9), Monotone (f i)\n\u22a2 \u2a06 j, \u2a05 i, f i j = \u2a05 i, \u2a06 j, f i j"}, {"line": "simpa only [iInf_univ] using finite_univ.iSup_biInf_of_monotone fun i _ => hf i", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.finite_diff_iUnion_Ioo' (s : Set \u03b1) : (s \\ \u22c3 x : s \u00d7 s, Ioo x.1 x.2).Finite := by\n  simpa only [iUnion,iSup_prod,iSup_subtype] using s.finite_diff_iUnion_Ioo\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s t : Set \u03b1}", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b1] {s : Set \u03b1}", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] [Nonempty \u03b1] {s : Set \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2076 : Preorder \u03b1\ninst\u271d\u2075 : IsDirected \u03b1 fun x1 x2 => x1 \u2264 x2\ninst\u271d\u2074 : Nonempty \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : IsDirected \u03b1 fun x1 x2 => x1 \u2265 x2\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\n\u22a2 (s \\ \u22c3 x, Ioo \u2191x.1 \u2191x.2).Finite"}, {"line": "simpa only [iUnion,iSup_prod,iSup_subtype] using s.finite_diff_iUnion_Ioo", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DirectedOn.exists_mem_subset_of_finset_subset_biUnion {\u03b1 \u03b9 : Type*} {f : \u03b9 \u2192 Set \u03b1}\n    {c : Set \u03b9} (hn : c.Nonempty) (hc : DirectedOn (fun i j => f i \u2286 f j) c) {s : Finset \u03b1}\n    (hs : (s : Set \u03b1) \u2286 \u22c3 i \u2208 c, f i) : \u2203 i \u2208 c, (s : Set \u03b1) \u2286 f i := by\n  rw [Set.biUnion_eq_iUnion] at hs\n  haveI := hn.coe_sort\n  simpa using (directed_comp.2 hc.directed_val).exists_mem_subset_of_finset_subset_biUnion hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lattice.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s t : Set \u03b1}", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] [Nonempty \u03b1] {s : Set \u03b1}", "[Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2265 \u00b7)] [Nonempty \u03b1] {s : Set \u03b1}", "[LinearOrder \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nf : \u03b9 \u2192 Set \u03b1\nc : Set \u03b9\nhn : c.Nonempty\nhc : DirectedOn (fun i j => f i \u2286 f j) c\ns : Finset \u03b1\nhs : \u2191s \u2286 \u22c3 i \u2208 c, f i\n\u22a2 \u2203 i \u2208 c, \u2191s \u2286 f i"}, {"line": "rw [Set.biUnion_eq_iUnion] at hs", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nf : \u03b9 \u2192 Set \u03b1\nc : Set \u03b9\nhn : c.Nonempty\nhc : DirectedOn (fun i j => f i \u2286 f j) c\ns : Finset \u03b1\nhs : \u2191s \u2286 \u22c3 x, f \u2191x\n\u22a2 \u2203 i \u2208 c, \u2191s \u2286 f i"}, {"line": "haveI := hn.coe_sort", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\nf : \u03b9 \u2192 Set \u03b1\nc : Set \u03b9\nhn : c.Nonempty\nhc : DirectedOn (fun i j => f i \u2286 f j) c\ns : Finset \u03b1\nhs : \u2191s \u2286 \u22c3 x, f \u2191x\nthis : Nonempty \u2191c\n\u22a2 \u2203 i \u2208 c, \u2191s \u2286 f i"}, {"line": "simpa using (directed_comp.2 hc.directed_val).exists_mem_subset_of_finset_subset_biUnion hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.induction_to {C : Set \u03b1 \u2192 Prop} {S : Set \u03b1} (h : S.Finite)\n    (S0 : Set \u03b1) (hS0 : S0 \u2286 S) (H0 : C S0) (H1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)) :\n    C S := by\n  have : Finite S := Finite.to_subtype h\n  have : Finite {T : Set \u03b1 // T \u2286 S} := Finite.of_equiv (Set S) (Equiv.Set.powerset S).symm\n  rw [\u2190 Subtype.coe_mk (p := (\u00b7 \u2286 S)) _ le_rfl]\n  rw [\u2190 Subtype.coe_mk (p := (\u00b7 \u2286 S)) _ hS0] at H0\n  refine Finite.to_wellFoundedGT.wf.induction_bot' (fun s hs hs' \u21a6 ?_) H0\n  obtain \u27e8a, \u27e8ha1, ha2\u27e9, ha'\u27e9 := H1 s (ssubset_of_ne_of_subset hs s.2) hs'\n  exact \u27e8\u27e8insert a s.1, insert_subset ha1 s.2\u27e9, Set.ssubset_insert ha2, ha'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Lemmas.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C S0\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\n\u22a2 C S"}, {"line": "have : Finite S := Finite.to_subtype h", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C S0\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis : Finite \u2191S\n\u22a2 C S"}, {"line": "have : Finite {T : Set \u03b1 // T \u2286 S} := Finite.of_equiv (Set S) (Equiv.Set.powerset S).symm", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C S0\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis\u271d : Finite \u2191S\nthis : Finite { T // T \u2286 S }\n\u22a2 C S"}, {"line": "rw [\u2190 Subtype.coe_mk (p := (\u00b7 \u2286 S)) _ le_rfl]", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C S0\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis\u271d : Finite \u2191S\nthis : Finite { T // T \u2286 S }\n\u22a2 C \u2191\u27e8S, \u22ef\u27e9"}, {"line": "rw [\u2190 Subtype.coe_mk (p := (\u00b7 \u2286 S)) _ hS0] at H0", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C \u2191\u27e8S0, hS0\u27e9\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis\u271d : Finite \u2191S\nthis : Finite { T // T \u2286 S }\n\u22a2 C \u2191\u27e8S, \u22ef\u27e9"}, {"line": "refine Finite.to_wellFoundedGT.wf.induction_bot' (fun s hs hs' \u21a6 ?_) H0", "tactic_state": "\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C \u2191\u27e8S0, hS0\u27e9\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis\u271d : Finite \u2191S\nthis : Finite { T // T \u2286 S }\ns : { x // x \u2286 S }\nhs : \u2191s \u2260 \u2191\u27e8S, \u22ef\u27e9\nhs' : C \u2191s\n\u22a2 \u2203 c > s, C \u2191c"}, {"line": "obtain \u27e8a, \u27e8ha1, ha2\u27e9, ha'\u27e9 := H1 s (ssubset_of_ne_of_subset hs s.2) hs'", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u\nC : Set \u03b1 \u2192 Prop\nS : Set \u03b1\nh : S.Finite\nS0 : Set \u03b1\nhS0 : S0 \u2286 S\nH0 : C \u2191\u27e8S0, hS0\u27e9\nH1 : \u2200 s \u2282 S, C s \u2192 \u2203 a \u2208 S \\ s, C (insert a s)\nthis\u271d : Finite \u2191S\nthis : Finite { T // T \u2286 S }\ns : { x // x \u2286 S }\nhs : \u2191s \u2260 \u2191\u27e8S, \u22ef\u27e9\nhs' : C \u2191s\na : \u03b1\nha' : C (insert a \u2191s)\nha1 : a \u2208 S\nha2 : a \u2209 \u2191s\n\u22a2 \u2203 c > s, C \u2191c"}, {"line": "exact \u27e8\u27e8insert a s.1, insert_subset ha1 s.2\u27e9, Set.ssubset_insert ha2, ha'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma finite_length_le : {l : List \u03b1 | l.length \u2264 n}.Finite := by\n  simpa [Nat.lt_succ_iff] using finite_length_lt \u03b1 (n + 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/List.lean", "context": {"open": [], "variables": ["(\u03b1 : Type*) [Finite \u03b1] (n : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Finite \u03b1\nn : \u2115\n\u22a2 {l | l.length \u2264 n}.Finite"}, {"line": "simpa [Nat.lt_succ_iff] using finite_length_lt \u03b1 (n + 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.finite_subsets {\u03b1 : Type u} {a : Set \u03b1} (h : a.Finite) : { b | b \u2286 a }.Finite := by\n  convert ((Finset.powerset h.toFinset).map Finset.coeEmb.1).finite_toSet\n  ext s\n  simpa [\u2190 @exists_finite_iff_finset \u03b1 fun t => t \u2286 a \u2227 t = s, Finite.subset_toFinset,\n    \u2190 and_assoc, Finset.coeEmb] using h.subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Powerset.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : Set \u03b1\nh : a.Finite\n\u22a2 {b | b \u2286 a}.Finite"}, {"line": "convert ((Finset.powerset h.toFinset).map Finset.coeEmb.1).finite_toSet", "tactic_state": "case h.e'_2\n\u03b1 : Type u\na : Set \u03b1\nh : a.Finite\n\u22a2 {b | b \u2286 a} = \u2191(Finset.map Finset.coeEmb.toEmbedding h.toFinset.powerset)"}, {"line": "ext s", "tactic_state": "case h.e'_2.h\n\u03b1 : Type u\na : Set \u03b1\nh : a.Finite\ns : Set \u03b1\n\u22a2 s \u2208 {b | b \u2286 a} \u2194 s \u2208 \u2191(Finset.map Finset.coeEmb.toEmbedding h.toFinset.powerset)"}, {"line": "simpa [\u2190 @exists_finite_iff_finset \u03b1 fun t => t \u2286 a \u2227 t = s, Finite.subset_toFinset,\n    \u2190 and_assoc, Finset.coeEmb] using h.subset", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.dependent_image {s : Set \u03b1} (hs : s.Finite) (F : \u2200 i \u2208 s, \u03b2) :\n    {y : \u03b2 | \u2203 x hx, F x hx = y}.Finite := by\n  have := hs.to_subtype\n  simpa [range] using finite_range fun x : s => F x x.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Range.lean", "context": {"open": ["Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nhs : s.Finite\nF : (i : \u03b1) \u2192 i \u2208 s \u2192 \u03b2\n\u22a2 {y | \u2203 x, \u2203 (hx : x \u2208 s), F x hx = y}.Finite"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nhs : s.Finite\nF : (i : \u03b1) \u2192 i \u2208 s \u2192 \u03b2\nthis : Finite \u2191s\n\u22a2 {y | \u2203 x, \u2203 (hx : x \u2208 s), F x hx = y}.Finite"}, {"line": "simpa [range] using finite_range fun x : s => F x x.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.toFinset_eq_toFinset {s : Set \u03b1} [Fintype s] (h : s.Finite) :\n    h.toFinset = s.toFinset := by\n  rw [Finite.toFinset]\n  rw [Subsingleton.elim h.fintype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\n\u22a2 h.toFinset = s.toFinset"}, {"line": "rw [Finite.toFinset]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : s.Finite\n\u22a2 s.toFinset = s.toFinset"}, {"line": "rw [Subsingleton.elim h.fintype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.exists_finset {s : Set \u03b1} (h : s.Finite) :\n    \u2203 s' : Finset \u03b1, \u2200 a : \u03b1, a \u2208 s' \u2194 a \u2208 s := by\n  cases h.nonempty_fintype\n  exact \u27e8s.toFinset, fun _ => mem_toFinset\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nh : s.Finite\n\u22a2 \u2203 s', \u2200 (a : \u03b1), a \u2208 s' \u2194 a \u2208 s"}, {"line": "cases h.nonempty_fintype", "tactic_state": "case intro\n\u03b1 : Type u\ns : Set \u03b1\nh : s.Finite\nval\u271d : Fintype \u2191s\n\u22a2 \u2203 s', \u2200 (a : \u03b1), a \u2208 s' \u2194 a \u2208 s"}, {"line": "exact \u27e8s.toFinset, fun _ => mem_toFinset\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.exists_finset_coe {s : Set \u03b1} (h : s.Finite) : \u2203 s' : Finset \u03b1, \u2191s' = s := by\n  cases h.nonempty_fintype\n  exact \u27e8s.toFinset, s.coe_toFinset\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nh : s.Finite\n\u22a2 \u2203 s', \u2191s' = s"}, {"line": "cases h.nonempty_fintype", "tactic_state": "case intro\n\u03b1 : Type u\ns : Set \u03b1\nh : s.Finite\nval\u271d : Fintype \u2191s\n\u22a2 \u2203 s', \u2191s' = s"}, {"line": "exact \u27e8s.toFinset, s.coe_toFinset\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeSort_toFinset : \u21a5hs.toFinset = \u21a5s := by\n  rw [\u2190 Finset.coe_sort_coe _]\n  rw [hs.coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u22a2 { x // x \u2208 hs.toFinset } = \u2191s"}, {"line": "rw [\u2190 Finset.coe_sort_coe _]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\n\u22a2 \u2191\u2191hs.toFinset = \u2191s"}, {"line": "rw [hs.coe_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_subset {t : Finset \u03b1} : hs.toFinset \u2286 t \u2194 s \u2286 t := by\n  rw [\u2190 Finset.coe_subset]\n  rw [Finite.coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\nt : Finset \u03b1\n\u22a2 hs.toFinset \u2286 t \u2194 s \u2286 \u2191t"}, {"line": "rw [\u2190 Finset.coe_subset]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\nt : Finset \u03b1\n\u22a2 \u2191hs.toFinset \u2286 \u2191t \u2194 s \u2286 \u2191t"}, {"line": "rw [Finite.coe_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toFinset_ssubset {t : Finset \u03b1} : hs.toFinset \u2282 t \u2194 s \u2282 t := by\n  rw [\u2190 Finset.coe_ssubset]\n  rw [Finite.coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\nt : Finset \u03b1\n\u22a2 hs.toFinset \u2282 t \u2194 s \u2282 \u2191t"}, {"line": "rw [\u2190 Finset.coe_ssubset]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Finite\nt : Finset \u03b1\n\u22a2 \u2191hs.toFinset \u2282 \u2191t \u2194 s \u2282 \u2191t"}, {"line": "rw [Finite.coe_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_toFinset {s : Finset \u03b1} : s \u2286 ht.toFinset \u2194 \u2191s \u2286 t := by\n  rw [\u2190 Finset.coe_subset]\n  rw [Finite.coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\nht : t.Finite\ns : Finset \u03b1\n\u22a2 s \u2286 ht.toFinset \u2194 \u2191s \u2286 t"}, {"line": "rw [\u2190 Finset.coe_subset]", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\nht : t.Finite\ns : Finset \u03b1\n\u22a2 \u2191s \u2286 \u2191ht.toFinset \u2194 \u2191s \u2286 t"}, {"line": "rw [Finite.coe_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ssubset_toFinset {s : Finset \u03b1} : s \u2282 ht.toFinset \u2194 \u2191s \u2282 t := by\n  rw [\u2190 Finset.coe_ssubset]\n  rw [Finite.coe_toFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\nht : t.Finite\ns : Finset \u03b1\n\u22a2 s \u2282 ht.toFinset \u2194 \u2191s \u2282 t"}, {"line": "rw [\u2190 Finset.coe_ssubset]", "tactic_state": "\u03b1 : Type u\nt : Set \u03b1\nht : t.Finite\ns : Finset \u03b1\n\u22a2 \u2191s \u2282 \u2191ht.toFinset \u2194 \u2191s \u2282 t"}, {"line": "rw [Finite.coe_toFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u00abforall\u00bb {p : Finset \u03b1 \u2192 Prop} :\n    (\u2200 s, p s) \u2194 \u2200 (s : Set \u03b1) (hs : s.Finite), p hs.toFinset where\n  mp h s hs := h _\n  mpr h s := by simpa using h s s.finite_toSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : Finset \u03b1 \u2192 Prop\nh : \u2200 (s : Set \u03b1) (hs : s.Finite), p hs.toFinset\ns : Finset \u03b1\n\u22a2 p s"}, {"line": "simpa using h s s.finite_toSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_toSet (s : Multiset \u03b1) : { x | x \u2208 s }.Finite := by\n  classical simpa only [\u2190 Multiset.mem_toFinset] using s.toFinset.finite_toSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Multiset \u03b1\n\u22a2 {x | x \u2208 s}.Finite"}, {"line": "classical simpa only [\u2190 Multiset.mem_toFinset] using s.toFinset.finite_toSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_toSet_toFinset [DecidableEq \u03b1] (s : Multiset \u03b1) :\n    s.finite_toSet.toFinset = s.toFinset := by\n  ext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\n\u22a2 \u22ef.toFinset = s.toFinset"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Multiset \u03b1\nx : \u03b1\n\u22a2 x \u2208 \u22ef.toFinset \u2194 x \u2208 s.toFinset"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.subset {s : Set \u03b1} (hs : s.Finite) {t : Set \u03b1} (ht : t \u2286 s) : t.Finite := by\n  have := hs.to_subtype\n  exact Finite.Set.subset _ ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nt : Set \u03b1\nht : t \u2286 s\n\u22a2 t.Finite"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nt : Set \u03b1\nht : t \u2286 s\nthis : Finite \u2191s\n\u22a2 t.Finite"}, {"line": "exact Finite.Set.subset _ ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.union (hs : s.Finite) (ht : t.Finite) : (s \u222a t).Finite := by\n  rw [Set.Finite] at hs ht\n  apply toFinite\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nhs : s.Finite\nht : t.Finite\n\u22a2 (s \u222a t).Finite"}, {"line": "rw [Set.Finite] at hs ht", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\nhs : Finite \u2191s\nht : Finite \u2191t\n\u22a2 (s \u222a t).Finite"}, {"line": "apply toFinite", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.finite_of_compl {s : Set \u03b1} (hs : s.Finite) (hsc : s\u1d9c.Finite) : Finite \u03b1 := by\n  rw [\u2190 finite_univ_iff]\n  rw [\u2190 union_compl_self s]\n  exact hs.union hsc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nhsc : s\u1d9c.Finite\n\u22a2 Finite \u03b1"}, {"line": "rw [\u2190 finite_univ_iff]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nhsc : s\u1d9c.Finite\n\u22a2 univ.Finite"}, {"line": "rw [\u2190 union_compl_self s]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nhs : s.Finite\nhsc : s\u1d9c.Finite\n\u22a2 (s \u222a s\u1d9c).Finite"}, {"line": "exact hs.union hsc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_of_finite_preimage (h : (f \u207b\u00b9' s).Finite) (hs : s \u2286 range f) : s.Finite := by\n  rw [\u2190 image_preimage_eq_of_subset hs]\n  exact Finite.image f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : (f \u207b\u00b9' s).Finite\nhs : s \u2286 range f\n\u22a2 s.Finite"}, {"line": "rw [\u2190 image_preimage_eq_of_subset hs]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\nh : (f \u207b\u00b9' s).Finite\nhs : s \u2286 range f\n\u22a2 (f '' (f \u207b\u00b9' s)).Finite"}, {"line": "exact Finite.image f h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.surjOn_iff_bijOn_of_mapsTo (hs : s.Finite) (hm : MapsTo f s s) :\n    SurjOn f s s \u2194 BijOn f s s := by\n  refine \u27e8fun h \u21a6 \u27e8hm, ?_, h\u27e9, BijOn.surjOn\u27e9\n  have : Finite s := finite_coe_iff.mpr hs\n  exact hm.restrict_inj.mp (Finite.injective_iff_surjective.mpr <| hm.restrict_surjective_iff.mpr h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\n\u22a2 SurjOn f s s \u2194 BijOn f s s"}, {"line": "refine \u27e8fun h \u21a6 \u27e8hm, ?_, h\u27e9, BijOn.surjOn\u27e9", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\nh : SurjOn f s s\n\u22a2 InjOn f s"}, {"line": "have : Finite s := finite_coe_iff.mpr hs", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\nh : SurjOn f s s\nthis : Finite \u2191s\n\u22a2 InjOn f s"}, {"line": "exact hm.restrict_inj.mp (Finite.injective_iff_surjective.mpr <| hm.restrict_surjective_iff.mpr h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.injOn_iff_bijOn_of_mapsTo (hs : s.Finite) (hm : MapsTo f s s) :\n    InjOn f s \u2194 BijOn f s s := by\n  refine \u27e8fun h \u21a6 \u27e8hm, h, ?_\u27e9, BijOn.injOn\u27e9\n  have : Finite s := finite_coe_iff.mpr hs\n  exact hm.restrict_surjective_iff.mp (Finite.injective_iff_surjective.mp <| hm.restrict_inj.mpr h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\n\u22a2 InjOn f s \u2194 BijOn f s s"}, {"line": "refine \u27e8fun h \u21a6 \u27e8hm, h, ?_\u27e9, BijOn.injOn\u27e9", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\nh : InjOn f s\n\u22a2 SurjOn f s s"}, {"line": "have : Finite s := finite_coe_iff.mpr hs", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\nhs : s.Finite\nhm : MapsTo f s s\nh : InjOn f s\nthis : Finite \u2191s\n\u22a2 SurjOn f s s"}, {"line": "exact hm.restrict_surjective_iff.mp (Finite.injective_iff_surjective.mp <| hm.restrict_inj.mpr h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.induction_on {motive : \u2200 s : Set \u03b1, s.Finite \u2192 Prop} (s : Set \u03b1) (hs : s.Finite)\n    (empty : motive \u2205 finite_empty)\n    (insert : \u2200 {a s}, a \u2209 s \u2192\n      \u2200 hs : Set.Finite s, motive s hs \u2192 motive (insert a s) (hs.insert a)) :\n    motive s hs := by\n  lift s to Finset \u03b1 using id hs\n  induction' s using Finset.cons_induction_on with a s ha ih\n  \u00b7 simpa\n  \u00b7 simpa using @insert a s ha (Set.toFinite _) (ih _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\ns : Set \u03b1\nhs : s.Finite\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {s : Set \u03b1}, a \u2209 s \u2192 \u2200 (hs : s.Finite), motive s hs \u2192 motive (Insert.insert a s) \u22ef\n\u22a2 motive s hs"}, {"line": "lift s to Finset \u03b1 using id hs", "tactic_state": "case intro\n\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {s : Set \u03b1}, a \u2209 s \u2192 \u2200 (hs : s.Finite), motive s hs \u2192 motive (Insert.insert a s) \u22ef\ns : Finset \u03b1\nhs : (\u2191s).Finite\n\u22a2 motive (\u2191s) hs"}, {"line": "induction' s using Finset.cons_induction_on with a s ha ih", "tactic_state": "case intro.empty\n\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {s : Set \u03b1}, a \u2209 s \u2192 \u2200 (hs : s.Finite), motive s hs \u2192 motive (Insert.insert a s) \u22ef\nhs : (\u2191\u2205).Finite\n\u22a2 motive (\u2191\u2205) hs\n---\ncase intro.cons\n\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {s : Set \u03b1}, a \u2209 s \u2192 \u2200 (hs : s.Finite), motive s hs \u2192 motive (Insert.insert a s) \u22ef\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nih : \u2200 (hs : (\u2191s).Finite), motive (\u2191s) hs\nhs : (\u2191(Finset.cons a s ha)).Finite\n\u22a2 motive (\u2191(Finset.cons a s ha)) hs"}, {"line": "\u00b7 simpa", "tactic_state": "case intro.cons\n\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {s : Set \u03b1}, a \u2209 s \u2192 \u2200 (hs : s.Finite), motive s hs \u2192 motive (Insert.insert a s) \u22ef\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nih : \u2200 (hs : (\u2191s).Finite), motive (\u2191s) hs\nhs : (\u2191(Finset.cons a s ha)).Finite\n\u22a2 motive (\u2191(Finset.cons a s ha)) hs"}, {"line": "\u00b7 simpa using @insert a s ha (Set.toFinite _) (ih _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finite.induction_on_subset {motive : \u2200 s : Set \u03b1, s.Finite \u2192 Prop} (s : Set \u03b1)\n    (hs : s.Finite) (empty : motive \u2205 finite_empty)\n    (insert : \u2200 {a t}, a \u2208 s \u2192 \u2200 hts : t \u2286 s, a \u2209 t \u2192 motive t (hs.subset hts) \u2192\n      motive (insert a t) ((hs.subset hts).insert a)) : motive s hs := by\n  refine Set.Finite.induction_on (motive := fun t _ => \u2200 hts : t \u2286 s, motive t (hs.subset hts)) s hs\n    (fun _ => empty) ?_ .rfl\n  intro a s has _ hCs haS\n  rw [insert_subset_iff] at haS\n  exact insert haS.1 haS.2 has (hCs haS.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\ns : Set \u03b1\nhs : s.Finite\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {t : Set \u03b1}, a \u2208 s \u2192 \u2200 (hts : t \u2286 s), a \u2209 t \u2192 motive t \u22ef \u2192 motive (Insert.insert a t) \u22ef\n\u22a2 motive s hs"}, {"line": "refine Set.Finite.induction_on (motive := fun t _ => \u2200 hts : t \u2286 s, motive t (hs.subset hts)) s hs\n    (fun _ => empty) ?_ .rfl", "tactic_state": "\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\ns : Set \u03b1\nhs : s.Finite\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {t : Set \u03b1}, a \u2208 s \u2192 \u2200 (hts : t \u2286 s), a \u2209 t \u2192 motive t \u22ef \u2192 motive (Insert.insert a t) \u22ef\n\u22a2 \u2200 {a : \u03b1} {s_1 : Set \u03b1},\n    a \u2209 s_1 \u2192\n      \u2200 (hs_1 : s_1.Finite),\n        (fun t x => \u2200 (hts : t \u2286 s), motive t \u22ef) s_1 hs_1 \u2192\n          (fun t x => \u2200 (hts : t \u2286 s), motive t \u22ef) (Insert.insert a s_1) \u22ef"}, {"line": "intro a s has _ hCs haS", "tactic_state": "\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\ns\u271d : Set \u03b1\nhs : s\u271d.Finite\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {t : Set \u03b1}, a \u2208 s\u271d \u2192 \u2200 (hts : t \u2286 s\u271d), a \u2209 t \u2192 motive t \u22ef \u2192 motive (Insert.insert a t) \u22ef\na : \u03b1\ns : Set \u03b1\nhas : a \u2209 s\nhs\u271d : s.Finite\nhCs : \u2200 (hts : s \u2286 s\u271d), motive s \u22ef\nhaS : Insert.insert a s \u2286 s\u271d\n\u22a2 motive (Insert.insert a s) \u22ef"}, {"line": "rw [insert_subset_iff] at haS", "tactic_state": "\u03b1 : Type u_1\nmotive : (s : Set \u03b1) \u2192 s.Finite \u2192 Prop\ns\u271d : Set \u03b1\nhs : s\u271d.Finite\nempty : motive \u2205 \u22ef\ninsert : \u2200 {a : \u03b1} {t : Set \u03b1}, a \u2208 s\u271d \u2192 \u2200 (hts : t \u2286 s\u271d), a \u2209 t \u2192 motive t \u22ef \u2192 motive (Insert.insert a t) \u22ef\na : \u03b1\ns : Set \u03b1\nhas : a \u2209 s\nhs\u271d : s.Finite\nhCs : \u2200 (hts : s \u2286 s\u271d), motive s \u22ef\nhaS\u271d : Insert.insert a s \u2286 s\u271d\nhaS : a \u2208 s\u271d \u2227 s \u2286 s\u271d\n\u22a2 motive (Insert.insert a s) \u22ef"}, {"line": "exact insert haS.1 haS.2 has (hCs haS.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seq_of_forall_finite_exists {\u03b3 : Type*} {P : \u03b3 \u2192 Set \u03b3 \u2192 Prop}\n    (h : \u2200 t : Set \u03b3, t.Finite \u2192 \u2203 c, P c t) : \u2203 u : \u2115 \u2192 \u03b3, \u2200 n, P (u n) (u '' Iio n) := by\n  haveI : Nonempty \u03b3 := (h \u2205 finite_empty).nonempty\n  choose! c hc using h\n  set f : (n : \u2115) \u2192 (g : (m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k : Iio n => g k.1 k.2)\n  set u : \u2115 \u2192 \u03b3 := fun n => Nat.strongRecOn' n f\n  refine \u27e8u, fun n => ?_\u27e9\n  convert hc (u '' Iio n) ((finite_lt_nat _).image _)\n  rw [image_eq_range]\n  exact Nat.strongRecOn'_beta\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nh : \u2200 (t : Set \u03b3), t.Finite \u2192 \u2203 c, P c t\n\u22a2 \u2203 u, \u2200 (n : \u2115), P (u n) (u '' Iio n)"}, {"line": "haveI : Nonempty \u03b3 := (h \u2205 finite_empty).nonempty", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nh : \u2200 (t : Set \u03b3), t.Finite \u2192 \u2203 c, P c t\nthis : Nonempty \u03b3\n\u22a2 \u2203 u, \u2200 (n : \u2115), P (u n) (u '' Iio n)"}, {"line": "choose! c hc using h", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\n\u22a2 \u2203 u, \u2200 (n : \u2115), P (u n) (u '' Iio n)"}, {"line": "set f : (n : \u2115) \u2192 (g : (m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k : Iio n => g k.1 k.2)", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\nf : (n : \u2115) \u2192 ((m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k => g \u2191k \u22ef)\n\u22a2 \u2203 u, \u2200 (n : \u2115), P (u n) (u '' Iio n)"}, {"line": "set u : \u2115 \u2192 \u03b3 := fun n => Nat.strongRecOn' n f", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\nf : (n : \u2115) \u2192 ((m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k => g \u2191k \u22ef)\nu : \u2115 \u2192 \u03b3 := fun n => n.strongRecOn' f\n\u22a2 \u2203 u, \u2200 (n : \u2115), P (u n) (u '' Iio n)"}, {"line": "refine \u27e8u, fun n => ?_\u27e9", "tactic_state": "\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\nf : (n : \u2115) \u2192 ((m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k => g \u2191k \u22ef)\nu : \u2115 \u2192 \u03b3 := fun n => n.strongRecOn' f\nn : \u2115\n\u22a2 P (u n) (u '' Iio n)"}, {"line": "convert hc (u '' Iio n) ((finite_lt_nat _).image _)", "tactic_state": "case h.e'_1\n\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\nf : (n : \u2115) \u2192 ((m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k => g \u2191k \u22ef)\nu : \u2115 \u2192 \u03b3 := fun n => n.strongRecOn' f\nn : \u2115\n\u22a2 u n = c (u '' Iio n)"}, {"line": "rw [image_eq_range]", "tactic_state": "case h.e'_1\n\u03b3 : Type u_1\nP : \u03b3 \u2192 Set \u03b3 \u2192 Prop\nthis : Nonempty \u03b3\nc : Set \u03b3 \u2192 \u03b3\nhc : \u2200 (t : Set \u03b3), t.Finite \u2192 P (c t) t\nf : (n : \u2115) \u2192 ((m : \u2115) \u2192 m < n \u2192 \u03b3) \u2192 \u03b3 := fun n g => c (range fun k => g \u2191k \u22ef)\nu : \u2115 \u2192 \u03b3 := fun n => n.strongRecOn' f\nn : \u2115\n\u22a2 u n = c (range fun x => u \u2191x)"}, {"line": "exact Nat.strongRecOn'_beta", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintypeInsertOfNotMem {a : \u03b1} (s : Set \u03b1) [Fintype s] (h : a \u2209 s) :\n    @Fintype.card _ (fintypeInsertOfNotMem s h) = Fintype.card s + 1 := by\n  simp [fintypeInsertOfNotMem, Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\nh : a \u2209 s\n\u22a2 Fintype.card \u2191(insert a s) = Fintype.card \u2191s + 1"}, {"line": "simp [fintypeInsertOfNotMem, Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_ne_eq [Fintype \u03b1] (a : \u03b1) [Fintype { x : \u03b1 | x \u2260 a }] :\n    Fintype.card { x : \u03b1 | x \u2260 a } = Fintype.card \u03b1 - 1 := by\n  haveI := Classical.decEq \u03b1\n  rw [\u2190 toFinset_card]\n  rw [toFinset_setOf]\n  rw [Finset.filter_ne']\n  rw [Finset.card_erase_of_mem (Finset.mem_univ _)]\n  rw [Finset.card_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\n\u22a2 Fintype.card \u2191{x | x \u2260 a} = Fintype.card \u03b1 - 1"}, {"line": "haveI := Classical.decEq \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 Fintype.card \u2191{x | x \u2260 a} = Fintype.card \u03b1 - 1"}, {"line": "rw [\u2190 toFinset_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 {x | x \u2260 a}.toFinset.card = Fintype.card \u03b1 - 1"}, {"line": "rw [toFinset_setOf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 {x | x \u2260 a}.card = Fintype.card \u03b1 - 1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 Fintype \u03b1"}, {"line": "rw [Finset.filter_ne']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 (Finset.univ.erase a).card = Fintype.card \u03b1 - 1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 Fintype \u03b1"}, {"line": "rw [Finset.card_erase_of_mem (Finset.mem_univ _)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 Finset.univ.card - 1 = Fintype.card \u03b1 - 1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : Fintype \u03b1\na : \u03b1\ninst\u271d : Fintype \u2191{x | x \u2260 a}\nthis : DecidableEq \u03b1\n\u22a2 Fintype \u03b1"}, {"line": "rw [Finset.card_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_univ_iff : (@univ \u03b1).Infinite \u2194 Infinite \u03b1 := by\n  rw [Set.Infinite]\n  rw [finite_univ_iff]\n  rw [not_finite_iff_infinite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 univ.Infinite \u2194 Infinite \u03b1"}, {"line": "rw [Set.Infinite]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acuniv.Finite \u2194 Infinite \u03b1"}, {"line": "rw [finite_univ_iff]", "tactic_state": "\u03b1 : Type u_1\n\u22a2 \u00acFinite \u03b1 \u2194 Infinite \u03b1"}, {"line": "rw [not_finite_iff_infinite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_union {s t : Set \u03b1} : (s \u222a t).Infinite \u2194 s.Infinite \u2228 t.Infinite := by\n  simp only [Set.Infinite]\n  simp only [finite_union]\n  simp only [not_and_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns t : Set \u03b1\n\u22a2 (s \u222a t).Infinite \u2194 s.Infinite \u2228 t.Infinite"}, {"line": "simp only [Set.Infinite]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns t : Set \u03b1\n\u22a2 \u00ac(s \u222a t).Finite \u2194 \u00acs.Finite \u2228 \u00act.Finite"}, {"line": "simp only [finite_union]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Infinite \u03b1\ns t : Set \u03b1\n\u22a2 \u00ac(s.Finite \u2227 t.Finite) \u2194 \u00acs.Finite \u2228 \u00act.Finite"}, {"line": "simp only [not_and_or]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_range_iff {f : \u03b1 \u2192 \u03b2} (hi : Injective f) :\n    (range f).Infinite \u2194 Infinite \u03b1 := by\n  rw [\u2190 image_univ]\n  rw [infinite_image_iff hi.injOn]\n  rw [infinite_univ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 (range f).Infinite \u2194 Infinite \u03b1"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 (f '' univ).Infinite \u2194 Infinite \u03b1"}, {"line": "rw [infinite_image_iff hi.injOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 univ.Infinite \u2194 Infinite \u03b1"}, {"line": "rw [infinite_univ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Infinite.exists_ne_map_eq_of_mapsTo {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hs : s.Infinite)\n    (hf : MapsTo f s t) (ht : t.Finite) : \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y := by\n  contrapose! ht\n  exact infinite_of_injOn_mapsTo (fun x hx y hy => not_imp_not.1 (ht x hx y hy)) hf hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhs : s.Infinite\nhf : MapsTo f s t\nht : t.Finite\n\u22a2 \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y"}, {"line": "contrapose! ht", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\ns : Set \u03b1\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhs : s.Infinite\nhf : MapsTo f s t\nht : \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2260 y \u2192 f x \u2260 f y\n\u22a2 \u00act.Finite"}, {"line": "exact infinite_of_injOn_mapsTo (fun x hx y hy => not_imp_not.1 (ht x hx y hy)) hf hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_range_of_injective [Infinite \u03b1] {f : \u03b1 \u2192 \u03b2} (hi : Injective f) :\n    (range f).Infinite := by\n  rw [\u2190 image_univ]\n  rw [infinite_image_iff hi.injOn]\n  exact infinite_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 (range f).Infinite"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 (f '' univ).Infinite"}, {"line": "rw [infinite_image_iff hi.injOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\n\u22a2 univ.Infinite"}, {"line": "exact infinite_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_of_injective_forall_mem [Infinite \u03b1] {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hi : Injective f)\n    (hf : \u2200 x : \u03b1, f x \u2208 s) : s.Infinite := by\n  rw [\u2190 range_subset_iff] at hf\n  exact (infinite_range_of_injective hi).mono hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : Infinite \u03b1\ns : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\nhf : \u2200 (x : \u03b1), f x \u2208 s\n\u22a2 s.Infinite"}, {"line": "rw [\u2190 range_subset_iff] at hf", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 inst\u271d : Infinite \u03b1\ns : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nhi : Injective f\nhf : range f \u2286 s\n\u22a2 s.Infinite"}, {"line": "exact (infinite_range_of_injective hi).mono hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_injOn_infinite_finite_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h_inf : s.Infinite)\n    (h_fin : (f '' s).Finite) : \u00acInjOn f s := by\n  have : Finite (f '' s) := finite_coe_iff.mpr h_fin\n  have : Infinite s := infinite_coe_iff.mpr h_inf\n  have h := not_injective_infinite_finite\n            ((f '' s).codRestrict (s.restrict f) fun x => \u27e8x, x.property, rfl\u27e9)\n  contrapose! h\n  rwa [injective_codRestrict, \u2190 injOn_iff_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Finite/Basic.lean", "context": {"open": ["Set Function", "scoped symmDiff", "scoped symmDiff in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w} {\u03b3 : Type x}", "{s t : Set \u03b1} {a : \u03b1} (hs : s.Finite) {ht : t.Finite}", "{hs}", "{s t u : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}", "{s : Set \u03b1} {f : \u03b1 \u2192 \u03b1}", "{s t : Set \u03b1}", "[Infinite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh_inf : s.Infinite\nh_fin : (f '' s).Finite\n\u22a2 \u00acInjOn f s"}, {"line": "have : Finite (f '' s) := finite_coe_iff.mpr h_fin", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh_inf : s.Infinite\nh_fin : (f '' s).Finite\nthis : Finite \u2191(f '' s)\n\u22a2 \u00acInjOn f s"}, {"line": "have : Infinite s := infinite_coe_iff.mpr h_inf", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh_inf : s.Infinite\nh_fin : (f '' s).Finite\nthis\u271d : Finite \u2191(f '' s)\nthis : Infinite \u2191s\n\u22a2 \u00acInjOn f s"}, {"line": "have h := not_injective_infinite_finite\n            ((f '' s).codRestrict (s.restrict f) fun x => \u27e8x, x.property, rfl\u27e9)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh_inf : s.Infinite\nh_fin : (f '' s).Finite\nthis\u271d : Finite \u2191(f '' s)\nthis : Infinite \u2191s\nh : \u00acInjective (codRestrict (s.restrict f) (f '' s) \u22ef)\n\u22a2 \u00acInjOn f s"}, {"line": "contrapose! h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : Infinite \u03b1\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nh_inf : s.Infinite\nh_fin : (f '' s).Finite\nthis\u271d : Finite \u2191(f '' s)\nthis : Infinite \u2191s\nh : InjOn f s\n\u22a2 Injective (codRestrict (s.restrict f) (f '' s) \u22ef)"}, {"line": "rwa [injective_codRestrict, \u2190 injOn_iff_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma kernImage_compl {s : Set \u03b1} : kernImage f (s\u1d9c) = (f '' s)\u1d9c := by\n  rw [kernImage_eq_compl]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 kernImage f s\u1d9c = (f '' s)\u1d9c"}, {"line": "rw [kernImage_eq_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 (f '' s\u1d9c\u1d9c)\u1d9c = (f '' s)\u1d9c"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma kernImage_empty : kernImage f \u2205 = (range f)\u1d9c := by\n  rw [kernImage_eq_compl]\n  rw [compl_empty]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 kernImage f \u2205 = (range f)\u1d9c"}, {"line": "rw [kernImage_eq_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (f '' \u2205\u1d9c)\u1d9c = (range f)\u1d9c"}, {"line": "rw [compl_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (f '' univ)\u1d9c = (range f)\u1d9c"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma kernImage_preimage_eq_iff {s : Set \u03b2} : kernImage f (f \u207b\u00b9' s) = s \u2194 (range f)\u1d9c \u2286 s := by\n  rw [kernImage_eq_compl]\n  rw [\u2190 preimage_compl]\n  rw [compl_eq_comm]\n  rw [eq_comm]\n  rw [image_preimage_eq_iff]\n  rw [compl_subset_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 kernImage f (f \u207b\u00b9' s) = s \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [kernImage_eq_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 (f '' (f \u207b\u00b9' s)\u1d9c)\u1d9c = s \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [\u2190 preimage_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 (f '' (f \u207b\u00b9' s\u1d9c))\u1d9c = s \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [compl_eq_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 s\u1d9c = f '' (f \u207b\u00b9' s\u1d9c) \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [eq_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f '' (f \u207b\u00b9' s\u1d9c) = s\u1d9c \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [image_preimage_eq_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 s\u1d9c \u2286 range f \u2194 (range f)\u1d9c \u2286 s"}, {"line": "rw [compl_subset_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma compl_range_subset_kernImage {s : Set \u03b1} : (range f)\u1d9c \u2286 kernImage f s := by\n  rw [\u2190 kernImage_empty]\n  exact kernImage_mono (empty_subset _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 (range f)\u1d9c \u2286 kernImage f s"}, {"line": "rw [\u2190 kernImage_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\n\u22a2 kernImage f \u2205 \u2286 kernImage f s"}, {"line": "exact kernImage_mono (empty_subset _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma kernImage_union_preimage {s : Set \u03b1} {t : Set \u03b2} :\n    kernImage f (s \u222a f \u207b\u00b9' t) = kernImage f s \u222a t := by\n  rw [kernImage_eq_compl]\n  rw [kernImage_eq_compl]\n  rw [compl_union]\n  rw [\u2190 preimage_compl]\n  rw [image_inter_preimage]\n  rw [compl_inter]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 kernImage f (s \u222a f \u207b\u00b9' t) = kernImage f s \u222a t"}, {"line": "rw [kernImage_eq_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' (s \u222a f \u207b\u00b9' t)\u1d9c)\u1d9c = kernImage f s \u222a t"}, {"line": "rw [kernImage_eq_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' (s \u222a f \u207b\u00b9' t)\u1d9c)\u1d9c = (f '' s\u1d9c)\u1d9c \u222a t"}, {"line": "rw [compl_union]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' (s\u1d9c \u2229 (f \u207b\u00b9' t)\u1d9c))\u1d9c = (f '' s\u1d9c)\u1d9c \u222a t"}, {"line": "rw [\u2190 preimage_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' (s\u1d9c \u2229 f \u207b\u00b9' t\u1d9c))\u1d9c = (f '' s\u1d9c)\u1d9c \u222a t"}, {"line": "rw [image_inter_preimage]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' s\u1d9c \u2229 t\u1d9c)\u1d9c = (f '' s\u1d9c)\u1d9c \u222a t"}, {"line": "rw [compl_inter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 (f '' s\u1d9c)\u1d9c \u222a t\u1d9c\u1d9c = (f '' s\u1d9c)\u1d9c \u222a t"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma kernImage_preimage_union {s : Set \u03b1} {t : Set \u03b2} :\n    kernImage f (f \u207b\u00b9' t \u222a s) = t \u222a kernImage f s := by\n  rw [union_comm]\n  rw [kernImage_union_preimage]\n  rw [union_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 kernImage f (f \u207b\u00b9' t \u222a s) = t \u222a kernImage f s"}, {"line": "rw [union_comm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 kernImage f (s \u222a f \u207b\u00b9' t) = t \u222a kernImage f s"}, {"line": "rw [kernImage_union_preimage]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 kernImage f s \u222a t = t \u222a kernImage f s"}, {"line": "rw [union_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_projection_prod {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {v : \u2200 i : \u03b9, Set (\u03b1 i)}\n    (hv : (pi univ v).Nonempty) (i : \u03b9) :\n    ((fun x : \u2200 i : \u03b9, \u03b1 i => x i) '' \u22c2 k, (fun x : \u2200 j : \u03b9, \u03b1 j => x k) \u207b\u00b9' v k) = v i := by\n  classical\n    apply Subset.antisymm\n    \u00b7 simp [iInter_subset]\n    \u00b7 intro y y_in\n      simp only [mem_image]\n      simp only [mem_iInter]\n      simp only [mem_preimage]\n      rcases hv with \u27e8z, hz\u27e9\n      refine \u27e8Function.update z i y, ?_, update_self i y z\u27e9\n      rw [@forall_update_iff \u03b9 \u03b1 _ z i y fun i t => t \u2208 v i]\n      exact \u27e8y_in, fun j _ => by simpa using hz j\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_9\n\u03b1 : \u03b9 \u2192 Type u_10\nv : (i : \u03b9) \u2192 Set (\u03b1 i)\nhv : (univ.pi v).Nonempty\ni : \u03b9\n\u22a2 (fun x => x i) '' \u22c2 k, (fun x => x k) \u207b\u00b9' v k = v i"}, {"line": "classical\n    apply Subset.antisymm\n    \u00b7 simp [iInter_subset]\n    \u00b7 intro y y_in\n      simp only [mem_image]\n      simp only [mem_iInter]\n      simp only [mem_preimage]\n      rcases hv with \u27e8z, hz\u27e9\n      refine \u27e8Function.update z i y, ?_, update_self i y z\u27e9\n      rw [@forall_update_iff \u03b9 \u03b1 _ z i y fun i t => t \u2208 v i]\n      exact \u27e8y_in, fun j _ => by simpa using hz j\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_sInter_subset (S : Set (Set \u03b1)) (f : \u03b1 \u2192 \u03b2) : f '' \u22c2\u2080 S \u2286 \u22c2 s \u2208 S, f '' s := by\n  rw [sInter_eq_biInter]\n  apply image_iInter\u2082_subset\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u22c2\u2080 S \u2286 \u22c2 s \u2208 S, f '' s"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nf : \u03b1 \u2192 \u03b2\n\u22a2 f '' \u22c2 i \u2208 S, i \u2286 \u22c2 s \u2208 S, f '' s"}, {"line": "apply image_iInter\u2082_subset", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sInter_right_subset (t : Set \u03b1) (S : Set (Set \u03b2)) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    image2 f t (\u22c2\u2080 S) \u2286 \u22c2 s \u2208 S, image2 f t s := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nt : Set \u03b1\nS : Set (Set \u03b2)\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 image2 f t (\u22c2\u2080 S) \u2286 \u22c2 s \u2208 S, image2 f t s"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sInter_left_subset (S : Set (Set \u03b1)) (t : Set \u03b2)  (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    image2 f (\u22c2\u2080 S) t \u2286 \u22c2 s \u2208 S, image2 f s t := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nS : Set (Set \u03b1)\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\n\u22a2 image2 f (\u22c2\u2080 S) t \u2286 \u22c2 s \u2208 S, image2 f s t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injective_iff_injective_of_iUnion_eq_univ :\n    Injective f \u2194 \u2200 i, Injective ((U i).restrictPreimage f) := by\n  refine \u27e8fun H i => (U i).restrictPreimage_injective H, fun H x y e => ?_\u27e9\n  obtain \u27e8i, hi\u27e9 := Set.mem_iUnion.mp\n      (show f x \u2208 Set.iUnion U by rw [hU]; trivial)\n  injection @H i \u27e8x, hi\u27e9 \u27e8y, show f y \u2208 U i from e \u25b8 hi\u27e9 (Subtype.ext e)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\n\u22a2 Injective f \u2194 \u2200 (i : \u03b9), Injective ((U i).restrictPreimage f)"}, {"line": "refine \u27e8fun H i => (U i).restrictPreimage_injective H, fun H x y e => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\nH : \u2200 (i : \u03b9), Injective ((U i).restrictPreimage f)\nx y : \u03b1\ne : f x = f y\n\u22a2 x = y"}, {"line": "obtain \u27e8i, hi\u27e9 := Set.mem_iUnion.mp\n      (show f x \u2208 Set.iUnion U by rw [hU]; trivial)", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\nH : \u2200 (i : \u03b9), Injective ((U i).restrictPreimage f)\nx y : \u03b1\ne : f x = f y\ni : \u03b9\nhi : f x \u2208 U i\n\u22a2 x = y"}, {"line": "injection @H i \u27e8x, hi\u27e9 \u27e8y, show f y \u2208 U i from e \u25b8 hi\u27e9 (Subtype.ext e)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjective_iff_surjective_of_iUnion_eq_univ :\n    Surjective f \u2194 \u2200 i, Surjective ((U i).restrictPreimage f) := by\n  refine \u27e8fun H i => (U i).restrictPreimage_surjective H, fun H x => ?_\u27e9\n  obtain \u27e8i, hi\u27e9 :=\n    Set.mem_iUnion.mp\n      (show x \u2208 Set.iUnion U by rw [hU]; trivial)\n  exact \u27e8_, congr_arg Subtype.val (H i \u27e8x, hi\u27e9).choose_spec\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\n\u22a2 Surjective f \u2194 \u2200 (i : \u03b9), Surjective ((U i).restrictPreimage f)"}, {"line": "refine \u27e8fun H i => (U i).restrictPreimage_surjective H, fun H x => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\nH : \u2200 (i : \u03b9), Surjective ((U i).restrictPreimage f)\nx : \u03b2\n\u22a2 \u2203 a, f a = x"}, {"line": "obtain \u27e8i, hi\u27e9 :=\n    Set.mem_iUnion.mp\n      (show x \u2208 Set.iUnion U by rw [hU]; trivial)", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nU : \u03b9 \u2192 Set \u03b2\nH : \u2200 (i : \u03b9), Surjective ((U i).restrictPreimage f)\nx : \u03b2\ni : \u03b9\nhi : x \u2208 U i\n\u22a2 \u2203 a, f a = x"}, {"line": "exact \u27e8_, congr_arg Subtype.val (H i \u27e8x, hi\u27e9).choose_spec\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem InjOn.image_biInter_eq {p : \u03b9 \u2192 Prop} {s : \u2200 i, p i \u2192 Set \u03b1} (hp : \u2203 i, p i)\n    {f : \u03b1 \u2192 \u03b2} (h : InjOn f (\u22c3 (i) (hi), s i hi)) :\n    (f '' \u22c2 (i) (hi), s i hi) = \u22c2 (i) (hi), f '' s i hi := by\n  simp only [iInter]\n  simp only [iInf_subtype']\n  haveI : Nonempty { i // p i } := nonempty_subtype.2 hp\n  apply InjOn.image_iInter_eq\n  simpa only [iUnion,iSup_subtype'] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u22c2 i, \u22c2 (hi : p i), s i hi = \u22c2 i, \u22c2 (hi : p i), f '' s i hi"}, {"line": "simp only [iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u2a05 i, \u2a05 (hi : p i), s i hi = \u2a05 i, \u2a05 (hi : p i), f '' s i hi"}, {"line": "simp only [iInf_subtype']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef"}, {"line": "haveI : Nonempty { i // p i } := nonempty_subtype.2 hp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 f '' \u2a05 x, s \u2191x \u22ef = \u2a05 x, f '' s \u2191x \u22ef"}, {"line": "apply InjOn.image_iInter_eq", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : (i : \u03b9) \u2192 p i \u2192 Set \u03b1\nhp : \u2203 i, p i\nf : \u03b1 \u2192 \u03b2\nh : InjOn f (\u22c3 i, \u22c3 (hi : p i), s i hi)\nthis : Nonempty { i // p i }\n\u22a2 InjOn f (\u22c3 i, s \u2191i \u22ef)"}, {"line": "simpa only [iUnion,iSup_subtype'] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_iInter {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (s : \u03b9 \u2192 Set \u03b1) :\n    (f '' \u22c2 i, s i) = \u22c2 i, f '' s i := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp_rw [iInter_of_empty, image_univ_of_surjective hf.surjective]\n  \u00b7 exact hf.injective.injOn.image_iInter_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : \u03b9 \u2192 Set \u03b1\n\u22a2 f '' \u22c2 i, s i = \u22c2 i, f '' s i"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : \u03b9 \u2192 Set \u03b1\nh\u271d : IsEmpty \u03b9\n\u22a2 f '' \u22c2 i, s i = \u22c2 i, f '' s i\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : \u03b9 \u2192 Set \u03b1\nh\u271d : Nonempty \u03b9\n\u22a2 f '' \u22c2 i, s i = \u22c2 i, f '' s i"}, {"line": "\u00b7 simp_rw [iInter_of_empty, image_univ_of_surjective hf.surjective]", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : \u03b9 \u2192 Set \u03b1\nh\u271d : Nonempty \u03b9\n\u22a2 f '' \u22c2 i, s i = \u22c2 i, f '' s i"}, {"line": "\u00b7 exact hf.injective.injOn.image_iInter_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_iInter\u2082 {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) (s : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (f '' \u22c2 (i) (j), s i j) = \u22c2 (i) (j), f '' s i j := by simp_rw [image_iInter hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2\nhf : Bijective f\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 f '' \u22c2 i, \u22c2 j, s i j = \u22c2 i, \u22c2 j, f '' s i j"}, {"line": "simp_rw [image_iInter hf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inj_on_iUnion_of_directed {s : \u03b9 \u2192 Set \u03b1} (hs : Directed (\u00b7 \u2286 \u00b7) s) {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 i, InjOn f (s i)) : InjOn f (\u22c3 i, s i) := by\n  intro x hx y hy hxy\n  rcases mem_iUnion.1 hx with \u27e8i, hx\u27e9\n  rcases mem_iUnion.1 hy with \u27e8j, hy\u27e9\n  rcases hs i j with \u27e8k, hi, hj\u27e9\n  exact hf k (hi hx) (hj hy) hxy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nhs : Directed (fun x1 x2 => x1 \u2286 x2) s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), InjOn f (s i)\n\u22a2 InjOn f (\u22c3 i, s i)"}, {"line": "intro x hx y hy hxy", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nhs : Directed (fun x1 x2 => x1 \u2286 x2) s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), InjOn f (s i)\nx : \u03b1\nhx : x \u2208 \u22c3 i, s i\ny : \u03b1\nhy : y \u2208 \u22c3 i, s i\nhxy : f x = f y\n\u22a2 x = y"}, {"line": "rcases mem_iUnion.1 hx with \u27e8i, hx\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nhs : Directed (fun x1 x2 => x1 \u2286 x2) s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), InjOn f (s i)\nx : \u03b1\nhx\u271d : x \u2208 \u22c3 i, s i\ny : \u03b1\nhy : y \u2208 \u22c3 i, s i\nhxy : f x = f y\ni : \u03b9\nhx : x \u2208 s i\n\u22a2 x = y"}, {"line": "rcases mem_iUnion.1 hy with \u27e8j, hy\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nhs : Directed (fun x1 x2 => x1 \u2286 x2) s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), InjOn f (s i)\nx : \u03b1\nhx\u271d : x \u2208 \u22c3 i, s i\ny : \u03b1\nhy\u271d : y \u2208 \u22c3 i, s i\nhxy : f x = f y\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\n\u22a2 x = y"}, {"line": "rcases hs i j with \u27e8k, hi, hj\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nhs : Directed (fun x1 x2 => x1 \u2286 x2) s\nf : \u03b1 \u2192 \u03b2\nhf : \u2200 (i : \u03b9), InjOn f (s i)\nx : \u03b1\nhx\u271d : x \u2208 \u22c3 i, s i\ny : \u03b1\nhy\u271d : y \u2208 \u22c3 i, s i\nhxy : f x = f y\ni : \u03b9\nhx : x \u2208 s i\nj : \u03b9\nhy : y \u2208 s j\nk : \u03b9\nhi : s i \u2286 s k\nhj : s j \u2286 s k\n\u22a2 x = y"}, {"line": "exact hf k (hi hx) (hj hy) hxy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_iUnion\u2082 (f : \u03b1 \u2192 \u03b2) (s : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (f '' \u22c3 (i) (j), s i j) = \u22c3 (i) (j), f '' s i j := by simp_rw [image_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\n\u22a2 f '' \u22c3 i, \u22c3 j, s i j = \u22c3 i, \u22c3 j, f '' s i j"}, {"line": "simp_rw [image_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_iUnion_eq' {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} :\n    \u22c3 (x) (y) (_ : f y = x), g x = \u22c3 y, g (f y) := by simpa using biUnion_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b9 \u2192 \u03b1\ng : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c3 x, \u22c3 y, \u22c3 (_ : f y = x), g x = \u22c3 y, g (f y)"}, {"line": "simpa using biUnion_range", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInter_iInter_eq' {f : \u03b9 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2} :\n    \u22c2 (x) (y) (_ : f y = x), g x = \u22c2 y, g (f y) := by simpa using biInter_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\nf : \u03b9 \u2192 \u03b1\ng : \u03b1 \u2192 Set \u03b2\n\u22a2 \u22c2 x, \u22c2 y, \u22c2 (_ : f y = x), g x = \u22c2 y, g (f y)"}, {"line": "simpa using biInter_range", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iUnion_inter_iUnion {\u03b9 \u03ba : Sort*} (f : \u03b9 \u2192 Set \u03b1) (g : \u03ba \u2192 Set \u03b1) :\n    (\u22c3 i, f i) \u2229 \u22c3 j, g j = \u22c3 i, \u22c3 j, f i \u2229 g j := by simp_rw [iUnion_inter, inter_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_9\n\u03ba : Sort u_10\nf : \u03b9 \u2192 Set \u03b1\ng : \u03ba \u2192 Set \u03b1\n\u22a2 (\u22c3 i, f i) \u2229 \u22c3 j, g j = \u22c3 i, \u22c3 j, f i \u2229 g j"}, {"line": "simp_rw [iUnion_inter, inter_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iInter_union_iInter {\u03b9 \u03ba : Sort*} (f : \u03b9 \u2192 Set \u03b1) (g : \u03ba \u2192 Set \u03b1) :\n    (\u22c2 i, f i) \u222a \u22c2 j, g j = \u22c2 i, \u22c2 j, f i \u222a g j := by simp_rw [iInter_union, union_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Sort u_9\n\u03ba : Sort u_10\nf : \u03b9 \u2192 Set \u03b1\ng : \u03ba \u2192 Set \u03b1\n\u22a2 (\u22c2 i, f i) \u222a \u22c2 j, g j = \u22c2 i, \u22c2 j, f i \u222a g j"}, {"line": "simp_rw [iInter_union, union_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iUnion\u2082_inter_iUnion\u2082 {\u03b9\u2081 \u03ba\u2081 : Sort*} {\u03b9\u2082 : \u03b9\u2081 \u2192 Sort*} {k\u2082 : \u03ba\u2081 \u2192 Sort*}\n    (f : \u2200 i\u2081, \u03b9\u2082 i\u2081 \u2192 Set \u03b1) (g : \u2200 j\u2081, k\u2082 j\u2081 \u2192 Set \u03b1) :\n    (\u22c3 i\u2081, \u22c3 i\u2082, f i\u2081 i\u2082) \u2229 \u22c3 j\u2081, \u22c3 j\u2082, g j\u2081 j\u2082 = \u22c3 i\u2081, \u22c3 i\u2082, \u22c3 j\u2081, \u22c3 j\u2082, f i\u2081 i\u2082 \u2229 g j\u2081 j\u2082 := by\n  simp_rw [iUnion_inter, inter_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9\u2081 : Sort u_9\n\u03ba\u2081 : Sort u_10\n\u03b9\u2082 : \u03b9\u2081 \u2192 Sort u_11\nk\u2082 : \u03ba\u2081 \u2192 Sort u_12\nf : (i\u2081 : \u03b9\u2081) \u2192 \u03b9\u2082 i\u2081 \u2192 Set \u03b1\ng : (j\u2081 : \u03ba\u2081) \u2192 k\u2082 j\u2081 \u2192 Set \u03b1\n\u22a2 (\u22c3 i\u2081, \u22c3 i\u2082, f i\u2081 i\u2082) \u2229 \u22c3 j\u2081, \u22c3 j\u2082, g j\u2081 j\u2082 = \u22c3 i\u2081, \u22c3 i\u2082, \u22c3 j\u2081, \u22c3 j\u2082, f i\u2081 i\u2082 \u2229 g j\u2081 j\u2082"}, {"line": "simp_rw [iUnion_inter, inter_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma iInter\u2082_union_iInter\u2082 {\u03b9\u2081 \u03ba\u2081 : Sort*} {\u03b9\u2082 : \u03b9\u2081 \u2192 Sort*} {k\u2082 : \u03ba\u2081 \u2192 Sort*}\n    (f : \u2200 i\u2081, \u03b9\u2082 i\u2081 \u2192 Set \u03b1) (g : \u2200 j\u2081, k\u2082 j\u2081 \u2192 Set \u03b1) :\n    (\u22c2 i\u2081, \u22c2 i\u2082, f i\u2081 i\u2082) \u222a \u22c2 j\u2081, \u22c2 j\u2082, g j\u2081 j\u2082 = \u22c2 i\u2081, \u22c2 i\u2082, \u22c2 j\u2081, \u22c2 j\u2082, f i\u2081 i\u2082 \u222a g j\u2081 j\u2082 := by\n  simp_rw [iInter_union, union_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9\u2081 : Sort u_9\n\u03ba\u2081 : Sort u_10\n\u03b9\u2082 : \u03b9\u2081 \u2192 Sort u_11\nk\u2082 : \u03ba\u2081 \u2192 Sort u_12\nf : (i\u2081 : \u03b9\u2081) \u2192 \u03b9\u2082 i\u2081 \u2192 Set \u03b1\ng : (j\u2081 : \u03ba\u2081) \u2192 k\u2082 j\u2081 \u2192 Set \u03b1\n\u22a2 (\u22c2 i\u2081, \u22c2 i\u2082, f i\u2081 i\u2082) \u222a \u22c2 j\u2081, \u22c2 j\u2082, g j\u2081 j\u2082 = \u22c2 i\u2081, \u22c2 i\u2082, \u22c2 j\u2081, \u22c2 j\u2082, f i\u2081 i\u2082 \u222a g j\u2081 j\u2082"}, {"line": "simp_rw [iInter_union, union_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_iUnion\u2082 {f : \u03b1 \u2192 \u03b2} {s : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (f \u207b\u00b9' \u22c3 (i) (j), s i j) = \u22c3 (i) (j), f \u207b\u00b9' s i j := by simp_rw [preimage_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 f \u207b\u00b9' \u22c3 i, \u22c3 j, s i j = \u22c3 i, \u22c3 j, f \u207b\u00b9' s i j"}, {"line": "simp_rw [preimage_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_sUnion {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} : f \u207b\u00b9' \u22c3\u2080 s = \u22c3 t \u2208 s, f \u207b\u00b9' t := by\n  rw [sUnion_eq_biUnion]\n  rw [preimage_iUnion\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set (Set \u03b2)\n\u22a2 f \u207b\u00b9' \u22c3\u2080 s = \u22c3 t \u2208 s, f \u207b\u00b9' t"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set (Set \u03b2)\n\u22a2 f \u207b\u00b9' \u22c3 i \u2208 s, i = \u22c3 t \u2208 s, f \u207b\u00b9' t"}, {"line": "rw [preimage_iUnion\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_iInter\u2082 {f : \u03b1 \u2192 \u03b2} {s : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (f \u207b\u00b9' \u22c2 (i) (j), s i j) = \u22c2 (i) (j), f \u207b\u00b9' s i j := by simp_rw [preimage_iInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 f \u207b\u00b9' \u22c2 i, \u22c2 j, s i j = \u22c2 i, \u22c2 j, f \u207b\u00b9' s i j"}, {"line": "simp_rw [preimage_iInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_sInter {f : \u03b1 \u2192 \u03b2} {s : Set (Set \u03b2)} : f \u207b\u00b9' \u22c2\u2080 s = \u22c2 t \u2208 s, f \u207b\u00b9' t := by\n  rw [sInter_eq_biInter]\n  rw [preimage_iInter\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set (Set \u03b2)\n\u22a2 f \u207b\u00b9' \u22c2\u2080 s = \u22c2 t \u2208 s, f \u207b\u00b9' t"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set (Set \u03b2)\n\u22a2 f \u207b\u00b9' \u22c2 i \u2208 s, i = \u22c2 t \u2208 s, f \u207b\u00b9' t"}, {"line": "rw [preimage_iInter\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_preimage_singleton (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : \u22c3 y \u2208 s, f \u207b\u00b9' {y} = f \u207b\u00b9' s := by\n  rw [\u2190 preimage_iUnion\u2082]\n  rw [biUnion_of_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 \u22c3 y \u2208 s, f \u207b\u00b9' {y} = f \u207b\u00b9' s"}, {"line": "rw [\u2190 preimage_iUnion\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b2\n\u22a2 f \u207b\u00b9' \u22c3 i \u2208 s, {i} = f \u207b\u00b9' s"}, {"line": "rw [biUnion_of_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem biUnion_range_preimage_singleton (f : \u03b1 \u2192 \u03b2) : \u22c3 y \u2208 range f, f \u207b\u00b9' {y} = univ := by\n  rw [biUnion_preimage_singleton]\n  rw [preimage_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u22c3 y \u2208 range f, f \u207b\u00b9' {y} = univ"}, {"line": "rw [biUnion_preimage_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 f \u207b\u00b9' range f = univ"}, {"line": "rw [preimage_range]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_iUnion {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} : (s \u00d7\u02e2 \u22c3 i, t i) = \u22c3 i, s \u00d7\u02e2 t i := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 s \u00d7\u02e2 \u22c3 i, t i = \u22c3 i, s \u00d7\u02e2 t i"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 s \u00d7\u02e2 \u22c3 i, t i \u2194 x\u271d \u2208 \u22c3 i, s \u00d7\u02e2 t i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_iUnion\u2082 {s : Set \u03b1} {t : \u2200 i, \u03ba i \u2192 Set \u03b2} :\n    (s \u00d7\u02e2 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s \u00d7\u02e2 t i j := by simp_rw [prod_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 s \u00d7\u02e2 \u22c3 i, \u22c3 j, t i j = \u22c3 i, \u22c3 j, s \u00d7\u02e2 t i j"}, {"line": "simp_rw [prod_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_sUnion {s : Set \u03b1} {C : Set (Set \u03b2)} : s \u00d7\u02e2 \u22c3\u2080 C = \u22c3\u2080 ((fun t => s \u00d7\u02e2 t) '' C) := by\n  simp_rw [sUnion_eq_biUnion, biUnion_image, prod_iUnion\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nC : Set (Set \u03b2)\n\u22a2 s \u00d7\u02e2 \u22c3\u2080 C = \u22c3\u2080 ((fun t => s \u00d7\u02e2 t) '' C)"}, {"line": "simp_rw [sUnion_eq_biUnion, biUnion_image, prod_iUnion\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_prod_const {s : \u03b9 \u2192 Set \u03b1} {t : Set \u03b2} : (\u22c3 i, s i) \u00d7\u02e2 t = \u22c3 i, s i \u00d7\u02e2 t := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 (\u22c3 i, s i) \u00d7\u02e2 t = \u22c3 i, s i \u00d7\u02e2 t"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 (\u22c3 i, s i) \u00d7\u02e2 t \u2194 x\u271d \u2208 \u22c3 i, s i \u00d7\u02e2 t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion\u2082_prod_const {s : \u2200 i, \u03ba i \u2192 Set \u03b1} {t : Set \u03b2} :\n    (\u22c3 (i) (j), s i j) \u00d7\u02e2 t = \u22c3 (i) (j), s i j \u00d7\u02e2 t := by simp_rw [iUnion_prod_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 (\u22c3 i, \u22c3 j, s i j) \u00d7\u02e2 t = \u22c3 i, \u22c3 j, s i j \u00d7\u02e2 t"}, {"line": "simp_rw [iUnion_prod_const]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sUnion_prod_const {C : Set (Set \u03b1)} {t : Set \u03b2} :\n    \u22c3\u2080 C \u00d7\u02e2 t = \u22c3\u2080 ((fun s : Set \u03b1 => s \u00d7\u02e2 t) '' C) := by\n  simp only [sUnion_eq_biUnion]\n  simp only [iUnion\u2082_prod_const]\n  simp only [biUnion_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 \u22c3\u2080 C \u00d7\u02e2 t = \u22c3\u2080 ((fun s => s \u00d7\u02e2 t) '' C)"}, {"line": "simp only [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 (\u22c3 i \u2208 C, i) \u00d7\u02e2 t = \u22c3 i \u2208 (fun s => s \u00d7\u02e2 t) '' C, i"}, {"line": "simp only [iUnion\u2082_prod_const]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nC : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 \u22c3 i \u2208 C, i \u00d7\u02e2 t = \u22c3 i \u2208 (fun s => s \u00d7\u02e2 t) '' C, i"}, {"line": "simp only [biUnion_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_prod {\u03b9 \u03b9' \u03b1 \u03b2} (s : \u03b9 \u2192 Set \u03b1) (t : \u03b9' \u2192 Set \u03b2) :\n    \u22c3 x : \u03b9 \u00d7 \u03b9', s x.1 \u00d7\u02e2 t x.2 = (\u22c3 i : \u03b9, s i) \u00d7\u02e2 \u22c3 i : \u03b9', t i := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_9\n\u03b9' : Type u_10\n\u03b1 : Type u_11\n\u03b2 : Type u_12\ns : \u03b9 \u2192 Set \u03b1\nt : \u03b9' \u2192 Set \u03b2\n\u22a2 \u22c3 x, s x.1 \u00d7\u02e2 t x.2 = (\u22c3 i, s i) \u00d7\u02e2 \u22c3 i, t i"}, {"line": "ext", "tactic_state": "case h\n\u03b9 : Type u_9\n\u03b9' : Type u_10\n\u03b1 : Type u_11\n\u03b2 : Type u_12\ns : \u03b9 \u2192 Set \u03b1\nt : \u03b9' \u2192 Set \u03b2\nx\u271d : \u03b1 \u00d7 \u03b2\n\u22a2 x\u271d \u2208 \u22c3 x, s x.1 \u00d7\u02e2 t x.2 \u2194 x\u271d \u2208 (\u22c3 i, s i) \u00d7\u02e2 \u22c3 i, t i"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_prod_sInter {S : Set (Set \u03b1)} {T : Set (Set \u03b2)} (hS : S.Nonempty) (hT : T.Nonempty) :\n    \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T = \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2 := by\n  obtain \u27e8s\u2081, h\u2081\u27e9 := hS\n  obtain \u27e8s\u2082, h\u2082\u27e9 := hT\n  refine Set.Subset.antisymm (sInter_prod_sInter_subset S T) fun x hx => ?_\n  rw [mem_iInter\u2082] at hx\n  exact \u27e8fun s\u2080 h\u2080 => (hx (s\u2080, s\u2082) \u27e8h\u2080, h\u2082\u27e9).1, fun s\u2080 h\u2080 => (hx (s\u2081, s\u2080) \u27e8h\u2081, h\u2080\u27e9).2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nT : Set (Set \u03b2)\nhS : S.Nonempty\nhT : T.Nonempty\n\u22a2 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T = \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2"}, {"line": "obtain \u27e8s\u2081, h\u2081\u27e9 := hS", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nT : Set (Set \u03b2)\nhT : T.Nonempty\ns\u2081 : Set \u03b1\nh\u2081 : s\u2081 \u2208 S\n\u22a2 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T = \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2"}, {"line": "obtain \u27e8s\u2082, h\u2082\u27e9 := hT", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nT : Set (Set \u03b2)\ns\u2081 : Set \u03b1\nh\u2081 : s\u2081 \u2208 S\ns\u2082 : Set \u03b2\nh\u2082 : s\u2082 \u2208 T\n\u22a2 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T = \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2"}, {"line": "refine Set.Subset.antisymm (sInter_prod_sInter_subset S T) fun x hx => ?_", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nT : Set (Set \u03b2)\ns\u2081 : Set \u03b1\nh\u2081 : s\u2081 \u2208 S\ns\u2082 : Set \u03b2\nh\u2082 : s\u2082 \u2208 T\nx : \u03b1 \u00d7 \u03b2\nhx : x \u2208 \u22c2 r \u2208 S \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2\n\u22a2 x \u2208 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T"}, {"line": "rw [mem_iInter\u2082] at hx", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nT : Set (Set \u03b2)\ns\u2081 : Set \u03b1\nh\u2081 : s\u2081 \u2208 S\ns\u2082 : Set \u03b2\nh\u2082 : s\u2082 \u2208 T\nx : \u03b1 \u00d7 \u03b2\nhx : \u2200 i \u2208 S \u00d7\u02e2 T, x \u2208 i.1 \u00d7\u02e2 i.2\n\u22a2 x \u2208 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 T"}, {"line": "exact \u27e8fun s\u2080 h\u2080 => (hx (s\u2080, s\u2082) \u27e8h\u2080, h\u2082\u27e9).1, fun s\u2080 h\u2080 => (hx (s\u2081, s\u2080) \u27e8h\u2081, h\u2080\u27e9).2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInter_prod {S : Set (Set \u03b1)} (hS : S.Nonempty) (t : Set \u03b2) :\n    \u22c2\u2080 S \u00d7\u02e2 t = \u22c2 s \u2208 S, s \u00d7\u02e2 t := by\n  rw [\u2190 sInter_singleton t]\n  rw [sInter_prod_sInter hS (singleton_nonempty t)]\n  rw [sInter_singleton]\n  simp_rw [prod_singleton, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nhS : S.Nonempty\nt : Set \u03b2\n\u22a2 \u22c2\u2080 S \u00d7\u02e2 t = \u22c2 s \u2208 S, s \u00d7\u02e2 t"}, {"line": "rw [\u2190 sInter_singleton t]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nhS : S.Nonempty\nt : Set \u03b2\n\u22a2 \u22c2\u2080 S \u00d7\u02e2 \u22c2\u2080 {t} = \u22c2 s \u2208 S, s \u00d7\u02e2 \u22c2\u2080 {t}"}, {"line": "rw [sInter_prod_sInter hS (singleton_nonempty t)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nhS : S.Nonempty\nt : Set \u03b2\n\u22a2 \u22c2 r \u2208 S \u00d7\u02e2 {t}, r.1 \u00d7\u02e2 r.2 = \u22c2 s \u2208 S, s \u00d7\u02e2 \u22c2\u2080 {t}"}, {"line": "rw [sInter_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nS : Set (Set \u03b1)\nhS : S.Nonempty\nt : Set \u03b2\n\u22a2 \u22c2 r \u2208 S \u00d7\u02e2 {t}, r.1 \u00d7\u02e2 r.2 = \u22c2 s \u2208 S, s \u00d7\u02e2 t"}, {"line": "simp_rw [prod_singleton, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_sInter {T : Set (Set \u03b2)} (hT : T.Nonempty) (s : Set \u03b1) :\n    s \u00d7\u02e2 \u22c2\u2080 T = \u22c2 t \u2208 T, s \u00d7\u02e2 t := by\n  rw [\u2190 sInter_singleton s]\n  rw [sInter_prod_sInter (singleton_nonempty s) hT]\n  rw [sInter_singleton]\n  simp_rw [singleton_prod, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nT : Set (Set \u03b2)\nhT : T.Nonempty\ns : Set \u03b1\n\u22a2 s \u00d7\u02e2 \u22c2\u2080 T = \u22c2 t \u2208 T, s \u00d7\u02e2 t"}, {"line": "rw [\u2190 sInter_singleton s]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nT : Set (Set \u03b2)\nhT : T.Nonempty\ns : Set \u03b1\n\u22a2 \u22c2\u2080 {s} \u00d7\u02e2 \u22c2\u2080 T = \u22c2 t \u2208 T, \u22c2\u2080 {s} \u00d7\u02e2 t"}, {"line": "rw [sInter_prod_sInter (singleton_nonempty s) hT]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nT : Set (Set \u03b2)\nhT : T.Nonempty\ns : Set \u03b1\n\u22a2 \u22c2 r \u2208 {s} \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2 = \u22c2 t \u2208 T, \u22c2\u2080 {s} \u00d7\u02e2 t"}, {"line": "rw [sInter_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nT : Set (Set \u03b2)\nhT : T.Nonempty\ns : Set \u03b1\n\u22a2 \u22c2 r \u2208 {s} \u00d7\u02e2 T, r.1 \u00d7\u02e2 r.2 = \u22c2 t \u2208 T, s \u00d7\u02e2 t"}, {"line": "simp_rw [singleton_prod, mem_image, iInter_exists, biInter_and', iInter_iInter_eq_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_iInter {s : Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} [h\u03b9 : Nonempty \u03b9] :\n    (s \u00d7\u02e2 \u22c2 i, t i) = \u22c2 i, s \u00d7\u02e2 t i := by\n  ext x\n  simp only [mem_prod]\n  simp only [mem_iInter]\n  exact \u27e8fun h i => \u27e8h.1, h.2 i\u27e9, fun h => \u27e8(h h\u03b9.some).1, fun i => (h i).2\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\nh\u03b9 : Nonempty \u03b9\n\u22a2 s \u00d7\u02e2 \u22c2 i, t i = \u22c2 i, s \u00d7\u02e2 t i"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\nh\u03b9 : Nonempty \u03b9\nx : \u03b1 \u00d7 \u03b2\n\u22a2 x \u2208 s \u00d7\u02e2 \u22c2 i, t i \u2194 x \u2208 \u22c2 i, s \u00d7\u02e2 t i"}, {"line": "simp only [mem_prod]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\nh\u03b9 : Nonempty \u03b9\nx : \u03b1 \u00d7 \u03b2\n\u22a2 x.1 \u2208 s \u2227 x.2 \u2208 \u22c2 i, t i \u2194 x \u2208 \u22c2 i, s \u00d7\u02e2 t i"}, {"line": "simp only [mem_iInter]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b9 : Sort u_5\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\nh\u03b9 : Nonempty \u03b9\nx : \u03b1 \u00d7 \u03b2\n\u22a2 (x.1 \u2208 s \u2227 \u2200 (i : \u03b9), x.2 \u2208 t i) \u2194 \u2200 (i : \u03b9), x \u2208 s \u00d7\u02e2 t i"}, {"line": "exact \u27e8fun h i => \u27e8h.1, h.2 i\u27e9, fun h => \u27e8(h h\u03b9.some).1, fun i => (h i).2\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_image_left : \u22c3 a \u2208 s, f a '' t = image2 f s t := by\n  simp only [image2_eq_iUnion]\n  simp only [image_eq_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u22c3 a \u2208 s, f a '' t = image2 f s t"}, {"line": "simp only [image2_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u22c3 a \u2208 s, f a '' t = \u22c3 i \u2208 s, \u22c3 j \u2208 t, {f i j}"}, {"line": "simp only [image_eq_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_image_right : \u22c3 b \u2208 t, (f \u00b7 b) '' s = image2 f s t := by\n  rw [image2_swap]\n  rw [iUnion_image_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u22c3 b \u2208 t, (fun x => f x b) '' s = image2 f s t"}, {"line": "rw [image2_swap]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 \u22c3 b \u2208 t, (fun x => f x b) '' s = image2 (fun a b => f b a) t s"}, {"line": "rw [iUnion_image_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iUnion_left (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c3 i, s i) t = \u22c3 i, image2 f (s i) t := by\n  simp only [\u2190 image_prod]\n  simp only [iUnion_prod_const]\n  simp only [image_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c3 i, s i) t = \u22c3 i, image2 f (s i) t"}, {"line": "simp only [\u2190 image_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 (fun x => f x.1 x.2) '' (\u22c3 i, s i) \u00d7\u02e2 t = \u22c3 i, (fun x => f x.1 x.2) '' s i \u00d7\u02e2 t"}, {"line": "simp only [iUnion_prod_const]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 (fun x => f x.1 x.2) '' \u22c3 i, s i \u00d7\u02e2 t = \u22c3 i, (fun x => f x.1 x.2) '' s i \u00d7\u02e2 t"}, {"line": "simp only [image_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iUnion_right (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) :\n    image2 f s (\u22c3 i, t i) = \u22c3 i, image2 f s (t i) := by\n  simp only [\u2190 image_prod]\n  simp only [prod_iUnion]\n  simp only [image_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c3 i, t i) = \u22c3 i, image2 f s (t i)"}, {"line": "simp only [\u2190 image_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 (fun x => f x.1 x.2) '' s \u00d7\u02e2 \u22c3 i, t i = \u22c3 i, (fun x => f x.1 x.2) '' s \u00d7\u02e2 t i"}, {"line": "simp only [prod_iUnion]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 (fun x => f x.1 x.2) '' \u22c3 i, s \u00d7\u02e2 t i = \u22c3 i, (fun x => f x.1 x.2) '' s \u00d7\u02e2 t i"}, {"line": "simp only [image_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sUnion_left (S : Set (Set \u03b1)) (t : Set \u03b2) :\n    image2 f (\u22c3\u2080 S) t = \u22c3 s \u2208 S, image2 f s t := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nS : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 image2 f (\u22c3\u2080 S) t = \u22c3 s \u2208 S, image2 f s t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sUnion_right (s : Set \u03b1) (T : Set (Set \u03b2)) :\n    image2 f s (\u22c3\u2080 T) = \u22c3 t \u2208 T, image2 f s t := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nT : Set (Set \u03b2)\n\u22a2 image2 f s (\u22c3\u2080 T) = \u22c3 t \u2208 T, image2 f s t"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iUnion\u2082_left (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c3 (i) (j), s i j) t = \u22c3 (i) (j), image2 f (s i j) t := by simp_rw [image2_iUnion_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c3 i, \u22c3 j, s i j) t = \u22c3 i, \u22c3 j, image2 f (s i j) t"}, {"line": "simp_rw [image2_iUnion_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iUnion\u2082_right (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    image2 f s (\u22c3 (i) (j), t i j) = \u22c3 (i) (j), image2 f s (t i j) := by\n  simp_rw [image2_iUnion_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c3 i, \u22c3 j, t i j) = \u22c3 i, \u22c3 j, image2 f s (t i j)"}, {"line": "simp_rw [image2_iUnion_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iInter_subset_left (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c2 i, s i) t \u2286 \u22c2 i, image2 f (s i) t := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i => mem_image2_of_mem (hx _) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c2 i, s i) t \u2286 \u22c2 i, image2 f (s i) t"}, {"line": "simp_rw [image2_subset_iff, mem_iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : \u03b9 \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9), x \u2208 s i) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9), f x y \u2208 image2 f (s i) t"}, {"line": "exact fun x hx y hy i => mem_image2_of_mem (hx _) hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iInter_subset_right (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) :\n    image2 f s (\u22c2 i, t i) \u2286 \u22c2 i, image2 f s (t i) := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i => mem_image2_of_mem hx (hy _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c2 i, t i) \u2286 \u22c2 i, image2 f s (t i)"}, {"line": "simp_rw [image2_subset_iff, mem_iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : \u03b9 \u2192 Set \u03b2\n\u22a2 \u2200 x \u2208 s, \u2200 (y : \u03b2), (\u2200 (i : \u03b9), y \u2208 t i) \u2192 \u2200 (i : \u03b9), f x y \u2208 image2 f s (t i)"}, {"line": "exact fun x hx y hy i => mem_image2_of_mem hx (hy _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iInter\u2082_subset_left (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    image2 f (\u22c2 (i) (j), s i j) t \u2286 \u22c2 (i) (j), image2 f (s i j) t := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i j => mem_image2_of_mem (hx _ _) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 image2 f (\u22c2 i, \u22c2 j, s i j) t \u2286 \u22c2 i, \u22c2 j, image2 f (s i j) t"}, {"line": "simp_rw [image2_subset_iff, mem_iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b1\nt : Set \u03b2\n\u22a2 \u2200 (x : \u03b1), (\u2200 (i : \u03b9) (i_1 : \u03ba i), x \u2208 s i i_1) \u2192 \u2200 y \u2208 t, \u2200 (i : \u03b9) (i_1 : \u03ba i), f x y \u2208 image2 f (s i i_1) t"}, {"line": "exact fun x hx y hy i j => mem_image2_of_mem (hx _ _) hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_iInter\u2082_subset_right (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    image2 f s (\u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), image2 f s (t i j) := by\n  simp_rw [image2_subset_iff, mem_iInter]\n  exact fun x hx y hy i j => mem_image2_of_mem hx (hy _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 image2 f s (\u22c2 i, \u22c2 j, t i j) \u2286 \u22c2 i, \u22c2 j, image2 f s (t i j)"}, {"line": "simp_rw [image2_subset_iff, mem_iInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b9 : Sort u_5\n\u03ba : \u03b9 \u2192 Sort u_8\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : (i : \u03b9) \u2192 \u03ba i \u2192 Set \u03b2\n\u22a2 \u2200 x \u2208 s, \u2200 (y : \u03b2), (\u2200 (i : \u03b9) (i_1 : \u03ba i), y \u2208 t i i_1) \u2192 \u2200 (i : \u03b9) (i_1 : \u03ba i), f x y \u2208 image2 f s (t i i_1)"}, {"line": "exact fun x hx y hy i j => mem_image2_of_mem hx (hy _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sInter_subset_left (S : Set (Set \u03b1)) (t : Set \u03b2) :\n    image2 f (\u22c2\u2080 S) t \u2286 \u22c2 s \u2208 S, image2 f s t := by\n  rw [sInter_eq_biInter]\n  exact image2_iInter\u2082_subset_left ..\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nS : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 image2 f (\u22c2\u2080 S) t \u2286 \u22c2 s \u2208 S, image2 f s t"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nS : Set (Set \u03b1)\nt : Set \u03b2\n\u22a2 image2 f (\u22c2 i \u2208 S, i) t \u2286 \u22c2 s \u2208 S, image2 f s t"}, {"line": "exact image2_iInter\u2082_subset_left ..", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_sInter_subset_right (s : Set \u03b1) (T : Set (Set \u03b2)) :\n    image2 f s (\u22c2\u2080 T) \u2286 \u22c2 t \u2208 T, image2 f s t := by\n  rw [sInter_eq_biInter]\n  exact image2_iInter\u2082_subset_right ..\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nT : Set (Set \u03b2)\n\u22a2 image2 f s (\u22c2\u2080 T) \u2286 \u22c2 t \u2208 T, image2 f s t"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nT : Set (Set \u03b2)\n\u22a2 image2 f s (\u22c2 i \u2208 T, i) \u2286 \u22c2 t \u2208 T, image2 f s t"}, {"line": "exact image2_iInter\u2082_subset_right ..", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_biUnion_left : s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t := by\n  rw [iUnion_image_left]\n  rw [image2_mk_eq_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t"}, {"line": "rw [iUnion_image_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = image2 (fun a b => (a, b)) s t"}, {"line": "rw [image2_mk_eq_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_biUnion_right : s \u00d7\u02e2 t = \u22c3 b \u2208 t, (fun a => (a, b)) '' s := by\n  rw [iUnion_image_right]\n  rw [image2_mk_eq_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = \u22c3 b \u2208 t, (fun a => (a, b)) '' s"}, {"line": "rw [iUnion_image_right]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = image2 Prod.mk s t"}, {"line": "rw [image2_mk_eq_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seq_def {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} : seq s t = \u22c3 f \u2208 s, f '' t := by\n  rw [seq_eq_image2]\n  rw [iUnion_image_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 s.seq t = \u22c3 f \u2208 s, f '' t"}, {"line": "rw [seq_eq_image2]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 image2 (fun f a => f a) s t = \u22c3 f \u2208 s, f '' t"}, {"line": "rw [iUnion_image_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seq_seq {s : Set (\u03b2 \u2192 \u03b3)} {t : Set (\u03b1 \u2192 \u03b2)} {u : Set \u03b1} :\n    seq s (seq t u) = seq (seq ((\u00b7 \u2218 \u00b7) '' s) t) u := by\n  simp only [seq_eq_image2]\n  simp only [image2_image_left]\n  exact .symm <| image2_assoc fun _ _ _ \u21a6 rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set (\u03b2 \u2192 \u03b3)\nt : Set (\u03b1 \u2192 \u03b2)\nu : Set \u03b1\n\u22a2 s.seq (t.seq u) = (((fun x1 x2 => x1 \u2218 x2) '' s).seq t).seq u"}, {"line": "simp only [seq_eq_image2]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set (\u03b2 \u2192 \u03b3)\nt : Set (\u03b1 \u2192 \u03b2)\nu : Set \u03b1\n\u22a2 image2 (fun f a => f a) s (image2 (fun f a => f a) t u) =\n    image2 (fun f a => f a) (image2 (fun f a => f a) ((fun x1 x2 => x1 \u2218 x2) '' s) t) u"}, {"line": "simp only [image2_image_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ns : Set (\u03b2 \u2192 \u03b3)\nt : Set (\u03b1 \u2192 \u03b2)\nu : Set \u03b1\n\u22a2 image2 (fun f a => f a) s (image2 (fun f a => f a) t u) =\n    image2 (fun f a => f a) (image2 (fun x1 x2 => x1 \u2218 x2) s t) u"}, {"line": "exact .symm <| image2_assoc fun _ _ _ \u21a6 rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image_seq {f : \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u2192 \u03b2)} {t : Set \u03b1} :\n    f '' seq s t = seq ((f \u2218 \u00b7) '' s) t := by\n  simp only [seq]\n  simp only [image_image2]\n  simp only [image2_image_left]\n  simp only [comp_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 f '' s.seq t = ((fun x => f \u2218 x) '' s).seq t"}, {"line": "simp only [seq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 f '' image2 (fun f => f) s t = image2 (fun f => f) ((fun x => f \u2218 x) '' s) t"}, {"line": "simp only [image_image2]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 image2 (fun a b => f (a b)) s t = image2 (fun f => f) ((fun x => f \u2218 x) '' s) t"}, {"line": "simp only [image2_image_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\ns : Set (\u03b1 \u2192 \u03b2)\nt : Set \u03b1\n\u22a2 image2 (fun a b => f (a b)) s t = image2 (fun a b => (f \u2218 a) b) s t"}, {"line": "simp only [comp_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_seq {s : Set \u03b1} {t : Set \u03b2} : s \u00d7\u02e2 t = (Prod.mk '' s).seq t := by\n  rw [seq_eq_image2]\n  rw [image2_image_left]\n  rw [image2_mk_eq_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Lattice/Image.lean", "context": {"open": ["Function Set", "Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 \u03b9' \u03b9\u2082 : Sort*} {\u03ba : \u03b9 \u2192 Sort*}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2} {U : \u03b9 \u2192 Set \u03b2} (hU : iUnion U = univ)", "{s : Set \u03b3} {f : \u03b3 \u2192 \u03b1} {g : \u03b1 \u2192 Set \u03b2}", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = (Prod.mk '' s).seq t"}, {"line": "rw [seq_eq_image2]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = image2 (fun f a => f a) (Prod.mk '' s) t"}, {"line": "rw [image2_image_left]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 s \u00d7\u02e2 t = image2 (fun a b => (a, b)) s t"}, {"line": "rw [image2_mk_eq_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nodup.pairwise_coe [IsSymm \u03b1 r] (hl : l.Nodup) :\n    { a | a \u2208 l }.Pairwise r \u2194 l.Pairwise r := by\n  induction l with | nil => simp | cons a l ih => ?_\n  rw [List.nodup_cons] at hl\n  have : \u2200 b \u2208 l, \u00aca = b \u2192 r a b \u2194 r a b := fun b hb =>\n    imp_iff_right (ne_of_mem_of_not_mem hb hl.1).symm\n  simp [Set.setOf_or, Set.pairwise_insert_of_symmetric fun _ _ \u21a6 symm_of r, ih hl.2, and_comm,\n    forall\u2082_congr this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/List.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{l : List \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nl : List \u03b1\ninst\u271d : IsSymm \u03b1 r\nhl : l.Nodup\n\u22a2 {a | a \u2208 l}.Pairwise r \u2194 List.Pairwise r l"}, {"line": "induction l with | nil => simp | cons a l ih => ?_", "tactic_state": "case cons\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u271d : List \u03b1\ninst\u271d : IsSymm \u03b1 r\na : \u03b1\nl : List \u03b1\nih : l.Nodup \u2192 ({a | a \u2208 l}.Pairwise r \u2194 List.Pairwise r l)\nhl : (a :: l).Nodup\n\u22a2 {a_1 | a_1 \u2208 a :: l}.Pairwise r \u2194 List.Pairwise r (a :: l)"}, {"line": "rw [List.nodup_cons] at hl", "tactic_state": "case cons\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u271d : List \u03b1\ninst\u271d : IsSymm \u03b1 r\na : \u03b1\nl : List \u03b1\nih : l.Nodup \u2192 ({a | a \u2208 l}.Pairwise r \u2194 List.Pairwise r l)\nhl : a \u2209 l \u2227 l.Nodup\n\u22a2 {a_1 | a_1 \u2208 a :: l}.Pairwise r \u2194 List.Pairwise r (a :: l)"}, {"line": "have : \u2200 b \u2208 l, \u00aca = b \u2192 r a b \u2194 r a b := fun b hb =>\n    imp_iff_right (ne_of_mem_of_not_mem hb hl.1).symm", "tactic_state": "case cons\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u271d : List \u03b1\ninst\u271d : IsSymm \u03b1 r\na : \u03b1\nl : List \u03b1\nih : l.Nodup \u2192 ({a | a \u2208 l}.Pairwise r \u2194 List.Pairwise r l)\nhl : a \u2209 l \u2227 l.Nodup\nthis : \u2200 b \u2208 l, \u00aca = b \u2192 r a b \u2194 r a b\n\u22a2 {a_1 | a_1 \u2208 a :: l}.Pairwise r \u2194 List.Pairwise r (a :: l)"}, {"line": "simp [Set.setOf_or, Set.pairwise_insert_of_symmetric fun _ _ \u21a6 symm_of r, ih hl.2, and_comm,\n    forall\u2082_congr this]", "tactic_state": "case cons\n\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nl\u271d : List \u03b1\ninst\u271d : IsSymm \u03b1 r\na : \u03b1\nl : List \u03b1\nih : l.Nodup \u2192 ({a | a \u2208 l}.Pairwise r \u2194 List.Pairwise r l)\nhl : a \u2209 l \u2227 l.Nodup\nthis : \u2200 b \u2208 l, \u00aca = b \u2192 r a b \u2194 r a b\n\u22a2 (insert a {a | a \u2208 l}).Pairwise r \u2194 List.Pairwise r l \u2227 \u2200 a' \u2208 l, r a a'"}]}
{"declaration": "theorem pairwise_on_bool (hr : Symmetric r) {a b : \u03b1} :\n    Pairwise (r on fun c => cond c a b) \u2194 r a b := by simpa [Pairwise, Function.onFun] using @hr a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nhr : Symmetric r\na b : \u03b1\n\u22a2 Pairwise (onFun r fun c => bif c then a else b) \u2194 r a b"}, {"line": "simpa [Pairwise, Function.onFun] using @hr a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_iff_exists_forall [Nonempty \u03b9] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b9) {r : \u03b9 \u2192 \u03b9 \u2192 Prop}\n    [IsEquiv \u03b9 r] : s.Pairwise (r on f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  \u00b7 simp\n  \u00b7 exact hne.pairwise_iff_exists_forall\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b9\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b9\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ninst\u271d : IsEquiv \u03b9 r\n\u22a2 s.Pairwise (onFun r f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z"}, {"line": "rcases s.eq_empty_or_nonempty with (rfl | hne)", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b9\nf : \u03b1 \u2192 \u03b9\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ninst\u271d : IsEquiv \u03b9 r\n\u22a2 \u2205.Pairwise (onFun r f) \u2194 \u2203 z, \u2200 x \u2208 \u2205, r (f x) z\n---\ncase inr\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b9\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b9\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ninst\u271d : IsEquiv \u03b9 r\nhne : s.Nonempty\n\u22a2 s.Pairwise (onFun r f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : Nonempty \u03b9\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b9\nr : \u03b9 \u2192 \u03b9 \u2192 Prop\ninst\u271d : IsEquiv \u03b9 r\nhne : s.Nonempty\n\u22a2 s.Pairwise (onFun r f) \u2194 \u2203 z, \u2200 x \u2208 s, r (f x) z"}, {"line": "\u00b7 exact hne.pairwise_iff_exists_forall", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_union :\n    (s \u222a t).Pairwise r \u2194\n    s.Pairwise r \u2227 t.Pairwise r \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a := by\n  simp only [Set.Pairwise]\n  simp only [mem_union]\n  simp only [or_imp]\n  simp only [forall_and]\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (s \u222a t).Pairwise r \u2194 s.Pairwise r \u2227 t.Pairwise r \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u222a t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u222a t \u2192 x \u2260 y \u2192 r x y) \u2194\n    (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227\n      (\u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 t \u2192 x \u2260 y \u2192 r x y) \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [mem_union]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2228 x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2228 y \u2208 t \u2192 x \u2260 y \u2192 r x y) \u2194\n    (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227\n      (\u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 t \u2192 x \u2260 y \u2192 r x y) \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [or_imp]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984,\n      (x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, (y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227 (y \u2208 t \u2192 x \u2260 y \u2192 r x y)) \u2227\n        (x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, (y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227 (y \u2208 t \u2192 x \u2260 y \u2192 r x y))) \u2194\n    (\u2200 \u2983x : \u03b1\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 s \u2192 x \u2260 y \u2192 r x y) \u2227\n      (\u2200 \u2983x : \u03b1\u2984, x \u2208 t \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 t \u2192 x \u2260 y \u2192 r x y) \u2227 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [forall_and]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns t : Set \u03b1\n\u22a2 (((\u2200 x \u2208 s, \u2200 x_2 \u2208 s, x \u2260 x_2 \u2192 r x x_2) \u2227 \u2200 x \u2208 s, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x x_2) \u2227\n      (\u2200 x \u2208 t, \u2200 x_2 \u2208 s, x \u2260 x_2 \u2192 r x x_2) \u2227 \u2200 x \u2208 t, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x x_2) \u2194\n    (\u2200 x \u2208 s, \u2200 x_2 \u2208 s, x \u2260 x_2 \u2192 r x x_2) \u2227\n      (\u2200 x \u2208 t, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x x_2) \u2227\n        (\u2200 x \u2208 s, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x x_2) \u2227 \u2200 x \u2208 s, \u2200 x_2 \u2208 t, x \u2260 x_2 \u2192 r x_2 x"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_insert :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a := by\n  simp only [insert_eq]\n  simp only [pairwise_union]\n  simp only [pairwise_singleton]\n  simp only [true_and]\n  simp only [mem_singleton_iff]\n  simp only [forall_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [insert_eq]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 ({a} \u222a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [pairwise_union]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 ({a}.Pairwise r \u2227 s.Pairwise r \u2227 \u2200 a_1 \u2208 {a}, \u2200 b \u2208 s, a_1 \u2260 b \u2192 r a_1 b \u2227 r b a_1) \u2194\n    s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [pairwise_singleton]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 (True \u2227 s.Pairwise r \u2227 \u2200 a_1 \u2208 {a}, \u2200 b \u2208 s, a_1 \u2260 b \u2192 r a_1 b \u2227 r b a_1) \u2194\n    s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [true_and]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 (s.Pairwise r \u2227 \u2200 a_1 \u2208 {a}, \u2200 b \u2208 s, a_1 \u2260 b \u2192 r a_1 b \u2227 r b a_1) \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [mem_singleton_iff]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\n\u22a2 (s.Pairwise r \u2227 \u2200 (a_1 : \u03b1), a_1 = a \u2192 \u2200 b \u2208 s, a_1 \u2260 b \u2192 r a_1 b \u2227 r b a_1) \u2194\n    s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp only [forall_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_insert_of_symmetric (hr : Symmetric r) :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b := by\n  simp only [pairwise_insert]\n  simp only [hr.iff a]\n  simp only [and_self_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\n\u22a2 (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b"}, {"line": "simp only [pairwise_insert]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\n\u22a2 (s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b \u2227 r b a) \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r a b"}, {"line": "simp only [hr.iff a]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\n\u22a2 (s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r b a \u2227 r b a) \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, a \u2260 b \u2192 r b a"}, {"line": "simp only [and_self_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_insert_of_symmetric_of_not_mem (hr : Symmetric r) (ha : a \u2209 s) :\n    (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r a b := by\n  simp only [pairwise_insert_of_not_mem ha]\n  simp only [hr.iff a]\n  simp only [and_self_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\nha : a \u2209 s\n\u22a2 (insert a s).Pairwise r \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r a b"}, {"line": "simp only [pairwise_insert_of_not_mem ha]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\nha : a \u2209 s\n\u22a2 (s.Pairwise r \u2227 \u2200 b \u2208 s, r a b \u2227 r b a) \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r a b"}, {"line": "simp only [hr.iff a]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set \u03b1\na : \u03b1\nhr : Symmetric r\nha : a \u2209 s\n\u22a2 (s.Pairwise r \u2227 \u2200 b \u2208 s, r b a \u2227 r b a) \u2194 s.Pairwise r \u2227 \u2200 b \u2208 s, r b a"}, {"line": "simp only [and_self_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_pair : Set.Pairwise {a, b} r \u2194 a \u2260 b \u2192 r a b \u2227 r b a := by simp [pairwise_insert]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\n\u22a2 {a, b}.Pairwise r \u2194 a \u2260 b \u2192 r a b \u2227 r b a"}, {"line": "simp [pairwise_insert]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_pair_of_symmetric (hr : Symmetric r) : Set.Pairwise {a, b} r \u2194 a \u2260 b \u2192 r a b := by\n  simp [pairwise_insert_of_symmetric hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\na b : \u03b1\nhr : Symmetric r\n\u22a2 {a, b}.Pairwise r \u2194 a \u2260 b \u2192 r a b"}, {"line": "simp [pairwise_insert_of_symmetric hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_univ : (univ : Set \u03b1).Pairwise r \u2194 Pairwise r := by\n  simp only [Set.Pairwise]\n  simp only [Pairwise]\n  simp only [mem_univ]\n  simp only [forall_const]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 univ.Pairwise r \u2194 Pairwise r"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 univ \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 univ \u2192 x \u2260 y \u2192 r x y) \u2194 Pairwise r"}, {"line": "simp only [Pairwise]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, x \u2208 univ \u2192 \u2200 \u2983y : \u03b1\u2984, y \u2208 univ \u2192 x \u2260 y \u2192 r x y) \u2194 \u2200 \u2983i j : \u03b1\u2984, i \u2260 j \u2192 r i j"}, {"line": "simp only [mem_univ]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\n\u22a2 (\u2200 \u2983x : \u03b1\u2984, True \u2192 \u2200 \u2983y : \u03b1\u2984, True \u2192 x \u2260 y \u2192 r x y) \u2194 \u2200 \u2983i j : \u03b1\u2984, i \u2260 j \u2192 r i j"}, {"line": "simp only [forall_const]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma injOn_iff_pairwise_ne {s : Set \u03b9} : InjOn f s \u2194 s.Pairwise (f \u00b7 \u2260 f \u00b7) := by\n  simp only [InjOn]\n  simp only [Set.Pairwise]\n  simp only [not_imp_not]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\n\u22a2 InjOn f s \u2194 s.Pairwise fun x1 x2 => f x1 \u2260 f x2"}, {"line": "simp only [InjOn]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\n\u22a2 (\u2200 \u2983x\u2081 : \u03b9\u2984, x\u2081 \u2208 s \u2192 \u2200 \u2983x\u2082 : \u03b9\u2984, x\u2082 \u2208 s \u2192 f x\u2081 = f x\u2082 \u2192 x\u2081 = x\u2082) \u2194 s.Pairwise fun x1 x2 => f x1 \u2260 f x2"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\n\u22a2 (\u2200 \u2983x\u2081 : \u03b9\u2984, x\u2081 \u2208 s \u2192 \u2200 \u2983x\u2082 : \u03b9\u2984, x\u2082 \u2208 s \u2192 f x\u2081 = f x\u2082 \u2192 x\u2081 = x\u2082) \u2194\n    \u2200 \u2983x : \u03b9\u2984, x \u2208 s \u2192 \u2200 \u2983y : \u03b9\u2984, y \u2208 s \u2192 x \u2260 y \u2192 f x \u2260 f y"}, {"line": "simp only [not_imp_not]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem InjOn.pairwise_image {s : Set \u03b9} (h : s.InjOn f) :\n    (f '' s).Pairwise r \u2194 s.Pairwise (r on f) := by\n  simp +contextual [h.eq_iff, Set.Pairwise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\nf : \u03b9 \u2192 \u03b1\ns : Set \u03b9\nh : InjOn f s\n\u22a2 (f '' s).Pairwise r \u2194 s.Pairwise (onFun r f)"}, {"line": "simp +contextual [h.eq_iff, Set.Pairwise]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PairwiseDisjoint.image_of_le (hs : s.PairwiseDisjoint f) {g : \u03b9 \u2192 \u03b9} (hg : f \u2218 g \u2264 f) :\n    (g '' s).PairwiseDisjoint f := by\n  rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 h\n  exact (hs ha hb <| ne_of_apply_ne _ h).mono (hg a) (hg b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint f\ng : \u03b9 \u2192 \u03b9\nhg : f \u2218 g \u2264 f\n\u22a2 (g '' s).PairwiseDisjoint f"}, {"line": "rintro _ \u27e8a, ha, rfl\u27e9 _ \u27e8b, hb, rfl\u27e9 h", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint f\ng : \u03b9 \u2192 \u03b9\nhg : f \u2218 g \u2264 f\na : \u03b9\nha : a \u2208 s\nb : \u03b9\nhb : b \u2208 s\nh : g a \u2260 g b\n\u22a2 onFun Disjoint f (g a) (g b)"}, {"line": "exact (hs ha hb <| ne_of_apply_ne _ h).mono (hg a) (hg b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PairwiseDisjoint.range (g : s \u2192 \u03b9) (hg : \u2200 i : s, f (g i) \u2264 f i)\n    (ht : s.PairwiseDisjoint f) : (range g).PairwiseDisjoint f := by\n  rintro _ \u27e8x, rfl\u27e9 _ \u27e8y, rfl\u27e9 hxy\n  exact ((ht x.2 y.2) fun h => hxy <| congr_arg g <| Subtype.ext h).mono (hg x) (hg y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\ng : \u2191s \u2192 \u03b9\nhg : \u2200 (i : \u2191s), f (g i) \u2264 f \u2191i\nht : s.PairwiseDisjoint f\n\u22a2 (Set.range g).PairwiseDisjoint f"}, {"line": "rintro _ \u27e8x, rfl\u27e9 _ \u27e8y, rfl\u27e9 hxy", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\ng : \u2191s \u2192 \u03b9\nhg : \u2200 (i : \u2191s), f (g i) \u2264 f \u2191i\nht : s.PairwiseDisjoint f\nx y : \u2191s\nhxy : g x \u2260 g y\n\u22a2 onFun Disjoint f (g x) (g y)"}, {"line": "exact ((ht x.2 y.2) fun h => hxy <| congr_arg g <| Subtype.ext h).mono (hg x) (hg y)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma PairwiseDisjoint.eq_or_disjoint\n    (h : s.PairwiseDisjoint f) {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s) :\n    i = j \u2228 Disjoint (f i) (f j) := by\n  rw [or_iff_not_imp_right]\n  exact h.elim hi hj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\nh : s.PairwiseDisjoint f\ni j : \u03b9\nhi : i \u2208 s\nhj : j \u2208 s\n\u22a2 i = j \u2228 Disjoint (f i) (f j)"}, {"line": "rw [or_iff_not_imp_right]", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 \u03b1\nh : s.PairwiseDisjoint f\ni j : \u03b9\nhi : i \u2208 s\nhj : j \u2208 s\n\u22a2 \u00acDisjoint (f i) (f j) \u2192 i = j"}, {"line": "exact h.elim hi hj", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pairwiseDisjoint_range_iff {\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 (Set \u03b2)} :\n    (range f).PairwiseDisjoint id \u2194 \u2200 x y, f x \u2260 f y \u2192 Disjoint (f x) (f y) := by\n  aesop (add simp [PairwiseDisjoint, Set.Pairwise])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\nf : \u03b1 \u2192 Set \u03b2\n\u22a2 (range f).PairwiseDisjoint id \u2194 \u2200 (x y : \u03b1), f x \u2260 f y \u2192 Disjoint (f x) (f y)"}, {"line": "aesop (add simp [PairwiseDisjoint, Set.Pairwise])", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_ne_mem_inter_of_not_pairwiseDisjoint\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac s.PairwiseDisjoint f) :\n    \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x : \u03b1, x \u2208 f i \u2229 f j := by\n  change \u00ac \u2200 i, i \u2208 s \u2192 \u2200 j, j \u2208 s \u2192 i \u2260 j \u2192 \u2200 t, t \u2264 f i \u2192 t \u2264 f j \u2192 t \u2264 \u22a5 at h\n  simp only [not_forall] at h\n  obtain \u27e8i, hi, j, hj, h_ne, t, hfi, hfj, ht\u27e9 := h\n  replace ht : t.Nonempty := by\n    rwa [le_bot_iff, bot_eq_empty, \u2190 Ne, \u2190 nonempty_iff_ne_empty] at ht\n  obtain \u27e8x, hx\u27e9 := ht\n  exact \u27e8i, hi, j, hj, h_ne, x, hfi hx, hfj hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "{s : Set \u03b9} {t : Set \u03b9'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "change \u00ac \u2200 i, i \u2208 s \u2192 \u2200 j, j \u2208 s \u2192 i \u2260 j \u2192 \u2200 t, t \u2264 f i \u2192 t \u2264 f j \u2192 t \u2264 \u22a5 at h", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00ac\u2200 i \u2208 s, \u2200 j \u2208 s, i \u2260 j \u2192 \u2200 t \u2264 f i, t \u2264 f j \u2192 t \u2264 \u22a5\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "simp only [not_forall] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u2203 x, \u2203 (_ : x \u2208 s), \u2203 x_1, \u2203 (_ : x_1 \u2208 s) (_ : x \u2260 x_1), \u2203 x_2, \u2203 (_ : x_2 \u2264 f x) (_ : x_2 \u2264 f x_1), \u00acx_2 \u2264 \u22a5\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "obtain \u27e8i, hi, j, hj, h_ne, t, hfi, hfj, ht\u27e9 := h", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nh_ne : i \u2260 j\nt : Set \u03b1\nhfi : t \u2264 f i\nhfj : t \u2264 f j\nht : \u00act \u2264 \u22a5\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "replace ht : t.Nonempty := by\n    rwa [le_bot_iff, bot_eq_empty, \u2190 Ne, \u2190 nonempty_iff_ne_empty] at ht", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nh_ne : i \u2260 j\nt : Set \u03b1\nhfi : t \u2264 f i\nhfj : t \u2264 f j\nht : t.Nonempty\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "obtain \u27e8x, hx\u27e9 := ht", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\ns : Set \u03b9\nf : \u03b9 \u2192 Set \u03b1\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nh_ne : i \u2260 j\nt : Set \u03b1\nhfi : t \u2264 f i\nhfj : t \u2264 f j\nx : \u03b1\nhx : x \u2208 t\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "exact \u27e8i, hi, j, hj, h_ne, x, hfi hx, hfj hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_lt_mem_inter_of_not_pairwiseDisjoint [LinearOrder \u03b9]\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac s.PairwiseDisjoint f) :\n    \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j := by\n  obtain \u27e8i, hi, j, hj, hne, x, hx\u2081, hx\u2082\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  rcases lt_or_lt_iff_ne.mpr hne with h_lt | h_lt\n  \u00b7 exact \u27e8i, hi, j, hj, h_lt, x, hx\u2081, hx\u2082\u27e9\n  \u00b7 exact \u27e8j, hj, i, hi, h_lt, x, hx\u2082, hx\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "{s : Set \u03b9} {t : Set \u03b9'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Set \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "obtain \u27e8i, hi, j, hj, hne, x, hx\u2081, hx\u2082\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Set \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nhne : i \u2260 j\nx : \u03b1\nhx\u2081 : x \u2208 f i\nhx\u2082 : x \u2208 f j\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "rcases lt_or_lt_iff_ne.mpr hne with h_lt | h_lt", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.inl\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Set \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nhne : i \u2260 j\nx : \u03b1\nhx\u2081 : x \u2208 f i\nhx\u2082 : x \u2208 f j\nh_lt : i < j\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j\n---\ncase intro.intro.intro.intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Set \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nhne : i \u2260 j\nx : \u03b1\nhx\u2081 : x \u2208 f i\nhx\u2082 : x \u2208 f j\nh_lt : j < i\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "\u00b7 exact \u27e8i, hi, j, hj, h_lt, x, hx\u2081, hx\u2082\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u2074 : PartialOrder \u03b1\ninst\u271d\u00b3 : OrderBot \u03b1\ninst\u271d\u00b2 : SemilatticeInf \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ns : Set \u03b9\ninst\u271d : LinearOrder \u03b9\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acs.PairwiseDisjoint f\ni : \u03b9\nhi : i \u2208 s\nj : \u03b9\nhj : j \u2208 s\nhne : i \u2260 j\nx : \u03b1\nhx\u2081 : x \u2208 f i\nhx\u2082 : x \u2208 f j\nh_lt : j < i\n\u22a2 \u2203 i \u2208 s, \u2203 j \u2208 s, i < j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "\u00b7 exact \u27e8j, hj, i, hi, h_lt, x, hx\u2082, hx\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_ne_mem_inter_of_not_pairwise_disjoint\n    {f : \u03b9 \u2192 Set \u03b1} (h : \u00ac Pairwise (Disjoint on f)) :\n    \u2203 i j : \u03b9, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j := by\n  rw [\u2190 pairwise_univ] at h\n  obtain \u27e8i, _hi, j, _hj, h\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h\n  exact \u27e8i, j, h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Basic.lean", "context": {"open": ["Function Order Set"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b9 \u03b9' : Type*} {r p : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f g : \u03b9 \u2192 \u03b1} {s t : Set \u03b1} {a b : \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s t : Set \u03b9} {f g : \u03b9 \u2192 \u03b1}", "[SemilatticeInf \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "{s : Set \u03b9} {t : Set \u03b9'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acPairwise (onFun Disjoint f)\n\u22a2 \u2203 i j, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "rw [\u2190 pairwise_univ] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\nf : \u03b9 \u2192 Set \u03b1\nh : \u00acuniv.Pairwise (onFun Disjoint f)\n\u22a2 \u2203 i j, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "obtain \u27e8i, _hi, j, _hj, h\u27e9 := exists_ne_mem_inter_of_not_pairwiseDisjoint h", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_4\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : SemilatticeInf \u03b1\ninst\u271d : OrderBot \u03b1\nf : \u03b9 \u2192 Set \u03b1\nh\u271d : \u00acuniv.Pairwise (onFun Disjoint f)\ni : \u03b9\n_hi : i \u2208 univ\nj : \u03b9\n_hj : j \u2208 univ\nh : i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j\n\u22a2 \u2203 i j, i \u2260 j \u2227 \u2203 x, x \u2208 f i \u2229 f j"}, {"line": "exact \u27e8i, j, h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pairwise_sUnion {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).Pairwise r \u2194 \u2200 a \u2208 s, Set.Pairwise a r := by\n  rw [sUnion_eq_iUnion]\n  rw [pairwise_iUnion h.directed_val]\n  rw [SetCoe.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Lattice.lean", "context": {"open": ["Function Set Order"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set (Set \u03b1)\nh : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\n\u22a2 (\u22c3\u2080 s).Pairwise r \u2194 \u2200 a \u2208 s, a.Pairwise r"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set (Set \u03b1)\nh : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\n\u22a2 (\u22c3 i, \u2191i).Pairwise r \u2194 \u2200 a \u2208 s, a.Pairwise r"}, {"line": "rw [pairwise_iUnion h.directed_val]", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ns : Set (Set \u03b1)\nh : DirectedOn (fun x1 x2 => x1 \u2286 x2) s\n\u22a2 (\u2200 (n : { x // x \u2208 s }), (\u2191n).Pairwise r) \u2194 \u2200 a \u2208 s, a.Pairwise r"}, {"line": "rw [SetCoe.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PairwiseDisjoint.biUnion {s : Set \u03b9'} {g : \u03b9' \u2192 Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => \u2a06 i \u2208 g i', f i)\n    (hg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f) : (\u22c3 i \u2208 s, g i).PairwiseDisjoint f := by\n  rintro a ha b hb hab\n  simp_rw [Set.mem_iUnion] at ha hb\n  obtain \u27e8c, hc, ha\u27e9 := ha\n  obtain \u27e8d, hd, hb\u27e9 := hb\n  obtain hcd | hcd := eq_or_ne (g c) (g d)\n  \u00b7 exact hg d hd (hcd \u25b8 ha) hb hab\n  \u00b7 exact (hs hc hd <| ne_of_apply_ne _ hcd).mono\n      (le_iSup\u2082 (f := fun i _ => f i) a ha)\n      (le_iSup\u2082 (f := fun i _ => f i) b hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Lattice.lean", "context": {"open": ["Function Set Order"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\n\u22a2 (\u22c3 i \u2208 s, g i).PairwiseDisjoint f"}, {"line": "rintro a ha b hb hab", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na : \u03b9\nha : a \u2208 \u22c3 i \u2208 s, g i\nb : \u03b9\nhb : b \u2208 \u22c3 i \u2208 s, g i\nhab : a \u2260 b\n\u22a2 onFun Disjoint f a b"}, {"line": "simp_rw [Set.mem_iUnion] at ha hb", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nha : \u2203 i, \u2203 (_ : i \u2208 s), a \u2208 g i\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 g i\n\u22a2 onFun Disjoint f a b"}, {"line": "obtain \u27e8c, hc, ha\u27e9 := ha", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nhb : \u2203 i, \u2203 (_ : i \u2208 s), b \u2208 g i\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 g c\n\u22a2 onFun Disjoint f a b"}, {"line": "obtain \u27e8d, hd, hb\u27e9 := hb", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 g c\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 g d\n\u22a2 onFun Disjoint f a b"}, {"line": "obtain hcd | hcd := eq_or_ne (g c) (g d)", "tactic_state": "case intro.intro.intro.intro.inl\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 g c\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 g d\nhcd : g c = g d\n\u22a2 onFun Disjoint f a b\n---\ncase intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 g c\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 g d\nhcd : g c \u2260 g d\n\u22a2 onFun Disjoint f a b"}, {"line": "\u00b7 exact hg d hd (hcd \u25b8 ha) hb hab", "tactic_state": "case intro.intro.intro.intro.inr\n\u03b1 : Type u_1\n\u03b9 : Type u_2\n\u03b9' : Type u_3\ninst\u271d\u00b2 : PartialOrder \u03b1\ninst\u271d\u00b9 : OrderBot \u03b1\ninst\u271d : CompleteLattice \u03b1\ns : Set \u03b9'\ng : \u03b9' \u2192 Set \u03b9\nf : \u03b9 \u2192 \u03b1\nhs : s.PairwiseDisjoint fun i' => \u2a06 i \u2208 g i', f i\nhg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f\na b : \u03b9\nhab : a \u2260 b\nc : \u03b9'\nhc : c \u2208 s\nha : a \u2208 g c\nd : \u03b9'\nhd : d \u2208 s\nhb : b \u2208 g d\nhcd : g c \u2260 g d\n\u22a2 onFun Disjoint f a b"}, {"line": "\u00b7 exact (hs hc hd <| ne_of_apply_ne _ hcd).mono\n      (le_iSup\u2082 (f := fun i _ => f i) a ha)\n      (le_iSup\u2082 (f := fun i _ => f i) b hb)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.pairwiseDisjoint_iff :\n    s.PairwiseDisjoint f \u2194 \u2200 \u2983i\u2984, i \u2208 s \u2192 \u2200 \u2983j\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j := by\n  simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Lattice.lean", "context": {"open": ["Function Set Order"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}", "[Frame \u03b1]", "{f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 Set \u03b1\ns : Set \u03b9\n\u22a2 s.PairwiseDisjoint f \u2194 \u2200 \u2983i : \u03b9\u2984, i \u2208 s \u2192 \u2200 \u2983j : \u03b9\u2984, j \u2208 s \u2192 (f i \u2229 f j).Nonempty \u2192 i = j"}, {"line": "simp [Set.PairwiseDisjoint, Set.Pairwise, Function.onFun, not_imp_comm (a := _ = _),\n    not_disjoint_iff_nonempty_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.pairwiseDisjoint_pair_insert {s : Set \u03b1} {a : \u03b1} (ha : a \u2209 s) :\n    s.powerset.PairwiseDisjoint fun t \u21a6 ({t, insert a t} : Set (Set \u03b1)) := by\n  rw [pairwiseDisjoint_iff]\n  rintro i hi j hj\n  have := insert_erase_invOn.2.injOn (not_mem_subset hi ha) (not_mem_subset hj ha)\n  aesop (add simp [Set.Nonempty, Set.subset_def])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Lattice.lean", "context": {"open": ["Function Set Order"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}", "[Frame \u03b1]", "{f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 (\ud835\udcab s).PairwiseDisjoint fun t => {t, insert a t}"}, {"line": "rw [pairwiseDisjoint_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\n\u22a2 \u2200 \u2983i : Set \u03b1\u2984, i \u2208 \ud835\udcab s \u2192 \u2200 \u2983j : Set \u03b1\u2984, j \u2208 \ud835\udcab s \u2192 ({i, insert a i} \u2229 {j, insert a j}).Nonempty \u2192 i = j"}, {"line": "rintro i hi j hj", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\ni : Set \u03b1\nhi : i \u2208 \ud835\udcab s\nj : Set \u03b1\nhj : j \u2208 \ud835\udcab s\n\u22a2 ({i, insert a i} \u2229 {j, insert a j}).Nonempty \u2192 i = j"}, {"line": "have := insert_erase_invOn.2.injOn (not_mem_subset hi ha) (not_mem_subset hj ha)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\ns : Set \u03b1\na : \u03b1\nha : a \u2209 s\ni : Set \u03b1\nhi : i \u2208 \ud835\udcab s\nj : Set \u03b1\nhj : j \u2208 \ud835\udcab s\nthis : insert a i = insert a j \u2192 i = j\n\u22a2 ({i, insert a i} \u2229 {j, insert a j}).Nonempty \u2192 i = j"}, {"line": "aesop (add simp [Set.Nonempty, Set.subset_def])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion (h\u2080 : (s \u222a t).PairwiseDisjoint f)\n    (h\u2081 : \u2200 i \u2208 s, (f i).Nonempty) (h : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i) : s \u2286 t := by\n  rintro i hi\n  obtain \u27e8a, hai\u27e9 := h\u2081 i hi\n  obtain \u27e8j, hj, haj\u27e9 := mem_iUnion\u2082.1 (h <| mem_iUnion\u2082_of_mem hi hai)\n  rwa [h\u2080.eq (subset_union_left hi) (subset_union_right hj)\n      (not_disjoint_iff.2 \u27e8a, hai, haj\u27e9)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pairwise/Lattice.lean", "context": {"open": ["Function Set Order"], "variables": ["{\u03b1 \u03b9 \u03b9' : Type*} {\u03ba : Sort*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}", "{f : \u03b9 \u2192 \u03b1} {s : Set \u03b1}", "[PartialOrder \u03b1] [OrderBot \u03b1] {s : Set \u03b9} {f : \u03b9 \u2192 \u03b1}", "[CompleteLattice \u03b1] {s : Set \u03b9} {t : Set \u03b9'}", "[Frame \u03b1]", "{f : \u03b9 \u2192 Set \u03b1} {s t : Set \u03b9}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : (s \u222a t).PairwiseDisjoint f\nh\u2081 : \u2200 i \u2208 s, (f i).Nonempty\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\n\u22a2 s \u2286 t"}, {"line": "rintro i hi", "tactic_state": "\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : (s \u222a t).PairwiseDisjoint f\nh\u2081 : \u2200 i \u2208 s, (f i).Nonempty\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\n\u22a2 i \u2208 t"}, {"line": "obtain \u27e8a, hai\u27e9 := h\u2081 i hi", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : (s \u222a t).PairwiseDisjoint f\nh\u2081 : \u2200 i \u2208 s, (f i).Nonempty\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\n\u22a2 i \u2208 t"}, {"line": "obtain \u27e8j, hj, haj\u27e9 := mem_iUnion\u2082.1 (h <| mem_iUnion\u2082_of_mem hi hai)", "tactic_state": "case intro.intro.intro\n\u03b1 : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : OrderBot \u03b1\ninst\u271d\u00b9 : CompleteLattice \u03b1\ninst\u271d : Frame \u03b1\nf : \u03b9 \u2192 Set \u03b1\ns t : Set \u03b9\nh\u2080 : (s \u222a t).PairwiseDisjoint f\nh\u2081 : \u2200 i \u2208 s, (f i).Nonempty\nh : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i\ni : \u03b9\nhi : i \u2208 s\na : \u03b1\nhai : a \u2208 f i\nj : \u03b9\nhj : j \u2208 t\nhaj : a \u2208 f j\n\u22a2 i \u2208 t"}, {"line": "rwa [h\u2080.eq (subset_union_left hi) (subset_union_right hj)\n      (not_disjoint_iff.2 \u27e8a, hai, haj\u27e9)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mulSupport_comp_inv_smul [One \u03b3] (c : \u03b1) (f : \u03b2 \u2192 \u03b3) :\n    (mulSupport fun x \u21a6 f (c\u207b\u00b9 \u2022 x)) = c \u2022 mulSupport f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem]\n  simp only [mem_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pointwise/Support.lean", "context": {"open": ["Pointwise", "Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Group \u03b1] [MulAction \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : One \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\n\u22a2 (mulSupport fun x => f (c\u207b\u00b9 \u2022 x)) = c \u2022 mulSupport f"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : One \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 (x \u2208 mulSupport fun x => f (c\u207b\u00b9 \u2022 x)) \u2194 x \u2208 c \u2022 mulSupport f"}, {"line": "simp only [mem_smul_set_iff_inv_smul_mem]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : One \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 (x \u2208 mulSupport fun x => f (c\u207b\u00b9 \u2022 x)) \u2194 c\u207b\u00b9 \u2022 x \u2208 mulSupport f"}, {"line": "simp only [mem_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem support_comp_inv_smul [Zero \u03b3] (c : \u03b1) (f : \u03b2 \u2192 \u03b3) :\n    (support fun x \u21a6 f (c\u207b\u00b9 \u2022 x)) = c \u2022 support f := by\n  ext x\n  simp only [mem_smul_set_iff_inv_smul_mem]\n  simp only [mem_support]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Pointwise/Support.lean", "context": {"open": ["Pointwise", "Function Set"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} [Group \u03b1] [MulAction \u03b1 \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : Zero \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\n\u22a2 (support fun x => f (c\u207b\u00b9 \u2022 x)) = c \u2022 support f"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : Zero \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 (x \u2208 support fun x => f (c\u207b\u00b9 \u2022 x)) \u2194 x \u2208 c \u2022 support f"}, {"line": "simp only [mem_smul_set_iff_inv_smul_mem]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : MulAction \u03b1 \u03b2\ninst\u271d : Zero \u03b3\nc : \u03b1\nf : \u03b2 \u2192 \u03b3\nx : \u03b2\n\u22a2 (x \u2208 support fun x => f (c\u207b\u00b9 \u2022 x)) \u2194 c\u207b\u00b9 \u2022 x \u2208 support f"}, {"line": "simp only [mem_support]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInf_def {s : Set (Setoid \u03b1)} : \u21d1(sInf s) = sInf ((\u21d1) '' s) := by\n  ext\n  simp only [sInf_image]\n  simp only [iInf_apply]\n  simp only [iInf_Prop_eq]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Basic.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set (Setoid \u03b1)\n\u22a2 \u21d1(sInf s) = sInf (@Setoid.r \u03b1 '' s)"}, {"line": "ext", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s) x\u271d\u00b9 x\u271d \u2194 sInf (@Setoid.r \u03b1 '' s) x\u271d\u00b9 x\u271d"}, {"line": "simp only [sInf_image]", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s) x\u271d\u00b9 x\u271d \u2194 (\u2a05 a \u2208 s, \u21d1a) x\u271d\u00b9 x\u271d"}, {"line": "simp only [iInf_apply]", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s) x\u271d\u00b9 x\u271d \u2194 \u2a05 i \u2208 s, i x\u271d\u00b9 x\u271d"}, {"line": "simp only [iInf_Prop_eq]", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\ns : Set (Setoid \u03b1)\nx\u271d\u00b9 x\u271d : \u03b1\n\u22a2 (sInf s) x\u271d\u00b9 x\u271d \u2194 \u2200 i \u2208 s, i x\u271d\u00b9 x\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_top_iff {s : Setoid \u03b1} : s = (\u22a4 : Setoid \u03b1) \u2194 \u2200 x y : \u03b1, s x y := by\n  rw [_root_.eq_top_iff]\n  rw [Setoid.le_def]\n  rw [Setoid.top_def]\n  simp only [Pi.top_apply]\n  simp only [Prop.top_eq_true]\n  simp only [forall_true_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Basic.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 s = \u22a4 \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "rw [_root_.eq_top_iff]", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 \u22a4 \u2264 s \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "rw [Setoid.le_def]", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 (\u2200 {x y : \u03b1}, \u22a4 x y \u2192 s x y) \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "rw [Setoid.top_def]", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 (\u2200 {x y : \u03b1}, \u22a4 x y \u2192 s x y) \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "simp only [Pi.top_apply]", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 (\u2200 {x y : \u03b1}, \u22a4 \u2192 s x y) \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "simp only [Prop.top_eq_true]", "tactic_state": "\u03b1 : Type u_1\ns : Setoid \u03b1\n\u22a2 (\u2200 {x y : \u03b1}, True \u2192 s x y) \u2194 \u2200 (x y : \u03b1), s x y"}, {"line": "simp only [forall_true_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quotient_mk_sInf_eq {S : Set (Setoid \u03b1)} {x y : \u03b1} :\n    Quotient.mk (sInf S) x = Quotient.mk (sInf S) y \u2194 \u2200 s \u2208 S, s x y := by\n  simp [sInf_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Basic.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Setoid \u03b1)\nx y : \u03b1\n\u22a2 \u27e6x\u27e7 = \u27e6y\u27e7 \u2194 \u2200 s \u2208 S, s x y"}, {"line": "simp [sInf_iff]", "tactic_state": "\u03b1 : Type u_1\nS : Set (Setoid \u03b1)\nx y : \u03b1\n\u22a2 (sInf S) x y \u2194 \u2200 s \u2208 S, s x y"}]}
{"declaration": "theorem classes_ker_subset_fiber_set {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) :\n    (Setoid.ker f).classes \u2286 Set.range fun y => { x | f x = y } := by\n  rintro s \u27e8x, rfl\u27e9\n  rw [Set.mem_range]\n  exact \u27e8f x, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Partition.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\n\u22a2 (Setoid.ker f).classes \u2286 Set.range fun y => {x | f x = y}"}, {"line": "rintro s \u27e8x, rfl\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 {x_1 | (Setoid.ker f) x_1 x} \u2208 Set.range fun y => {x | f x = y}"}, {"line": "rw [Set.mem_range]", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 \u2203 y, {x | f x = y} = {x_1 | (Setoid.ker f) x_1 x}"}, {"line": "exact \u27e8f x, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.PairwiseDisjoint.isPartition_of_exists_of_ne_empty {\u03b1 : Type*} {s : Set (Set \u03b1)}\n    (h\u2081 : s.PairwiseDisjoint id) (h\u2082 : \u2200 a : \u03b1, \u2203 x \u2208 s, a \u2208 x) (h\u2083 : \u2205 \u2209 s) :\n    Setoid.IsPartition s := by\n  refine \u27e8h\u2083, fun a \u21a6 existsUnique_of_exists_of_unique (h\u2082 a) ?_\u27e9\n  intro b\u2081 b\u2082 hb\u2081 hb\u2082\n  apply h\u2081.elim hb\u2081.1 hb\u2082.1\n  simp only [Set.not_disjoint_iff]\n  exact \u27e8a, hb\u2081.2, hb\u2082.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Partition.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ns : Set (Set \u03b1)\nh\u2081 : s.PairwiseDisjoint id\nh\u2082 : \u2200 (a : \u03b1), \u2203 x \u2208 s, a \u2208 x\nh\u2083 : \u2205 \u2209 s\n\u22a2 Setoid.IsPartition s"}, {"line": "refine \u27e8h\u2083, fun a \u21a6 existsUnique_of_exists_of_unique (h\u2082 a) ?_\u27e9", "tactic_state": "\u03b1 : Type u_2\ns : Set (Set \u03b1)\nh\u2081 : s.PairwiseDisjoint id\nh\u2082 : \u2200 (a : \u03b1), \u2203 x \u2208 s, a \u2208 x\nh\u2083 : \u2205 \u2209 s\na : \u03b1\n\u22a2 \u2200 (y\u2081 y\u2082 : Set \u03b1), y\u2081 \u2208 s \u2227 a \u2208 y\u2081 \u2192 y\u2082 \u2208 s \u2227 a \u2208 y\u2082 \u2192 y\u2081 = y\u2082"}, {"line": "intro b\u2081 b\u2082 hb\u2081 hb\u2082", "tactic_state": "\u03b1 : Type u_2\ns : Set (Set \u03b1)\nh\u2081 : s.PairwiseDisjoint id\nh\u2082 : \u2200 (a : \u03b1), \u2203 x \u2208 s, a \u2208 x\nh\u2083 : \u2205 \u2209 s\na : \u03b1\nb\u2081 b\u2082 : Set \u03b1\nhb\u2081 : b\u2081 \u2208 s \u2227 a \u2208 b\u2081\nhb\u2082 : b\u2082 \u2208 s \u2227 a \u2208 b\u2082\n\u22a2 b\u2081 = b\u2082"}, {"line": "apply h\u2081.elim hb\u2081.1 hb\u2082.1", "tactic_state": "\u03b1 : Type u_2\ns : Set (Set \u03b1)\nh\u2081 : s.PairwiseDisjoint id\nh\u2082 : \u2200 (a : \u03b1), \u2203 x \u2208 s, a \u2208 x\nh\u2083 : \u2205 \u2209 s\na : \u03b1\nb\u2081 b\u2082 : Set \u03b1\nhb\u2081 : b\u2081 \u2208 s \u2227 a \u2208 b\u2081\nhb\u2082 : b\u2082 \u2208 s \u2227 a \u2208 b\u2082\n\u22a2 \u00acDisjoint (id b\u2081) (id b\u2082)"}, {"line": "simp only [Set.not_disjoint_iff]", "tactic_state": "\u03b1 : Type u_2\ns : Set (Set \u03b1)\nh\u2081 : s.PairwiseDisjoint id\nh\u2082 : \u2200 (a : \u03b1), \u2203 x \u2208 s, a \u2208 x\nh\u2083 : \u2205 \u2209 s\na : \u03b1\nb\u2081 b\u2082 : Set \u03b1\nhb\u2081 : b\u2081 \u2208 s \u2227 a \u2208 b\u2081\nhb\u2082 : b\u2082 \u2208 s \u2227 a \u2208 b\u2082\n\u22a2 \u2203 x \u2208 id b\u2081, x \u2208 id b\u2082"}, {"line": "exact \u27e8a, hb\u2081.2, hb\u2082.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion : \u22c3 i, s i = univ := by\n  ext x\n  simp [hs.exists_mem x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Setoid/Partition.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation", "Set"], "variables": ["{\u03b1 : Type*}", "(\u03b1) in", "{\u03b9 \u03b1 : Type*} {s : \u03b9 \u2192 Set \u03b1}", "(hs : IndexedPartition s)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s\u271d : ?m.63 \u2192 Set ?m.64\n\u03b1 : Type u_1\nhs : IndexedPartition s\u271d\nx\u271d\u00b9 : Type u_3\nx\u271d : Type u_2\ns : x\u271d\u00b9 \u2192 Set x\u271d\n\u22a2 \u22c3 i, s i = univ"}, {"line": "ext x", "tactic_state": "case h\ns\u271d : ?m.63 \u2192 Set ?m.64\n\u03b1 : Type u_1\nhs : IndexedPartition s\u271d\nx\u271d\u00b9 : Type u_3\nx\u271d : Type u_2\ns : x\u271d\u00b9 \u2192 Set x\u271d\nx : x\u271d\n\u22a2 x \u2208 \u22c3 i, s i \u2194 x \u2208 univ"}, {"line": "simp [hs.exists_mem x]", "tactic_state": "case h\ns\u271d : ?m.63 \u2192 Set ?m.64\n\u03b1 : Type u_1\nhs : IndexedPartition s\u271d\nx\u271d\u00b9 : Type u_3\nx\u271d : Type u_2\ns : x\u271d\u00b9 \u2192 Set x\u271d\nx : x\u271d\n\u22a2 \u2203 i, x \u2208 s i"}]}
{"declaration": "theorem lex_swap : Lex (Function.swap r) s a b \u2194 Lex r (fun i => Function.swap (s i)) b a := by\n  constructor <;>\n    \u00b7 rintro (\u27e8a, b, h\u27e9 | \u27e8a, b, h\u27e9)\n      \u00b7 exact Lex.left _ _ h\n      \u00b7 exact Lex.right _ _ h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sigma/Lex.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} {r r\u2081 r\u2082 : \u03b9 \u2192 \u03b9 \u2192 Prop} {s s\u2081 s\u2082 : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2194 sorry"}, {"line": "constructor <;>\n    \u00b7 rintro (\u27e8a, b, h\u27e9 | \u27e8a, b, h\u27e9)\n      \u00b7 exact Lex.left _ _ h\n      \u00b7 exact Lex.right _ _ h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk.inj_iff {a\u2081 a\u2082 : \u03b1} {b\u2081 : \u03b2 a\u2081} {b\u2082 : \u03b2 a\u2082} :\n    Sigma.mk a\u2081 b\u2081 = \u27e8a\u2082, b\u2082\u27e9 \u2194 a\u2081 = a\u2082 \u2227 HEq b\u2081 b\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sigma/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b2\u2081 : \u03b1\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b1\u2082 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_4\na\u2081 a\u2082 : \u03b1\nb\u2081 : \u03b2 a\u2081\nb\u2082 : \u03b2 a\u2082\n\u22a2 \u27e8a\u2081, b\u2081\u27e9 = \u27e8a\u2082, b\u2082\u27e9 \u2194 a\u2081 = a\u2082 \u2227 HEq b\u2081 b\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Function.eq_of_sigmaMk_comp {\u03b3 : Type*} [Nonempty \u03b3]\n    {a b : \u03b1} {f : \u03b3 \u2192 \u03b2 a} {g : \u03b3 \u2192 \u03b2 b} (h : Sigma.mk a \u2218 f = Sigma.mk b \u2218 g) :\n    a = b \u2227 HEq f g := by\n  rcases \u2039Nonempty \u03b3\u203a with \u27e8i\u27e9\n  obtain rfl : a = b := congr_arg Sigma.fst (congr_fun h i)\n  simpa [funext_iff] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sigma/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b2\u2081 : \u03b1\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b1\u2082 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_4\n\u03b3 : Type u_7\ninst\u271d : Nonempty \u03b3\na b : \u03b1\nf : \u03b3 \u2192 \u03b2 a\ng : \u03b3 \u2192 \u03b2 b\nh : Sigma.mk a \u2218 f = Sigma.mk b \u2218 g\n\u22a2 a = b \u2227 HEq f g"}, {"line": "rcases \u2039Nonempty \u03b3\u203a with \u27e8i\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_4\n\u03b3 : Type u_7\ninst\u271d : Nonempty \u03b3\na b : \u03b1\nf : \u03b3 \u2192 \u03b2 a\ng : \u03b3 \u2192 \u03b2 b\nh : Sigma.mk a \u2218 f = Sigma.mk b \u2218 g\ni : \u03b3\n\u22a2 a = b \u2227 HEq f g"}, {"line": "obtain rfl : a = b := congr_arg Sigma.fst (congr_fun h i)", "tactic_state": "case intro\n\u03b1 : Type u_1\n\u03b2 : \u03b1 \u2192 Type u_4\n\u03b3 : Type u_7\ninst\u271d : Nonempty \u03b3\na : \u03b1\nf : \u03b3 \u2192 \u03b2 a\ni : \u03b3\ng : \u03b3 \u2192 \u03b2 a\nh : Sigma.mk a \u2218 f = Sigma.mk a \u2218 g\n\u22a2 a = a \u2227 HEq f g"}, {"line": "simpa [funext_iff] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Surjective.sigma_map {f\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082} {f\u2082 : \u2200 a, \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)}\n    (h\u2081 : Surjective f\u2081) (h\u2082 : \u2200 a, Surjective (f\u2082 a)) : Surjective (Sigma.map f\u2081 f\u2082) := by\n  simp only [Surjective]\n  simp only [Sigma.forall]\n  simp only [h\u2081.forall]\n  exact fun i \u21a6 (h\u2082 _).forall.2 fun x \u21a6 \u27e8\u27e8i, x\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sigma/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1\u2081 \u03b1\u2082 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b2\u2081 : \u03b1\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b1\u2082 \u2192 Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1\u2081 : Type u_2\n\u03b1\u2082 : Type u_3\n\u03b2\u2081 : \u03b1\u2081 \u2192 Type u_5\n\u03b2\u2082 : \u03b1\u2082 \u2192 Type u_6\nf\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082\nf\u2082 : (a : \u03b1\u2081) \u2192 \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)\nh\u2081 : Surjective f\u2081\nh\u2082 : \u2200 (a : \u03b1\u2081), Surjective (f\u2082 a)\n\u22a2 Surjective (Sigma.map f\u2081 f\u2082)"}, {"line": "simp only [Surjective]", "tactic_state": "\u03b1\u2081 : Type u_2\n\u03b1\u2082 : Type u_3\n\u03b2\u2081 : \u03b1\u2081 \u2192 Type u_5\n\u03b2\u2082 : \u03b1\u2082 \u2192 Type u_6\nf\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082\nf\u2082 : (a : \u03b1\u2081) \u2192 \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)\nh\u2081 : Surjective f\u2081\nh\u2082 : \u2200 (a : \u03b1\u2081), Surjective (f\u2082 a)\n\u22a2 \u2200 (b : Sigma \u03b2\u2082), \u2203 a, Sigma.map f\u2081 f\u2082 a = b"}, {"line": "simp only [Sigma.forall]", "tactic_state": "\u03b1\u2081 : Type u_2\n\u03b1\u2082 : Type u_3\n\u03b2\u2081 : \u03b1\u2081 \u2192 Type u_5\n\u03b2\u2082 : \u03b1\u2082 \u2192 Type u_6\nf\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082\nf\u2082 : (a : \u03b1\u2081) \u2192 \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)\nh\u2081 : Surjective f\u2081\nh\u2082 : \u2200 (a : \u03b1\u2081), Surjective (f\u2082 a)\n\u22a2 \u2200 (a : \u03b1\u2082) (b : \u03b2\u2082 a), \u2203 a_1, Sigma.map f\u2081 f\u2082 a_1 = \u27e8a, b\u27e9"}, {"line": "simp only [h\u2081.forall]", "tactic_state": "\u03b1\u2081 : Type u_2\n\u03b1\u2082 : Type u_3\n\u03b2\u2081 : \u03b1\u2081 \u2192 Type u_5\n\u03b2\u2082 : \u03b1\u2082 \u2192 Type u_6\nf\u2081 : \u03b1\u2081 \u2192 \u03b1\u2082\nf\u2082 : (a : \u03b1\u2081) \u2192 \u03b2\u2081 a \u2192 \u03b2\u2082 (f\u2081 a)\nh\u2081 : Surjective f\u2081\nh\u2082 : \u2200 (a : \u03b1\u2081), Surjective (f\u2082 a)\n\u22a2 \u2200 (x : \u03b1\u2081) (b : \u03b2\u2082 (f\u2081 x)), \u2203 a, Sigma.map f\u2081 f\u2082 a = \u27e8f\u2081 x, b\u27e9"}, {"line": "exact fun i \u21a6 (h\u2082 _).forall.2 fun x \u21a6 \u27e8\u27e8i, x\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem head_drop (a : Stream' \u03b1) (n : \u2115) : (a.drop n).head = a.get n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\na : Stream' \u03b1\nn : \u2115\n\u22a2 (Stream'.drop n a).head = a.get n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem append_stream_head_tail (s : Stream' \u03b1) : [head s] ++\u209b tail s = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nhead : x\u271d\u00b9\nx\u271d : Sort u_2\ntail : x\u271d\ns : Stream' \u03b1\n\u22a2 [sorry] ++\u209b sorry = s"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nhead : x\u271d\u00b9\nx\u271d : Sort u_2\ntail : x\u271d\ns : Stream' \u03b1\n\u22a2 Stream'.cons (sorry ()) (sorry ()) = s"}]}
{"declaration": "theorem length_take (n : \u2115) (s : Stream' \u03b1) : (take n s).length = n := by\n  induction n generalizing s <;> simp [*, take_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ntake : x\u271d\nn : \u2115\ns : Stream' \u03b1\n\u22a2 sorry = n"}, {"line": "induction n generalizing s <;> simp [*, take_succ]", "tactic_state": "case zero\n\u03b1 : Type u\nx\u271d : Sort u_1\ntake : x\u271d\ns : Stream' \u03b1\n\u22a2 sorry () = 0\n---\ncase succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ntake : x\u271d\nn\u271d : \u2115\na\u271d : Stream' \u03b1 \u2192 sorry = n\u271d\ns : Stream' \u03b1\n\u22a2 sorry () = n\u271d + 1"}]}
{"declaration": "theorem append_take_drop : \u2200 (n : \u2115) (s : Stream' \u03b1),\n    appendStream' (take n s) (drop n s) = s := by\n  intro n\n  induction' n with n' ih\n  \u00b7 intro s\n    rfl\n  \u00b7 intro s\n    rw [take_succ]\n    rw [drop_succ]\n    rw [cons_append_stream]\n    rw [ih (tail s)]\n    rw [Stream'.eta]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nappendStream' : x\u271d\n\u22a2 \u2115 \u2192 \u2200 (s : Stream' \u03b1), sorry = s"}, {"line": "intro n", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nappendStream' : x\u271d\nn : \u2115\n\u22a2 \u2200 (s : Stream' \u03b1), sorry = s"}, {"line": "induction' n with n' ih", "tactic_state": "case zero\n\u03b1 : Type u\nx\u271d : Sort u_1\nappendStream' : x\u271d\n\u22a2 \u2200 (s : Stream' \u03b1), sorry = s\n---\ncase succ\n\u03b1 : Type u\nx\u271d : Sort u_1\nappendStream' : x\u271d\nn' : \u2115\nih : \u2200 (s : Stream' \u03b1), sorry = s\n\u22a2 \u2200 (s : Stream' \u03b1), sorry = s"}, {"line": "\u00b7 intro s\n    rfl", "tactic_state": "case succ\n\u03b1 : Type u\nx\u271d : Sort u_1\nappendStream' : x\u271d\nn' : \u2115\nih : \u2200 (s : Stream' \u03b1), sorry = s\n\u22a2 \u2200 (s : Stream' \u03b1), sorry = s"}, {"line": "\u00b7 intro s\n    rw [take_succ]\n    rw [drop_succ]\n    rw [cons_append_stream]\n    rw [ih (tail s)]\n    rw [Stream'.eta]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma append_take : x ++ (a.take n) = (x ++\u209b a).take (x.length + n) := by\n  induction' x <;> simp [take, Nat.add_comm, cons_append_stream, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nn : \u2115\nx : List \u03b1\na : Stream' \u03b1\n\u22a2 x ++ Stream'.take n a = Stream'.take (x.length + n) (x ++\u209b a)"}, {"line": "induction' x <;> simp [take, Nat.add_comm, cons_append_stream, *]", "tactic_state": "case cons\n\u03b1 : Type u\nn : \u2115\nx : List \u03b1\na : Stream' \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : tail\u271d ++ Stream'.take n a = Stream'.take (tail\u271d.length + n) (tail\u271d ++\u209b a)\n\u22a2 head\u271d :: Stream'.take (n + tail\u271d.length) (tail\u271d ++\u209b a) = Stream'.take (n + (tail\u271d.length + 1)) (head\u271d :: tail\u271d ++\u209b a)"}]}
{"declaration": "lemma take_add : a.take (m + n) = a.take m ++ (a.drop m).take n := by\n  apply append_left_injective _ _ (a.drop (m + n)) ((a.drop m).drop n) <;>\n    simp [- drop_drop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm n : \u2115\na : Stream' \u03b1\n\u22a2 Stream'.take (m + n) a = Stream'.take m a ++ Stream'.take n (Stream'.drop m a)"}, {"line": "apply append_left_injective _ _ (a.drop (m + n)) ((a.drop m).drop n) <;>\n    simp [- drop_drop]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map_take (f : \u03b1 \u2192 \u03b2) : (a.take n).map f = (a.map f).take n := by\n  apply List.ext_getElem <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nn : \u2115\na : Stream' \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 List.map f (Stream'.take n a) = Stream'.take n (Stream'.map f a)"}, {"line": "apply List.ext_getElem <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma take_drop : (a.drop m).take n = (a.take (m + n)).drop m := by\n  apply List.ext_getElem <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nm n : \u2115\na : Stream' \u03b1\n\u22a2 Stream'.take n (Stream'.drop m a) = List.drop m (Stream'.take (m + n) a)"}, {"line": "apply List.ext_getElem <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_get_inits_core :\n    \u2200 (a : \u03b1) (n : \u2115) (l : List \u03b1) (s : Stream' \u03b1),\n      (a::get (initsCore l s) n) = get (initsCore (a::l) s) n := by\n  intro a n\n  induction' n with n' ih\n  \u00b7 intros\n    rfl\n  \u00b7 intro l s\n    rw [get_succ]\n    rw [inits_core_eq]\n    rw [tail_cons]\n    rw [ih]\n    rw [inits_core_eq (a::l) s]\n    rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Stream/Init.lean", "context": {"open": ["Nat Function Option"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b4 : Type w}", "(m n : \u2115) (x y : List \u03b1) (a b : Stream' \u03b1)", "(f : \u03b1 \u2192 \u03b2)", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b4)", "(R : Stream' \u03b1 \u2192 Stream' \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ninitsCore : x\u271d\n\u22a2 \u2200 (a : \u03b1), \u2115 \u2192 List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry"}, {"line": "intro a n", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ninitsCore : x\u271d\na : \u03b1\nn : \u2115\n\u22a2 List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry"}, {"line": "induction' n with n' ih", "tactic_state": "case zero\n\u03b1 : Type u\nx\u271d : Sort u_1\ninitsCore : x\u271d\na : \u03b1\n\u22a2 List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry\n---\ncase succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ninitsCore : x\u271d\na : \u03b1\nn' : \u2115\nih : List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry\n\u22a2 List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry"}, {"line": "\u00b7 intros\n    rfl", "tactic_state": "case succ\n\u03b1 : Type u\nx\u271d : Sort u_1\ninitsCore : x\u271d\na : \u03b1\nn' : \u2115\nih : List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry\n\u22a2 List \u03b1 \u2192 Stream' \u03b1 \u2192 a :: sorry = sorry"}, {"line": "\u00b7 intro l s\n    rw [get_succ]\n    rw [inits_core_eq]\n    rw [tail_cons]\n    rw [ih]\n    rw [inits_core_eq (a::l) s]\n    rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma length_eq_list_length (l : List Char) : (String.mk l).length = l.length := by\n  simp only [String.length]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/String/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : List Char\n\u22a2 { data := l }.length = l.length"}, {"line": "simp only [String.length]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_isLeft_and_isRight {x : \u03b1 \u2295 \u03b2} : \u00ac(x.isLeft \u2227 x.isRight) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {\u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\n\u22a2 \u00ac(x.isLeft = true \u2227 x.isRight = true)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_right_iff_getRight_eq {b : \u03b2} : x = inr b \u2194 \u2203 h, x.getRight h = b := by\n  cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {\u03b3 \u03b4 : Type*}", "{x : \u03b1 \u2295 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\nx\u271d : Sort u_3\ninr : x\u271d\nb : \u03b2\n\u22a2 x = sorry \u2194 \u2203 (h : x.isRight = true), x.getRight h = b"}, {"line": "cases x <;> simp", "tactic_state": "case inl\n\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_3\ninr : x\u271d\nb : \u03b2\nval\u271d : \u03b1\n\u22a2 \u00acSum.inl val\u271d = sorry ()\n---\ncase inr\n\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_3\ninr : x\u271d\nb val\u271d : \u03b2\n\u22a2 Sum.inr val\u271d = sorry () \u2194 val\u271d = b"}]}
{"declaration": "theorem getLeft_eq_getLeft? (h\u2081 : x.isLeft) (h\u2082 : x.getLeft?.isSome) :\n    x.getLeft h\u2081 = x.getLeft?.get h\u2082 := by simp [\u2190 getLeft?_eq_some_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {\u03b3 \u03b4 : Type*}", "{x : \u03b1 \u2295 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\nh\u2081 : x.isLeft = true\nh\u2082 : x.getLeft?.isSome = true\n\u22a2 x.getLeft h\u2081 = x.getLeft?.get h\u2082"}, {"line": "simp [\u2190 getLeft?_eq_some_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\nh\u2081 : x.isLeft = true\nh\u2082 : x.getLeft?.isSome = true\n\u22a2 x = Sum.inl (x.getLeft?.get h\u2082)"}]}
{"declaration": "theorem getRight_eq_getRight? (h\u2081 : x.isRight) (h\u2082 : x.getRight?.isSome) :\n    x.getRight h\u2081 = x.getRight?.get h\u2082 := by simp [\u2190 getRight?_eq_some_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b1' : Type w} {\u03b2 : Type v} {\u03b2' : Type x} {\u03b3 \u03b4 : Type*}", "{x : \u03b1 \u2295 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\nh\u2081 : x.isRight = true\nh\u2082 : x.getRight?.isSome = true\n\u22a2 x.getRight h\u2081 = x.getRight?.get h\u2082"}, {"line": "simp [\u2190 getRight?_eq_some_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx : \u03b1 \u2295 \u03b2\nh\u2081 : x.isRight = true\nh\u2082 : x.getRight?.isSome = true\n\u22a2 x = Sum.inr (x.getRight?.get h\u2082)"}]}
{"declaration": "theorem Ioo_inl_inr : Ioo (inl a\u2081) (inr b\u2082) = \u2205 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Interval.lean", "context": {"open": ["Function Sum", "Finset Function"], "variables": ["{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 \u03b3\u2081 \u03b3\u2082 : Type*}", "(f f\u2081 g\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Finset \u03b3\u2081) (g f\u2082 g\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Finset \u03b3\u2082)", "{f f\u2081 g\u2081 g f\u2082 g\u2082} {a : \u03b1\u2081 \u2295 \u03b1\u2082} {b : \u03b2\u2081 \u2295 \u03b2\u2082} {c : \u03b3\u2081 \u2295 \u03b3\u2082}", "(f\u2081 f\u2081' : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Finset \u03b3\u2081) (f\u2082 f\u2082' : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Finset \u03b3\u2082)", "{f\u2081 g\u2081 f\u2082 g\u2082 f\u2081' g\u2081' f\u2082' g\u2082'} {a : \u03b1\u2081 \u2295 \u03b1\u2082} {b : \u03b2\u2081 \u2295 \u03b2\u2082} {c : \u03b3\u2081 \u2295 \u03b3\u2082}", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "(a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\na\u2081 : \u03b1\nb\u2082 : \u03b2\n\u22a2 Ioo (inl a\u2081) (inr b\u2082) = \u2205"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ioo_inr_inl : Ioo (inr b\u2081) (inl a\u2082) = \u2205 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sum/Interval.lean", "context": {"open": ["Function Sum", "Finset Function"], "variables": ["{\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 \u03b3\u2081 \u03b3\u2082 : Type*}", "(f f\u2081 g\u2081 : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Finset \u03b3\u2081) (g f\u2082 g\u2082 : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Finset \u03b3\u2082)", "{f f\u2081 g\u2081 g f\u2082 g\u2082} {a : \u03b1\u2081 \u2295 \u03b1\u2082} {b : \u03b2\u2081 \u2295 \u03b2\u2082} {c : \u03b3\u2081 \u2295 \u03b3\u2082}", "(f\u2081 f\u2081' : \u03b1\u2081 \u2192 \u03b2\u2081 \u2192 Finset \u03b3\u2081) (f\u2082 f\u2082' : \u03b1\u2082 \u2192 \u03b2\u2082 \u2192 Finset \u03b3\u2082)", "{f\u2081 g\u2081 f\u2082 g\u2082 f\u2081' g\u2081' f\u2082' g\u2082'} {a : \u03b1\u2081 \u2295 \u03b1\u2082} {b : \u03b2\u2081 \u2295 \u03b2\u2082} {c : \u03b3\u2081 \u2295 \u03b3\u2082}", "{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2] [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]", "(a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LocallyFiniteOrder \u03b1\ninst\u271d : LocallyFiniteOrder \u03b2\na\u2082 : \u03b1\nb\u2081 : \u03b2\n\u22a2 Ioo (inr b\u2081) (inl a\u2082) = \u2205"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u00abforall\u00bb {p : Sym \u03b1 n \u2192 Prop} :\n    (\u2200 s : Sym \u03b1 n, p s) \u2194 \u2200 (s : Multiset \u03b1) (hs : Multiset.card s = n), p (Sym.mk s hs) := by\n  simp [Sym]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\np : Sym \u03b1 n \u2192 Prop\n\u22a2 (\u2200 (s : Sym \u03b1 n), p s) \u2194 \u2200 (s : Multiset \u03b1) (hs : s.card = n), p (Sym.mk s hs)"}, {"line": "simp [Sym]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma \u00abexists\u00bb {p : Sym \u03b1 n \u2192 Prop} :\n    (\u2203 s : Sym \u03b1 n, p s) \u2194 \u2203 (s : Multiset \u03b1) (hs : Multiset.card s = n), p (Sym.mk s hs) := by\n  simp [Sym]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\np : Sym \u03b1 n \u2192 Prop\n\u22a2 (\u2203 s, p s) \u2194 \u2203 s, \u2203 (hs : s.card = n), p (Sym.mk s hs)"}, {"line": "simp [Sym]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_cons_of_mem {s : Sym \u03b1 (n + 1)} {a : \u03b1} (h : a \u2208 s) : \u2203 t, s = a ::\u209b t := by\n  obtain \u27e8m, h\u27e9 := Multiset.exists_cons_of_mem h\n  have : Multiset.card m = n := by\n    apply_fun Multiset.card at h\n    rw [s.2] at h\n    rw [Multiset.card_cons] at h\n    rw [add_left_inj] at h\n    exact h.symm\n  use \u27e8m, this\u27e9\n  apply Subtype.ext\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\ns : Sym \u03b1 (n + 1)\na : \u03b1\nh : a \u2208 s\n\u22a2 \u2203 t, s = a ::\u209b t"}, {"line": "obtain \u27e8m, h\u27e9 := Multiset.exists_cons_of_mem h", "tactic_state": "case intro\n\u03b1 : Type u_1\nn : \u2115\ns : Sym \u03b1 (n + 1)\na : \u03b1\nh\u271d : a \u2208 s\nm : Multiset \u03b1\nh : \u2191s = a ::\u2098 m\n\u22a2 \u2203 t, s = a ::\u209b t"}, {"line": "have : Multiset.card m = n := by\n    apply_fun Multiset.card at h\n    rw [s.2] at h\n    rw [Multiset.card_cons] at h\n    rw [add_left_inj] at h\n    exact h.symm", "tactic_state": "case intro\n\u03b1 : Type u_1\nn : \u2115\ns : Sym \u03b1 (n + 1)\na : \u03b1\nh\u271d : a \u2208 s\nm : Multiset \u03b1\nh : \u2191s = a ::\u2098 m\nthis : m.card = n\n\u22a2 \u2203 t, s = a ::\u209b t"}, {"line": "use \u27e8m, this\u27e9", "tactic_state": "case h\n\u03b1 : Type u_1\nn : \u2115\ns : Sym \u03b1 (n + 1)\na : \u03b1\nh\u271d : a \u2208 s\nm : Multiset \u03b1\nh : \u2191s = a ::\u2098 m\nthis : m.card = n\n\u22a2 s = a ::\u209b \u27e8m, this\u27e9"}, {"line": "apply Subtype.ext", "tactic_state": "case h.a\n\u03b1 : Type u_1\nn : \u2115\ns : Sym \u03b1 (n + 1)\na : \u03b1\nh\u271d : a \u2208 s\nm : Multiset \u03b1\nh : \u2191s = a ::\u2098 m\nthis : m.card = n\n\u22a2 \u2191s = \u2191(a ::\u209b \u27e8m, this\u27e9)"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem append_comm (s : Sym \u03b1 n') (s' : Sym \u03b1 n') :\n    s.append s' = Sym.cast (add_comm _ _) (s'.append s) := by\n  ext\n  simp [append, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function", "scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn' : \u2115\ns s' : Sym \u03b1 n'\n\u22a2 s.append s' = (Sym.cast \u22ef) (s'.append s)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nn' : \u2115\ns s' : Sym \u03b1 n'\n\u22a2 \u2191(s.append s') = \u2191((Sym.cast \u22ef) (s'.append s))"}, {"line": "simp [append, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_coe_fill_self_of_not_mem [DecidableEq \u03b1] {a : \u03b1} {i : Fin (n + 1)} {s : Sym \u03b1 (n - i)}\n    (hx : a \u2209 s) :\n    count a (fill a i s : Multiset \u03b1) = i := by\n  simp [coe_fill, coe_replicate, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function", "scoped List in", "Multiset"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\nhx : a \u2209 s\n\u22a2 sorry = i"}, {"line": "simp [coe_fill, coe_replicate, hx]", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\nhx : a \u2209 s\n\u22a2 sorry () = i"}]}
{"declaration": "theorem count_coe_fill_of_ne [DecidableEq \u03b1] {a x : \u03b1} {i : Fin (n + 1)} {s : Sym \u03b1 (n - i)}\n    (hx : x \u2260 a) :\n    count x (fill a i s : Multiset \u03b1) = count x s := by\n  suffices x \u2209 Multiset.replicate i a by simp [coe_fill, coe_replicate, this]\n  simp [Multiset.mem_replicate, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Basic.lean", "context": {"open": ["List (Vector)", "Function", "scoped List in", "Multiset"], "variables": ["{\u03b1 \u03b2 : Type*} {n n' m : \u2115} {s : Sym \u03b1 n} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na x : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\nhx : x \u2260 a\n\u22a2 sorry = sorry"}, {"line": "suffices x \u2209 Multiset.replicate i a by simp [coe_fill, coe_replicate, this]", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nx\u271d : Sort u_3\ncount : x\u271d\ninst\u271d : DecidableEq \u03b1\na x : \u03b1\ni : Fin (n + 1)\ns : Sym \u03b1 (n - \u2191i)\nhx : x \u2260 a\n\u22a2 x \u2209 Multiset.replicate (\u2191i) a"}, {"line": "simp [Multiset.mem_replicate, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_image_offDiag (s : Finset \u03b1) : #(s.offDiag.image Sym2.mk) = (#s).choose 2 := by\n  rw [Nat.choose_two_right]\n  rw [Nat.mul_sub_left_distrib]\n  rw [mul_one]\n  rw [\u2190 offDiag_card]\n  rw [Nat.div_eq_of_eq_mul_right Nat.zero_lt_two (two_mul_card_image_offDiag s).symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Card.lean", "context": {"open": ["Finset Fintype Function Sum Nat"], "variables": ["{\u03b1 : Type*}", "(\u03b1) (n : \u2115)", "[DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (image Sym2.mk s.offDiag).card = s.card.choose 2"}, {"line": "rw [Nat.choose_two_right]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (image Sym2.mk s.offDiag).card = s.card * (s.card - 1) / 2"}, {"line": "rw [Nat.mul_sub_left_distrib]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (image Sym2.mk s.offDiag).card = (s.card * s.card - s.card * 1) / 2"}, {"line": "rw [mul_one]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (image Sym2.mk s.offDiag).card = (s.card * s.card - s.card) / 2"}, {"line": "rw [\u2190 offDiag_card]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 (image Sym2.mk s.offDiag).card = s.offDiag.card / 2\n---\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}, {"line": "rw [Nat.div_eq_of_eq_mul_right Nat.zero_lt_two (two_mul_card_image_offDiag s).symm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns : Finset \u03b1\n\u22a2 DecidableEq \u03b1"}]}
{"declaration": "theorem Rel.symm {x y : \u03b1 \u00d7 \u03b1} : Rel \u03b1 x y \u2192 Rel \u03b1 y x := by aesop (rule_sets := [Sym2])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : \u03b1 \u00d7 \u03b1\n\u22a2 sorry \u2192 sorry"}, {"line": "aesop (rule_sets := [Sym2])", "tactic_state": "\u03b1 : Type u_1\na : sorry\nfst snd fst_1 snd_1 : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem Rel.trans {x y z : \u03b1 \u00d7 \u03b1} (a : Rel \u03b1 x y) (b : Rel \u03b1 y z) : Rel \u03b1 x z := by\n  aesop (rule_sets := [Sym2])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y z : \u03b1 \u00d7 \u03b1\na : sorry\nb : sorry\n\u22a2 sorry"}, {"line": "aesop (rule_sets := [Sym2])", "tactic_state": "\u03b1 : Type u_1\na : sorry\nb : sorry\nfst snd fst_1 snd_1 fst_2 snd_2 : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem rel_iff' {p q : \u03b1 \u00d7 \u03b1} : Rel \u03b1 p q \u2194 p = q \u2228 p = q.swap := by\n  aesop (rule_sets := [Sym2])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np q : \u03b1 \u00d7 \u03b1\n\u22a2 sorry \u2194 p = q \u2228 p = q.swap"}, {"line": "aesop (rule_sets := [Sym2])", "tactic_state": "case mp\n\u03b1 : Type u_1\nfst snd fst_1 snd_1 : \u03b1\na : sorry ()\n\u22a2 fst = fst_1 \u2227 snd = snd_1 \u2228 fst = snd_1 \u2227 snd = fst_1\n---\ncase mpr.inl\n\u03b1 : Type u_1\nfst snd : \u03b1\n\u22a2 sorry ()\n---\ncase mpr.inr\n\u03b1 : Type u_1\nfst snd : \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem rel_iff {x y z w : \u03b1} : Rel \u03b1 (x, y) (z, w) \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y z w : \u03b1\n\u22a2 sorry \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_1\nx y z w : \u03b1\n\u22a2 sorry () \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z"}]}
{"declaration": "theorem mk_prod_swap_eq {p : \u03b1 \u00d7 \u03b1} : Sym2.mk p.swap = Sym2.mk p := by\n  cases p\n  exact eq_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u00d7 \u03b1\n\u22a2 Sym2.mk p.swap = Sym2.mk p"}, {"line": "cases p", "tactic_state": "case mk\n\u03b1 : Type u_1\nfst\u271d snd\u271d : \u03b1\n\u22a2 Sym2.mk (fst\u271d, snd\u271d).swap = s(fst\u271d, snd\u271d)"}, {"line": "exact eq_swap", "tactic_state": "No Goals!"}]}
{"declaration": "theorem congr_right {a b c : \u03b1} : s(a, b) = s(a, c) \u2194 b = c := by\n  simp +contextual\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c : \u03b1\n\u22a2 s(a, b) = s(a, c) \u2194 b = c"}, {"line": "simp +contextual", "tactic_state": "No Goals!"}]}
{"declaration": "theorem congr_left {a b c : \u03b1} : s(b, a) = s(c, a) \u2194 b = c := by\n  simp +contextual\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na b c : \u03b1\n\u22a2 s(b, a) = s(c, a) \u2194 b = c"}, {"line": "simp +contextual", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_iff {x y z w : \u03b1} : s(x, y) = s(z, w) \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y z w : \u03b1\n\u22a2 s(x, y) = s(z, w) \u2194 x = z \u2227 y = w \u2228 x = w \u2227 y = z"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} : Sym2.map (g \u2218 f) = Sym2.map g \u2218 Sym2.map f := by\n  ext \u27e8\u27e8x, y\u27e9\u27e9\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\n\u22a2 Sym2.map (g \u2218 f) = Sym2.map g \u2218 Sym2.map f"}, {"line": "ext \u27e8\u27e8x, y\u27e9\u27e9", "tactic_state": "case h.mk.mk.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ng : \u03b2 \u2192 \u03b3\nf : \u03b1 \u2192 \u03b2\nx\u271d\u00b9 : Sym2 \u03b1\nx y : \u03b1\nx\u271d : \u03b3\n\u22a2 x\u271d \u2208 Sym2.map (g \u2218 f) (Quot.mk (Sym2.Rel \u03b1) (x, y)) \u2194 x\u271d \u2208 (Sym2.map g \u2218 Sym2.map f) (Quot.mk (Sym2.Rel \u03b1) (x, y))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ball {p : \u03b1 \u2192 Prop} {a b : \u03b1} : (\u2200 c \u2208 s(a, b), p c) \u2194 p a \u2227 p b := by\n  refine \u27e8fun h => \u27e8h _ <| mem_mk_left _ _, h _ <| mem_mk_right _ _\u27e9, fun h c hc => ?_\u27e9\n  obtain rfl | rfl := Sym2.mem_iff.1 hc\n  \u00b7 exact h.1\n  \u00b7 exact h.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\na b : \u03b1\n\u22a2 (\u2200 c \u2208 s(a, b), p c) \u2194 p a \u2227 p b"}, {"line": "refine \u27e8fun h => \u27e8h _ <| mem_mk_left _ _, h _ <| mem_mk_right _ _\u27e9, fun h c hc => ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\na b : \u03b1\nh : p a \u2227 p b\nc : \u03b1\nhc : c \u2208 s(a, b)\n\u22a2 p c"}, {"line": "obtain rfl | rfl := Sym2.mem_iff.1 hc", "tactic_state": "case inl\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\nb c : \u03b1\nh : p c \u2227 p b\nhc : c \u2208 s(c, b)\n\u22a2 p c\n---\ncase inr\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\na c : \u03b1\nh : p a \u2227 p c\nhc : c \u2208 s(a, c)\n\u22a2 p c"}, {"line": "\u00b7 exact h.1", "tactic_state": "case inr\n\u03b1 : Type u_1\np : \u03b1 \u2192 Prop\na c : \u03b1\nh : p a \u2227 p c\nhc : c \u2208 s(a, c)\n\u22a2 p c"}, {"line": "\u00b7 exact h.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_and_mem_iff {x y : \u03b1} {z : Sym2 \u03b1} (hne : x \u2260 y) : x \u2208 z \u2227 y \u2208 z \u2194 z = s(x, y) := by\n  constructor\n  \u00b7 cases z\n    rw [mem_iff]\n    rw [mem_iff]\n    aesop\n  \u00b7 rintro rfl\n    simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx y : \u03b1\nz : Sym2 \u03b1\nhne : x \u2260 y\n\u22a2 x \u2208 z \u2227 y \u2208 z \u2194 z = s(x, y)"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\nx y : \u03b1\nz : Sym2 \u03b1\nhne : x \u2260 y\n\u22a2 x \u2208 z \u2227 y \u2208 z \u2192 z = s(x, y)\n---\ncase mpr\n\u03b1 : Type u_1\nx y : \u03b1\nz : Sym2 \u03b1\nhne : x \u2260 y\n\u22a2 z = s(x, y) \u2192 x \u2208 z \u2227 y \u2208 z"}, {"line": "\u00b7 cases z\n    rw [mem_iff]\n    rw [mem_iff]\n    aesop", "tactic_state": "case mpr\n\u03b1 : Type u_1\nx y : \u03b1\nz : Sym2 \u03b1\nhne : x \u2260 y\n\u22a2 z = s(x, y) \u2192 x \u2208 z \u2227 y \u2208 z"}, {"line": "\u00b7 rintro rfl\n    simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem other_invol' [DecidableEq \u03b1] {a : \u03b1} {z : Sym2 \u03b1} (ha : a \u2208 z) (hb : Mem.other' ha \u2208 z) :\n    Mem.other' hb = a := by\n  induction z\n  aesop (rule_sets := [Sym2]) (add norm unfold [Sym2.rec, Quot.rec])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2.lean", "context": {"open": ["List (Vector)", "Finset Function Sym"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "{e : Sym2 \u03b1} {f : \u03b1 \u2192 \u03b2}", "{r : \u03b1 \u2192 \u03b1 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\nz : Sym2 \u03b1\nha : a \u2208 z\nhb : sorry \u2208 z\n\u22a2 sorry = a"}, {"line": "induction z", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na x\u271d y\u271d : \u03b1\nha : a \u2208 s(x\u271d, y\u271d)\nhb : sorry \u2208 s(x\u271d, y\u271d)\n\u22a2 sorry = a"}, {"line": "aesop (rule_sets := [Sym2]) (add norm unfold [Sym2.rec, Quot.rec])", "tactic_state": "case inl.inr\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\na : \u03b1\n\u22a2 sorry () = a\n---\ncase inr.inl\n\u03b1 : Type u_1\ninst : DecidableEq \u03b1\na : \u03b1\n\u22a2 sorry () = a"}]}
{"declaration": "lemma mem_sym2_support_of_mul_ne_zero (p : Sym2 \u03b1) (hp : mul (p.map f) \u2260 0) :\n    p \u2208 f.support.sym2 := by\n  obtain \u27e8a, b\u27e9 := p\n  simp only [map_pair_eq] at hp\n  simp only [mul_mk] at hp\n  simp only [ne_eq] at hp\n  simpa using .intro (left_ne_zero_of_mul hp) (right_ne_zero_of_mul hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Sym/Sym2/Finsupp.lean", "context": {"open": ["Sym2"], "variables": ["{\u03b1 M\u2080 : Type*} [CommMonoidWithZero M\u2080] {f : \u03b1 \u2192\u2080 M\u2080}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nf : \u03b1 \u2192\u2080 M\u2080\np : Sym2 \u03b1\nhp : (map (\u21d1f) p).mul \u2260 0\n\u22a2 p \u2208 f.support.sym2"}, {"line": "obtain \u27e8a, b\u27e9 := p", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nf : \u03b1 \u2192\u2080 M\u2080\np : Sym2 \u03b1\na b : \u03b1\nhp : (map (\u21d1f) (Quot.mk (Sym2.Rel \u03b1) (a, b))).mul \u2260 0\n\u22a2 Quot.mk (Sym2.Rel \u03b1) (a, b) \u2208 f.support.sym2"}, {"line": "simp only [map_pair_eq] at hp", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nf : \u03b1 \u2192\u2080 M\u2080\np : Sym2 \u03b1\na b : \u03b1\nhp : s(f a, f b).mul \u2260 0\n\u22a2 Quot.mk (Sym2.Rel \u03b1) (a, b) \u2208 f.support.sym2"}, {"line": "simp only [mul_mk] at hp", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nf : \u03b1 \u2192\u2080 M\u2080\np : Sym2 \u03b1\na b : \u03b1\nhp : f a * f b \u2260 0\n\u22a2 Quot.mk (Sym2.Rel \u03b1) (a, b) \u2208 f.support.sym2"}, {"line": "simp only [ne_eq] at hp", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\nM\u2080 : Type u_2\ninst\u271d : CommMonoidWithZero M\u2080\nf : \u03b1 \u2192\u2080 M\u2080\np : Sym2 \u03b1\na b : \u03b1\nhp : \u00acf a * f b = 0\n\u22a2 Quot.mk (Sym2.Rel \u03b1) (a, b) \u2208 f.support.sym2"}, {"line": "simpa using .intro (left_ne_zero_of_mul hp) (right_ne_zero_of_mul hp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem numLeaves_eq_numNodes_succ (x : Tree \u03b1) : x.numLeaves = x.numNodes + 1 := by\n  induction x <;> simp [*, Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Tree/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx : Tree \u03b1\n\u22a2 x.numLeaves = x.numNodes + 1"}, {"line": "induction x <;> simp [*, Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zipWith_get (x : Vector \u03b1 n) (y : Vector \u03b2 n) (i) :\n    (Vector.zipWith f x y).get i = f (x.get i) (y.get i) := by\n  dsimp only [Vector.zipWith, Vector.get]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Zip.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {n : \u2115} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : Vector \u03b1 n\ny : Vector \u03b2 n\ni : Fin n\n\u22a2 (Vector.zipWith f x y).get i = f (x.get i) (y.get i)"}, {"line": "dsimp only [Vector.zipWith, Vector.get]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : Vector \u03b1 n\ny : Vector \u03b2 n\ni : Fin n\n\u22a2 (Array.zipWith f x.toArray y.toArray)[\u2191(Fin.cast \u22ef i)] = f x.toArray[\u2191(Fin.cast \u22ef i)] y.toArray[\u2191(Fin.cast \u22ef i)]"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zipWith_tail (x : Vector \u03b1 n) (y : Vector \u03b2 n) :\n    (Vector.zipWith f x y).tail = Vector.zipWith f x.tail y.tail := by\n  ext\n  simp [get_tail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Zip.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*} {n : \u2115} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : Vector \u03b1 n\ny : Vector \u03b2 n\n\u22a2 (Vector.zipWith f x y).tail = Vector.zipWith f x.tail y.tail"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : Vector \u03b1 n\ny : Vector \u03b2 n\ni\u271d : \u2115\nx\u271d : i\u271d < n - 1\n\u22a2 (Vector.zipWith f x y).tail[i\u271d] = (Vector.zipWith f x.tail y.tail)[i\u271d]"}, {"line": "simp [get_tail]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nn : \u2115\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nx : Vector \u03b1 n\ny : Vector \u03b2 n\ni\u271d : \u2115\nx\u271d : i\u271d < n - 1\n\u22a2 (Vector.zipWith f x y).tail[i\u271d] = f x.tail[i\u271d] y.tail[i\u271d]"}]}
{"declaration": "theorem get_replicate (a : \u03b1) (i : Fin n) : (Vector.replicate n a).get i = a := by\n  apply List.getElem_replicate\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03c3 \u03c6 : Type*} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\ni : Fin n\n\u22a2 (Vector.replicate n a).get i = a"}, {"line": "apply List.getElem_replicate", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nodup_iff_injective_get {v : Vector \u03b1 n} : v.toList.Nodup \u2194 Function.Injective v.get := by\n  obtain \u27e8l, hl\u27e9 := v\n  subst hl\n  exact List.nodup_iff_injective_get\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03c3 \u03c6 : Type*} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nv : Vector \u03b1 n\n\u22a2 v.toList.Nodup \u2194 Function.Injective v.get"}, {"line": "obtain \u27e8l, hl\u27e9 := v", "tactic_state": "case mk\n\u03b1 : Type u_1\nn : \u2115\nl : Array \u03b1\nhl : l.size = n\n\u22a2 { toArray := l, size_toArray := hl }.toList.Nodup \u2194 Function.Injective { toArray := l, size_toArray := hl }.get"}, {"line": "subst hl", "tactic_state": "case mk\n\u03b1 : Type u_1\nl : Array \u03b1\n\u22a2 { toArray := l, size_toArray := \u22ef }.toList.Nodup \u2194 Function.Injective { toArray := l, size_toArray := \u22ef }.get"}, {"line": "exact List.nodup_iff_injective_get", "tactic_state": "No Goals!"}]}
{"declaration": "theorem reverse_reverse {v : Vector \u03b1 n} : v.reverse.reverse = v := by\n  cases v\n  simp [Vector.reverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03c3 \u03c6 : Type*} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\nv : Vector \u03b1 n\n\u22a2 v.reverse.reverse = v"}, {"line": "cases v", "tactic_state": "case mk\n\u03b1 : Type u_1\nn : \u2115\ntoArray\u271d : Array \u03b1\nsize_toArray\u271d : toArray\u271d.size = n\n\u22a2 { toArray := toArray\u271d, size_toArray := size_toArray\u271d }.reverse.reverse =\n    { toArray := toArray\u271d, size_toArray := size_toArray\u271d }"}, {"line": "simp [Vector.reverse]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_cons_zero (a : \u03b1) (v : Vector \u03b1 n) : get (a ::\u1d65 v) 0 = a := by simp [get_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03c3 \u03c6 : Type*} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nv : Vector \u03b1 n\n\u22a2 sorry = a"}, {"line": "simp [get_zero]", "tactic_state": "\u03b1 : Type u_1\nn : \u2115\na : \u03b1\nv : Vector \u03b1 n\n\u22a2 sorry () = a"}]}
{"declaration": "theorem mem_map_iff (b : \u03b2) (v : Vector \u03b1 n) (f : \u03b1 \u2192 \u03b2) :\n    b \u2208 (v.map f).toList \u2194 \u2203 a : \u03b1, a \u2208 v.toList \u2227 f a = b := by\n  rw [Vector.toList_map]\n  rw [List.mem_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Vector/Mem.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {n : \u2115} (a a' : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\nb : \u03b2\nv : Vector \u03b1 n\nf : \u03b1 \u2192 \u03b2\n\u22a2 b \u2208 (Vector.map f v).toList \u2194 \u2203 a \u2208 v.toList, f a = b"}, {"line": "rw [Vector.toList_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nn : \u2115\nb : \u03b2\nv : Vector \u03b1 n\nf : \u03b1 \u2192 \u03b2\n\u22a2 b \u2208 List.map f v.toList \u2194 \u2203 a \u2208 v.toList, f a = b"}, {"line": "rw [List.mem_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tail_cons (a : \u03b1) (s) : tail (cons a s) = s := by simp [tail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/WSeq/Basic.lean", "context": {"open": ["Function", "Computation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ncons : x\u271d\na : \u03b1\ns : Computation (?m.451 a)\n\u22a2 sorry.tail = s"}, {"line": "simp [tail]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ncons : x\u271d\na : \u03b1\ns : Computation (?m.451 a)\n\u22a2 \u27e8(\u2191(sorry ())).tail, \u22ef\u27e9 = s"}]}
{"declaration": "theorem toList_ofList (l : List \u03b1) : l \u2208 toList (ofList l) := by\n  induction' l with a l IH\n  \u00b7 simp [ret_mem]\n  \u00b7 simpa [ret_mem] using think_mem (Computation.mem_map _ IH)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/WSeq/Basic.lean", "context": {"open": ["Function", "Computation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ntoList : x\u271d\nl : List \u03b1\n\u22a2 l \u2208 sorry"}, {"line": "induction' l with a l IH", "tactic_state": "case nil\n\u03b1 : Type u\nx\u271d : Sort u_1\ntoList : x\u271d\n\u22a2 [] \u2208 sorry\n---\ncase cons\n\u03b1 : Type u\nx\u271d : Sort u_1\ntoList : x\u271d\na : \u03b1\nl : List \u03b1\nIH : l \u2208 sorry\n\u22a2 a :: l \u2208 sorry"}, {"line": "\u00b7 simp [ret_mem]", "tactic_state": "case cons\n\u03b1 : Type u\nx\u271d : Sort u_1\ntoList : x\u271d\na : \u03b1\nl : List \u03b1\nIH : l \u2208 sorry\n\u22a2 a :: l \u2208 sorry"}, {"line": "\u00b7 simpa [ret_mem] using think_mem (Computation.mem_map _ IH)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftRel_nil (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : LiftRel R nil nil := by\n  simp [liftRel_destruct_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/WSeq/Relation.lean", "context": {"open": ["Function", "Computation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nnil : Computation \u03b1\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\n\u22a2 LiftRel R nil sorry"}, {"line": "simp [liftRel_destruct_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nnil : Computation \u03b1\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\n\u22a2 LiftRel R nil (sorry ())"}]}
{"declaration": "theorem liftRel_cons (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (a b s t) :\n    LiftRel R (cons a s) (cons b t) \u2194 R a b \u2227 LiftRel R s t := by\n  simp [liftRel_destruct_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/WSeq/Relation.lean", "context": {"open": ["Function", "Computation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\ncons : x\u271d\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\ns : Computation \u03b1\nt : Computation \u03b2\n\u22a2 LiftRel R sorry sorry \u2194 R a b \u2227 LiftRel R s t"}, {"line": "simp [liftRel_destruct_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\ncons : x\u271d\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\ns : Computation \u03b1\nt : Computation \u03b2\n\u22a2 LiftRel R (sorry ()) (sorry ()) \u2194 R a b \u2227 LiftRel R s t"}]}
{"declaration": "theorem cast_descFactorial {n p : \u2115} (h : n \u2264 p) :\n    (descFactorial (p - 1) n : ZMod p) = (-1) ^ n * n ! := by\n  rw [descFactorial_eq_prod_range]\n  rw [\u2190 prod_range_add_one_eq_factorial]\n  simp only [cast_prod]\n  nth_rw 2 [\u2190 card_range n]\n  rw [pow_card_mul_prod]\n  refine prod_congr rfl ?_\n  intro x hx\n  rw [\u2190 tsub_add_eq_tsub_tsub_swap]\n  rw [Nat.cast_sub <| Nat.le_trans (Nat.add_one_le_iff.mpr (List.mem_range.mp hx)) h]\n  rw [CharP.cast_eq_zero]\n  rw [zero_sub]\n  rw [cast_succ]\n  rw [neg_add_rev]\n  rw [mul_add]\n  rw [neg_mul]\n  rw [one_mul]\n  rw [mul_one]\n  rw [add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Factorial.lean", "context": {"open": ["Finset Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u2191((p - 1).descFactorial n) = (-1) ^ n * \u2191n.factorial"}, {"line": "rw [descFactorial_eq_prod_range]", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u2191(\u220f i \u2208 range n, (p - 1 - i)) = (-1) ^ n * \u2191n.factorial"}, {"line": "rw [\u2190 prod_range_add_one_eq_factorial]", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u2191(\u220f i \u2208 range n, (p - 1 - i)) = (-1) ^ n * \u2191(\u220f x \u2208 range n, (x + 1))"}, {"line": "simp only [cast_prod]", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u220f i \u2208 range n, \u2191(p - 1 - i) = (-1) ^ n * \u220f i \u2208 range n, \u2191(i + 1)"}, {"line": "nth_rw 2 [\u2190 card_range n]", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u220f i \u2208 range n, \u2191(p - 1 - i) = (-1) ^ (range n).card * \u220f i \u2208 range n, \u2191(i + 1)"}, {"line": "rw [pow_card_mul_prod]", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u220f i \u2208 range n, \u2191(p - 1 - i) = \u220f a \u2208 range n, -1 * \u2191(a + 1)"}, {"line": "refine prod_congr rfl ?_", "tactic_state": "n p : \u2115\nh : n \u2264 p\n\u22a2 \u2200 x \u2208 range n, \u2191(p - 1 - x) = -1 * \u2191(x + 1)"}, {"line": "intro x hx", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 \u2191(p - 1 - x) = -1 * \u2191(x + 1)"}, {"line": "rw [\u2190 tsub_add_eq_tsub_tsub_swap]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 \u2191(p - (x + 1)) = -1 * \u2191(x + 1)"}, {"line": "rw [Nat.cast_sub <| Nat.le_trans (Nat.add_one_le_iff.mpr (List.mem_range.mp hx)) h]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 \u2191p - \u2191(x + 1) = -1 * \u2191(x + 1)"}, {"line": "rw [CharP.cast_eq_zero]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 0 - \u2191(x + 1) = -1 * \u2191(x + 1)"}, {"line": "rw [zero_sub]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -\u2191(x + 1) = -1 * \u2191(x + 1)"}, {"line": "rw [cast_succ]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -(\u2191x + 1) = -1 * (\u2191x + 1)"}, {"line": "rw [neg_add_rev]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -1 + -\u2191x = -1 * (\u2191x + 1)"}, {"line": "rw [mul_add]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -1 + -\u2191x = -1 * \u2191x + -1 * 1"}, {"line": "rw [neg_mul]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -1 + -\u2191x = -(1 * \u2191x) + -1 * 1"}, {"line": "rw [one_mul]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -1 + -\u2191x = -\u2191x + -1 * 1"}, {"line": "rw [mul_one]", "tactic_state": "n p : \u2115\nh : n \u2264 p\nx : \u2115\nhx : x \u2208 range n\n\u22a2 -1 + -\u2191x = -\u2191x + -1"}, {"line": "rw [add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_lt {n : \u2115} [NeZero n] (a : ZMod n) : a.val < n := by\n  cases n\n  \u00b7 cases NeZero.ne 0 rfl\n  exact Fin.is_lt a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 a.val < n"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.val < 0\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.val < n\u271d + 1"}, {"line": "\u00b7 cases NeZero.ne 0 rfl", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.val < n\u271d + 1"}, {"line": "exact Fin.is_lt a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma val_natCast_of_lt {n a : \u2115} (h : a < n) : (a : ZMod n).val = a := by\n  rwa [val_natCast, Nat.mod_eq_of_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nh : a < n\n\u22a2 (\u2191a).val = a"}, {"line": "rwa [val_natCast, Nat.mod_eq_of_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_unit' {n : ZMod 0} : IsUnit n \u2194 n.val = 1 := by\n  simp only [val]\n  rw [Int.isUnit_iff]\n  rw [Int.natAbs_eq_iff]\n  rw [Nat.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZMod 0\n\u22a2 IsUnit n \u2194 n.val = 1"}, {"line": "simp only [val]", "tactic_state": "n : ZMod 0\n\u22a2 IsUnit n \u2194 Int.natAbs n = 1"}, {"line": "rw [Int.isUnit_iff]", "tactic_state": "n : ZMod 0\n\u22a2 n = 1 \u2228 n = -1 \u2194 Int.natAbs n = 1"}, {"line": "rw [Int.natAbs_eq_iff]", "tactic_state": "n : ZMod 0\n\u22a2 n = 1 \u2228 n = -1 \u2194 n = \u21911 \u2228 n = -\u21911"}, {"line": "rw [Nat.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_one_of_isUnit_natCast {n : \u2115} (h : IsUnit (n : ZMod 0)) : n = 1 := by\n  rw [\u2190 Nat.mod_zero n]\n  rw [\u2190 val_natCast]\n  rw [val_unit'.mp h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : IsUnit \u2191n\n\u22a2 n = 1"}, {"line": "rw [\u2190 Nat.mod_zero n]", "tactic_state": "n : \u2115\nh : IsUnit \u2191n\n\u22a2 n % 0 = 1"}, {"line": "rw [\u2190 val_natCast]", "tactic_state": "n : \u2115\nh : IsUnit \u2191n\n\u22a2 (\u2191n).val = 1"}, {"line": "rw [val_unit'.mp h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem addOrderOf_coe (a : \u2115) {n : \u2115} (n0 : n \u2260 0) : addOrderOf (a : ZMod n) = n / n.gcd a := by\n  rcases a with - | a\n  \u00b7 simp only [Nat.cast_zero, addOrderOf_zero, Nat.gcd_zero_right,\n      Nat.pos_of_ne_zero n0, Nat.div_self]\n  rw [\u2190 Nat.smul_one_eq_cast]\n  rw [addOrderOf_nsmul' _ a.succ_ne_zero]\n  rw [ZMod.addOrderOf_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\nn0 : n \u2260 0\n\u22a2 addOrderOf \u2191a = n / n.gcd a"}, {"line": "rcases a with - | a", "tactic_state": "case zero\nn : \u2115\nn0 : n \u2260 0\n\u22a2 addOrderOf \u21910 = n / n.gcd 0\n---\ncase succ\nn : \u2115\nn0 : n \u2260 0\na : \u2115\n\u22a2 addOrderOf \u2191(a + 1) = n / n.gcd (a + 1)"}, {"line": "\u00b7 simp only [Nat.cast_zero, addOrderOf_zero, Nat.gcd_zero_right,\n      Nat.pos_of_ne_zero n0, Nat.div_self]", "tactic_state": "case succ\nn : \u2115\nn0 : n \u2260 0\na : \u2115\n\u22a2 addOrderOf \u2191(a + 1) = n / n.gcd (a + 1)"}, {"line": "rw [\u2190 Nat.smul_one_eq_cast]", "tactic_state": "case succ\nn : \u2115\nn0 : n \u2260 0\na : \u2115\n\u22a2 addOrderOf ((a + 1) \u2022 1) = n / n.gcd (a + 1)"}, {"line": "rw [addOrderOf_nsmul' _ a.succ_ne_zero]", "tactic_state": "case succ\nn : \u2115\nn0 : n \u2260 0\na : \u2115\n\u22a2 addOrderOf 1 / (addOrderOf 1).gcd a.succ = n / n.gcd (a + 1)"}, {"line": "rw [ZMod.addOrderOf_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem addOrderOf_coe' {a : \u2115} (n : \u2115) (a0 : a \u2260 0) : addOrderOf (a : ZMod n) = n / n.gcd a := by\n  rw [\u2190 Nat.smul_one_eq_cast]\n  rw [addOrderOf_nsmul' _ a0]\n  rw [ZMod.addOrderOf_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\na0 : a \u2260 0\n\u22a2 addOrderOf \u2191a = n / n.gcd a"}, {"line": "rw [\u2190 Nat.smul_one_eq_cast]", "tactic_state": "a n : \u2115\na0 : a \u2260 0\n\u22a2 addOrderOf (a \u2022 1) = n / n.gcd a"}, {"line": "rw [addOrderOf_nsmul' _ a0]", "tactic_state": "a n : \u2115\na0 : a \u2260 0\n\u22a2 addOrderOf 1 / (addOrderOf 1).gcd a = n / n.gcd a"}, {"line": "rw [ZMod.addOrderOf_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ringChar_zmod_n (n : \u2115) : ringChar (ZMod n) = n := by\n  rw [ringChar.eq_iff]\n  exact ZMod.charP n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 ringChar (ZMod n) = n"}, {"line": "rw [ringChar.eq_iff]", "tactic_state": "n : \u2115\n\u22a2 CharP (ZMod n) n"}, {"line": "exact ZMod.charP n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_zero : (cast (0 : ZMod n) : R) = 0 := by\n  delta ZMod.cast\n  cases n\n  \u00b7 exact Int.cast_zero\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d : AddGroupWithOne R\n\u22a2 ZMod.cast 0 = 0"}, {"line": "delta ZMod.cast", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d : AddGroupWithOne R\n\u22a2 (match (motive := (x : \u2115) \u2192 ZMod x \u2192 R) n with\n      | 0 => Int.cast\n      | n.succ => fun i => \u2191i.val)\n      0 =\n    0"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u_1\ninst\u271d : AddGroupWithOne R\n\u22a2 (match (motive := (x : \u2115) \u2192 ZMod x \u2192 R) 0 with\n      | 0 => Int.cast\n      | n.succ => fun i => \u2191i.val)\n      0 =\n    0\n---\ncase succ\nR : Type u_1\ninst\u271d : AddGroupWithOne R\nn\u271d : \u2115\n\u22a2 (match (motive := (x : \u2115) \u2192 ZMod x \u2192 R) n\u271d + 1 with\n      | 0 => Int.cast\n      | n.succ => fun i => \u2191i.val)\n      0 =\n    0"}, {"line": "\u00b7 exact Int.cast_zero", "tactic_state": "case succ\nR : Type u_1\ninst\u271d : AddGroupWithOne R\nn\u271d : \u2115\n\u22a2 (match (motive := (x : \u2115) \u2192 ZMod x \u2192 R) n\u271d + 1 with\n      | 0 => Int.cast\n      | n.succ => fun i => \u2191i.val)\n      0 =\n    0"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_eq_val [NeZero n] (a : ZMod n) : (cast a : R) = a.val := by\n  cases n\n  \u00b7 cases NeZero.ne 0 rfl\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 a.cast = \u2191a.val"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 a.cast = \u2191a.val\n---\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.cast = \u2191a.val"}, {"line": "\u00b7 cases NeZero.ne 0 rfl", "tactic_state": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 a.cast = \u2191a.val"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Prod.fst_zmod_cast (a : ZMod n) : (cast a : R \u00d7 S).fst = cast a := by\n  cases n\n  \u00b7 rfl\n  \u00b7 simp [ZMod.cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod n\n\u22a2 a.cast.1 = a.cast"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.1 = a.cast\n---\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.1 = a.cast"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.1 = a.cast"}, {"line": "\u00b7 simp [ZMod.cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Prod.snd_zmod_cast (a : ZMod n) : (cast a : R \u00d7 S).snd = cast a := by\n  cases n\n  \u00b7 rfl\n  \u00b7 simp [ZMod.cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod n\n\u22a2 a.cast.2 = a.cast"}, {"line": "cases n", "tactic_state": "case zero\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\na : ZMod 0\n\u22a2 a.cast.2 = a.cast\n---\ncase succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.2 = a.cast"}, {"line": "\u00b7 rfl", "tactic_state": "case succ\nR : Type u_1\ninst\u271d\u00b9 : AddGroupWithOne R\nS : Type u_2\ninst\u271d : AddGroupWithOne S\nn\u271d : \u2115\na : ZMod (n\u271d + 1)\n\u22a2 a.cast.2 = a.cast"}, {"line": "\u00b7 simp [ZMod.cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_zmod_val {n : \u2115} [NeZero n] (a : ZMod n) : (a.val : ZMod n) = a := by\n  cases n\n  \u00b7 cases NeZero.ne 0 rfl\n  \u00b7 apply Fin.cast_val_eq_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na : ZMod n\n\u22a2 \u2191a.val = a"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\na : ZMod 0\n\u22a2 \u2191a.val = a\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 \u2191a.val = a"}, {"line": "\u00b7 cases NeZero.ne 0 rfl", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na : ZMod (n\u271d + 1)\n\u22a2 \u2191a.val = a"}, {"line": "\u00b7 apply Fin.cast_val_eq_self", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_refl_apply {a : \u2115} (x : ZMod a) : ringEquivCongr rfl x = x := by\n  rw [ringEquivCongr_refl]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nx : ZMod a\n\u22a2 (ringEquivCongr \u22ef) x = x"}, {"line": "rw [ringEquivCongr_refl]", "tactic_state": "a : \u2115\nx : ZMod a\n\u22a2 (RingEquiv.refl (ZMod a)) x = x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_symm {a b : \u2115} (hab : a = b) :\n    (ringEquivCongr hab).symm = ringEquivCongr hab.symm := by\n  subst hab\n  cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhab : a = b\n\u22a2 (ringEquivCongr hab).symm = ringEquivCongr \u22ef"}, {"line": "subst hab", "tactic_state": "a : \u2115\n\u22a2 (ringEquivCongr \u22ef).symm = ringEquivCongr \u22ef"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_trans {a b c : \u2115} (hab : a = b) (hbc : b = c) :\n    (ringEquivCongr hab).trans (ringEquivCongr hbc) = ringEquivCongr (hab.trans hbc) := by\n  subst hab hbc\n  cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nhab : a = b\nhbc : b = c\n\u22a2 (ringEquivCongr hab).trans (ringEquivCongr hbc) = ringEquivCongr \u22ef"}, {"line": "subst hab hbc", "tactic_state": "a : \u2115\n\u22a2 (ringEquivCongr \u22ef).trans (ringEquivCongr \u22ef) = ringEquivCongr \u22ef"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_ringEquivCongr_apply {a b c : \u2115} (hab : a = b) (hbc : b = c) (x : ZMod a) :\n    ringEquivCongr hbc (ringEquivCongr hab x) = ringEquivCongr (hab.trans hbc) x := by\n  rw [\u2190 ringEquivCongr_trans hab hbc]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nhab : a = b\nhbc : b = c\nx : ZMod a\n\u22a2 (ringEquivCongr hbc) ((ringEquivCongr hab) x) = (ringEquivCongr \u22ef) x"}, {"line": "rw [\u2190 ringEquivCongr_trans hab hbc]", "tactic_state": "a b c : \u2115\nhab : a = b\nhbc : b = c\nx : ZMod a\n\u22a2 (ringEquivCongr hbc) ((ringEquivCongr hab) x) = ((ringEquivCongr hab).trans (ringEquivCongr hbc)) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_val {a b : \u2115} (h : a = b) (x : ZMod a) :\n    ZMod.val ((ZMod.ringEquivCongr h) x) = ZMod.val x := by\n  subst h\n  cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\nx : ZMod a\n\u22a2 ((ringEquivCongr h) x).val = x.val"}, {"line": "subst h", "tactic_state": "a : \u2115\nx : ZMod a\n\u22a2 ((ringEquivCongr \u22ef) x).val = x.val"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ringEquivCongr_intCast {a b : \u2115} (h : a = b) (z : \u2124) :\n    ZMod.ringEquivCongr h z = z := by\n  subst h\n  cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a = b\nz : \u2124\n\u22a2 (ringEquivCongr h) \u2191z = \u2191z"}, {"line": "subst h", "tactic_state": "a : \u2115\nz : \u2124\n\u22a2 (ringEquivCongr \u22ef) \u2191z = \u2191z"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_eq_natCast_iff (a b c : \u2115) : (a : ZMod c) = (b : ZMod c) \u2194 a \u2261 b [MOD c] := by\n  simpa [Int.natCast_modEq_iff] using ZMod.intCast_eq_intCast_iff a b c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 \u2191a = \u2191b \u2194 a \u2261 b [MOD c]"}, {"line": "simpa [Int.natCast_modEq_iff] using ZMod.intCast_eq_intCast_iff a b c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_zmod_eq_zero_iff_dvd (a : \u2124) (b : \u2115) : (a : ZMod b) = 0 \u2194 (b : \u2124) \u2223 a := by\n  rw [\u2190 Int.cast_zero]\n  rw [ZMod.intCast_eq_intCast_iff]\n  rw [Int.modEq_zero_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\nb : \u2115\n\u22a2 \u2191a = 0 \u2194 \u2191b \u2223 a"}, {"line": "rw [\u2190 Int.cast_zero]", "tactic_state": "a : \u2124\nb : \u2115\n\u22a2 \u2191a = \u21910 \u2194 \u2191b \u2223 a"}, {"line": "rw [ZMod.intCast_eq_intCast_iff]", "tactic_state": "a : \u2124\nb : \u2115\n\u22a2 a \u2261 0 [ZMOD \u2191b] \u2194 \u2191b \u2223 a"}, {"line": "rw [Int.modEq_zero_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_eq_intCast_iff_dvd_sub (a b : \u2124) (c : \u2115) : (a : ZMod c) = \u2191b \u2194 \u2191c \u2223 b - a := by\n  rw [ZMod.intCast_eq_intCast_iff]\n  rw [Int.modEq_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2124\nc : \u2115\n\u22a2 \u2191a = \u2191b \u2194 \u2191c \u2223 b - a"}, {"line": "rw [ZMod.intCast_eq_intCast_iff]", "tactic_state": "a b : \u2124\nc : \u2115\n\u22a2 a \u2261 b [ZMOD \u2191c] \u2194 \u2191c \u2223 b - a"}, {"line": "rw [Int.modEq_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_zmod_eq_zero_iff_dvd (a b : \u2115) : (a : ZMod b) = 0 \u2194 b \u2223 a := by\n  rw [\u2190 Nat.cast_zero]\n  rw [ZMod.natCast_eq_natCast_iff]\n  rw [Nat.modEq_zero_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191a = 0 \u2194 b \u2223 a"}, {"line": "rw [\u2190 Nat.cast_zero]", "tactic_state": "a b : \u2115\n\u22a2 \u2191a = \u21910 \u2194 b \u2223 a"}, {"line": "rw [ZMod.natCast_eq_natCast_iff]", "tactic_state": "a b : \u2115\n\u22a2 a \u2261 0 [MOD b] \u2194 b \u2223 a"}, {"line": "rw [Nat.modEq_zero_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_intCast (a : \u2124) : cast (a : ZMod n) = a % n := by\n  cases n\n  \u00b7 rw [Int.ofNat_zero, Int.emod_zero, Int.cast_id]; rfl\n  \u00b7 rw [\u2190 val_intCast, val]; rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : \u2124\n\u22a2 (\u2191a).cast = a % \u2191n"}, {"line": "cases n", "tactic_state": "case zero\na : \u2124\n\u22a2 (\u2191a).cast = a % \u21910\n---\ncase succ\na : \u2124\nn\u271d : \u2115\n\u22a2 (\u2191a).cast = a % \u2191(n\u271d + 1)"}, {"line": "\u00b7 rw [Int.ofNat_zero, Int.emod_zero, Int.cast_id]; rfl", "tactic_state": "case succ\na : \u2124\nn\u271d : \u2115\n\u22a2 (\u2191a).cast = a % \u2191(n\u271d + 1)"}, {"line": "\u00b7 rw [\u2190 val_intCast, val]; rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_cast_add (x y : ZMod n) : (cast (x + y) : \u2124) = (cast x + cast y) % n := by\n  rw [\u2190 ZMod.coe_intCast]\n  rw [Int.cast_add]\n  rw [ZMod.intCast_zmod_cast]\n  rw [ZMod.intCast_zmod_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x + y).cast = (x.cast + y.cast) % \u2191n"}, {"line": "rw [\u2190 ZMod.coe_intCast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x + y).cast = (\u2191(x.cast + y.cast)).cast"}, {"line": "rw [Int.cast_add]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x + y).cast = (\u2191x.cast + \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x + y).cast = (x + \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_cast_mul (x y : ZMod n) : (cast (x * y) : \u2124) = cast x * cast y % n := by\n  rw [\u2190 ZMod.coe_intCast]\n  rw [Int.cast_mul]\n  rw [ZMod.intCast_zmod_cast]\n  rw [ZMod.intCast_zmod_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x * y).cast = x.cast * y.cast % \u2191n"}, {"line": "rw [\u2190 ZMod.coe_intCast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x * y).cast = (\u2191(x.cast * y.cast)).cast"}, {"line": "rw [Int.cast_mul]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x * y).cast = (\u2191x.cast * \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x * y).cast = (x * \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_cast_sub (x y : ZMod n) : (cast (x - y) : \u2124) = (cast x - cast y) % n := by\n  rw [\u2190 ZMod.coe_intCast]\n  rw [Int.cast_sub]\n  rw [ZMod.intCast_zmod_cast]\n  rw [ZMod.intCast_zmod_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x - y).cast = (x.cast - y.cast) % \u2191n"}, {"line": "rw [\u2190 ZMod.coe_intCast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x - y).cast = (\u2191(x.cast - y.cast)).cast"}, {"line": "rw [Int.cast_sub]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x - y).cast = (\u2191x.cast - \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "n : \u2115\nx y : ZMod n\n\u22a2 (x - y).cast = (x - \u2191y.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma intCast_cast_neg (x : ZMod n) : (cast (-x) : \u2124) = -cast x % n := by\n  rw [\u2190 ZMod.coe_intCast]\n  rw [Int.cast_neg]\n  rw [ZMod.intCast_zmod_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : ZMod n\n\u22a2 (-x).cast = -x.cast % \u2191n"}, {"line": "rw [\u2190 ZMod.coe_intCast]", "tactic_state": "n : \u2115\nx : ZMod n\n\u22a2 (-x).cast = (\u2191(-x.cast)).cast"}, {"line": "rw [Int.cast_neg]", "tactic_state": "n : \u2115\nx : ZMod n\n\u22a2 (-x).cast = (-\u2191x.cast).cast"}, {"line": "rw [ZMod.intCast_zmod_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_neg_one {R : Type*} [Ring R] (n : \u2115) : cast (-1 : ZMod n) = (n - 1 : R) := by\n  rcases n with - | n\n  \u00b7 dsimp [ZMod, ZMod.cast]; simp\n  \u00b7 rw [\u2190 natCast_val, val_neg_one, Nat.cast_succ, add_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (-1).cast = \u2191n - 1"}, {"line": "rcases n with - | n", "tactic_state": "case zero\nR : Type u_3\ninst\u271d : Ring R\n\u22a2 (-1).cast = \u21910 - 1\n---\ncase succ\nR : Type u_3\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (-1).cast = \u2191(n + 1) - 1"}, {"line": "\u00b7 dsimp [ZMod, ZMod.cast]; simp", "tactic_state": "case succ\nR : Type u_3\ninst\u271d : Ring R\nn : \u2115\n\u22a2 (-1).cast = \u2191(n + 1) - 1"}, {"line": "\u00b7 rw [\u2190 natCast_val, val_neg_one, Nat.cast_succ, add_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_mod (a : \u2124) (b : \u2115) : ((a % b : \u2124) : ZMod b) = (a : ZMod b) := by\n  rw [ZMod.intCast_eq_intCast_iff]\n  apply Int.mod_modEq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\nb : \u2115\n\u22a2 \u2191(a % \u2191b) = \u2191a"}, {"line": "rw [ZMod.intCast_eq_intCast_iff]", "tactic_state": "a : \u2124\nb : \u2115\n\u22a2 a % \u2191b \u2261 a [ZMOD \u2191b]"}, {"line": "apply Int.mod_modEq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ker_intCastAddHom (n : \u2115) :\n    (Int.castAddHom (ZMod n)).ker = AddSubgroup.zmultiples (n : \u2124) := by\n  ext\n  rw [Int.mem_zmultiples_iff]\n  rw [AddMonoidHom.mem_ker]\n  rw [Int.coe_castAddHom]\n  rw [intCast_zmod_eq_zero_iff_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (Int.castAddHom (ZMod n)).ker = AddSubgroup.zmultiples \u2191n"}, {"line": "ext", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 (Int.castAddHom (ZMod n)).ker \u2194 x\u271d \u2208 AddSubgroup.zmultiples \u2191n"}, {"line": "rw [Int.mem_zmultiples_iff]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 x\u271d \u2208 (Int.castAddHom (ZMod n)).ker \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [AddMonoidHom.mem_ker]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 (Int.castAddHom (ZMod n)) x\u271d = 0 \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [Int.coe_castAddHom]", "tactic_state": "case h\nn : \u2115\nx\u271d : \u2124\n\u22a2 (fun x => \u2191x) x\u271d = 0 \u2194 \u2191n \u2223 x\u271d"}, {"line": "rw [intCast_zmod_eq_zero_iff_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_zmod_eq_zero_iff_of_le {m n : \u2115} [NeZero m] (h : m \u2264 n) (a : ZMod m) :\n    (cast a : ZMod n) = 0 \u2194 a = 0 := by\n  rw [\u2190 ZMod.cast_zero (n := m)]\n  exact Injective.eq_iff' (cast_injective_of_le h) rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\nh : m \u2264 n\na : ZMod m\n\u22a2 a.cast = 0 \u2194 a = 0"}, {"line": "rw [\u2190 ZMod.cast_zero (n := m)]", "tactic_state": "m n : \u2115\ninst\u271d : NeZero m\nh : m \u2264 n\na : ZMod m\n\u22a2 a.cast = ZMod.cast 0 \u2194 a = 0"}, {"line": "exact Injective.eq_iff' (cast_injective_of_le h) rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_injective (n : \u2115) [NeZero n] : Function.Injective (val : ZMod n \u2192 \u2115) := by\n  cases n\n  \u00b7 cases NeZero.ne 0 rfl\n  intro a b h\n  dsimp [ZMod]\n  ext\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\n\u22a2 Injective val"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\n\u22a2 Injective val\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Injective val"}, {"line": "\u00b7 cases NeZero.ne 0 rfl", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\n\u22a2 Injective val"}, {"line": "intro a b h", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na b : ZMod (n\u271d + 1)\nh : a.val = b.val\n\u22a2 a = b"}, {"line": "dsimp [ZMod]", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na b : ZMod (n\u271d + 1)\nh : a.val = b.val\n\u22a2 a = b"}, {"line": "ext", "tactic_state": "case succ.h\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na b : ZMod (n\u271d + 1)\nh : a.val = b.val\n\u22a2 \u2191a = \u2191b"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_one_eq_one_mod (n : \u2115) : (1 : ZMod n).val = 1 % n := by\n  rw [\u2190 Nat.cast_one]\n  rw [val_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 val 1 = 1 % n"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "n : \u2115\n\u22a2 (\u21911).val = 1 % n"}, {"line": "rw [val_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_two_eq_two_mod (n : \u2115) : (2 : ZMod n).val = 2 % n := by\n  rw [\u2190 Nat.cast_two]\n  rw [val_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 val 2 = 2 % n"}, {"line": "rw [\u2190 Nat.cast_two]", "tactic_state": "n : \u2115\n\u22a2 (\u21912).val = 2 % n"}, {"line": "rw [val_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_one (n : \u2115) [Fact (1 < n)] : (1 : ZMod n).val = 1 := by\n  rw [val_one_eq_one_mod]\n  exact Nat.mod_eq_of_lt Fact.out\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : Fact (1 < n)\n\u22a2 val 1 = 1"}, {"line": "rw [val_one_eq_one_mod]", "tactic_state": "n : \u2115\ninst\u271d : Fact (1 < n)\n\u22a2 1 % n = 1"}, {"line": "exact Nat.mod_eq_of_lt Fact.out", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_add {n : \u2115} [NeZero n] (a b : ZMod n) : (a + b).val = (a.val + b.val) % n := by\n  cases n\n  \u00b7 cases NeZero.ne 0 rfl\n  \u00b7 apply Fin.val_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na b : ZMod n\n\u22a2 (a + b).val = (a.val + b.val) % n"}, {"line": "cases n", "tactic_state": "case zero\ninst\u271d : NeZero 0\na b : ZMod 0\n\u22a2 (a + b).val = (a.val + b.val) % 0\n---\ncase succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na b : ZMod (n\u271d + 1)\n\u22a2 (a + b).val = (a.val + b.val) % (n\u271d + 1)"}, {"line": "\u00b7 cases NeZero.ne 0 rfl", "tactic_state": "case succ\nn\u271d : \u2115\ninst\u271d : NeZero (n\u271d + 1)\na b : ZMod (n\u271d + 1)\n\u22a2 (a + b).val = (a.val + b.val) % (n\u271d + 1)"}, {"line": "\u00b7 apply Fin.val_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_add_le {n : \u2115} (a b : ZMod n) : (a + b).val \u2264 a.val + b.val := by\n  cases n\n  \u00b7 simpa [ZMod.val] using Int.natAbs_add_le _ _\n  \u00b7 simpa [ZMod.val_add] using Nat.mod_le _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : ZMod n\n\u22a2 (a + b).val \u2264 a.val + b.val"}, {"line": "cases n", "tactic_state": "case zero\na b : ZMod 0\n\u22a2 (a + b).val \u2264 a.val + b.val\n---\ncase succ\nn\u271d : \u2115\na b : ZMod (n\u271d + 1)\n\u22a2 (a + b).val \u2264 a.val + b.val"}, {"line": "\u00b7 simpa [ZMod.val] using Int.natAbs_add_le _ _", "tactic_state": "case succ\nn\u271d : \u2115\na b : ZMod (n\u271d + 1)\n\u22a2 (a + b).val \u2264 a.val + b.val"}, {"line": "\u00b7 simpa [ZMod.val_add] using Nat.mod_le _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_mul_le {n : \u2115} (a b : ZMod n) : (a * b).val \u2264 a.val * b.val := by\n  rw [val_mul]\n  apply Nat.mod_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : ZMod n\n\u22a2 (a * b).val \u2264 a.val * b.val"}, {"line": "rw [val_mul]", "tactic_state": "n : \u2115\na b : ZMod n\n\u22a2 a.val * b.val % n \u2264 a.val * b.val"}, {"line": "apply Nat.mod_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_mul_of_lt {n : \u2115} {a b : ZMod n} (h : a.val * b.val < n) :\n    (a * b).val = a.val * b.val := by\n  rw [val_mul]\n  apply Nat.mod_eq_of_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na b : ZMod n\nh : a.val * b.val < n\n\u22a2 (a * b).val = a.val * b.val"}, {"line": "rw [val_mul]", "tactic_state": "n : \u2115\na b : ZMod n\nh : a.val * b.val < n\n\u22a2 a.val * b.val % n = a.val * b.val"}, {"line": "apply Nat.mod_eq_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_mul_iff_lt {n : \u2115} [NeZero n] (a b : ZMod n) :\n    (a * b).val = a.val * b.val \u2194 a.val * b.val < n := by\n  constructor <;> intro h\n  \u00b7 rw [\u2190 h]; apply ZMod.val_lt\n  \u00b7 apply ZMod.val_mul_of_lt h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na b : ZMod n\n\u22a2 (a * b).val = a.val * b.val \u2194 a.val * b.val < n"}, {"line": "constructor <;> intro h", "tactic_state": "case mp\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : (a * b).val = a.val * b.val\n\u22a2 a.val * b.val < n\n---\ncase mpr\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : a.val * b.val < n\n\u22a2 (a * b).val = a.val * b.val"}, {"line": "\u00b7 rw [\u2190 h]; apply ZMod.val_lt", "tactic_state": "case mpr\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : a.val * b.val < n\n\u22a2 (a * b).val = a.val * b.val"}, {"line": "\u00b7 apply ZMod.val_mul_of_lt h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_eq_zero_iff {n : \u2115} : (1 : ZMod n) = 0 \u2194 n = 1 := by\n  rw [\u2190 Nat.cast_one]\n  rw [natCast_zmod_eq_zero_iff_dvd]\n  rw [Nat.dvd_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 1 = 0 \u2194 n = 1"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "n : \u2115\n\u22a2 \u21911 = 0 \u2194 n = 1"}, {"line": "rw [natCast_zmod_eq_zero_iff_dvd]", "tactic_state": "n : \u2115\n\u22a2 n \u2223 1 \u2194 n = 1"}, {"line": "rw [Nat.dvd_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_mod (a : \u2115) (n : \u2115) : ((a % n : \u2115) : ZMod n) = a := by\n  conv =>\n      rhs\n      rw [\u2190 Nat.mod_add_div a n]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\n\u22a2 \u2191(a % n) = \u2191a"}, {"line": "conv =>\n      rhs\n      rw [\u2190 Nat.mod_add_div a n]", "tactic_state": "a n : \u2115\n\u22a2 \u2191(a % n) = \u2191(a % n + n * (a / n))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_iff_odd {n : \u2115} : (n : ZMod 2) = 1 \u2194 Odd n := by\n  rw [\u2190 @Nat.cast_one (ZMod 2)]\n  rw [ZMod.eq_iff_modEq_nat]\n  rw [Nat.odd_iff]\n  rw [Nat.ModEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191n = 1 \u2194 Odd n"}, {"line": "rw [\u2190 @Nat.cast_one (ZMod 2)]", "tactic_state": "n : \u2115\n\u22a2 \u2191n = \u21911 \u2194 Odd n"}, {"line": "rw [ZMod.eq_iff_modEq_nat]", "tactic_state": "n : \u2115\n\u22a2 n \u2261 1 [MOD 2] \u2194 Odd n"}, {"line": "rw [Nat.odd_iff]", "tactic_state": "n : \u2115\n\u22a2 n \u2261 1 [MOD 2] \u2194 n % 2 = 1"}, {"line": "rw [Nat.ModEq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_iff_odd {n : \u2115} : (n : ZMod 2) \u2260 0 \u2194 Odd n := by\n  constructor <;>\n    \u00b7 contrapose\n      simp [eq_zero_iff_even]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191n \u2260 0 \u2194 Odd n"}, {"line": "constructor <;>\n    \u00b7 contrapose\n      simp [eq_zero_iff_even]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_mul_inv_eq_one {n : \u2115} (x : \u2115) (h : Nat.Coprime x n) :\n    ((x : ZMod n) * (x : ZMod n)\u207b\u00b9) = 1 := by\n  rw [Nat.Coprime] at h\n  rw [Nat.gcd_comm] at h\n  rw [Nat.gcd_rec] at h\n  rw [mul_inv_eq_gcd]\n  rw [val_natCast]\n  rw [h]\n  rw [Nat.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n x : \u2115\nh : x.Coprime n\n\u22a2 \u2191x * (\u2191x)\u207b\u00b9 = 1"}, {"line": "rw [Nat.Coprime] at h", "tactic_state": "n x : \u2115\nh : x.gcd n = 1\n\u22a2 \u2191x * (\u2191x)\u207b\u00b9 = 1"}, {"line": "rw [Nat.gcd_comm] at h", "tactic_state": "n x : \u2115\nh : n.gcd x = 1\n\u22a2 \u2191x * (\u2191x)\u207b\u00b9 = 1"}, {"line": "rw [Nat.gcd_rec] at h", "tactic_state": "n x : \u2115\nh : (x % n).gcd n = 1\n\u22a2 \u2191x * (\u2191x)\u207b\u00b9 = 1"}, {"line": "rw [mul_inv_eq_gcd]", "tactic_state": "n x : \u2115\nh : (x % n).gcd n = 1\n\u22a2 \u2191((\u2191x).val.gcd n) = 1"}, {"line": "rw [val_natCast]", "tactic_state": "n x : \u2115\nh : (x % n).gcd n = 1\n\u22a2 \u2191((x % n).gcd n) = 1"}, {"line": "rw [h]", "tactic_state": "n x : \u2115\nh : (x % n).gcd n = 1\n\u22a2 \u21911 = 1"}, {"line": "rw [Nat.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_val_inv (hmn : m.Coprime n) : (m * (m\u207b\u00b9 : ZMod n).val : ZMod n) = 1 := by\n  obtain rfl | hn := eq_or_ne n 0\n  \u00b7 simp [m.coprime_zero_right.1 hmn]\n  haveI : NeZero n := \u27e8hn\u27e9\n  rw [ZMod.natCast_zmod_val]\n  rw [ZMod.coe_mul_inv_eq_one _ hmn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhmn : m.Coprime n\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1"}, {"line": "obtain rfl | hn := eq_or_ne n 0", "tactic_state": "case inl\nm : \u2115\nhmn : m.Coprime 0\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1\n---\ncase inr\nm n : \u2115\nhmn : m.Coprime n\nhn : n \u2260 0\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1"}, {"line": "\u00b7 simp [m.coprime_zero_right.1 hmn]", "tactic_state": "case inr\nm n : \u2115\nhmn : m.Coprime n\nhn : n \u2260 0\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1"}, {"line": "haveI : NeZero n := \u27e8hn\u27e9", "tactic_state": "case inr\nm n : \u2115\nhmn : m.Coprime n\nhn : n \u2260 0\nthis : NeZero n\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1"}, {"line": "rw [ZMod.natCast_zmod_val]", "tactic_state": "case inr\nm n : \u2115\nhmn : m.Coprime n\nhn : n \u2260 0\nthis : NeZero n\n\u22a2 \u2191m * (\u2191m)\u207b\u00b9 = 1"}, {"line": "rw [ZMod.coe_mul_inv_eq_one _ hmn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma val_inv_mul (hmn : m.Coprime n) : ((m\u207b\u00b9 : ZMod n).val * m : ZMod n) = 1 := by\n  rw [mul_comm]\n  rw [mul_val_inv hmn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhmn : m.Coprime n\n\u22a2 \u2191(\u2191m)\u207b\u00b9.val * \u2191m = 1"}, {"line": "rw [mul_comm]", "tactic_state": "m n : \u2115\nhmn : m.Coprime n\n\u22a2 \u2191m * \u2191(\u2191m)\u207b\u00b9.val = 1"}, {"line": "rw [mul_val_inv hmn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUnit_iff_coprime (m n : \u2115) : IsUnit (m : ZMod n) \u2194 m.Coprime n := by\n  refine \u27e8fun H \u21a6 ?_, fun H \u21a6 (unitOfCoprime m H).isUnit\u27e9\n  have H' := val_coe_unit_coprime H.unit\n  rw [IsUnit.unit_spec] at H'\n  rw [val_natCast] at H'\n  rw [Nat.coprime_iff_gcd_eq_one] at H'\n  rw [Nat.coprime_iff_gcd_eq_one]\n  rw [Nat.gcd_comm]\n  rw [\u2190 H']\n  exact Nat.gcd_rec n m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 IsUnit \u2191m \u2194 m.Coprime n"}, {"line": "refine \u27e8fun H \u21a6 ?_, fun H \u21a6 (unitOfCoprime m H).isUnit\u27e9", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\n\u22a2 m.Coprime n"}, {"line": "have H' := val_coe_unit_coprime H.unit", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (\u2191H.unit).val.Coprime n\n\u22a2 m.Coprime n"}, {"line": "rw [IsUnit.unit_spec] at H'", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (\u2191m).val.Coprime n\n\u22a2 m.Coprime n"}, {"line": "rw [val_natCast] at H'", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (m % n).Coprime n\n\u22a2 m.Coprime n"}, {"line": "rw [Nat.coprime_iff_gcd_eq_one] at H'", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (m % n).gcd n = 1\n\u22a2 m.Coprime n"}, {"line": "rw [Nat.coprime_iff_gcd_eq_one]", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (m % n).gcd n = 1\n\u22a2 m.gcd n = 1"}, {"line": "rw [Nat.gcd_comm]", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (m % n).gcd n = 1\n\u22a2 n.gcd m = 1"}, {"line": "rw [\u2190 H']", "tactic_state": "m n : \u2115\nH : IsUnit \u2191m\nH' : (m % n).gcd n = 1\n\u22a2 n.gcd m = (m % n).gcd n"}, {"line": "exact Nat.gcd_rec n m", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isUnit_prime_iff_not_dvd {n p : \u2115} (hp : p.Prime) : IsUnit (p : ZMod n) \u2194 \u00acp \u2223 n := by\n  rw [isUnit_iff_coprime]\n  rw [Nat.Prime.coprime_iff_not_dvd hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 IsUnit \u2191p \u2194 \u00acp \u2223 n"}, {"line": "rw [isUnit_iff_coprime]", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 p.Coprime n \u2194 \u00acp \u2223 n"}, {"line": "rw [Nat.Prime.coprime_iff_not_dvd hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_inv_of_unit {n : \u2115} (a : ZMod n) (h : IsUnit a) : a * a\u207b\u00b9 = 1 := by\n  rcases h with \u27e8u, rfl\u27e9\n  rw [inv_coe_unit]\n  rw [u.mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : ZMod n\nh : IsUnit a\n\u22a2 a * a\u207b\u00b9 = 1"}, {"line": "rcases h with \u27e8u, rfl\u27e9", "tactic_state": "case intro\nn : \u2115\nu : (ZMod n)\u02e3\n\u22a2 \u2191u * (\u2191u)\u207b\u00b9 = 1"}, {"line": "rw [inv_coe_unit]", "tactic_state": "case intro\nn : \u2115\nu : (ZMod n)\u02e3\n\u22a2 \u2191u * \u2191u\u207b\u00b9 = 1"}, {"line": "rw [u.mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_mul_of_unit {n : \u2115} (a : ZMod n) (h : IsUnit a) : a\u207b\u00b9 * a = 1 := by\n  rw [mul_comm]\n  rw [mul_inv_of_unit a h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : ZMod n\nh : IsUnit a\n\u22a2 a\u207b\u00b9 * a = 1"}, {"line": "rw [mul_comm]", "tactic_state": "n : \u2115\na : ZMod n\nh : IsUnit a\n\u22a2 a * a\u207b\u00b9 = 1"}, {"line": "rw [mul_inv_of_unit a h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_mul_eq_one_of_isUnit {n : \u2115} {a : ZMod n} (ha : IsUnit a) (b : ZMod n) :\n    a\u207b\u00b9 * b = 1 \u2194 a = b := by\n  -- ideally, this would be `ha.inv_mul_eq_one`, but `ZMod n` is not a `DivisionMonoid`...\n  -- (see the \"TODO\" above)\n  refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H \u25b8 a.inv_mul_of_unit ha\u27e9\n  apply_fun (a * \u00b7) at H\n  rwa [\u2190 mul_assoc, a.mul_inv_of_unit ha, one_mul, mul_one, eq_comm] at H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : ZMod n\nha : IsUnit a\nb : ZMod n\n\u22a2 a\u207b\u00b9 * b = 1 \u2194 a = b"}, {"line": "refine \u27e8fun H \u21a6 ?_, fun H \u21a6 H \u25b8 a.inv_mul_of_unit ha\u27e9", "tactic_state": "n : \u2115\na : ZMod n\nha : IsUnit a\nb : ZMod n\nH : a\u207b\u00b9 * b = 1\n\u22a2 a = b"}, {"line": "apply_fun (a * \u00b7) at H", "tactic_state": "n : \u2115\na : ZMod n\nha : IsUnit a\nb : ZMod n\nH : a * (a\u207b\u00b9 * b) = a * 1\n\u22a2 a = b"}, {"line": "rwa [\u2190 mul_assoc, a.mul_inv_of_unit ha, one_mul, mul_one, eq_comm] at H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_self_eq_zero_iff_eq_zero {n : \u2115} (hn : Odd n) {a : ZMod n} :\n    a + a = 0 \u2194 a = 0 := by\n  rw [Nat.odd_iff] at hn\n  rw [\u2190 Nat.two_dvd_ne_zero] at hn\n  rw [\u2190 Nat.prime_two.coprime_iff_not_dvd] at hn\n  rw [\u2190 mul_two]\n  rw [\u2190 @Nat.cast_two (ZMod n)]\n  rw [\u2190 ZMod.coe_unitOfCoprime 2 hn]\n  rw [Units.mul_left_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : Odd n\na : ZMod n\n\u22a2 a + a = 0 \u2194 a = 0"}, {"line": "rw [Nat.odd_iff] at hn", "tactic_state": "n : \u2115\nhn : n % 2 = 1\na : ZMod n\n\u22a2 a + a = 0 \u2194 a = 0"}, {"line": "rw [\u2190 Nat.two_dvd_ne_zero] at hn", "tactic_state": "n : \u2115\nhn : \u00ac2 \u2223 n\na : ZMod n\n\u22a2 a + a = 0 \u2194 a = 0"}, {"line": "rw [\u2190 Nat.prime_two.coprime_iff_not_dvd] at hn", "tactic_state": "n : \u2115\nhn : Nat.Coprime 2 n\na : ZMod n\n\u22a2 a + a = 0 \u2194 a = 0"}, {"line": "rw [\u2190 mul_two]", "tactic_state": "n : \u2115\nhn : Nat.Coprime 2 n\na : ZMod n\n\u22a2 a * 2 = 0 \u2194 a = 0"}, {"line": "rw [\u2190 @Nat.cast_two (ZMod n)]", "tactic_state": "n : \u2115\nhn : Nat.Coprime 2 n\na : ZMod n\n\u22a2 a * \u21912 = 0 \u2194 a = 0"}, {"line": "rw [\u2190 ZMod.coe_unitOfCoprime 2 hn]", "tactic_state": "n : \u2115\nhn : Nat.Coprime 2 n\na : ZMod n\n\u22a2 a * \u2191(unitOfCoprime 2 hn) = 0 \u2194 a = 0"}, {"line": "rw [Units.mul_left_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_neg_self {n : \u2115} (hn : Odd n) {a : ZMod n} (ha : a \u2260 0) : a \u2260 -a := by\n  rwa [Ne, eq_neg_iff_add_eq_zero, add_self_eq_zero_iff_eq_zero hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : Odd n\na : ZMod n\nha : a \u2260 0\n\u22a2 a \u2260 -a"}, {"line": "rwa [Ne, eq_neg_iff_add_eq_zero, add_self_eq_zero_iff_eq_zero hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natAbs_mod_two (a : \u2124) : (a.natAbs : ZMod 2) = a := by\n  cases a\n  \u00b7 simp only [Int.natAbs_natCast, Int.cast_natCast, Int.ofNat_eq_coe]\n  \u00b7 simp only [neg_eq_self_mod_two, Nat.cast_succ, Int.natAbs, Int.cast_negSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 \u2191a.natAbs = \u2191a"}, {"line": "cases a", "tactic_state": "case ofNat\na\u271d : \u2115\n\u22a2 \u2191(Int.ofNat a\u271d).natAbs = \u2191(Int.ofNat a\u271d)\n---\ncase negSucc\na\u271d : \u2115\n\u22a2 \u2191(Int.negSucc a\u271d).natAbs = \u2191(Int.negSucc a\u271d)"}, {"line": "\u00b7 simp only [Int.natAbs_natCast, Int.cast_natCast, Int.ofNat_eq_coe]", "tactic_state": "case negSucc\na\u271d : \u2115\n\u22a2 \u2191(Int.negSucc a\u271d).natAbs = \u2191(Int.negSucc a\u271d)"}, {"line": "\u00b7 simp only [neg_eq_self_mod_two, Nat.cast_succ, Int.natAbs, Int.cast_negSucc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_pos {n : \u2115} {a : ZMod n} : 0 < a.val \u2194 a \u2260 0 := by\n  simp [pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : ZMod n\n\u22a2 0 < a.val \u2194 a \u2260 0"}, {"line": "simp [pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_cast_of_lt {n : \u2115} {a : \u2115} (h : a < n) : (a : ZMod n).val = a := by\n  rw [val_natCast]\n  rw [Nat.mod_eq_of_lt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nh : a < n\n\u22a2 (\u2191a).val = a"}, {"line": "rw [val_natCast]", "tactic_state": "n a : \u2115\nh : a < n\n\u22a2 a % n = a"}, {"line": "rw [Nat.mod_eq_of_lt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem val_sub {n : \u2115} [NeZero n] {a b : ZMod n} (h : b.val \u2264 a.val) :\n    (a - b).val = a.val - b.val := by\n  by_cases hb : b = 0\n  \u00b7 cases hb; simp\n  \u00b7 have : NeZero b := \u27e8hb\u27e9\n    rw [sub_eq_add_neg]\n    rw [val_add]\n    rw [val_neg_of_ne_zero]\n    rw [\u2190 Nat.add_sub_assoc (le_of_lt (val_lt _))]\n    rw [add_comm]\n    rw [Nat.add_sub_assoc h]\n    rw [Nat.add_mod_left]\n    apply Nat.mod_eq_of_lt (tsub_lt_of_lt (val_lt _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : b.val \u2264 a.val\n\u22a2 (a - b).val = a.val - b.val"}, {"line": "by_cases hb : b = 0", "tactic_state": "case pos\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : b.val \u2264 a.val\nhb : b = 0\n\u22a2 (a - b).val = a.val - b.val\n---\ncase neg\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : b.val \u2264 a.val\nhb : \u00acb = 0\n\u22a2 (a - b).val = a.val - b.val"}, {"line": "\u00b7 cases hb; simp", "tactic_state": "case neg\nn : \u2115\ninst\u271d : NeZero n\na b : ZMod n\nh : b.val \u2264 a.val\nhb : \u00acb = 0\n\u22a2 (a - b).val = a.val - b.val"}, {"line": "\u00b7 have : NeZero b := \u27e8hb\u27e9\n    rw [sub_eq_add_neg]\n    rw [val_add]\n    rw [val_neg_of_ne_zero]\n    rw [\u2190 Nat.add_sub_assoc (le_of_lt (val_lt _))]\n    rw [add_comm]\n    rw [Nat.add_sub_assoc h]\n    rw [Nat.add_mod_left]\n    apply Nat.mod_eq_of_lt (tsub_lt_of_lt (val_lt _))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zmod_smul_mem (hx : x \u2208 K) : \u2200 a : ZMod n, a \u2022 x \u2208 K := by\n  simpa [ZMod.forall, Int.cast_smul_eq_zsmul] using zsmul_mem hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nS : Type u_5\nG : Type u_6\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : SetLike S G\ninst\u271d\u00b9 : AddSubgroupClass S G\nK : S\ninst\u271d : Module (ZMod n) G\nx : G\nhx : x \u2208 K\n\u22a2 \u2200 (a : ZMod n), a \u2022 x \u2208 K"}, {"line": "simpa [ZMod.forall, Int.cast_smul_eq_zsmul] using zsmul_mem hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ZModModule.two_le_char [NeZero n] [Nontrivial G] : 2 \u2264 n := by\n  have := NeZero.ne n\n  have := char_ne_one n G\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nG : Type u_6\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : Module (ZMod n) G\ninst\u271d\u00b9 : NeZero n\ninst\u271d : Nontrivial G\n\u22a2 2 \u2264 n"}, {"line": "have := NeZero.ne n", "tactic_state": "n : \u2115\nG : Type u_6\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : Module (ZMod n) G\ninst\u271d\u00b9 : NeZero n\ninst\u271d : Nontrivial G\nthis : n \u2260 0\n\u22a2 2 \u2264 n"}, {"line": "have := char_ne_one n G", "tactic_state": "n : \u2115\nG : Type u_6\ninst\u271d\u00b3 : AddCommGroup G\ninst\u271d\u00b2 : Module (ZMod n) G\ninst\u271d\u00b9 : NeZero n\ninst\u271d : Nontrivial G\nthis\u271d : n \u2260 0\nthis : n \u2260 1\n\u22a2 2 \u2264 n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ZModModule.add_self (x : G) : x + x = 0 := by\n  simpa [two_nsmul] using char_nsmul_eq_zero 2 x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx : G\n\u22a2 x + x = 0"}, {"line": "simpa [two_nsmul] using char_nsmul_eq_zero 2 x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ZModModule.neg_eq_self (x : G) : -x = x := by simp [add_self, eq_comm, \u2190 sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx : G\n\u22a2 -x = x"}, {"line": "simp [add_self, eq_comm, \u2190 sub_eq_zero]", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx : G\n\u22a2 x = -x"}]}
{"declaration": "lemma ZModModule.sub_eq_add (x y : G) : x - y = x + y := by simp [neg_eq_self, sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx y : G\n\u22a2 x - y = x + y"}, {"line": "simp [neg_eq_self, sub_eq_add_neg]", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx y : G\n\u22a2 x + -y = x + y"}]}
{"declaration": "lemma ZModModule.add_add_add_cancel (x y z : G) : (x + y) + (y + z) = x + z := by\n  simpa [sub_eq_add] using sub_add_sub_cancel x y z\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_6\ninst\u271d : AddCommGroup G\nx y z : G\n\u22a2 x + y + (y + z) = x + z"}, {"line": "simpa [sub_eq_add] using sub_add_sub_cancel x y z", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nsmul_zmod_val_inv_nsmul (hn : (Nat.card \u03b1).Coprime n) (a : \u03b1) :\n    n \u2022 (n\u207b\u00b9 : ZMod (Nat.card \u03b1)).val \u2022 a = a := by\n  rw [\u2190 mul_nsmul']\n  rw [\u2190 mod_natCard_nsmul]\n  rw [\u2190 ZMod.val_natCast]\n  rw [Nat.cast_mul]\n  rw [ZMod.mul_val_inv hn.symm]\n  rw [ZMod.val_one_eq_one_mod]\n  rw [mod_natCard_nsmul]\n  rw [one_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]", "{\u03b1 : Type*} [AddGroup \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 n \u2022 (\u2191n)\u207b\u00b9.val \u2022 a = a"}, {"line": "rw [\u2190 mul_nsmul']", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (n * (\u2191n)\u207b\u00b9.val) \u2022 a = a"}, {"line": "rw [\u2190 mod_natCard_nsmul]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (n * (\u2191n)\u207b\u00b9.val % Nat.card \u03b1) \u2022 a = a"}, {"line": "rw [\u2190 ZMod.val_natCast]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (\u2191(n * (\u2191n)\u207b\u00b9.val)).val \u2022 a = a"}, {"line": "rw [Nat.cast_mul]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (\u2191n * \u2191(\u2191n)\u207b\u00b9.val).val \u2022 a = a"}, {"line": "rw [ZMod.mul_val_inv hn.symm]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 val 1 \u2022 a = a"}, {"line": "rw [ZMod.val_one_eq_one_mod]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (1 % Nat.card \u03b1) \u2022 a = a"}, {"line": "rw [mod_natCard_nsmul]", "tactic_state": "\u03b1 : Type u_7\ninst\u271d : AddGroup \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 1 \u2022 a = a"}, {"line": "rw [one_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_zmod_val_inv_pow (hn : (Nat.card \u03b1).Coprime n) (a : \u03b1) :\n    (a ^ (n\u207b\u00b9 : ZMod (Nat.card \u03b1)).val) ^ n = a := by\n  rw [\u2190 pow_mul']\n  rw [\u2190 pow_mod_natCard]\n  rw [\u2190 ZMod.val_natCast]\n  rw [Nat.cast_mul]\n  rw [ZMod.mul_val_inv hn.symm]\n  rw [ZMod.val_one_eq_one_mod]\n  rw [pow_mod_natCard]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Basic.lean", "context": {"open": ["Function ZMod"], "variables": ["{n : \u2115} {R : Type*}", "[AddGroupWithOne R]", "{S : Type*} [AddGroupWithOne S]", "(R) [Ring R]", "{R}", "{m : \u2115} [CharP R m]", "[CharP R n]", "(R)", "{m n : \u2115}", "{n : \u2115} {R : Type*}", "(n) {A : Type*} [AddGroup A]", "(f : { f : \u2124 \u2192+ A // f n = 0 })", "{n : \u2115} {S G : Type*} [AddCommGroup G] [SetLike S G] [AddSubgroupClass S G] {K : S} {x : G}", "[Module (ZMod n) G] {x : G}", "(n)", "(G) in", "(G) in", "[Module (ZMod 2) G]", "{\u03b1 : Type*} [AddGroup \u03b1] {n : \u2115}", "{\u03b1 : Type*} [Group \u03b1] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 (a ^ (\u2191n)\u207b\u00b9.val) ^ n = a"}, {"line": "rw [\u2190 pow_mul']", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ (n * (\u2191n)\u207b\u00b9.val) = a"}, {"line": "rw [\u2190 pow_mod_natCard]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ (n * (\u2191n)\u207b\u00b9.val % Nat.card \u03b1) = a"}, {"line": "rw [\u2190 ZMod.val_natCast]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ (\u2191(n * (\u2191n)\u207b\u00b9.val)).val = a"}, {"line": "rw [Nat.cast_mul]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ (\u2191n * \u2191(\u2191n)\u207b\u00b9.val).val = a"}, {"line": "rw [ZMod.mul_val_inv hn.symm]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ val 1 = a"}, {"line": "rw [ZMod.val_one_eq_one_mod]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ (1 % Nat.card \u03b1) = a"}, {"line": "rw [pow_mod_natCard]", "tactic_state": "\u03b1 : Type u_8\ninst\u271d : Group \u03b1\nn : \u2115\nhn : (Nat.card \u03b1).Coprime n\na : \u03b1\n\u22a2 a ^ 1 = a"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma index_zmultiples (a : \u2124) : (AddSubgroup.zmultiples a).index = a.natAbs := by\n  rw [AddSubgroup.index]\n  rw [Nat.card_congr (quotientZMultiplesEquivZMod a).toEquiv]\n  rw [Nat.card_zmod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/QuotientGroup.lean", "context": {"open": ["QuotientAddGroup Set ZMod"], "variables": ["(n : \u2115) {A R : Type*} [AddGroup A] [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2124\n\u22a2 (AddSubgroup.zmultiples a).index = a.natAbs"}, {"line": "rw [AddSubgroup.index]", "tactic_state": "a : \u2124\n\u22a2 Nat.card (\u2124 \u29f8 AddSubgroup.zmultiples a) = a.natAbs"}, {"line": "rw [Nat.card_congr (quotientZMultiplesEquivZMod a).toEquiv]", "tactic_state": "a : \u2124\n\u22a2 Nat.card ?m.328 = a.natAbs\n---\na : \u2124\n\u22a2 Type ?u.325"}, {"line": "rw [Nat.card_zmod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.AddAction.orbitZMultiplesEquiv_symm_apply' {\u03b1 \u03b2 : Type*} [AddGroup \u03b1] (a : \u03b1)\n    [AddAction \u03b1 \u03b2] (b : \u03b2) (k : \u2124) :\n    (AddAction.orbitZMultiplesEquiv a b).symm k =\n      k \u2022 (\u27e8a, mem_zmultiples a\u27e9 : zmultiples a) +\u1d65 \u27e8b, AddAction.mem_orbit_self b\u27e9 := by\n  rw [AddAction.orbitZMultiplesEquiv_symm_apply]\n  rw [ZMod.coe_intCast]\n  -- Making `a` explicit turns this from ~190000 heartbeats to ~700.\n  exact Subtype.ext (zsmul_vadd_mod_minimalPeriod a _ k)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/QuotientGroup.lean", "context": {"open": ["QuotientAddGroup Set ZMod", "AddSubgroup AddMonoidHom AddEquiv Function", "AddAction Subgroup AddSubgroup Function"], "variables": ["(n : \u2115) {A R : Type*} [AddGroup A] [Ring R]", "{\u03b1 \u03b2 : Type*} [AddGroup \u03b1] (a : \u03b1) [AddAction \u03b1 \u03b2] (b : \u03b2)", "{\u03b1 \u03b2 : Type*} [Group \u03b1] (a : \u03b1) [MulAction \u03b1 \u03b2] (b : \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d\u00b9 : AddGroup \u03b1\na : \u03b1\ninst\u271d : AddAction \u03b1 \u03b2\nb : \u03b2\nk : \u2124\n\u22a2 (orbitZMultiplesEquiv a b).symm \u2191k = k \u2022 \u27e8a, \u22ef\u27e9 +\u1d65 \u27e8b, \u22ef\u27e9"}, {"line": "rw [AddAction.orbitZMultiplesEquiv_symm_apply]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d\u00b9 : AddGroup \u03b1\na : \u03b1\ninst\u271d : AddAction \u03b1 \u03b2\nb : \u03b2\nk : \u2124\n\u22a2 (\u2191k).cast \u2022 \u27e8a, \u22ef\u27e9 +\u1d65 \u27e8b, \u22ef\u27e9 = k \u2022 \u27e8a, \u22ef\u27e9 +\u1d65 \u27e8b, \u22ef\u27e9"}, {"line": "rw [ZMod.coe_intCast]", "tactic_state": "\u03b1 : Type u_7\n\u03b2 : Type u_8\ninst\u271d\u00b9 : AddGroup \u03b1\na : \u03b1\ninst\u271d : AddAction \u03b1 \u03b2\nb : \u03b2\nk : \u2124\n\u22a2 (k % \u2191(minimalPeriod (fun x => a +\u1d65 x) b)) \u2022 \u27e8a, \u22ef\u27e9 +\u1d65 \u27e8b, \u22ef\u27e9 = k \u2022 \u27e8a, \u22ef\u27e9 +\u1d65 \u27e8b, \u22ef\u27e9"}, {"line": "exact Subtype.ext (zsmul_vadd_mod_minimalPeriod a _ k)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma quotientEquivSigmaZMod_apply (q : orbitRel.Quotient (zpowers g) (G \u29f8 H)) (k : \u2124) :\n    quotientEquivSigmaZMod H g (g ^ k \u2022 q.out) = \u27e8q, k\u27e9 := by\n  rw [apply_eq_iff_eq_symm_apply]\n  rw [quotientEquivSigmaZMod_symm_apply]\n  rw [ZMod.coe_intCast]\n  rw [zpow_smul_mod_minimalPeriod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/QuotientGroup.lean", "context": {"open": ["QuotientAddGroup Set ZMod", "AddSubgroup AddMonoidHom AddEquiv Function", "AddAction Subgroup AddSubgroup Function", "Subgroup", "Equiv Function MulAction"], "variables": ["(n : \u2115) {A R : Type*} [AddGroup A] [Ring R]", "{\u03b1 \u03b2 : Type*} [AddGroup \u03b1] (a : \u03b1) [AddAction \u03b1 \u03b2] (b : \u03b2)", "{\u03b1 \u03b2 : Type*} [Group \u03b1] (a : \u03b1) [MulAction \u03b1 \u03b2] (b : \u03b2)", "{\u03b1 : Type*} [Group \u03b1] (a : \u03b1)", "{a}", "{G : Type*} [Group G] (H : Subgroup G) (g : G)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_8\ninst\u271d : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (\u21a5(zpowers g)) (G \u29f8 H)\nk : \u2124\n\u22a2 (H.quotientEquivSigmaZMod g) (g ^ k \u2022 Quotient.out q) = \u27e8q, \u2191k\u27e9"}, {"line": "rw [apply_eq_iff_eq_symm_apply]", "tactic_state": "G : Type u_8\ninst\u271d : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (\u21a5(zpowers g)) (G \u29f8 H)\nk : \u2124\n\u22a2 g ^ k \u2022 Quotient.out q = (H.quotientEquivSigmaZMod g).symm \u27e8q, \u2191k\u27e9"}, {"line": "rw [quotientEquivSigmaZMod_symm_apply]", "tactic_state": "G : Type u_8\ninst\u271d : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (\u21a5(zpowers g)) (G \u29f8 H)\nk : \u2124\n\u22a2 g ^ k \u2022 Quotient.out q = g ^ (\u2191k).cast \u2022 Quotient.out q"}, {"line": "rw [ZMod.coe_intCast]", "tactic_state": "G : Type u_8\ninst\u271d : Group G\nH : Subgroup G\ng : G\nq : MulAction.orbitRel.Quotient (\u21a5(zpowers g)) (G \u29f8 H)\nk : \u2124\n\u22a2 g ^ k \u2022 Quotient.out q = g ^ (k % \u2191(minimalPeriod (fun x => g \u2022 x) (Quotient.out q))) \u2022 Quotient.out q"}, {"line": "rw [zpow_smul_mod_minimalPeriod]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unitsMap_self (n : \u2115) : unitsMap (dvd_refl n) = MonoidHom.id _ := by\n  simp [unitsMap, castHom_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/Units.lean", "context": {"open": [], "variables": ["{n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nunitsMap : x\u271d\nn : \u2115\n\u22a2 sorry = MonoidHom.id (?m.954 n)"}, {"line": "simp [unitsMap, castHom_self]", "tactic_state": "x\u271d : Sort u_1\nunitsMap : x\u271d\nn : \u2115\n\u22a2 sorry () = MonoidHom.id (?m.954 n)"}]}
{"declaration": "lemma natAbs_valMinAbs_neg (a : ZMod n) : (-a).valMinAbs.natAbs = a.valMinAbs.natAbs := by\n  by_cases h2a : 2 * a.val = n\n  \u00b7 rw [a.neg_eq_self_iff.2 (Or.inr h2a)]\n  \u00b7 rw [valMinAbs_neg_of_ne_half h2a, Int.natAbs_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/ValMinAbs.lean", "context": {"open": [], "variables": ["{n : \u2115} {a : ZMod n}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\na : ZMod n\n\u22a2 (-a).valMinAbs.natAbs = a.valMinAbs.natAbs"}, {"line": "by_cases h2a : 2 * a.val = n", "tactic_state": "case pos\nn : \u2115\na : ZMod n\nh2a : 2 * a.val = n\n\u22a2 (-a).valMinAbs.natAbs = a.valMinAbs.natAbs\n---\ncase neg\nn : \u2115\na : ZMod n\nh2a : \u00ac2 * a.val = n\n\u22a2 (-a).valMinAbs.natAbs = a.valMinAbs.natAbs"}, {"line": "\u00b7 rw [a.neg_eq_self_iff.2 (Or.inr h2a)]", "tactic_state": "case neg\nn : \u2115\na : ZMod n\nh2a : \u00ac2 * a.val = n\n\u22a2 (-a).valMinAbs.natAbs = a.valMinAbs.natAbs"}, {"line": "\u00b7 rw [valMinAbs_neg_of_ne_half h2a, Int.natAbs_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valMinAbs_natCast_of_le_half (ha : a \u2264 n / 2) : (a : ZMod n).valMinAbs = a := by\n  cases n\n  \u00b7 simp\n  \u00b7 simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt (ha.trans_lt <| Nat.div_lt_self' _ 0),\n      ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/ValMinAbs.lean", "context": {"open": [], "variables": ["{n : \u2115} {a : ZMod n}", "{n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nha : a \u2264 n / 2\n\u22a2 (\u2191a).valMinAbs = \u2191a"}, {"line": "cases n", "tactic_state": "case zero\na : \u2115\nha : a \u2264 0 / 2\n\u22a2 (\u2191a).valMinAbs = \u2191a\n---\ncase succ\na n\u271d : \u2115\nha : a \u2264 (n\u271d + 1) / 2\n\u22a2 (\u2191a).valMinAbs = \u2191a"}, {"line": "\u00b7 simp", "tactic_state": "case succ\na n\u271d : \u2115\nha : a \u2264 (n\u271d + 1) / 2\n\u22a2 (\u2191a).valMinAbs = \u2191a"}, {"line": "\u00b7 simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt (ha.trans_lt <| Nat.div_lt_self' _ 0),\n      ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valMinAbs_natCast_of_half_lt (ha : n / 2 < a) (ha' : a < n) :\n    (a : ZMod n).valMinAbs = a - n := by\n  cases n\n  \u00b7 cases not_lt_bot ha'\n  \u00b7 simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt ha', ha.not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/ValMinAbs.lean", "context": {"open": [], "variables": ["{n : \u2115} {a : ZMod n}", "{n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nha : n / 2 < a\nha' : a < n\n\u22a2 (\u2191a).valMinAbs = \u2191a - \u2191n"}, {"line": "cases n", "tactic_state": "case zero\na : \u2115\nha : 0 / 2 < a\nha' : a < 0\n\u22a2 (\u2191a).valMinAbs = \u2191a - \u21910\n---\ncase succ\na n\u271d : \u2115\nha : (n\u271d + 1) / 2 < a\nha' : a < n\u271d + 1\n\u22a2 (\u2191a).valMinAbs = \u2191a - \u2191(n\u271d + 1)"}, {"line": "\u00b7 cases not_lt_bot ha'", "tactic_state": "case succ\na n\u271d : \u2115\nha : (n\u271d + 1) / 2 < a\nha' : a < n\u271d + 1\n\u22a2 (\u2191a).valMinAbs = \u2191a - \u2191(n\u271d + 1)"}, {"line": "\u00b7 simp [valMinAbs_def_pos, val_natCast, Nat.mod_eq_of_lt ha', ha.not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma valMinAbs_natCast_eq_self [NeZero n] : (a : ZMod n).valMinAbs = a \u2194 a \u2264 n / 2 := by\n  refine \u27e8fun ha => ?_, valMinAbs_natCast_of_le_half\u27e9\n  rw [\u2190 Int.natAbs_natCast a]\n  rw [\u2190 ha]\n  exact natAbs_valMinAbs_le (n := n) a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/ZMod/ValMinAbs.lean", "context": {"open": [], "variables": ["{n : \u2115} {a : ZMod n}", "{n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\ninst\u271d : NeZero n\n\u22a2 (\u2191a).valMinAbs = \u2191a \u2194 a \u2264 n / 2"}, {"line": "refine \u27e8fun ha => ?_, valMinAbs_natCast_of_le_half\u27e9", "tactic_state": "n a : \u2115\ninst\u271d : NeZero n\nha : (\u2191a).valMinAbs = \u2191a\n\u22a2 a \u2264 n / 2"}, {"line": "rw [\u2190 Int.natAbs_natCast a]", "tactic_state": "n a : \u2115\ninst\u271d : NeZero n\nha : (\u2191a).valMinAbs = \u2191a\n\u22a2 (\u2191a).natAbs \u2264 n / 2"}, {"line": "rw [\u2190 ha]", "tactic_state": "n a : \u2115\ninst\u271d : NeZero n\nha : (\u2191a).valMinAbs = \u2191a\n\u22a2 (\u2191a).valMinAbs.natAbs \u2264 n / 2"}, {"line": "exact natAbs_valMinAbs_le (n := n) a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sum (\u03b1 \u03b2 : Type*) :\n    PartENat.card (\u03b1 \u2295 \u03b2) = PartENat.card \u03b1 + PartENat.card \u03b2 := by\n  simp only [PartENat.card]\n  simp only [Cardinal.mk_sum]\n  simp only [map_add]\n  simp only [Cardinal.toPartENat_lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 PartENat.card (\u03b1 \u2295 \u03b2) = PartENat.card \u03b1 + PartENat.card \u03b2"}, {"line": "simp only [PartENat.card]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 toPartENat (mk (\u03b1 \u2295 \u03b2)) = toPartENat (mk \u03b1) + toPartENat (mk \u03b2)"}, {"line": "simp only [Cardinal.mk_sum]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 toPartENat (lift.{u_2, u_1} (mk \u03b1) + lift.{u_1, u_2} (mk \u03b2)) = toPartENat (mk \u03b1) + toPartENat (mk \u03b2)"}, {"line": "simp only [map_add]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u22a2 toPartENat (lift.{u_2, u_1} (mk \u03b1)) + toPartENat (lift.{u_1, u_2} (mk \u03b2)) = toPartENat (mk \u03b1) + toPartENat (mk \u03b2)"}, {"line": "simp only [Cardinal.toPartENat_lift]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.natCast_le_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n \u2264 toPartENat c \u2194 \u2191n \u2264 c := by\n  rw [\u2190 toPartENat_natCast n]\n  rw [toPartENat_le_iff_of_le_aleph0 (le_of_lt (nat_lt_aleph0 n))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n \u2264 toPartENat c \u2194 \u2191n \u2264 c"}, {"line": "rw [\u2190 toPartENat_natCast n]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 toPartENat \u2191n \u2264 toPartENat c \u2194 \u2191n \u2264 c"}, {"line": "rw [toPartENat_le_iff_of_le_aleph0 (le_of_lt (nat_lt_aleph0 n))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toPartENat_le_natCast_iff {c : Cardinal} {n : \u2115} :\n    toPartENat c \u2264 n \u2194 c \u2264 n := by\n  rw [\u2190 toPartENat_natCast n]\n  rw [toPartENat_le_iff_of_lt_aleph0 (nat_lt_aleph0 n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nn : \u2115\n\u22a2 toPartENat c \u2264 \u2191n \u2194 c \u2264 \u2191n"}, {"line": "rw [\u2190 toPartENat_natCast n]", "tactic_state": "c : Cardinal.{u_1}\nn : \u2115\n\u22a2 toPartENat c \u2264 toPartENat \u2191n \u2194 c \u2264 \u2191n"}, {"line": "rw [toPartENat_le_iff_of_lt_aleph0 (nat_lt_aleph0 n)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.natCast_eq_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n = toPartENat c \u2194 \u2191n = c := by\n  rw [le_antisymm_iff]\n  rw [le_antisymm_iff]\n  rw [Cardinal.toPartENat_le_natCast_iff]\n  rw [Cardinal.natCast_le_toPartENat_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n = toPartENat c \u2194 \u2191n = c"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n \u2264 toPartENat c \u2227 toPartENat c \u2264 \u2191n \u2194 \u2191n = c"}, {"line": "rw [le_antisymm_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n \u2264 toPartENat c \u2227 toPartENat c \u2264 \u2191n \u2194 \u2191n \u2264 c \u2227 c \u2264 \u2191n"}, {"line": "rw [Cardinal.toPartENat_le_natCast_iff]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n \u2264 toPartENat c \u2227 c \u2264 \u2191n \u2194 \u2191n \u2264 c \u2227 c \u2264 \u2191n"}, {"line": "rw [Cardinal.natCast_le_toPartENat_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toPartENat_eq_natCast_iff {c : Cardinal} {n : \u2115} :\n    Cardinal.toPartENat c = n \u2194 c = n := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Cardinal.{u_1}\nn : \u2115\n\u22a2 toPartENat c = \u2191n \u2194 c = \u2191n"}]}
{"declaration": "theorem _root_.Cardinal.natCast_lt_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n < toPartENat c \u2194 \u2191n < c := by\n  simp only [\u2190 not_le]\n  simp only [Cardinal.toPartENat_le_natCast_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u2191n < toPartENat c \u2194 \u2191n < c"}, {"line": "simp only [\u2190 not_le]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u00actoPartENat c \u2264 \u2191n \u2194 \u00acc \u2264 \u2191n"}, {"line": "simp only [Cardinal.toPartENat_le_natCast_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Cardinal.toPartENat_lt_natCast_iff {n : \u2115} {c : Cardinal} :\n    toPartENat c < \u2191n \u2194 c < \u2191n := by\n  simp only [\u2190 not_le]\n  simp only [Cardinal.natCast_le_toPartENat_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Deprecated/Cardinal/Finite.lean", "context": {"open": ["Cardinal"], "variables": ["{\u03b1 : Type u}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 toPartENat c < \u2191n \u2194 c < \u2191n"}, {"line": "simp only [\u2190 not_le]", "tactic_state": "n : \u2115\nc : Cardinal.{u_1}\n\u22a2 \u00ac\u2191n \u2264 toPartENat c \u2194 \u00ac\u2191n \u2264 c"}, {"line": "simp only [Cardinal.natCast_le_toPartENat_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isInvariant_iff_image : IsInvariant \u03d5 s \u2194 \u2200 t, \u03d5 t '' s \u2286 s := by\n  simp_rw [IsInvariant, mapsTo']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Flow.lean", "context": {"open": ["Set Function Filter"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*}", "(\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1) (s : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u22a2 IsInvariant \u03d5 s \u2194 \u2200 (t : \u03c4), \u03d5 t '' s \u2286 s"}, {"line": "simp_rw [IsInvariant, mapsTo']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omegaLimit_subset_of_tendsto {m : \u03c4 \u2192 \u03c4} {f\u2081 f\u2082 : Filter \u03c4} (hf : Tendsto m f\u2081 f\u2082) :\n    \u03c9 f\u2081 (fun t x \u21a6 \u03d5 (m t) x) s \u2286 \u03c9 f\u2082 \u03d5 s := by\n  refine iInter\u2082_mono' fun u hu \u21a6 \u27e8m \u207b\u00b9' u, tendsto_def.mp hf _ hu, ?_\u27e9\n  rw [\u2190 image2_image_left]\n  exact closure_mono (image2_subset (image_preimage_subset _ _) Subset.rfl)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nm : \u03c4 \u2192 \u03c4\nf\u2081 f\u2082 : Filter \u03c4\nhf : Tendsto m f\u2081 f\u2082\n\u22a2 omegaLimit f\u2081 (fun t x => \u03d5 (m t) x) s \u2286 omegaLimit f\u2082 \u03d5 s"}, {"line": "refine iInter\u2082_mono' fun u hu \u21a6 \u27e8m \u207b\u00b9' u, tendsto_def.mp hf _ hu, ?_\u27e9", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nm : \u03c4 \u2192 \u03c4\nf\u2081 f\u2082 : Filter \u03c4\nhf : Tendsto m f\u2081 f\u2082\nu : Set \u03c4\nhu : u \u2208 f\u2082\n\u22a2 closure (image2 (fun t x => \u03d5 (m t) x) (m \u207b\u00b9' u) s) \u2286 closure (image2 \u03d5 u s)"}, {"line": "rw [\u2190 image2_image_left]", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nm : \u03c4 \u2192 \u03c4\nf\u2081 f\u2082 : Filter \u03c4\nhf : Tendsto m f\u2081 f\u2082\nu : Set \u03c4\nhu : u \u2208 f\u2082\n\u22a2 closure (image2 \u03d5 (m '' (m \u207b\u00b9' u)) s) \u2286 closure (image2 \u03d5 u s)"}, {"line": "exact closure_mono (image2_subset (image_preimage_subset _ _) Subset.rfl)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omegaLimit_image_eq {\u03b1' : Type*} (\u03d5 : \u03c4 \u2192 \u03b1' \u2192 \u03b2) (f : Filter \u03c4) (g : \u03b1 \u2192 \u03b1') :\n    \u03c9 f \u03d5 (g '' s) = \u03c9 f (fun t x \u21a6 \u03d5 t (g x)) s := by simp only [omegaLimit, image2_image_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\n\u03b1' : Type u_5\n\u03d5 : \u03c4 \u2192 \u03b1' \u2192 \u03b2\nf : Filter \u03c4\ng : \u03b1 \u2192 \u03b1'\n\u22a2 omegaLimit f \u03d5 (g '' s) = omegaLimit f (fun t x => \u03d5 t (g x)) s"}, {"line": "simp only [omegaLimit, image2_image_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_omegaLimit_iff_frequently\u2082 (y : \u03b2) :\n    y \u2208 \u03c9 f \u03d5 s \u2194 \u2200 n \u2208 \ud835\udcdd y, \u2203\u1da0 t in f, (\u03d5 t '' s \u2229 n).Nonempty := by\n  simp_rw [mem_omegaLimit_iff_frequently, image_inter_nonempty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\ny : \u03b2\n\u22a2 y \u2208 omegaLimit f \u03d5 s \u2194 \u2200 n \u2208 nhds y, \u2203\u1da0 (t : \u03c4) in f, (\u03d5 t '' s \u2229 n).Nonempty"}, {"line": "simp_rw [mem_omegaLimit_iff_frequently, image_inter_nonempty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_omegaLimit_singleton_iff_map_cluster_point (x : \u03b1) (y : \u03b2) :\n    y \u2208 \u03c9 f \u03d5 {x} \u2194 MapClusterPt y f fun t \u21a6 \u03d5 t x := by\n  simp_rw [mem_omegaLimit_iff_frequently, mapClusterPt_iff_frequently, singleton_inter_nonempty,\n    mem_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\nx : \u03b1\ny : \u03b2\n\u22a2 y \u2208 omegaLimit f \u03d5 {x} \u2194 MapClusterPt y f fun t => \u03d5 t x"}, {"line": "simp_rw [mem_omegaLimit_iff_frequently, mapClusterPt_iff_frequently, singleton_inter_nonempty,\n    mem_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omegaLimit_iUnion (p : \u03b9 \u2192 Set \u03b1) : \u22c3 i, \u03c9 f \u03d5 (p i) \u2286 \u03c9 f \u03d5 (\u22c3 i, p i) := by\n  rw [iUnion_subset_iff]\n  exact fun i \u21a6 omegaLimit_mono_right _ _ (subset_iUnion _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\np : \u03b9 \u2192 Set \u03b1\n\u22a2 \u22c3 i, omegaLimit f \u03d5 (p i) \u2286 omegaLimit f \u03d5 (\u22c3 i, p i)"}, {"line": "rw [iUnion_subset_iff]", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\n\u03b9 : Type u_4\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\np : \u03b9 \u2192 Set \u03b1\n\u22a2 \u2200 (i : \u03b9), omegaLimit f \u03d5 (p i) \u2286 omegaLimit f \u03d5 (\u22c3 i, p i)"}, {"line": "exact fun i \u21a6 omegaLimit_mono_right _ _ (subset_iUnion _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omegaLimit_eq_iInter_inter {v : Set \u03c4} (hv : v \u2208 f) :\n    \u03c9 f \u03d5 s = \u22c2 u : \u21a5f.sets, closure (image2 \u03d5 (u \u2229 v) s) := by\n  rw [omegaLimit_eq_biInter_inter _ _ _ hv]\n  apply biInter_eq_iInter\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nv : Set \u03c4\nhv : v \u2208 f\n\u22a2 omegaLimit f \u03d5 s = \u22c2 u, closure (image2 \u03d5 (\u2191u \u2229 v) s)"}, {"line": "rw [omegaLimit_eq_biInter_inter _ _ _ hv]", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nv : Set \u03c4\nhv : v \u2208 f\n\u22a2 \u22c2 u \u2208 f, closure (image2 \u03d5 (u \u2229 v) s) = \u22c2 u, closure (image2 \u03d5 (\u2191u \u2229 v) s)"}, {"line": "apply biInter_eq_iInter", "tactic_state": "No Goals!"}]}
{"declaration": "theorem omegaLimit_subset_closure_fw_image {u : Set \u03c4} (hu : u \u2208 f) :\n    \u03c9 f \u03d5 s \u2286 closure (image2 \u03d5 u s) := by\n  rw [omegaLimit_eq_iInter]\n  intro _ hx\n  rw [mem_iInter] at hx\n  exact hx \u27e8u, hu\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/OmegaLimit.lean", "context": {"open": ["Set Function Filter Topology", "omegaLimit"], "variables": ["{\u03c4 : Type*} {\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[TopologicalSpace \u03b2]", "(f : Filter \u03c4) (\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2) (s s\u2081 s\u2082 : Set \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nu : Set \u03c4\nhu : u \u2208 f\n\u22a2 omegaLimit f \u03d5 s \u2286 closure (image2 \u03d5 u s)"}, {"line": "rw [omegaLimit_eq_iInter]", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nu : Set \u03c4\nhu : u \u2208 f\n\u22a2 \u22c2 u, closure (image2 \u03d5 (\u2191u) s) \u2286 closure (image2 \u03d5 u s)"}, {"line": "intro _ hx", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nu : Set \u03c4\nhu : u \u2208 f\na\u271d : \u03b2\nhx : a\u271d \u2208 \u22c2 u, closure (image2 \u03d5 (\u2191u) s)\n\u22a2 a\u271d \u2208 closure (image2 \u03d5 u s)"}, {"line": "rw [mem_iInter] at hx", "tactic_state": "\u03c4 : Type u_1\n\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d : TopologicalSpace \u03b2\nf : Filter \u03c4\n\u03d5 : \u03c4 \u2192 \u03b1 \u2192 \u03b2\ns : Set \u03b1\nu : Set \u03c4\nhu : u \u2208 f\na\u271d : \u03b2\nhx : \u2200 (i : \u2191f.sets), a\u271d \u2208 closure (image2 \u03d5 (\u2191i) s)\n\u22a2 a\u271d \u2208 closure (image2 \u03d5 u s)"}, {"line": "exact hx \u27e8u, hu\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem newtonMap_apply_of_isUnit (h : IsUnit <| aeval x (derivative P)) :\n    P.newtonMap x = x - h.unit\u207b\u00b9 * aeval x P := by\n  simp [newtonMap_apply, Ring.inverse, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Newton.lean", "context": {"open": ["Set Function"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (P : R[X]) {x : S}", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\naeval : x\u271d\n\u03b1\u271d : Type u_2\nx : \u03b1\u271d\nh : IsUnit sorry\n\u22a2 sorry = x - h.unit\u207b\u00b9 * sorry"}, {"line": "simp [newtonMap_apply, Ring.inverse, h]", "tactic_state": "x\u271d : Sort u_1\naeval : x\u271d\n\u03b1\u271d : Type u_2\nx : \u03b1\u271d\nh : IsUnit sorry\n\u22a2 sorry () = x - h.unit\u207b\u00b9 * sorry ()"}]}
{"declaration": "theorem newtonMap_apply_of_not_isUnit (h : \u00ac (IsUnit <| aeval x (derivative P))) :\n    P.newtonMap x = x := by\n  simp [newtonMap_apply, Ring.inverse, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Newton.lean", "context": {"open": ["Set Function"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (P : R[X]) {x : S}", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\naeval : x\u271d\n\u03b1\u271d : Sort u_2\nx : \u03b1\u271d\nh : \u00acIsUnit sorry\n\u22a2 sorry = x"}, {"line": "simp [newtonMap_apply, Ring.inverse, h]", "tactic_state": "x\u271d : Sort u_1\naeval : x\u271d\n\u03b1\u271d : Sort u_2\nx : \u03b1\u271d\nh : \u00acIsUnit sorry\n\u22a2 sorry () = x"}]}
{"declaration": "theorem birkhoffAverage_zero (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (x : \u03b1) :\n    birkhoffAverage R f g 0 x = 0 := by simp [birkhoffAverage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/BirkhoffSum/Average.lean", "context": {"open": ["Finset"], "variables": ["(R : Type*) {\u03b1 M : Type*} [DivisionSemiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : DivisionSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 M\nx : \u03b1\n\u22a2 birkhoffAverage R f g 0 x = 0"}, {"line": "simp [birkhoffAverage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem birkhoffAverage_one (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (x : \u03b1) :\n    birkhoffAverage R f g 1 x = g x := by simp [birkhoffAverage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/BirkhoffSum/Average.lean", "context": {"open": ["Finset"], "variables": ["(R : Type*) {\u03b1 M : Type*} [DivisionSemiring R] [AddCommMonoid M] [Module R M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : DivisionSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 M\nx : \u03b1\n\u22a2 birkhoffAverage R f g 1 x = g x"}, {"line": "simp [birkhoffAverage]", "tactic_state": "R : Type u_1\n\u03b1 : Type u_2\nM : Type u_3\ninst\u271d\u00b2 : DivisionSemiring R\ninst\u271d\u00b9 : AddCommMonoid M\ninst\u271d : Module R M\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 M\nx : \u03b1\n\u22a2 1\u207b\u00b9 \u2022 g x = g x"}]}
{"declaration": "theorem birkhoffSum_add (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 M) (m n : \u2115) (x : \u03b1) :\n    birkhoffSum f g (m + n) x = birkhoffSum f g m x + birkhoffSum f g n (f^[m] x) := by\n  simp_rw [birkhoffSum, sum_range_add, add_comm m, iterate_add_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/BirkhoffSum/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 M : Type*} [AddCommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : AddCommMonoid M\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 M\nm n : \u2115\nx : \u03b1\n\u22a2 birkhoffSum f g (m + n) x = birkhoffSum f g m x + birkhoffSum f g n (f^[m] x)"}, {"line": "simp_rw [birkhoffSum, sum_range_add, add_comm m, iterate_add_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.IsFixedPt.birkhoffSum_eq {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (h : IsFixedPt f x) (g : \u03b1 \u2192 M)\n    (n : \u2115) : birkhoffSum f g n x = n \u2022 g x := by\n  simp [birkhoffSum, (h.iterate _).eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/BirkhoffSum/Basic.lean", "context": {"open": ["Finset Function"], "variables": ["{\u03b1 M : Type*} [AddCommMonoid M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nM : Type u_2\ninst\u271d : AddCommMonoid M\nf : \u03b1 \u2192 \u03b1\nx : \u03b1\nh : IsFixedPt f x\ng : \u03b1 \u2192 M\nn : \u2115\n\u22a2 birkhoffSum f g n x = n \u2022 g x"}, {"line": "simp [birkhoffSum, (h.iterate _).eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_birkhoffAverage_birkhoffAverage (f : \u03b1 \u2192 \u03b1) (g : \u03b1 \u2192 E) (n : \u2115) (x y : \u03b1) :\n    dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) =\n      dist (birkhoffSum f g n x) (birkhoffSum f g n y) / n := by\n  simp [birkhoffAverage, dist_smul\u2080, div_eq_inv_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/BirkhoffSum/NormedSpace.lean", "context": {"open": ["Function Set Filter", "scoped Topology ENNReal Uniformity"], "variables": ["{\u03b1 E : Type*}", "[NormedAddCommGroup E]", "(\ud835\udd5c : Type*) [RCLike \ud835\udd5c] [Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : IsBoundedSMul \ud835\udd5c E\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 E\nn : \u2115\nx y : \u03b1\n\u22a2 dist (birkhoffAverage \ud835\udd5c f g n x) (birkhoffAverage \ud835\udd5c f g n y) = dist (birkhoffSum f g n x) (birkhoffSum f g n y) / \u2191n"}, {"line": "simp [birkhoffAverage, dist_smul\u2080, div_eq_inv_mul]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : NormedAddCommGroup E\n\ud835\udd5c : Type u_3\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : Module \ud835\udd5c E\ninst\u271d : IsBoundedSMul \ud835\udd5c E\nf : \u03b1 \u2192 \u03b1\ng : \u03b1 \u2192 E\nn : \u2115\nx y : \u03b1\n\u22a2 dist ((\u2191n)\u207b\u00b9 \u2022 birkhoffSum f g n x) ((\u2191n)\u207b\u00b9 \u2022 birkhoffSum f g n y) =\n    (\u2191n)\u207b\u00b9 * dist (birkhoffSum f g n x) (birkhoffSum f g n y)"}]}
{"declaration": "theorem commute_nat_add (n : \u2115) : Function.Commute f (n + \u00b7) := by\n  simpa only [nsmul_one,add_left_iterate] using Function.Commute.iterate_right f.map_one_add n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\n\u22a2 Function.Commute \u21d1f fun x => \u2191n + x"}, {"line": "simpa only [nsmul_one,add_left_iterate] using Function.Commute.iterate_right f.map_one_add n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commute_add_nat (n : \u2115) : Function.Commute f (\u00b7 + n) := by\n  simp only [add_comm _ (n : \u211d)]\n  simp only [f.commute_nat_add n]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\n\u22a2 Function.Commute \u21d1f fun x => x + \u2191n"}, {"line": "simp only [add_comm _ (n : \u211d)]", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\n\u22a2 Function.Commute \u21d1f fun x => \u2191n + x"}, {"line": "simp only [f.commute_nat_add n]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commute_sub_nat (n : \u2115) : Function.Commute f (\u00b7 - n) := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_nat n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\n\u22a2 Function.Commute \u21d1f fun x => x - \u2191n"}, {"line": "simpa only [sub_eq_add_neg] using\n    (f.commute_add_nat n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commute_int_add (n : \u2124) : Function.Commute f (n + \u00b7) := by\n  simpa only [add_comm _ (n : \u211d)] using f.commute_add_int n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2124\n\u22a2 Function.Commute \u21d1f fun x => \u2191n + x"}, {"line": "simpa only [add_comm _ (n : \u211d)] using f.commute_add_int n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem commute_sub_int (n : \u2124) : Function.Commute f (\u00b7 - n) := by\n  simpa only [sub_eq_add_neg] using\n    (f.commute_add_int n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2124\n\u22a2 Function.Commute \u21d1f fun x => x - \u2191n"}, {"line": "simpa only [sub_eq_add_neg] using\n    (f.commute_add_int n).inverses_right (Equiv.addRight _).right_inv (Equiv.addRight _).left_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_fract_sub_fract_eq (x : \u211d) : f (fract x) - fract x = f x - x := by\n  rw [Int.fract]\n  rw [f.map_sub_int]\n  rw [sub_sub_sub_cancel_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\n\u22a2 f (fract x) - fract x = f x - x"}, {"line": "rw [Int.fract]", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\n\u22a2 f (x - \u2191\u230ax\u230b) - (x - \u2191\u230ax\u230b) = f x - x"}, {"line": "rw [f.map_sub_int]", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\n\u22a2 f x - \u2191\u230ax\u230b - (x - \u2191\u230ax\u230b) = f x - x"}, {"line": "rw [sub_sub_sub_cancel_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_map_map_zero_lt : dist (f 0 + g 0) (f (g 0)) < 1 := by\n  rw [dist_comm]\n  rw [Real.dist_eq]\n  rw [abs_lt]\n  rw [lt_sub_iff_add_lt']\n  rw [sub_lt_iff_lt_add']\n  rw [\u2190 sub_eq_add_neg]\n  exact \u27e8f.lt_map_map_zero g, f.map_map_zero_lt g\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 dist (f 0 + g 0) (f (g 0)) < 1"}, {"line": "rw [dist_comm]", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 dist (f (g 0)) (f 0 + g 0) < 1"}, {"line": "rw [Real.dist_eq]", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 |f (g 0) - (f 0 + g 0)| < 1"}, {"line": "rw [abs_lt]", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 -1 < f (g 0) - (f 0 + g 0) \u2227 f (g 0) - (f 0 + g 0) < 1"}, {"line": "rw [lt_sub_iff_add_lt']", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 f 0 + g 0 + -1 < f (g 0) \u2227 f (g 0) - (f 0 + g 0) < 1"}, {"line": "rw [sub_lt_iff_lt_add']", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 f 0 + g 0 + -1 < f (g 0) \u2227 f (g 0) < f 0 + g 0 + 1"}, {"line": "rw [\u2190 sub_eq_add_neg]", "tactic_state": "f g : CircleDeg1Lift\n\u22a2 f 0 + g 0 - 1 < f (g 0) \u2227 f (g 0) < f 0 + g 0 + 1"}, {"line": "exact \u27e8f.lt_map_map_zero g, f.map_map_zero_lt g\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_le_of_map_le_add_int {x : \u211d} {m : \u2124} (h : f x \u2264 x + m) (n : \u2115) :\n    f^[n] x \u2264 x + n * m := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const (m : \u211d)) h n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nh : f x \u2264 x + \u2191m\nn : \u2115\n\u22a2 (\u21d1f)^[n] x \u2264 x + \u2191n * \u2191m"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_le_of_map_le f.monotone (monotone_id.add_const (m : \u211d)) h n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iterate_of_add_int_le_map {x : \u211d} {m : \u2124} (h : x + m \u2264 f x) (n : \u2115) :\n    x + n * m \u2264 f^[n] x := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const (m : \u211d)) f.monotone h n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nh : x + \u2191m \u2264 f x\nn : \u2115\n\u22a2 x + \u2191n * \u2191m \u2264 (\u21d1f)^[n] x"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).symm.iterate_le_of_map_le (monotone_id.add_const (m : \u211d)) f.monotone h n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_eq_of_map_eq_add_int {x : \u211d} {m : \u2124} (h : f x = x + m) (n : \u2115) :\n    f^[n] x = x + n * m := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nh : f x = x + \u2191m\nn : \u2115\n\u22a2 (\u21d1f)^[n] x = x + \u2191n * \u2191m"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using (f.commute_add_int m).iterate_eq_of_map_eq n h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_pos_le_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x \u2264 x + n * m \u2194 f x \u2264 x + m := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strictMono_id.add_const (m : \u211d)) hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nn : \u2115\nhn : 0 < n\n\u22a2 (\u21d1f)^[n] x \u2264 x + \u2191n * \u2191m \u2194 f x \u2264 x + \u2191m"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_le_iff_map_le f.monotone (strictMono_id.add_const (m : \u211d)) hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_pos_lt_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x < x + n * m \u2194 f x < x + m := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strictMono_id.add_const (m : \u211d)) hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nn : \u2115\nhn : 0 < n\n\u22a2 (\u21d1f)^[n] x < x + \u2191n * \u2191m \u2194 f x < x + \u2191m"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_lt_iff_map_lt f.monotone (strictMono_id.add_const (m : \u211d)) hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterate_pos_eq_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    f^[n] x = x + n * m \u2194 f x = x + m := by\n  simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strictMono_id.add_const (m : \u211d)) hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nn : \u2115\nhn : 0 < n\n\u22a2 (\u21d1f)^[n] x = x + \u2191n * \u2191m \u2194 f x = x + \u2191m"}, {"line": "simpa only [nsmul_eq_mul,add_right_iterate] using\n    (f.commute_add_int m).iterate_pos_eq_iff_map_eq f.monotone (strictMono_id.add_const (m : \u211d)) hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_iterate_pos_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    x + n * m \u2264 f^[n] x \u2194 x + m \u2264 f x := by\n  simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nn : \u2115\nhn : 0 < n\n\u22a2 x + \u2191n * \u2191m \u2264 (\u21d1f)^[n] x \u2194 x + \u2191m \u2264 f x"}, {"line": "simpa only [not_lt] using not_congr (f.iterate_pos_lt_iff hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_iterate_pos_iff {x : \u211d} {m : \u2124} {n : \u2115} (hn : 0 < n) :\n    x + n * m < f^[n] x \u2194 x + m < f x := by\n  simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx : \u211d\nm : \u2124\nn : \u2115\nhn : 0 < n\n\u22a2 x + \u2191n * \u2191m < (\u21d1f)^[n] x \u2194 x + \u2191m < f x"}, {"line": "simpa only [not_le] using not_congr (f.iterate_pos_le_iff hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem transnumAuxSeq_dist_lt (n : \u2115) :\n    dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n := by\n  have : 0 < (2 ^ (n + 1) : \u211d) := pow_pos zero_lt_two _\n  rw [div_div]\n  rw [\u2190 pow_succ']\n  rw [\u2190 abs_of_pos this]\n  calc\n    _ = dist ((f ^ 2 ^ n) 0 + (f ^ 2 ^ n) 0) ((f ^ 2 ^ n) ((f ^ 2 ^ n) 0)) / |2 ^ (n + 1)| := by\n      simp_rw [transnumAuxSeq, Real.dist_eq]\n      rw [\u2190 abs_div]\n      rw [sub_div]\n      rw [pow_succ]\n      rw [pow_succ']\n      rw [\u2190 two_mul]\n      rw [mul_div_mul_left _ _ (two_ne_zero' \u211d)]\n      rw [pow_mul]\n      rw [sq]\n      rw [mul_apply]\n    _ < _ := by gcongr; exact (f ^ 2 ^ n).dist_map_map_zero_lt (f ^ 2 ^ n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\n\u22a2 dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n"}, {"line": "have : 0 < (2 ^ (n + 1) : \u211d) := pow_pos zero_lt_two _", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\nthis : 0 < 2 ^ (n + 1)\n\u22a2 dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 / 2 ^ n"}, {"line": "rw [div_div]", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\nthis : 0 < 2 ^ (n + 1)\n\u22a2 dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / (2 * 2 ^ n)"}, {"line": "rw [\u2190 pow_succ']", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\nthis : 0 < 2 ^ (n + 1)\n\u22a2 dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / 2 ^ (n + 1)"}, {"line": "rw [\u2190 abs_of_pos this]", "tactic_state": "f : CircleDeg1Lift\nn : \u2115\nthis : 0 < 2 ^ (n + 1)\n\u22a2 dist (f.transnumAuxSeq n) (f.transnumAuxSeq (n + 1)) < 1 / |2 ^ (n + 1)|"}, {"line": "calc\n    _ = dist ((f ^ 2 ^ n) 0 + (f ^ 2 ^ n) 0) ((f ^ 2 ^ n) ((f ^ 2 ^ n) 0)) / |2 ^ (n + 1)| := by\n      simp_rw [transnumAuxSeq, Real.dist_eq]\n      rw [\u2190 abs_div]\n      rw [sub_div]\n      rw [pow_succ]\n      rw [pow_succ']\n      rw [\u2190 two_mul]\n      rw [mul_div_mul_left _ _ (two_ne_zero' \u211d)]\n      rw [pow_mul]\n      rw [sq]\n      rw [mul_apply]\n    _ < _ := by gcongr; exact (f ^ 2 ^ n).dist_map_map_zero_lt (f ^ 2 ^ n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_translation_number\u2080' :\n    Tendsto (fun n : \u2115 => (f ^ (n + 1) : CircleDeg1Lift) 0 / ((n : \u211d) + 1)) atTop (\ud835\udcdd <| \u03c4 f) := by\n  refine\n    tendsto_iff_dist_tendsto_zero.2 <|\n      squeeze_zero (fun _ => dist_nonneg) (fun n => ?_)\n        ((tendsto_const_div_atTop_nhds_zero_nat 1).comp (tendsto_add_atTop_nat 1))\n  dsimp\n  have : (0 : \u211d) < n + 1 := n.cast_add_one_pos\n  rw [Real.dist_eq]\n  rw [div_sub' (ne_of_gt this)]\n  rw [abs_div]\n  rw [\u2190 Real.dist_eq]\n  rw [abs_of_pos this]\n  rw [Nat.cast_add_one]\n  rw [div_le_div_iff_of_pos_right this]\n  rw [\u2190 Nat.cast_add_one]\n  apply dist_pow_map_zero_mul_translationNumber_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\n\u22a2 Tendsto (fun n => (f ^ (n + 1)) 0 / (\u2191n + 1)) atTop (nhds sorry)"}, {"line": "refine\n    tendsto_iff_dist_tendsto_zero.2 <|\n      squeeze_zero (fun _ => dist_nonneg) (fun n => ?_)\n        ((tendsto_const_div_atTop_nhds_zero_nat 1).comp (tendsto_add_atTop_nat 1))", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\n\u22a2 dist ((f ^ (n + 1)) 0 / (\u2191n + 1)) sorry \u2264 ((fun n => 1 / \u2191n) \u2218 fun a => a + 1) n"}, {"line": "dsimp", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\n\u22a2 dist ((f ^ (n + 1)) 0 / (\u2191n + 1)) (sorry ()) \u2264 1 / \u2191(n + 1)"}, {"line": "have : (0 : \u211d) < n + 1 := n.cast_add_one_pos", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0 / (\u2191n + 1)) (sorry ()) \u2264 1 / \u2191(n + 1)"}, {"line": "rw [Real.dist_eq]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 |(f ^ (n + 1)) 0 / (\u2191n + 1) - sorry ()| \u2264 1 / \u2191(n + 1)"}, {"line": "rw [div_sub' (ne_of_gt this)]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 |((f ^ (n + 1)) 0 - (\u2191n + 1) * sorry ()) / (\u2191n + 1)| \u2264 1 / \u2191(n + 1)"}, {"line": "rw [abs_div]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 |(f ^ (n + 1)) 0 - (\u2191n + 1) * sorry ()| / |\u2191n + 1| \u2264 1 / \u2191(n + 1)"}, {"line": "rw [\u2190 Real.dist_eq]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0) ((\u2191n + 1) * sorry ()) / |\u2191n + 1| \u2264 1 / \u2191(n + 1)"}, {"line": "rw [abs_of_pos this]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0) ((\u2191n + 1) * sorry ()) / (\u2191n + 1) \u2264 1 / \u2191(n + 1)"}, {"line": "rw [Nat.cast_add_one]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0) ((\u2191n + 1) * sorry ()) / (\u2191n + 1) \u2264 1 / (\u2191n + 1)"}, {"line": "rw [div_le_div_iff_of_pos_right this]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0) ((\u2191n + 1) * sorry ()) \u2264 1"}, {"line": "rw [\u2190 Nat.cast_add_one]", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nn : \u2115\nthis : 0 < \u2191n + 1\n\u22a2 dist ((f ^ (n + 1)) 0) (\u2191(n + 1) * sorry ()) \u2264 1"}, {"line": "apply dist_pow_map_zero_mul_translationNumber_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_eq_add_translationNumber (hf : Continuous f) : \u2203 x, f x = x + \u03c4 f := by\n  obtain \u27e8a, ha\u27e9 : \u2203 x, f x \u2264 x + \u03c4 f := by\n    by_contra! H\n    exact lt_irrefl _ (f.lt_translationNumber_of_forall_add_lt hf H)\n  obtain \u27e8b, hb\u27e9 : \u2203 x, x + \u03c4 f \u2264 f x := by\n    by_contra! H\n    exact lt_irrefl _ (f.translationNumber_lt_of_forall_lt_add hf H)\n  exact intermediate_value_univ\u2082 hf (continuous_id.add continuous_const) ha hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\n\u22a2 \u2203 x, f x = x + sorry"}, {"line": "obtain \u27e8a, ha\u27e9 : \u2203 x, f x \u2264 x + \u03c4 f := by\n    by_contra! H\n    exact lt_irrefl _ (f.lt_translationNumber_of_forall_add_lt hf H)", "tactic_state": "case intro\nf : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\na : \u211d\nha : f a \u2264 a + sorry\n\u22a2 \u2203 x, f x = x + sorry"}, {"line": "obtain \u27e8b, hb\u27e9 : \u2203 x, x + \u03c4 f \u2264 f x := by\n    by_contra! H\n    exact lt_irrefl _ (f.translationNumber_lt_of_forall_lt_add hf H)", "tactic_state": "case intro.intro\nf : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\na : \u211d\nha : f a \u2264 a + sorry\nb : \u211d\nhb : b + sorry \u2264 f b\n\u22a2 \u2203 x, f x = x + sorry"}, {"line": "exact intermediate_value_univ\u2082 hf (continuous_id.add continuous_const) ha hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem translationNumber_eq_int_iff (hf : Continuous f) {m : \u2124} :\n    \u03c4 f = m \u2194 \u2203 x : \u211d, f x = x + m := by\n  constructor\n  \u00b7 intro h\n    simp only [\u2190 h]\n    exact f.exists_eq_add_translationNumber hf\n  \u00b7 rintro \u27e8x, hx\u27e9\n    exact f.translationNumber_of_eq_add_int hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\nm : \u2124\n\u22a2 sorry = m \u2194 \u2203 x, f x = x + \u2191m"}, {"line": "constructor", "tactic_state": "case mp\nf : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\nm : \u2124\n\u22a2 sorry = m \u2192 \u2203 x, f x = x + \u2191m\n---\ncase mpr\nf : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\nm : \u2124\n\u22a2 (\u2203 x, f x = x + \u2191m) \u2192 sorry = m"}, {"line": "\u00b7 intro h\n    simp only [\u2190 h]\n    exact f.exists_eq_add_translationNumber hf", "tactic_state": "case mpr\nf : CircleDeg1Lift\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nhf : Continuous \u21d1f\nm : \u2124\n\u22a2 (\u2203 x, f x = x + \u2191m) \u2192 sorry = m"}, {"line": "\u00b7 rintro \u27e8x, hx\u27e9\n    exact f.translationNumber_of_eq_add_int hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem semiconj_of_isUnit_of_translationNumber_eq {f\u2081 f\u2082 : CircleDeg1Lift} (h\u2081 : IsUnit f\u2081)\n    (h\u2082 : IsUnit f\u2082) (h : \u03c4 f\u2081 = \u03c4 f\u2082) : \u2203 F : CircleDeg1Lift, Semiconj F f\u2081 f\u2082 := by\n  rcases h\u2081, h\u2082 with \u27e8\u27e8f\u2081, rfl\u27e9, \u27e8f\u2082, rfl\u27e9\u27e9\n  exact units_semiconj_of_translationNumber_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Circle/RotationNumber/TranslationNumber.lean", "context": {"open": ["Filter Set Int Topology", "Function hiding Commute"], "variables": ["(f g : CircleDeg1Lift)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\n\u03c4 : x\u271d\nf\u2081 f\u2082 : CircleDeg1Lift\nh\u2081 : IsUnit f\u2081\nh\u2082 : IsUnit f\u2082\nh : sorry = sorry\n\u22a2 \u2203 F, Semiconj \u21d1F \u21d1f\u2081 \u21d1f\u2082"}, {"line": "rcases h\u2081, h\u2082 with \u27e8\u27e8f\u2081, rfl\u27e9, \u27e8f\u2082, rfl\u27e9\u27e9", "tactic_state": "case intro.intro\nx\u271d : Sort u_1\n\u03c4 : x\u271d\nf\u2081 f\u2082 : CircleDeg1Lift\u02e3\nh : sorry = sorry\n\u22a2 \u2203 F, Semiconj \u21d1F \u21d1\u2191f\u2081 \u21d1\u2191f\u2082"}, {"line": "exact units_semiconj_of_translationNumber_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_extremePoints_measure_univ_eq [IsFiniteMeasure \u03bc] (h\u03bc : Ergodic f \u03bc) :\n    \u03bc \u2208 extremePoints \u211d\u22650\u221e {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ} := by\n  rw [mem_extremePoints_iff_left]\n  refine \u27e8\u27e8h\u03bc.toMeasurePreserving, rfl\u27e9, ?_\u27e9\n  rintro \u03bd\u2081 \u27e8hf\u03bd\u2081, h\u03bd\u2081\u03bc\u27e9 \u03bd\u2082 \u27e8hf\u03bd\u2082, h\u03bd\u2082\u03bc\u27e9 \u27e8a, b, ha, hb, hab, rfl\u27e9\n  have : IsFiniteMeasure \u03bd\u2081 := \u27e8by rw [h\u03bd\u2081\u03bc]; apply measure_lt_top\u27e9\n  apply h\u03bc.eq_of_absolutelyContinuous_measure_univ_eq hf\u03bd\u2081 (.add_right _ _) h\u03bd\u2081\u03bc\n  apply absolutelyContinuous_smul ha.ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Extreme.lean", "context": {"open": ["Filter Set Function MeasureTheory Measure ProbabilityTheory", "scoped NNReal ENNReal Topology"], "variables": ["{X : Type*} {m : MeasurableSpace X} {\u03bc \u03bd : Measure X} {f : X \u2192 X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nm : MeasurableSpace X\n\u03bc : Measure X\nf : X \u2192 X\ninst\u271d : IsFiniteMeasure \u03bc\nh\u03bc : Ergodic f \u03bc\n\u22a2 \u03bc \u2208 extremePoints ENNReal {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ}"}, {"line": "rw [mem_extremePoints_iff_left]", "tactic_state": "X : Type u_1\nm : MeasurableSpace X\n\u03bc : Measure X\nf : X \u2192 X\ninst\u271d : IsFiniteMeasure \u03bc\nh\u03bc : Ergodic f \u03bc\n\u22a2 \u03bc \u2208 {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ} \u2227\n    \u2200 x\u2081 \u2208 {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ},\n      \u2200 x\u2082 \u2208 {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ}, \u03bc \u2208 openSegment ENNReal x\u2081 x\u2082 \u2192 x\u2081 = \u03bc"}, {"line": "refine \u27e8\u27e8h\u03bc.toMeasurePreserving, rfl\u27e9, ?_\u27e9", "tactic_state": "X : Type u_1\nm : MeasurableSpace X\n\u03bc : Measure X\nf : X \u2192 X\ninst\u271d : IsFiniteMeasure \u03bc\nh\u03bc : Ergodic f \u03bc\n\u22a2 \u2200 x\u2081 \u2208 {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ},\n    \u2200 x\u2082 \u2208 {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 \u03bd univ = \u03bc univ}, \u03bc \u2208 openSegment ENNReal x\u2081 x\u2082 \u2192 x\u2081 = \u03bc"}, {"line": "rintro \u03bd\u2081 \u27e8hf\u03bd\u2081, h\u03bd\u2081\u03bc\u27e9 \u03bd\u2082 \u27e8hf\u03bd\u2082, h\u03bd\u2082\u03bc\u27e9 \u27e8a, b, ha, hb, hab, rfl\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nm : MeasurableSpace X\nf : X \u2192 X\n\u03bd\u2081 : Measure X\nhf\u03bd\u2081 : MeasurePreserving f \u03bd\u2081 \u03bd\u2081\n\u03bd\u2082 : Measure X\nhf\u03bd\u2082 : MeasurePreserving f \u03bd\u2082 \u03bd\u2082\na b : ENNReal\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ninst\u271d : IsFiniteMeasure (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bc : Ergodic f (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bd\u2081\u03bc : \u03bd\u2081 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\nh\u03bd\u2082\u03bc : \u03bd\u2082 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\n\u22a2 \u03bd\u2081 = a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082"}, {"line": "have : IsFiniteMeasure \u03bd\u2081 := \u27e8by rw [h\u03bd\u2081\u03bc]; apply measure_lt_top\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro\nX : Type u_1\nm : MeasurableSpace X\nf : X \u2192 X\n\u03bd\u2081 : Measure X\nhf\u03bd\u2081 : MeasurePreserving f \u03bd\u2081 \u03bd\u2081\n\u03bd\u2082 : Measure X\nhf\u03bd\u2082 : MeasurePreserving f \u03bd\u2082 \u03bd\u2082\na b : ENNReal\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ninst\u271d : IsFiniteMeasure (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bc : Ergodic f (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bd\u2081\u03bc : \u03bd\u2081 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\nh\u03bd\u2082\u03bc : \u03bd\u2082 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\nthis : IsFiniteMeasure \u03bd\u2081\n\u22a2 \u03bd\u2081 = a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082"}, {"line": "apply h\u03bc.eq_of_absolutelyContinuous_measure_univ_eq hf\u03bd\u2081 (.add_right _ _) h\u03bd\u2081\u03bc", "tactic_state": "X : Type u_1\nm : MeasurableSpace X\nf : X \u2192 X\n\u03bd\u2081 : Measure X\nhf\u03bd\u2081 : MeasurePreserving f \u03bd\u2081 \u03bd\u2081\n\u03bd\u2082 : Measure X\nhf\u03bd\u2082 : MeasurePreserving f \u03bd\u2082 \u03bd\u2082\na b : ENNReal\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\ninst\u271d : IsFiniteMeasure (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bc : Ergodic f (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082)\nh\u03bd\u2081\u03bc : \u03bd\u2081 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\nh\u03bd\u2082\u03bc : \u03bd\u2082 univ = (a \u2022 \u03bd\u2081 + b \u2022 \u03bd\u2082) univ\nthis : IsFiniteMeasure \u03bd\u2081\n\u22a2 \u03bd\u2081.AbsolutelyContinuous (a \u2022 \u03bd\u2081)"}, {"line": "apply absolutelyContinuous_smul ha.ne'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_extremePoints [IsProbabilityMeasure \u03bc] (h\u03bc : Ergodic f \u03bc) :\n    \u03bc \u2208 extremePoints \u211d\u22650\u221e {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 IsProbabilityMeasure \u03bd} := by\n  simpa only [isProbabilityMeasure_iff,measure_univ] using h\u03bc.mem_extremePoints_measure_univ_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Extreme.lean", "context": {"open": ["Filter Set Function MeasureTheory Measure ProbabilityTheory", "scoped NNReal ENNReal Topology"], "variables": ["{X : Type*} {m : MeasurableSpace X} {\u03bc \u03bd : Measure X} {f : X \u2192 X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nm : MeasurableSpace X\n\u03bc : Measure X\nf : X \u2192 X\ninst\u271d : IsProbabilityMeasure \u03bc\nh\u03bc : Ergodic f \u03bc\n\u22a2 \u03bc \u2208 extremePoints ENNReal {\u03bd | MeasurePreserving f \u03bd \u03bd \u2227 IsProbabilityMeasure \u03bd}"}, {"line": "simpa only [isProbabilityMeasure_iff,measure_univ] using h\u03bc.mem_extremePoints_measure_univ_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_mem_imp_frequently_image_mem (hf : Conservative f \u03bc) (hs : NullMeasurableSet s \u03bc) :\n    \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 \u2203\u1da0 n in atTop, f^[n] x \u2208 s := by\n  simp only [frequently_atTop]\n  simp only [@forall_swap (_ \u2208 s)]\n  simp only [ae_all_iff]\n  intro n\n  filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Conservative.lean", "context": {"open": ["Set Filter MeasureTheory Finset Function TopologicalSpace Topology", "Measure"], "variables": ["{\u03b1 : Type*} [MeasurableSpace \u03b1] {f : \u03b1 \u2192 \u03b1} {s : Set \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 \u2203\u1da0 (n : \u2115) in atTop, f^[n] x \u2208 s"}, {"line": "simp only [frequently_atTop]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 s \u2192 \u2200 (a : \u2115), \u2203 b \u2265 a, f^[b] x \u2208 s"}, {"line": "simp only [@forall_swap (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\n\u22a2 \u2200\u1d50 (x : \u03b1) \u2202\u03bc, \u2200 (y : \u2115), x \u2208 s \u2192 \u2203 b \u2265 y, f^[b] x \u2208 s"}, {"line": "simp only [ae_all_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\n\u22a2 \u2200 (i : \u2115), \u2200\u1d50 (a : \u03b1) \u2202\u03bc, a \u2208 s \u2192 \u2203 b \u2265 i, f^[b] a \u2208 s"}, {"line": "intro n", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\nn : \u2115\n\u22a2 \u2200\u1d50 (a : \u03b1) \u2202\u03bc, a \u2208 s \u2192 \u2203 b \u2265 n, f^[b] a \u2208 s"}, {"line": "filter_upwards [measure_zero_iff_ae_nmem.1 (hf.measure_mem_forall_ge_image_not_mem_eq_zero hs n)]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\ns : Set \u03b1\n\u03bc : Measure \u03b1\nhf : Conservative f \u03bc\nhs : NullMeasurableSet s \u03bc\nn : \u2115\n\u22a2 \u2200 (a : \u03b1), \u00ac(a \u2208 s \u2227 \u2200 m \u2265 n, f^[m] a \u2209 s) \u2192 a \u2208 s \u2192 \u2203 b \u2265 n, f^[b] a \u2208 s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_empty_or_univ (hf : PreErgodic f \u03bc) (hs : MeasurableSet s) (hfs : f \u207b\u00b9' s = s) :\n    s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ := by\n  simpa only [eventuallyConst_set'] using hf.aeconst_set hs hfs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Ergodic.lean", "context": {"open": ["Set Function Filter MeasureTheory MeasureTheory.Measure", "ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}", "{f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : PreErgodic f \u03bc\nhs : MeasurableSet s\nhfs : f \u207b\u00b9' s = s\n\u22a2 s =\u1da0[ae \u03bc] \u2205 \u2228 s =\u1da0[ae \u03bc] univ"}, {"line": "simpa only [eventuallyConst_set'] using hf.aeconst_set hs hfs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measure_self_or_compl_eq_zero (hf : PreErgodic f \u03bc) (hs : MeasurableSet s)\n    (hs' : f \u207b\u00b9' s = s) : \u03bc s = 0 \u2228 \u03bc s\u1d9c = 0 := by\n  simpa using hf.ae_empty_or_univ hs hs'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Ergodic.lean", "context": {"open": ["Set Function Filter MeasureTheory MeasureTheory.Measure", "ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}", "{f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : PreErgodic f \u03bc\nhs : MeasurableSet s\nhs' : f \u207b\u00b9' s = s\n\u22a2 \u03bc s = 0 \u2228 \u03bc s\u1d9c = 0"}, {"line": "simpa using hf.ae_empty_or_univ hs hs'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_measure (f : \u03b1 \u2192 \u03b1) : @PreErgodic \u03b1 m f 0 where\n  aeconst_set _ _ _ := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Ergodic.lean", "context": {"open": ["Set Function Filter MeasureTheory MeasureTheory.Measure", "ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}", "{f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\nf : \u03b1 \u2192 \u03b1\nx\u271d\u00b2 : Set \u03b1\nx\u271d\u00b9 : MeasurableSet x\u271d\u00b2\nx\u271d : f \u207b\u00b9' x\u271d\u00b2 = x\u271d\u00b2\n\u22a2 EventuallyConst x\u271d\u00b2 (ae 0)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_empty_or_univ_of_preimage_ae_le' (hf : Ergodic f \u03bc) (hs : NullMeasurableSet s \u03bc)\n    (hs' : f \u207b\u00b9' s \u2264\u1d50[\u03bc] s) (h_fin : \u03bc s \u2260 \u221e) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ := by\n  refine hf.quasiErgodic.ae_empty_or_univ\u2080 hs ?_\n  refine ae_eq_of_ae_subset_of_measure_ge hs' (hf.measure_preimage hs).ge ?_ h_fin\n  exact hs.preimage hf.quasiMeasurePreserving\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Ergodic.lean", "context": {"open": ["Set Function Filter MeasureTheory MeasureTheory.Measure", "ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}", "{f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1}", "{\u03b2 : Type*} {m' : MeasurableSpace \u03b2} {\u03bc' : Measure \u03b2} {g : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : Ergodic f \u03bc\nhs : NullMeasurableSet s \u03bc\nhs' : f \u207b\u00b9' s \u2264\u1da0[ae \u03bc] s\nh_fin : \u03bc s \u2260 \u22a4\n\u22a2 s =\u1da0[ae \u03bc] \u2205 \u2228 s =\u1da0[ae \u03bc] univ"}, {"line": "refine hf.quasiErgodic.ae_empty_or_univ\u2080 hs ?_", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : Ergodic f \u03bc\nhs : NullMeasurableSet s \u03bc\nhs' : f \u207b\u00b9' s \u2264\u1da0[ae \u03bc] s\nh_fin : \u03bc s \u2260 \u22a4\n\u22a2 f \u207b\u00b9' s =\u1da0[ae \u03bc] s"}, {"line": "refine ae_eq_of_ae_subset_of_measure_ge hs' (hf.measure_preimage hs).ge ?_ h_fin", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : Ergodic f \u03bc\nhs : NullMeasurableSet s \u03bc\nhs' : f \u207b\u00b9' s \u2264\u1da0[ae \u03bc] s\nh_fin : \u03bc s \u2260 \u22a4\n\u22a2 NullMeasurableSet (f \u207b\u00b9' s) \u03bc"}, {"line": "exact hs.preimage hf.quasiMeasurePreserving", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ae_empty_or_univ_of_image_ae_le' (hf : Ergodic f \u03bc) (hs : NullMeasurableSet s \u03bc)\n    (hs' : f '' s \u2264\u1d50[\u03bc] s) (h_fin : \u03bc s \u2260 \u221e) : s =\u1d50[\u03bc] (\u2205 : Set \u03b1) \u2228 s =\u1d50[\u03bc] univ := by\n  replace hs' : s \u2264\u1d50[\u03bc] f \u207b\u00b9' s :=\n    (HasSubset.Subset.eventuallyLE (subset_preimage_image f s)).trans\n      (hf.quasiMeasurePreserving.preimage_mono_ae hs')\n  exact ae_empty_or_univ_of_ae_le_preimage' hf hs hs' h_fin\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/Ergodic.lean", "context": {"open": ["Set Function Filter MeasureTheory MeasureTheory.Measure", "ENNReal"], "variables": ["{\u03b1 : Type*} {m : MeasurableSpace \u03b1} {s : Set \u03b1}", "{f : \u03b1 \u2192 \u03b1} {\u03bc : Measure \u03b1}", "{\u03b2 : Type*} {m' : MeasurableSpace \u03b2} {\u03bc' : Measure \u03b2} {g : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : Ergodic f \u03bc\nhs : NullMeasurableSet s \u03bc\nhs' : f '' s \u2264\u1da0[ae \u03bc] s\nh_fin : \u03bc s \u2260 \u22a4\n\u22a2 s =\u1da0[ae \u03bc] \u2205 \u2228 s =\u1da0[ae \u03bc] univ"}, {"line": "replace hs' : s \u2264\u1d50[\u03bc] f \u207b\u00b9' s :=\n    (HasSubset.Subset.eventuallyLE (subset_preimage_image f s)).trans\n      (hf.quasiMeasurePreserving.preimage_mono_ae hs')", "tactic_state": "\u03b1 : Type u_1\nm : MeasurableSpace \u03b1\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b1\n\u03bc : Measure \u03b1\nhf : Ergodic f \u03bc\nhs : NullMeasurableSet s \u03bc\nh_fin : \u03bc s \u2260 \u22a4\nhs' : s \u2264\u1da0[ae \u03bc] f \u207b\u00b9' s\n\u22a2 s =\u1da0[ae \u03bc] \u2205 \u2228 s =\u1da0[ae \u03bc] univ"}, {"line": "exact ae_empty_or_univ_of_ae_le_preimage' hf hs hs' h_fin", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrict_image_emb {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) (h\u2082 : MeasurableEmbedding f)\n    (s : Set \u03b1) : MeasurePreserving f (\u03bca.restrict s) (\u03bcb.restrict (f '' s)) := by\n  simpa only [Set.preimage_image_eq _ h\u2082.injective] using hf.restrict_preimage_emb h\u2082 (f '' s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "context": {"open": ["MeasureTheory.Measure Function Set", "scoped ENNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]", "{\u03bca : Measure \u03b1} {\u03bcb : Measure \u03b2} {\u03bcc : Measure \u03b3} {\u03bcd : Measure \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.1702\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b3 : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bca : sorry\n\u03bcb : sorry\n\u03bcc : sorry\n\u03bcd : sorry\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nx\u271d : Sort u_5\nMeasurePreserving : x\u271d\nf : \u03b1 \u2192 \u03b2\nhf : sorry\nh\u2082 : MeasurableEmbedding f\ns : Set \u03b1\n\u22a2 sorry"}, {"line": "simpa only [Set.preimage_image_eq _ h\u2082.injective] using hf.restrict_preimage_emb h\u2082 (f '' s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem measureReal_preimage {f : \u03b1 \u2192 \u03b2} (hf : MeasurePreserving f \u03bca \u03bcb) {s : Set \u03b2}\n    (hs : NullMeasurableSet s \u03bcb) : \u03bca.real (f \u207b\u00b9' s) = \u03bcb.real s := by\n  simp [measureReal_def, measure_preimage hf hs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/Ergodic/MeasurePreserving.lean", "context": {"open": ["MeasureTheory.Measure Function Set", "scoped ENNReal"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [MeasurableSpace \u03b1] [MeasurableSpace \u03b2] [MeasurableSpace \u03b3]", "{\u03bca : Measure \u03b1} {\u03bcb : Measure \u03b2} {\u03bcc : Measure \u03b3} {\u03bcd : Measure \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Measure : ?m.1702\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b3 : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bca : sorry\n\u03bcb : sorry\n\u03bcc : sorry\n\u03bcd : sorry\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nx\u271d\u00b9 : Sort u_5\nMeasurePreserving : x\u271d\u00b9\nx\u271d : Sort u_6\nNullMeasurableSet : x\u271d\nf : \u03b1 \u2192 \u03b2\nhf : sorry\ns : Set \u03b2\nhs : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [measureReal_def, measure_preimage hf hs]", "tactic_state": "Measure : ?m.1702\n\u03b1\u271d : Type u_1\n\u03b2\u271d : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u2074 : MeasurableSpace \u03b1\u271d\ninst\u271d\u00b3 : MeasurableSpace \u03b2\u271d\ninst\u271d\u00b2 : MeasurableSpace \u03b3\n\u03bca : sorry\n\u03bcb : sorry\n\u03bcc : sorry\n\u03bcd : sorry\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : MeasurableSpace \u03b1\ninst\u271d : MeasurableSpace \u03b2\nx\u271d\u00b9 : Sort u_5\nMeasurePreserving : x\u271d\u00b9\nx\u271d : Sort u_6\nNullMeasurableSet : x\u271d\nf : \u03b1 \u2192 \u03b2\nhf : sorry\ns : Set \u03b2\nhs : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem Commute.left_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn f (fixedPoints <| f \u2218 g) (fixedPoints <| f \u2218 g) := by\n  simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/FixedPoints/Basic.lean", "context": {"open": ["Equiv", "Function (Commute)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {f fa g : \u03b1 \u2192 \u03b1} {x : \u03b1} {fb : \u03b2 \u2192 \u03b2} {e : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf g : \u03b1 \u2192 \u03b1\nx\u271d : Sort u_1\nfixedPoints : x\u271d\nh : Function.Commute f g\n\u22a2 Set.BijOn f sorry sorry"}, {"line": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp g f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Commute.right_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn g (fixedPoints <| f \u2218 g) (fixedPoints <| f \u2218 g) := by\n  simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/FixedPoints/Basic.lean", "context": {"open": ["Equiv", "Function (Commute)"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {f fa g : \u03b1 \u2192 \u03b1} {x : \u03b1} {fb : \u03b2 \u2192 \u03b2} {e : Perm \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nf g : \u03b1 \u2192 \u03b1\nx\u271d : Sort u_1\nfixedPoints : x\u271d\nh : Function.Commute f g\n\u22a2 Set.BijOn g sorry sorry"}, {"line": "simpa only [h.comp_eq] using bijOn_fixedPoints_comp f g", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem minimalPeriod_iterate_eq_div_gcd_aux (h : 0 < gcd (minimalPeriod f x) n) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n := by\n  apply Nat.dvd_antisymm\n  \u00b7 apply IsPeriodicPt.minimalPeriod_dvd\n    rw [IsPeriodicPt]\n    rw [IsFixedPt]\n    rw [\u2190 iterate_mul]\n    rw [\u2190 Nat.mul_div_assoc _ (gcd_dvd_left _ _)]\n    rw [mul_comm]\n    rw [Nat.mul_div_assoc _ (gcd_dvd_right _ _)]\n    rw [mul_comm]\n    rw [iterate_mul]\n    exact (isPeriodicPt_minimalPeriod f x).iterate _\n  \u00b7 apply Coprime.dvd_of_dvd_mul_right (coprime_div_gcd_div_gcd h)\n    apply Nat.dvd_of_mul_dvd_mul_right h\n    rw [Nat.div_mul_cancel (gcd_dvd_left _ _)]\n    rw [mul_assoc]\n    rw [Nat.div_mul_cancel (gcd_dvd_right _ _)]\n    rw [mul_comm]\n    apply IsPeriodicPt.minimalPeriod_dvd\n    rw [IsPeriodicPt]\n    rw [IsFixedPt]\n    rw [iterate_mul]\n    exact isPeriodicPt_minimalPeriod _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/PeriodicPts/Defs.lean", "context": {"open": ["Set", "Function (Commute)", "scoped Classical in", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {f fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {x y : \u03b1} {m n : \u2115}", "(f)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx\u271d : Sort u_3\nminimalPeriod : x\u271d\nh : 0 < gcd sorry n\n\u22a2 sorry = sorry / sorry.gcd n"}, {"line": "apply Nat.dvd_antisymm", "tactic_state": "case a\nn : \u2115\nx\u271d : Sort u_3\nminimalPeriod : x\u271d\nh : 0 < gcd sorry n\n\u22a2 sorry \u2223 sorry / sorry.gcd n\n---\ncase a\nn : \u2115\nx\u271d : Sort u_3\nminimalPeriod : x\u271d\nh : 0 < gcd sorry n\n\u22a2 sorry / sorry.gcd n \u2223 sorry"}, {"line": "\u00b7 apply IsPeriodicPt.minimalPeriod_dvd\n    rw [IsPeriodicPt]\n    rw [IsFixedPt]\n    rw [\u2190 iterate_mul]\n    rw [\u2190 Nat.mul_div_assoc _ (gcd_dvd_left _ _)]\n    rw [mul_comm]\n    rw [Nat.mul_div_assoc _ (gcd_dvd_right _ _)]\n    rw [mul_comm]\n    rw [iterate_mul]\n    exact (isPeriodicPt_minimalPeriod f x).iterate _", "tactic_state": "case a\nn : \u2115\nx\u271d : Sort u_3\nminimalPeriod : x\u271d\nh : 0 < gcd sorry n\n\u22a2 sorry / sorry.gcd n \u2223 sorry"}, {"line": "\u00b7 apply Coprime.dvd_of_dvd_mul_right (coprime_div_gcd_div_gcd h)\n    apply Nat.dvd_of_mul_dvd_mul_right h\n    rw [Nat.div_mul_cancel (gcd_dvd_left _ _)]\n    rw [mul_assoc]\n    rw [Nat.div_mul_cancel (gcd_dvd_right _ _)]\n    rw [mul_comm]\n    apply IsPeriodicPt.minimalPeriod_dvd\n    rw [IsPeriodicPt]\n    rw [IsFixedPt]\n    rw [iterate_mul]\n    exact isPeriodicPt_minimalPeriod _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPeriodicPt_prodMap (x : \u03b1 \u00d7 \u03b2) :\n    IsPeriodicPt (Prod.map f g) n x \u2194 IsPeriodicPt f n x.1 \u2227 IsPeriodicPt g n x.2 := by\n  simp [IsPeriodicPt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/PeriodicPts/Defs.lean", "context": {"open": ["Set", "Function (Commute)", "scoped Classical in", "Nat"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {f fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {x y : \u03b1} {m n : \u2115}", "(f)", "{f}", "{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b2} {x : \u03b1 \u00d7 \u03b2} {a : \u03b1} {b : \u03b2} {m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nx\u271d : Sort u_5\nIsPeriodicPt : x\u271d\nx : \u03b1 \u00d7 \u03b2\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [IsPeriodicPt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isPeriodicPt_smul_iff {m : M} {a : \u03b1} {n : \u2115} :\n    IsPeriodicPt (m \u2022 \u00b7) n a \u2194 m ^ n \u2022 a = a := by\n  rw [\u2190 smul_iterate_apply]\n  rw [IsPeriodicPt]\n  rw [IsFixedPt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/PeriodicPts/Defs.lean", "context": {"open": ["Set", "Function (Commute)", "scoped Classical in", "Nat", "Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {f fa : \u03b1 \u2192 \u03b1} {fb : \u03b2 \u2192 \u03b2} {x y : \u03b1} {m n : \u2115}", "(f)", "{f}", "{\u03b1 \u03b2 : Type*} {f : \u03b1 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b2} {x : \u03b1 \u00d7 \u03b2} {a : \u03b1} {b : \u03b2} {m n : \u2115}", "{\u03b1 : Type v}", "{G : Type u} [Group G] [MulAction G \u03b1]", "{M : Type u} [Monoid M] [MulAction M \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type v\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulAction M \u03b1\nm : M\na : \u03b1\nn : \u2115\n\u22a2 IsPeriodicPt (fun x => m \u2022 x) n a \u2194 m ^ n \u2022 a = a"}, {"line": "rw [\u2190 smul_iterate_apply]", "tactic_state": "\u03b1 : Type v\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulAction M \u03b1\nm : M\na : \u03b1\nn : \u2115\n\u22a2 IsPeriodicPt (fun x => m \u2022 x) n a \u2194 (fun x => m \u2022 x)^[n] a = a"}, {"line": "rw [IsPeriodicPt]", "tactic_state": "\u03b1 : Type v\nM : Type u\ninst\u271d\u00b9 : Monoid M\ninst\u271d : MulAction M \u03b1\nm : M\na : \u03b1\nn : \u2115\n\u22a2 IsFixedPt (fun x => m \u2022 x)^[n] a \u2194 (fun x => m \u2022 x)^[n] a = a"}, {"line": "rw [IsFixedPt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dynEntourage_eq_inter_Ico (T : X \u2192 X) (U : Set (X \u00d7 X)) (n : \u2115) :\n    dynEntourage T U n = \u22c2 k : Ico 0 n, (map T T)^[k] \u207b\u00b9' U := by\n  simp [dynEntourage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/TopologicalEntropy/DynamicalEntourage.lean", "context": {"open": ["Prod Set UniformSpace", "scoped Topology Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\nn : \u2115\n\u22a2 sorry = \u22c2 k, (map T T)^[\u2191k] \u207b\u00b9' U"}, {"line": "simp [dynEntourage]", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\nn : \u2115\n\u22a2 sorry () = \u22c2 i, \u22c2 (_ : i < n), map T^[i] T^[i] \u207b\u00b9' U"}]}
{"declaration": "lemma mem_dynEntourage {T : X \u2192 X} {U : Set (X \u00d7 X)} {n : \u2115} {x y : X} :\n    (x, y) \u2208 dynEntourage T U n \u2194 \u2200 k < n, (T^[k] x, T^[k] y) \u2208 U := by\n  simp [dynEntourage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/TopologicalEntropy/DynamicalEntourage.lean", "context": {"open": ["Prod Set UniformSpace", "scoped Topology Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\nn : \u2115\nx y : X\n\u22a2 (x, y) \u2208 sorry \u2194 \u2200 k < n, (T^[k] x, T^[k] y) \u2208 U"}, {"line": "simp [dynEntourage]", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\nn : \u2115\nx y : X\n\u22a2 (x, y) \u2208 sorry () \u2194 \u2200 k < n, (T^[k] x, T^[k] y) \u2208 U"}]}
{"declaration": "lemma dynEntourage_zero {T : X \u2192 X} {U : Set (X \u00d7 X)} :\n    dynEntourage T U 0 = univ := by simp [dynEntourage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/TopologicalEntropy/DynamicalEntourage.lean", "context": {"open": ["Prod Set UniformSpace", "scoped Topology Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\n\u22a2 sorry = univ"}, {"line": "simp [dynEntourage]", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\n\u22a2 sorry () = univ"}]}
{"declaration": "lemma dynEntourage_one {T : X \u2192 X} {U : Set (X \u00d7 X)} :\n    dynEntourage T U 1 = U := by simp [dynEntourage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/TopologicalEntropy/DynamicalEntourage.lean", "context": {"open": ["Prod Set UniformSpace", "scoped Topology Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\n\u22a2 sorry = U"}, {"line": "simp [dynEntourage]", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nU : Set (X \u00d7 X)\n\u22a2 sorry () = U"}]}
{"declaration": "lemma dynEntourage_univ {T : X \u2192 X} {n : \u2115} :\n    dynEntourage T univ n = univ := by simp [dynEntourage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Dynamics/TopologicalEntropy/DynamicalEntourage.lean", "context": {"open": ["Prod Set UniformSpace", "scoped Topology Uniformity"], "variables": ["{X : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nn : \u2115\n\u22a2 sorry = univ"}, {"line": "simp [dynEntourage]", "tactic_state": "X : Type u_1\nx\u271d : Sort u_2\ndynEntourage : x\u271d\nT : X \u2192 X\nn : \u2115\n\u22a2 sorry () = univ"}]}
{"declaration": "theorem map_eq_of_algebraicClosure_eq_bot [Algebra E K] [IsScalarTower F E K]\n    (h : algebraicClosure E K = \u22a5) :\n    (algebraicClosure F E).map (IsScalarTower.toAlgHom F E K) = algebraicClosure F K := by\n  refine le_antisymm (map_le_of_algHom _) (fun x hx \u21a6 ?_)\n  obtain \u27e8y, rfl\u27e9 := mem_bot.1 <| h \u25b8 mem_algebraicClosure_iff'.2\n    (IsIntegral.tower_top <| mem_algebraicClosure_iff'.1 hx)\n  exact \u27e8y, (map_mem_algebraicClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AlgebraicClosure.lean", "context": {"open": ["Polynomial FiniteDimensional IntermediateField Field"], "variables": ["(F E : Type*) [Field F] [Field E] [Algebra F E]", "{K : Type*} [Field K] [Algebra F K]", "{F E}", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nE : Type u_2\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type u_3\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : algebraicClosure E K = \u22a5\n\u22a2 IntermediateField.map (IsScalarTower.toAlgHom F E K) (algebraicClosure F E) = algebraicClosure F K"}, {"line": "refine le_antisymm (map_le_of_algHom _) (fun x hx \u21a6 ?_)", "tactic_state": "F : Type u_1\nE : Type u_2\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type u_3\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : algebraicClosure E K = \u22a5\nx : K\nhx : x \u2208 algebraicClosure F K\n\u22a2 x \u2208 IntermediateField.map (IsScalarTower.toAlgHom F E K) (algebraicClosure F E)"}, {"line": "obtain \u27e8y, rfl\u27e9 := mem_bot.1 <| h \u25b8 mem_algebraicClosure_iff'.2\n    (IsIntegral.tower_top <| mem_algebraicClosure_iff'.1 hx)", "tactic_state": "case intro\nF : Type u_1\nE : Type u_2\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type u_3\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : algebraicClosure E K = \u22a5\ny : E\nhx : (algebraMap E K) y \u2208 algebraicClosure F K\n\u22a2 (algebraMap E K) y \u2208 IntermediateField.map (IsScalarTower.toAlgHom F E K) (algebraicClosure F E)"}, {"line": "exact \u27e8y, (map_mem_algebraicClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem char_dvd_card_solutions_of_fintype_sum_lt [Fintype \u03b9] {f : \u03b9 \u2192 MvPolynomial \u03c3 K}\n    (h : (\u2211 i, (f i).totalDegree) < Fintype.card \u03c3) :\n    p \u2223 Fintype.card { x : \u03c3 \u2192 K // \u2200 i, eval x (f i) = 0 } := by\n  simpa using char_dvd_card_solutions_of_sum_lt p h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/ChevalleyWarning.lean", "context": {"open": ["MvPolynomial", "Function hiding eval", "Finset FiniteField"], "variables": ["{K \u03c3 \u03b9 : Type*} [Fintype K] [Field K] [Fintype \u03c3] [DecidableEq \u03c3]", "[DecidableEq K] (p : \u2115) [CharP K p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\n\u03c3 : Type u_2\n\u03b9 : Type u_3\ninst\u271d\u2076 : Fintype K\ninst\u271d\u2075 : Field K\ninst\u271d\u2074 : Fintype \u03c3\ninst\u271d\u00b3 : DecidableEq \u03c3\ninst\u271d\u00b2 : DecidableEq K\np : \u2115\ninst\u271d\u00b9 : CharP K p\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 MvPolynomial \u03c3 K\nh : \u2211 i, (f i).totalDegree < Fintype.card \u03c3\n\u22a2 p \u2223 Fintype.card { x // \u2200 (i : \u03b9), (eval x) (f i) = 0 }"}, {"line": "simpa using char_dvd_card_solutions_of_sum_lt p h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pNilradical_le_nilradical {R : Type*} [CommSemiring R] {p : \u2115} :\n    pNilradical R p \u2264 nilradical R := by\n  by_cases hp : 1 < p\n  \u00b7 rw [pNilradical, if_pos hp]\n  simp_rw [pNilradical, if_neg hp, bot_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsPerfectClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\n\u22a2 pNilradical R p \u2264 nilradical R"}, {"line": "by_cases hp : 1 < p", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : 1 < p\n\u22a2 pNilradical R p \u2264 nilradical R\n---\ncase neg\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : \u00ac1 < p\n\u22a2 pNilradical R p \u2264 nilradical R"}, {"line": "\u00b7 rw [pNilradical, if_pos hp]", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : \u00ac1 < p\n\u22a2 pNilradical R p \u2264 nilradical R"}, {"line": "simp_rw [pNilradical, if_neg hp, bot_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pNilradical_eq_nilradical {R : Type*} [CommSemiring R] {p : \u2115} (hp : 1 < p) :\n    pNilradical R p = nilradical R := by rw [pNilradical, if_pos hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsPerfectClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : 1 < p\n\u22a2 pNilradical R p = nilradical R"}, {"line": "rw [pNilradical, if_pos hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pNilradical_eq_bot {R : Type*} [CommSemiring R] {p : \u2115} (hp : \u00ac 1 < p) :\n    pNilradical R p = \u22a5 := by rw [pNilradical, if_neg hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsPerfectClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommSemiring R\np : \u2115\nhp : \u00ac1 < p\n\u22a2 pNilradical R p = \u22a5"}, {"line": "rw [pNilradical, if_neg hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem X_pow_sub_C_irreducible_of_prime_pow\n    {p : \u2115} (hp : p.Prime) (hp' : p \u2260 2) (n : \u2115) {a : K} (ha : \u2200 b : K, b ^ p \u2260 a) :\n    Irreducible (X ^ (p ^ n) - C a) := by\n  apply X_pow_sub_C_irreducible_of_odd (hp.odd_of_ne_two hp').pow\n  intros q hq hq'\n  simpa [(Nat.prime_dvd_prime_iff_eq hq hp).mp (hq.dvd_of_dvd_pow hq')] using ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerExtension.lean", "context": {"open": ["Polynomial IntermediateField AdjoinRoot"], "variables": ["{K : Type u} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\np : \u2115\nhp : Nat.Prime p\nhp' : p \u2260 2\nn : \u2115\na : K\nha : \u2200 (b : K), b ^ p \u2260 a\n\u22a2 Irreducible (X ^ p ^ n - C a)"}, {"line": "apply X_pow_sub_C_irreducible_of_odd (hp.odd_of_ne_two hp').pow", "tactic_state": "K : Type u\ninst\u271d : Field K\np : \u2115\nhp : Nat.Prime p\nhp' : p \u2260 2\nn : \u2115\na : K\nha : \u2200 (b : K), b ^ p \u2260 a\n\u22a2 \u2200 (p_1 : \u2115), Nat.Prime p_1 \u2192 p_1 \u2223 p ^ n \u2192 \u2200 (b : K), b ^ p_1 \u2260 a"}, {"line": "intros q hq hq'", "tactic_state": "K : Type u\ninst\u271d : Field K\np : \u2115\nhp : Nat.Prime p\nhp' : p \u2260 2\nn : \u2115\na : K\nha : \u2200 (b : K), b ^ p \u2260 a\nq : \u2115\nhq : Nat.Prime q\nhq' : q \u2223 p ^ n\n\u22a2 \u2200 (b : K), b ^ q \u2260 a"}, {"line": "simpa [(Nat.prime_dvd_prime_iff_eq hq hp).mp (hq.dvd_of_dvd_pow hq')] using ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma adjoinRootXPowSubCEquiv_root :\n    adjoinRootXPowSubCEquiv h\u03b6 H h\u03b1 (root _) = \u03b1 := by\n  rw [adjoinRootXPowSubCEquiv]\n  rw [AlgEquiv.coe_ofBijective]\n  rw [liftHom_root]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerExtension.lean", "context": {"open": ["Polynomial IntermediateField AdjoinRoot", "scoped KummerExtension"], "variables": ["{K : Type u} [Field K]", "{n : \u2115} (h\u03b6 : (primitiveRoots n K).Nonempty)", "(a : K) (H : Irreducible (X ^ n - C a))", "(n)", "{n}", "{a}", "{a}", "{L : Type*} [Field L] [Algebra K L] [IsSplittingField K L (X ^ n - C a)]", "{\u03b1 : L} (h\u03b1 : \u03b1 ^ n = algebraMap K L a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : Field K\nn : \u2115\nh\u03b6 : (primitiveRoots n K).Nonempty\na : K\nH : Irreducible (X ^ n - C a)\nL : Type u_1\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsSplittingField K L (X ^ n - C a)\n\u03b1 : L\nh\u03b1 : \u03b1 ^ n = (algebraMap K L) a\n\u22a2 (adjoinRootXPowSubCEquiv h\u03b6 H h\u03b1) (root (X ^ n - C a)) = \u03b1"}, {"line": "rw [adjoinRootXPowSubCEquiv]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : Field K\nn : \u2115\nh\u03b6 : (primitiveRoots n K).Nonempty\na : K\nH : Irreducible (X ^ n - C a)\nL : Type u_1\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsSplittingField K L (X ^ n - C a)\n\u03b1 : L\nh\u03b1 : \u03b1 ^ n = (algebraMap K L) a\n\u22a2 (AlgEquiv.ofBijective (liftHom (X ^ n - C a) \u03b1 \u22ef) \u22ef) (root (X ^ n - C a)) = \u03b1"}, {"line": "rw [AlgEquiv.coe_ofBijective]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : Field K\nn : \u2115\nh\u03b6 : (primitiveRoots n K).Nonempty\na : K\nH : Irreducible (X ^ n - C a)\nL : Type u_1\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : IsSplittingField K L (X ^ n - C a)\n\u03b1 : L\nh\u03b1 : \u03b1 ^ n = (algebraMap K L) a\n\u22a2 (liftHom (X ^ n - C a) \u03b1 \u22ef) (root (X ^ n - C a)) = \u03b1"}, {"line": "rw [liftHom_root]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma autEquivZmod_symm_apply_natCast [NeZero n] {\u03b6 : K} (h\u03b6 : IsPrimitiveRoot \u03b6 n) (m : \u2115) :\n    (autEquivZmod H L h\u03b6).symm (Multiplicative.ofAdd (m : ZMod n)) \u03b1 = \u03b6 ^ m \u2022 \u03b1 := by\n  simpa only [Int.cast_natCast,zpow_natCast] using autEquivZmod_symm_apply_intCast H L h\u03b1 h\u03b6 m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerExtension.lean", "context": {"open": ["Polynomial IntermediateField AdjoinRoot", "scoped KummerExtension"], "variables": ["{K : Type u} [Field K]", "{n : \u2115} (h\u03b6 : (primitiveRoots n K).Nonempty)", "(a : K) (H : Irreducible (X ^ n - C a))", "(n)", "{n}", "{a}", "{a}", "{L : Type*} [Field L] [Algebra K L] [IsSplittingField K L (X ^ n - C a)]", "{\u03b1 : L} (h\u03b1 : \u03b1 ^ n = algebraMap K L a)", "(a) (L)", "{a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u2074 : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\nL : Type u_1\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra K L\ninst\u271d\u00b9 : IsSplittingField K L (X ^ n - C a)\n\u03b1 : L\ninst\u271d : NeZero n\n\u03b6 : K\nh\u03b6 : IsPrimitiveRoot \u03b6 n\nm : \u2115\n\u22a2 ((autEquivZmod H L h\u03b6).symm (Multiplicative.ofAdd \u2191m)) \u03b1 = \u03b6 ^ m \u2022 \u03b1"}, {"line": "simpa only [Int.cast_natCast,zpow_natCast] using autEquivZmod_symm_apply_intCast H L h\u03b1 h\u03b6 m", "tactic_state": "No Goals!"}]}
{"declaration": "lemma root_X_pow_sub_C_pow (n : \u2115) (a : K) :\n    (AdjoinRoot.root (X ^ n - C a)) ^ n = AdjoinRoot.of _ a := by\n  rw [\u2190 sub_eq_zero]\n  rw [\u2190 AdjoinRoot.eval\u2082_root]\n  rw [eval\u2082_sub]\n  rw [eval\u2082_C]\n  rw [eval\u2082_pow]\n  rw [eval\u2082_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerPolynomial.lean", "context": {"open": ["Polynomial AdjoinRoot"], "variables": ["{K : Type u} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n = (of (X ^ n - C a)) a"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n - (of (X ^ n - C a)) a = 0"}, {"line": "rw [\u2190 AdjoinRoot.eval\u2082_root]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n - (of (X ^ n - C a)) a = eval\u2082 (of (X ^ n - C a)) (root (X ^ n - C a)) (X ^ n - C a)"}, {"line": "rw [eval\u2082_sub]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n - (of (X ^ n - C a)) a =\n    eval\u2082 (of (X ^ n - C a)) (root (X ^ n - C a)) (X ^ n) - eval\u2082 (of (X ^ n - C a)) (root (X ^ n - C a)) (C a)"}, {"line": "rw [eval\u2082_C]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n - (of (X ^ n - C a)) a =\n    eval\u2082 (of (X ^ n - C a)) (root (X ^ n - C a)) (X ^ n) - (of (X ^ n - C a)) a"}, {"line": "rw [eval\u2082_pow]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\n\u22a2 root (X ^ n - C a) ^ n - (of (X ^ n - C a)) a =\n    eval\u2082 (of (X ^ n - C a)) (root (X ^ n - C a)) X ^ n - (of (X ^ n - C a)) a"}, {"line": "rw [eval\u2082_X]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ne_zero_of_irreducible_X_pow_sub_C {n : \u2115} {a : K} (H : Irreducible (X ^ n - C a)) :\n    n \u2260 0 := by\n  rintro rfl\n  rw [pow_zero] at H\n  rw [\u2190 C.map_one] at H\n  rw [\u2190 map_sub] at H\n  exact not_irreducible_C _ H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerPolynomial.lean", "context": {"open": ["Polynomial AdjoinRoot"], "variables": ["{K : Type u} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\n\u22a2 n \u2260 0"}, {"line": "rintro rfl", "tactic_state": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (X ^ 0 - C a)\n\u22a2 False"}, {"line": "rw [pow_zero] at H", "tactic_state": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (1 - C a)\n\u22a2 False"}, {"line": "rw [\u2190 C.map_one] at H", "tactic_state": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C 1 - C a)\n\u22a2 False"}, {"line": "rw [\u2190 map_sub] at H", "tactic_state": "K : Type u\ninst\u271d : Field K\na : K\nH\u271d : Irreducible (C 1 - C a)\nH : Irreducible (C (1 - a))\n\u22a2 False\n---\nK : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C 1 - C a)\n\u22a2 AddGroup K\n---\nK : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C 1 - C a)\n\u22a2 AddMonoidHomClass (K \u2192+* Polynomial K) K (Polynomial K)"}, {"line": "exact not_irreducible_C _ H", "tactic_state": "K : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C 1 - C a)\n\u22a2 AddGroup K\n---\nK : Type u\ninst\u271d : Field K\na : K\nH : Irreducible (C 1 - C a)\n\u22a2 AddMonoidHomClass (K \u2192+* Polynomial K) K (Polynomial K)"}]}
{"declaration": "lemma ne_zero_of_irreducible_X_pow_sub_C' {n : \u2115} (hn : n \u2260 1) {a : K}\n    (H : Irreducible (X ^ n - C a)) : a \u2260 0 := by\n  rintro rfl\n  rw [map_zero] at H\n  rw [sub_zero] at H\n  exact not_irreducible_pow hn H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerPolynomial.lean", "context": {"open": ["Polynomial AdjoinRoot"], "variables": ["{K : Type u} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\na : K\nH : Irreducible (X ^ n - C a)\n\u22a2 a \u2260 0"}, {"line": "rintro rfl", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n - C 0)\n\u22a2 False"}, {"line": "rw [map_zero] at H", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n - 0)\n\u22a2 False"}, {"line": "rw [sub_zero] at H", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : n \u2260 1\nH : Irreducible (X ^ n)\n\u22a2 False"}, {"line": "exact not_irreducible_pow hn H", "tactic_state": "No Goals!"}]}
{"declaration": "lemma root_X_pow_sub_C_eq_zero_iff {n : \u2115} {a : K} (H : Irreducible (X ^ n - C a)) :\n    (AdjoinRoot.root (X ^ n - C a)) = 0 \u2194 a = 0 := by\n  have hn := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible_X_pow_sub_C H)\n  refine \u27e8not_imp_not.mp (root_X_pow_sub_C_ne_zero' hn), ?_\u27e9\n  rintro rfl\n  have := not_imp_not.mp (fun hn \u21a6 ne_zero_of_irreducible_X_pow_sub_C' hn H) rfl\n  rw [this]\n  rw [pow_one]\n  rw [map_zero]\n  rw [sub_zero]\n  rw [\u2190 mk_X]\n  rw [mk_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KummerPolynomial.lean", "context": {"open": ["Polynomial AdjoinRoot"], "variables": ["{K : Type u} [Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\n\u22a2 root (X ^ n - C a) = 0 \u2194 a = 0"}, {"line": "have hn := Nat.pos_iff_ne_zero.mpr (ne_zero_of_irreducible_X_pow_sub_C H)", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\nhn : 0 < n\n\u22a2 root (X ^ n - C a) = 0 \u2194 a = 0"}, {"line": "refine \u27e8not_imp_not.mp (root_X_pow_sub_C_ne_zero' hn), ?_\u27e9", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\na : K\nH : Irreducible (X ^ n - C a)\nhn : 0 < n\n\u22a2 a = 0 \u2192 root (X ^ n - C a) = 0"}, {"line": "rintro rfl", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\n\u22a2 root (X ^ n - C 0) = 0"}, {"line": "have := not_imp_not.mp (fun hn \u21a6 ne_zero_of_irreducible_X_pow_sub_C' hn H) rfl", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 root (X ^ n - C 0) = 0"}, {"line": "rw [this]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 root (X ^ 1 - C 0) = 0"}, {"line": "rw [pow_one]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 root (X - C 0) = 0"}, {"line": "rw [map_zero]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 root (X - 0) = 0"}, {"line": "rw [sub_zero]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 root X = 0"}, {"line": "rw [\u2190 mk_X]", "tactic_state": "K : Type u\ninst\u271d : Field K\nn : \u2115\nhn : 0 < n\nH : Irreducible (X ^ n - C 0)\nthis : n = 1\n\u22a2 (mk X) X = 0"}, {"line": "rw [mk_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normalizedTrace_algebraMap_apply_eq_self (a : F) :\n    normalizedTrace F K (algebraMap F K a) = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/NormalizedTrace.lean", "context": {"open": ["IntermediateField"], "variables": ["(F K : Type*) [Field F] [Field K] [Algebra F K]", "[CharZero F]", "{K} in", "[Algebra.IsIntegral F K]", "{K} in", "{F} in", "{K} in", "(F E K : Type*) [Field F] [Field E] [Field K]", "[Algebra F E] [Algebra E K] [Algebra F K] [IsScalarTower F E K]", "[Algebra.IsIntegral F E] [Algebra.IsIntegral F K]", "[CharZero F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 inst\u271d : CharZero F\nx\u271d : Sort u_3\nnormalizedTrace : x\u271d\na : F\n\u22a2 sorry = a"}, {"line": "simp", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 inst\u271d : CharZero F\nx\u271d : Sort u_3\nnormalizedTrace : x\u271d\na : F\n\u22a2 sorry () = a"}]}
{"declaration": "theorem relfinrank_self : relfinrank A A = 1 := by\n  simp [relfinrank_eq_toNat_relrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [relfinrank_eq_toNat_relrank]", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem relfinrank_eq_one_of_le (h : B \u2264 A) : relfinrank A B = 1 := by\n  simp [relfinrank_eq_toNat_relrank, relrank_eq_one_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\nh : B \u2264 A\n\u22a2 sorry = 1"}, {"line": "simp [relfinrank_eq_toNat_relrank, relrank_eq_one_of_le h]", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\nh : B \u2264 A\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem relfinrank_mul_finrank_top (h : A \u2264 B) : relfinrank A B * finrank B E = finrank A E := by\n  simpa using congr(toNat $(relrank_mul_rank_top h))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\nh : A \u2264 B\n\u22a2 sorry * finrank (\u21a5B) E = finrank (\u21a5A) E"}, {"line": "simpa using congr(toNat $(relrank_mul_rank_top h))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relfinrank_top_right : relfinrank A \u22a4 = finrank A E := by\n  simp [relfinrank_eq_toNat_relrank, finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry = finrank (\u21a5A) E"}, {"line": "simp [relfinrank_eq_toNat_relrank, finrank]", "tactic_state": "E : Type v\ninst\u271d : Field E\nA : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry () = Cardinal.toNat (Module.rank (\u21a5A) E)"}]}
{"declaration": "theorem lift_rank_comap (f : L \u2192+* E) :\n    lift.{v} (Module.rank (A.comap f) L) = lift.{w} (relrank A f.fieldRange) := by\n  simpa only [relrank_top_right,\u2190 RingHom.fieldRange_eq_map] using lift_relrank_comap A f \u22a4\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d\u00b9 : Field E\nL : Type w\ninst\u271d : Field L\nA : Subfield E\nx\u271d : Sort u_1\nrelrank : x\u271d\nf : L \u2192+* E\n\u22a2 lift.{v, w} (Module.rank (\u21a5(Subfield.comap f A)) L) = lift.{w, v} sorry"}, {"line": "simpa only [relrank_top_right,\u2190 RingHom.fieldRange_eq_map] using lift_relrank_comap A f \u22a4", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rank_comap {L : Type v} [Field L] (f : L \u2192+* E) :\n    Module.rank (A.comap f) L = relrank A f.fieldRange := by\n  simpa only [lift_id] using A.lift_rank_comap f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d\u00b9 : Field E\nA : Subfield E\nx\u271d : Sort u_1\nrelrank : x\u271d\nL : Type v\ninst\u271d : Field L\nf : L \u2192+* E\n\u22a2 Module.rank (\u21a5(Subfield.comap f A)) L = sorry"}, {"line": "simpa only [lift_id] using A.lift_rank_comap f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_comap (f : L \u2192+* E) : finrank (A.comap f) L = relfinrank A f.fieldRange := by\n  simpa using congr(toNat $(lift_rank_comap A f))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d\u00b9 : Field E\nL : Type w\ninst\u271d : Field L\nA : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\nf : L \u2192+* E\n\u22a2 finrank (\u21a5(Subfield.comap f A)) L = sorry"}, {"line": "simpa using congr(toNat $(lift_rank_comap A f))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relfinrank_inf_mul_relfinrank :\n    A.relfinrank (B \u2293 C) * B.relfinrank C = (A \u2293 B).relfinrank C := by\n  simpa using congr(toNat $(relrank_inf_mul_relrank A B C))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B C : Subfield E\n\u22a2 A.relfinrank (B \u2293 C) * B.relfinrank C = (A \u2293 B).relfinrank C"}, {"line": "simpa using congr(toNat $(relrank_inf_mul_relrank A B C))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relrank_mul_relrank_eq_inf_relrank (h : B \u2264 C) :\n    relrank A B * relrank B C = (A \u2293 B).relrank C := by\n  simpa only [inf_of_le_left h] using relrank_inf_mul_relrank A B C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B C : Subfield E\nx\u271d : Sort u_1\nrelrank : x\u271d\nh : B \u2264 C\n\u22a2 sorry * sorry = (A \u2293 B).relrank C"}, {"line": "simpa only [inf_of_le_left h] using relrank_inf_mul_relrank A B C", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relfinrank_mul_relfinrank_eq_inf_relfinrank (h : B \u2264 C) :\n    relfinrank A B * relfinrank B C = (A \u2293 B).relfinrank C := by\n  simpa using congr(toNat $(relrank_mul_relrank_eq_inf_relrank A h))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B C : Subfield E\nx\u271d : Sort u_1\nrelfinrank : x\u271d\nh : B \u2264 C\n\u22a2 sorry * sorry = (A \u2293 B).relfinrank C"}, {"line": "simpa using congr(toNat $(relrank_mul_relrank_eq_inf_relrank A h))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relrank_inf_mul_relrank_of_le (h : A \u2264 B) :\n    A.relrank (B \u2293 C) * B.relrank C = A.relrank C := by\n  simpa only [inf_of_le_left h] using relrank_inf_mul_relrank A B C\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B C : Subfield E\nh : A \u2264 B\n\u22a2 A.relrank (B \u2293 C) * B.relrank C = A.relrank C"}, {"line": "simpa only [inf_of_le_left h] using relrank_inf_mul_relrank A B C", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relfinrank_inf_mul_relfinrank_of_le (h : A \u2264 B) :\n    A.relfinrank (B \u2293 C) * B.relfinrank C = A.relfinrank C := by\n  simpa using congr(toNat $(relrank_inf_mul_relrank_of_le C h))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type v\ninst\u271d : Field E\nA B C : Subfield E\nh : A \u2264 B\n\u22a2 A.relfinrank (B \u2293 C) * B.relfinrank C = A.relfinrank C"}, {"line": "simpa using congr(toNat $(relrank_inf_mul_relrank_of_le C h))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem relfinrank_eq_one_of_le (h : B \u2264 A) : relfinrank A B = 1 := by\n  simp [relfinrank_eq_toNat_relrank, relrank_eq_one_of_le h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]", "{L : Type w} [Field L] [Algebra F L]", "(A B C : IntermediateField F E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\nh : sorry\n\u22a2 sorry = 1"}, {"line": "simp [relfinrank_eq_toNat_relrank, relrank_eq_one_of_le h]", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\nh : sorry\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem relfinrank_top_right : relfinrank A \u22a4 = finrank A E := by\n  simp [relfinrank_eq_toNat_relrank, finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]", "{L : Type w} [Field L] [Algebra F L]", "(A B C : IntermediateField F E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [relfinrank_eq_toNat_relrank, finrank]", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem relfinrank_bot_left : relfinrank \u22a5 A = finrank F A := by\n  simp [relfinrank_eq_toNat_relrank, finrank]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Relrank.lean", "context": {"open": ["Module Cardinal"], "variables": ["{E : Type v} [Field E] {L : Type w} [Field L]", "(A B C : Subfield E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]", "{L : Type w} [Field L] [Algebra F L]", "(A B C : IntermediateField F E)", "{A B C}", "(A B C)", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B} in", "{A B C} in", "{A B C} in", "{B C} in", "{B C} in", "{A B} in", "{A B} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [relfinrank_eq_toNat_relrank, finrank]", "tactic_state": "x\u271d : Sort u_1\nrelfinrank : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem gal_zero_isSolvable : IsSolvable (0 : F[X]).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\n\u22a2 IsSolvable (Gal 0)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_one_isSolvable : IsSolvable (1 : F[X]).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\n\u22a2 IsSolvable (Gal 1)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_C_isSolvable (x : F) : IsSolvable (C x).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx : F\n\u22a2 IsSolvable (C x).Gal"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_X_isSolvable : IsSolvable (X : F[X]).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\n\u22a2 IsSolvable X.Gal"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_X_sub_C_isSolvable (x : F) : IsSolvable (X - C x).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx : F\n\u22a2 IsSolvable (X - C x).Gal"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_X_pow_isSolvable (n : \u2115) : IsSolvable (X ^ n : F[X]).Gal := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nn : \u2115\n\u22a2 IsSolvable (X ^ n).Gal"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gal_prod_isSolvable {s : Multiset F[X]} (hs : \u2200 p \u2208 s, IsSolvable (Gal p)) :\n    IsSolvable s.prod.Gal := by\n  apply Multiset.induction_on' s\n  \u00b7 exact gal_one_isSolvable\n  \u00b7 intro p t hps _ ht\n    rw [Multiset.insert_eq_cons]\n    rw [Multiset.prod_cons]\n    exact gal_mul_isSolvable (hs p hps) ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AbelRuffini.lean", "context": {"open": ["Polynomial IntermediateField"], "variables": ["{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\ns : Multiset (Polynomial F)\nhs : \u2200 p \u2208 s, IsSolvable p.Gal\n\u22a2 IsSolvable s.prod.Gal"}, {"line": "apply Multiset.induction_on' s", "tactic_state": "case h\u2081\nF : Type u_1\ninst\u271d : Field F\ns : Multiset (Polynomial F)\nhs : \u2200 p \u2208 s, IsSolvable p.Gal\n\u22a2 IsSolvable (Multiset.prod 0).Gal\n---\ncase h\u2082\nF : Type u_1\ninst\u271d : Field F\ns : Multiset (Polynomial F)\nhs : \u2200 p \u2208 s, IsSolvable p.Gal\n\u22a2 \u2200 {a : Polynomial F} {s_1 : Multiset (Polynomial F)},\n    a \u2208 s \u2192 s_1 \u2286 s \u2192 IsSolvable s_1.prod.Gal \u2192 IsSolvable (insert a s_1).prod.Gal"}, {"line": "\u00b7 exact gal_one_isSolvable", "tactic_state": "case h\u2082\nF : Type u_1\ninst\u271d : Field F\ns : Multiset (Polynomial F)\nhs : \u2200 p \u2208 s, IsSolvable p.Gal\n\u22a2 \u2200 {a : Polynomial F} {s_1 : Multiset (Polynomial F)},\n    a \u2208 s \u2192 s_1 \u2286 s \u2192 IsSolvable s_1.prod.Gal \u2192 IsSolvable (insert a s_1).prod.Gal"}, {"line": "\u00b7 intro p t hps _ ht\n    rw [Multiset.insert_eq_cons]\n    rw [Multiset.prod_cons]\n    exact gal_mul_isSolvable (hs p hps) ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ax_grothendieck_zeroLocus\n    (I : Ideal (MvPolynomial \u03b9 K))\n    (p : \u03b9 \u2192 MvPolynomial \u03b9 K) :\n    let S := zeroLocus I\n    S.MapsTo (fun v i => eval v (p i)) S \u2192\n    S.InjOn (fun v i => eval v (p i)) \u2192\n    S.SurjOn (fun v i => eval v (p i)) S := by\n  letI := compatibleRingOfRing K\n  intro S\n  obtain \u27e8s, rfl\u27e9 : I.FG := IsNoetherian.noetherian I\n  exact ax_grothendieck_of_definable S (mvPolynomial_zeroLocus_definable s) p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AxGrothendieck.lean", "context": {"open": ["MvPolynomial Finset", "MvPolynomial FreeCommRing Language Field Ring BoundedFormula", "FirstOrder Language Field Ring MvPolynomial"], "variables": ["{\u03b9 \u03b1 : Type*} [Finite \u03b1] {K : Type*} [Field K] [CompatibleRing K]", "{K \u03b9 : Type*} [Field K] [IsAlgClosed K] [Finite \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 let S := zeroLocus I;\n  Set.MapsTo (fun v i => (eval v) (p i)) S S \u2192\n    Set.InjOn (fun v i => (eval v) (p i)) S \u2192 Set.SurjOn (fun v i => (eval v) (p i)) S S"}, {"line": "letI := compatibleRingOfRing K", "tactic_state": "case refine_6\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\nthis : CompatibleRing K := sorry\n\u22a2 let S := zeroLocus I;\n  Set.MapsTo (fun v i => (eval v) (p i)) S S \u2192\n    Set.InjOn (fun v i => (eval v) (p i)) S \u2192 Set.SurjOn (fun v i => (eval v) (p i)) S S\n---\ncase refine_1\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Add K\n---\ncase refine_2\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Mul K\n---\ncase refine_3\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Neg K\n---\ncase refine_4\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 One K\n---\ncase refine_5\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Zero K"}, {"line": "intro S", "tactic_state": "case refine_6\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\nthis : CompatibleRing K := sorry\nS : Set (\u03b9 \u2192 K) := zeroLocus I\n\u22a2 Set.MapsTo (fun v i => (eval v) (p i)) S S \u2192\n    Set.InjOn (fun v i => (eval v) (p i)) S \u2192 Set.SurjOn (fun v i => (eval v) (p i)) S S\n---\ncase refine_1\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Add K\n---\ncase refine_2\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Mul K\n---\ncase refine_3\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Neg K\n---\ncase refine_4\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 One K\n---\ncase refine_5\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\nI : Ideal (MvPolynomial \u03b9 K)\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 Zero K"}, {"line": "obtain \u27e8s, rfl\u27e9 : I.FG := IsNoetherian.noetherian I", "tactic_state": "case refine_6.intro\nK : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 MvPolynomial \u03b9 K\ns : Finset (MvPolynomial \u03b9 K)\nthis : CompatibleRing K := sorry\nS : Set (\u03b9 \u2192 K) := zeroLocus (Ideal.span \u2191s)\n\u22a2 Set.MapsTo (fun v i => (eval v) (p i)) S S \u2192\n    Set.InjOn (fun v i => (eval v) (p i)) S \u2192 Set.SurjOn (fun v i => (eval v) (p i)) S S"}, {"line": "exact ax_grothendieck_of_definable S (mvPolynomial_zeroLocus_definable s) p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ax_grothendieck_univ (p : \u03b9 \u2192 MvPolynomial \u03b9 K) :\n    (fun v i => eval v (p i)).Injective \u2192\n    (fun v i => eval v (p i)).Surjective := by\n  simpa [Set.injective_iff_injOn_univ, Set.surjective_iff_surjOn_univ] using\n      ax_grothendieck_zeroLocus 0 p", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/AxGrothendieck.lean", "context": {"open": ["MvPolynomial Finset", "MvPolynomial FreeCommRing Language Field Ring BoundedFormula", "FirstOrder Language Field Ring MvPolynomial"], "variables": ["{\u03b9 \u03b1 : Type*} [Finite \u03b1] {K : Type*} [Field K] [CompatibleRing K]", "{K \u03b9 : Type*} [Field K] [IsAlgClosed K] [Finite \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : IsAlgClosed K\ninst\u271d : Finite \u03b9\np : \u03b9 \u2192 MvPolynomial \u03b9 K\n\u22a2 (Function.Injective fun v i => (eval v) (p i)) \u2192 Function.Surjective fun v i => (eval v) (p i)"}, {"line": "simpa [Set.injective_iff_injOn_univ, Set.surjective_iff_surjOn_univ] using\n      ax_grothendieck_zeroLocus 0 p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Field.nonempty_iff {\u03b1 : Type u} : Nonempty (Field \u03b1) \u2194 IsPrimePow #\u03b1 := by\n  rw [Cardinal.isPrimePow_iff]\n  obtain h | h := fintypeOrInfinite \u03b1\n  \u00b7 simpa only [Cardinal.mk_fintype,Nat.cast_inj,exists_eq_left',(Cardinal.nat_lt_aleph0 _).not_le,false_or] using Fintype.nonempty_field_iff\n  \u00b7 simpa only [\u2190 Cardinal.infinite_iff,h,true_or,iff_true] using Infinite.nonempty_field", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Cardinality.lean", "context": {"open": ["scoped Cardinal nonZeroDivisors"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u22a2 Nonempty (Field \u03b1) \u2194 IsPrimePow (Cardinal.mk \u03b1)"}, {"line": "rw [Cardinal.isPrimePow_iff]", "tactic_state": "\u03b1 : Type u\n\u22a2 Nonempty (Field \u03b1) \u2194 Cardinal.aleph0 \u2264 Cardinal.mk \u03b1 \u2228 \u2203 n, Cardinal.mk \u03b1 = \u2191n \u2227 IsPrimePow n"}, {"line": "obtain h | h := fintypeOrInfinite \u03b1", "tactic_state": "case inl\n\u03b1 : Type u\nh : Fintype \u03b1\n\u22a2 Nonempty (Field \u03b1) \u2194 Cardinal.aleph0 \u2264 Cardinal.mk \u03b1 \u2228 \u2203 n, Cardinal.mk \u03b1 = \u2191n \u2227 IsPrimePow n\n---\ncase inr\n\u03b1 : Type u\nh : Infinite \u03b1\n\u22a2 Nonempty (Field \u03b1) \u2194 Cardinal.aleph0 \u2264 Cardinal.mk \u03b1 \u2228 \u2203 n, Cardinal.mk \u03b1 = \u2191n \u2227 IsPrimePow n"}, {"line": "\u00b7 simpa only [Cardinal.mk_fintype,Nat.cast_inj,exists_eq_left',(Cardinal.nat_lt_aleph0 _).not_le,false_or] using Fintype.nonempty_field_iff", "tactic_state": "case inr\n\u03b1 : Type u\nh : Infinite \u03b1\n\u22a2 Nonempty (Field \u03b1) \u2194 Cardinal.aleph0 \u2264 Cardinal.mk \u03b1 \u2228 \u2203 n, Cardinal.mk \u03b1 = \u2191n \u2227 IsPrimePow n"}, {"line": "\u00b7 simpa only [\u2190 Cardinal.infinite_iff,h,true_or,iff_true] using Infinite.nonempty_field", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toAlgAut_bijective [Finite G] [FaithfulSMul G F] :\n    Function.Bijective (MulSemiringAction.toAlgAut G (FixedPoints.subfield G F) F) := by\n  refine \u27e8fun _ _ h \u21a6 (FixedPoints.toAlgHom_bijective G F).injective ?_,\n    fun f \u21a6 ((FixedPoints.toAlgHom_bijective G F).surjective f).imp (fun _ h \u21a6 ?_)\u27e9 <;>\n      rwa [DFunLike.ext_iff] at h \u22a2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Fixed.lean", "context": {"open": ["MulAction Finset Module"], "variables": ["{M : Type u} [Monoid M]", "(G : Type u) [Group G]", "(F : Type v) [Field F] [MulSemiringAction M F] [MulSemiringAction G F] (m : M)", "(M) {F}", "(S : Subfield F)", "(M)", "[Fintype G] (x : F)", "[Fintype G] (x : F)", "[Finite G]", "(G F : Type*) [Group G] [Field F] [MulSemiringAction G F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nF : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : MulSemiringAction G F\ninst\u271d\u00b9 : Finite G\ninst\u271d : FaithfulSMul G F\n\u22a2 Function.Bijective \u21d1(MulSemiringAction.toAlgAut G (\u21a5(FixedPoints.subfield G F)) F)"}, {"line": "refine \u27e8fun _ _ h \u21a6 (FixedPoints.toAlgHom_bijective G F).injective ?_,\n    fun f \u21a6 ((FixedPoints.toAlgHom_bijective G F).surjective f).imp (fun _ h \u21a6 ?_)\u27e9 <;>\n      rwa [DFunLike.ext_iff] at h \u22a2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IntermediateField.fixingSubgroup.antimono {K L : Type*} [Field K] [Field L] [Algebra K L]\n    {E1 E2 : IntermediateField K L} (h12 : E1 \u2264 E2) : E2.fixingSubgroup \u2264 E1.fixingSubgroup := by\n  rintro \u03c3 h\u03c3 \u27e8x, hx\u27e9\n  exact h\u03c3 \u27e8x, h12 hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KrullTopology.lean", "context": {"open": ["scoped Pointwise"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nE1 E2 : IntermediateField K L\nh12 : E1 \u2264 E2\n\u22a2 E2.fixingSubgroup \u2264 E1.fixingSubgroup"}, {"line": "rintro \u03c3 h\u03c3 \u27e8x, hx\u27e9", "tactic_state": "case mk\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nE1 E2 : IntermediateField K L\nh12 : E1 \u2264 E2\n\u03c3 : L \u2243\u2090[K] L\nh\u03c3 : \u03c3 \u2208 E2.fixingSubgroup\nx : L\nhx : x \u2208 \u2191E1\n\u22a2 \u03c3 \u2022 \u2191\u27e8x, hx\u27e9 = \u2191\u27e8x, hx\u27e9"}, {"line": "exact h\u03c3 \u27e8x, h12 hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma krullTopology_mem_nhds_one_iff (K L : Type*) [Field K] [Field L] [Algebra K L]\n    (s : Set (L \u2243\u2090[K] L)) : s \u2208 \ud835\udcdd 1 \u2194 \u2203 E : IntermediateField K L,\n    FiniteDimensional K E \u2227 (E.fixingSubgroup : Set (L \u2243\u2090[K] L)) \u2286 s := by\n  rw [GroupFilterBasis.nhds_one_eq]\n  constructor\n  \u00b7 rintro \u27e8-, \u27e8-, \u27e8E, fin, rfl\u27e9, rfl\u27e9, hE\u27e9\n    exact \u27e8E, fin, hE\u27e9\n  \u00b7 rintro \u27e8E, fin, hE\u27e9\n    exact \u27e8E.fixingSubgroup, \u27e8E.fixingSubgroup, \u27e8E, fin, rfl\u27e9, rfl\u27e9, hE\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/KrullTopology.lean", "context": {"open": ["scoped Pointwise", "scoped Topology in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ns : Set (L \u2243\u2090[K] L)\n\u22a2 s \u2208 nhds 1 \u2194 \u2203 E, FiniteDimensional K \u21a5E \u2227 \u2191E.fixingSubgroup \u2286 s"}, {"line": "rw [GroupFilterBasis.nhds_one_eq]", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ns : Set (L \u2243\u2090[K] L)\n\u22a2 s \u2208 GroupFilterBasis.toFilterBasis.filter \u2194 \u2203 E, FiniteDimensional K \u21a5E \u2227 \u2191E.fixingSubgroup \u2286 s"}, {"line": "constructor", "tactic_state": "case mp\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ns : Set (L \u2243\u2090[K] L)\n\u22a2 s \u2208 GroupFilterBasis.toFilterBasis.filter \u2192 \u2203 E, FiniteDimensional K \u21a5E \u2227 \u2191E.fixingSubgroup \u2286 s\n---\ncase mpr\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ns : Set (L \u2243\u2090[K] L)\n\u22a2 (\u2203 E, FiniteDimensional K \u21a5E \u2227 \u2191E.fixingSubgroup \u2286 s) \u2192 s \u2208 GroupFilterBasis.toFilterBasis.filter"}, {"line": "\u00b7 rintro \u27e8-, \u27e8-, \u27e8E, fin, rfl\u27e9, rfl\u27e9, hE\u27e9\n    exact \u27e8E, fin, hE\u27e9", "tactic_state": "case mpr\nK : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\ns : Set (L \u2243\u2090[K] L)\n\u22a2 (\u2203 E, FiniteDimensional K \u21a5E \u2227 \u2191E.fixingSubgroup \u2286 s) \u2192 s \u2208 GroupFilterBasis.toFilterBasis.filter"}, {"line": "\u00b7 rintro \u27e8E, fin, hE\u27e9\n    exact \u27e8E.fixingSubgroup, \u27e8E.fixingSubgroup, \u27e8E, fin, rfl\u27e9, rfl\u27e9, hE\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finrank_sup (H : A.LinearDisjoint B) : finrank F \u21a5(A \u2294 B) = finrank F A * finrank F B := by\n  simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct", "Module IntermediateField"], "variables": ["{F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]", "(A B : IntermediateField F E)", "(L : Type w) [Field L] [Algebra F L] [Algebra L E] [IsScalarTower F L E]", "{A B L}", "{L' : Type*} [Field L'] [Algebra F L'] [Algebra L' E] [IsScalarTower F L' E]", "(A) in", "(A) in", "(F E L) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint \u21a5B\n\u22a2 finrank F \u21a5(A \u2294 B) = finrank F \u21a5A * finrank F \u21a5B"}, {"line": "simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isDomain' {A B : Type*} [Field A] [Algebra F A] [Field B] [Algebra F B]\n    {fa : A \u2192\u2090[F] E} {fb : B \u2192\u2090[F] E} (H : fa.fieldRange.LinearDisjoint fb.fieldRange) :\n    IsDomain (A \u2297[F] B) := by\n  simp_rw [linearDisjoint_iff', AlgHom.fieldRange_toSubalgebra] at H\n  exact H.isDomain_of_injective fa.injective fb.injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/LinearDisjoint.lean", "context": {"open": ["scoped TensorProduct", "Module IntermediateField"], "variables": ["{F : Type u} {E : Type v} [Field F] [Field E] [Algebra F E]", "(A B : IntermediateField F E)", "(L : Type w) [Field L] [Algebra F L] [Algebra L E] [IsScalarTower F L E]", "{A B L}", "{L' : Type*} [Field L'] [Algebra F L'] [Algebra L' E] [IsScalarTower F L' E]", "(A) in", "(A) in", "(F E L) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b3 : Field A\ninst\u271d\u00b2 : Algebra F A\ninst\u271d\u00b9 : Field B\ninst\u271d : Algebra F B\nfa : A \u2192\u2090[F] E\nfb : B \u2192\u2090[F] E\nH : fa.fieldRange.LinearDisjoint \u21a5fb.fieldRange\n\u22a2 IsDomain (TensorProduct F A B)"}, {"line": "simp_rw [linearDisjoint_iff', AlgHom.fieldRange_toSubalgebra] at H", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nA : Type u_2\nB : Type u_3\ninst\u271d\u00b3 : Field A\ninst\u271d\u00b2 : Algebra F A\ninst\u271d\u00b9 : Field B\ninst\u271d : Algebra F B\nfa : A \u2192\u2090[F] E\nfb : B \u2192\u2090[F] E\nH : fa.range.LinearDisjoint fb.range\n\u22a2 IsDomain (TensorProduct F A B)"}, {"line": "exact H.isDomain_of_injective fa.injective fb.injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterateFrobeniusEquiv_zero_apply (x : R) : iterateFrobeniusEquiv R p 0 x = x := by\n  rw [iterateFrobeniusEquiv_def]\n  rw [pow_zero]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\np : \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\nx : R\n\u22a2 (iterateFrobeniusEquiv R p 0) x = x"}, {"line": "rw [iterateFrobeniusEquiv_def]", "tactic_state": "R : Type u_1\np : \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\nx : R\n\u22a2 x ^ p ^ 0 = x"}, {"line": "rw [pow_zero]", "tactic_state": "R : Type u_1\np : \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\nx : R\n\u22a2 x ^ 1 = x"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iterateFrobeniusEquiv_one_apply (x : R) : iterateFrobeniusEquiv R p 1 x = x ^ p := by\n  rw [iterateFrobeniusEquiv_def]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\np : \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\nx : R\n\u22a2 (iterateFrobeniusEquiv R p 1) x = x ^ p"}, {"line": "rw [iterateFrobeniusEquiv_def]", "tactic_state": "R : Type u_1\np : \u2115\ninst\u271d\u00b2 : CommSemiring R\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\nx : R\n\u22a2 x ^ p ^ 1 = x ^ p"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_expand_map_frobenius_le :\n    (expand R p f).roots.map (frobenius R p) \u2264 p \u2022 f.roots := by\n  rw [\u2190 iterateFrobenius_one]\n  convert \u2190 roots_expand_pow_map_iterateFrobenius_le p 1 f <;> apply pow_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial", "Multiset"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]", "{K : Type*} [Field K]", "[PerfectField K]", "{R : Type*} [CommRing R] [IsDomain R] (p n : \u2115) [ExpChar R p] (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np : \u2115\ninst\u271d : ExpChar R p\nf : Polynomial R\n\u22a2 Multiset.map (\u21d1(frobenius R p)) ((expand R p) f).roots \u2264 p \u2022 f.roots"}, {"line": "rw [\u2190 iterateFrobenius_one]", "tactic_state": "R : Type u_3\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : IsDomain R\np : \u2115\ninst\u271d : ExpChar R p\nf : Polynomial R\n\u22a2 Multiset.map (\u21d1(iterateFrobenius R p 1)) ((expand R p) f).roots \u2264 p \u2022 f.roots"}, {"line": "convert \u2190 roots_expand_pow_map_iterateFrobenius_le p 1 f <;> apply pow_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_expand_image_frobenius_subset [DecidableEq R] :\n    (expand R p f).roots.toFinset.image (frobenius R p) \u2286 f.roots.toFinset := by\n  rw [\u2190 iterateFrobenius_one]\n  convert \u2190 roots_expand_pow_image_iterateFrobenius_subset p 1 f\n  apply pow_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial", "Multiset"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]", "{K : Type*} [Field K]", "[PerfectField K]", "{R : Type*} [CommRing R] [IsDomain R] (p n : \u2115) [ExpChar R p] (f : R[X])"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\nf : Polynomial R\ninst\u271d : DecidableEq R\n\u22a2 Finset.image (\u21d1(frobenius R p)) ((expand R p) f).roots.toFinset \u2286 f.roots.toFinset"}, {"line": "rw [\u2190 iterateFrobenius_one]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\nf : Polynomial R\ninst\u271d : DecidableEq R\n\u22a2 Finset.image (\u21d1(iterateFrobenius R p 1)) ((expand R p) f).roots.toFinset \u2286 f.roots.toFinset"}, {"line": "convert \u2190 roots_expand_pow_image_iterateFrobenius_subset p 1 f", "tactic_state": "case h.e'_3.h.e'_5.h.e'_3.h.e'_4.h.e'_5.h.e'_3\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\nf : Polynomial R\ninst\u271d : DecidableEq R\n\u22a2 p ^ 1 = p"}, {"line": "apply pow_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_X_pow_char_pow_sub_C_pow {y : R} {m : \u2115} :\n    ((X ^ p ^ n - C y) ^ m).roots = (m * p ^ n) \u2022 {(iterateFrobeniusEquiv R p n).symm y} := by\n  rw [roots_pow]\n  rw [roots_X_pow_char_pow_sub_C]\n  rw [mul_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial", "Multiset"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]", "{K : Type*} [Field K]", "[PerfectField K]", "{R : Type*} [CommRing R] [IsDomain R] (p n : \u2115) [ExpChar R p] (f : R[X])", "{p n f}", "[PerfectRing R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np n : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 ((X ^ p ^ n - C y) ^ m).roots = (m * p ^ n) \u2022 {(iterateFrobeniusEquiv R p n).symm y}"}, {"line": "rw [roots_pow]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np n : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 m \u2022 (X ^ p ^ n - C y).roots = (m * p ^ n) \u2022 {(iterateFrobeniusEquiv R p n).symm y}"}, {"line": "rw [roots_X_pow_char_pow_sub_C]", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np n : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 m \u2022 p ^ n \u2022 {(iterateFrobeniusEquiv R p n).symm y} = (m * p ^ n) \u2022 {(iterateFrobeniusEquiv R p n).symm y}\n---\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np n : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 ExpChar R p\n---\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np n : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 PerfectRing R p"}, {"line": "rw [mul_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_X_pow_char_sub_C {y : R} :\n    (X ^ p - C y).roots = p \u2022 {(frobeniusEquiv R p).symm y} := by\n  have H := roots_X_pow_char_pow_sub_C (p := p) (n := 1) (y := y)\n  rwa [pow_one, iterateFrobeniusEquiv_one] at H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial", "Multiset"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]", "{K : Type*} [Field K]", "[PerfectField K]", "{R : Type*} [CommRing R] [IsDomain R] (p n : \u2115) [ExpChar R p] (f : R[X])", "{p n f}", "[PerfectRing R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\n\u22a2 (X ^ p - C y).roots = p \u2022 {(frobeniusEquiv R p).symm y}"}, {"line": "have H := roots_X_pow_char_pow_sub_C (p := p) (n := 1) (y := y)", "tactic_state": "case refine_5\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nH : (X ^ p ^ 1 - C y).roots = p ^ 1 \u2022 {(iterateFrobeniusEquiv R p 1).symm y}\n\u22a2 (X ^ p - C y).roots = p \u2022 {(frobeniusEquiv R p).symm y}\n---\ncase refine_1\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\n\u22a2 CommRing R\n---\ncase refine_2\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\n\u22a2 IsDomain R\n---\ncase refine_3\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\n\u22a2 ExpChar R p\n---\ncase refine_4\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\n\u22a2 PerfectRing R p"}, {"line": "rwa [pow_one, iterateFrobeniusEquiv_one] at H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem roots_X_pow_char_sub_C_pow {y : R} {m : \u2115} :\n    ((X ^ p - C y) ^ m).roots = (m * p) \u2022 {(frobeniusEquiv R p).symm y} := by\n  have H := roots_X_pow_char_pow_sub_C_pow (p := p) (n := 1) (y := y) (m := m)\n  rwa [pow_one, iterateFrobeniusEquiv_one] at H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Perfect.lean", "context": {"open": ["Function Polynomial", "Multiset"], "variables": ["(R : Type*) (p m n : \u2115) [CommSemiring R] [ExpChar R p]", "[PerfectRing R p]", "{K : Type*} [Field K]", "[PerfectField K]", "{R : Type*} [CommRing R] [IsDomain R] (p n : \u2115) [ExpChar R p] (f : R[X])", "{p n f}", "[PerfectRing R p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 ((X ^ p - C y) ^ m).roots = (m * p) \u2022 {(frobeniusEquiv R p).symm y}"}, {"line": "have H := roots_X_pow_char_pow_sub_C_pow (p := p) (n := 1) (y := y) (m := m)", "tactic_state": "case refine_5\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\nH : ((X ^ p ^ 1 - C y) ^ m).roots = (m * p ^ 1) \u2022 {(iterateFrobeniusEquiv R p 1).symm y}\n\u22a2 ((X ^ p - C y) ^ m).roots = (m * p) \u2022 {(frobeniusEquiv R p).symm y}\n---\ncase refine_1\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 CommRing R\n---\ncase refine_2\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 IsDomain R\n---\ncase refine_3\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 ExpChar R p\n---\ncase refine_4\nR : Type u_3\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : IsDomain R\np : \u2115\ninst\u271d\u00b9 : ExpChar R p\ninst\u271d : PerfectRing R p\ny : R\nm : \u2115\n\u22a2 PerfectRing R p"}, {"line": "rwa [pow_one, iterateFrobeniusEquiv_one] at H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast (x : \u2124) : (x : PerfectClosure K p) = mk K p (0, x) := by\n  cases x <;> simp [natCast K p 0]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PerfectClosure.lean", "context": {"open": ["Function"], "variables": ["(K : Type u) [CommRing K] (p : \u2115) [Fact p.Prime] [CharP K p]", "(K : Type u)", "[CommRing K] (p : \u2115) [Fact p.Prime] [CharP K p]", "{K p}", "(K p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b2 : CommRing K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : CharP K p\nx\u271d : Sort u_1\nmk : x\u271d\nx : \u2124\n\u22a2 \u2191x = sorry"}, {"line": "cases x <;> simp [natCast K p 0]", "tactic_state": "case ofNat\nK : Type u\ninst\u271d\u00b2 : CommRing K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : CharP K p\nx\u271d : Sort u_1\nmk : x\u271d\na\u271d : \u2115\n\u22a2 \u2191a\u271d = sorry ()\n---\ncase negSucc\nK : Type u\ninst\u271d\u00b2 : CommRing K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : CharP K p\nx\u271d : Sort u_1\nmk : x\u271d\na\u271d : \u2115\n\u22a2 -1 + -\u2191a\u271d = sorry ()"}]}
{"declaration": "theorem frobenius_mk (x : \u2115 \u00d7 K) :\n    (frobenius (PerfectClosure K p) p : PerfectClosure K p \u2192 PerfectClosure K p) (mk K p x) =\n      mk _ _ (x.1, x.2 ^ p) := by\n  simp only [frobenius_def]\n  exact mk_pow K p x p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PerfectClosure.lean", "context": {"open": ["Function"], "variables": ["(K : Type u) [CommRing K] (p : \u2115) [Fact p.Prime] [CharP K p]", "(K : Type u)", "[CommRing K] (p : \u2115) [Fact p.Prime] [CharP K p]", "{K p}", "(K p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b2 : CommRing K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : CharP K p\nx\u271d : Sort u_1\nmk : x\u271d\nx : \u2115 \u00d7 K\n\u22a2 (frobenius (PerfectClosure K p) p) sorry = sorry"}, {"line": "simp only [frobenius_def]", "tactic_state": "K : Type u\ninst\u271d\u00b2 : CommRing K\np : \u2115\ninst\u271d\u00b9 : Fact (Nat.Prime p)\ninst\u271d : CharP K p\nx\u271d : Sort u_1\nmk : x\u271d\nx : \u2115 \u00d7 K\n\u22a2 sorry ^ p = sorry"}, {"line": "exact mk_pow K p x p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AlgHom.card_of_splits (L : Type*) [Field L] [Algebra F L]\n    (hL : \u2200 x : E, (minpoly F x).Splits (algebraMap F L)) :\n    Fintype.card (E \u2192\u2090[F] L) = finrank F E := by\n  convert (AlgHom.card_of_powerBasis (L := L) (Field.powerBasisOfFiniteOfSeparable F E)\n    (Algebra.IsSeparable.isSeparable _ _) <| hL _).trans\n      (PowerBasis.finrank _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PrimitiveElement.lean", "context": {"open": ["Module Polynomial IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F : Type*} [Field F] [Infinite F] {E : Type*} [Field E] (\u03d5 : F \u2192+* E) (\u03b1 \u03b2 : E)", "(F)", "[Algebra F E]", "(F E : Type*) [Field F] [Field E]", "[Algebra F E]", "[FiniteDimensional F E] [Algebra.IsSeparable F E]", "(F E : Type*) [Field F] [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 sorry = finrank F E"}, {"line": "convert (AlgHom.card_of_powerBasis (L := L) (Field.powerBasisOfFiniteOfSeparable F E)\n    (Algebra.IsSeparable.isSeparable _ _) <| hL _).trans\n      (PowerBasis.finrank _).symm", "tactic_state": "case h.e'_2\nF : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 sorry = Fintype.card (E \u2192\u2090[F] L)\n---\ncase convert_1\nF : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 FiniteDimensional F E\n---\ncase convert_2\nF : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 Algebra.IsSeparable F E\n---\ncase convert_3\nF : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 Algebra.IsSeparable F E\n---\ncase convert_4\nF : Type u_7\nE : Type u_8\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nL : Type u_9\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra F L\nhL : \u2200 (x : E), Splits (algebraMap F L) (minpoly F x)\n\u22a2 StrongRankCondition F"}]}
{"declaration": "theorem separable_of_subsingleton [Subsingleton R] (f : R[X]) : f.Separable := by\n  simp [Separable, IsCoprime, eq_iff_true_of_subsingleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Subsingleton R\nf : Polynomial R\n\u22a2 f.Separable"}, {"line": "simp [Separable, IsCoprime, eq_iff_true_of_subsingleton]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : CommSemiring R\ninst\u271d : Subsingleton R\nf : Polynomial R\n\u22a2 \u2203 a b, a * f + b * derivative f = 1"}]}
{"declaration": "theorem separable_X_add_C (a : R) : (X + C a).Separable := by\n  rw [separable_def]\n  rw [derivative_add]\n  rw [derivative_X]\n  rw [derivative_C]\n  rw [add_zero]\n  exact isCoprime_one_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 (X + C a).Separable"}, {"line": "rw [separable_def]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 IsCoprime (X + C a) (derivative (X + C a))"}, {"line": "rw [derivative_add]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 IsCoprime (X + C a) (derivative X + derivative (C a))"}, {"line": "rw [derivative_X]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 IsCoprime (X + C a) (1 + derivative (C a))"}, {"line": "rw [derivative_C]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 IsCoprime (X + C a) (1 + 0)"}, {"line": "rw [add_zero]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\na : R\n\u22a2 IsCoprime (X + C a) 1"}, {"line": "exact isCoprime_one_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem separable_X : (X : R[X]).Separable := by\n  rw [separable_def]\n  rw [derivative_X]\n  exact isCoprime_one_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\n\u22a2 X.Separable"}, {"line": "rw [separable_def]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\n\u22a2 IsCoprime X (derivative X)"}, {"line": "rw [derivative_X]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\n\u22a2 IsCoprime X 1"}, {"line": "exact isCoprime_one_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem separable_C (r : R) : (C r).Separable \u2194 IsUnit r := by\n  rw [separable_def]\n  rw [derivative_C]\n  rw [isCoprime_zero_right]\n  rw [isUnit_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nr : R\n\u22a2 (C r).Separable \u2194 IsUnit r"}, {"line": "rw [separable_def]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nr : R\n\u22a2 IsCoprime (C r) (derivative (C r)) \u2194 IsUnit r"}, {"line": "rw [derivative_C]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nr : R\n\u22a2 IsCoprime (C r) 0 \u2194 IsUnit r"}, {"line": "rw [isCoprime_zero_right]", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nr : R\n\u22a2 IsUnit (C r) \u2194 IsUnit r"}, {"line": "rw [isUnit_C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Separable.of_mul_right {f g : R[X]} (h : (f * g).Separable) : g.Separable := by\n  rw [mul_comm] at h\n  exact h.of_mul_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nf g : Polynomial R\nh : (f * g).Separable\n\u22a2 g.Separable"}, {"line": "rw [mul_comm] at h", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nf g : Polynomial R\nh : (g * f).Separable\n\u22a2 g.Separable"}, {"line": "exact h.of_mul_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Separable.of_dvd {f g : R[X]} (hf : f.Separable) (hfg : g \u2223 f) : g.Separable := by\n  rcases hfg with \u27e8f', rfl\u27e9\n  exact Separable.of_mul_left hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommSemiring R\nf g : Polynomial R\nhf : f.Separable\nhfg : g \u2223 f\n\u22a2 g.Separable"}, {"line": "rcases hfg with \u27e8f', rfl\u27e9", "tactic_state": "case intro\nR : Type u\ninst\u271d : CommSemiring R\ng f' : Polynomial R\nhf : (g * f').Separable\n\u22a2 g.Separable"}, {"line": "exact Separable.of_mul_left hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Separable.mul {f g : R[X]} (hf : f.Separable) (hg : g.Separable) (h : IsCoprime f g) :\n    (f * g).Separable := by\n  rw [separable_def]\n  rw [derivative_mul]\n  exact\n    ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]", "(p q : \u2115)", "{R : Type u} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf g : Polynomial R\nhf : f.Separable\nhg : g.Separable\nh : IsCoprime f g\n\u22a2 (f * g).Separable"}, {"line": "rw [separable_def]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf g : Polynomial R\nhf : f.Separable\nhg : g.Separable\nh : IsCoprime f g\n\u22a2 IsCoprime (f * g) (derivative (f * g))"}, {"line": "rw [derivative_mul]", "tactic_state": "R : Type u\ninst\u271d : CommRing R\nf g : Polynomial R\nhf : f.Separable\nhg : g.Separable\nh : IsCoprime f g\n\u22a2 IsCoprime (f * g) (derivative f * g + f * derivative g)"}, {"line": "exact\n    ((hf.mul_right h).add_mul_left_right _).mul_left ((h.symm.mul_right hg).mul_add_right_right _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSeparable.isIntegral {x : K} (h : IsSeparable F x) : IsIntegral F x := by\n  cases subsingleton_or_nontrivial F\n  \u00b7 haveI := Module.subsingleton F K\n    exact \u27e81, monic_one, Subsingleton.elim _ _\u27e9\n  \u00b7 exact of_not_not (h.ne_zero <| minpoly.eq_zero \u00b7)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Separable.lean", "context": {"open": ["Polynomial Finset", "scoped Function in -- required for scoped `on` notation", "Polynomial"], "variables": ["{R : Type u} [CommSemiring R] {S : Type v} [CommSemiring S]", "(p q : \u2115)", "{R : Type u} [CommRing R]", "{R : Type u} [CommRing R] [IsDomain R]", "{F : Type u} [Field F] {K : Type v} [Field K]", "(p : \u2115) [HF : CharP F p]", "{i : F \u2192+* K}", "(F L K : Type*) [CommRing F] [Ring K] [Algebra F K]", "{K} in", "{K}", "{F} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nK : Type u_3\ninst\u271d\u00b2 : CommRing F\ninst\u271d\u00b9 : Ring K\ninst\u271d : Algebra F K\nx : K\nh : IsSeparable F x\n\u22a2 IsIntegral F x"}, {"line": "cases subsingleton_or_nontrivial F", "tactic_state": "case inl\nF : Type u_1\nK : Type u_3\ninst\u271d\u00b2 : CommRing F\ninst\u271d\u00b9 : Ring K\ninst\u271d : Algebra F K\nx : K\nh : IsSeparable F x\nh\u271d : Subsingleton F\n\u22a2 IsIntegral F x\n---\ncase inr\nF : Type u_1\nK : Type u_3\ninst\u271d\u00b2 : CommRing F\ninst\u271d\u00b9 : Ring K\ninst\u271d : Algebra F K\nx : K\nh : IsSeparable F x\nh\u271d : Nontrivial F\n\u22a2 IsIntegral F x"}, {"line": "\u00b7 haveI := Module.subsingleton F K\n    exact \u27e81, monic_one, Subsingleton.elim _ _\u27e9", "tactic_state": "case inr\nF : Type u_1\nK : Type u_3\ninst\u271d\u00b2 : CommRing F\ninst\u271d\u00b9 : Ring K\ninst\u271d : Algebra F K\nx : K\nh : IsSeparable F x\nh\u271d : Nontrivial F\n\u22a2 IsIntegral F x"}, {"line": "\u00b7 exact of_not_not (h.ne_zero <| minpoly.eq_zero \u00b7)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem separableClosure.map_eq_of_separableClosure_eq_bot [Algebra E K] [IsScalarTower F E K]\n    (h : separableClosure E K = \u22a5) :\n    (separableClosure F E).map (IsScalarTower.toAlgHom F E K) = separableClosure F K := by\n  refine le_antisymm (map_le_of_algHom _) (fun x hx \u21a6 ?_)\n  obtain \u27e8y, rfl\u27e9 := mem_bot.1 <| h \u25b8 mem_separableClosure_iff.2\n    (IsSeparable.tower_top E <| mem_separableClosure_iff.1 hx)\n  exact \u27e8y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E K}", "(F) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : separableClosure E K = \u22a5\n\u22a2 IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E) = separableClosure F K"}, {"line": "refine le_antisymm (map_le_of_algHom _) (fun x hx \u21a6 ?_)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : separableClosure E K = \u22a5\nx : K\nhx : x \u2208 separableClosure F K\n\u22a2 x \u2208 IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E)"}, {"line": "obtain \u27e8y, rfl\u27e9 := mem_bot.1 <| h \u25b8 mem_separableClosure_iff.2\n    (IsSeparable.tower_top E <| mem_separableClosure_iff.1 hx)", "tactic_state": "case intro\nF : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\nh : separableClosure E K = \u22a5\ny : E\nhx : (algebraMap E K) y \u2208 separableClosure F K\n\u22a2 (algebraMap E K) y \u2208 IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E)"}, {"line": "exact \u27e8y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finInsepDegree_eq_of_equiv (i : E \u2243\u2090[F] K) :\n    finInsepDegree F E = finInsepDegree F K := by\n  simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat\n    (lift_insepDegree_eq_of_equiv F E K i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E K}", "(F) in", "(F E K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2074 : Field F\ninst\u271d\u00b3 : Field E\ninst\u271d\u00b2 : Algebra F E\nK : Type w\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra F K\ni : E \u2243\u2090[F] K\n\u22a2 finInsepDegree F E = finInsepDegree F K"}, {"line": "simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat\n    (lift_insepDegree_eq_of_equiv F E K i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finInsepDegree_self : finInsepDegree F F = 1 := by\n  rw [finInsepDegree_def']\n  rw [insepDegree_self]\n  rw [Cardinal.one_toNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E K}", "(F) in", "(F E K)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\ninst\u271d : Field F\n\u22a2 finInsepDegree F F = 1"}, {"line": "rw [finInsepDegree_def']", "tactic_state": "F : Type u\ninst\u271d : Field F\n\u22a2 Cardinal.toNat (insepDegree F F) = 1"}, {"line": "rw [insepDegree_self]", "tactic_state": "F : Type u\ninst\u271d : Field F\n\u22a2 Cardinal.toNat 1 = 1"}, {"line": "rw [Cardinal.one_toNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finInsepDegree_bot' :\n    finInsepDegree F (\u22a5 : IntermediateField E K) = finInsepDegree F E := by\n  simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat (lift_insepDegree_bot' F E K)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E K}", "(F) in", "(F E K)", "[Algebra E K] [IsScalarTower F E K]", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\n\u22a2 finInsepDegree F \u21a5\u22a5 = finInsepDegree F E"}, {"line": "simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat (lift_insepDegree_bot' F E K)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finInsepDegree_top : finInsepDegree F (\u22a4 : IntermediateField E K) = finInsepDegree F K := by\n  rw [finInsepDegree_def']\n  rw [insepDegree_top]\n  rw [\u2190 finInsepDegree_def']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableClosure.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E K}", "(F) in", "(F E K)", "[Algebra E K] [IsScalarTower F E K]", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\n\u22a2 finInsepDegree F \u21a5\u22a4 = finInsepDegree F K"}, {"line": "rw [finInsepDegree_def']", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\n\u22a2 Cardinal.toNat (insepDegree F \u21a5\u22a4) = finInsepDegree F K"}, {"line": "rw [insepDegree_top]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2076 : Field F\ninst\u271d\u2075 : Field E\ninst\u271d\u2074 : Algebra F E\nK : Type w\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra E K\ninst\u271d : IsScalarTower F E K\n\u22a2 Cardinal.toNat (insepDegree F K) = finInsepDegree F K"}, {"line": "rw [\u2190 finInsepDegree_def']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finSepDegree_mul_finSepDegree_of_isAlgebraic\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsAlgebraic E K] :\n    finSepDegree F E * finSepDegree E K = finSepDegree F K := by\n  simpa only [Nat.card_prod] using Nat.card_congr (embProdEmbOfIsAlgebraic F E K)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableDegree.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F}", "[Algebra E K] [IsScalarTower F E K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2079 : Field F\ninst\u271d\u2078 : Field E\ninst\u271d\u2077 : Algebra F E\nK : Type w\ninst\u271d\u2076 : Field K\ninst\u271d\u2075 : Algebra F K\ninst\u271d\u2074 : Algebra E K\ninst\u271d\u00b3 : IsScalarTower F E K\ninst\u271d\u00b2 : Algebra E K\ninst\u271d\u00b9 : IsScalarTower F E K\ninst\u271d : Algebra.IsAlgebraic E K\n\u22a2 finSepDegree F E * finSepDegree E K = finSepDegree F K"}, {"line": "simpa only [Nat.card_prod] using Nat.card_congr (embProdEmbOfIsAlgebraic F E K)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natSepDegree_eq_one_iff_eq_expand_X_sub_C : (minpoly F x).natSepDegree = 1 \u2194\n    \u2203 (n : \u2115) (y : F), minpoly F x = expand F (q ^ n) (X - C y) := by\n  refine \u27e8fun h \u21a6 ?_, fun \u27e8n, y, h\u27e9 \u21a6 ?_\u27e9\n  \u00b7 have halg : IsIntegral F x := by_contra fun h' \u21a6 by\n      simp only [eq_zero h'] at h\n      simp only [natSepDegree_zero] at h\n      simp only [zero_ne_one] at h\n    exact (minpoly.irreducible halg).natSepDegree_eq_one_iff_of_monic' q\n      (minpoly.monic halg) |>.1 h\n  rw [h]\n  rw [natSepDegree_expand _ q]\n  rw [natSepDegree_X_sub_C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableDegree.lean", "context": {"open": ["Module Polynomial IntermediateField Field", "Classical in"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F}", "[Algebra E K] [IsScalarTower F E K]", "{F E}", "(f : F[X])", "{f} in", "(E) in", "{f} in", "{f} in", "{F}", "{f : F[X]}", "{F}", "{f : F[X]}", "{F : Type u} {E : Type v} [Field F] [Ring E] [IsDomain E] [Algebra F E]", "(q : \u2115) [hF : ExpChar F q] {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\n\u22a2 (minpoly F x).natSepDegree = 1 \u2194 \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun \u27e8n, y, h\u27e9 \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nh : (minpoly F x).natSepDegree = 1\n\u22a2 \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\n---\ncase refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 (minpoly F x).natSepDegree = 1"}, {"line": "\u00b7 have halg : IsIntegral F x := by_contra fun h' \u21a6 by\n      simp only [eq_zero h'] at h\n      simp only [natSepDegree_zero] at h\n      simp only [zero_ne_one] at h\n    exact (minpoly.irreducible halg).natSepDegree_eq_one_iff_of_monic' q\n      (minpoly.monic halg) |>.1 h", "tactic_state": "case refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 (minpoly F x).natSepDegree = 1"}, {"line": "rw [h]", "tactic_state": "case refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 ((expand F (q ^ n)) (X - C y)).natSepDegree = 1"}, {"line": "rw [natSepDegree_expand _ q]", "tactic_state": "case refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 (X - C y).natSepDegree = 1\n---\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 ExpChar F q"}, {"line": "rw [natSepDegree_X_sub_C]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\nx\u271d : \u2203 n y, minpoly F x = (expand F (q ^ n)) (X - C y)\nn : \u2115\ny : F\nh : minpoly F x = (expand F (q ^ n)) (X - C y)\n\u22a2 ExpChar F q"}]}
{"declaration": "theorem IntermediateField.isSeparable_adjoin_simple_iff_isSeparable {x : E} :\n    Algebra.IsSeparable F F\u27eex\u27ef \u2194 IsSeparable F x := by\n  refine \u27e8fun _ \u21a6 ?_, fun hsep \u21a6 ?_\u27e9\n  \u00b7 exact isSeparable_of_mem_isSeparable F E <| mem_adjoin_simple_self F x\n  \u00b7 have h := IsSeparable.isIntegral hsep\n    haveI := adjoin.finiteDimensional h\n    rwa [\u2190 finSepDegree_eq_finrank_iff,\n      finSepDegree_adjoin_simple_eq_finrank_iff F E x h.isAlgebraic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableDegree.lean", "context": {"open": ["Module Polynomial IntermediateField Field", "Classical in"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F}", "[Algebra E K] [IsScalarTower F E K]", "{F E}", "(f : F[X])", "{f} in", "(E) in", "{f} in", "{f} in", "{F}", "{f : F[X]}", "{F}", "{f : F[X]}", "{F : Type u} {E : Type v} [Field F] [Ring E] [IsDomain E] [Algebra F E]", "(q : \u2115) [hF : ExpChar F q] {x : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : E\n\u22a2 sorry \u2194 IsSeparable F x"}, {"line": "refine \u27e8fun _ \u21a6 ?_, fun hsep \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : E\nx\u271d : sorry\n\u22a2 IsSeparable F x\n---\ncase refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : E\nhsep : IsSeparable F x\n\u22a2 sorry"}, {"line": "\u00b7 exact isSeparable_of_mem_isSeparable F E <| mem_adjoin_simple_self F x", "tactic_state": "case refine_2\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : E\nhsep : IsSeparable F x\n\u22a2 sorry"}, {"line": "\u00b7 have h := IsSeparable.isIntegral hsep\n    haveI := adjoin.finiteDimensional h\n    rwa [\u2190 finSepDegree_eq_finrank_iff,\n      finSepDegree_adjoin_simple_eq_finrank_iff F E x h.isAlgebraic]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparable_algebraMap (x : F) : IsSeparable F ((algebraMap F E) x) := by\n  rw [IsSeparable]\n  rw [minpoly.algebraMap_eq (algebraMap F E).injective]\n  exact Algebra.IsSeparable.isSeparable F x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SeparableDegree.lean", "context": {"open": ["Module Polynomial IntermediateField Field", "Classical in"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F}", "[Algebra E K] [IsScalarTower F E K]", "{F E}", "(f : F[X])", "{f} in", "(E) in", "{f} in", "{f} in", "{F}", "{f : F[X]}", "{F}", "{f : F[X]}", "{F : Type u} {E : Type v} [Field F] [Ring E] [IsDomain E] [Algebra F E]", "(q : \u2115) [hF : ExpChar F q] {x : E}", "{E K} in", "{F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : F\n\u22a2 IsSeparable F ((algebraMap F E) x)"}, {"line": "rw [IsSeparable]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : F\n\u22a2 (minpoly F ((algebraMap F E) x)).Separable"}, {"line": "rw [minpoly.algebraMap_eq (algebraMap F E).injective]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : F\n\u22a2 (minpoly F x).Separable\n---\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : F\n\u22a2 IsScalarTower F F E"}, {"line": "exact Algebra.IsSeparable.isSeparable F x", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Ring E\ninst\u271d\u00b9 : IsDomain E\ninst\u271d : Algebra F E\nx : F\n\u22a2 IsScalarTower F F E"}]}
{"declaration": "theorem _root_.FiniteField.splits_X_pow_nat_card_sub_X [Finite K] :\n    Splits (algebraMap (ZMod p) K) (X ^ Nat.card K - X) := by\n  haveI : Fintype K := Fintype.ofFinite K\n  rw [Nat.card_eq_fintype_card]\n  exact (FiniteField.isSplittingField_sub K (ZMod p)).splits\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/GaloisField.lean", "context": {"open": ["Polynomial Finset", "scoped Polynomial"], "variables": ["(p : \u2115) [Fact p.Prime] (n : \u2115)", "(p : \u2115) [h_prime : Fact p.Prime] (n : \u2115)", "{K : Type*} [Field K] [Fintype K] [Algebra (ZMod p) K]", "{K : Type*} [Field K] [Algebra (ZMod p) K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nK : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (ZMod p) K\ninst\u271d : Finite K\n\u22a2 Splits (algebraMap (ZMod p) K) (X ^ Nat.card K - X)"}, {"line": "haveI : Fintype K := Fintype.ofFinite K", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nK : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (ZMod p) K\ninst\u271d : Finite K\nthis : Fintype K\n\u22a2 Splits (algebraMap (ZMod p) K) (X ^ Nat.card K - X)"}, {"line": "rw [Nat.card_eq_fintype_card]", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nK : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra (ZMod p) K\ninst\u271d : Finite K\nthis : Fintype K\n\u22a2 Splits (algebraMap (ZMod p) K) (X ^ Fintype.card K - X)"}, {"line": "exact (FiniteField.isSplittingField_sub K (ZMod p)).splits", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.FiniteField.isSplittingField_of_nat_card_eq (h : Nat.card K = p ^ n) :\n    IsSplittingField (ZMod p) K (X ^ p ^ n - X) := by\n  haveI : Finite K := (Nat.card_pos_iff.mp (h \u25b8 pow_pos h_prime.1.pos n)).2\n  haveI : Fintype K := Fintype.ofFinite K\n  rw [\u2190 h]\n  rw [Nat.card_eq_fintype_card]\n  exact FiniteField.isSplittingField_sub K (ZMod p)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/GaloisField.lean", "context": {"open": ["Polynomial Finset", "scoped Polynomial"], "variables": ["(p : \u2115) [Fact p.Prime] (n : \u2115)", "(p : \u2115) [h_prime : Fact p.Prime] (n : \u2115)", "{K : Type*} [Field K] [Fintype K] [Algebra (ZMod p) K]", "{K : Type*} [Field K] [Algebra (ZMod p) K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nn : \u2115\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra (ZMod p) K\nh : Nat.card K = p ^ n\n\u22a2 IsSplittingField (ZMod p) K (X ^ p ^ n - X)"}, {"line": "haveI : Finite K := (Nat.card_pos_iff.mp (h \u25b8 pow_pos h_prime.1.pos n)).2", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nn : \u2115\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra (ZMod p) K\nh : Nat.card K = p ^ n\nthis : Finite K\n\u22a2 IsSplittingField (ZMod p) K (X ^ p ^ n - X)"}, {"line": "haveI : Fintype K := Fintype.ofFinite K", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nn : \u2115\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra (ZMod p) K\nh : Nat.card K = p ^ n\nthis\u271d : Finite K\nthis : Fintype K\n\u22a2 IsSplittingField (ZMod p) K (X ^ p ^ n - X)"}, {"line": "rw [\u2190 h]", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nn : \u2115\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra (ZMod p) K\nh : Nat.card K = p ^ n\nthis\u271d : Finite K\nthis : Fintype K\n\u22a2 IsSplittingField (ZMod p) K (X ^ Nat.card K - X)"}, {"line": "rw [Nat.card_eq_fintype_card]", "tactic_state": "p : \u2115\nh_prime : Fact (Nat.Prime p)\nn : \u2115\nK : Type u_2\ninst\u271d\u00b9 : Field K\ninst\u271d : Algebra (ZMod p) K\nh : Nat.card K = p ^ n\nthis\u271d : Finite K\nthis : Fintype K\n\u22a2 IsSplittingField (ZMod p) K (X ^ Fintype.card K - X)"}, {"line": "exact FiniteField.isSplittingField_sub K (ZMod p)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.sq_add_sq_modEq (p : \u2115) [Fact p.Prime] (x : \u2115) :\n    \u2203 a b : \u2115, a \u2264 p / 2 \u2227 b \u2264 p / 2 \u2227 a ^ 2 + b ^ 2 \u2261 x [MOD p] := by\n  simpa only [\u2190 Int.natCast_modEq_iff] using Nat.sq_add_sq_zmodEq p x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Prime p)\nx : \u2115\n\u22a2 \u2203 a b, a \u2264 p / 2 \u2227 b \u2264 p / 2 \u2227 a ^ 2 + b ^ 2 \u2261 x [MOD p]"}, {"line": "simpa only [\u2190 Int.natCast_modEq_iff] using Nat.sq_add_sq_zmodEq p x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.pow_totient {n : \u2115} (x : (ZMod n)\u02e3) : x ^ \u03c6 n = 1 := by\n  cases n\n  \u00b7 rw [Nat.totient_zero, pow_zero]\n  \u00b7 rw [\u2190 card_units_eq_totient, pow_card_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : (ZMod n)\u02e3\n\u22a2 x ^ n.totient = 1"}, {"line": "cases n", "tactic_state": "case zero\nx : (ZMod 0)\u02e3\n\u22a2 x ^ Nat.totient 0 = 1\n---\ncase succ\nn\u271d : \u2115\nx : (ZMod (n\u271d + 1))\u02e3\n\u22a2 x ^ (n\u271d + 1).totient = 1"}, {"line": "\u00b7 rw [Nat.totient_zero, pow_zero]", "tactic_state": "case succ\nn\u271d : \u2115\nx : (ZMod (n\u271d + 1))\u02e3\n\u22a2 x ^ (n\u271d + 1).totient = 1"}, {"line": "\u00b7 rw [\u2190 card_units_eq_totient, pow_card_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.ModEq.pow_totient {x n : \u2115} (h : Nat.Coprime x n) : x ^ \u03c6 n \u2261 1 [MOD n] := by\n  rw [\u2190 ZMod.eq_iff_modEq_nat]\n  let x' : Units (ZMod n) := ZMod.unitOfCoprime _ h\n  have := ZMod.pow_totient x'\n  apply_fun ((fun (x : Units (ZMod n)) => (x : ZMod n)) : Units (ZMod n) \u2192 ZMod n) at this\n  simpa only [Nat.succ_eq_add_one,Nat.cast_pow,Units.val_one,Nat.cast_one,coe_unitOfCoprime,Units.val_pow_eq_pow_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x n : \u2115\nh : x.Coprime n\n\u22a2 x ^ n.totient \u2261 1 [MOD n]"}, {"line": "rw [\u2190 ZMod.eq_iff_modEq_nat]", "tactic_state": "x n : \u2115\nh : x.Coprime n\n\u22a2 \u2191(x ^ n.totient) = \u21911"}, {"line": "let x' : Units (ZMod n) := ZMod.unitOfCoprime _ h", "tactic_state": "x n : \u2115\nh : x.Coprime n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\n\u22a2 \u2191(x ^ n.totient) = \u21911"}, {"line": "have := ZMod.pow_totient x'", "tactic_state": "x n : \u2115\nh : x.Coprime n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : x' ^ n.totient = 1\n\u22a2 \u2191(x ^ n.totient) = \u21911"}, {"line": "apply_fun ((fun (x : Units (ZMod n)) => (x : ZMod n)) : Units (ZMod n) \u2192 ZMod n) at this", "tactic_state": "x n : \u2115\nh : x.Coprime n\nx' : (ZMod n)\u02e3 := unitOfCoprime x h\nthis : \u2191(x' ^ n.totient) = \u21911\n\u22a2 \u2191(x ^ n.totient) = \u21911"}, {"line": "simpa only [Nat.succ_eq_add_one,Nat.cast_pow,Units.val_one,Nat.cast_one,coe_unitOfCoprime,Units.val_pow_eq_pow_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frobenius_zmod (p : \u2115) [Fact p.Prime] : frobenius (ZMod p) p = RingHom.id _ := by\n  ext a\n  rw [frobenius_def]\n  rw [ZMod.pow_card]\n  rw [RingHom.id_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 frobenius (ZMod p) p = RingHom.id (ZMod p)"}, {"line": "ext a", "tactic_state": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 (frobenius (ZMod p) p) a = (RingHom.id (ZMod p)) a"}, {"line": "rw [frobenius_def]", "tactic_state": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 a ^ p = (RingHom.id (ZMod p)) a"}, {"line": "rw [ZMod.pow_card]", "tactic_state": "case a\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 a = (RingHom.id (ZMod p)) a"}, {"line": "rw [RingHom.id_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_card_sub_one (a : ZMod p) :\n    a ^ (p - 1) = if a \u2260 0 then 1 else 0 := by\n  split_ifs with ha\n  \u00b7 exact pow_card_sub_one_eq_one ha\n  \u00b7 simp [of_not_not ha, (Fact.out : p.Prime).one_lt, tsub_eq_zero_iff_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\n\u22a2 a ^ (p - 1) = if a \u2260 0 then 1 else 0"}, {"line": "split_ifs with ha", "tactic_state": "case pos\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : a \u2260 0\n\u22a2 a ^ (p - 1) = 1\n---\ncase neg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : \u00aca \u2260 0\n\u22a2 a ^ (p - 1) = 0"}, {"line": "\u00b7 exact pow_card_sub_one_eq_one ha", "tactic_state": "case neg\np : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : ZMod p\nha : \u00aca \u2260 0\n\u22a2 a ^ (p - 1) = 0"}, {"line": "\u00b7 simp [of_not_not ha, (Fact.out : p.Prime).one_lt, tsub_eq_zero_iff_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.ModEq.pow_card_sub_one_eq_one {p : \u2115} (hp : Nat.Prime p) {n : \u2124} (hpn : IsCoprime n p) :\n    n ^ (p - 1) \u2261 1 [ZMOD p] := by\n  haveI : Fact p.Prime := \u27e8hp\u27e9\n  have : \u00ac(n : ZMod p) = 0 := by\n    rw [CharP.intCast_eq_zero_iff _ p]\n    rw [\u2190 (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]\n    \u00b7 exact hpn.symm\n  simpa [\u2190 ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField", "Polynomial"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nn : \u2124\nhpn : IsCoprime n \u2191p\n\u22a2 n ^ (p - 1) \u2261 1 [ZMOD \u2191p]"}, {"line": "haveI : Fact p.Prime := \u27e8hp\u27e9", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nn : \u2124\nhpn : IsCoprime n \u2191p\nthis : Fact (Nat.Prime p)\n\u22a2 n ^ (p - 1) \u2261 1 [ZMOD \u2191p]"}, {"line": "have : \u00ac(n : ZMod p) = 0 := by\n    rw [CharP.intCast_eq_zero_iff _ p]\n    rw [\u2190 (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd]\n    \u00b7 exact hpn.symm", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nn : \u2124\nhpn : IsCoprime n \u2191p\nthis\u271d : Fact (Nat.Prime p)\nthis : \u00ac\u2191n = 0\n\u22a2 n ^ (p - 1) \u2261 1 [ZMOD \u2191p]"}, {"line": "simpa [\u2190 ZMod.intCast_eq_intCast_iff] using ZMod.pow_card_sub_one_eq_one this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ZMod.eq_one_or_isUnit_sub_one {n p k : \u2115} [Fact p.Prime] (hn : n = p ^ k) (a : ZMod n)\n    (ha : (orderOf a).Coprime n) : a = 1 \u2228 IsUnit (a - 1) := by\n  rcases eq_or_ne n 0 with rfl | hn0\n  \u00b7 exact Or.inl (orderOf_eq_one_iff.mp ((orderOf a).coprime_zero_right.mp ha))\n  rcases eq_or_ne a 0 with rfl | ha0\n  \u00b7 exact Or.inr (zero_sub (1 : ZMod n) \u25b8 isUnit_neg_one)\n  have : NeZero n := \u27e8hn0\u27e9\n  obtain \u27e8a, rfl\u27e9 := ZMod.natCast_zmod_surjective a\n  rw [\u2190 orderOf_eq_one_iff]\n  rw [or_iff_not_imp_right]\n  refine fun h \u21a6 ha.eq_one_of_dvd ?_\n  rw [orderOf_dvd_iff_pow_eq_one]\n  rw [\u2190 Nat.cast_pow]\n  rw [\u2190 Nat.cast_one]\n  rw [ZMod.eq_iff_modEq_nat]\n  rw [hn]\n  replace ha0 : 1 \u2264 a := by\n    contrapose! ha0\n    rw [Nat.lt_one_iff.mp ha0]\n    rw [Nat.cast_zero]\n  rw [\u2190 Nat.cast_one] at h\n  rw [\u2190 Nat.cast_sub ha0] at h\n  rw [ZMod.isUnit_iff_coprime] at h\n  rw [hn] at h\n  obtain \u27e8b, hb\u27e9 := not_imp_comm.mp (Nat.Prime.coprime_pow_of_not_dvd Fact.out) h\n  rw [tsub_eq_iff_eq_add_of_le ha0] at hb\n  rw [add_comm] at hb\n  exact hb \u25b8 pow_pow_modEq_one p k b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Finite/Basic.lean", "context": {"open": ["Finset", "scoped Polynomial", "Polynomial", "Polynomial in", "Polynomial", "Polynomial", "FiniteField Polynomial", "scoped Nat", "ZMod", "FiniteField", "Polynomial"], "variables": ["{K : Type*} {R : Type*}", "[CommRing R] [IsDomain R]", "[GroupWithZero K] [Fintype K]", "(K) [Field K] [Fintype K]", "(R) [CommRing R] [Algebra K R]", "(L : Type*) [Field L] [Algebra K L]", "[Finite L]", "[Fintype K] (K' : Type*) [Field K'] {p n : \u2115}", "{K}", "{p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "rcases eq_or_ne n 0 with rfl | hn0", "tactic_state": "case inl\np k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : 0 = p ^ k\na : ZMod 0\nha : (orderOf a).Coprime 0\n\u22a2 a = 1 \u2228 IsUnit (a - 1)\n---\ncase inr\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\nhn0 : n \u2260 0\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "\u00b7 exact Or.inl (orderOf_eq_one_iff.mp ((orderOf a).coprime_zero_right.mp ha))", "tactic_state": "case inr\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\nhn0 : n \u2260 0\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "rcases eq_or_ne a 0 with rfl | ha0", "tactic_state": "case inr.inl\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nha : (orderOf 0).Coprime n\n\u22a2 0 = 1 \u2228 IsUnit (0 - 1)\n---\ncase inr.inr\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\nhn0 : n \u2260 0\nha0 : a \u2260 0\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "\u00b7 exact Or.inr (zero_sub (1 : ZMod n) \u25b8 isUnit_neg_one)", "tactic_state": "case inr.inr\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\nhn0 : n \u2260 0\nha0 : a \u2260 0\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "have : NeZero n := \u27e8hn0\u27e9", "tactic_state": "case inr.inr\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\na : ZMod n\nha : (orderOf a).Coprime n\nhn0 : n \u2260 0\nha0 : a \u2260 0\nthis : NeZero n\n\u22a2 a = 1 \u2228 IsUnit (a - 1)"}, {"line": "obtain \u27e8a, rfl\u27e9 := ZMod.natCast_zmod_surjective a", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\n\u22a2 \u2191a = 1 \u2228 IsUnit (\u2191a - 1)"}, {"line": "rw [\u2190 orderOf_eq_one_iff]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\n\u22a2 orderOf \u2191a = 1 \u2228 IsUnit (\u2191a - 1)"}, {"line": "rw [or_iff_not_imp_right]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\n\u22a2 \u00acIsUnit (\u2191a - 1) \u2192 orderOf \u2191a = 1"}, {"line": "refine fun h \u21a6 ha.eq_one_of_dvd ?_", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 orderOf \u2191a \u2223 n"}, {"line": "rw [orderOf_dvd_iff_pow_eq_one]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 \u2191a ^ n = 1"}, {"line": "rw [\u2190 Nat.cast_pow]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 \u2191(a ^ n) = 1"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 \u2191(a ^ n) = \u21911"}, {"line": "rw [ZMod.eq_iff_modEq_nat]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 a ^ n \u2261 1 [MOD n]"}, {"line": "rw [hn]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nha0 : \u2191a \u2260 0\nh : \u00acIsUnit (\u2191a - 1)\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "replace ha0 : 1 \u2264 a := by\n    contrapose! ha0\n    rw [Nat.lt_one_iff.mp ha0]\n    rw [Nat.cast_zero]", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00acIsUnit (\u2191a - 1)\nha0 : 1 \u2264 a\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [\u2190 Nat.cast_one] at h", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00acIsUnit (\u2191a - \u21911)\nha0 : 1 \u2264 a\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [\u2190 Nat.cast_sub ha0] at h", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00acIsUnit \u2191(a - 1)\nha0 : 1 \u2264 a\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [ZMod.isUnit_iff_coprime] at h", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00ac(a - 1).Coprime n\nha0 : 1 \u2264 a\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [hn] at h", "tactic_state": "case inr.inr.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00ac(a - 1).Coprime (p ^ k)\nha0 : 1 \u2264 a\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "obtain \u27e8b, hb\u27e9 := not_imp_comm.mp (Nat.Prime.coprime_pow_of_not_dvd Fact.out) h", "tactic_state": "case inr.inr.intro.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00ac(a - 1).Coprime (p ^ k)\nha0 : 1 \u2264 a\nb : \u2115\nhb : a - 1 = p * b\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [tsub_eq_iff_eq_add_of_le ha0] at hb", "tactic_state": "case inr.inr.intro.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00ac(a - 1).Coprime (p ^ k)\nha0 : 1 \u2264 a\nb : \u2115\nhb : a = p * b + 1\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "rw [add_comm] at hb", "tactic_state": "case inr.inr.intro.intro\nn p k : \u2115\ninst\u271d : Fact (Nat.Prime p)\nhn : n = p ^ k\nhn0 : n \u2260 0\nthis : NeZero n\na : \u2115\nha : (orderOf \u2191a).Coprime n\nh : \u00ac(a - 1).Coprime (p ^ k)\nha0 : 1 \u2264 a\nb : \u2115\nhb : a = 1 + p * b\n\u22a2 a ^ p ^ k \u2261 1 [MOD p ^ k]"}, {"line": "exact hb \u25b8 pow_pow_modEq_one p k b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGalois_iff_isGalois_bot : IsGalois (\u22a5 : IntermediateField F E) E \u2194 IsGalois F E := by\n  constructor\n  \u00b7 intro h\n    exact IsGalois.tower_top_of_isGalois (\u22a5 : IntermediateField F E) F E\n  \u00b7 intro h; infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\nE : Type u_5\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 IsGalois (\u21a5\u22a5) E \u2194 IsGalois F E"}, {"line": "constructor", "tactic_state": "case mp\nF : Type u_3\nE : Type u_5\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 IsGalois (\u21a5\u22a5) E \u2192 IsGalois F E\n---\ncase mpr\nF : Type u_3\nE : Type u_5\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 IsGalois F E \u2192 IsGalois (\u21a5\u22a5) E"}, {"line": "\u00b7 intro h\n    exact IsGalois.tower_top_of_isGalois (\u22a5 : IntermediateField F E) F E", "tactic_state": "case mpr\nF : Type u_3\nE : Type u_5\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 IsGalois F E \u2192 IsGalois (\u21a5\u22a5) E"}, {"line": "\u00b7 intro h; infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_fixedField_iff (x) :\n    x \u2208 fixedField H \u2194 \u2200 f \u2208 H, f x = x := by\n  show x \u2208 MulAction.fixedPoints H E \u2194 _\n  simp only [MulAction.mem_fixedPoints]\n  simp only [Subtype.forall]\n  simp only [Subgroup.mk_smul]\n  simp only [AlgEquiv.smul_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 x \u2208 fixedField H \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "show x \u2208 MulAction.fixedPoints H E \u2194 _", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 x \u2208 MulAction.fixedPoints (\u21a5H) E \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "simp only [MulAction.mem_fixedPoints]", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 (\u2200 (m : \u21a5H), m \u2022 x = x) \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "simp only [Subtype.forall]", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 (\u2200 (a : E \u2243\u2090[F] E) (b : a \u2208 H), \u27e8a, b\u27e9 \u2022 x = x) \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "simp only [Subgroup.mk_smul]", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nH : Subgroup (E \u2243\u2090[F] E)\nx : E\n\u22a2 (\u2200 a \u2208 H, a \u2022 x = x) \u2194 \u2200 f \u2208 H, f x = x"}, {"line": "simp only [AlgEquiv.smul_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma fixingSubgroup_anti : Antitone (IntermediateField.fixingSubgroup (F := F) (E := E)) := by\n  intro K K' h\n  rw [\u2190 le_iff_le]\n  exact le_trans h ((le_iff_le _ _).mpr (le_refl K'.fixingSubgroup))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u22a2 Antitone IntermediateField.fixingSubgroup"}, {"line": "intro K K' h", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nK K' : IntermediateField F E\nh : K \u2264 K'\n\u22a2 K'.fixingSubgroup \u2264 K.fixingSubgroup"}, {"line": "rw [\u2190 le_iff_le]", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nK K' : IntermediateField F E\nh : K \u2264 K'\n\u22a2 K \u2264 fixedField K'.fixingSubgroup"}, {"line": "exact le_trans h ((le_iff_le _ _).mpr (le_refl K'.fixingSubgroup))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IntermediateField.restrictNormalHom_ker (E : IntermediateField K L) [Normal K E] :\n    (restrictNormalHom E).ker = E.fixingSubgroup := by\n  simp [fixingSubgroup, Subgroup.ext_iff, AlgEquiv.ext_iff, Subtype.ext_iff,\n    restrictNormalHom_apply, mem_fixingSubgroup_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField", "IntermediateField", "scoped Pointwise"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)", "{K L : Type*} [Field K] [Field L] [Algebra K L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_9\nL : Type u_10\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\nE : IntermediateField K L\ninst\u271d : Normal K \u21a5E\n\u22a2 (restrictNormalHom \u21a5E).ker = E.fixingSubgroup"}, {"line": "simp [fixingSubgroup, Subgroup.ext_iff, AlgEquiv.ext_iff, Subtype.ext_iff,\n    restrictNormalHom_apply, mem_fixingSubgroup_iff]", "tactic_state": "K : Type u_9\nL : Type u_10\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\nE : IntermediateField K L\ninst\u271d : Normal K \u21a5E\n\u22a2 \u2200 (x : L \u2243\u2090[K] L), (\u2200 a \u2208 E, x a = a) \u2194 x \u2208 _root_.fixingSubgroup (L \u2243\u2090[K] L) \u2191E"}]}
{"declaration": "theorem of_fixedField_eq_bot [FiniteDimensional F E]\n    (h : IntermediateField.fixedField (\u22a4 : Subgroup (E \u2243\u2090[F] E)) = \u22a5) : IsGalois F E := by\n  rw [\u2190 isGalois_iff_isGalois_bot]\n  rw [\u2190 h]\n  classical exact IsGalois.of_fixed_field E (\u22a4 : Subgroup (E \u2243\u2090[F] E))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Galois/Basic.lean", "context": {"open": ["scoped Polynomial IntermediateField", "Module AlgEquiv IntermediateField", "IntermediateField", "scoped Pointwise", "scoped Pointwise"], "variables": ["(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]", "{F E}", "(F E)", "{E}", "(E)", "(F K E : Type*) [Field F] [Field K] [Field E] {E' : Type*} [Field E'] [Algebra F E']", "[Algebra F K] [Algebra F E] [Algebra K E] [IsScalarTower F K E]", "{F E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(H : Subgroup (E \u2243\u2090[F] E)) (K : IntermediateField F E)", "{K L : Type*} [Field K] [Field L] [Algebra K L]", "(E : IntermediateField K L)", "(F : Type*) [Field F] (E : Type*) [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_11\ninst\u271d\u00b3 : Field F\nE : Type u_12\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : FiniteDimensional F E\nh : fixedField \u22a4 = \u22a5\n\u22a2 IsGalois F E"}, {"line": "rw [\u2190 isGalois_iff_isGalois_bot]", "tactic_state": "F : Type u_11\ninst\u271d\u00b3 : Field F\nE : Type u_12\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : FiniteDimensional F E\nh : fixedField \u22a4 = \u22a5\n\u22a2 IsGalois (\u21a5\u22a5) E"}, {"line": "rw [\u2190 h]", "tactic_state": "F : Type u_11\ninst\u271d\u00b3 : Field F\nE : Type u_12\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : FiniteDimensional F E\nh : fixedField \u22a4 = \u22a5\n\u22a2 IsGalois (\u21a5(fixedField \u22a4)) E"}, {"line": "classical exact IsGalois.of_fixed_field E (\u22a4 : Subgroup (E \u2243\u2090[F] E))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_mem (n : \u2115) : (n : L) \u2208 S := by simpa using intCast_mem S n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(K L L' : Type*) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']", "{K L L'}", "(S : IntermediateField K L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\nS : IntermediateField K L\nn : \u2115\n\u22a2 \u2191n \u2208 S"}, {"line": "simpa using intCast_mem S n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_sum {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b9 \u2192 S) : (\u2191(\u2211 i, f i) : L) = \u2211 i, (f i : L) := by\n  classical\n    induction' (Finset.univ : Finset \u03b9) using Finset.induction_on with i s hi H\n    \u00b7 simp\n    \u00b7 rw [Finset.sum_insert hi, AddMemClass.coe_add, H, Finset.sum_insert hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(K L L' : Type*) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']", "{K L L'}", "(S : IntermediateField K L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\nS : IntermediateField K L\n\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \u21a5S\n\u22a2 \u2191(\u2211 i, f i) = \u2211 i, \u2191(f i)"}, {"line": "classical\n    induction' (Finset.univ : Finset \u03b9) using Finset.induction_on with i s hi H\n    \u00b7 simp\n    \u00b7 rw [Finset.sum_insert hi, AddMemClass.coe_add, H, Finset.sum_insert hi]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_prod {\u03b9 : Type*} [Fintype \u03b9] (f : \u03b9 \u2192 S) : (\u2191(\u220f i, f i) : L) = \u220f i, (f i : L) := by\n  classical\n    induction' (Finset.univ : Finset \u03b9) using Finset.induction_on with i s hi H\n    \u00b7 simp\n    \u00b7 rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(K L L' : Type*) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']", "{K L L'}", "(S : IntermediateField K L)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\ninst\u271d\u00b3 : Field K\ninst\u271d\u00b2 : Field L\ninst\u271d\u00b9 : Algebra K L\nS : IntermediateField K L\n\u03b9 : Type u_4\ninst\u271d : Fintype \u03b9\nf : \u03b9 \u2192 \u21a5S\n\u22a2 \u2191(\u220f i, f i) = \u220f i, \u2191(f i)"}, {"line": "classical\n    induction' (Finset.univ : Finset \u03b9) using Finset.induction_on with i s hi H\n    \u00b7 simp\n    \u00b7 rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]", "tactic_state": "No Goals!"}]}
{"declaration": "example {F : IntermediateField K L} {E : IntermediateField F L} : Algebra K E := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Basic.lean", "context": {"open": ["Polynomial"], "variables": ["(K L L' : Type*) [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']", "{K L L'}", "(S : IntermediateField K L)", "{X Y}", "{E} [Field E] [Algebra L E] (T : IntermediateField S E) {S}", "(f : L \u2192\u2090[K] L')", "{f}", "{S}", "{F E : IntermediateField K L}", "(S)", "{S}", "(K)", "[Algebra L' L] [IsScalarTower K L' L]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst\u271d\u2078 : Field K\ninst\u271d\u2077 : Field L\ninst\u271d\u2076 : Field L'\ninst\u271d\u2075 : Algebra K L\ninst\u271d\u2074 : Algebra K L'\nS : IntermediateField K L\nX : ?m.12081\nY : ?m.12084\nE\u271d\u00b9 : Type ?u.12090\ninst\u271d\u00b3 : Field E\u271d\u00b9\ninst\u271d\u00b2 : Algebra L E\u271d\u00b9\nT : IntermediateField (\u21a5S) E\u271d\u00b9\nf : L \u2192\u2090[K] L'\nF\u271d E\u271d : IntermediateField K L\ninst\u271d\u00b9 : Algebra L' L\ninst\u271d : IsScalarTower K L' L\nF : IntermediateField K L\nE : IntermediateField (\u21a5F) L\n\u22a2 Algebra K \u21a5E"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fg_of_fg_toSubalgebra (S : IntermediateField F E) (h : S.toSubalgebra.FG) : S.FG := by\n  obtain \u27e8t, ht\u27e9 := h\n  exact \u27e8t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Algebra.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "(\u03b1 : E)", "{F} {\u03b1}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "(E)", "{K : Type*} [Field K] [Algebra F K] [Algebra E K] [IsScalarTower F E K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_6\ninst\u271d\u00b2 : Field F\nE : Type u_7\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : IntermediateField F E\nh : S.FG\n\u22a2 S.FG"}, {"line": "obtain \u27e8t, ht\u27e9 := h", "tactic_state": "case intro\nF : Type u_6\ninst\u271d\u00b2 : Field F\nE : Type u_7\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nS : IntermediateField F E\nt : Finset E\nht : Algebra.adjoin F \u2191t = S.toSubalgebra\n\u22a2 S.FG"}, {"line": "exact \u27e8t, (eq_adjoin_of_eq_algebra_adjoin _ _ _ ht.symm).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toSubalgebra_iSup_of_directed (dir : Directed (\u00b7 \u2264 \u00b7) t) :\n    (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 simp_rw [iSup_of_empty, bot_toSubalgebra]\n  \u00b7 exact SetLike.ext' ((coe_iSup_of_directed dir).trans (Subalgebra.coe_iSup_of_directed dir).symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {S : Set E}", "{F}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "{\u03b9 : Type*} {t : \u03b9 \u2192 IntermediateField K L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : IsEmpty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra\n---\ncase inr\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : Nonempty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "\u00b7 simp_rw [iSup_of_empty, bot_toSubalgebra]", "tactic_state": "case inr\nK : Type u_3\nL : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Field L\ninst\u271d : Algebra K L\n\u03b9 : Type u_5\nt : \u03b9 \u2192 IntermediateField K L\ndir : Directed (fun x1 x2 => x1 \u2264 x2) t\nh\u271d : Nonempty \u03b9\n\u22a2 (iSup t).toSubalgebra = \u2a06 i, (t i).toSubalgebra"}, {"line": "\u00b7 exact SetLike.ext' ((coe_iSup_of_directed dir).trans (Subalgebra.coe_iSup_of_directed dir).symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinalMk_adjoin_le {E : Type u} [Field E] [Algebra F E] (s : Set E) :\n    #(adjoin F s) \u2264 #F \u2294 #s \u2294 \u2135\u2080 := by\n  simpa using lift_cardinalMk_adjoin_le F s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Basic.lean", "context": {"open": ["Module Polynomial", "Set CompleteLattice", "Module Module", "Module AdjoinRoot in", "AlgEquiv", "IntermediateField", "IntermediateField", "Cardinal"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {S : Set E}", "{F}", "{K L : Type*} [Field K] [Field L] [Algebra K L] (E1 E2 : IntermediateField K L)", "{\u03b9 : Type*} {t : \u03b9 \u2192 IntermediateField K L}", "(E)", "{K : Type*} [Field K] [Algebra F K] [Algebra E K] [IsScalarTower F E K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E} {S : Set E}", "{K L : IntermediateField F E}", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E}", "{K : Type u} [Field K] [Algebra F K]", "{L : Type*} [Field L] [Algebra K L]", "{F} in", "{K L : Type _} [Field K] [Field L] [Algebra K L]", "{K L : Type*} [Field K] [Field L] [Algebra K L]", "(F : Type u) [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\ninst\u271d\u00b2 : Field F\nE : Type u\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\ns : Set E\n\u22a2 Cardinal.mk \u21a5(adjoin F s) \u2264 max (max (Cardinal.mk F) (Cardinal.mk \u2191s)) aleph0"}, {"line": "simpa using lift_cardinalMk_adjoin_le F s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_iInf {\u03b9 : Sort*} (S : \u03b9 \u2192 IntermediateField F E) : (\u2191(iInf S) : Set E) = \u22c2 i, S i := by\n  simp [iInf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u00b2 : Field F\nE : Type u_2\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\n\u03b9 : Sort u_3\nS : \u03b9 \u2192 IntermediateField F E\n\u22a2 \u2191(iInf S) = \u22c2 i, \u2191(S i)"}, {"line": "simp [iInf]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem botEquiv_def (x : F) : botEquiv F E (algebraMap F (\u22a5 : IntermediateField F E) x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx\u271d : Sort u_3\nbotEquiv : x\u271d\nx : F\n\u22a2 sorry = x"}, {"line": "simp", "tactic_state": "F : Type u_1\ninst\u271d : Field F\nx\u271d : Sort u_3\nbotEquiv : x\u271d\nx : F\n\u22a2 sorry () = x"}]}
{"declaration": "theorem map_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : E \u2192\u2090[F] K) (s : \u03b9 \u2192 IntermediateField F E) :\n    (iInf s).map f = \u2a05 i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective f.injective).image_iInter_eq (s := SetLike.coe \u2218 s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}", "{K : Type*} [Field K] [Algebra K E] [Algebra K F] [IsScalarTower K F E]", "(K)", "(L L' : IntermediateField F E)", "{K : Type*} [Field K] [Algebra F K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\ninst\u271d\u2075 : Field F\nE : Type u_2\ninst\u271d\u2074 : Field E\ninst\u271d\u00b3 : Algebra F E\nK : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra F K\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nf : E \u2192\u2090[F] K\ns : \u03b9 \u2192 IntermediateField F E\n\u22a2 IntermediateField.map f (iInf s) = \u2a05 i, IntermediateField.map f (s i)"}, {"line": "apply SetLike.coe_injective", "tactic_state": "case a\nF : Type u_1\ninst\u271d\u2075 : Field F\nE : Type u_2\ninst\u271d\u2074 : Field E\ninst\u271d\u00b3 : Algebra F E\nK : Type u_4\ninst\u271d\u00b2 : Field K\ninst\u271d\u00b9 : Algebra F K\n\u03b9 : Sort u_5\ninst\u271d : Nonempty \u03b9\nf : E \u2192\u2090[F] K\ns : \u03b9 \u2192 IntermediateField F E\n\u22a2 \u2191(IntermediateField.map f (iInf s)) = \u2191(\u2a05 i, IntermediateField.map f (s i))"}, {"line": "simpa using (Set.injOn_of_injective f.injective).image_iInter_eq (s := SetLike.coe \u2218 s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjoin.range_algebraMap_subset : Set.range (algebraMap F E) \u2286 adjoin F S := by\n  intro x hx\n  obtain \u27e8f, hf\u27e9 := hx\n  rw [\u2190 hf]\n  exact adjoin.algebraMap_mem F S f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}", "{K : Type*} [Field K] [Algebra K E] [Algebra K F] [IsScalarTower K F E]", "(K)", "(L L' : IntermediateField F E)", "{K : Type*} [Field K] [Algebra F K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\n\u22a2 Set.range \u21d1(algebraMap F E) \u2286 sorry"}, {"line": "intro x hx", "tactic_state": "F : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nhx : x \u2208 Set.range \u21d1(algebraMap F E)\n\u22a2 x \u2208 sorry"}, {"line": "obtain \u27e8f, hf\u27e9 := hx", "tactic_state": "case intro\nF : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nf : F\nhf : (algebraMap F E) f = x\n\u22a2 x \u2208 sorry"}, {"line": "rw [\u2190 hf]", "tactic_state": "case intro\nF : Type u_7\ninst\u271d\u00b2 : Field F\nE : Type u_8\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx\u271d : Sort u_9\nadjoin : x\u271d\nx : E\nf : F\nhf : (algebraMap F E) f = x\n\u22a2 (algebraMap F E) f \u2208 sorry"}, {"line": "exact adjoin.algebraMap_mem F S f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_comap_eq_self {f : L \u2192\u2090[K] L'} {S : IntermediateField K L'} (h : S \u2264 f.fieldRange) :\n    (S.comap f).map f = S := by\n  simpa only [inf_of_le_left h] using map_comap_eq f S\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IntermediateField/Adjoin/Defs.lean", "context": {"open": ["Module Polynomial", "Lean in", "Lean PrettyPrinter.Delaborator SubExpr in"], "variables": ["(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F S} in", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F E)", "{F E}", "{K : Type*} [Field K] [Algebra K E] [Algebra K F] [IsScalarTower K F E]", "(K)", "(L L' : IntermediateField F E)", "{K : Type*} [Field K] [Algebra F K]", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "(F : Type*) [Field F] {E : Type*} [Field E] [Algebra F E] (S : Set E)", "{F} in", "{F} in", "{K : Type*} [Semiring K] [Algebra F K]", "(\u03b1 : E)", "{F} {\u03b1}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E] {\u03b1 : E} {S : Set E}", "{F : Type*} [Field F] {E : Type*} [Field E] [Algebra F E]", "{K L L' : Type*} [Field K] [Field L] [Field L'] [Algebra K L] [Algebra K L']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_9\nL : Type u_10\nL' : Type u_11\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Field L'\ninst\u271d\u00b9 : Algebra K L\ninst\u271d : Algebra K L'\nf : L \u2192\u2090[K] L'\nS : IntermediateField K L'\nh : S \u2264 f.fieldRange\n\u22a2 IntermediateField.map f (IntermediateField.comap f S) = S"}, {"line": "simpa only [inf_of_le_left h] using map_comap_eq f S", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_le_max_transcendence_basis' (hv : IsTranscendenceBasis R v') :\n    #K' \u2264 max (max #R #\u03b9') \u2135\u2080 := by\n  simpa using cardinal_le_max_transcendence_basis v' hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["{R L K : Type*} [CommRing R]", "[Field K] [Algebra R K]", "[Field L] [Algebra R L]", "{\u03b9 : Type*} (v : \u03b9 \u2192 K)", "{\u03ba : Type*} (w : \u03ba \u2192 L)", "(hv : AlgebraicIndependent R v)", "(hw : AlgebraicIndependent R w)", "{R : Type u} {K : Type v} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K]", "{\u03b9 : Type w} (v : \u03b9 \u2192 K)", "{K' : Type u} [Field K'] [Algebra R K'] [IsAlgClosed K']", "{\u03b9' : Type u} (v' : \u03b9' \u2192 K')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b3 : CommRing R\nK' : Type u\ninst\u271d\u00b2 : Field K'\ninst\u271d\u00b9 : Algebra R K'\ninst\u271d : IsAlgClosed K'\n\u03b9' : Type u\nv' : \u03b9' \u2192 K'\nhv : IsTranscendenceBasis R v'\n\u22a2 mk K' \u2264 max (max (mk R) (mk \u03b9')) aleph0"}, {"line": "simpa using cardinal_le_max_transcendence_basis v' hv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt' [Nontrivial R]\n    (hv : IsTranscendenceBasis R v') (hR : #R \u2264 \u2135\u2080) (hK : \u2135\u2080 < #K') : #K' = #\u03b9' := by\n  simpa using cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt v' hv hR hK\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/IsAlgClosed/Classification.lean", "context": {"open": ["scoped Cardinal Polynomial", "Cardinal"], "variables": ["{R L K : Type*} [CommRing R]", "[Field K] [Algebra R K]", "[Field L] [Algebra R L]", "{\u03b9 : Type*} (v : \u03b9 \u2192 K)", "{\u03ba : Type*} (w : \u03ba \u2192 L)", "(hv : AlgebraicIndependent R v)", "(hw : AlgebraicIndependent R w)", "{R : Type u} {K : Type v} [CommRing R] [Field K] [Algebra R K] [IsAlgClosed K]", "{\u03b9 : Type w} (v : \u03b9 \u2192 K)", "{K' : Type u} [Field K'] [Algebra R K'] [IsAlgClosed K']", "{\u03b9' : Type u} (v' : \u03b9' \u2192 K')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u2074 : CommRing R\nK' : Type u\ninst\u271d\u00b3 : Field K'\ninst\u271d\u00b2 : Algebra R K'\ninst\u271d\u00b9 : IsAlgClosed K'\n\u03b9' : Type u\nv' : \u03b9' \u2192 K'\ninst\u271d : Nontrivial R\nhv : IsTranscendenceBasis R v'\nhR : mk R \u2264 aleph0\nhK : aleph0 < mk K'\n\u22a2 mk K' = mk \u03b9'"}, {"line": "simpa using cardinal_eq_cardinal_transcendence_basis_of_aleph0_lt v' hv hR hK", "tactic_state": "No Goals!"}]}
{"declaration": "lemma minpolyDiv_spec :\n    minpolyDiv R x * (X - C x) = (minpoly R x).map (algebraMap R S) := by\n  delta minpolyDiv\n  rw [mul_comm]\n  rw [mul_divByMonic_eq_iff_isRoot]\n  rw [IsRoot]\n  rw [eval_map]\n  rw [\u2190 aeval_def]\n  rw [minpoly.aeval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "context": {"open": ["Polynomial Module"], "variables": ["(R K) {L S} [CommRing R] [Field K] [Field L] [CommRing S] [Algebra R S] [Algebra K L]", "(x : S)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 minpolyDiv R x * (X - C x) = map (algebraMap R S) (minpoly R x)"}, {"line": "delta minpolyDiv", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 map (algebraMap R S) (minpoly R x) /\u2098 (X - C x) * (X - C x) = map (algebraMap R S) (minpoly R x)"}, {"line": "rw [mul_comm]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 (X - C x) * (map (algebraMap R S) (minpoly R x) /\u2098 (X - C x)) = map (algebraMap R S) (minpoly R x)"}, {"line": "rw [mul_divByMonic_eq_iff_isRoot]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 (map (algebraMap R S) (minpoly R x)).IsRoot x"}, {"line": "rw [IsRoot]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 eval x (map (algebraMap R S) (minpoly R x)) = 0"}, {"line": "rw [eval_map]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 eval\u2082 (algebraMap R S) x (minpoly R x) = 0"}, {"line": "rw [\u2190 aeval_def]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 (aeval x) (minpoly R x) = 0"}, {"line": "rw [minpoly.aeval]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma minpolyDiv_eq_zero (hx : \u00acIsIntegral R x) : minpolyDiv R x = 0 := by\n  delta minpolyDiv minpoly\n  rw [dif_neg hx]\n  rw [Polynomial.map_zero]\n  rw [zero_divByMonic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "context": {"open": ["Polynomial Module"], "variables": ["(R K) {L S} [CommRing R] [Field K] [Field L] [CommRing S] [Algebra R S] [Algebra K L]", "(x : S)", "{R x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\nhx : \u00acIsIntegral R x\n\u22a2 minpolyDiv R x = 0"}, {"line": "delta minpolyDiv minpoly", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\nhx : \u00acIsIntegral R x\n\u22a2 map (algebraMap R S)\n        (if hx : IsIntegral R x then \u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap R S) x x_1 = 0) hx else 0) /\u2098\n      (X - C x) =\n    0"}, {"line": "rw [dif_neg hx]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\nhx : \u00acIsIntegral R x\n\u22a2 map (algebraMap R S) 0 /\u2098 (X - C x) = 0"}, {"line": "rw [Polynomial.map_zero]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\nhx : \u00acIsIntegral R x\n\u22a2 0 /\u2098 (X - C x) = 0"}, {"line": "rw [zero_divByMonic]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eval_minpolyDiv_of_aeval_eq_zero [IsDomain S] [DecidableEq S]\n    {y} (hy : aeval y (minpoly R x) = 0) :\n    (minpolyDiv R x).eval y = if x = y then aeval x (derivative <| minpoly R x) else 0 := by\n  rw [eval]\n  rw [eval\u2082_minpolyDiv_of_eval\u2082_eq_zero]\n  rw [RingHom.id_apply]\n  rw [RingHom.id_apply]\n  simpa [aeval_def] using hy\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "context": {"open": ["Polynomial Module"], "variables": ["(R K) {L S} [CommRing R] [Field K] [Field L] [CommRing S] [Algebra R S] [Algebra K L]", "(x : S)", "{R x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 eval y (minpolyDiv R x) = if x = y then (aeval x) (derivative (minpoly R x)) else 0"}, {"line": "rw [eval]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 eval\u2082 (RingHom.id S) y (minpolyDiv R x) = if x = y then (aeval x) (derivative (minpoly R x)) else 0"}, {"line": "rw [eval\u2082_minpolyDiv_of_eval\u2082_eq_zero]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 (if (RingHom.id S) x = y then (RingHom.id S) ((aeval x) (derivative (minpoly R x))) else 0) =\n    if x = y then (aeval x) (derivative (minpoly R x)) else 0\n---\ncase hy\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 eval\u2082 ((RingHom.id S).comp (algebraMap R S)) y (minpoly R x) = 0\n---\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 IsDomain S\n---\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 DecidableEq S"}, {"line": "rw [RingHom.id_apply]", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 (if x = y then (RingHom.id S) ((aeval x) (derivative (minpoly R x))) else 0) =\n    if x = y then (aeval x) (derivative (minpoly R x)) else 0\n---\ncase hy\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 eval\u2082 ((RingHom.id S).comp (algebraMap R S)) y (minpoly R x) = 0\n---\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 IsDomain S\n---\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 DecidableEq S"}, {"line": "rw [RingHom.id_apply]", "tactic_state": "case hy\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 eval\u2082 ((RingHom.id S).comp (algebraMap R S)) y (minpoly R x) = 0\n---\nR : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 IsDomain S"}, {"line": "simpa [aeval_def] using hy", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u2074 : CommRing R\ninst\u271d\u00b3 : CommRing S\ninst\u271d\u00b2 : Algebra R S\nx : S\ninst\u271d\u00b9 : IsDomain S\ninst\u271d : DecidableEq S\ny : S\nhy : (aeval y) (minpoly R x) = 0\n\u22a2 IsDomain S"}]}
{"declaration": "lemma minpolyDiv_ne_zero [Nontrivial S] : minpolyDiv R x \u2260 0 := by\n  intro e\n  have := minpolyDiv_spec R x\n  rw [e] at this\n  rw [zero_mul] at this\n  exact ((minpoly.monic hx).map (algebraMap R S)).ne_zero this.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "context": {"open": ["Polynomial Module"], "variables": ["(R K) {L S} [CommRing R] [Field K] [Field L] [CommRing S] [Algebra R S] [Algebra K L]", "(x : S)", "{R x}", "(hx : IsIntegral R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\n\u22a2 minpolyDiv R x \u2260 0"}, {"line": "intro e", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\n\u22a2 False"}, {"line": "have := minpolyDiv_spec R x", "tactic_state": "case refine_4\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\nthis : minpolyDiv R x * (X - C x) = map (algebraMap R S) (minpoly R x)\n\u22a2 False\n---\ncase refine_1\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\n\u22a2 CommRing R\n---\ncase refine_2\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\n\u22a2 CommRing S\n---\ncase refine_3\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\n\u22a2 Algebra R S"}, {"line": "rw [e] at this", "tactic_state": "case refine_4\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\nthis : 0 * (X - C x) = map (algebraMap R S) (minpoly R x)\n\u22a2 False"}, {"line": "rw [zero_mul] at this", "tactic_state": "case refine_4\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : Algebra R S\nx : S\ninst\u271d : Nontrivial S\ne : minpolyDiv R x = 0\nthis : 0 = map (algebraMap R S) (minpoly R x)\n\u22a2 False"}, {"line": "exact ((minpoly.monic hx).map (algebraMap R S)).ne_zero this.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natDegree_minpolyDiv :\n    natDegree (minpolyDiv R x) = natDegree (minpoly R x) - 1 := by\n  nontriviality S\n  by_cases hx : IsIntegral R x\n  \u00b7 rw [\u2190 natDegree_minpolyDiv_succ hx]; rfl\n  \u00b7 rw [minpolyDiv_eq_zero hx, minpoly.eq_zero hx]; rfl\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/MinpolyDiv.lean", "context": {"open": ["Polynomial Module"], "variables": ["(R K) {L S} [CommRing R] [Field K] [Field L] [CommRing S] [Algebra R S] [Algebra K L]", "(x : S)", "{R x}", "(hx : IsIntegral R x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\n\u22a2 (minpolyDiv R x).natDegree = (minpoly R x).natDegree - 1"}, {"line": "nontriviality S", "tactic_state": "R : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\na\u271d : Nontrivial S\n\u22a2 (minpolyDiv R x).natDegree = (minpoly R x).natDegree - 1"}, {"line": "by_cases hx : IsIntegral R x", "tactic_state": "case pos\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\na\u271d : Nontrivial S\nhx : sorry\n\u22a2 (minpolyDiv R x).natDegree = (minpoly R x).natDegree - 1\n---\ncase neg\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\na\u271d : Nontrivial S\nhx : \u00acsorry\n\u22a2 (minpolyDiv R x).natDegree = (minpoly R x).natDegree - 1"}, {"line": "\u00b7 rw [\u2190 natDegree_minpolyDiv_succ hx]; rfl", "tactic_state": "case neg\nR : Type u_2\nS : Type u_1\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\ninst\u271d : Algebra R S\nx : S\na\u271d : Nontrivial S\nhx : \u00acsorry\n\u22a2 (minpolyDiv R x).natDegree = (minpoly R x).natDegree - 1"}, {"line": "\u00b7 rw [minpolyDiv_eq_zero hx, minpoly.eq_zero hx]; rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monic (hx : IsIntegral A x) : Monic (minpoly A x) := by\n  delta minpoly\n  rw [dif_pos hx]\n  exact (degree_lt_wf.min_mem _ hx).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (minpoly A x).Monic"}, {"line": "delta minpoly", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (if hx : IsIntegral A x then \u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx else 0).Monic"}, {"line": "rw [dif_pos hx]", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (\u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx).Monic"}, {"line": "exact (degree_lt_wf.min_mem _ hx).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem aeval : aeval x (minpoly A x) = 0 := by\n  delta minpoly\n  split_ifs with hx\n  \u00b7 exact (degree_lt_wf.min_mem _ hx).2\n  \u00b7 exact aeval_zero _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\n\u22a2 (Polynomial.aeval x) (minpoly A x) = 0"}, {"line": "delta minpoly", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\n\u22a2 (Polynomial.aeval x)\n      (if hx : IsIntegral A x then \u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx else 0) =\n    0"}, {"line": "split_ifs with hx", "tactic_state": "case pos\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 (Polynomial.aeval x) (\u22ef.min (fun x_1 => x_1.Monic \u2227 eval\u2082 (algebraMap A B) x x_1 = 0) hx) = 0\n---\ncase neg\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : \u00acIsIntegral A x\n\u22a2 (Polynomial.aeval x) 0 = 0"}, {"line": "\u00b7 exact (degree_lt_wf.min_mem _ hx).2", "tactic_state": "case neg\nB : Type u_1\nA : Type u_2\ninst\u271d\u2075 : CommRing A\ninst\u271d\u2074 : Ring B\ninst\u271d\u00b3 : Algebra A B\ninst\u271d\u00b2 : CommRing A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\nhx : \u00acIsIntegral A x\n\u22a2 (Polynomial.aeval x) 0 = 0"}, {"line": "\u00b7 exact aeval_zero _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton [Subsingleton B] : minpoly A x = 1 := by\n  nontriviality A\n  have := minpoly.min A x monic_one (Subsingleton.elim _ _)\n  rw [degree_one] at this\n  rcases le_or_lt (minpoly A x).degree 0 with h | h\n  \u00b7 rwa [(monic \u27e81, monic_one, by simp [eq_iff_true_of_subsingleton]\u27e9 :\n           (minpoly A x).Monic).degree_le_zero_iff_eq_one] at h\n  \u00b7 exact (this.not_lt h).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\n\u22a2 minpoly A x = 1"}, {"line": "nontriviality A", "tactic_state": "B : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 minpoly A x = 1"}, {"line": "have := minpoly.min A x monic_one (Subsingleton.elim _ _)", "tactic_state": "case refine_4\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\nthis : (minpoly A x).degree \u2264 degree 1\n\u22a2 minpoly A x = 1\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_2\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Ring B\n---\ncase refine_3\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Algebra A B"}, {"line": "rw [degree_one] at this", "tactic_state": "case refine_4\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\nthis : (minpoly A x).degree \u2264 0\n\u22a2 minpoly A x = 1\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_2\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Ring B\n---\ncase refine_3\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Algebra A B"}, {"line": "rcases le_or_lt (minpoly A x).degree 0 with h | h", "tactic_state": "case refine_4.inl\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\nthis : (minpoly A x).degree \u2264 0\nh : sorry \u2264 0\n\u22a2 minpoly A x = 1\n---\ncase refine_4.inr\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\nthis : (minpoly A x).degree \u2264 0\nh : 0 < sorry\n\u22a2 minpoly A x = 1\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_2\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Ring B\n---\ncase refine_3\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Algebra A B"}, {"line": "\u00b7 rwa [(monic \u27e81, monic_one, by simp [eq_iff_true_of_subsingleton]\u27e9 :\n           (minpoly A x).Monic).degree_le_zero_iff_eq_one] at h", "tactic_state": "case refine_4.inr\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\nthis : (minpoly A x).degree \u2264 0\nh : 0 < sorry\n\u22a2 minpoly A x = 1\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_2\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Ring B\n---\ncase refine_3\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Algebra A B"}, {"line": "\u00b7 exact (this.not_lt h).elim", "tactic_state": "case refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_1\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 CommRing A\n---\ncase refine_2\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Ring B\n---\ncase refine_3\nB : Type u_1\nA : Type u_2\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Subsingleton B\na\u271d : Nontrivial A\n\u22a2 Algebra A B"}]}
{"declaration": "theorem degree_eq_one_iff : (minpoly A x).degree = 1 \u2194 x \u2208 (algebraMap A B).range := by\n  refine \u27e8minpoly.mem_range_of_degree_eq_one _ _, ?_\u27e9\n  rintro \u27e8x, rfl\u27e9\n  haveI := Module.nontrivial A B\n  exact (degree_X_sub_C x \u25b8 minpoly.min A (algebraMap A B x) (monic_X_sub_C x) (by simp)).antisymm\n    (Nat.WithBot.add_one_le_of_lt <| minpoly.degree_pos isIntegral_algebraMap)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in", "Polynomial in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)", "[CommRing A]", "[Ring B] [Algebra A B]", "{x : B}", "[Nontrivial B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 (minpoly A x).degree = 1 \u2194 x \u2208 (algebraMap A B).range"}, {"line": "refine \u27e8minpoly.mem_range_of_degree_eq_one _ _, ?_\u27e9", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 x \u2208 (algebraMap A B).range \u2192 (minpoly A x).degree = 1"}, {"line": "rintro \u27e8x, rfl\u27e9", "tactic_state": "case intro\nB : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\ninst\u271d : Nontrivial B\nx : A\n\u22a2 (minpoly A ((algebraMap A B) x)).degree = 1"}, {"line": "haveI := Module.nontrivial A B", "tactic_state": "case intro\nB : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\ninst\u271d : Nontrivial B\nx : A\nthis : Nontrivial A\n\u22a2 (minpoly A ((algebraMap A B) x)).degree = 1"}, {"line": "exact (degree_X_sub_C x \u25b8 minpoly.min A (algebraMap A B x) (monic_X_sub_C x) (by simp)).antisymm\n    (Nat.WithBot.add_one_le_of_lt <| minpoly.degree_pos isIntegral_algebraMap)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_eq_one_iff :\n    (minpoly A x).natDegree = 1 \u2194 x \u2208 (algebraMap A B).range := by\n  rw [\u2190 Polynomial.degree_eq_iff_natDegree_eq_of_pos zero_lt_one]\n  exact degree_eq_one_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Basic.lean", "context": {"open": ["Polynomial Set Function", "scoped Classical in", "Polynomial in"], "variables": ["{A B B' : Type*}", "(A) [CommRing A] [Ring B] [Algebra A B]", "[CommRing A] [Ring B] [Ring B'] [Algebra A B] [Algebra A B']", "{x : B}", "(A x)", "[CommRing A]", "[Ring B] [Algebra A B]", "{x : B}", "[Nontrivial B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 (minpoly A x).natDegree = 1 \u2194 x \u2208 (algebraMap A B).range"}, {"line": "rw [\u2190 Polynomial.degree_eq_iff_natDegree_eq_of_pos zero_lt_one]", "tactic_state": "B : Type u_2\nA : Type u_1\ninst\u271d\u2079 : CommRing A\ninst\u271d\u2078 : Ring B\ninst\u271d\u2077 : Algebra A B\ninst\u271d\u2076 : CommRing A\ninst\u271d\u2075 : Ring B\ninst\u271d\u2074 : Algebra A B\ninst\u271d\u00b3 : CommRing A\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : Algebra A B\nx : B\ninst\u271d : Nontrivial B\n\u22a2 (minpoly A x).degree = \u21911 \u2194 x \u2208 (algebraMap A B).range"}, {"line": "exact degree_eq_one_iff", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ker_aeval_eq_span_minpoly :\n    RingHom.ker (Polynomial.aeval x) = A[X] \u2219 minpoly A x := by\n  ext p\n  simp_rw [RingHom.mem_ker, \u2190 minpoly.dvd_iff, Submodule.mem_span_singleton,\n    dvd_iff_exists_eq_mul_left, smul_eq_mul, eq_comm (a := p)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Field.lean", "context": {"open": ["Polynomial Set Function minpoly"], "variables": ["{A B : Type*}", "(A) [Field A]", "[Ring B] [Algebra A B] (x : B)", "{A x} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\n\u22a2 RingHom.ker (Polynomial.aeval x) = Submodule.span (Polynomial A) {minpoly A x}"}, {"line": "ext p", "tactic_state": "case h\nA : Type u_1\nB : Type u_2\ninst\u271d\u00b2 : Field A\ninst\u271d\u00b9 : Ring B\ninst\u271d : Algebra A B\nx : B\np : Polynomial A\n\u22a2 p \u2208 RingHom.ker (Polynomial.aeval x) \u2194 p \u2208 Submodule.span (Polynomial A) {minpoly A x}"}, {"line": "simp_rw [RingHom.mem_ker, \u2190 minpoly.dvd_iff, Submodule.mem_span_singleton,\n    dvd_iff_exists_eq_mul_left, smul_eq_mul, eq_comm (a := p)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_algebraMap {B : Type*} [CommRing B] [Algebra A B] (x : B)\n    (a : A) : minpoly A (x - algebraMap A B a) = (minpoly A x).comp (X + C a) := by\n  simpa [sub_eq_add_neg] using add_algebraMap x (-a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Field.lean", "context": {"open": ["Polynomial Set Function minpoly"], "variables": ["{A B : Type*}", "(A) [Field A]", "[Ring B] [Algebra A B] (x : B)", "{A x} in", "{A x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b2 : Field A\nB : Type u_3\ninst\u271d\u00b9 : CommRing B\ninst\u271d : Algebra A B\nx : B\na : A\n\u22a2 minpoly A (x - (algebraMap A B) a) = (minpoly A x).comp (X + C a)"}, {"line": "simpa [sub_eq_add_neg] using add_algebraMap x (-a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prime (hx : IsIntegral A x) : Prime (minpoly A x) := by\n  refine \u27e8minpoly.ne_zero hx, not_isUnit A x, ?_\u27e9\n  rintro p q \u27e8d, h\u27e9\n  have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]\n  replace : Polynomial.aeval x p = 0 \u2228 Polynomial.aeval x q = 0 := by simpa\n  exact Or.imp (dvd A x) (dvd A x) this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/Field.lean", "context": {"open": ["Polynomial Set Function minpoly", "scoped Classical in"], "variables": ["{A B : Type*}", "(A) [Field A]", "[Ring B] [Algebra A B] (x : B)", "{A x} in", "{A x}", "(F E K : Type*) [Field F] [Ring E] [CommRing K] [IsDomain K] [Algebra F E] [Algebra F K]", "(B) [Nontrivial B]", "(A)", "[Ring B] [IsDomain B] [Algebra A B]", "{A} {x : B}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 Prime (minpoly A x)"}, {"line": "refine \u27e8minpoly.ne_zero hx, not_isUnit A x, ?_\u27e9", "tactic_state": "A : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\n\u22a2 \u2200 (a b : Polynomial A), minpoly A x \u2223 a * b \u2192 minpoly A x \u2223 a \u2228 minpoly A x \u2223 b"}, {"line": "rintro p q \u27e8d, h\u27e9", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "have : Polynomial.aeval x (p * q) = 0 := by simp [h, aeval A x]", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\nthis : sorry = 0\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "replace : Polynomial.aeval x p = 0 \u2228 Polynomial.aeval x q = 0 := by simpa", "tactic_state": "case intro\nA : Type u_4\ninst\u271d\u2074 : Field A\nB : Type u_5\ninst\u271d\u00b3 : Nontrivial B\ninst\u271d\u00b2 : Ring B\ninst\u271d\u00b9 : IsDomain B\ninst\u271d : Algebra A B\nx : B\nhx : IsIntegral A x\np q d : Polynomial A\nh : p * q = minpoly A x * d\nthis : sorry = 0 \u2228 sorry = 0\n\u22a2 minpoly A x \u2223 p \u2228 minpoly A x \u2223 q"}, {"line": "exact Or.imp (dvd A x) (dvd A x) this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Algebra.adjoin.powerBasis'_gen (hx : IsIntegral R x) :\n    (adjoin.powerBasis' hx).gen = \u27e8x, SetLike.mem_coe.1 <| subset_adjoin <| mem_singleton x\u27e9 := by\n  rw [Algebra.adjoin.powerBasis']\n  rw [PowerBasis.map_gen]\n  rw [AdjoinRoot.powerBasis'_gen]\n  rw [equivAdjoin]\n  rw [AlgEquiv.ofBijective_apply]\n  rw [Minpoly.toAdjoin]\n  rw [liftHom_root]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "context": {"open": ["Polynomial Set Function minpoly", "Algebra Polynomial AdjoinRoot"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [IsDomain R] [Algebra R S]", "(K L : Type*) [Field K] [Algebra R K] [IsFractionRing R K] [CommRing L] [Nontrivial L]", "[IsIntegrallyClosed R]", "[IsDomain S] [NoZeroSMulDivisors R S]", "[IsIntegrallyClosed R]", "{x : S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (adjoin.powerBasis' hx).gen = \u27e8x, \u22ef\u27e9"}, {"line": "rw [Algebra.adjoin.powerBasis']", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 ((powerBasis' \u22ef).map (equivAdjoin hx)).gen = \u27e8x, \u22ef\u27e9"}, {"line": "rw [PowerBasis.map_gen]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (equivAdjoin hx) (powerBasis' \u22ef).gen = \u27e8x, \u22ef\u27e9"}, {"line": "rw [AdjoinRoot.powerBasis'_gen]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (equivAdjoin hx) (AdjoinRoot.root (minpoly R x)) = \u27e8x, \u22ef\u27e9"}, {"line": "rw [equivAdjoin]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (AlgEquiv.ofBijective (Minpoly.toAdjoin R x) \u22ef) (AdjoinRoot.root (minpoly R x)) = \u27e8x, \u22ef\u27e9"}, {"line": "rw [AlgEquiv.ofBijective_apply]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (Minpoly.toAdjoin R x) (AdjoinRoot.root (minpoly R x)) = \u27e8x, \u22ef\u27e9"}, {"line": "rw [Minpoly.toAdjoin]", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n\u22a2 (liftHom (minpoly R x) \u27e8x, \u22ef\u27e9 \u22ef) (AdjoinRoot.root (minpoly R x)) = \u27e8x, \u22ef\u27e9"}, {"line": "rw [liftHom_root]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.PowerBasis.ofGenMemAdjoin'_gen (B : PowerBasis R S) (hint : IsIntegral R x)\n    (hx : B.gen \u2208 adjoin R ({x} : Set S)) :\n    (B.ofGenMemAdjoin' hint hx).gen = x := by\n  simp [PowerBasis.ofGenMemAdjoin']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Minpoly/IsIntegrallyClosed.lean", "context": {"open": ["Polynomial Set Function minpoly", "Algebra Polynomial AdjoinRoot"], "variables": ["{R S : Type*} [CommRing R] [CommRing S] [IsDomain R] [Algebra R S]", "(K L : Type*) [Field K] [Algebra R K] [IsFractionRing R K] [CommRing L] [Nontrivial L]", "[IsIntegrallyClosed R]", "[IsDomain S] [NoZeroSMulDivisors R S]", "[IsIntegrallyClosed R]", "{x : S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nS : Type u_2\ninst\u271d\u2077 : CommRing R\ninst\u271d\u2076 : CommRing S\ninst\u271d\u2075 : IsDomain R\ninst\u271d\u2074 : Algebra R S\ninst\u271d\u00b3 : IsIntegrallyClosed R\ninst\u271d\u00b2 : IsDomain S\ninst\u271d\u00b9 : NoZeroSMulDivisors R S\ninst\u271d : IsIntegrallyClosed R\nx : S\nB : PowerBasis R S\nhint : IsIntegral R x\nhx : B.gen \u2208 adjoin R {x}\n\u22a2 (B.ofGenMemAdjoin' hint hx).gen = x"}, {"line": "simp [PowerBasis.ofGenMemAdjoin']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNormalClosure_iff : IsNormalClosure F K L \u2194\n    (\u2200 x : K, (minpoly F x).Splits (algebraMap F L)) \u2227 normalClosure F K L = \u22a4 := by\n  refine \u27e8fun \u27e8splits, h\u27e9 \u21a6 \u27e8splits, ?_\u27e9, fun \u27e8splits, h\u27e9 \u21a6 \u27e8splits, ?_\u27e9\u27e9 <;>\n    simpa only [normalClosure_eq_iSup_adjoin_of_splits splits] using h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/Normal/Closure.lean", "context": {"open": ["IntermediateField IsScalarTower Polynomial"], "variables": ["(F K L : Type*) [Field F] [Field K] [Field L] [Algebra F K] [Algebra F L]", "{F K L}", "[Algebra.IsAlgebraic F K]", "(splits : \u2200 x : K, (minpoly F x).Splits (algebraMap F L))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_1\nK : Type u_2\nL : Type u_3\ninst\u271d\u2075 : Field F\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Field L\ninst\u271d\u00b2 : Algebra F K\ninst\u271d\u00b9 : Algebra F L\ninst\u271d : Algebra.IsAlgebraic F K\n\u22a2 IsNormalClosure F K L \u2194 (\u2200 (x : K), Splits (algebraMap F L) (minpoly F x)) \u2227 normalClosure F K L = \u22a4"}, {"line": "refine \u27e8fun \u27e8splits, h\u27e9 \u21a6 \u27e8splits, ?_\u27e9, fun \u27e8splits, h\u27e9 \u21a6 \u27e8splits, ?_\u27e9\u27e9 <;>\n    simpa only [normalClosure_eq_iSup_adjoin_of_splits splits] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPurelyInseparable_adjoin_simple_iff_natSepDegree_eq_one {x : E} :\n    IsPurelyInseparable F F\u27eex\u27ef \u2194 (minpoly F x).natSepDegree = 1 := by\n  rw [\u2190 le_perfectClosure_iff]\n  rw [adjoin_simple_le_iff]\n  rw [mem_perfectClosure_iff_natSepDegree_eq_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/PerfectClosure.lean", "context": {"open": ["IntermediateField"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E}", "(F E)", "{F E K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx : E\n\u22a2 IsPurelyInseparable F \u21a5F\u27eex\u27ef \u2194 (minpoly F x).natSepDegree = 1"}, {"line": "rw [\u2190 le_perfectClosure_iff]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx : E\n\u22a2 F\u27eex\u27ef \u2264 perfectClosure F E \u2194 (minpoly F x).natSepDegree = 1"}, {"line": "rw [adjoin_simple_le_iff]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nx : E\n\u22a2 x \u2208 perfectClosure F E \u2194 (minpoly F x).natSepDegree = 1"}, {"line": "rw [mem_perfectClosure_iff_natSepDegree_eq_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPurelyInseparable_adjoin_simple_iff_pow_mem (q : \u2115) [hF : ExpChar F q] {x : E} :\n    IsPurelyInseparable F F\u27eex\u27ef \u2194 \u2203 n : \u2115, x ^ q ^ n \u2208 (algebraMap F E).range := by\n  rw [\u2190 le_perfectClosure_iff]\n  rw [adjoin_simple_le_iff]\n  rw [mem_perfectClosure_iff_pow_mem q]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/PerfectClosure.lean", "context": {"open": ["IntermediateField"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E}", "(F E)", "{F E K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\n\u22a2 IsPurelyInseparable F \u21a5F\u27eex\u27ef \u2194 \u2203 n, x ^ q ^ n \u2208 (algebraMap F E).range"}, {"line": "rw [\u2190 le_perfectClosure_iff]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\n\u22a2 F\u27eex\u27ef \u2264 perfectClosure F E \u2194 \u2203 n, x ^ q ^ n \u2208 (algebraMap F E).range"}, {"line": "rw [adjoin_simple_le_iff]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\n\u22a2 x \u2208 perfectClosure F E \u2194 \u2203 n, x ^ q ^ n \u2208 (algebraMap F E).range"}, {"line": "rw [mem_perfectClosure_iff_pow_mem q]", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b2 : Field F\ninst\u271d\u00b9 : Field E\ninst\u271d : Algebra F E\nq : \u2115\nhF : ExpChar F q\nx : E\n\u22a2 ExpChar F q"}]}
{"declaration": "theorem minpoly.frobenius_of_isSeparable [ExpChar E q] {a : E} (hsep : IsSeparable F a) :\n    minpoly F (frobenius E q a) = (minpoly F a).map (frobenius F q) := by\n  simpa using minpoly.iterateFrobenius_of_isSeparable q 1 hsep\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/PerfectClosure.lean", "context": {"open": ["IntermediateField"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "{F E}", "(F E)", "{F E K}", "(q n : \u2115) [hF : ExpChar F q] {\u03b9 : Type*} {v : \u03b9 \u2192 E} {F E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\nq : \u2115\ninst\u271d : ExpChar E q\na : E\nhsep : IsSeparable F a\n\u22a2 minpoly F ((frobenius E q) a) = Polynomial.map sorry (minpoly F a)"}, {"line": "simpa using minpoly.iterateFrobenius_of_isSeparable q 1 hsep", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPurelyInseparable_iff_fd_isPurelyInseparable [Algebra.IsAlgebraic F E] :\n    IsPurelyInseparable F E \u2194\n    \u2200 L : IntermediateField F E, FiniteDimensional F L \u2192 IsPurelyInseparable F L := by\n  refine \u27e8fun _ _ _ \u21a6 IsPurelyInseparable.tower_bot F _ E,\n    fun h \u21a6 isPurelyInseparable_iff.2 fun x \u21a6 ?_\u27e9\n  have hx : IsIntegral F x := Algebra.IsIntegral.isIntegral x\n  refine \u27e8hx, fun _ \u21a6 ?_\u27e9\n  obtain \u27e8y, h\u27e9 := (h _ (adjoin.finiteDimensional hx)).inseparable' _ <|\n    show Separable (minpoly F (AdjoinSimple.gen F x)) by rwa [minpoly_eq]\n  exact \u27e8y, congr_arg (algebraMap _ E) h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/Basic.lean", "context": {"open": ["Module Polynomial IntermediateField Field"], "variables": ["(F E : Type*) [CommRing F] [Ring E] [Algebra F E]", "(K : Type*) [Ring K] [Algebra F K]", "{E} in", "{E}", "{F}", "{K}", "(F E K)", "{F E} in", "(F : Type u) {E : Type v} [Field F] [Ring E] [IsDomain E] [Algebra F E]", "(q : \u2115) [ExpChar F q] (x : E)", "(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "(M : IntermediateField F K)", "{E}", "(E)", "{F E} in", "[IsPurelyInseparable F E] (R L : Type*) [CommSemiring R] [Algebra R F] [Algebra R E]", "{F E} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsAlgebraic F E\n\u22a2 IsPurelyInseparable F E \u2194 \u2200 (L : IntermediateField F E), FiniteDimensional F \u21a5L \u2192 IsPurelyInseparable F \u21a5L"}, {"line": "refine \u27e8fun _ _ _ \u21a6 IsPurelyInseparable.tower_bot F _ E,\n    fun h \u21a6 isPurelyInseparable_iff.2 fun x \u21a6 ?_\u27e9", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsAlgebraic F E\nh : \u2200 (L : IntermediateField F E), FiniteDimensional F \u21a5L \u2192 IsPurelyInseparable F \u21a5L\nx : E\n\u22a2 IsIntegral F x \u2227 (IsSeparable F x \u2192 x \u2208 (algebraMap F E).range)"}, {"line": "have hx : IsIntegral F x := Algebra.IsIntegral.isIntegral x", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsAlgebraic F E\nh : \u2200 (L : IntermediateField F E), FiniteDimensional F \u21a5L \u2192 IsPurelyInseparable F \u21a5L\nx : E\nhx : sorry\n\u22a2 IsIntegral F x \u2227 (IsSeparable F x \u2192 x \u2208 (algebraMap F E).range)"}, {"line": "refine \u27e8hx, fun _ \u21a6 ?_\u27e9", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsAlgebraic F E\nh : \u2200 (L : IntermediateField F E), FiniteDimensional F \u21a5L \u2192 IsPurelyInseparable F \u21a5L\nx : E\nhx : sorry\nx\u271d : IsSeparable F x\n\u22a2 x \u2208 (algebraMap F E).range"}, {"line": "obtain \u27e8y, h\u27e9 := (h _ (adjoin.finiteDimensional hx)).inseparable' _ <|\n    show Separable (minpoly F (AdjoinSimple.gen F x)) by rwa [minpoly_eq]", "tactic_state": "case intro\nF : Type u\nE : Type v\ninst\u271d\u00b3 : Field F\ninst\u271d\u00b2 : Field E\ninst\u271d\u00b9 : Algebra F E\ninst\u271d : Algebra.IsAlgebraic F E\nh\u271d : \u2200 (L : IntermediateField F E), FiniteDimensional F \u21a5L \u2192 IsPurelyInseparable F \u21a5L\nx : E\nhx : sorry\nx\u271d : IsSeparable F x\ny : F\nh : (algebraMap F \u21a5F\u27ee?m.22324\u27ef) y = ?m.23382\n\u22a2 x \u2208 (algebraMap F E).range"}, {"line": "exact \u27e8y, congr_arg (algebraMap _ E) h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rank_mul_sepDegree_of_isSeparable (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsSeparable F E] :\n    Module.rank F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_rank_mul_lift_sepDegree_of_isSeparable F E K\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/Tower.lean", "context": {"open": ["Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "[Algebra E K] [IsScalarTower F E K]", "{F K} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2077 : Field F\ninst\u271d\u2076 : Field E\ninst\u271d\u2075 : Algebra F E\nK : Type v\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra F K\ninst\u271d\u00b2 : Algebra E K\ninst\u271d\u00b9 : IsScalarTower F E K\ninst\u271d : Algebra.IsSeparable F E\n\u22a2 Module.rank F E * sepDegree E K = sepDegree F K"}, {"line": "simpa only [Cardinal.lift_id] using lift_rank_mul_lift_sepDegree_of_isSeparable F E K", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sepDegree_mul_sepDegree_of_isAlgebraic (K : Type v) [Field K] [Algebra F K]\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsAlgebraic F E] :\n    sepDegree F E * sepDegree E K = sepDegree F K := by\n  simpa only [Cardinal.lift_id] using lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E K\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/PurelyInseparable/Tower.lean", "context": {"open": ["Polynomial IntermediateField Field"], "variables": ["(F : Type u) (E : Type v) [Field F] [Field E] [Algebra F E]", "(K : Type w) [Field K] [Algebra F K]", "[Algebra E K] [IsScalarTower F E K]", "{F K} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u\nE : Type v\ninst\u271d\u2077 : Field F\ninst\u271d\u2076 : Field E\ninst\u271d\u2075 : Algebra F E\nK : Type v\ninst\u271d\u2074 : Field K\ninst\u271d\u00b3 : Algebra F K\ninst\u271d\u00b2 : Algebra E K\ninst\u271d\u00b9 : IsScalarTower F E K\ninst\u271d : Algebra.IsAlgebraic F E\n\u22a2 sepDegree F E * sepDegree E K = sepDegree F K"}, {"line": "simpa only [Cardinal.lift_id] using lift_sepDegree_mul_lift_sepDegree_of_isAlgebraic F E K", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eval_C {c : K} : eval f a (C c) = f c := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nc : K\n\u22a2 eval f a sorry = f c"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\nc : K\n\u22a2 Polynomial.eval\u2082 f a (sorry ()).num / Polynomial.eval\u2082 f a (sorry ()).denom = f c"}]}
{"declaration": "theorem eval_X : eval f a X = a := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a sorry = a"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 Polynomial.eval\u2082 f a (sorry ()).num / Polynomial.eval\u2082 f a (sorry ()).denom = a"}]}
{"declaration": "theorem eval_zero : eval f a 0 = 0 := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a 0 = 0"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 0 / 1 = 0"}]}
{"declaration": "theorem eval_one : eval f a 1 = 1 := by simp [eval]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 eval f a 1 = 1"}, {"line": "simp [eval]", "tactic_state": "K : Type u\ninst\u271d\u00b3 : CommRing K\ninst\u271d\u00b2 : IsDomain K\ninst\u271d\u00b9 : Field K\nL : Type u\ninst\u271d : Field L\nf : K \u2192+* L\na : L\n\u22a2 1 / 1 = 1"}]}
{"declaration": "theorem eval_algebraMap {S : Type*} [CommSemiring S] [Algebra S K[X]] (p : S) :\n    eval f a (algebraMap _ _ p) = (algebraMap _ K[X] p).eval\u2082 f a := by\n  simp [eval, IsScalarTower.algebraMap_apply S K[X] (RatFunc K)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/AsPolynomial.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc"], "variables": ["{K : Type u}", "[CommRing K] [IsDomain K]", "[Field K]", "{L : Type u} [Field L]", "{f : K \u2192+* L} {a : L}", "(f a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u2075 : CommRing K\ninst\u271d\u2074 : IsDomain K\ninst\u271d\u00b3 : Field K\nL : Type u\ninst\u271d\u00b2 : Field L\nf : K \u2192+* L\na : L\nS : Type u_1\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : Algebra S (Polynomial K)\np : S\n\u22a2 eval f a ((algebraMap S (RatFunc K)) p) = Polynomial.eval\u2082 f a ((algebraMap S (Polynomial K)) p)"}, {"line": "simp [eval, IsScalarTower.algebraMap_apply S K[X] (RatFunc K)]", "tactic_state": "K : Type u\ninst\u271d\u2075 : CommRing K\ninst\u271d\u2074 : IsDomain K\ninst\u271d\u00b3 : Field K\nL : Type u\ninst\u271d\u00b2 : Field L\nf : K \u2192+* L\na : L\nS : Type u_1\ninst\u271d\u00b9 : CommSemiring S\ninst\u271d : Algebra S (Polynomial K)\np : S\n\u22a2 Polynomial.eval\u2082 f a ((algebraMap S (RatFunc K)) p).num / Polynomial.eval\u2082 f a ((algebraMap S (RatFunc K)) p).denom =\n    Polynomial.eval\u2082 f a ((algebraMap S (Polynomial K)) p)"}]}
{"declaration": "theorem map_apply_ofFractionRing_mk [MonoidHomClass F R[X] S[X]] (\u03c6 : F)\n    (h\u03c6 : R[X]\u2070 \u2264 S[X]\u2070.comap \u03c6) (n : R[X]) (d : R[X]\u2070) :\n    map \u03c6 h\u03c6 (ofFractionRing (Localization.mk n d)) =\n      ofFractionRing (Localization.mk (\u03c6 n) \u27e8\u03c6 d, h\u03c6 d.prop\u27e9) := by\n  simp only [map]\n  simp only [MonoidHom.coe_mk]\n  simp only [OneHom.coe_mk]\n  simp only [liftOn_ofFractionRing_mk]\n  simp only [Submonoid.mem_comap.mp (h\u03c6 d.2)]\n  simp only [\u2193reduceDIte]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 (map \u03c6 h\u03c6) { toFractionRing := Localization.mk n d } = { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [map]", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 {\n        toFun := fun f =>\n          f.liftOn\n            (fun n d =>\n              if h : \u03c6 d \u2208 nonZeroDivisors (Polynomial S) then { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 d, h\u27e9 }\n              else 0)\n            \u22ef,\n        map_one' := \u22ef, map_mul' := \u22ef }\n      { toFractionRing := Localization.mk n d } =\n    { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [MonoidHom.coe_mk]", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 {\n        toFun := fun f =>\n          f.liftOn\n            (fun n d =>\n              if h : \u03c6 d \u2208 nonZeroDivisors (Polynomial S) then { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 d, h\u27e9 }\n              else 0)\n            \u22ef,\n        map_one' := \u22ef }\n      { toFractionRing := Localization.mk n d } =\n    { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [OneHom.coe_mk]", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 { toFractionRing := Localization.mk n d }.liftOn\n      (fun n d =>\n        if h : \u03c6 d \u2208 nonZeroDivisors (Polynomial S) then { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 d, h\u27e9 } else 0)\n      \u22ef =\n    { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [liftOn_ofFractionRing_mk]", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 (if h : \u03c6 \u2191d \u2208 nonZeroDivisors (Polynomial S) then { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, h\u27e9 } else 0) =\n    { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [Submonoid.mem_comap.mp (h\u03c6 d.2)]", "tactic_state": "R : Type u_4\nS : Type u_5\nF : Type u_6\ninst\u271d\u00b3 : CommRing R\ninst\u271d\u00b2 : CommRing S\ninst\u271d\u00b9 : FunLike F (Polynomial R) (Polynomial S)\ninst\u271d : MonoidHomClass F (Polynomial R) (Polynomial S)\n\u03c6 : F\nh\u03c6 : nonZeroDivisors (Polynomial R) \u2264 Submonoid.comap \u03c6 (nonZeroDivisors (Polynomial S))\nn : Polynomial R\nd : \u21a5(nonZeroDivisors (Polynomial R))\n\u22a2 (if h : True then { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 } else 0) =\n    { toFractionRing := Localization.mk (\u03c6 n) \u27e8\u03c6 \u2191d, \u22ef\u27e9 }"}, {"line": "simp only [\u2193reduceDIte]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_zero : num (0 : RatFunc K) = 0 := by convert num_div' (0 : K[X]) one_ne_zero <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\n\u22a2 num 0 = 0"}, {"line": "convert num_div' (0 : K[X]) one_ne_zero <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_div (p q : K[X]) :\n    num (algebraMap _ _ p / algebraMap _ _ q) =\n      Polynomial.C (q / gcd p q).leadingCoeff\u207b\u00b9 * (p / gcd p q) := by\n  by_cases hq : q = 0\n  \u00b7 simp [hq]\n  \u00b7 exact num_div' p hq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np q : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "by_cases hq : q = 0", "tactic_state": "case pos\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : q = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)\n---\ncase neg\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : \u00acq = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "\u00b7 simp [hq]", "tactic_state": "case neg\nK : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : \u00acq = 0\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p / (algebraMap (Polynomial K) (RatFunc K)) q).num =\n    Polynomial.C (q / sorry).leadingCoeff\u207b\u00b9 * (p / sorry)"}, {"line": "\u00b7 exact num_div' p hq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p := by convert num_div p 1 <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p).num = p"}, {"line": "convert num_div p 1 <;> simp", "tactic_state": "case h.e'_3\nK : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 p = Polynomial.C 1\u207b\u00b9 * p"}]}
{"declaration": "theorem num_div_dvd' (p : K[X]) {q : K[X]} (hq : q \u2260 0) :\n    C (q / gcd p q).leadingCoeff\u207b\u00b9 * (p / gcd p q) \u2223 p := by simpa using num_div_dvd p hq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np q : Polynomial K\nhq : q \u2260 0\n\u22a2 C (q / sorry).leadingCoeff\u207b\u00b9 * (\u2191p / sorry) \u2223 \u2191p"}, {"line": "simpa using num_div_dvd p hq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem denom_algebraMap (p : K[X]) : denom (algebraMap _ (RatFunc K) p) = 1 := by\n  convert denom_div p one_ne_zero <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 ((algebraMap (Polynomial K) (RatFunc K)) p).denom = 1"}, {"line": "convert denom_div p one_ne_zero <;> simp", "tactic_state": "case h.e'_3\nK : Type u_7\ninst\u271d : Field K\np : Polynomial K\n\u22a2 1 = Polynomial.C 1\u207b\u00b9"}]}
{"declaration": "theorem num_mul_denom_add_denom_mul_num_ne_zero {x y : RatFunc K} (hxy : x + y \u2260 0) :\n    x.num * y.denom + x.denom * y.num \u2260 0 := by\n  intro h_zero\n  have h := num_denom_add x y\n  rw [h_zero] at h\n  rw [zero_mul] at h\n  exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Basic.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial", "RatFunc", "scoped Classical in", "GCDMonoid Polynomial", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["{K : Type u}", "[CommRing K]", "[IsDomain K]", "{R : Type*}", "[IsDomain K]", "[Monoid R] [DistribMulAction R K[X]]", "[IsScalarTower R K[X] K[X]]", "(K)", "(K) [CommRing K]", "{K}", "{G\u2080 L R S F : Type*} [CommGroupWithZero G\u2080] [Field L] [CommRing R] [CommRing S]", "[FunLike F R[X] S[X]]", "(K)", "[IsDomain K]", "{K}", "(K)", "{K}", "{L R S : Type*} [Field L] [CommRing R] [IsDomain R] [CommSemiring S] [Algebra S K[X]]", "(K)", "{K}", "[Field K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\n\u22a2 x.num * y.denom + x.denom * y.num \u2260 0"}, {"line": "intro h_zero", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\n\u22a2 False"}, {"line": "have h := num_denom_add x y", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\nh : (x + y).num * (x.denom * y.denom) = (x.num * y.denom + x.denom * y.num) * (x + y).denom\n\u22a2 False"}, {"line": "rw [h_zero] at h", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\nh : (x + y).num * (x.denom * y.denom) = 0 * (x + y).denom\n\u22a2 False"}, {"line": "rw [zero_mul] at h", "tactic_state": "K : Type u_7\ninst\u271d : Field K\nx y : RatFunc K\nhxy : x + y \u2260 0\nh_zero : x.num * y.denom + x.denom * y.num = 0\nh : (x + y).num * (x.denom * y.denom) = 0\n\u22a2 False"}, {"line": "exact (mul_ne_zero (num_ne_zero hxy) (mul_ne_zero x.denom_ne_zero y.denom_ne_zero)) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_eq_div' (p q : K[X]) :\n    RatFunc.mk p q = ofFractionRing (algebraMap _ _ p / algebraMap _ _ q) := by rw [RatFunc.mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Defs.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial"], "variables": ["(K : Type u)", "{K}", "[CommRing K]", "[IsDomain K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nx\u271d : Sort u_1\nofFractionRing : x\u271d\np q : Polynomial K\n\u22a2 RatFunc.mk p q = sorry"}, {"line": "rw [RatFunc.mk]", "tactic_state": "K : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nx\u271d : Sort u_1\nofFractionRing : x\u271d\np q : Polynomial K\n\u22a2 {\n      toFractionRing :=\n        (algebraMap (Polynomial K) (FractionRing (Polynomial K))) p /\n          (algebraMap (Polynomial K) (FractionRing (Polynomial K))) q } =\n    sorry"}]}
{"declaration": "theorem liftOn_mk {P : Sort v} (p q : K[X]) (f : K[X] \u2192 K[X] \u2192 P) (f0 : \u2200 p, f p 0 = f 0 1)\n    (H' : \u2200 {p q p' q'} (_hq : q \u2260 0) (_hq' : q' \u2260 0), q' * p = q * p' \u2192 f p q = f p' q')\n    (H : \u2200 {p q p' q'} (_hq : q \u2208 K[X]\u2070) (_hq' : q' \u2208 K[X]\u2070), q' * p = q * p' \u2192 f p q = f p' q' :=\n      fun {_ _ _ _} hq hq' h => H' (nonZeroDivisors.ne_zero hq) (nonZeroDivisors.ne_zero hq') h) :\n    (RatFunc.mk p q).liftOn f @H = f p q := by\n  by_cases hq : q = 0\n  \u00b7 subst hq\n    simp only [mk_zero]\n    simp only [f0]\n    simp only [\u2190 Localization.mk_zero 1]\n    simp only [Localization.liftOn_mk]\n    simp only [liftOn_ofFractionRing_mk]\n    simp only [Submonoid.coe_one]\n  \u00b7 simp only [mk_eq_localization_mk _ hq, Localization.liftOn_mk, liftOn_ofFractionRing_mk]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/RatFunc/Defs.lean", "context": {"open": ["scoped nonZeroDivisors Polynomial"], "variables": ["(K : Type u)", "{K}", "[CommRing K]", "[IsDomain K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K \u2192 Polynomial K \u2192 P\nf0 : \u2200 (p : Polynomial K), f p 0 = f 0 1\nH' : \u2200 {p q p' q' : Polynomial K}, q \u2260 0 \u2192 q' \u2260 0 \u2192 q' * p = q * p' \u2192 f p q = f p' q'\nH :\n  optParam\n    (\u2200 {p q p' q' : Polynomial K},\n      q \u2208 nonZeroDivisors (Polynomial K) \u2192 q' \u2208 nonZeroDivisors (Polynomial K) \u2192 q' * p = q * p' \u2192 f p q = f p' q')\n    \u22ef\n\u22a2 (RatFunc.mk p q).liftOn f H = f p q"}, {"line": "by_cases hq : q = 0", "tactic_state": "case pos\nK : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K \u2192 Polynomial K \u2192 P\nf0 : \u2200 (p : Polynomial K), f p 0 = f 0 1\nH' : \u2200 {p q p' q' : Polynomial K}, q \u2260 0 \u2192 q' \u2260 0 \u2192 q' * p = q * p' \u2192 f p q = f p' q'\nH :\n  optParam\n    (\u2200 {p q p' q' : Polynomial K},\n      q \u2208 nonZeroDivisors (Polynomial K) \u2192 q' \u2208 nonZeroDivisors (Polynomial K) \u2192 q' * p = q * p' \u2192 f p q = f p' q')\n    \u22ef\nhq : q = 0\n\u22a2 (RatFunc.mk p q).liftOn f H = f p q\n---\ncase neg\nK : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K \u2192 Polynomial K \u2192 P\nf0 : \u2200 (p : Polynomial K), f p 0 = f 0 1\nH' : \u2200 {p q p' q' : Polynomial K}, q \u2260 0 \u2192 q' \u2260 0 \u2192 q' * p = q * p' \u2192 f p q = f p' q'\nH :\n  optParam\n    (\u2200 {p q p' q' : Polynomial K},\n      q \u2208 nonZeroDivisors (Polynomial K) \u2192 q' \u2208 nonZeroDivisors (Polynomial K) \u2192 q' * p = q * p' \u2192 f p q = f p' q')\n    \u22ef\nhq : \u00acq = 0\n\u22a2 (RatFunc.mk p q).liftOn f H = f p q"}, {"line": "\u00b7 subst hq\n    simp only [mk_zero]\n    simp only [f0]\n    simp only [\u2190 Localization.mk_zero 1]\n    simp only [Localization.liftOn_mk]\n    simp only [liftOn_ofFractionRing_mk]\n    simp only [Submonoid.coe_one]", "tactic_state": "case neg\nK : Type u\ninst\u271d\u00b9 : CommRing K\ninst\u271d : IsDomain K\nP : Sort v\np q : Polynomial K\nf : Polynomial K \u2192 Polynomial K \u2192 P\nf0 : \u2200 (p : Polynomial K), f p 0 = f 0 1\nH' : \u2200 {p q p' q' : Polynomial K}, q \u2260 0 \u2192 q' \u2260 0 \u2192 q' * p = q * p' \u2192 f p q = f p' q'\nH :\n  optParam\n    (\u2200 {p q p' q' : Polynomial K},\n      q \u2208 nonZeroDivisors (Polynomial K) \u2192 q' \u2208 nonZeroDivisors (Polynomial K) \u2192 q' * p = q * p' \u2192 f p q = f p' q')\n    \u22ef\nhq : \u00acq = 0\n\u22a2 (RatFunc.mk p q).liftOn f H = f p q"}, {"line": "\u00b7 simp only [mk_eq_localization_mk _ hq, Localization.liftOn_mk, liftOn_ofFractionRing_mk]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irreducible_factor (f : K[X]) : Irreducible (factor f) := by\n  rw [factor]\n  split_ifs with H\n  \u00b7 exact (Classical.choose_spec H).1\n  \u00b7 exact irreducible_X\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial", "Classical in"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\n\u22a2 Irreducible f.factor"}, {"line": "rw [factor]", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\n\u22a2 Irreducible (if H : \u2203 g, Irreducible g \u2227 g \u2223 f then Classical.choose H else X)"}, {"line": "split_ifs with H", "tactic_state": "case pos\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible (Classical.choose H)\n---\ncase neg\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u00ac\u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible X"}, {"line": "\u00b7 exact (Classical.choose_spec H).1", "tactic_state": "case neg\nK : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nH : \u00ac\u2203 g, Irreducible g \u2227 g \u2223 f\n\u22a2 Irreducible X"}, {"line": "\u00b7 exact irreducible_X", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natDegree_removeFactor' {f : K[X]} {n : \u2115} (hfn : f.natDegree = n + 1) :\n    f.removeFactor.natDegree = n := by rw [natDegree_removeFactor, hfn, n.add_sub_cancel]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/FieldTheory/SplittingField/Construction.lean", "context": {"open": ["Polynomial", "Classical in"], "variables": ["{F : Type u} {K : Type v} {L : Type w}", "[Field K] [Field L] [Field F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : Field K\nf : Polynomial K\nn : \u2115\nhfn : f.natDegree = n + 1\n\u22a2 f.removeFactor.natDegree = n"}, {"line": "rw [natDegree_removeFactor, hfn, n.add_sub_cancel]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_orthogonalProjection_of_eq_subspace {s s' : AffineSubspace \u211d P} [Nonempty s]\n    [Nonempty s'] [s.direction.HasOrthogonalProjection] [s'.direction.HasOrthogonalProjection]\n    (h : s = s') (p : P) : (orthogonalProjection s p : P) = (orthogonalProjection s' p : P) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Projection.lean", "context": {"open": ["RealInnerProductSpace", "AffineSubspace Module"], "variables": ["{V : Type*} {P : Type*}", "[NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "[NormedAddTorsor V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MetricSpace P\ninst\u271d\u2074 : NormedAddTorsor V P\nx\u271d : Sort u_3\northogonalProjection : x\u271d\ns s' : AffineSubspace \u211d P\ninst\u271d\u00b3 : Nonempty \u21a5s\ninst\u271d\u00b2 : Nonempty \u21a5s'\ninst\u271d\u00b9 : s.direction.HasOrthogonalProjection\ninst\u271d : s'.direction.HasOrthogonalProjection\nh : s = s'\np : P\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MetricSpace P\ninst\u271d\u2074 : NormedAddTorsor V P\nx\u271d : Sort u_3\northogonalProjection : x\u271d\ns : AffineSubspace \u211d P\ninst\u271d\u00b3 : Nonempty \u21a5s\ninst\u271d\u00b2 : s.direction.HasOrthogonalProjection\np : P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : s.direction.HasOrthogonalProjection\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_orthogonalProjection_eq_infNndist (s : AffineSubspace \u211d P) [Nonempty s]\n    [s.direction.HasOrthogonalProjection] (p : P) :\n    nndist p (orthogonalProjection s p) = Metric.infNndist p s := by\n  rw [\u2190 NNReal.coe_inj]\n  simp [dist_orthogonalProjection_eq_infDist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Projection.lean", "context": {"open": ["RealInnerProductSpace", "AffineSubspace Module"], "variables": ["{V : Type*} {P : Type*}", "[NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "[NormedAddTorsor V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : InnerProductSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\ninst\u271d\u00b2 : NormedAddTorsor V P\nx\u271d : Sort u_3\northogonalProjection : x\u271d\ns : AffineSubspace \u211d P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : s.direction.HasOrthogonalProjection\np : P\n\u22a2 nndist p sorry = Metric.infNndist p \u2191s"}, {"line": "rw [\u2190 NNReal.coe_inj]", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : InnerProductSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\ninst\u271d\u00b2 : NormedAddTorsor V P\nx\u271d : Sort u_3\northogonalProjection : x\u271d\ns : AffineSubspace \u211d P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : s.direction.HasOrthogonalProjection\np : P\n\u22a2 \u2191(nndist p sorry) = \u2191(Metric.infNndist p \u2191s)"}, {"line": "simp [dist_orthogonalProjection_eq_infDist]", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2075 : NormedAddCommGroup V\ninst\u271d\u2074 : InnerProductSpace \u211d V\ninst\u271d\u00b3 : MetricSpace P\ninst\u271d\u00b2 : NormedAddTorsor V P\nx\u271d : Sort u_3\northogonalProjection : x\u271d\ns : AffineSubspace \u211d P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : s.direction.HasOrthogonalProjection\np : P\n\u22a2 dist p (sorry ()) = Metric.infDist p \u2191s"}]}
{"declaration": "theorem eq_reflection_of_eq_subspace {s s' : AffineSubspace \u211d P} [Nonempty s] [Nonempty s']\n    [s.direction.HasOrthogonalProjection] [s'.direction.HasOrthogonalProjection] (h : s = s')\n    (p : P) : (reflection s p : P) = (reflection s' p : P) := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Projection.lean", "context": {"open": ["RealInnerProductSpace", "AffineSubspace Module"], "variables": ["{V : Type*} {P : Type*}", "[NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]", "[NormedAddTorsor V P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MetricSpace P\ninst\u271d\u2074 : NormedAddTorsor V P\ns s' : AffineSubspace \u211d P\ninst\u271d\u00b3 : Nonempty \u21a5s\ninst\u271d\u00b2 : Nonempty \u21a5s'\ninst\u271d\u00b9 : s.direction.HasOrthogonalProjection\ninst\u271d : s'.direction.HasOrthogonalProjection\nh : s = s'\np : P\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u2077 : NormedAddCommGroup V\ninst\u271d\u2076 : InnerProductSpace \u211d V\ninst\u271d\u2075 : MetricSpace P\ninst\u271d\u2074 : NormedAddTorsor V P\ns : AffineSubspace \u211d P\ninst\u271d\u00b3 : Nonempty \u21a5s\ninst\u271d\u00b2 : s.direction.HasOrthogonalProjection\np : P\ninst\u271d\u00b9 : Nonempty \u21a5s\ninst\u271d : s.direction.HasOrthogonalProjection\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_self_left (p\u2081 p\u2082 : P) : \u2221 p\u2081 p\u2081 p\u2082 = 0 := by simp [oangle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "context": {"open": ["Module Complex", "scoped Affine EuclideanGeometry Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\np\u2081 p\u2082 : P\n\u22a2 sorry = 0"}, {"line": "simp [oangle]", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\np\u2081 p\u2082 : P\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem oangle_self_right (p\u2081 p\u2082 : P) : \u2221 p\u2081 p\u2082 p\u2082 = 0 := by simp [oangle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Affine.lean", "context": {"open": ["Module Complex", "scoped Affine EuclideanGeometry Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V : Type*} {P : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\np\u2081 p\u2082 : P\n\u22a2 sorry = 0"}, {"line": "simp [oangle]", "tactic_state": "P : Type u_2\ninst\u271d : MetricSpace P\np\u2081 p\u2082 : P\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem oangle_zero_left (x : V) : o.oangle 0 x = 0 := by simp [oangle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 o.oangle 0 x = 0"}, {"line": "simp [oangle]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_zero_right (x : V) : o.oangle x 0 = 0 := by simp [oangle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 o.oangle x 0 = 0"}, {"line": "simp [oangle]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_add_oangle_rev (x y : V) : o.oangle x y + o.oangle y x = 0 := by\n  simp [o.oangle_rev y x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 o.oangle x y + o.oangle y x = 0"}, {"line": "simp [o.oangle_rev y x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_neg_left (x y : V) :\n    (2 : \u2124) \u2022 o.oangle (-x) y = (2 : \u2124) \u2022 o.oangle x y := by\n  by_cases hx : x = 0\n  \u00b7 simp [hx]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [o.oangle_neg_left hx hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y"}, {"line": "by_cases hx : x = 0", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y"}, {"line": "\u00b7 simp [hx]", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [o.oangle_neg_left hx hy]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle (-x) y = 2 \u2022 o.oangle x y"}]}
{"declaration": "theorem two_zsmul_oangle_neg_right (x y : V) :\n    (2 : \u2124) \u2022 o.oangle x (-y) = (2 : \u2124) \u2022 o.oangle x y := by\n  by_cases hx : x = 0\n  \u00b7 simp [hx]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [o.oangle_neg_right hx hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y"}, {"line": "by_cases hx : x = 0", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y"}, {"line": "\u00b7 simp [hx]", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [o.oangle_neg_right hx hy]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 2 \u2022 o.oangle x (-y) = 2 \u2022 o.oangle x y"}]}
{"declaration": "theorem oangle_neg_neg (x y : V) : o.oangle (-x) (-y) = o.oangle x y := by simp [oangle]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 o.oangle (-x) (-y) = o.oangle x y"}, {"line": "simp [oangle]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_neg_self_left {x : V} (hx : x \u2260 0) : o.oangle (-x) x = \u03c0 := by\n  simp [oangle_neg_left, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nhx : x \u2260 0\n\u22a2 o.oangle (-x) x = \u2191Real.pi"}, {"line": "simp [oangle_neg_left, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_neg_self_right {x : V} (hx : x \u2260 0) : o.oangle x (-x) = \u03c0 := by\n  simp [oangle_neg_right, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nhx : x \u2260 0\n\u22a2 o.oangle x (-x) = \u2191Real.pi"}, {"line": "simp [oangle_neg_right, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_neg_self_left (x : V) : (2 : \u2124) \u2022 o.oangle (-x) x = 0 := by\n  by_cases hx : x = 0 <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 2 \u2022 o.oangle (-x) x = 0"}, {"line": "by_cases hx : x = 0 <;> simp [hx]", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 OfNat V 0"}]}
{"declaration": "theorem two_zsmul_oangle_neg_self_right (x : V) : (2 : \u2124) \u2022 o.oangle x (-x) = 0 := by\n  by_cases hx : x = 0 <;> simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 2 \u2022 o.oangle x (-x) = 0"}, {"line": "by_cases hx : x = 0 <;> simp [hx]", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 OfNat V 0"}]}
{"declaration": "theorem oangle_smul_left_self_of_nonneg (x : V) {r : \u211d} (hr : 0 \u2264 r) : o.oangle (r \u2022 x) x = 0 := by\n  rcases hr.lt_or_eq with (h | h)\n  \u00b7 simp [h]\n  \u00b7 simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 o.oangle (r \u2022 x) x = 0"}, {"line": "rcases hr.lt_or_eq with (h | h)", "tactic_state": "case inl\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 < r\n\u22a2 o.oangle (r \u2022 x) x = 0\n---\ncase inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 = r\n\u22a2 o.oangle (r \u2022 x) x = 0"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 = r\n\u22a2 o.oangle (r \u2022 x) x = 0"}, {"line": "\u00b7 simp [h.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_smul_right_self_of_nonneg (x : V) {r : \u211d} (hr : 0 \u2264 r) : o.oangle x (r \u2022 x) = 0 := by\n  rcases hr.lt_or_eq with (h | h)\n  \u00b7 simp [h]\n  \u00b7 simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 o.oangle x (r \u2022 x) = 0"}, {"line": "rcases hr.lt_or_eq with (h | h)", "tactic_state": "case inl\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 < r\n\u22a2 o.oangle x (r \u2022 x) = 0\n---\ncase inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 = r\n\u22a2 o.oangle x (r \u2022 x) = 0"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\nhr : 0 \u2264 r\nh : 0 = r\n\u22a2 o.oangle x (r \u2022 x) = 0"}, {"line": "\u00b7 simp [h.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_smul_smul_self_of_nonneg (x : V) {r\u2081 r\u2082 : \u211d} (hr\u2081 : 0 \u2264 r\u2081) (hr\u2082 : 0 \u2264 r\u2082) :\n    o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0 := by\n  rcases hr\u2081.lt_or_eq with (h | h)\n  \u00b7 simp [h, hr\u2082]\n  \u00b7 simp [h.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr\u2081 r\u2082 : \u211d\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : 0 \u2264 r\u2082\n\u22a2 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0"}, {"line": "rcases hr\u2081.lt_or_eq with (h | h)", "tactic_state": "case inl\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr\u2081 r\u2082 : \u211d\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : 0 \u2264 r\u2082\nh : 0 < r\u2081\n\u22a2 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0\n---\ncase inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr\u2081 r\u2082 : \u211d\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : 0 \u2264 r\u2082\nh : 0 = r\u2081\n\u22a2 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0"}, {"line": "\u00b7 simp [h, hr\u2082]", "tactic_state": "case inr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr\u2081 r\u2082 : \u211d\nhr\u2081 : 0 \u2264 r\u2081\nhr\u2082 : 0 \u2264 r\u2082\nh : 0 = r\u2081\n\u22a2 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0"}, {"line": "\u00b7 simp [h.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_smul_left_of_ne_zero (x y : V) {r : \u211d} (hr : r \u2260 0) :\n    (2 : \u2124) \u2022 o.oangle (r \u2022 x) y = (2 : \u2124) \u2022 o.oangle x y := by\n  rcases hr.lt_or_lt with (h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\nhr : r \u2260 0\n\u22a2 2 \u2022 o.oangle (r \u2022 x) y = 2 \u2022 o.oangle x y"}, {"line": "rcases hr.lt_or_lt with (h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_smul_right_of_ne_zero (x y : V) {r : \u211d} (hr : r \u2260 0) :\n    (2 : \u2124) \u2022 o.oangle x (r \u2022 y) = (2 : \u2124) \u2022 o.oangle x y := by\n  rcases hr.lt_or_lt with (h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\nhr : r \u2260 0\n\u22a2 2 \u2022 o.oangle x (r \u2022 y) = 2 \u2022 o.oangle x y"}, {"line": "rcases hr.lt_or_lt with (h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_smul_left_self (x : V) {r : \u211d} : (2 : \u2124) \u2022 o.oangle (r \u2022 x) x = 0 := by\n  rcases lt_or_le r 0 with (h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\n\u22a2 2 \u2022 o.oangle (r \u2022 x) x = 0"}, {"line": "rcases lt_or_le r 0 with (h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_smul_right_self (x : V) {r : \u211d} : (2 : \u2124) \u2022 o.oangle x (r \u2022 x) = 0 := by\n  rcases lt_or_le r 0 with (h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr : \u211d\n\u22a2 2 \u2022 o.oangle x (r \u2022 x) = 0"}, {"line": "rcases lt_or_le r 0 with (h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_smul_smul_self (x : V) {r\u2081 r\u2082 : \u211d} :\n    (2 : \u2124) \u2022 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0 := by by_cases h : r\u2081 = 0 <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nr\u2081 r\u2082 : \u211d\n\u22a2 2 \u2022 o.oangle (r\u2081 \u2022 x) (r\u2082 \u2022 x) = 0"}, {"line": "by_cases h : r\u2081 = 0 <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_left_of_span_eq {x y : V} (z : V) (h : (\u211d \u2219 x) = \u211d \u2219 y) :\n    (2 : \u2124) \u2022 o.oangle x z = (2 : \u2124) \u2022 o.oangle y z := by\n  rw [Submodule.span_singleton_eq_span_singleton] at h\n  rcases h with \u27e8r, rfl\u27e9\n  exact (o.two_zsmul_oangle_smul_left_of_ne_zero _ _ (Units.ne_zero _)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nh : Submodule.span \u211d {x} = Submodule.span \u211d {y}\n\u22a2 2 \u2022 o.oangle x z = 2 \u2022 o.oangle y z"}, {"line": "rw [Submodule.span_singleton_eq_span_singleton] at h", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nh : \u2203 z, z \u2022 x = y\n\u22a2 2 \u2022 o.oangle x z = 2 \u2022 o.oangle y z"}, {"line": "rcases h with \u27e8r, rfl\u27e9", "tactic_state": "case intro\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx z : V\nr : \u211d\u02e3\n\u22a2 2 \u2022 o.oangle x z = 2 \u2022 o.oangle (r \u2022 x) z"}, {"line": "exact (o.two_zsmul_oangle_smul_left_of_ne_zero _ _ (Units.ne_zero _)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_oangle_right_of_span_eq (x : V) {y z : V} (h : (\u211d \u2219 y) = \u211d \u2219 z) :\n    (2 : \u2124) \u2022 o.oangle x y = (2 : \u2124) \u2022 o.oangle x z := by\n  rw [Submodule.span_singleton_eq_span_singleton] at h\n  rcases h with \u27e8r, rfl\u27e9\n  exact (o.two_zsmul_oangle_smul_right_of_ne_zero _ _ (Units.ne_zero _)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nh : Submodule.span \u211d {y} = Submodule.span \u211d {z}\n\u22a2 2 \u2022 o.oangle x y = 2 \u2022 o.oangle x z"}, {"line": "rw [Submodule.span_singleton_eq_span_singleton] at h", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nh : \u2203 z_1, z_1 \u2022 y = z\n\u22a2 2 \u2022 o.oangle x y = 2 \u2022 o.oangle x z"}, {"line": "rcases h with \u27e8r, rfl\u27e9", "tactic_state": "case intro\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\u02e3\n\u22a2 2 \u2022 o.oangle x y = 2 \u2022 o.oangle x (r \u2022 y)"}, {"line": "exact (o.two_zsmul_oangle_smul_right_of_ne_zero _ _ (Units.ne_zero _)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_add_cyc3 {x y z : V} (hx : x \u2260 0) (hy : y \u2260 0) (hz : z \u2260 0) :\n    o.oangle x y + o.oangle y z + o.oangle z x = 0 := by simp [hx, hy, hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y z : V\nhx : x \u2260 0\nhy : y \u2260 0\nhz : z \u2260 0\n\u22a2 o.oangle x y + o.oangle y z + o.oangle z x = 0"}, {"line": "simp [hx, hy, hz]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem _root_.Complex.oangle (w z : \u2102) :\n    Complex.orientation.oangle w z = Complex.arg (conj w * z) := by\n  simp [oangle, mul_comm z]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "w z : \u2102\n\u22a2 sorry = ((starRingEnd \u2102) w * z).arg"}, {"line": "simp [oangle, mul_comm z]", "tactic_state": "w z : \u2102\n\u22a2 sorry () = ((starRingEnd \u2102) w * z).arg"}]}
{"declaration": "theorem oangle_sign_smul_left (x y : V) (r : \u211d) :\n    (o.oangle (r \u2022 x) y).sign = SignType.sign r * (o.oangle x y).sign := by\n  rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\n\u22a2 (o.oangle (r \u2022 x) y).sign = SignType.sign r * (o.oangle x y).sign"}, {"line": "rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_sign_smul_right (x y : V) (r : \u211d) :\n    (o.oangle x (r \u2022 y)).sign = SignType.sign r * (o.oangle x y).sign := by\n  rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr : \u211d\n\u22a2 (o.oangle x (r \u2022 y)).sign = SignType.sign r * (o.oangle x y).sign"}, {"line": "rcases lt_trichotomy r 0 with (h | h | h) <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_sign_smul_add_smul_smul_add_smul (x y : V) (r\u2081 r\u2082 r\u2083 r\u2084 : \u211d) :\n    (o.oangle (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y)).sign =\n      SignType.sign (r\u2081 * r\u2084 - r\u2082 * r\u2083) * (o.oangle x y).sign := by\n  by_cases hr\u2081 : r\u2081 = 0\n  \u00b7 rw [hr\u2081, zero_smul, zero_mul, zero_add, zero_sub, Left.sign_neg,\n      oangle_sign_smul_left, add_comm, oangle_sign_smul_add_smul_right, oangle_rev,\n      Real.Angle.sign_neg, sign_mul, mul_neg, mul_neg, neg_mul, mul_assoc]\n  \u00b7 rw [\u2190 o.oangle_sign_smul_add_right (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y) (-r\u2083 / r\u2081), smul_add,\n      smul_smul, smul_smul, div_mul_cancel\u2080 _ hr\u2081, neg_smul, \u2190 add_assoc, add_comm (-(r\u2083 \u2022 x)), \u2190\n      sub_eq_add_neg, sub_add_cancel, \u2190 add_smul, oangle_sign_smul_right,\n      oangle_sign_smul_add_smul_left, \u2190 mul_assoc, \u2190 sign_mul, add_mul, mul_assoc, mul_comm r\u2082 r\u2081, \u2190\n      mul_assoc, div_mul_cancel\u2080 _ hr\u2081, add_comm, neg_mul, \u2190 sub_eq_add_neg, mul_comm r\u2084,\n      mul_comm r\u2083]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Basic.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr\u2081 r\u2082 r\u2083 r\u2084 : \u211d\n\u22a2 (o.oangle (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y)).sign = SignType.sign (r\u2081 * r\u2084 - r\u2082 * r\u2083) * (o.oangle x y).sign"}, {"line": "by_cases hr\u2081 : r\u2081 = 0", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr\u2081 r\u2082 r\u2083 r\u2084 : \u211d\nhr\u2081 : r\u2081 = 0\n\u22a2 (o.oangle (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y)).sign = SignType.sign (r\u2081 * r\u2084 - r\u2082 * r\u2083) * (o.oangle x y).sign\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr\u2081 r\u2082 r\u2083 r\u2084 : \u211d\nhr\u2081 : \u00acr\u2081 = 0\n\u22a2 (o.oangle (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y)).sign = SignType.sign (r\u2081 * r\u2084 - r\u2082 * r\u2083) * (o.oangle x y).sign"}, {"line": "\u00b7 rw [hr\u2081, zero_smul, zero_mul, zero_add, zero_sub, Left.sign_neg,\n      oangle_sign_smul_left, add_comm, oangle_sign_smul_add_smul_right, oangle_rev,\n      Real.Angle.sign_neg, sign_mul, mul_neg, mul_neg, neg_mul, mul_assoc]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nr\u2081 r\u2082 r\u2083 r\u2084 : \u211d\nhr\u2081 : \u00acr\u2081 = 0\n\u22a2 (o.oangle (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y)).sign = SignType.sign (r\u2081 * r\u2084 - r\u2082 * r\u2083) * (o.oangle x y).sign"}, {"line": "\u00b7 rw [\u2190 o.oangle_sign_smul_add_right (r\u2081 \u2022 x + r\u2082 \u2022 y) (r\u2083 \u2022 x + r\u2084 \u2022 y) (-r\u2083 / r\u2081), smul_add,\n      smul_smul, smul_smul, div_mul_cancel\u2080 _ hr\u2081, neg_smul, \u2190 add_assoc, add_comm (-(r\u2083 \u2022 x)), \u2190\n      sub_eq_add_neg, sub_add_cancel, \u2190 add_smul, oangle_sign_smul_right,\n      oangle_sign_smul_add_smul_left, \u2190 mul_assoc, \u2190 sign_mul, add_mul, mul_assoc, mul_comm r\u2082 r\u2081, \u2190\n      mul_assoc, div_mul_cancel\u2080 _ hr\u2081, add_comm, neg_mul, \u2190 sub_eq_add_neg, mul_comm r\u2084,\n      mul_comm r\u2083]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rotation_pi_apply (x : V) : o.rotation \u03c0 x = -x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\n\u22a2 (o.rotation \u2191Real.pi) x = -x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_rotation_self_left {x : V} (hx : x \u2260 0) (\u03b8 : Real.Angle) :\n    o.oangle (o.rotation \u03b8 x) x = -\u03b8 := by simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nhx : x \u2260 0\n\u03b8 : Real.Angle\n\u22a2 o.oangle ((o.rotation \u03b8) x) x = -\u03b8"}, {"line": "simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_rotation_self_right {x : V} (hx : x \u2260 0) (\u03b8 : Real.Angle) :\n    o.oangle x (o.rotation \u03b8 x) = \u03b8 := by simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx : V\nhx : x \u2260 0\n\u03b8 : Real.Angle\n\u22a2 o.oangle x ((o.rotation \u03b8) x) = \u03b8"}, {"line": "simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_rotation_oangle_left (x y : V) : o.oangle (o.rotation (o.oangle x y) x) y = 0 := by\n  by_cases hx : x = 0\n  \u00b7 simp [hx]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [hx, hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0"}, {"line": "by_cases hx : x = 0", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0"}, {"line": "\u00b7 simp [hx]", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : x = 0\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy]\n    \u00b7 simp [hx, hy]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\nhx : \u00acx = 0\n\u22a2 o.oangle ((o.rotation (o.oangle x y)) x) y = 0"}]}
{"declaration": "theorem oangle_rotation (x y : V) (\u03b8 : Real.Angle) :\n    o.oangle (o.rotation \u03b8 x) (o.rotation \u03b8 y) = o.oangle x y := by\n  by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp [hx, hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 o.oangle ((o.rotation \u03b8) x) ((o.rotation \u03b8) y) = o.oangle x y"}, {"line": "by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp [hx, hy]", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhy : y = 0\n\u22a2 OfNat V 0\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhy : \u00acy = 0\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : x = 0\n\u22a2 OfNat V 0\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 OfNat V 0"}]}
{"declaration": "theorem rotation_oangle_eq_iff_norm_eq (x y : V) : o.rotation (o.oangle x y) x = y \u2194 \u2016x\u2016 = \u2016y\u2016 := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 h]\n    rw [LinearIsometryEquiv.norm_map]\n  \u00b7 intro h\n    rw [o.eq_iff_oangle_eq_zero_of_norm_eq] <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 (o.rotation (o.oangle x y)) x = y \u2194 \u2016x\u2016 = \u2016y\u2016"}, {"line": "constructor", "tactic_state": "case mp\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 (o.rotation (o.oangle x y)) x = y \u2192 \u2016x\u2016 = \u2016y\u2016\n---\ncase mpr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 \u2016x\u2016 = \u2016y\u2016 \u2192 (o.rotation (o.oangle x y)) x = y"}, {"line": "\u00b7 intro h\n    rw [\u2190 h]\n    rw [LinearIsometryEquiv.norm_map]", "tactic_state": "case mpr\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u22a2 \u2016x\u2016 = \u2016y\u2016 \u2192 (o.rotation (o.oangle x y)) x = y"}, {"line": "\u00b7 intro h\n    rw [o.eq_iff_oangle_eq_zero_of_norm_eq] <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {x y : V} (\u03b8 : Real.Angle) :\n    o.oangle x y = \u03b8 \u2194\n      x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 o.rotation \u03b8 x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0) := by\n  by_cases hx : x = 0\n  \u00b7 simp [hx, eq_comm]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy, eq_comm]\n    \u00b7 rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "by_cases hx : x = 0", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : x = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "\u00b7 simp [hx, eq_comm]", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : x = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy, eq_comm]\n    \u00b7 rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 x \u2260 0 \u2227 y \u2260 0 \u2227 y = (\u2016y\u2016 / \u2016x\u2016) \u2022 (o.rotation \u03b8) x \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}]}
{"declaration": "theorem oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {x y : V} (\u03b8 : Real.Angle) :\n    o.oangle x y = \u03b8 \u2194\n      (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r : \u211d, 0 < r \u2227 y = r \u2022 o.rotation \u03b8 x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0) := by\n  by_cases hx : x = 0\n  \u00b7 simp [hx, eq_comm]\n  \u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy, eq_comm]\n    \u00b7 rw [o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Geometry/Euclidean/Angle/Oriented/Rotation.lean", "context": {"open": ["Module Complex", "scoped Real RealInnerProductSpace ComplexConjugate"], "variables": ["{V V' : Type*}", "[NormedAddCommGroup V] [NormedAddCommGroup V']", "[InnerProductSpace \u211d V] [InnerProductSpace \u211d V']", "[Fact (finrank \u211d V = 2)] [Fact (finrank \u211d V' = 2)] (o : Orientation \u211d V (Fin 2))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "by_cases hx : x = 0", "tactic_state": "V : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\n\u22a2 OfNat V 0\n---\ncase pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : x = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "\u00b7 simp [hx, eq_comm]", "tactic_state": "case pos\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : x = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)\n---\ncase neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}, {"line": "\u00b7 by_cases hy : y = 0\n    \u00b7 simp [hy, eq_comm]\n    \u00b7 rw [o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]", "tactic_state": "case neg\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : Fact (finrank \u211d V = 2)\no : Orientation \u211d V (Fin 2)\nx y : V\n\u03b8 : Real.Angle\nhx : \u00acx = 0\n\u22a2 o.oangle x y = \u03b8 \u2194 (x \u2260 0 \u2227 y \u2260 0 \u2227 \u2203 r, 0 < r \u2227 y = r \u2022 (o.rotation \u03b8) x) \u2228 \u03b8 = 0 \u2227 (x = 0 \u2228 y = 0)"}]}
