{"declaration": "theorem prod_bind [CommMonoid \u03b2] (s : Multiset \u03b1) (t : \u03b1 \u2192 Multiset \u03b2) :\n    (s.bind t).prod = (s.map fun a => (t a).prod).prod := by simp [bind]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d : CommMonoid \u03b2\ns : Multiset \u03b1\nt : \u03b1 \u2192 Multiset \u03b2\n\u22a2 (s.bind t).prod = (Multiset.map (fun a => (t a).prod) s).prod"}, {"line": "simp [bind]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fold_bind {\u03b9 : Type*} (s : Multiset \u03b9) (t : \u03b9 \u2192 Multiset \u03b1) (b : \u03b9 \u2192 \u03b1) (b\u2080 : \u03b1) :\n    (s.bind t).fold op ((s.map b).fold op b\u2080) =\n    (s.map fun i => (t i).fold op (b i)).fold op b\u2080 := by\n  induction' s using Multiset.induction_on with a ha ih\n  \u00b7 rw [zero_bind, map_zero, map_zero, fold_zero]\n  \u00b7 rw [cons_bind, map_cons, map_cons, fold_cons_left, fold_cons_left, fold_add, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nhc : Std.Commutative op\nha : Std.Associative op\n\u03b9 : Type u_1\ns : Multiset \u03b9\nt : \u03b9 \u2192 Multiset \u03b1\nb : \u03b9 \u2192 \u03b1\nb\u2080 : \u03b1\n\u22a2 Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b s)) (s.bind t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) s)"}, {"line": "induction' s using Multiset.induction_on with a ha ih", "tactic_state": "case empty\n\u03b1 : Type u_2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nhc : Std.Commutative op\nha : Std.Associative op\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Multiset \u03b1\nb : \u03b9 \u2192 \u03b1\nb\u2080 : \u03b1\n\u22a2 Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b 0)) (Multiset.bind 0 t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) 0)\n---\ncase cons\n\u03b1 : Type u_2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nhc : Std.Commutative op\nha\u271d : Std.Associative op\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Multiset \u03b1\nb : \u03b9 \u2192 \u03b1\nb\u2080 : \u03b1\na : \u03b9\nha : Multiset \u03b9\nih :\n  Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b ha)) (ha.bind t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) ha)\n\u22a2 Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b (a ::\u2098 ha))) ((a ::\u2098 ha).bind t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) (a ::\u2098 ha))"}, {"line": "\u00b7 rw [zero_bind, map_zero, map_zero, fold_zero]", "tactic_state": "case cons\n\u03b1 : Type u_2\nop : \u03b1 \u2192 \u03b1 \u2192 \u03b1\nhc : Std.Commutative op\nha\u271d : Std.Associative op\n\u03b9 : Type u_1\nt : \u03b9 \u2192 Multiset \u03b1\nb : \u03b9 \u2192 \u03b1\nb\u2080 : \u03b1\na : \u03b9\nha : Multiset \u03b9\nih :\n  Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b ha)) (ha.bind t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) ha)\n\u22a2 Multiset.fold op (Multiset.fold op b\u2080 (Multiset.map b (a ::\u2098 ha))) ((a ::\u2098 ha).bind t) =\n    Multiset.fold op b\u2080 (Multiset.map (fun i => Multiset.fold op (b i) (t i)) (a ::\u2098 ha))"}, {"line": "\u00b7 rw [cons_bind, map_cons, map_cons, fold_cons_left, fold_cons_left, fold_add, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_product : (a ::\u2098 s) \u00d7\u02e2 t = map (Prod.mk a) t + s \u00d7\u02e2 t := by simp [SProd.sprod, product]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\na : \u03b1\ns : Multiset \u03b1\nt : Multiset \u03b2\nx\u271d : Sort u_1\nmap : x\u271d\n\u22a2 (a ::\u2098 s) \u00d7\u02e2 t = sorry + s \u00d7\u02e2 t"}, {"line": "simp [SProd.sprod, product]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\na : \u03b1\ns : Multiset \u03b1\nt : Multiset \u03b2\nx\u271d : Sort u_1\nmap : x\u271d\n\u22a2 (a ::\u2098 s).product t = sorry () + s.product t"}]}
{"declaration": "theorem product_zero : s \u00d7\u02e2 (0 : Multiset \u03b2) = 0 := by simp [SProd.sprod, product]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Multiset \u03b1\n\u22a2 s \u00d7\u02e2 0 = 0"}, {"line": "simp [SProd.sprod, product]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : Multiset \u03b1\n\u22a2 s.product 0 = 0"}]}
{"declaration": "theorem product_cons : s \u00d7\u02e2 (b ::\u2098 t) = (s.map fun a => (a, b)) + s \u00d7\u02e2 t := by\n  simp [SProd.sprod, product]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 s \u00d7\u02e2 (b ::\u2098 t) = Multiset.map (fun a => (a, b)) s + s \u00d7\u02e2 t"}, {"line": "simp [SProd.sprod, product]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 s.product (b ::\u2098 t) = Multiset.map (fun a => (a, b)) s + s.product t"}]}
{"declaration": "theorem add_product (s t : Multiset \u03b1) (u : Multiset \u03b2) : (s + t) \u00d7\u02e2 u = s \u00d7\u02e2 u + t \u00d7\u02e2 u := by\n  simp [SProd.sprod, product]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Multiset \u03b1\nu : Multiset \u03b2\n\u22a2 (s + t) \u00d7\u02e2 u = s \u00d7\u02e2 u + t \u00d7\u02e2 u"}, {"line": "simp [SProd.sprod, product]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns t : Multiset \u03b1\nu : Multiset \u03b2\n\u22a2 (s + t).product u = s.product u + t.product u"}]}
{"declaration": "theorem card_product : card (s \u00d7\u02e2 t) = card s * card t := by simp [SProd.sprod, product]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\n\u22a2 sorry = sorry * sorry"}, {"line": "simp [SProd.sprod, product]", "tactic_state": "x\u271d : Sort u_1\ncard : x\u271d\n\u22a2 sorry () = sorry () * sorry ()"}]}
{"declaration": "theorem cons_sigma : (a ::\u2098 s).sigma t = (t a).map (Sigma.mk a) + s.sigma t := by\n  simp [Multiset.sigma]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)", "{s t}", "{\u03c3 : \u03b1 \u2192 Type*} (a : \u03b1) (s : Multiset \u03b1) (t : \u2200 a, Multiset (\u03c3 a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03c3 : \u03b1 \u2192 Type u_1\na : \u03b1\ns : Multiset \u03b1\nt : (a : \u03b1) \u2192 Multiset (\u03c3 a)\n\u22a2 (a ::\u2098 s).sigma t = Multiset.map (Sigma.mk a) (t a) + s.sigma t"}, {"line": "simp [Multiset.sigma]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_sigma (s t : Multiset \u03b1) (u : \u2200 a, Multiset (\u03c3 a)) :\n    (s + t).sigma u = s.sigma u + t.sigma u := by simp [Multiset.sigma]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)", "{s t}", "{\u03c3 : \u03b1 \u2192 Type*} (a : \u03b1) (s : Multiset \u03b1) (t : \u2200 a, Multiset (\u03c3 a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03c3 : \u03b1 \u2192 Type u_1\ns t : Multiset \u03b1\nu : (a : \u03b1) \u2192 Multiset (\u03c3 a)\n\u22a2 (s + t).sigma u = s.sigma u + t.sigma u"}, {"line": "simp [Multiset.sigma]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sigma : card (s.sigma t) = sum (map (fun a => card (t a)) s) := by\n  simp [Multiset.sigma, (\u00b7 \u2218 \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Bind.lean", "context": {"open": ["scoped Relator in", "scoped Function in -- required for scoped `on` notation"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 \u03b4 : Type*}", "(a : \u03b1) (s t : Multiset \u03b1) (f g : \u03b1 \u2192 Multiset \u03b2)", "{f s t}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]", "(a : \u03b1) (b : \u03b2) (s : Multiset \u03b1) (t : Multiset \u03b2)", "{s t}", "{\u03c3 : \u03b1 \u2192 Type*} (a : \u03b1) (s : Multiset \u03b1) (t : \u2200 a, Multiset (\u03c3 a))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\ncard : x\u271d\u00b9\nx\u271d : Sort u_3\nsum : x\u271d\n\u22a2 sorry = sorry"}, {"line": "simp [Multiset.sigma, (\u00b7 \u2218 \u00b7)]", "tactic_state": "x\u271d\u00b9 : Sort u_2\ncard : x\u271d\u00b9\nx\u271d : Sort u_3\nsum : x\u271d\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem fold_cons_right (b a : \u03b1) (s : Multiset \u03b1) : (a ::\u2098 s).fold op b = s.fold op b * a := by\n  simp [hc.comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fold.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "(op : \u03b1 \u2192 \u03b1 \u2192 \u03b1) [hc : Std.Commutative op] [ha : Std.Associative op]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nb a : \u03b1\ns : Multiset \u03b1\n\u22a2 sorry"}, {"line": "simp [hc.comm]", "tactic_state": "\u03b1 : Type u_1\nb a : \u03b1\ns : Multiset \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem sort_cons (a : \u03b1) (s : Multiset \u03b1) :\n    (\u2200 b \u2208 s, r a b) \u2192 sort r (a ::\u2098 s) = a :: sort r s := by\n  refine Quot.inductionOn s fun l => ?_\n  simpa [mergeSort_eq_insertionSort] using insertionSort_cons r (a := a) (l := l)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Sort.lean", "context": {"open": ["List"], "variables": ["{\u03b1 \u03b2 : Type*}", "(r : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel r] [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] [IsTotal \u03b1 r]", "(r' : \u03b2 \u2192 \u03b2 \u2192 Prop) [DecidableRel r'] [IsTrans \u03b2 r'] [IsAntisymm \u03b2 r'] [IsTotal \u03b2 r']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidableRel r\ninst\u271d\u00b2 : IsTrans \u03b1 r\ninst\u271d\u00b9 : IsAntisymm \u03b1 r\ninst\u271d : IsTotal \u03b1 r\nx\u271d : Sort u_3\nsort : x\u271d\na : \u03b1\ns : Multiset \u03b1\n\u22a2 (\u2200 b \u2208 s, r a b) \u2192 sorry = a :: sorry"}, {"line": "refine Quot.inductionOn s fun l => ?_", "tactic_state": "\u03b1 : Type u_1\nr : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d\u00b3 : DecidableRel r\ninst\u271d\u00b2 : IsTrans \u03b1 r\ninst\u271d\u00b9 : IsAntisymm \u03b1 r\ninst\u271d : IsTotal \u03b1 r\nx\u271d : Sort u_3\nsort : x\u271d\na : \u03b1\ns : Multiset \u03b1\nl : List \u03b1\n\u22a2 (\u2200 b \u2208 Quot.mk (\u21d1(isSetoid \u03b1)) l, r a b) \u2192 sorry = a :: sorry"}, {"line": "simpa [mergeSort_eq_insertionSort] using insertionSort_cons r (a := a) (l := l)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_sym2 {m : Multiset \u03b1} :\n    Multiset.card m.sym2 = Nat.choose (Multiset.card m + 1) 2 := by\n  refine m.inductionOn fun xs => ?_\n  simp [List.length_sym2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Sym.lean", "context": {"open": ["scoped List in"], "variables": ["{\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nm : Multiset \u03b1\n\u22a2 m.sym2.card = (m.card + 1).choose 2"}, {"line": "refine m.inductionOn fun xs => ?_", "tactic_state": "\u03b1 : Type u_1\nm : Multiset \u03b1\nxs : List \u03b1\n\u22a2 (Multiset.sym2 \u27e6xs\u27e7).card = (Multiset.card \u27e6xs\u27e7 + 1).choose 2"}, {"line": "simp [List.length_sym2]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_right (s t : Multiset \u03b1) : s \u2264 s + t := by\n  simpa using Multiset.add_le_add_left (zero_le t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/AddSub.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "{s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 s \u2264 s + t"}, {"line": "simpa using Multiset.add_le_add_left (zero_le t)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_left (s t : Multiset \u03b1) : s \u2264 t + s := by\n  simpa using Multiset.add_le_add_right (zero_le t)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/AddSub.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "{s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 s \u2264 t + s"}, {"line": "simpa using Multiset.add_le_add_right (zero_le t)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem erase_cons_tail_of_mem (h : a \u2208 s) :\n    (b ::\u2098 s).erase a = b ::\u2098 s.erase a := by\n  rcases eq_or_ne a b with rfl | hab\n  \u00b7 simp [cons_erase h]\n  \u00b7 exact s.erase_cons_tail hab.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/AddSub.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "{s t u : Multiset \u03b1}", "(p : \u03b1 \u2192 Prop) [DecidablePred p]", "[DecidableEq \u03b1] in", "[DecidableEq \u03b1] {s t : Multiset \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Multiset \u03b1\na b : \u03b1\nh : a \u2208 s\n\u22a2 sorry = b ::\u2098 sorry"}, {"line": "rcases eq_or_ne a b with rfl | hab", "tactic_state": "case inl\n\u03b1 : Type u_1\ns : Multiset \u03b1\na : \u03b1\nh : a \u2208 s\n\u22a2 sorry = a ::\u2098 sorry\n---\ncase inr\n\u03b1 : Type u_1\ns : Multiset \u03b1\na b : \u03b1\nh : a \u2208 s\nhab : a \u2260 b\n\u22a2 sorry = b ::\u2098 sorry"}, {"line": "\u00b7 simp [cons_erase h]", "tactic_state": "case inr\n\u03b1 : Type u_1\ns : Multiset \u03b1\na b : \u03b1\nh : a \u2208 s\nhab : a \u2260 b\n\u22a2 sorry = b ::\u2098 sorry"}, {"line": "\u00b7 exact s.erase_cons_tail hab.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem empty_toList {s : Multiset \u03b1} : s.toList.isEmpty \u2194 s = 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Basic.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Multiset \u03b1\n\u22a2 s.toList.isEmpty = true \u2194 s = 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sizeOf_lt_sizeOf_of_mem [SizeOf \u03b1] {x : \u03b1} {s : Multiset \u03b1} (hx : x \u2208 s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s := by\n  induction s using Quot.inductionOn\n  exact List.sizeOf_lt_sizeOf_of_mem hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Basic.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(p : \u03b1 \u2192 Prop) [DecidablePred p] (l : Multiset \u03b1)", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\ns : Multiset \u03b1\nhx : x \u2208 s\n\u22a2 sizeOf x < sizeOf s"}, {"line": "induction s using Quot.inductionOn", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : SizeOf \u03b1\nx : \u03b1\na\u271d : List \u03b1\nhx : x \u2208 Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d\n\u22a2 sizeOf x < sizeOf (Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d)"}, {"line": "exact List.sizeOf_lt_sizeOf_of_mem hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countP_congr {s s' : Multiset \u03b1} (hs : s = s')\n    {p p' : \u03b1 \u2192 Prop} [DecidablePred p] [DecidablePred p']\n    (hp : \u2200 x \u2208 s, p x = p' x) : s.countP p = s'.countP p' := by\n  revert hs hp\n  exact Quot.induction_on\u2082 s s'\n    (fun l l' hs hp => by\n      simp only [quot_mk_to_coe''] at hs\n      simp only [coe_eq_coe] at hs\n      apply hs.countP_congr\n      simpa using hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Count.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(p : \u03b1 \u2192 Prop) [DecidablePred p]", "{p}", "(p)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns s' : Multiset \u03b1\nhs : s = s'\np p' : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred p'\nhp : \u2200 x \u2208 s, p x = p' x\n\u22a2 Multiset.countP p s = Multiset.countP p' s'"}, {"line": "revert hs hp", "tactic_state": "\u03b1 : Type u_1\ns s' : Multiset \u03b1\np p' : \u03b1 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\ninst\u271d : DecidablePred p'\n\u22a2 s = s' \u2192 (\u2200 x \u2208 s, p x = p' x) \u2192 Multiset.countP p s = Multiset.countP p' s'"}, {"line": "exact Quot.induction_on\u2082 s s'\n    (fun l l' hs hp => by\n      simp only [quot_mk_to_coe''] at hs\n      simp only [coe_eq_coe] at hs\n      apply hs.countP_congr\n      simpa using hp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_pos {a : \u03b1} {s : Multiset \u03b1} : 0 < count a s \u2194 a \u2208 s := by simp [count, countP_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Count.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(p : \u03b1 \u2192 Prop) [DecidablePred p]", "{p}", "(p)", "{p}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\n\u22a2 0 < sorry \u2194 a \u2208 s"}, {"line": "simp [count, countP_pos]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns : Multiset \u03b1\n\u22a2 0 < sorry () \u2194 a \u2208 s"}]}
{"declaration": "theorem count_eq_card {a : \u03b1} {s} : count a s = card s \u2194 \u2200 x \u2208 s, a = x := by\n  simp [countP_eq_card, count, @eq_comm _ a]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Count.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(p : \u03b1 \u2192 Prop) [DecidablePred p]", "{p}", "(p)", "{p}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\ncard : x\u271d\na : \u03b1\ns : List \u03b1\n\u22a2 List.count a s = sorry \u2194 \u2200 x \u2208 s, a = x"}, {"line": "simp [countP_eq_card, count, @eq_comm _ a]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_3\ncard : x\u271d\na : \u03b1\ns : List \u03b1\n\u22a2 List.count a s = sorry () \u2194 \u2200 x \u2208 s, x = a"}]}
{"declaration": "theorem dedup_map_dedup_eq [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) :\n    dedup (map f (dedup s)) = dedup (map f s) := by\n  simp [dedup_ext]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Dedup.lean", "context": {"open": ["List"], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\n\u22a2 (map f sorry.dedup).dedup = (map f sorry).dedup"}, {"line": "simp [dedup_ext]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\n\u22a2 (map f (sorry ()).dedup).dedup = (map f (sorry ())).dedup"}]}
{"declaration": "private lemma transGen_oneStep_eq_isDershowitzMannaLT :\n    (TransGen OneStep : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop) = IsDershowitzMannaLT := by\n  ext M N\n  exact \u27e8isDershowitzMannaLT_of_transGen_oneStep, transGen_oneStep_of_isDershowitzMannaLT\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/DershowitzManna.lean", "context": {"open": ["Relation"], "variables": ["{\u03b1 : Type*} [Preorder \u03b1] {M N P : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nOneStep IsDershowitzMannaLT : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop\n\u22a2 TransGen OneStep = IsDershowitzMannaLT"}, {"line": "ext M N", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\ninst\u271d : Preorder \u03b1\nOneStep IsDershowitzMannaLT : Multiset \u03b1 \u2192 Multiset \u03b1 \u2192 Prop\nM N : Multiset \u03b1\n\u22a2 TransGen OneStep M N \u2194 IsDershowitzMannaLT M N"}, {"line": "exact \u27e8isDershowitzMannaLT_of_transGen_oneStep, transGen_oneStep_of_isDershowitzMannaLT\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_map {\u03b1 \u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (s : Multiset \u03b1) [DecidableEq \u03b2] (b : \u03b2) :\n    count b (map f s) = card (s.filter fun a => b = f a) := by\n  simp [Bool.beq_eq_decide_eq, eq_comm, count, countP_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Filter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(p : \u03b1 \u2192 Prop) [DecidablePred p]", "{p}", "(p)", "[DecidableEq \u03b1] {s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_5\ncard : x\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 sorry = sorry"}, {"line": "simp [Bool.beq_eq_decide_eq, eq_comm, count, countP_map]", "tactic_state": "x\u271d : Sort u_5\ncard : x\u271d\n\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b1 \u2192 \u03b2\ns : Multiset \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem length_ndinsert_of_not_mem {a : \u03b1} {s : Multiset \u03b1} (h : a \u2209 s) :\n    card (ndinsert a s) = card s + 1 := by simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/FinsetOps.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\ncard : x\u271d\na : \u03b1\ns : Multiset \u03b1\nh : a \u2209 s\n\u22a2 sorry = sorry + 1"}, {"line": "simp [h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\ncard : x\u271d\na : \u03b1\ns : Multiset \u03b1\nh : a \u2209 s\n\u22a2 False"}]}
{"declaration": "theorem Disjoint.ndunion_eq {s t : Multiset \u03b1} (h : Disjoint s t) :\n    s.ndunion t = s.dedup + t := by\n  induction s, t using Quot.induction_on\u2082\n  exact congr_arg ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) <| List.Disjoint.union_eq <| by simpa using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/FinsetOps.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nh : _root_.Disjoint s t\n\u22a2 s.ndunion t = s.dedup + t"}, {"line": "induction s, t using Quot.induction_on\u2082", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na\u271d b\u271d : List \u03b1\nh : _root_.Disjoint (Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d) (Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d)\n\u22a2 Multiset.ndunion (Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d) (Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d) =\n    Multiset.dedup (Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d) + Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d"}, {"line": "exact congr_arg ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) <| List.Disjoint.union_eq <| by simpa using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subset.ndunion_eq_right {s t : Multiset \u03b1} (h : s \u2286 t) : s.ndunion t = t := by\n  induction s, t using Quot.induction_on\u2082\n  exact congr_arg ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) <| List.Subset.union_eq_right h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/FinsetOps.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\nh : s \u2286 t\n\u22a2 s.ndunion t = t"}, {"line": "induction s, t using Quot.induction_on\u2082", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na\u271d b\u271d : List \u03b1\nh : Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d \u2286 Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d\n\u22a2 Multiset.ndunion (Quot.mk (\u21d1(isSetoid \u03b1)) a\u271d) (Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d) = Quot.mk (\u21d1(isSetoid \u03b1)) b\u271d"}, {"line": "exact congr_arg ((\u2191) : List \u03b1 \u2192 Multiset \u03b1) <| List.Subset.union_eq_right h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_ndinter_of_mem {a : \u03b1} (s : Multiset \u03b1) {t : Multiset \u03b1} (h : a \u2208 t) :\n    ndinter (a ::\u2098 s) t = a ::\u2098 ndinter s t := by simp [ndinter, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/FinsetOps.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nndinter : x\u271d\na : \u03b1\ns t : Multiset \u03b1\nh : a \u2208 t\n\u22a2 sorry = a ::\u2098 sorry"}, {"line": "simp [ndinter, h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nndinter : x\u271d\na : \u03b1\ns t : Multiset \u03b1\nh : a \u2208 t\n\u22a2 sorry () = a ::\u2098 sorry ()"}]}
{"declaration": "theorem le_ndinter {s t u : Multiset \u03b1} : s \u2264 ndinter t u \u2194 s \u2264 t \u2227 s \u2286 u := by\n  simp [ndinter, le_filter, subset_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/FinsetOps.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nndinter : x\u271d\ns t u : Multiset \u03b1\n\u22a2 s \u2264 sorry \u2194 s \u2264 t \u2227 s \u2286 u"}, {"line": "simp [ndinter, le_filter, subset_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nx\u271d : Sort u_2\nndinter : x\u271d\ns t u : Multiset \u03b1\n\u22a2 s \u2264 sorry () \u2194 s \u2264 t \u2227 s \u2286 u"}]}
{"declaration": "theorem toEnumFinset_mono {m\u2081 m\u2082 : Multiset \u03b1} (h : m\u2081 \u2264 m\u2082) :\n    m\u2081.toEnumFinset \u2286 m\u2082.toEnumFinset := by\n  intro p\n  simp only [Multiset.mem_toEnumFinset]\n  exact gt_of_ge_of_gt (Multiset.le_iff_count.mp h p.1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\n\u22a2 m\u2081.toEnumFinset \u2286 m\u2082.toEnumFinset"}, {"line": "intro p", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p \u2208 m\u2081.toEnumFinset \u2192 p \u2208 m\u2082.toEnumFinset"}, {"line": "simp only [Multiset.mem_toEnumFinset]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm\u2081 m\u2082 : Multiset \u03b1\nh : m\u2081 \u2264 m\u2082\np : \u03b1 \u00d7 \u2115\n\u22a2 p.2 < Multiset.count p.1 m\u2081 \u2192 p.2 < Multiset.count p.1 m\u2082"}, {"line": "exact gt_of_ge_of_gt (Multiset.le_iff_count.mp h p.1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toEmbedding_coeEquiv_trans (m : Multiset \u03b1) :\n    m.coeEquiv.toEmbedding.trans (Function.Embedding.subtype _) = m.coeEmbedding := by ext <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\n\u22a2 m.coeEquiv.toEmbedding.trans (Function.Embedding.subtype fun x => x \u2208 m.toEnumFinset) = m.coeEmbedding"}, {"line": "ext <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_univ_comp_coe {\u03b2 : Type*} (m : Multiset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    ((Finset.univ : Finset m).val.map (f \u2218 (fun x : m \u21a6 (x : \u03b1)))) = m.map f := by\n  rw [\u2190 Multiset.map_map]\n  rw [Multiset.map_univ_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : Type u_3\nm : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map (f \u2218 fun x => x.fst) Finset.univ.val = Multiset.map f m"}, {"line": "rw [\u2190 Multiset.map_map]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : Type u_3\nm : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map f (Multiset.map (fun x => x.fst) Finset.univ.val) = Multiset.map f m"}, {"line": "rw [Multiset.map_univ_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_univ {\u03b2 : Type*} (m : Multiset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    ((Finset.univ : Finset m).val.map fun (x : m) \u21a6 f (x : \u03b1)) = m.map f := by\n  simp_rw [\u2190 Function.comp_apply (f := f)]\n  exact map_univ_comp_coe m f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : Type u_3\nm : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map (fun x => f x.fst) Finset.univ.val = Multiset.map f m"}, {"line": "simp_rw [\u2190 Function.comp_apply (f := f)]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b2 : Type u_3\nm : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map (fun x => (f \u2218 Sigma.fst) x) Finset.univ.val = Multiset.map f m"}, {"line": "exact map_univ_comp_coe m f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_prod_coe [CommMonoid \u03b1] (m : Multiset \u03b1) : m.prod = \u220f x : m, (x : \u03b1) := by\n  congr\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\n\u22a2 m.prod = \u220f x, x.fst"}, {"line": "congr", "tactic_state": "case e_a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\n\u22a2 m = Multiset.map (fun x => x.fst) Finset.univ.val"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_eq_prod_toEnumFinset [CommMonoid \u03b1] (m : Multiset \u03b1) :\n    m.prod = \u220f x \u2208 m.toEnumFinset, x.1 := by\n  congr\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\n\u22a2 m.prod = \u220f x \u2208 m.toEnumFinset, x.1"}, {"line": "congr", "tactic_state": "case e_a\n\u03b1 : Type u_1\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : CommMonoid \u03b1\nm : Multiset \u03b1\n\u22a2 m = Multiset.map (fun x => x.1) m.toEnumFinset.val"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coe_consEquiv_of_eq_of_eq {v : \u03b1} (x : v ::\u2098 m) (hx : \u2191x = v) (hx2 : x.2 = m.count v) :\n    consEquiv x = none := by simp [consEquiv, hx, hx2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\nx\u271d : Sort u_3\nconsEquiv : x\u271d\nv : \u03b1\nx : (v ::\u2098 m).ToType\nhx : x.fst = v\nhx2 : \u2191x.snd = Multiset.count v m\n\u22a2 sorry = none"}, {"line": "simp [consEquiv, hx, hx2]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\nx\u271d : Sort u_3\nconsEquiv : x\u271d\nv : \u03b1\nx : (v ::\u2098 m).ToType\nhx : x.fst = v\nhx2 : \u2191x.snd = Multiset.count v m\n\u22a2 sorry () = none"}]}
{"declaration": "lemma coe_consEquiv_of_eq_of_lt {v : \u03b1} (x : v ::\u2098 m) (hx : \u2191x = v) (hx2 : x.2 < m.count v) :\n    consEquiv x = some \u27e8x.1, \u27e8x.2, by simpa [hx]\u27e9\u27e9 := by simp [consEquiv, hx, hx2.ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Fintype.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} [DecidableEq \u03b1] [DecidableEq \u03b2] {m : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\nx\u271d : Sort u_3\nconsEquiv : x\u271d\nv : \u03b1\nx : (v ::\u2098 m).ToType\nhx : x.fst = v\nhx2 : \u2191x.snd < Multiset.count v m\n\u22a2 sorry = some sorry"}, {"line": "simp [consEquiv, hx, hx2.ne]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nm : Multiset \u03b1\nx\u271d : Sort u_3\nconsEquiv : x\u271d\nv : \u03b1\nx : (v ::\u2098 m).ToType\nhx : x.fst = v\nhx2 : \u2191x.snd < Multiset.count v m\n\u22a2 sorry () = some (sorry ())"}]}
{"declaration": "theorem id_traverse {\u03b1 : Type*} (x : Multiset \u03b1) : traverse (pure : \u03b1 \u2192 Id \u03b1) x = x := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp [traverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Functor.lean", "context": {"open": ["List", "LawfulTraversable CommApplicative", "Functor", "Traversable LawfulTraversable"], "variables": ["{F : Type u \u2192 Type u} [Applicative F] [CommApplicative F]", "{\u03b1' \u03b2' : Type u} (f : \u03b1' \u2192 F \u03b2')"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : Multiset \u03b1\n\u22a2 sorry = x"}, {"line": "refine Quotient.inductionOn x ?_", "tactic_state": "\u03b1 : Type u_1\nx : Multiset \u03b1\n\u22a2 \u2200 (a : List \u03b1), sorry = \u27e6a\u27e7"}, {"line": "intro", "tactic_state": "\u03b1 : Type u_1\nx : Multiset \u03b1\na\u271d : List \u03b1\n\u22a2 sorry = \u27e6a\u271d\u27e7"}, {"line": "simp [traverse]", "tactic_state": "\u03b1 : Type u_1\nx : Multiset \u03b1\na\u271d : List \u03b1\n\u22a2 sorry () = \u2191a\u271d"}]}
{"declaration": "theorem map_comp_cons (f : \u03b1 \u2192 \u03b2) (t) : map f \u2218 cons t = cons (f t) \u2218 map f := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/MapFold.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\n\u22a2 sorry \u2218 cons t = cons (f t) \u2218 List.map f"}, {"line": "ext", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nx\u271d : List \u03b1\ni\u271d : \u2115\na\u271d : \u03b2\n\u22a2 a\u271d \u2208 ((sorry \u2218 cons t) x\u271d)[i\u271d]? \u2194 a\u271d \u2208 ((cons (f t) \u2218 List.map f) x\u271d)[i\u271d]?"}, {"line": "simp", "tactic_state": "case h.h.a\n\u03b1 : Type u_1\n\u03b2 : Type v\nf : \u03b1 \u2192 \u03b2\nt : \u03b1\nx\u271d : List \u03b1\ni\u271d : \u2115\na\u271d : \u03b2\n\u22a2 (sorry () (t :: x\u271d))[i\u271d]? = some a\u271d \u2194 (f t :: List.map f x\u271d)[i\u271d]? = some a\u271d"}]}
{"declaration": "theorem map_eq_zero {s : Multiset \u03b1} {f : \u03b1 \u2192 \u03b2} : s.map f = 0 \u2194 s = 0 := by\n  rw [\u2190 Multiset.card_eq_zero]\n  rw [Multiset.card_map]\n  rw [Multiset.card_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/MapFold.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ns : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 Multiset.map f s = 0 \u2194 s = 0"}, {"line": "rw [\u2190 Multiset.card_eq_zero]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ns : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 (Multiset.map f s).card = 0 \u2194 s = 0"}, {"line": "rw [Multiset.card_map]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ns : Multiset \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 s.card = 0 \u2194 s = 0"}, {"line": "rw [Multiset.card_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_erase [DecidableEq \u03b1] [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) (x : \u03b1)\n    (s : Multiset \u03b1) : (s.erase x).map f = (s.map f).erase (f x) := by\n  induction s using Multiset.induction_on with | empty => simp | cons y s ih => ?_\n  by_cases hxy : y = x\n  \u00b7 cases hxy\n    simp\n  \u00b7 rw [s.erase_cons_tail hxy, map_cons, map_cons, (s.map f).erase_cons_tail (hf.ne hxy), ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/MapFold.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx : \u03b1\ns : Multiset \u03b1\n\u22a2 Multiset.map f (s.erase x) = (Multiset.map f s).erase (f x)"}, {"line": "induction s using Multiset.induction_on with | empty => simp | cons y s ih => ?_", "tactic_state": "case cons\n\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y : \u03b1\ns : Multiset \u03b1\nih : Multiset.map f (s.erase x) = (Multiset.map f s).erase (f x)\n\u22a2 Multiset.map f ((y ::\u2098 s).erase x) = (Multiset.map f (y ::\u2098 s)).erase (f x)"}, {"line": "by_cases hxy : y = x", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y : \u03b1\ns : Multiset \u03b1\nih : Multiset.map f (s.erase x) = (Multiset.map f s).erase (f x)\nhxy : y = x\n\u22a2 Multiset.map f ((y ::\u2098 s).erase x) = (Multiset.map f (y ::\u2098 s)).erase (f x)\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y : \u03b1\ns : Multiset \u03b1\nih : Multiset.map f (s.erase x) = (Multiset.map f s).erase (f x)\nhxy : \u00acy = x\n\u22a2 Multiset.map f ((y ::\u2098 s).erase x) = (Multiset.map f (y ::\u2098 s)).erase (f x)"}, {"line": "\u00b7 cases hxy\n    simp", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type v\ninst\u271d\u00b9 : DecidableEq \u03b1\ninst\u271d : DecidableEq \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : Injective f\nx y : \u03b1\ns : Multiset \u03b1\nih : Multiset.map f (s.erase x) = (Multiset.map f s).erase (f x)\nhxy : \u00acy = x\n\u22a2 Multiset.map f ((y ::\u2098 s).erase x) = (Multiset.map f (y ::\u2098 s)).erase (f x)"}, {"line": "\u00b7 rw [s.erase_cons_tail hxy, map_cons, map_cons, (s.map f).erase_cons_tail (hf.ne hxy), ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_eq_map_of_bij_of_nodup (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3) {s : Multiset \u03b1} {t : Multiset \u03b2}\n    (hs : s.Nodup) (ht : t.Nodup) (i : \u2200 a \u2208 s, \u03b2) (hi : \u2200 a ha, i a ha \u2208 t)\n    (i_inj : \u2200 a\u2081 ha\u2081 a\u2082 ha\u2082, i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082)\n    (i_surj : \u2200 b \u2208 t, \u2203 a ha, i a ha = b) (h : \u2200 a ha, f a = g (i a ha)) : s.map f = t.map g := by\n  have : t = s.attach.map fun x => i x.1 x.2 := by\n    rw [ht.ext]\n    \u00b7 aesop\n    \u00b7 exact hs.attach.map fun x y hxy \u21a6 Subtype.ext <| i_inj _ x.2 _ y.2 hxy\n  calc\n    s.map f = s.pmap (fun x _ => f x) fun _ => id := by rw [pmap_eq_map]\n    _ = s.attach.map fun x => f x.1 := by rw [pmap_eq_map_attach]\n    _ = t.map g := by rw [this, Multiset.map_map]; exact map_congr rfl fun x _ => h _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/MapFold.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "(f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) [RightCommutative f]", "(f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) [LeftCommutative f]", "[DecidableEq \u03b1] {s t u : Multiset \u03b1}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}", "{\u03b4 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b3 \u2192 \u03b4 \u2192 Prop}", "{s : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\ns : Multiset \u03b1\nt : Multiset \u03b2\nhs : s.Nodup\nht : t.Nodup\ni : (a : \u03b1) \u2192 a \u2208 s \u2192 \u03b2\nhi : \u2200 (a : \u03b1) (ha : a \u2208 s), i a ha \u2208 t\ni_inj : \u2200 (a\u2081 : \u03b1) (ha\u2081 : a\u2081 \u2208 s) (a\u2082 : \u03b1) (ha\u2082 : a\u2082 \u2208 s), i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082\ni_surj : \u2200 b \u2208 t, \u2203 a, \u2203 (ha : a \u2208 s), i a ha = b\nh : \u2200 (a : \u03b1) (ha : a \u2208 s), f a = g (i a ha)\n\u22a2 Multiset.map f s = Multiset.map g t"}, {"line": "have : t = s.attach.map fun x => i x.1 x.2 := by\n    rw [ht.ext]\n    \u00b7 aesop\n    \u00b7 exact hs.attach.map fun x y hxy \u21a6 Subtype.ext <| i_inj _ x.2 _ y.2 hxy", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\ns : Multiset \u03b1\nt : Multiset \u03b2\nhs : s.Nodup\nht : t.Nodup\ni : (a : \u03b1) \u2192 a \u2208 s \u2192 \u03b2\nhi : \u2200 (a : \u03b1) (ha : a \u2208 s), i a ha \u2208 t\ni_inj : \u2200 (a\u2081 : \u03b1) (ha\u2081 : a\u2081 \u2208 s) (a\u2082 : \u03b1) (ha\u2082 : a\u2082 \u2208 s), i a\u2081 ha\u2081 = i a\u2082 ha\u2082 \u2192 a\u2081 = a\u2082\ni_surj : \u2200 b \u2208 t, \u2203 a, \u2203 (ha : a \u2208 s), i a ha = b\nh : \u2200 (a : \u03b1) (ha : a \u2208 s), f a = g (i a ha)\nthis : t = Multiset.map (fun x => i \u2191x \u22ef) s.attach\n\u22a2 Multiset.map f s = Multiset.map g t"}, {"line": "calc\n    s.map f = s.pmap (fun x _ => f x) fun _ => id := by rw [pmap_eq_map]\n    _ = s.attach.map fun x => f x.1 := by rw [pmap_eq_map_attach]\n    _ = t.map g := by rw [this, Multiset.map_map]; exact map_congr rfl fun x _ => h _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cons_eta {m : Multiset \u03b1} {a : \u03b1} (f : \u2200 a' \u2208 a ::\u2098 m, \u03b4 a') :\n    (cons m a (f _ (mem_cons_self _ _)) fun a' ha' => f a' (mem_cons_of_mem ha')) = f := by\n  ext a' h'\n  by_cases h : a' = a\n  \u00b7 subst h\n    rw [Pi.cons_same]\n  \u00b7 rw [Pi.cons_ne _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Pi.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} [DecidableEq \u03b1] {\u03b4 : \u03b1 \u2192 Sort*}", "(m : Multiset \u03b1) (a : \u03b1)", "{m a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b4 : \u03b1 \u2192 Sort u_2\nx\u271d : Sort u_3\ncons : x\u271d\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\n\u22a2 sorry = f"}, {"line": "ext a' h'", "tactic_state": "case h.h\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b4 : \u03b1 \u2192 Sort u_2\nx\u271d : Sort u_3\ncons : x\u271d\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\n\u22a2 sorry a' h' = f a' h'"}, {"line": "by_cases h : a' = a", "tactic_state": "case pos\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b4 : \u03b1 \u2192 Sort u_2\nx\u271d : Sort u_3\ncons : x\u271d\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : a' = a\n\u22a2 sorry a' h' = f a' h'\n---\ncase neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b4 : \u03b1 \u2192 Sort u_2\nx\u271d : Sort u_3\ncons : x\u271d\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : \u00aca' = a\n\u22a2 sorry a' h' = f a' h'"}, {"line": "\u00b7 subst h\n    rw [Pi.cons_same]", "tactic_state": "case neg\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\n\u03b4 : \u03b1 \u2192 Sort u_2\nx\u271d : Sort u_3\ncons : x\u271d\nm : Multiset \u03b1\na : \u03b1\nf : (a' : \u03b1) \u2192 a' \u2208 a ::\u2098 m \u2192 \u03b4 a'\na' : \u03b1\nh' : a' \u2208 a ::\u2098 m\nh : \u00aca' = a\n\u22a2 sorry a' h' = f a' h'"}, {"line": "\u00b7 rw [Pi.cons_ne _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem powersetAux'_cons (a : \u03b1) (l : List \u03b1) :\n    powersetAux' (a :: l) = powersetAux' l ++ List.map (cons a) (powersetAux' l) := by\n  simp [powersetAux']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Powerset.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetAux' : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = sorry ++ map (cons a) sorry"}, {"line": "simp [powersetAux']", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetAux' : x\u271d\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = []"}]}
{"declaration": "theorem powersetCardAux_zero (l : List \u03b1) : powersetCardAux 0 l = [0] := by\n  simp [powersetCardAux_eq_map_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Powerset.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetCardAux : x\u271d\nl : List \u03b1\n\u22a2 sorry = [0]"}, {"line": "simp [powersetCardAux_eq_map_coe]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetCardAux : x\u271d\nl : List \u03b1\n\u22a2 sorry () = [0]"}]}
{"declaration": "theorem powersetCardAux_cons (n : \u2115) (a : \u03b1) (l : List \u03b1) :\n    powersetCardAux (n + 1) (a :: l) =\n      powersetCardAux (n + 1) l ++ List.map (cons a) (powersetCardAux n l) := by\n  simp [powersetCardAux_eq_map_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Powerset.lean", "context": {"open": ["List"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetCardAux : x\u271d\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 sorry = sorry ++ map (cons a) sorry"}, {"line": "simp [powersetCardAux_eq_map_coe]", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\npowersetCardAux : x\u271d\nn : \u2115\na : \u03b1\nl : List \u03b1\n\u22a2 sorry () = []"}]}
{"declaration": "theorem count_replicate (a b : \u03b1) (n : \u2115) : count a (replicate n b) = if b = a then n else 0 := by\n  convert List.count_replicate (a := a)\n  \u00b7 rw [\u2190 coe_count, coe_replicate]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/Replicate.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 List.count a (replicate n b) = if b = a then n else 0"}, {"line": "convert List.count_replicate (a := a)", "tactic_state": "case h.e'_3.h\u2081.a\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 b = a \u2194 (b == a) = true\n---\ncase convert_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 LawfulBEq \u03b1"}, {"line": "\u00b7 rw [\u2190 coe_count, coe_replicate]", "tactic_state": "case convert_2\n\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na b : \u03b1\nn : \u2115\n\u22a2 LawfulBEq \u03b1"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cons_union_distrib (a : \u03b1) (s t : Multiset \u03b1) : a ::\u2098 (s \u222a t) = a ::\u2098 s \u222a a ::\u2098 t := by\n  simpa using add_union_distrib (a ::\u2098 0) s t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a ::\u2098 (s \u222a t) = a ::\u2098 s \u222a a ::\u2098 t"}, {"line": "simpa using add_union_distrib (a ::\u2098 0) s t", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cons_inter_distrib (a : \u03b1) (s t : Multiset \u03b1) : a ::\u2098 s \u2229 t = (a ::\u2098 s) \u2229 (a ::\u2098 t) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a ::\u2098 s \u2229 t = (a ::\u2098 s) \u2229 (a ::\u2098 t)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_iff_ne {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b := by\n  simp [disjoint_left, imp_not_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 _root_.Disjoint s t \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2260 b"}, {"line": "simp [disjoint_left, imp_not_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t : Multiset \u03b1\n\u22a2 _root_.Disjoint s t \u2194 \u2200 a \u2208 s, a \u2209 t"}]}
{"declaration": "theorem singleton_disjoint {l : Multiset \u03b1} {a : \u03b1} : Disjoint {a} l \u2194 a \u2209 l := by\n  simp [disjoint_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\nl : Multiset \u03b1\na : \u03b1\n\u22a2 _root_.Disjoint {a} l \u2194 a \u2209 l"}, {"line": "simp [disjoint_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_add_left {s t u : Multiset \u03b1} :\n    Disjoint (s + t) u \u2194 Disjoint s u \u2227 Disjoint t u := by simp [disjoint_left, or_imp, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DecidableEq \u03b1\ns t u : Multiset \u03b1\n\u22a2 _root_.Disjoint (s + t) u \u2194 _root_.Disjoint s u \u2227 _root_.Disjoint t u"}, {"line": "simp [disjoint_left, or_imp, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_union_right_of_le [DecidableEq \u03b1] {x y z : Multiset \u03b1} (h : z \u2264 y) :\n    x + y = x \u222a z \u2194 y = z \u2227 Disjoint x y := by\n  simpa only [and_comm] using add_eq_union_left_of_le h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 inst\u271d : DecidableEq \u03b1\nx y z : Multiset \u03b1\nh : z \u2264 y\n\u22a2 x + y = x \u222a z \u2194 y = z \u2227 _root_.Disjoint x y"}, {"line": "simpa only [and_comm] using add_eq_union_left_of_le h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_map_map {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} {s : Multiset \u03b1} {t : Multiset \u03b2} :\n    Disjoint (s.map f) (t.map g) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, f a \u2260 g b := by\n  simp [disjoint_iff_ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 _root_.Disjoint (Multiset.map f s) (Multiset.map g t) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, f a \u2260 g b"}, {"line": "simp [disjoint_iff_ne]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type v\n\u03b3 : Type u_2\ninst\u271d : DecidableEq \u03b1\nf : \u03b1 \u2192 \u03b3\ng : \u03b2 \u2192 \u03b3\ns : Multiset \u03b1\nt : Multiset \u03b2\n\u22a2 _root_.Disjoint (Multiset.map f s) (Multiset.map g t) \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, \u00acf a = g b"}]}
{"declaration": "theorem Nodup.add_iff (d\u2081 : Nodup s) (d\u2082 : Nodup t) : Nodup (s + t) \u2194 Disjoint s t := by\n  simp [nodup_add, d\u2081, d\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/UnionInter.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "[DecidableEq \u03b1] {s t u : Multiset \u03b1} {a : \u03b1}", "{s t : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d\u2081 : Nodup ?m.329\nd\u2082 : Nodup ?m.398\n\u22a2 Nodup ?m.792 \u2194 sorry"}, {"line": "simp [nodup_add, d\u2081, d\u2082]", "tactic_state": "d\u2081 : Nodup ?m.329\nd\u2082 : Nodup ?m.398\n\u22a2 Nodup ?m.792 \u2194 sorry ()"}]}
{"declaration": "theorem cons_subset {a : \u03b1} {s t : Multiset \u03b1} : a ::\u2098 s \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t := by\n  simp [subset_iff, or_imp, forall_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/ZeroCons.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "{C : Multiset \u03b1 \u2192 Sort*}", "{C_0 : C 0} {C_cons : \u2200 a m, C m \u2192 C (a ::\u2098 m)}", "{s : Multiset \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : \u03b1\ns t : Multiset \u03b1\n\u22a2 a ::\u2098 s \u2286 t \u2194 a \u2208 t \u2227 s \u2286 t"}, {"line": "simp [subset_iff, or_imp, forall_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rel_eq {s t : Multiset \u03b1} : Rel (\u00b7 = \u00b7) s t \u2194 s = t := by\n  constructor\n  \u00b7 intro h\n    induction h <;> simp [*]\n  \u00b7 intro h\n    subst h\n    exact rel_eq_refl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Multiset/ZeroCons.lean", "context": {"open": ["List Subtype Nat Function"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type v} {\u03b3 : Type*}", "{C : Multiset \u03b1 \u2192 Sort*}", "{C_0 : C 0} {C_cons : \u2200 a m, C m \u2192 C (a ::\u2098 m)}", "{s : Multiset \u03b1} {a : \u03b1}", "{s t : Multiset \u03b1} {a : \u03b1}", "{\u03b4 : Type*} {r : \u03b1 \u2192 \u03b2 \u2192 Prop} {p : \u03b3 \u2192 \u03b4 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 sorry \u2194 s = t"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 sorry \u2192 s = t\n---\ncase mpr\n\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 s = t \u2192 sorry"}, {"line": "\u00b7 intro h\n    induction h <;> simp [*]", "tactic_state": "case mpr\n\u03b1 : Type u_1\ns t : Multiset \u03b1\n\u22a2 s = t \u2192 sorry"}, {"line": "\u00b7 intro h\n    subst h\n    exact rel_eq_refl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ceil_cast (x : \u211a\u22650) : \u2308(x : K)\u2309\u208a = \u2308x\u2309\u208a := by\n  obtain rfl | hx := eq_or_ne x 0\n  \u00b7 simp\n  \u00b7 refine (Nat.ceil_eq_iff ?_).2 (mod_cast (Nat.ceil_eq_iff ?_).1 (Eq.refl \u2308x\u2309\u208a)) <;> simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Floor.lean", "context": {"open": [], "variables": ["{K} [Semifield K] [LinearOrder K] [IsStrictOrderedRing K] [FloorSemiring K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b3 : Semifield K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorSemiring K\nx : \u211a\u22650\n\u22a2 \u2308\u2191x\u2309\u208a = \u2308x\u2309\u208a"}, {"line": "obtain rfl | hx := eq_or_ne x 0", "tactic_state": "case inl\nK : Type u_1\ninst\u271d\u00b3 : Semifield K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorSemiring K\n\u22a2 \u2308\u21910\u2309\u208a = \u23080\u2309\u208a\n---\ncase inr\nK : Type u_1\ninst\u271d\u00b3 : Semifield K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorSemiring K\nx : \u211a\u22650\nhx : x \u2260 0\n\u22a2 \u2308\u2191x\u2309\u208a = \u2308x\u2309\u208a"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nK : Type u_1\ninst\u271d\u00b3 : Semifield K\ninst\u271d\u00b2 : LinearOrder K\ninst\u271d\u00b9 : IsStrictOrderedRing K\ninst\u271d : FloorSemiring K\nx : \u211a\u22650\nhx : x \u2260 0\n\u22a2 \u2308\u2191x\u2309\u208a = \u2308x\u2309\u208a"}, {"line": "\u00b7 refine (Nat.ceil_eq_iff ?_).2 (mod_cast (Nat.ceil_eq_iff ?_).1 (Eq.refl \u2308x\u2309\u208a)) <;> simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_eq_zero : (q : \u211a) = 0 \u2194 q = 0 := by norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)"], "variables": ["{p q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\u22650\n\u22a2 \u2191q = 0 \u2194 q = 0"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_pos : 0 < toNNRat q \u2194 0 < q := by simp [toNNRat, \u2190 coe_lt_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\n\u22a2 0 < q.toNNRat \u2194 0 < q"}, {"line": "simp [toNNRat, \u2190 coe_lt_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_eq_zero : toNNRat q = 0 \u2194 q \u2264 0 := by\n  simpa [-toNNRat_pos] using (@toNNRat_pos q).not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\n\u22a2 q.toNNRat = 0 \u2194 q \u2264 0"}, {"line": "simpa [-toNNRat_pos] using (@toNNRat_pos q).not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_le_toNNRat_iff (hp : 0 \u2264 p) : toNNRat q \u2264 toNNRat p \u2194 q \u2264 p := by\n  simp [\u2190 coe_le_coe, toNNRat, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211a\nhp : 0 \u2264 p\n\u22a2 q.toNNRat \u2264 p.toNNRat \u2194 q \u2264 p"}, {"line": "simp [\u2190 coe_le_coe, toNNRat, hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_lt_toNNRat_iff' : toNNRat q < toNNRat p \u2194 q < p \u2227 0 < p := by\n  simp [\u2190 coe_lt_coe, toNNRat, lt_irrefl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211a\n\u22a2 q.toNNRat < p.toNNRat \u2194 q < p \u2227 0 < p"}, {"line": "simp [\u2190 coe_lt_coe, toNNRat, lt_irrefl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_toNNRat_iff_coe_le {q : \u211a\u22650} (hp : 0 \u2264 p) : q \u2264 toNNRat p \u2194 \u2191q \u2264 p := by\n  rw [\u2190 coe_le_coe]\n  rw [Rat.coe_toNNRat p hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211a\nq : \u211a\u22650\nhp : 0 \u2264 p\n\u22a2 q \u2264 p.toNNRat \u2194 \u2191q \u2264 p"}, {"line": "rw [\u2190 coe_le_coe]", "tactic_state": "p : \u211a\nq : \u211a\u22650\nhp : 0 \u2264 p\n\u22a2 \u2191q \u2264 \u2191p.toNNRat \u2194 \u2191q \u2264 p"}, {"line": "rw [Rat.coe_toNNRat p hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_lt_iff_lt_coe {p : \u211a\u22650} (hq : 0 \u2264 q) : toNNRat q < p \u2194 q < \u2191p := by\n  rw [\u2190 coe_lt_coe]\n  rw [Rat.coe_toNNRat q hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\np : \u211a\u22650\nhq : 0 \u2264 q\n\u22a2 q.toNNRat < p \u2194 q < \u2191p"}, {"line": "rw [\u2190 coe_lt_coe]", "tactic_state": "q : \u211a\np : \u211a\u22650\nhq : 0 \u2264 q\n\u22a2 \u2191q.toNNRat < \u2191p \u2194 q < \u2191p"}, {"line": "rw [Rat.coe_toNNRat q hq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNRat_mul (hp : 0 \u2264 p) : toNNRat (p * q) = toNNRat p * toNNRat q := by\n  rcases le_total 0 q with hq | hq\n  \u00b7 ext; simp [toNNRat, hp, hq, max_eq_left, mul_nonneg]\n  \u00b7 have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq\n    rw [toNNRat_eq_zero.2 hq]\n    rw [toNNRat_eq_zero.2 hpq]\n    rw [mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211a\nhp : 0 \u2264 p\n\u22a2 (p * q).toNNRat = p.toNNRat * q.toNNRat"}, {"line": "rcases le_total 0 q with hq | hq", "tactic_state": "case inl\np q : \u211a\nhp : 0 \u2264 p\nhq : 0 \u2264 q\n\u22a2 (p * q).toNNRat = p.toNNRat * q.toNNRat\n---\ncase inr\np q : \u211a\nhp : 0 \u2264 p\nhq : q \u2264 0\n\u22a2 (p * q).toNNRat = p.toNNRat * q.toNNRat"}, {"line": "\u00b7 ext; simp [toNNRat, hp, hq, max_eq_left, mul_nonneg]", "tactic_state": "case inr\np q : \u211a\nhp : 0 \u2264 p\nhq : q \u2264 0\n\u22a2 (p * q).toNNRat = p.toNNRat * q.toNNRat"}, {"line": "\u00b7 have hpq := mul_nonpos_of_nonneg_of_nonpos hp hq\n    rw [toNNRat_eq_zero.2 hq]\n    rw [toNNRat_eq_zero.2 hpq]\n    rw [mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coprime_num_den (q : \u211a\u22650) : q.num.Coprime q.den := by simpa [num, den] using Rat.reduced _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}", "{p q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\u22650\n\u22a2 q.num.Coprime q.den"}, {"line": "simpa [num, den] using Rat.reduced _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ext_num_den (hn : p.num = q.num) (hd : p.den = q.den) : p = q := by\n  refine ext <| Rat.ext ?_ hd\n  simpa [num_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNRat/Defs.lean", "context": {"open": ["Function", "Rat (toNNRat)", "NNRat"], "variables": ["{p q : \u211a\u22650}", "{p q : \u211a}", "{p q : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211a\u22650\nhn : p.num = q.num\nhd : p.den = q.den\n\u22a2 p = q"}, {"line": "refine ext <| Rat.ext ?_ hd", "tactic_state": "p q : \u211a\u22650\nhn : p.num = q.num\nhd : p.den = q.den\n\u22a2 (\u2191p).num = (\u2191q).num"}, {"line": "simpa [num_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.toNNReal_of_nonneg {r : \u211d} (hr : 0 \u2264 r) : r.toNNReal = \u27e8r, hr\u27e9 := by\n  simp_rw [Real.toNNReal, max_eq_left hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\n\u22a2 r.toNNReal = \u27e8r, hr\u27e9"}, {"line": "simp_rw [Real.toNNReal, max_eq_left hr]", "tactic_state": "No Goals!"}]}
{"declaration": "example : Zero \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : One \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Add \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Sub \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Mul \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : LE \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Bot \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Inhabited \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Nontrivial \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Nontrivial \u211d \u2265 0"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : CommSemiring \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Algebra \u211d\u22650 \u211d := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : DistribMulAction \u211d\u22650\u02e3 \u211d := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : MonoidWithZero \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : CommMonoidWithZero \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : OrderBot \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : PartialOrder \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : AddCommMonoid \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : IsOrderedAddMonoid \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 IsOrderedAddMonoid \u211d \u2265 0"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : DistribLattice \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : SemilatticeInf \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : SemilatticeSup \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : Semiring \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : CommMonoid \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 sorry"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : IsOrderedMonoid \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 IsOrderedMonoid \u211d \u2265 0"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : DenselyOrdered \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 DenselyOrdered \u211d \u2265 0"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : NoMaxOrder \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : sorry\nr\u2081 : sorry\nr\u2082 : sorry\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 NoMaxOrder \u211d \u2265 0"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_pos {r : \u211d} : 0 < Real.toNNReal r \u2194 0 < r := by\n  simp [\u2190 NNReal.coe_lt_coe, lt_irrefl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 0 < r.toNNReal \u2194 0 < r"}, {"line": "simp [\u2190 NNReal.coe_lt_coe, lt_irrefl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_eq_zero {r : \u211d} : Real.toNNReal r = 0 \u2194 r \u2264 0 := by\n  simpa [-toNNReal_pos] using not_iff_not.2 (@toNNReal_pos r)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 r.toNNReal = 0 \u2194 r \u2264 0"}, {"line": "simpa [-toNNReal_pos] using not_iff_not.2 (@toNNReal_pos r)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_le_toNNReal_iff {r p : \u211d} (hp : 0 \u2264 p) :\n    toNNReal r \u2264 toNNReal p \u2194 r \u2264 p := by simp [\u2190 NNReal.coe_le_coe, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ntoNNReal : x\u271d\nr p : \u211d\nhp : 0 \u2264 p\n\u22a2 sorry \u2264 sorry \u2194 r \u2264 p"}, {"line": "simp [\u2190 NNReal.coe_le_coe, hp]", "tactic_state": "x\u271d : Sort u_2\ntoNNReal : x\u271d\nr p : \u211d\nhp : 0 \u2264 p\n\u22a2 sorry () \u2264 sorry () \u2194 r \u2264 p"}]}
{"declaration": "lemma toNNReal_le_one {r : \u211d} : r.toNNReal \u2264 1 \u2194 r \u2264 1 := by\n  simpa using toNNReal_le_toNNReal_iff zero_le_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 r.toNNReal \u2264 1 \u2194 r \u2264 1"}, {"line": "simpa using toNNReal_le_toNNReal_iff zero_le_one", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_lt_toNNReal {r : \u211d} : 1 < r.toNNReal \u2194 1 < r := by\n  simpa only [not_le] using toNNReal_le_one.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 1 < r.toNNReal \u2194 1 < r"}, {"line": "simpa only [not_le] using toNNReal_le_one.not", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toNNReal_le_natCast {r : \u211d} {n : \u2115} : r.toNNReal \u2264 n \u2194 r \u2264 n := by\n  simpa using toNNReal_le_toNNReal_iff n.cast_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nn : \u2115\n\u22a2 r.toNNReal \u2264 \u2191n \u2194 r \u2264 \u2191n"}, {"line": "simpa using toNNReal_le_toNNReal_iff n.cast_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_lt_toNNReal {r : \u211d} {n : \u2115} : n < r.toNNReal \u2194 n < r := by\n  simpa only [not_le] using toNNReal_le_natCast.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nn : \u2115\n\u22a2 \u2191n < r.toNNReal \u2194 \u2191n < r"}, {"line": "simpa only [not_le] using toNNReal_le_natCast.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_eq_toNNReal_iff {r p : \u211d} (hr : 0 \u2264 r) (hp : 0 \u2264 p) :\n    toNNReal r = toNNReal p \u2194 r = p := by simp [\u2190 coe_inj, coe_toNNReal, hr, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ntoNNReal : x\u271d\nr p : \u211d\nhr : 0 \u2264 r\nhp : 0 \u2264 p\n\u22a2 sorry = sorry \u2194 r = p"}, {"line": "simp [\u2190 coe_inj, coe_toNNReal, hr, hp]", "tactic_state": "x\u271d : Sort u_2\ntoNNReal : x\u271d\nr p : \u211d\nhr : 0 \u2264 r\nhp : 0 \u2264 p\n\u22a2 sorry () = sorry () \u2194 r = p"}]}
{"declaration": "lemma one_le_toNNReal {r : \u211d} : 1 \u2264 r.toNNReal \u2194 1 \u2264 r := by\n  simpa using toNNReal_le_toNNReal_iff_of_pos one_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 1 \u2264 r.toNNReal \u2194 1 \u2264 r"}, {"line": "simpa using toNNReal_le_toNNReal_iff_of_pos one_pos", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toNNReal_lt_one {r : \u211d} : r.toNNReal < 1 \u2194 r < 1 := by simp only [\u2190 not_le, one_le_toNNReal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 r.toNNReal < 1 \u2194 r < 1"}, {"line": "simp only [\u2190 not_le, one_le_toNNReal]", "tactic_state": "r : \u211d\n\u22a2 \u00ac1 \u2264 r.toNNReal \u2194 \u00ac1 \u2264 r"}]}
{"declaration": "lemma natCastle_toNNReal' {n : \u2115} {r : \u211d} : \u2191n \u2264 r.toNNReal \u2194 n \u2264 r \u2228 n = 0 := by\n  simpa [n.cast_nonneg.le_iff_eq] using toNNReal_le_toNNReal_iff' (r := n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nr : \u211d\n\u22a2 \u2191n \u2264 r.toNNReal \u2194 \u2191n \u2264 r \u2228 n = 0"}, {"line": "simpa [n.cast_nonneg.le_iff_eq] using toNNReal_le_toNNReal_iff' (r := n)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toNNReal_lt_natCast' {n : \u2115} {r : \u211d} : r.toNNReal < n \u2194 r < n \u2227 n \u2260 0 := by\n  simpa [pos_iff_ne_zero] using toNNReal_lt_toNNReal_iff' (r := r) (p := n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nr : \u211d\n\u22a2 r.toNNReal < \u2191n \u2194 r < \u2191n \u2227 n \u2260 0"}, {"line": "simpa [pos_iff_ne_zero] using toNNReal_lt_toNNReal_iff' (r := r) (p := n)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natCast_le_toNNReal {n : \u2115} {r : \u211d} (hn : n \u2260 0) : \u2191n \u2264 r.toNNReal \u2194 n \u2264 r := by simp [hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nr : \u211d\nhn : n \u2260 0\n\u22a2 \u2191n \u2264 r.toNNReal \u2194 \u2191n \u2264 r"}, {"line": "simp [hn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toNNReal_lt_natCast {r : \u211d} {n : \u2115} (hn : n \u2260 0) : r.toNNReal < n \u2194 r < n := by simp [hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nn : \u2115\nhn : n \u2260 0\n\u22a2 r.toNNReal < \u2191n \u2194 r < \u2191n"}, {"line": "simp [hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_toNNReal_iff_coe_le {r : \u211d\u22650} {p : \u211d} (hp : 0 \u2264 p) : r \u2264 Real.toNNReal p \u2194 \u2191r \u2264 p := by\n  rw [\u2190 NNReal.coe_le_coe]\n  rw [Real.coe_toNNReal p hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : NNReal\np : \u211d\nhp : 0 \u2264 p\n\u22a2 r \u2264 p.toNNReal \u2194 \u2191r \u2264 p"}, {"line": "rw [\u2190 NNReal.coe_le_coe]", "tactic_state": "r : NNReal\np : \u211d\nhp : 0 \u2264 p\n\u22a2 \u2191r \u2264 \u2191p.toNNReal \u2194 \u2191r \u2264 p"}, {"line": "rw [Real.coe_toNNReal p hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_lt_iff_lt_coe {r : \u211d} {p : \u211d\u22650} (ha : 0 \u2264 r) : Real.toNNReal r < p \u2194 r < \u2191p := by\n  rw [\u2190 NNReal.coe_lt_coe]\n  rw [Real.coe_toNNReal r ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\np : NNReal\nha : 0 \u2264 r\n\u22a2 r.toNNReal < p \u2194 r < \u2191p"}, {"line": "rw [\u2190 NNReal.coe_lt_coe]", "tactic_state": "r : \u211d\np : NNReal\nha : 0 \u2264 r\n\u22a2 \u2191r.toNNReal < \u2191p \u2194 r < \u2191p"}, {"line": "rw [Real.coe_toNNReal r ha]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_pow {x : \u211d} (hx : 0 \u2264 x) (n : \u2115) : (x ^ n).toNNReal = x.toNNReal ^ n := by\n  rw [\u2190 coe_inj]\n  rw [NNReal.coe_pow]\n  rw [Real.coe_toNNReal _ (pow_nonneg hx _)]\n  rw [Real.coe_toNNReal x hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\n\u22a2 (x ^ n).toNNReal = x.toNNReal ^ n"}, {"line": "rw [\u2190 coe_inj]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\n\u22a2 \u2191(x ^ n).toNNReal = \u2191(x.toNNReal ^ n)"}, {"line": "rw [NNReal.coe_pow]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\n\u22a2 \u2191(x ^ n).toNNReal = \u2191x.toNNReal ^ n"}, {"line": "rw [Real.coe_toNNReal _ (pow_nonneg hx _)]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\n\u22a2 x ^ n = \u2191x.toNNReal ^ n"}, {"line": "rw [Real.coe_toNNReal x hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toNNReal_zpow {x : \u211d} (hx : 0 \u2264 x) (n : \u2124) : (x ^ n).toNNReal = x.toNNReal ^ n := by\n  rw [\u2190 coe_inj]\n  rw [NNReal.coe_zpow]\n  rw [Real.coe_toNNReal _ (zpow_nonneg hx _)]\n  rw [Real.coe_toNNReal x hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\n\u22a2 (x ^ n).toNNReal = x.toNNReal ^ n"}, {"line": "rw [\u2190 coe_inj]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\n\u22a2 \u2191(x ^ n).toNNReal = \u2191(x.toNNReal ^ n)"}, {"line": "rw [NNReal.coe_zpow]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\n\u22a2 \u2191(x ^ n).toNNReal = \u2191x.toNNReal ^ n"}, {"line": "rw [Real.coe_toNNReal _ (zpow_nonneg hx _)]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\n\u22a2 x ^ n = \u2191x.toNNReal ^ n"}, {"line": "rw [Real.coe_toNNReal x hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_mul_left {a b c : \u211d\u22650} (h : a \u2260 0) : a * b = a * c \u2194 b = c := by\n  rw [mul_eq_mul_left_iff]\n  rw [or_iff_left h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : NNReal\nh : a \u2260 0\n\u22a2 a * b = a * c \u2194 b = c"}, {"line": "rw [mul_eq_mul_left_iff]", "tactic_state": "a b c : NNReal\nh : a \u2260 0\n\u22a2 b = c \u2228 a = 0 \u2194 b = c"}, {"line": "rw [or_iff_left h]", "tactic_state": "No Goals!"}]}
{"declaration": "example : OrderedSub \u211d\u22650 := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r r\u2081 r\u2082 : NNReal\nx y : \u211d\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\n\u22a2 OrderedSub NNReal"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_le {r p : \u211d\u22650} (h : r \u2260 0) : r\u207b\u00b9 \u2264 p \u2194 1 \u2264 r * p := by\n  rw [\u2190 mul_le_mul_left (pos_iff_ne_zero.2 h)]\n  rw [mul_inv_cancel\u2080 h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r p : NNReal\nh : r \u2260 0\n\u22a2 r\u207b\u00b9 \u2264 p \u2194 1 \u2264 r * p"}, {"line": "rw [\u2190 mul_le_mul_left (pos_iff_ne_zero.2 h)]", "tactic_state": "r p : NNReal\nh : r \u2260 0\n\u22a2 r * r\u207b\u00b9 \u2264 r * p \u2194 1 \u2264 r * p"}, {"line": "rw [mul_inv_cancel\u2080 h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_le_of_le_mul {r p : \u211d\u22650} (h : 1 \u2264 r * p) : r\u207b\u00b9 \u2264 p := by\n  by_cases r = 0 <;> simp [*, inv_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r p : NNReal\nh : 1 \u2264 r * p\n\u22a2 r\u207b\u00b9 \u2264 p"}, {"line": "by_cases r = 0 <;> simp [*, inv_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_inv_iff_mul_le {r p : \u211d\u22650} (h : p \u2260 0) : r \u2264 p\u207b\u00b9 \u2194 r * p \u2264 1 := by\n  rw [\u2190 mul_le_mul_left (pos_iff_ne_zero.2 h)]\n  rw [mul_inv_cancel\u2080 h]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 r \u2264 p\u207b\u00b9 \u2194 r * p \u2264 1"}, {"line": "rw [\u2190 mul_le_mul_left (pos_iff_ne_zero.2 h)]", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 p * r \u2264 p * p\u207b\u00b9 \u2194 r * p \u2264 1"}, {"line": "rw [mul_inv_cancel\u2080 h]", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 p * r \u2264 1 \u2194 r * p \u2264 1"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_inv_iff_mul_lt {r p : \u211d\u22650} (h : p \u2260 0) : r < p\u207b\u00b9 \u2194 r * p < 1 := by\n  rw [\u2190 mul_lt_mul_left (pos_iff_ne_zero.2 h)]\n  rw [mul_inv_cancel\u2080 h]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 r < p\u207b\u00b9 \u2194 r * p < 1"}, {"line": "rw [\u2190 mul_lt_mul_left (pos_iff_ne_zero.2 h)]", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 p * r < p * p\u207b\u00b9 \u2194 r * p < 1"}, {"line": "rw [mul_inv_cancel\u2080 h]", "tactic_state": "r p : NNReal\nh : p \u2260 0\n\u22a2 p * r < 1 \u2194 r * p < 1"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_lt_one_of_lt {a b : \u211d\u22650} (h : a < b) : a / b < 1 := by\n  rwa [div_lt_iff\u2080 h.bot_lt, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : NNReal\nh : a < b\n\u22a2 a / b < 1"}, {"line": "rwa [div_lt_iff\u2080 h.bot_lt, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.toNNReal_div {x y : \u211d} (hx : 0 \u2264 x) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y := by\n  rw [div_eq_mul_inv]\n  rw [div_eq_mul_inv]\n  rw [\u2190 Real.toNNReal_inv]\n  rw [\u2190 Real.toNNReal_mul hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x / y).toNNReal = x.toNNReal / y.toNNReal"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x * y\u207b\u00b9).toNNReal = x.toNNReal / y.toNNReal"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x * y\u207b\u00b9).toNNReal = x.toNNReal * y.toNNReal\u207b\u00b9"}, {"line": "rw [\u2190 Real.toNNReal_inv]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x * y\u207b\u00b9).toNNReal = x.toNNReal * y\u207b\u00b9.toNNReal"}, {"line": "rw [\u2190 Real.toNNReal_mul hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.toNNReal_div' {x y : \u211d} (hy : 0 \u2264 y) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y := by\n  rw [div_eq_inv_mul]\n  rw [div_eq_inv_mul]\n  rw [Real.toNNReal_mul (inv_nonneg.2 hy)]\n  rw [Real.toNNReal_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhy : 0 \u2264 y\n\u22a2 (x / y).toNNReal = x.toNNReal / y.toNNReal"}, {"line": "rw [div_eq_inv_mul]", "tactic_state": "x y : \u211d\nhy : 0 \u2264 y\n\u22a2 (y\u207b\u00b9 * x).toNNReal = x.toNNReal / y.toNNReal"}, {"line": "rw [div_eq_inv_mul]", "tactic_state": "x y : \u211d\nhy : 0 \u2264 y\n\u22a2 (y\u207b\u00b9 * x).toNNReal = y.toNNReal\u207b\u00b9 * x.toNNReal"}, {"line": "rw [Real.toNNReal_mul (inv_nonneg.2 hy)]", "tactic_state": "x y : \u211d\nhy : 0 \u2264 y\n\u22a2 y\u207b\u00b9.toNNReal * x.toNNReal = y.toNNReal\u207b\u00b9 * x.toNNReal"}, {"line": "rw [Real.toNNReal_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_lt_one_iff {x : \u211d\u22650} (hx : x \u2260 0) : x\u207b\u00b9 < 1 \u2194 1 < x := by\n  rw [\u2190 one_div]\n  rw [div_lt_iff\u2080 hx.bot_lt]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nhx : x \u2260 0\n\u22a2 x\u207b\u00b9 < 1 \u2194 1 < x"}, {"line": "rw [\u2190 one_div]", "tactic_state": "x : NNReal\nhx : x \u2260 0\n\u22a2 1 / x < 1 \u2194 1 < x"}, {"line": "rw [div_lt_iff\u2080 hx.bot_lt]", "tactic_state": "x : NNReal\nhx : x \u2260 0\n\u22a2 1 < 1 * x \u2194 1 < x"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_const_zero {\u03b1 : Sort*} : \u2a05 _ : \u03b1, (0 : \u211d\u22650) = 0 := by\n  rw [\u2190 coe_inj]\n  rw [coe_iInf]\n  exact Real.iInf_const_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Sort u_3\n\u22a2 \u2a05 x, 0 = 0"}, {"line": "rw [\u2190 coe_inj]", "tactic_state": "\u03b1 : Sort u_3\n\u22a2 \u2191(\u2a05 x, 0) = \u21910"}, {"line": "rw [coe_iInf]", "tactic_state": "\u03b1 : Sort u_3\n\u22a2 \u2a05 i, \u21910 = \u21910"}, {"line": "exact Real.iInf_const_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnabs_of_nonneg {x : \u211d} (h : 0 \u2264 x) : nnabs x = toNNReal x := by\n  ext\n  rw [coe_toNNReal x h]\n  rw [coe_nnabs]\n  rw [abs_of_nonneg h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 nnabs x = x.toNNReal"}, {"line": "ext", "tactic_state": "case a\nx : \u211d\nh : 0 \u2264 x\n\u22a2 \u2191(nnabs x) = \u2191x.toNNReal"}, {"line": "rw [coe_toNNReal x h]", "tactic_state": "case a\nx : \u211d\nh : 0 \u2264 x\n\u22a2 \u2191(nnabs x) = x"}, {"line": "rw [coe_nnabs]", "tactic_state": "case a\nx : \u211d\nh : 0 \u2264 x\n\u22a2 |x| = x"}, {"line": "rw [abs_of_nonneg h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnabs_coe (x : \u211d\u22650) : nnabs x = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\n\u22a2 nnabs \u2191x = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_natAbs_eq_nnabs_cast (n : \u2124) : (n.natAbs : \u211d\u22650) = nnabs n := by\n  ext\n  rw [NNReal.coe_natCast]\n  rw [Int.cast_natAbs]\n  rw [Real.coe_nnabs]\n  rw [Int.cast_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 \u2191n.natAbs = nnabs \u2191n"}, {"line": "ext", "tactic_state": "case a\nn : \u2124\n\u22a2 \u2191\u2191n.natAbs = \u2191(nnabs \u2191n)"}, {"line": "rw [NNReal.coe_natCast]", "tactic_state": "case a\nn : \u2124\n\u22a2 \u2191n.natAbs = \u2191(nnabs \u2191n)"}, {"line": "rw [Int.cast_natAbs]", "tactic_state": "case a\nn : \u2124\n\u22a2 \u2191|n| = \u2191(nnabs \u2191n)"}, {"line": "rw [Real.coe_nnabs]", "tactic_state": "case a\nn : \u2124\n\u22a2 \u2191|n| = |\u2191n|"}, {"line": "rw [Int.cast_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnreal_trichotomy (r : \u211d) : r = 0 \u2228 \u2203 x : \u211d\u22650, 0 < x \u2227 (r = x \u2228 r = -x) := by\n  obtain \u27e8x, hx\u27e9 := nnreal_dichotomy r\n  rw [or_iff_not_imp_left]\n  aesop (add simp pos_iff_ne_zero)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 r = 0 \u2228 \u2203 x, 0 < x \u2227 (r = \u2191x \u2228 r = -\u2191x)"}, {"line": "obtain \u27e8x, hx\u27e9 := nnreal_dichotomy r", "tactic_state": "case intro\nr : \u211d\nx : NNReal\nhx : r = \u2191x \u2228 r = -\u2191x\n\u22a2 r = 0 \u2228 \u2203 x, 0 < x \u2227 (r = \u2191x \u2228 r = -\u2191x)"}, {"line": "rw [or_iff_not_imp_left]", "tactic_state": "case intro\nr : \u211d\nx : NNReal\nhx : r = \u2191x \u2228 r = -\u2191x\n\u22a2 \u00acr = 0 \u2192 \u2203 x, 0 < x \u2227 (r = \u2191x \u2228 r = -\u2191x)"}, {"line": "aesop (add simp pos_iff_ne_zero)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnreal_induction_on {motive : \u211d \u2192 Prop} (nonneg : \u2200 x : \u211d\u22650, motive x)\n    (nonpos : \u2200 x : \u211d\u22650, motive x \u2192 motive (-x)) (r : \u211d) : motive r := by\n  obtain \u27e8r, (rfl | rfl)\u27e9 := r.nnreal_dichotomy\n  all_goals simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "motive : \u211d \u2192 Prop\nnonneg : \u2200 (x : NNReal), motive \u2191x\nnonpos : \u2200 (x : NNReal), motive \u2191x \u2192 motive (-\u2191x)\nr : \u211d\n\u22a2 motive r"}, {"line": "obtain \u27e8r, (rfl | rfl)\u27e9 := r.nnreal_dichotomy", "tactic_state": "case intro.inl\nmotive : \u211d \u2192 Prop\nnonneg : \u2200 (x : NNReal), motive \u2191x\nnonpos : \u2200 (x : NNReal), motive \u2191x \u2192 motive (-\u2191x)\nr : NNReal\n\u22a2 motive \u2191r\n---\ncase intro.inr\nmotive : \u211d \u2192 Prop\nnonneg : \u2200 (x : NNReal), motive \u2191x\nnonpos : \u2200 (x : NNReal), motive \u2191x \u2192 motive (-\u2191x)\nr : NNReal\n\u22a2 motive (-\u2191r)"}, {"line": "all_goals simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnreal_induction_on' {motive : \u211d \u2192 Prop} (zero : motive 0) (pos : \u2200 x : \u211d\u22650, 0 < x \u2192 motive x)\n    (neg : \u2200 x : \u211d\u22650, 0 < x \u2192 motive x \u2192 motive (-x)) (r : \u211d) : motive r := by\n  obtain rfl | \u27e8r, hr, (rfl | rfl)\u27e9 := r.nnreal_trichotomy\n  all_goals simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "motive : \u211d \u2192 Prop\nzero : motive 0\npos : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x\nneg : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x \u2192 motive (-\u2191x)\nr : \u211d\n\u22a2 motive r"}, {"line": "obtain rfl | \u27e8r, hr, (rfl | rfl)\u27e9 := r.nnreal_trichotomy", "tactic_state": "case inl\nmotive : \u211d \u2192 Prop\nzero : motive 0\npos : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x\nneg : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x \u2192 motive (-\u2191x)\n\u22a2 motive 0\n---\ncase inr.intro.intro.inl\nmotive : \u211d \u2192 Prop\nzero : motive 0\npos : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x\nneg : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x \u2192 motive (-\u2191x)\nr : NNReal\nhr : 0 < r\n\u22a2 motive \u2191r\n---\ncase inr.intro.intro.inr\nmotive : \u211d \u2192 Prop\nzero : motive 0\npos : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x\nneg : \u2200 (x : NNReal), 0 < x \u2192 motive \u2191x \u2192 motive (-\u2191x)\nr : NNReal\nhr : 0 < r\n\u22a2 motive (-\u2191r)"}, {"line": "all_goals simp_all", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.exists_lt_of_strictMono [h : Nontrivial \u0393\u2080\u02e3] {f : \u0393\u2080 \u2192*\u2080 \u211d\u22650} (hf : StrictMono f)\n    {r : \u211d} (hr : 0 < r) : \u2203 d : \u0393\u2080\u02e3, (f d : \u211d) < r := by\n  set s : NNReal := \u27e8r, le_of_lt hr\u27e9\n  have hs : 0 < s := hr\n  exact NNReal.exists_lt_of_strictMono hf hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/NNReal/Defs.lean", "context": {"open": ["Function", "NNReal", "Real", "Set", "NNReal"], "variables": ["{r r\u2081 r\u2082 : \u211d\u22650} {x y : \u211d}", "{\u03b9 : Type*} {f : \u03b9 \u2192 \u211d}", "{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650}", "{s : Set \u211d} {t : Set \u211d\u22650}", "{\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u0393\u2080 : Type u_3\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nh : Nontrivial \u0393\u2080\u02e3\nf : \u0393\u2080 \u2192*\u2080 NNReal\nhf : StrictMono \u21d1f\nr : \u211d\nhr : 0 < r\n\u22a2 \u2203 d, \u2191(f \u2191d) < r"}, {"line": "set s : NNReal := \u27e8r, le_of_lt hr\u27e9", "tactic_state": "\u0393\u2080 : Type u_3\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nh : Nontrivial \u0393\u2080\u02e3\nf : \u0393\u2080 \u2192*\u2080 NNReal\nhf : StrictMono \u21d1f\nr : \u211d\nhr : 0 < r\ns : NNReal := \u27e8r, \u22ef\u27e9\n\u22a2 \u2203 d, \u2191(f \u2191d) < r"}, {"line": "have hs : 0 < s := hr", "tactic_state": "\u0393\u2080 : Type u_3\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nh : Nontrivial \u0393\u2080\u02e3\nf : \u0393\u2080 \u2192*\u2080 NNReal\nhf : StrictMono \u21d1f\nr : \u211d\nhr : 0 < r\ns : NNReal := \u27e8r, \u22ef\u27e9\nhs : 0 < s\n\u22a2 \u2203 d, \u2191(f \u2191d) < r"}, {"line": "exact NNReal.exists_lt_of_strictMono hf hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bit_testBit_zero_shiftRight_one (n : Nat) : bit (n.testBit 0) (n >>> 1) = n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/BinaryRec.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\nn : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem bit_eq_zero_iff {n : Nat} {b : Bool} : bit b n = 0 \u2194 n = 0 \u2227 b = false := by\n  cases n <;> cases b <;> simp [bit, Nat.shiftLeft_succ, Nat.two_mul, \u2190 Nat.add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/BinaryRec.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\nn : \u2115\nb : Bool\n\u22a2 sorry = 0 \u2194 n = 0 \u2227 b = false"}, {"line": "cases n <;> cases b <;> simp [bit, Nat.shiftLeft_succ, Nat.two_mul, \u2190 Nat.add_assoc]", "tactic_state": "case zero.false\nx\u271d : Sort u_1\nbit : x\u271d\n\u22a2 sorry () = 0\n---\ncase zero.true\nx\u271d : Sort u_1\nbit : x\u271d\n\u22a2 \u00acsorry () = 0\n---\ncase succ.false\nx\u271d : Sort u_1\nbit : x\u271d\nn\u271d : \u2115\n\u22a2 \u00acsorry () = 0\n---\ncase succ.true\nx\u271d : Sort u_1\nbit : x\u271d\nn\u271d : \u2115\n\u22a2 \u00acsorry () = 0"}]}
{"declaration": "theorem testBit_bit_zero (b n) : (bit b n).testBit 0 = b := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/BinaryRec.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\nb : ?m.450\nn : ?m.451 b\n\u22a2 sorry = b"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\nb : ?m.450\nn : ?m.451 b\n\u22a2 sorry () = b"}]}
{"declaration": "lemma bitwise_zero_left (m : Nat) : bitwise f 0 m = if f false true then m else 0 := by\n  simp [bitwise]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : Bool \u2192 Bool \u2192 Bool\nx\u271d : Sort u_1\nbitwise : x\u271d\nm : \u2115\n\u22a2 sorry = if f false true = true then m else 0"}, {"line": "simp [bitwise]", "tactic_state": "f : Bool \u2192 Bool \u2192 Bool\nx\u271d : Sort u_1\nbitwise : x\u271d\nm : \u2115\n\u22a2 sorry () = if f false true = true then m else 0"}]}
{"declaration": "lemma bit_mod_two_eq_zero_iff (a x) :\n    bit a x % 2 = 0 \u2194 !a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\na : Bool\nx : ?m.1105 a\n\u22a2 sorry % 2 = 0 \u2194 (!a) = true"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\na : Bool\nx : ?m.1105 a\n\u22a2 sorry () % 2 = 0 \u2194 a = false"}]}
{"declaration": "lemma bit_mod_two_eq_one_iff (a x) :\n    bit a x % 2 = 1 \u2194 a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\na : Prop\nx : ?m.1026 a\n\u22a2 sorry % 2 = 1 \u2194 a"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nbit : x\u271d\na : Prop\nx : ?m.1026 a\n\u22a2 sorry () % 2 = 1 \u2194 a"}]}
{"declaration": "theorem bit_ne_zero_iff {n : \u2115} {b : Bool} : n.bit b \u2260 0 \u2194 n = 0 \u2192 b = true := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nb : Bool\n\u22a2 Nat.bit b n \u2260 0 \u2194 n = 0 \u2192 b = true"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem land_assoc (n m k : \u2115) : (n &&& m) &&& k = n &&& (m &&& k) := by bitwise_assoc_tac\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 n &&& m &&& k = n &&& (m &&& k)"}, {"line": "bitwise_assoc_tac", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lor_assoc (n m k : \u2115) : (n ||| m) ||| k = n ||| (m ||| k) := by bitwise_assoc_tac\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bitwise.lean", "context": {"open": ["Function"], "variables": ["{f : Bool \u2192 Bool \u2192 Bool}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 n ||| m ||| k = n ||| (m ||| k)"}, {"line": "bitwise_assoc_tac", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hyperoperation_ge_three_eq_one (n m : \u2115) : hyperoperation (n + 3) m 0 = 1 := by\n  rw [hyperoperation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Hyperoperation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 hyperoperation (n + 3) m 0 = 1"}, {"line": "rw [hyperoperation]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hyperoperation_recursion (n m k : \u2115) :\n    hyperoperation (n + 1) m (k + 1) = hyperoperation n m (hyperoperation (n + 1) m k) := by\n  rw [hyperoperation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Hyperoperation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m k : \u2115\n\u22a2 hyperoperation (n + 1) m (k + 1) = hyperoperation n m (hyperoperation (n + 1) m k)"}, {"line": "rw [hyperoperation]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hyperoperation_two_two_eq_four (n : \u2115) : hyperoperation (n + 1) 2 2 = 4 := by\n  induction' n with nn nih\n  \u00b7 rw [hyperoperation_one]\n  \u00b7 rw [hyperoperation_recursion, hyperoperation_ge_two_eq_self, nih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Hyperoperation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 hyperoperation (n + 1) 2 2 = 4"}, {"line": "induction' n with nn nih", "tactic_state": "case zero\n\u22a2 hyperoperation (0 + 1) 2 2 = 4\n---\ncase succ\nnn : \u2115\nnih : hyperoperation (nn + 1) 2 2 = 4\n\u22a2 hyperoperation (nn + 1 + 1) 2 2 = 4"}, {"line": "\u00b7 rw [hyperoperation_one]", "tactic_state": "case succ\nnn : \u2115\nnih : hyperoperation (nn + 1) 2 2 = 4\n\u22a2 hyperoperation (nn + 1 + 1) 2 2 = 4"}, {"line": "\u00b7 rw [hyperoperation_recursion, hyperoperation_ge_two_eq_self, nih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hyperoperation_ge_three_one (n : \u2115) : \u2200 k : \u2115, hyperoperation (n + 3) 1 k = 1 := by\n  induction' n with nn nih\n  \u00b7 intro k\n    rw [hyperoperation_three]\n    dsimp\n    rw [one_pow]\n  \u00b7 intro k\n    cases k\n    \u00b7 rw [hyperoperation_ge_three_eq_one]\n    \u00b7 rw [hyperoperation_recursion, nih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Hyperoperation.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2200 (k : \u2115), hyperoperation (n + 3) 1 k = 1"}, {"line": "induction' n with nn nih", "tactic_state": "case zero\n\u22a2 \u2200 (k : \u2115), hyperoperation (0 + 3) 1 k = 1\n---\ncase succ\nnn : \u2115\nnih : \u2200 (k : \u2115), hyperoperation (nn + 3) 1 k = 1\n\u22a2 \u2200 (k : \u2115), hyperoperation (nn + 1 + 3) 1 k = 1"}, {"line": "\u00b7 intro k\n    rw [hyperoperation_three]\n    dsimp\n    rw [one_pow]", "tactic_state": "case succ\nnn : \u2115\nnih : \u2200 (k : \u2115), hyperoperation (nn + 3) 1 k = 1\n\u22a2 \u2200 (k : \u2115), hyperoperation (nn + 1 + 3) 1 k = 1"}, {"line": "\u00b7 intro k\n    cases k\n    \u00b7 rw [hyperoperation_ge_three_eq_one]\n    \u00b7 rw [hyperoperation_recursion, nih]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_primeFactors_of_ne_zero (hn : n \u2260 0) : p \u2208 n.primeFactors \u2194 p.Prime \u2227 p \u2223 n := by\n  simp [hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PrimeFin.lean", "context": {"open": ["Finset"], "variables": ["{a b k m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhn : n \u2260 0\n\u22a2 p \u2208 n.primeFactors \u2194 Nat.Prime p \u2227 p \u2223 n"}, {"line": "simp [hn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma primeFactors_pow_succ (n k : \u2115) : (n ^ (k + 1)).primeFactors = n.primeFactors := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  \u00b7 simp\n  induction' k with k ih\n  \u00b7 simp\n  \u00b7 rw [pow_succ', primeFactors_mul hn (pow_ne_zero _ hn), ih, Finset.union_idempotent]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PrimeFin.lean", "context": {"open": ["Finset"], "variables": ["{a b k m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (n ^ (k + 1)).primeFactors = n.primeFactors"}, {"line": "rcases eq_or_ne n 0 with (rfl | hn)", "tactic_state": "case inl\nk : \u2115\n\u22a2 (0 ^ (k + 1)).primeFactors = Nat.primeFactors 0\n---\ncase inr\nn k : \u2115\nhn : n \u2260 0\n\u22a2 (n ^ (k + 1)).primeFactors = n.primeFactors"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nn k : \u2115\nhn : n \u2260 0\n\u22a2 (n ^ (k + 1)).primeFactors = n.primeFactors"}, {"line": "induction' k with k ih", "tactic_state": "case inr.zero\nn : \u2115\nhn : n \u2260 0\n\u22a2 (n ^ (0 + 1)).primeFactors = n.primeFactors\n---\ncase inr.succ\nn : \u2115\nhn : n \u2260 0\nk : \u2115\nih : (n ^ (k + 1)).primeFactors = n.primeFactors\n\u22a2 (n ^ (k + 1 + 1)).primeFactors = n.primeFactors"}, {"line": "\u00b7 simp", "tactic_state": "case inr.succ\nn : \u2115\nhn : n \u2260 0\nk : \u2115\nih : (n ^ (k + 1)).primeFactors = n.primeFactors\n\u22a2 (n ^ (k + 1 + 1)).primeFactors = n.primeFactors"}, {"line": "\u00b7 rw [pow_succ', primeFactors_mul hn (pow_ne_zero _ hn), ih, Finset.union_idempotent]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_union_range_succ : {0} \u222a range succ = univ := by\n  ext n\n  cases n <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Set.lean", "context": {"open": ["Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9\u271d : Sort u_1\nsucc : \u03b9\u271d \u2192 \u2115\n\u22a2 {0} \u222a range succ = univ"}, {"line": "ext n", "tactic_state": "case h\n\u03b9\u271d : Sort u_1\nsucc : \u03b9\u271d \u2192 \u2115\nn : \u2115\n\u22a2 n \u2208 {0} \u222a range succ \u2194 n \u2208 univ"}, {"line": "cases n <;> simp", "tactic_state": "case h.succ\n\u03b9\u271d : Sort u_1\nsucc : \u03b9\u271d \u2192 \u2115\nn\u271d : \u2115\n\u22a2 \u2203 y, succ y = n\u271d + 1"}]}
{"declaration": "theorem size_zero : size 0 = 0 := by simp [size]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Size.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsize : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [size]", "tactic_state": "x\u271d : Sort u_1\nsize : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem size_eq_zero {n : \u2115} : size n = 0 \u2194 n = 0 := by\n  simpa [Nat.pos_iff_ne_zero, not_iff_not] using size_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Size.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsize : x\u271d\nn : \u2115\n\u22a2 sorry = 0 \u2194 n = 0"}, {"line": "simpa [Nat.pos_iff_ne_zero, not_iff_not] using size_pos", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_left_injective (hn : n \u2260 0) : Injective (fun a : \u2115 \u21a6 a ^ n) := by\n  simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_left hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Basic.lean", "context": {"open": ["Function"], "variables": ["{a b c d m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 Injective fun a => a ^ n"}, {"line": "simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_left hn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bodd_add (m n : \u2115) : bodd (m + n) = bxor (bodd m) (bodd n) := by\n  induction n\n  case zero => simp\n  case succ n ih => simp [\u2190 Nat.add_assoc, Bool.xor_not, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bits.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nbodd : x\u271d\u00b9\nx\u271d : Sort u_2\nbxor : x\u271d\nm n : \u2115\n\u22a2 sorry = sorry"}, {"line": "induction n", "tactic_state": "case zero\nx\u271d\u00b9 : Sort u_1\nbodd : x\u271d\u00b9\nx\u271d : Sort u_2\nbxor : x\u271d\nm : \u2115\n\u22a2 sorry = sorry\n---\ncase succ\nx\u271d\u00b9 : Sort u_1\nbodd : x\u271d\u00b9\nx\u271d : Sort u_2\nbxor : x\u271d\nm n\u271d : \u2115\na\u271d : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "case zero => simp", "tactic_state": "case succ\nx\u271d\u00b9 : Sort u_1\nbodd : x\u271d\u00b9\nx\u271d : Sort u_2\nbxor : x\u271d\nm n\u271d : \u2115\na\u271d : sorry = sorry\n\u22a2 sorry = sorry"}, {"line": "case succ n ih => simp [\u2190 Nat.add_assoc, Bool.xor_not, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_bits : bits 0 = [] := by simp [Nat.bits]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Bits.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nbits : x\u271d\n\u22a2 sorry = []"}, {"line": "simp [Nat.bits]", "tactic_state": "x\u271d : Sort u_1\nbits : x\u271d\n\u22a2 sorry () = []"}]}
{"declaration": "theorem chineseRemainderOfFinset_lt_prod {t : Finset \u03b9}\n    (hs : \u2200 i \u2208 t, s i \u2260 0) (pp : Set.Pairwise t (Coprime on s)) :\n    chineseRemainderOfFinset a s t hs pp < \u220f i \u2208 t, s i := by\n  simpa [chineseRemainderOfFinset] using\n    chineseRemainderOfMultiset_lt_prod a s t.nodup (by simpa using hs) (by simpa using pp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ChineseRemainder.lean", "context": {"open": ["scoped Function -- required for scoped `on` notation"], "variables": ["{\u03b9 : Type*}", "(a s : \u03b9 \u2192 \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ns : \u03b9 \u2192 \u2115\nCoprime : \u2115 \u2192 \u2115 \u2192 Prop\nx\u271d : Sort u_2\nchineseRemainderOfFinset : x\u271d\nt : Finset \u03b9\nhs : \u2200 i \u2208 t, s i \u2260 0\npp : (\u2191t).Pairwise (Function.onFun Coprime s)\n\u22a2 sorry < \u220f i \u2208 t, s i"}, {"line": "simpa [chineseRemainderOfFinset] using\n    chineseRemainderOfMultiset_lt_prod a s t.nodup (by simpa using hs) (by simpa using pp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_succ (n : \u2115) : count p (n + 1) = count p n + if p n then 1 else 0 := by\n  split_ifs with h <;> simp [count, List.range_succ, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry = sorry + if p n then 1 else 0"}, {"line": "split_ifs with h <;> simp [count, List.range_succ, h]", "tactic_state": "case pos\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\nh : p n\n\u22a2 False"}]}
{"declaration": "theorem count_one : count p 1 = if p 0 then 1 else 0 := by simp [count_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\n\u22a2 sorry = if p 0 then 1 else 0"}, {"line": "simp [count_succ]", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\n\u22a2 sorry () = if p 0 then 1 else 0"}]}
{"declaration": "theorem count_lt_count_succ_iff {n : \u2115} : count p n < count p (n + 1) \u2194 p n := by\n  by_cases h : p n <;> simp [count_succ, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry < sorry \u2194 p n"}, {"line": "by_cases h : p n <;> simp [count_succ, h]", "tactic_state": "case pos\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\nh : p n\n\u22a2 sorry () < sorry ()\n---\ncase neg\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\nh : \u00acp n\n\u22a2 \u00acsorry () < sorry ()"}]}
{"declaration": "theorem count_succ_eq_succ_count_iff {n : \u2115} : count p (n + 1) = count p n + 1 \u2194 p n := by\n  by_cases h : p n <;> simp [h, count_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry = sorry + 1 \u2194 p n"}, {"line": "by_cases h : p n <;> simp [h, count_succ]", "tactic_state": "case pos\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\nh : p n\n\u22a2 False"}]}
{"declaration": "theorem count_succ_eq_count_iff {n : \u2115} : count p (n + 1) = count p n \u2194 \u00acp n := by\n  by_cases h : p n <;> simp [h, count_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry = sorry \u2194 \u00acp n"}, {"line": "by_cases h : p n <;> simp [h, count_succ]", "tactic_state": "case pos\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\nh : p n\n\u22a2 False"}]}
{"declaration": "theorem count_injective {m n : \u2115} (hm : p m) (hn : p n) (heq : count p m = count p n) : m = n := by\n  by_contra! h : m \u2260 n\n  wlog hmn : m < n\n  \u00b7 exact this hn hm heq.symm h.symm (h.lt_or_lt.resolve_left hmn)\n  \u00b7 simpa [heq] using count_strict_mono hm hmn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nm n : \u2115\nhm : p m\nhn : p n\nheq : sorry = sorry\n\u22a2 m = n"}, {"line": "by_contra! h : m \u2260 n", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nm n : \u2115\nhm : p m\nhn : p n\nheq : sorry = sorry\nh : m \u2260 n\n\u22a2 False"}, {"line": "wlog hmn : m < n", "tactic_state": "case inr\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nm n : \u2115\nhm : p m\nhn : p n\nheq : sorry = sorry\nh : m \u2260 n\nthis :\n  \u2200 {p : \u2115 \u2192 Prop} [inst : DecidablePred p] {x : Sort u_1} {count : x} {m n : \u2115} (hm : p m) (hn : p n),\n    sorry = sorry \u2192 m \u2260 n \u2192 m < n \u2192 False\nhmn : \u00acm < n\n\u22a2 False\n---\np\u271d : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nm n : \u2115\nhm : p m\nhn : p n\nheq : sorry = sorry\nh : m \u2260 n\nhmn : m < n\n\u22a2 False"}, {"line": "\u00b7 exact this hn hm heq.symm h.symm (h.lt_or_lt.resolve_left hmn)", "tactic_state": "p\u271d : \u2115 \u2192 Prop\ninst\u271d\u00b9 : DecidablePred p\u271d\np : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nm n : \u2115\nhm : p m\nhn : p n\nheq : sorry = sorry\nh : m \u2260 n\nhmn : m < n\n\u22a2 False"}, {"line": "\u00b7 simpa [heq] using count_strict_mono hm hmn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_iff_forall {n : \u2115} : count p n = n \u2194 \u2200 n' < n, p n' := by\n  simpa [count_eq_card_filter_range, card_range, mem_range] using\n    card_filter_eq_iff (p := p) (s := range n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry = n \u2194 \u2200 n' < n, p n'"}, {"line": "simpa [count_eq_card_filter_range, card_range, mem_range] using\n    card_filter_eq_iff (p := p) (s := range n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem count_iff_forall_not {n : \u2115} : count p n = 0 \u2194 \u2200 m < n, \u00acp m := by\n  simpa [count_eq_card_filter_range, mem_range] using\n    card_filter_eq_zero_iff (p := p) (s := range n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Count.lean", "context": {"open": ["Finset", "Count"], "variables": ["(p : \u2115 \u2192 Prop)", "[DecidablePred p]", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\ncount : x\u271d\nn : \u2115\n\u22a2 sorry = 0 \u2194 \u2200 m < n, \u00acp m"}, {"line": "simpa [count_eq_card_filter_range, mem_range] using\n    card_filter_eq_zero_iff (p := p) (s := range n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem digitsAux_def (b : \u2115) (h : 2 \u2264 b) (n : \u2115) (w : 0 < n) :\n    digitsAux b h n = (n % b) :: digitsAux b h (n / b) := by\n  cases n\n  \u00b7 cases w\n  \u00b7 rw [digitsAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigitsAux : x\u271d\nb : \u2115\nh : 2 \u2264 b\nn : \u2115\nw : 0 < n\n\u22a2 sorry = n % b :: sorry"}, {"line": "cases n", "tactic_state": "case zero\nx\u271d : Sort u_1\ndigitsAux : x\u271d\nb : \u2115\nh : 2 \u2264 b\nw : 0 < 0\n\u22a2 sorry = 0 % b :: sorry\n---\ncase succ\nx\u271d : Sort u_1\ndigitsAux : x\u271d\nb : \u2115\nh : 2 \u2264 b\nn\u271d : \u2115\nw : 0 < n\u271d + 1\n\u22a2 sorry = (n\u271d + 1) % b :: sorry"}, {"line": "\u00b7 cases w", "tactic_state": "case succ\nx\u271d : Sort u_1\ndigitsAux : x\u271d\nb : \u2115\nh : 2 \u2264 b\nn\u271d : \u2115\nw : 0 < n\u271d + 1\n\u22a2 sorry = (n\u271d + 1) % b :: sorry"}, {"line": "\u00b7 rw [digitsAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem digits_add_two_add_one (b n : \u2115) :\n    digits (b + 2) (n + 1) = ((n + 1) % (b + 2)) :: digits (b + 2) ((n + 1) / (b + 2)) := by\n  simp [digits, digitsAux_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb n : \u2115\n\u22a2 sorry = (n + 1) % (b + 2) :: sorry"}, {"line": "simp [digits, digitsAux_def]", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb n : \u2115\n\u22a2 False"}]}
{"declaration": "lemma digits_of_two_le_of_pos {b : \u2115} (hb : 2 \u2264 b) (hn : 0 < n) :\n    Nat.digits b n = n % b :: Nat.digits b (n / b) := by\n  rw [Nat.eq_add_of_sub_eq hb rfl]\n  rw [Nat.eq_add_of_sub_eq hn rfl]\n  rw [Nat.digits_add_two_add_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n b : \u2115\nhb : 2 \u2264 b\nhn : 0 < n\n\u22a2 b.digits n = n % b :: b.digits (n / b)"}, {"line": "rw [Nat.eq_add_of_sub_eq hb rfl]", "tactic_state": "n b : \u2115\nhb : 2 \u2264 b\nhn : 0 < n\n\u22a2 (b - 2 + 2).digits n = n % (b - 2 + 2) :: (b - 2 + 2).digits (n / (b - 2 + 2))"}, {"line": "rw [Nat.eq_add_of_sub_eq hn rfl]", "tactic_state": "n b : \u2115\nhb : 2 \u2264 b\nhn : 0 < n\n\u22a2 (b - 2 + 2).digits (n - Nat.succ 0 + Nat.succ 0) =\n    (n - Nat.succ 0 + Nat.succ 0) % (b - 2 + 2) :: (b - 2 + 2).digits ((n - Nat.succ 0 + Nat.succ 0) / (b - 2 + 2))"}, {"line": "rw [Nat.digits_add_two_add_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofDigits_singleton {b n : \u2115} : ofDigits b [n] = n := by simp [ofDigits]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb n : \u2115\n\u22a2 sorry = n"}, {"line": "simp [ofDigits]", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb n : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem ofDigits_one_cons {\u03b1 : Type*} [Semiring \u03b1] (h : \u2115) (L : List \u2115) :\n    ofDigits (1 : \u03b1) (h :: L) = h + ofDigits 1 L := by simp [ofDigits]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nh : \u2115\nL : List \u2115\n\u22a2 sorry = h + sorry"}, {"line": "simp [ofDigits]", "tactic_state": "x\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nh : \u2115\nL : List \u2115\n\u22a2 h = 0"}]}
{"declaration": "theorem coe_ofDigits (\u03b1 : Type*) [Semiring \u03b1] (b : \u2115) (L : List \u2115) :\n    ((ofDigits b L : \u2115) : \u03b1) = ofDigits (b : \u03b1) L := by\n  induction' L with d L ih\n  \u00b7 simp [ofDigits]\n  \u00b7 dsimp [ofDigits]; push_cast; rw [ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nb : \u2115\nL : List \u2115\n\u22a2 \u2191sorry = sorry"}, {"line": "induction' L with d L ih", "tactic_state": "case nil\nx\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nb : \u2115\n\u22a2 \u2191sorry = sorry\n---\ncase cons\nx\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nb d : \u2115\nL : List \u2115\nih : \u2191sorry = sorry\n\u22a2 \u2191sorry = sorry"}, {"line": "\u00b7 simp [ofDigits]", "tactic_state": "case cons\nx\u271d : Sort u_2\nofDigits : x\u271d\n\u03b1 : Type u_1\ninst\u271d : Semiring \u03b1\nb d : \u2115\nL : List \u2115\nih : \u2191sorry = sorry\n\u22a2 \u2191sorry = sorry"}, {"line": "\u00b7 dsimp [ofDigits]; push_cast; rw [ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_int_ofDigits (b : \u2115) (L : List \u2115) : ((ofDigits b L : \u2115) : \u2124) = ofDigits (b : \u2124) L := by\n  induction' L with d L _\n  \u00b7 rfl\n  \u00b7 dsimp [ofDigits]; push_cast; simp only\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb : \u2115\nL : List \u2115\n\u22a2 \u2191sorry = sorry"}, {"line": "induction' L with d L _", "tactic_state": "case nil\nx\u271d : Sort u_1\nofDigits : x\u271d\nb : \u2115\n\u22a2 \u2191sorry = sorry\n---\ncase cons\nx\u271d : Sort u_1\nofDigits : x\u271d\nb d : \u2115\nL : List \u2115\ntail_ih\u271d : \u2191sorry = sorry\n\u22a2 \u2191sorry = sorry"}, {"line": "\u00b7 rfl", "tactic_state": "case cons\nx\u271d : Sort u_1\nofDigits : x\u271d\nb d : \u2115\nL : List \u2115\ntail_ih\u271d : \u2191sorry = sorry\n\u22a2 \u2191sorry = sorry"}, {"line": "\u00b7 dsimp [ofDigits]; push_cast; simp only", "tactic_state": "No Goals!"}]}
{"declaration": "theorem digits_eq_cons_digits_div {b n : \u2115} (h : 1 < b) (w : n \u2260 0) :\n    digits b n = (n % b) :: digits b (n / b) := by\n  rcases b with (_ | _ | b)\n  \u00b7 rw [digits_zero_succ' w, Nat.mod_zero, Nat.div_zero, Nat.digits_zero_zero]\n  \u00b7 norm_num at h\n  rcases n with (_ | n)\n  \u00b7 norm_num at w\n  \u00b7 simp only [digits_add_two_add_one, ne_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb n : \u2115\nh : 1 < b\nw : n \u2260 0\n\u22a2 sorry = n % b :: sorry"}, {"line": "rcases b with (_ | _ | b)", "tactic_state": "case zero\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nh : 1 < 0\n\u22a2 sorry = n % 0 :: sorry\n---\ncase succ.zero\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nh : 1 < 0 + 1\n\u22a2 sorry = n % (0 + 1) :: sorry\n---\ncase succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nb : \u2115\nh : 1 < b + 1 + 1\n\u22a2 sorry = n % (b + 1 + 1) :: sorry"}, {"line": "\u00b7 rw [digits_zero_succ' w, Nat.mod_zero, Nat.div_zero, Nat.digits_zero_zero]", "tactic_state": "case succ.zero\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nh : 1 < 0 + 1\n\u22a2 sorry = n % (0 + 1) :: sorry\n---\ncase succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nb : \u2115\nh : 1 < b + 1 + 1\n\u22a2 sorry = n % (b + 1 + 1) :: sorry"}, {"line": "\u00b7 norm_num at h", "tactic_state": "case succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nn : \u2115\nw : n \u2260 0\nb : \u2115\nh : 1 < b + 1 + 1\n\u22a2 sorry = n % (b + 1 + 1) :: sorry"}, {"line": "rcases n with (_ | n)", "tactic_state": "case succ.succ.zero\nx\u271d : Sort u_1\ndigits : x\u271d\nb : \u2115\nh : 1 < b + 1 + 1\nw : 0 \u2260 0\n\u22a2 sorry = 0 % (b + 1 + 1) :: sorry\n---\ncase succ.succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nb : \u2115\nh : 1 < b + 1 + 1\nn : \u2115\nw : n + 1 \u2260 0\n\u22a2 sorry = (n + 1) % (b + 1 + 1) :: sorry"}, {"line": "\u00b7 norm_num at w", "tactic_state": "case succ.succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nb : \u2115\nh : 1 < b + 1 + 1\nn : \u2115\nw : n + 1 \u2260 0\n\u22a2 sorry = (n + 1) % (b + 1 + 1) :: sorry"}, {"line": "\u00b7 simp only [digits_add_two_add_one, ne_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem digits_lt_base {b m d : \u2115} (hb : 1 < b) (hd : d \u2208 digits b m) : d < b := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact digits_lt_base' hd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb m d : \u2115\nhb : 1 < b\nhd : d \u2208 sorry\n\u22a2 d < b"}, {"line": "rcases b with (_ | _ | b) <;> try simp_all", "tactic_state": "case zero\nx\u271d : Sort u_1\ndigits : x\u271d\nm d : \u2115\nhb : 1 < 0\nhd : d \u2208 sorry ()\n\u22a2 False\n---\ncase succ.zero\nx\u271d : Sort u_1\ndigits : x\u271d\nm d : \u2115\nhb : 1 < 0 + 1\nhd : d \u2208 sorry ()\n\u22a2 d = 0\n---\ncase succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nm d b : \u2115\nhb : 1 < b + 1 + 1\nhd : d \u2208 sorry ()\n\u22a2 d < b + 1 + 1"}, {"line": "exact digits_lt_base' hd", "tactic_state": "case succ.zero\nx\u271d : Sort u_1\ndigits : x\u271d\nm d : \u2115\nhb : 1 < 0 + 1\nhd : d \u2208 sorry ()\n\u22a2 d = 0\n---\ncase succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nm d b : \u2115\nhb : 1 < b + 1 + 1\nhd : d \u2208 sorry ()\n\u22a2 d < b + 1 + 1"}]}
{"declaration": "theorem ofDigits_lt_base_pow_length {b : \u2115} {l : List \u2115} (hb : 1 < b) (hl : \u2200 x \u2208 l, x < b) :\n    ofDigits b l < b ^ l.length := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact ofDigits_lt_base_pow_length' hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb : \u2115\nl : List \u2115\nhb : 1 < b\nhl : \u2200 x \u2208 l, x < b\n\u22a2 sorry < b ^ l.length"}, {"line": "rcases b with (_ | _ | b) <;> try simp_all", "tactic_state": "case succ.succ\nx\u271d : Sort u_1\nofDigits : x\u271d\nl : List \u2115\nb : \u2115\nhl : \u2200 x \u2208 l, x < b + 1 + 1\n\u22a2 sorry () < (b + 1 + 1) ^ l.length"}, {"line": "exact ofDigits_lt_base_pow_length' hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_base_pow_length_digits {b m : \u2115} (hb : 1 < b) : m < b ^ (digits b m).length := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact lt_base_pow_length_digits'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb m : \u2115\nhb : 1 < b\n\u22a2 m < b ^ sorry"}, {"line": "rcases b with (_ | _ | b) <;> try simp_all", "tactic_state": "case succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nm b : \u2115\n\u22a2 m < (b + 1 + 1) ^ sorry ()"}, {"line": "exact lt_base_pow_length_digits'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem base_pow_length_digits_le (b m : \u2115) (hb : 1 < b) :\n    m \u2260 0 \u2192 b ^ (digits b m).length \u2264 b * m := by\n  rcases b with (_ | _ | b) <;> try simp_all\n  exact base_pow_length_digits_le' b m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ndigits : x\u271d\nb m : \u2115\nhb : 1 < b\n\u22a2 m \u2260 0 \u2192 b ^ sorry \u2264 b * m"}, {"line": "rcases b with (_ | _ | b) <;> try simp_all", "tactic_state": "case succ.succ\nx\u271d : Sort u_1\ndigits : x\u271d\nm b : \u2115\n\u22a2 \u00acm = 0 \u2192 (b + 1 + 1) ^ sorry () \u2264 (b + 1 + 1) * m"}, {"line": "exact base_pow_length_digits_le' b m", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofDigits_div_eq_ofDigits_tail {p : \u2115} (hpos : 0 < p) (digits : List \u2115)\n    (w\u2081 : \u2200 l \u2208 digits, l < p) : ofDigits p digits / p = ofDigits p digits.tail := by\n  induction' digits with hd tl\n  \u00b7 simp [ofDigits]\n  \u00b7 refine Eq.trans (add_mul_div_left hd _ hpos) ?_\n    rw [Nat.div_eq_of_lt <| w\u2081 _ List.mem_cons_self]\n    rw [zero_add]\n    rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\n\u22a2 sorry / p = sorry"}, {"line": "induction' digits with hd tl", "tactic_state": "case nil\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\nw\u2081 : \u2200 l \u2208 [], l < p\n\u22a2 sorry / p = sorry\n---\ncase cons\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 sorry / p = sorry\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 sorry / p = sorry"}, {"line": "\u00b7 simp [ofDigits]", "tactic_state": "case cons\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\nhd : \u2115\ntl : List \u2115\ntail_ih\u271d : (\u2200 l \u2208 tl, l < p) \u2192 sorry / p = sorry\nw\u2081 : \u2200 l \u2208 hd :: tl, l < p\n\u22a2 sorry / p = sorry"}, {"line": "\u00b7 refine Eq.trans (add_mul_div_left hd _ hpos) ?_\n    rw [Nat.div_eq_of_lt <| w\u2081 _ List.mem_cons_self]\n    rw [zero_add]\n    rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofDigits_div_pow_eq_ofDigits_drop\n    {p : \u2115} (i : \u2115) (hpos : 0 < p) (digits : List \u2115) (w\u2081 : \u2200 l \u2208 digits, l < p) :\n    ofDigits p digits / p ^ i = ofDigits p (digits.drop i) := by\n  induction' i with i hi\n  \u00b7 simp\n  \u00b7 rw [Nat.pow_succ, \u2190 Nat.div_div_eq_div_mul, hi, ofDigits_div_eq_ofDigits_tail hpos\n      (List.drop i digits) fun x hx \u21a6 w\u2081 x <| List.mem_of_mem_drop hx, \u2190 List.drop_one,\n      List.drop_drop, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": [], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\np i : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\n\u22a2 sorry / p ^ i = sorry"}, {"line": "induction' i with i hi", "tactic_state": "case zero\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\n\u22a2 sorry / p ^ 0 = sorry\n---\ncase succ\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\ni : \u2115\nhi : sorry / p ^ i = sorry\n\u22a2 sorry / p ^ (i + 1) = sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nx\u271d : Sort u_1\nofDigits : x\u271d\np : \u2115\nhpos : 0 < p\ndigits : List \u2115\nw\u2081 : \u2200 l \u2208 digits, l < p\ni : \u2115\nhi : sorry / p ^ i = sorry\n\u22a2 sorry / p ^ (i + 1) = sorry"}, {"line": "\u00b7 rw [Nat.pow_succ, \u2190 Nat.div_div_eq_div_mul, hi, ofDigits_div_eq_ofDigits_tail hpos\n      (List.drop i digits) fun x hx \u21a6 w\u2081 x <| List.mem_of_mem_drop hx, \u2190 List.drop_one,\n      List.drop_drop, add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofDigits_mod_eq_head! (b : \u2115) (l : List \u2115) : ofDigits b l % b = l.head! % b := by\n  induction l <;> simp [Nat.ofDigits, Int.ModEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": ["Finset"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb : \u2115\nl : List \u2115\n\u22a2 sorry % b = l.head! % b"}, {"line": "induction l <;> simp [Nat.ofDigits, Int.ModEq]", "tactic_state": "case nil\nx\u271d : Sort u_1\nofDigits : x\u271d\nb : \u2115\n\u22a2 sorry () % b = 0\n---\ncase cons\nx\u271d : Sort u_1\nofDigits : x\u271d\nb head\u271d : \u2115\ntail\u271d : List \u2115\ntail_ih\u271d : sorry % b = tail\u271d.head! % b\n\u22a2 sorry () % b = head\u271d % b"}]}
{"declaration": "theorem dvd_iff_dvd_ofDigits (b b' : \u2115) (c : \u2124) (h : (b : \u2124) \u2223 (b' : \u2124) - c) (n : \u2115) :\n    b \u2223 n \u2194 (b : \u2124) \u2223 ofDigits c (digits b' n) := by\n  rw [\u2190 Int.natCast_dvd_natCast]\n  exact\n    dvd_iff_dvd_of_dvd_sub (zmodeq_ofDigits_digits b b' c (Int.modEq_iff_dvd.2 h).symm _).symm.dvd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": ["Finset"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb b' : \u2115\nc : \u2124\nh : \u2191b \u2223 \u2191b' - c\nn : \u2115\n\u22a2 b \u2223 n \u2194 \u2191b \u2223 sorry"}, {"line": "rw [\u2190 Int.natCast_dvd_natCast]", "tactic_state": "x\u271d : Sort u_1\nofDigits : x\u271d\nb b' : \u2115\nc : \u2124\nh : \u2191b \u2223 \u2191b' - c\nn : \u2115\n\u22a2 \u2191b \u2223 \u2191n \u2194 \u2191b \u2223 sorry"}, {"line": "exact\n    dvd_iff_dvd_of_dvd_sub (zmodeq_ofDigits_digits b b' c (Int.modEq_iff_dvd.2 h).symm _).symm.dvd", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nat_repr_len_aux (n b e : Nat) (h_b_pos : 0 < b) :  n < b ^ e.succ \u2192 n / b < b ^ e := by\n  simp only [Nat.pow_succ]\n  exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": ["Finset"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n b e : \u2115\nh_b_pos : 0 < b\n\u22a2 n < b ^ e.succ \u2192 n / b < b ^ e"}, {"line": "simp only [Nat.pow_succ]", "tactic_state": "n b e : \u2115\nh_b_pos : 0 < b\n\u22a2 n < b ^ e * b \u2192 n / b < b ^ e"}, {"line": "exact (@Nat.div_lt_iff_lt_mul b n (b ^ e) h_b_pos).mpr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem digits_one (b n) (n0 : 0 < n) (nb : n < b) : Nat.digits b n = [n] \u2227 1 < b \u2227 0 < n := by\n  have b2 : 1 < b :=\n    lt_iff_add_one_le.mpr (le_trans (add_le_add_right (lt_iff_add_one_le.mp n0) 1) nb)\n  refine \u27e8?_, b2, n0\u27e9\n  rw [Nat.digits_def' b2 n0]\n  rw [Nat.mod_eq_of_lt nb]\n  rw [Nat.div_eq_zero_iff.2 <| .inr nb]\n  rw [Nat.digits_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Digits.lean", "context": {"open": ["Finset"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\n\u22a2 b.digits n = [n] \u2227 1 < b \u2227 0 < n"}, {"line": "have b2 : 1 < b :=\n    lt_iff_add_one_le.mpr (le_trans (add_le_add_right (lt_iff_add_one_le.mp n0) 1) nb)", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 b.digits n = [n] \u2227 1 < b \u2227 0 < n"}, {"line": "refine \u27e8?_, b2, n0\u27e9", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 b.digits n = [n]"}, {"line": "rw [Nat.digits_def' b2 n0]", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 n % b :: b.digits (n / b) = [n]"}, {"line": "rw [Nat.mod_eq_of_lt nb]", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 n :: b.digits (n / b) = [n]"}, {"line": "rw [Nat.div_eq_zero_iff.2 <| .inr nb]", "tactic_state": "b n : \u2115\nn0 : 0 < n\nnb : n < b\nb2 : 1 < b\n\u22a2 n :: b.digits 0 = [n]"}, {"line": "rw [Nat.digits_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_comm (n m : \u2115) : dist n m = dist m n := by simp [dist, add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Dist.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 dist n m = dist m n"}, {"line": "simp [dist, add_comm]", "tactic_state": "n m : \u2115\n\u22a2 |\u2191n - \u2191m| = |\u2191m - \u2191n|"}]}
{"declaration": "theorem dist_self (n : \u2115) : dist n n = 0 := by simp [dist, tsub_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Dist.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 dist n n = 0"}, {"line": "simp [dist, tsub_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_eq_zero {n m : \u2115} (h : n = m) : dist n m = 0 := by rw [h, dist_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Dist.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : n = m\n\u22a2 dist n m = 0"}, {"line": "rw [h, dist_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_mul_left (k n m : \u2115) : dist (k * n) (k * m) = k * dist n m := by\n  rw [mul_comm k n]\n  rw [mul_comm k m]\n  rw [dist_mul_right]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Dist.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k n m : \u2115\n\u22a2 dist (k * n) (k * m) = \u2191k * dist n m"}, {"line": "rw [mul_comm k n]", "tactic_state": "k n m : \u2115\n\u22a2 dist (n * k) (k * m) = \u2191k * dist n m"}, {"line": "rw [mul_comm k m]", "tactic_state": "k n m : \u2115\n\u22a2 dist (n * k) (m * k) = \u2191k * dist n m"}, {"line": "rw [dist_mul_right]", "tactic_state": "k n m : \u2115\n\u22a2 dist n m = \u2191k * dist n m\n---\nk n m : \u2115\n\u22a2 IsIsometricSMul \u2115\u1d50\u1d52\u1d56 \u2115"}, {"line": "rw [mul_comm]", "tactic_state": "k n m : \u2115\n\u22a2 dist n m = dist n m * \u2191k\n---\nk n m : \u2115\n\u22a2 IsIsometricSMul \u2115\u1d50\u1d52\u1d56 \u2115"}]}
{"declaration": "theorem dist_succ_succ {i j : Nat} : dist (succ i) (succ j) = dist i j := by\n  simp [dist, succ_sub_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Dist.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsucc : x\u271d\ni j : \u2115\n\u22a2 dist sorry sorry = dist i j"}, {"line": "simp [dist, succ_sub_succ]", "tactic_state": "x\u271d : Sort u_1\nsucc : x\u271d\ni j : \u2115\n\u22a2 dist (sorry ()) (sorry ()) = |\u2191i - \u2191j|"}]}
{"declaration": "theorem primeFactorsList_zero : primeFactorsList 0 = [] := by rw [primeFactorsList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 primeFactorsList 0 = []"}, {"line": "rw [primeFactorsList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem primeFactorsList_one : primeFactorsList 1 = [] := by rw [primeFactorsList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 primeFactorsList 1 = []"}, {"line": "rw [primeFactorsList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem primeFactorsList_two : primeFactorsList 2 = [2] := by simp [primeFactorsList]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 primeFactorsList 2 = [2]"}, {"line": "simp [primeFactorsList]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_of_perm_primeFactorsList {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : a.primeFactorsList ~ b.primeFactorsList) : a = b := by\n  simpa [prod_primeFactorsList ha, prod_primeFactorsList hb] using List.Perm.prod_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\nh : a.primeFactorsList.Perm b.primeFactorsList\n\u22a2 a = b"}, {"line": "simpa [prod_primeFactorsList ha, prod_primeFactorsList hb] using List.Perm.prod_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_of_mem_primeFactorsList {n p : \u2115} (h : p \u2208 n.primeFactorsList) : p \u2223 n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  \u00b7 exact dvd_zero p\n  \u00b7 rwa [\u2190 mem_primeFactorsList_iff_dvd hn.ne' (prime_of_mem_primeFactorsList h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in", "List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nh : p \u2208 n.primeFactorsList\n\u22a2 p \u2223 n"}, {"line": "rcases n.eq_zero_or_pos with (rfl | hn)", "tactic_state": "case inl\np : \u2115\nh : p \u2208 primeFactorsList 0\n\u22a2 p \u2223 0\n---\ncase inr\nn p : \u2115\nh : p \u2208 n.primeFactorsList\nhn : n > 0\n\u22a2 p \u2223 n"}, {"line": "\u00b7 exact dvd_zero p", "tactic_state": "case inr\nn p : \u2115\nh : p \u2208 n.primeFactorsList\nhn : n > 0\n\u22a2 p \u2223 n"}, {"line": "\u00b7 rwa [\u2190 mem_primeFactorsList_iff_dvd hn.ne' (prime_of_mem_primeFactorsList h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_primeFactorsList_mul_of_coprime {a b : \u2115} (hab : Coprime a b) (p : \u2115) :\n    p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList := by\n  rcases a.eq_zero_or_pos with (rfl | ha)\n  \u00b7 simp [(coprime_zero_left _).mp hab]\n  rcases b.eq_zero_or_pos with (rfl | hb)\n  \u00b7 simp [(coprime_zero_right _).mp hab]\n  rw [mem_primeFactorsList_mul ha.ne' hb.ne']\n  rw [List.mem_union_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in", "List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhab : a.Coprime b\np : \u2115\n\u22a2 p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "rcases a.eq_zero_or_pos with (rfl | ha)", "tactic_state": "case inl\nb p : \u2115\nhab : Coprime 0 b\n\u22a2 p \u2208 (0 * b).primeFactorsList \u2194 p \u2208 primeFactorsList 0 \u222a b.primeFactorsList\n---\ncase inr\na b : \u2115\nhab : a.Coprime b\np : \u2115\nha : a > 0\n\u22a2 p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "\u00b7 simp [(coprime_zero_left _).mp hab]", "tactic_state": "case inr\na b : \u2115\nhab : a.Coprime b\np : \u2115\nha : a > 0\n\u22a2 p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "rcases b.eq_zero_or_pos with (rfl | hb)", "tactic_state": "case inr.inl\na p : \u2115\nha : a > 0\nhab : a.Coprime 0\n\u22a2 p \u2208 (a * 0).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a primeFactorsList 0\n---\ncase inr.inr\na b : \u2115\nhab : a.Coprime b\np : \u2115\nha : a > 0\nhb : b > 0\n\u22a2 p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "\u00b7 simp [(coprime_zero_right _).mp hab]", "tactic_state": "case inr.inr\na b : \u2115\nhab : a.Coprime b\np : \u2115\nha : a > 0\nhb : b > 0\n\u22a2 p \u2208 (a * b).primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "rw [mem_primeFactorsList_mul ha.ne' hb.ne']", "tactic_state": "case inr.inr\na b : \u2115\nhab : a.Coprime b\np : \u2115\nha : a > 0\nhb : b > 0\n\u22a2 p \u2208 a.primeFactorsList \u2228 p \u2208 b.primeFactorsList \u2194 p \u2208 a.primeFactorsList \u222a b.primeFactorsList"}, {"line": "rw [List.mem_union_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_primeFactorsList_mul_left {p a b : \u2115} (hpa : p \u2208 a.primeFactorsList) (hb : b \u2260 0) :\n    p \u2208 (a * b).primeFactorsList := by\n  rcases eq_or_ne a 0 with (rfl | ha)\n  \u00b7 simp at hpa\n  apply (mem_primeFactorsList_mul ha hb).2 (Or.inl hpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in", "List", "List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u2115\nhpa : p \u2208 a.primeFactorsList\nhb : b \u2260 0\n\u22a2 p \u2208 (a * b).primeFactorsList"}, {"line": "rcases eq_or_ne a 0 with (rfl | ha)", "tactic_state": "case inl\np b : \u2115\nhb : b \u2260 0\nhpa : p \u2208 primeFactorsList 0\n\u22a2 p \u2208 (0 * b).primeFactorsList\n---\ncase inr\np a b : \u2115\nhpa : p \u2208 a.primeFactorsList\nhb : b \u2260 0\nha : a \u2260 0\n\u22a2 p \u2208 (a * b).primeFactorsList"}, {"line": "\u00b7 simp at hpa", "tactic_state": "case inr\np a b : \u2115\nhpa : p \u2208 a.primeFactorsList\nhb : b \u2260 0\nha : a \u2260 0\n\u22a2 p \u2208 (a * b).primeFactorsList"}, {"line": "apply (mem_primeFactorsList_mul ha hb).2 (Or.inl hpa)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_primeFactorsList_mul_right {p a b : \u2115} (hpb : p \u2208 b.primeFactorsList) (ha : a \u2260 0) :\n    p \u2208 (a * b).primeFactorsList := by\n  rw [mul_comm]\n  exact mem_primeFactorsList_mul_left hpb ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in", "List", "List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u2115\nhpb : p \u2208 b.primeFactorsList\nha : a \u2260 0\n\u22a2 p \u2208 (a * b).primeFactorsList"}, {"line": "rw [mul_comm]", "tactic_state": "p a b : \u2115\nhpb : p \u2208 b.primeFactorsList\nha : a \u2260 0\n\u22a2 p \u2208 (b * a).primeFactorsList"}, {"line": "exact mem_primeFactorsList_mul_left hpb ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem four_dvd_or_exists_odd_prime_and_dvd_of_two_lt {n : \u2115} (n2 : 2 < n) :\n    4 \u2223 n \u2228 \u2203 p, Prime p \u2227 p \u2223 n \u2227 Odd p := by\n  obtain \u27e8_ | _ | k, rfl\u27e9 | \u27e8p, hp, hdvd, hodd\u27e9 := n.eq_two_pow_or_exists_odd_prime_and_dvd\n  \u00b7 contradiction\n  \u00b7 contradiction\n  \u00b7 simp [Nat.pow_succ, mul_assoc]\n  \u00b7 exact Or.inr \u27e8p, hp, hdvd, hodd\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factors.lean", "context": {"open": ["Bool Subtype", "Nat", "scoped List in", "List", "List"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nn2 : 2 < n\n\u22a2 4 \u2223 n \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p"}, {"line": "obtain \u27e8_ | _ | k, rfl\u27e9 | \u27e8p, hp, hdvd, hodd\u27e9 := n.eq_two_pow_or_exists_odd_prime_and_dvd", "tactic_state": "case inl.intro.zero\nn2 : 2 < 2 ^ 0\n\u22a2 4 \u2223 2 ^ 0 \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ 0 \u2227 Odd p\n---\ncase inl.intro.succ.zero\nn2 : 2 < 2 ^ (0 + 1)\n\u22a2 4 \u2223 2 ^ (0 + 1) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ (0 + 1) \u2227 Odd p\n---\ncase inl.intro.succ.succ\nk : \u2115\nn2 : 2 < 2 ^ (k + 1 + 1)\n\u22a2 4 \u2223 2 ^ (k + 1 + 1) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ (k + 1 + 1) \u2227 Odd p\n---\ncase inr.intro.intro.intro\nn : \u2115\nn2 : 2 < n\np : \u2115\nhp : Nat.Prime p\nhdvd : p \u2223 n\nhodd : Odd p\n\u22a2 4 \u2223 n \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p"}, {"line": "\u00b7 contradiction", "tactic_state": "case inl.intro.succ.zero\nn2 : 2 < 2 ^ (0 + 1)\n\u22a2 4 \u2223 2 ^ (0 + 1) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ (0 + 1) \u2227 Odd p\n---\ncase inl.intro.succ.succ\nk : \u2115\nn2 : 2 < 2 ^ (k + 1 + 1)\n\u22a2 4 \u2223 2 ^ (k + 1 + 1) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ (k + 1 + 1) \u2227 Odd p\n---\ncase inr.intro.intro.intro\nn : \u2115\nn2 : 2 < n\np : \u2115\nhp : Nat.Prime p\nhdvd : p \u2223 n\nhodd : Odd p\n\u22a2 4 \u2223 n \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p"}, {"line": "\u00b7 contradiction", "tactic_state": "case inl.intro.succ.succ\nk : \u2115\nn2 : 2 < 2 ^ (k + 1 + 1)\n\u22a2 4 \u2223 2 ^ (k + 1 + 1) \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 2 ^ (k + 1 + 1) \u2227 Odd p\n---\ncase inr.intro.intro.intro\nn : \u2115\nn2 : 2 < n\np : \u2115\nhp : Nat.Prime p\nhdvd : p \u2223 n\nhodd : Odd p\n\u22a2 4 \u2223 n \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p"}, {"line": "\u00b7 simp [Nat.pow_succ, mul_assoc]", "tactic_state": "case inr.intro.intro.intro\nn : \u2115\nn2 : 2 < n\np : \u2115\nhp : Nat.Prime p\nhdvd : p \u2223 n\nhodd : Odd p\n\u22a2 4 \u2223 n \u2228 \u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 Odd p"}, {"line": "\u00b7 exact Or.inr \u27e8p, hp, hdvd, hodd\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma findGreatest_of_not (h : \u00ac P (n + 1)) : findGreatest P (n + 1) = findGreatest P n := by\n  simp [Nat.findGreatest, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Find.lean", "context": {"open": [], "variables": ["{m n k : \u2115} {p q : \u2115 \u2192 Prop}", "[DecidablePred p] (H : \u2203 n, p n)", "{P Q : \u2115 \u2192 Prop} [DecidablePred P] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nx\u271d : Sort u_1\nfindGreatest : x\u271d\nh : \u00acP (n + 1)\n\u22a2 sorry = sorry"}, {"line": "simp [Nat.findGreatest, h]", "tactic_state": "P : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nx\u271d : Sort u_1\nfindGreatest : x\u271d\nh : \u00acP (n + 1)\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma findGreatest_spec (hmb : m \u2264 n) (hm : P m) : P (Nat.findGreatest P n) := by\n  by_cases h : Nat.findGreatest P n = 0\n  \u00b7 cases m\n    \u00b7 rwa [h]\n    exact ((findGreatest_eq_zero_iff.1 h) (zero_lt_succ _) hmb hm).elim\n  \u00b7 exact (findGreatest_eq_iff.1 rfl).2.1 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Find.lean", "context": {"open": [], "variables": ["{m n k : \u2115} {p q : \u2115 \u2192 Prop}", "[DecidablePred p] (H : \u2203 n, p n)", "{P Q : \u2115 \u2192 Prop} [DecidablePred P] {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\nP : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nhmb : m \u2264 n\nhm : P m\n\u22a2 P (Nat.findGreatest P n)"}, {"line": "by_cases h : Nat.findGreatest P n = 0", "tactic_state": "case pos\nm : \u2115\nP : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nhmb : m \u2264 n\nhm : P m\nh : Nat.findGreatest P n = 0\n\u22a2 P (Nat.findGreatest P n)\n---\ncase neg\nm : \u2115\nP : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nhmb : m \u2264 n\nhm : P m\nh : \u00acNat.findGreatest P n = 0\n\u22a2 P (Nat.findGreatest P n)"}, {"line": "\u00b7 cases m\n    \u00b7 rwa [h]\n    exact ((findGreatest_eq_zero_iff.1 h) (zero_lt_succ _) hmb hm).elim", "tactic_state": "case neg\nm : \u2115\nP : \u2115 \u2192 Prop\ninst\u271d : DecidablePred P\nn : \u2115\nhmb : m \u2264 n\nhm : P m\nh : \u00acNat.findGreatest P n = 0\n\u22a2 P (Nat.findGreatest P n)"}, {"line": "\u00b7 exact (findGreatest_eq_iff.1 rfl).2.1 h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma succ_succ_ne_one (n : \u2115) : n.succ.succ \u2260 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.succ.succ \u2260 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_succ_iff : m \u2264 n.succ \u2194 m \u2264 n \u2228 m = n.succ := by\n  refine \u27e8fun hmn \u21a6 (Nat.lt_or_eq_of_le hmn).imp_left le_of_lt_succ, ?_\u27e9\n  rintro (hmn | rfl)\n  \u00b7 exact le_succ_of_le hmn\n  \u00b7 exact Nat.le_refl _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m \u2264 n.succ \u2194 m \u2264 n \u2228 m = n.succ"}, {"line": "refine \u27e8fun hmn \u21a6 (Nat.lt_or_eq_of_le hmn).imp_left le_of_lt_succ, ?_\u27e9", "tactic_state": "m n : \u2115\n\u22a2 m \u2264 n \u2228 m = n.succ \u2192 m \u2264 n.succ"}, {"line": "rintro (hmn | rfl)", "tactic_state": "case inl\nm n : \u2115\nhmn : m \u2264 n\n\u22a2 m \u2264 n.succ\n---\ncase inr\nn : \u2115\n\u22a2 n.succ \u2264 n.succ"}, {"line": "\u00b7 exact le_succ_of_le hmn", "tactic_state": "case inr\nn : \u2115\n\u22a2 n.succ \u2264 n.succ"}, {"line": "\u00b7 exact Nat.le_refl _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_one_add_iff : m < 1 + n \u2194 m \u2264 n := by simp only [Nat.add_comm, Nat.lt_succ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m < 1 + n \u2194 m \u2264 n"}, {"line": "simp only [Nat.add_comm, Nat.lt_succ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_add_le_iff : 1 + m \u2264 n \u2194 m < n := by simp only [Nat.add_comm, add_one_le_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 1 + m \u2264 n \u2194 m < n"}, {"line": "simp only [Nat.add_comm, add_one_le_iff]", "tactic_state": "m n : \u2115\n\u22a2 m + 1 \u2264 n \u2194 m < n"}]}
{"declaration": "lemma pred_eq_self_iff : n.pred = n \u2194 n = 0 := by cases n <;> simp [(Nat.succ_ne_self _).symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.pred = n \u2194 n = 0"}, {"line": "cases n <;> simp [(Nat.succ_ne_self _).symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pred_eq_of_eq_succ (H : m = n.succ) : m.pred = n := by simp [H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nH : m = n.succ\n\u22a2 m.pred = n"}, {"line": "simp [H]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma forall_lt_succ : (\u2200 m < n + 1, p m) \u2194 (\u2200 m < n, p m) \u2227 p n := by\n  simp only [Nat.lt_succ_iff]\n  simp only [Nat.le_iff_lt_or_eq]\n  simp only [or_comm]\n  simp only [forall_eq_or_imp]\n  simp only [and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\np : \u2115 \u2192 Prop\n\u22a2 (\u2200 m < n + 1, p m) \u2194 (\u2200 m < n, p m) \u2227 p n"}, {"line": "simp only [Nat.lt_succ_iff]", "tactic_state": "n : \u2115\np : \u2115 \u2192 Prop\n\u22a2 (\u2200 m \u2264 n, p m) \u2194 (\u2200 m < n, p m) \u2227 p n"}, {"line": "simp only [Nat.le_iff_lt_or_eq]", "tactic_state": "n : \u2115\np : \u2115 \u2192 Prop\n\u22a2 (\u2200 (m : \u2115), m < n \u2228 m = n \u2192 p m) \u2194 (\u2200 m < n, p m) \u2227 p n"}, {"line": "simp only [or_comm]", "tactic_state": "n : \u2115\np : \u2115 \u2192 Prop\n\u22a2 (\u2200 (m : \u2115), m = n \u2228 m < n \u2192 p m) \u2194 (\u2200 m < n, p m) \u2227 p n"}, {"line": "simp only [forall_eq_or_imp]", "tactic_state": "n : \u2115\np : \u2115 \u2192 Prop\n\u22a2 (p n \u2227 \u2200 a < n, p a) \u2194 (\u2200 a < n, p a) \u2227 p n"}, {"line": "simp only [and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_of_lt_pred (h : m < n - 1) : m < n := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh : m < n - 1\n\u22a2 m < n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_pred_of_pos (a : \u2115) (hb : b \u2260 0) : a \u2264 b + (a - 1) := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b a : \u2115\nhb : b \u2260 0\n\u22a2 a \u2264 b + (a - 1)"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_max_iff : m + n = max m n \u2194 m = 0 \u2228 n = 0 := by omega", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m + n = max m n \u2194 m = 0 \u2228 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_min_iff : m + n = min m n \u2194 m = 0 \u2227 n = 0 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m + n = min m n \u2194 m = 0 \u2227 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_pos_iff_pos_or_pos : 0 < m + n \u2194 0 < m \u2228 0 < n := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 0 < m + n \u2194 0 < m \u2228 0 < n"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_one_iff : m + n = 1 \u2194 m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m + n = 1 \u2194 m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_two_iff : m + n = 2 \u2194 m = 0 \u2227 n = 2 \u2228 m = 1 \u2227 n = 1 \u2228 m = 2 \u2227 n = 0 := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m + n = 2 \u2194 m = 0 \u2227 n = 2 \u2228 m = 1 \u2227 n = 1 \u2228 m = 2 \u2227 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_eq_three_iff :\n    m + n = 3 \u2194 m = 0 \u2227 n = 3 \u2228 m = 1 \u2227 n = 2 \u2228 m = 2 \u2227 n = 1 \u2228 m = 3 \u2227 n = 0 := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m + n = 3 \u2194 m = 0 \u2227 n = 3 \u2228 m = 1 \u2227 n = 2 \u2228 m = 2 \u2227 n = 1 \u2228 m = 3 \u2227 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_add_one_iff : m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m \u2264 n + 1 \u2194 m \u2264 n \u2228 m = n + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_and_le_add_one_iff : n \u2264 m \u2227 m \u2264 n + 1 \u2194 m = n \u2228 m = n + 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 n \u2264 m \u2227 m \u2264 n + 1 \u2194 m = n \u2228 m = n + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma add_succ_lt_add (hab : a < b) (hcd : c < d) : a + c + 1 < b + d := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nhab : a < b\nhcd : c < d\n\u22a2 a + c + 1 < b + d"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_or_le_of_add_eq_add_pred (h : a + c = b + d - 1) : b \u2264 a \u2228 d \u2264 c := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nh : a + c = b + d - 1\n\u22a2 b \u2264 a \u2228 d \u2264 c"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_eq_right (hb : b \u2260 0) : a * b = b \u2194 a = 1 := by simpa using Nat.mul_left_inj hb (c := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhb : b \u2260 0\n\u22a2 a * b = b \u2194 a = 1"}, {"line": "simpa using Nat.mul_left_inj hb (c := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_zero_of_double_le (h : 2 * n \u2264 n) : n = 0 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 2 * n \u2264 n\n\u22a2 n = 0"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_div_two_iff_mul_two_le {n m : \u2115} : m \u2264 n / 2 \u2194 (m : \u2124) * 2 \u2264 n := by\n  rw [Nat.le_div_iff_mul_le Nat.zero_lt_two]\n  rw [\u2190 Int.ofNat_le]\n  rw [Int.ofNat_mul]\n  rw [Int.ofNat_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 m \u2264 n / 2 \u2194 \u2191m * 2 \u2264 \u2191n"}, {"line": "rw [Nat.le_div_iff_mul_le Nat.zero_lt_two]", "tactic_state": "n m : \u2115\n\u22a2 m * 2 \u2264 n \u2194 \u2191m * 2 \u2264 \u2191n"}, {"line": "rw [\u2190 Int.ofNat_le]", "tactic_state": "n m : \u2115\n\u22a2 \u2191(m * 2) \u2264 \u2191n \u2194 \u2191m * 2 \u2264 \u2191n"}, {"line": "rw [Int.ofNat_mul]", "tactic_state": "n m : \u2115\n\u22a2 \u2191m * \u21912 \u2264 \u2191n \u2194 \u2191m * 2 \u2264 \u2191n"}, {"line": "rw [Int.ofNat_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_mul_div_comm : b \u2223 a \u2192 d \u2223 c \u2192 (a / b) * (c / d) = (a * c) / (b * d) := by\n  rintro \u27e8x, rfl\u27e9 \u27e8y, rfl\u27e9\n  obtain rfl | hb := b.eq_zero_or_pos\n  \u00b7 simp\n  obtain rfl | hd := d.eq_zero_or_pos\n  \u00b7 simp\n  rw [Nat.mul_div_cancel_left _ hb]\n  rw [Nat.mul_div_cancel_left _ hd]\n  rw [Nat.mul_assoc b]\n  rw [Nat.mul_left_comm x]\n  rw [\u2190 Nat.mul_assoc b]\n  rw [Nat.mul_div_cancel_left _ (Nat.mul_pos hb hd)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\n\u22a2 b \u2223 a \u2192 d \u2223 c \u2192 a / b * (c / d) = a * c / (b * d)"}, {"line": "rintro \u27e8x, rfl\u27e9 \u27e8y, rfl\u27e9", "tactic_state": "case intro.intro\nb d x y : \u2115\n\u22a2 b * x / b * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "obtain rfl | hb := b.eq_zero_or_pos", "tactic_state": "case intro.intro.inl\nd x y : \u2115\n\u22a2 0 * x / 0 * (d * y / d) = 0 * x * (d * y) / (0 * d)\n---\ncase intro.intro.inr\nb d x y : \u2115\nhb : b > 0\n\u22a2 b * x / b * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "\u00b7 simp", "tactic_state": "case intro.intro.inr\nb d x y : \u2115\nhb : b > 0\n\u22a2 b * x / b * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "obtain rfl | hd := d.eq_zero_or_pos", "tactic_state": "case intro.intro.inr.inl\nb x y : \u2115\nhb : b > 0\n\u22a2 b * x / b * (0 * y / 0) = b * x * (0 * y) / (b * 0)\n---\ncase intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 b * x / b * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "\u00b7 simp", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 b * x / b * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "rw [Nat.mul_div_cancel_left _ hb]", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 x * (d * y / d) = b * x * (d * y) / (b * d)"}, {"line": "rw [Nat.mul_div_cancel_left _ hd]", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 x * y = b * x * (d * y) / (b * d)"}, {"line": "rw [Nat.mul_assoc b]", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 x * y = b * (x * (d * y)) / (b * d)"}, {"line": "rw [Nat.mul_left_comm x]", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 x * y = b * (d * (x * y)) / (b * d)"}, {"line": "rw [\u2190 Nat.mul_assoc b]", "tactic_state": "case intro.intro.inr.inr\nb d x y : \u2115\nhb : b > 0\nhd : d > 0\n\u22a2 x * y = b * d * (x * y) / (b * d)"}, {"line": "rw [Nat.mul_div_cancel_left _ (Nat.mul_pos hb hd)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_mul_div_le_div (a b c : \u2115) : a / c * b / a \u2264 b / c := by\n  obtain rfl | ha := Nat.eq_zero_or_pos a\n  \u00b7 simp\n  \u00b7 calc\n      a / c * b / a \u2264 b * a / c / a :=\n        Nat.div_le_div_right (by rw [Nat.mul_comm]; exact mul_div_le_mul_div_assoc _ _ _)\n      _ = b / c := by rw [Nat.div_div_eq_div_mul, Nat.mul_comm b, Nat.mul_comm c,\n          Nat.mul_div_mul_left _ _ ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a / c * b / a \u2264 b / c"}, {"line": "obtain rfl | ha := Nat.eq_zero_or_pos a", "tactic_state": "case inl\nb c : \u2115\n\u22a2 0 / c * b / 0 \u2264 b / c\n---\ncase inr\na b c : \u2115\nha : a > 0\n\u22a2 a / c * b / a \u2264 b / c"}, {"line": "\u00b7 simp", "tactic_state": "case inr\na b c : \u2115\nha : a > 0\n\u22a2 a / c * b / a \u2264 b / c"}, {"line": "\u00b7 calc\n      a / c * b / a \u2264 b * a / c / a :=\n        Nat.div_le_div_right (by rw [Nat.mul_comm]; exact mul_div_le_mul_div_assoc _ _ _)\n      _ = b / c := by rw [Nat.div_div_eq_div_mul, Nat.mul_comm b, Nat.mul_comm c,\n          Nat.mul_div_mul_left _ _ ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_half_of_half_lt_sub (h : a / 2 < a - b) : b \u2264 a / 2 := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a / 2 < a - b\n\u22a2 b \u2264 a / 2"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma half_le_of_sub_le_half (h : a - b \u2264 a / 2) : a / 2 \u2264 b := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nh : a - b \u2264 a / 2\n\u22a2 a / 2 \u2264 b"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_mul_odd_div_two (hn : n % 2 = 1) : 2 * (n / 2) = n - 1 := by\n  conv => rhs; rw [\u2190 Nat.mod_add_div n 2, hn, Nat.add_sub_cancel_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n % 2 = 1\n\u22a2 2 * (n / 2) = n - 1"}, {"line": "conv => rhs; rw [\u2190 Nat.mod_add_div n 2, hn, Nat.add_sub_cancel_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_div_iff_mul_lt_of_dvd (hc : c \u2260 0) (hcb : c \u2223 b) : a < b / c \u2194 a * c < b := by\n  simp [\u2190 Nat.div_lt_div_right _ _ hcb, hc, Nat.pos_iff_ne_zero, Nat.dvd_mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nhc : c \u2260 0\nhcb : c \u2223 b\n\u22a2 a < b / c \u2194 a * c < b"}, {"line": "simp [\u2190 Nat.div_lt_div_right _ _ hcb, hc, Nat.pos_iff_ne_zero, Nat.dvd_mul_left]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_pow (n m : \u2115) (h : 0 < m) : 1 \u2264 m ^ n := by simpa using Nat.pow_le_pow_left h n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh : 0 < m\n\u22a2 1 \u2264 m ^ n"}, {"line": "simpa using Nat.pow_le_pow_left h n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_lt_pow (hn : n \u2260 0) (ha : 1 < a) : 1 < a ^ n := by simpa using Nat.pow_lt_pow_left ha hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\nhn : n \u2260 0\nha : 1 < a\n\u22a2 1 < a ^ n"}, {"line": "simpa using Nat.pow_lt_pow_left ha hn", "tactic_state": "No Goals!"}]}
{"declaration": "lemma two_pow_succ (n : \u2115) : 2 ^ (n + 1) = 2 ^ n + 2 ^ n := by simp [Nat.pow_succ, Nat.mul_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 2 ^ (n + 1) = 2 ^ n + 2 ^ n"}, {"line": "simp [Nat.pow_succ, Nat.mul_two]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_lt_mul_pow_succ (ha : 0 < a) (hb : 1 < b) : n * b < a * b ^ (n + 1) := by\n  rw [Nat.pow_succ]\n  rw [\u2190 Nat.mul_assoc]\n  rw [Nat.mul_lt_mul_right (Nat.lt_trans Nat.zero_lt_one hb)]\n  exact Nat.lt_of_le_of_lt (Nat.le_mul_of_pos_left _ ha)\n    ((Nat.mul_lt_mul_left ha).2 <| Nat.lt_pow_self hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b n : \u2115\nha : 0 < a\nhb : 1 < b\n\u22a2 n * b < a * b ^ (n + 1)"}, {"line": "rw [Nat.pow_succ]", "tactic_state": "a b n : \u2115\nha : 0 < a\nhb : 1 < b\n\u22a2 n * b < a * (b ^ n * b)"}, {"line": "rw [\u2190 Nat.mul_assoc]", "tactic_state": "a b n : \u2115\nha : 0 < a\nhb : 1 < b\n\u22a2 n * b < a * b ^ n * b"}, {"line": "rw [Nat.mul_lt_mul_right (Nat.lt_trans Nat.zero_lt_one hb)]", "tactic_state": "a b n : \u2115\nha : 0 < a\nhb : 1 < b\n\u22a2 n < a * b ^ n"}, {"line": "exact Nat.lt_of_le_of_lt (Nat.le_mul_of_pos_left _ ha)\n    ((Nat.mul_lt_mul_left ha).2 <| Nat.lt_pow_self hb)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sq_sub_sq (a b : \u2115) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by\n  simpa [Nat.pow_succ] using Nat.mul_self_sub_mul_self_eq a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 a ^ 2 - b ^ 2 = (a + b) * (a - b)"}, {"line": "simpa [Nat.pow_succ] using Nat.mul_self_sub_mul_self_eq a b", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_self_pos : 0 < n ^ n := by simp [Nat.pow_pos_iff, n.eq_zero_or_pos.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 0 < n ^ n"}, {"line": "simp [Nat.pow_pos_iff, n.eq_zero_or_pos.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma leRec_self {n} {motive : (m : \u2115) \u2192 n \u2264 m \u2192 Sort*}\n    (refl : motive n (Nat.le_refl _))\n    (le_succ_of_le : \u2200 \u2983k\u2984 (h : n \u2264 k), motive k h \u2192 motive (k + 1) (le_succ_of_le h)) :\n    (leRec (motive := motive) refl le_succ_of_le (Nat.le_refl _) :\n    motive n (Nat.le_refl _)) = refl := by\n  cases n <;> simp [leRec, Or.by_cases, dif_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_2\nle_succ_of_le\u271d : x\u271d\u00b9\nx\u271d : Sort u_3\nleRec : x\u271d\nn : \u2115\nmotive : (m : \u2115) \u2192 n \u2264 m \u2192 Sort u_1\nrefl : motive n \u22ef\nle_succ_of_le : \u2983k : \u2115\u2984 \u2192 (h : n \u2264 k) \u2192 motive k h \u2192 motive (k + 1) \u22ef\n\u22a2 sorry = refl"}, {"line": "cases n <;> simp [leRec, Or.by_cases, dif_neg]", "tactic_state": "case zero\nx\u271d\u00b9 : Sort u_2\nle_succ_of_le\u271d : x\u271d\u00b9\nx\u271d : Sort u_3\nleRec : x\u271d\nmotive : (m : \u2115) \u2192 0 \u2264 m \u2192 Sort u_1\nrefl : motive 0 \u22ef\nle_succ_of_le : \u2983k : \u2115\u2984 \u2192 (h : 0 \u2264 k) \u2192 motive k h \u2192 motive (k + 1) \u22ef\n\u22a2 sorry () = refl\n---\ncase succ\nx\u271d\u00b9 : Sort u_2\nle_succ_of_le\u271d : x\u271d\u00b9\nx\u271d : Sort u_3\nleRec : x\u271d\nn\u271d : \u2115\nmotive : (m : \u2115) \u2192 n\u271d + 1 \u2264 m \u2192 Sort u_1\nrefl : motive (n\u271d + 1) \u22ef\nle_succ_of_le : \u2983k : \u2115\u2984 \u2192 (h : n\u271d + 1 \u2264 k) \u2192 motive k h \u2192 motive (k + 1) \u22ef\n\u22a2 sorry () = refl"}]}
{"declaration": "lemma mul_div_lt_iff_not_dvd : d * (n / d) < n \u2194 \u00ac d \u2223 n := by\n  simp [Nat.lt_iff_le_and_ne, mul_div_eq_iff_dvd, mul_div_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "d n : \u2115\n\u22a2 d * (n / d) < n \u2194 \u00acd \u2223 n"}, {"line": "simp [Nat.lt_iff_le_and_ne, mul_div_eq_iff_dvd, mul_div_le]", "tactic_state": "d n : \u2115\n\u22a2 d * (n / d) \u2264 n \u2227 \u00acd * (n / d) = n \u2194 \u00acd \u2223 n"}]}
{"declaration": "lemma div_ne_zero_iff_of_dvd (hba : b \u2223 a) : a / b \u2260 0 \u2194 a \u2260 0 \u2227 b \u2260 0 := by\n  obtain rfl | hb := Decidable.em (b = 0) <;>\n    simp [Nat.div_ne_zero_iff, Nat.le_iff_ne_zero_of_dvd, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhba : b \u2223 a\n\u22a2 a / b \u2260 0 \u2194 a \u2260 0 \u2227 b \u2260 0"}, {"line": "obtain rfl | hb := Decidable.em (b = 0) <;>\n    simp [Nat.div_ne_zero_iff, Nat.le_iff_ne_zero_of_dvd, *]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_dvd_of_pos_of_lt (h1 : 0 < n) (h2 : n < m) : \u00acm \u2223 n := by\n  rintro \u27e8k, rfl\u27e9\n  rcases Nat.eq_zero_or_pos k with (rfl | hk)\n  \u00b7 exact Nat.lt_irrefl 0 h1\n  \u00b7 exact Nat.not_lt.2 (Nat.le_mul_of_pos_right _ hk) h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nh1 : 0 < n\nh2 : n < m\n\u22a2 \u00acm \u2223 n"}, {"line": "rintro \u27e8k, rfl\u27e9", "tactic_state": "case intro\nm k : \u2115\nh1 : 0 < m * k\nh2 : m * k < m\n\u22a2 False"}, {"line": "rcases Nat.eq_zero_or_pos k with (rfl | hk)", "tactic_state": "case intro.inl\nm : \u2115\nh1 : 0 < m * 0\nh2 : m * 0 < m\n\u22a2 False\n---\ncase intro.inr\nm k : \u2115\nh1 : 0 < m * k\nh2 : m * k < m\nhk : k > 0\n\u22a2 False"}, {"line": "\u00b7 exact Nat.lt_irrefl 0 h1", "tactic_state": "case intro.inr\nm k : \u2115\nh1 : 0 < m * k\nh2 : m * k < m\nhk : k > 0\n\u22a2 False"}, {"line": "\u00b7 exact Nat.not_lt.2 (Nat.le_mul_of_pos_right _ hk) h2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_mod_eq_zero_of_mod_eq (h : m % k = n % k) : (m - n) % k = 0 := by\n  rw [\u2190 Nat.mod_add_div m k]\n  rw [\u2190 Nat.mod_add_div n k]\n  rw [\u2190 h]\n  rw [\u2190 Nat.sub_sub]\n  rw [Nat.add_sub_cancel_left]\n  rw [\u2190 k.mul_sub]\n  rw [Nat.mul_mod_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (m - n) % k = 0"}, {"line": "rw [\u2190 Nat.mod_add_div m k]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (m % k + k * (m / k) - n) % k = 0"}, {"line": "rw [\u2190 Nat.mod_add_div n k]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (m % k + k * (m / k) - (n % k + k * (n / k))) % k = 0"}, {"line": "rw [\u2190 h]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (m % k + k * (m / k) - (m % k + k * (n / k))) % k = 0"}, {"line": "rw [\u2190 Nat.sub_sub]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (m % k + k * (m / k) - m % k - k * (n / k)) % k = 0"}, {"line": "rw [Nat.add_sub_cancel_left]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 (k * (m / k) - k * (n / k)) % k = 0"}, {"line": "rw [\u2190 k.mul_sub]", "tactic_state": "m n k : \u2115\nh : m % k = n % k\n\u22a2 k * (m / k - n / k) % k = 0"}, {"line": "rw [Nat.mul_mod_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_dvd_of_between_consec_multiples (h1 : n * k < m) (h2 : m < n * (k + 1)) : \u00acn \u2223 m := by\n  rintro \u27e8d, rfl\u27e9\n  have := Nat.lt_of_mul_lt_mul_left h1\n  have := Nat.lt_of_mul_lt_mul_left h2\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\nh1 : n * k < m\nh2 : m < n * (k + 1)\n\u22a2 \u00acn \u2223 m"}, {"line": "rintro \u27e8d, rfl\u27e9", "tactic_state": "case intro\nn k d : \u2115\nh1 : n * k < n * d\nh2 : n * d < n * (k + 1)\n\u22a2 False"}, {"line": "have := Nat.lt_of_mul_lt_mul_left h1", "tactic_state": "case intro\nn k d : \u2115\nh1 : n * k < n * d\nh2 : n * d < n * (k + 1)\nthis : k < d\n\u22a2 False"}, {"line": "have := Nat.lt_of_mul_lt_mul_left h2", "tactic_state": "case intro\nn k d : \u2115\nh1 : n * k < n * d\nh2 : n * d < n * (k + 1)\nthis\u271d : k < d\nthis : d < k + 1\n\u22a2 False"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_dvd_of_div_eq_one (hab : a \u2223 b) (h : b / a = 1) : a = b := by\n  rw [\u2190 Nat.div_mul_cancel hab]\n  rw [h]\n  rw [Nat.one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 1\n\u22a2 a = b"}, {"line": "rw [\u2190 Nat.div_mul_cancel hab]", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 1\n\u22a2 a = b / a * a"}, {"line": "rw [h]", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 1\n\u22a2 a = 1 * a"}, {"line": "rw [Nat.one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_zero_of_dvd_of_div_eq_zero (hab : a \u2223 b) (h : b / a = 0) : b = 0 := by\n  rw [\u2190 Nat.div_mul_cancel hab]\n  rw [h]\n  rw [Nat.zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 0\n\u22a2 b = 0"}, {"line": "rw [\u2190 Nat.div_mul_cancel hab]", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 0\n\u22a2 b / a * a = 0"}, {"line": "rw [h]", "tactic_state": "a b : \u2115\nhab : a \u2223 b\nh : b / a = 0\n\u22a2 0 * a = 0"}, {"line": "rw [Nat.zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_mul_div_succ (a : \u2115) (hb : 0 < b) : a < b * (a / b + 1) := by\n  rw [Nat.mul_comm]\n  rw [\u2190 Nat.div_lt_iff_lt_mul hb]\n  exact lt_succ_self _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b a : \u2115\nhb : 0 < b\n\u22a2 a < b * (a / b + 1)"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "b a : \u2115\nhb : 0 < b\n\u22a2 a < (a / b + 1) * b"}, {"line": "rw [\u2190 Nat.div_lt_iff_lt_mul hb]", "tactic_state": "b a : \u2115\nhb : 0 < b\n\u22a2 a / b < a / b + 1"}, {"line": "exact lt_succ_self _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_add_mod' (a b c : \u2115) : (a * b + c) % b = c % b := by rw [Nat.mul_comm, Nat.mul_add_mod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 (a * b + c) % b = c % b"}, {"line": "rw [Nat.mul_comm, Nat.mul_add_mod]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_add_mod_of_lt (h : c < b) : (a * b + c) % b = c := by\n  rw [Nat.mul_add_mod']\n  rw [Nat.mod_eq_of_lt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : c < b\n\u22a2 (a * b + c) % b = c"}, {"line": "rw [Nat.mul_add_mod']", "tactic_state": "a b c : \u2115\nh : c < b\n\u22a2 c % b = c"}, {"line": "rw [Nat.mod_eq_of_lt h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dvd_mul_of_div_dvd (h : b \u2223 a) (hdiv : a / b \u2223 c) : a \u2223 b * c := by\n  obtain \u27e8e, rfl\u27e9 := hdiv\n  rw [\u2190 Nat.mul_assoc]\n  rw [Nat.mul_comm _ (a / b)]\n  rw [Nat.div_mul_cancel h]\n  exact Nat.dvd_mul_right a e\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh : b \u2223 a\nhdiv : a / b \u2223 c\n\u22a2 a \u2223 b * c"}, {"line": "obtain \u27e8e, rfl\u27e9 := hdiv", "tactic_state": "case intro\na b : \u2115\nh : b \u2223 a\ne : \u2115\n\u22a2 a \u2223 b * (a / b * e)"}, {"line": "rw [\u2190 Nat.mul_assoc]", "tactic_state": "case intro\na b : \u2115\nh : b \u2223 a\ne : \u2115\n\u22a2 a \u2223 b * (a / b) * e"}, {"line": "rw [Nat.mul_comm _ (a / b)]", "tactic_state": "case intro\na b : \u2115\nh : b \u2223 a\ne : \u2115\n\u22a2 a \u2223 a / b * b * e"}, {"line": "rw [Nat.div_mul_cancel h]", "tactic_state": "case intro\na b : \u2115\nh : b \u2223 a\ne : \u2115\n\u22a2 a \u2223 a * e"}, {"line": "exact Nat.dvd_mul_right a e", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_dvd_iff_lt_mul_succ (n : \u2115) {a : \u2115} (ha : 0 < a) :\n     \u00ac a \u2223 n \u2194 (\u2203 k : \u2115, a * k < n \u2227 n < a * (k + 1)) := by\n  refine\n    \u27e8fun han =>\n      \u27e8n / a, \u27e8Nat.lt_of_le_of_ne (mul_div_le n a) ?_, lt_mul_div_succ _ ha\u27e9\u27e9,\n      fun \u27e8k, hk1, hk2\u27e9 => not_dvd_of_between_consec_multiples hk1 hk2\u27e9\n  exact mt (\u27e8n / a, Eq.symm \u00b7\u27e9) han\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nha : 0 < a\n\u22a2 \u00aca \u2223 n \u2194 \u2203 k, a * k < n \u2227 n < a * (k + 1)"}, {"line": "refine\n    \u27e8fun han =>\n      \u27e8n / a, \u27e8Nat.lt_of_le_of_ne (mul_div_le n a) ?_, lt_mul_div_succ _ ha\u27e9\u27e9,\n      fun \u27e8k, hk1, hk2\u27e9 => not_dvd_of_between_consec_multiples hk1 hk2\u27e9", "tactic_state": "n a : \u2115\nha : 0 < a\nhan : \u00aca \u2223 n\n\u22a2 \u00aca * (n / a) = n"}, {"line": "exact mt (\u27e8n / a, Eq.symm \u00b7\u27e9) han", "tactic_state": "No Goals!"}]}
{"declaration": "lemma div_lt_div_of_lt_of_dvd {a b d : \u2115} (hdb : d \u2223 b) (h : a < b) : a / d < b / d := by\n  rw [Nat.lt_div_iff_mul_lt' hdb]\n  exact Nat.lt_of_le_of_lt (mul_div_le a d) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Init.lean", "context": {"open": ["Function"], "variables": ["{a b c d e m n k : \u2115} {p : \u2115 \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b d : \u2115\nhdb : d \u2223 b\nh : a < b\n\u22a2 a / d < b / d"}, {"line": "rw [Nat.lt_div_iff_mul_lt' hdb]", "tactic_state": "a b d : \u2115\nhdb : d \u2223 b\nh : a < b\n\u22a2 d * (a / d) < b"}, {"line": "exact Nat.lt_of_le_of_lt (mul_div_le a d) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_of_pos_sInf {s : Set \u2115} (h : 0 < sInf s) : s.Nonempty := by\n  by_contra contra\n  rw [Set.not_nonempty_iff_eq_empty] at contra\n  have h' : sInf s \u2260 0 := ne_of_gt h\n  apply h'\n  rw [Nat.sInf_eq_zero]\n  right\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Lattice.lean", "context": {"open": ["Set", "scoped Classical in", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\n\u22a2 s.Nonempty"}, {"line": "by_contra contra", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\ncontra : \u00acs.Nonempty\n\u22a2 False"}, {"line": "rw [Set.not_nonempty_iff_eq_empty] at contra", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\n\u22a2 False"}, {"line": "have h' : sInf s \u2260 0 := ne_of_gt h", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\nh' : sInf s \u2260 0\n\u22a2 False"}, {"line": "apply h'", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\nh' : sInf s \u2260 0\n\u22a2 sInf s = 0"}, {"line": "rw [Nat.sInf_eq_zero]", "tactic_state": "s : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\nh' : sInf s \u2260 0\n\u22a2 0 \u2208 s \u2228 s = \u2205"}, {"line": "right", "tactic_state": "case h\ns : Set \u2115\nh : 0 < sInf s\ncontra : s = \u2205\nh' : sInf s \u2260 0\n\u22a2 s = \u2205"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_log_of_pow_le {b x y : \u2115} (hb : 1 < b) (h : b ^ x \u2264 y) : x \u2264 log b y := by\n  rcases ne_or_eq y 0 with (hy | rfl)\n  exacts [(pow_le_iff_le_log hb hy).1 h, (h.not_lt (Nat.pow_pos (Nat.zero_lt_one.trans hb))).elim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Log.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb x y : \u2115\nhb : 1 < b\nh : b ^ x \u2264 y\n\u22a2 x \u2264 sorry"}, {"line": "rcases ne_or_eq y 0 with (hy | rfl)", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\nb x y : \u2115\nhb : 1 < b\nh : b ^ x \u2264 y\nhy : y \u2260 0\n\u22a2 x \u2264 sorry\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nb x : \u2115\nhb : 1 < b\nh : b ^ x \u2264 0\n\u22a2 x \u2264 sorry"}, {"line": "exacts [(pow_le_iff_le_log hb hy).1 h, (h.not_lt (Nat.pow_pos (Nat.zero_lt_one.trans hb))).elim]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma log2_eq_log_two {n : \u2115} : Nat.log2 n = Nat.log 2 n := by\n  rcases eq_or_ne n 0 with rfl | hn\n  \u00b7 rw [log2_zero, log_zero_right]\n  apply eq_of_forall_le_iff\n  intro m\n  rw [Nat.le_log2 hn]\n  rw [\u2190 Nat.pow_le_iff_le_log Nat.one_lt_two hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Log.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.log2 = Nat.log 2 n"}, {"line": "rcases eq_or_ne n 0 with rfl | hn", "tactic_state": "case inl\n\u22a2 Nat.log2 0 = Nat.log 2 0\n---\ncase inr\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.log2 = Nat.log 2 n"}, {"line": "\u00b7 rw [log2_zero, log_zero_right]", "tactic_state": "case inr\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.log2 = Nat.log 2 n"}, {"line": "apply eq_of_forall_le_iff", "tactic_state": "case inr.H\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2200 (c : \u2115), c \u2264 n.log2 \u2194 c \u2264 Nat.log 2 n"}, {"line": "intro m", "tactic_state": "case inr.H\nn : \u2115\nhn : n \u2260 0\nm : \u2115\n\u22a2 m \u2264 n.log2 \u2194 m \u2264 Nat.log 2 n"}, {"line": "rw [Nat.le_log2 hn]", "tactic_state": "case inr.H\nn : \u2115\nhn : n \u2260 0\nm : \u2115\n\u22a2 2 ^ m \u2264 n \u2194 m \u2264 Nat.log 2 n"}, {"line": "rw [\u2190 Nat.pow_le_iff_le_log Nat.one_lt_two hn]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma logC_zero {b : \u2115} :\n    logC b 0 = 0 := by\n  rcases le_or_lt b 1 with hb | hb\n  case inl => exact logC_of_left_le_one hb\n  case inr =>\n    rw [logC]\n    rw [dif_pos hb]\n    split\n    next q e heq =>\n    rw [logC.step] at heq\n    rw [dif_pos (zero_lt_of_lt hb)] at heq\n    rw [(Prod.mk.inj heq).2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Log.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlogC : x\u271d\nb : \u2115\n\u22a2 sorry = 0"}, {"line": "rcases le_or_lt b 1 with hb | hb", "tactic_state": "case inl\nx\u271d : Sort u_1\nlogC : x\u271d\nb : \u2115\nhb : b \u2264 1\n\u22a2 sorry = 0\n---\ncase inr\nx\u271d : Sort u_1\nlogC : x\u271d\nb : \u2115\nhb : 1 < b\n\u22a2 sorry = 0"}, {"line": "case inl => exact logC_of_left_le_one hb", "tactic_state": "case inr\nx\u271d : Sort u_1\nlogC : x\u271d\nb : \u2115\nhb : 1 < b\n\u22a2 sorry = 0"}, {"line": "case inr =>\n    rw [logC]\n    rw [dif_pos hb]\n    split\n    next q e heq =>\n    rw [logC.step] at heq\n    rw [dif_pos (zero_lt_of_lt hb)] at heq\n    rw [(Prod.mk.inj heq).2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_div (h : a / c \u2261 b / c [MOD m / c]) (ha : c \u2223 a) (ha : c \u2223 b) (ha : c \u2223 m) :\n    a \u2261 b [MOD m] := by convert h.mul_left' c <;> rwa [Nat.mul_div_cancel']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m a b c : \u2115\nh : a / c \u2261 b / c [MOD m / c]\nha\u271d\u00b9 : c \u2223 a\nha\u271d : c \u2223 b\nha : c \u2223 m\n\u22a2 a \u2261 b [MOD m]"}, {"line": "convert h.mul_left' c <;> rwa [Nat.mul_div_cancel']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_eq (h : a \u2261 b [MOD m]) : gcd a m = gcd b m := by\n  have h1 := gcd_dvd_right a m\n  have h2 := gcd_dvd_right b m\n  exact\n    dvd_antisymm (dvd_gcd ((h.dvd_iff h1).mp (gcd_dvd_left a m)) h1)\n      (dvd_gcd ((h.dvd_iff h2).mpr (gcd_dvd_left b m)) h2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m a b : \u2115\nh : a \u2261 b [MOD m]\n\u22a2 gcd a m = gcd b m"}, {"line": "have h1 := gcd_dvd_right a m", "tactic_state": "m a b : \u2115\nh : a \u2261 b [MOD m]\nh1 : gcd a m \u2223 m\n\u22a2 gcd a m = gcd b m"}, {"line": "have h2 := gcd_dvd_right b m", "tactic_state": "m a b : \u2115\nh : a \u2261 b [MOD m]\nh1 : gcd a m \u2223 m\nh2 : gcd b m \u2223 m\n\u22a2 gcd a m = gcd b m"}, {"line": "exact\n    dvd_antisymm (dvd_gcd ((h.dvd_iff h1).mp (gcd_dvd_left a m)) h1)\n      (dvd_gcd ((h.dvd_iff h2).mpr (gcd_dvd_left b m)) h2)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_abs_lt (h : a \u2261 b [MOD m]) (h2 : |(b : \u2124) - a| < m) : a = b := by\n  apply Int.ofNat.inj\n  rw [eq_comm]\n  rw [\u2190 sub_eq_zero]\n  exact Int.eq_zero_of_abs_lt_dvd h.dvd h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m a b : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 a = b"}, {"line": "apply Int.ofNat.inj", "tactic_state": "case x\nm a b : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat a = Int.ofNat b"}, {"line": "rw [eq_comm]", "tactic_state": "case x\nm a b : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat b = Int.ofNat a"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "case x\nm a b : \u2115\nh : a \u2261 b [MOD m]\nh2 : |\u2191b - \u2191a| < \u2191m\n\u22a2 Int.ofNat b - Int.ofNat a = 0"}, {"line": "exact Int.eq_zero_of_abs_lt_dvd h.dvd h2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem chineseRemainder_modEq_unique (co : n.Coprime m) {a b z}\n    (hzan : z \u2261 a [MOD n]) (hzbm : z \u2261 b [MOD m]) : z \u2261 chineseRemainder co a b [MOD n*m] := by\n  simpa [Nat.Coprime.lcm_eq_mul co] using\n    mod_lcm (hzan.trans ((chineseRemainder co a b).prop.1).symm)\n      (hzbm.trans ((chineseRemainder co a b).prop.2).symm)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nchineseRemainder : x\u271d\nco : n.Coprime m\na b z : \u2115\nhzan : z \u2261 a [MOD n]\nhzbm : z \u2261 b [MOD m]\n\u22a2 z \u2261 sorry [MOD n * m]"}, {"line": "simpa [Nat.Coprime.lcm_eq_mul co] using\n    mod_lcm (hzan.trans ((chineseRemainder co a b).prop.1).symm)\n      (hzbm.trans ((chineseRemainder co a b).prop.2).symm)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_of_mul_modEq_one (b : \u2115) {a n : \u2115} (h : a * b \u2261 1 [MOD n]) : a.Coprime n := by\n  obtain \u27e8g, hh\u27e9 := Nat.gcd_dvd_right a n\n  rw [Nat.coprime_iff_gcd_eq_one]\n  rw [\u2190 Nat.dvd_one]\n  rw [\u2190 Nat.modEq_zero_iff_dvd]\n  calc\n    1 \u2261 a * b [MOD a.gcd n] := (hh \u25b8 h).symm.of_mul_right g\n    _ \u2261 0 * b [MOD a.gcd n] := (Nat.modEq_zero_iff_dvd.mpr (Nat.gcd_dvd_left _ _)).mul_right b\n    _ = 0 := by rw [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b a n : \u2115\nh : a * b \u2261 1 [MOD n]\n\u22a2 a.Coprime n"}, {"line": "obtain \u27e8g, hh\u27e9 := Nat.gcd_dvd_right a n", "tactic_state": "case intro\nb a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = a.gcd n * g\n\u22a2 a.Coprime n"}, {"line": "rw [Nat.coprime_iff_gcd_eq_one]", "tactic_state": "case intro\nb a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = a.gcd n * g\n\u22a2 a.gcd n = 1"}, {"line": "rw [\u2190 Nat.dvd_one]", "tactic_state": "case intro\nb a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = a.gcd n * g\n\u22a2 a.gcd n \u2223 1"}, {"line": "rw [\u2190 Nat.modEq_zero_iff_dvd]", "tactic_state": "case intro\nb a n : \u2115\nh : a * b \u2261 1 [MOD n]\ng : \u2115\nhh : n = a.gcd n * g\n\u22a2 1 \u2261 0 [MOD a.gcd n]"}, {"line": "calc\n    1 \u2261 a * b [MOD a.gcd n] := (hh \u25b8 h).symm.of_mul_right g\n    _ \u2261 0 * b [MOD a.gcd n] := (Nat.modEq_zero_iff_dvd.mpr (Nat.gcd_dvd_left _ _)).mul_right b\n    _ = 0 := by rw [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_div_eq_of_le_mod_add_mod {a b c : \u2115} (hc : c \u2264 a % c + b % c) (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + 1 := by rw [Nat.add_div hc0, if_pos hc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nhc : c \u2264 a % c + b % c\nhc0 : 0 < c\n\u22a2 (a + b) / c = a / c + b / c + 1"}, {"line": "rw [Nat.add_div hc0, if_pos hc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem odd_mul_odd {n m : \u2115} : n % 2 = 1 \u2192 m % 2 = 1 \u2192 n * m % 2 = 1 := by\n  simpa [Nat.ModEq] using @ModEq.mul 2 n 1 m 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\n\u22a2 n % 2 = 1 \u2192 m % 2 = 1 \u2192 n * m % 2 = 1"}, {"line": "simpa [Nat.ModEq] using @ModEq.mul 2 n 1 m 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem odd_of_mod_four_eq_one {n : \u2115} : n % 4 = 1 \u2192 n % 2 = 1 := by\n  simpa [ModEq] using @ModEq.of_mul_left 2 n 1 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n % 4 = 1 \u2192 n % 2 = 1"}, {"line": "simpa [ModEq] using @ModEq.of_mul_left 2 n 1 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem odd_of_mod_four_eq_three {n : \u2115} : n % 4 = 3 \u2192 n % 2 = 1 := by\n  simpa [ModEq] using @ModEq.of_mul_left 2 n 3 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/ModEq.lean", "context": {"open": [], "variables": ["{m n a b c d : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n % 4 = 3 \u2192 n % 2 = 1"}, {"line": "simpa [ModEq] using @ModEq.of_mul_left 2 n 3 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_dvd_factorial_iff {p : \u2115} {n r b : \u2115} (hp : p.Prime) (hbn : log p n < b) :\n    p ^ r \u2223 n ! \u2194 r \u2264 \u2211 i \u2208 Ico 1 b, n / p ^ i := by\n  rw [\u2190 WithTop.coe_le_coe]\n  rw [ENat.some_eq_coe]\n  rw [\u2190 hp.emultiplicity_factorial hbn]\n  rw [pow_dvd_iff_le_emultiplicity]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Multiplicity.lean", "context": {"open": ["Finset Nat", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n r b : \u2115\nhp : Nat.Prime p\nhbn : log p n < b\n\u22a2 p ^ r \u2223 n.factorial \u2194 r \u2264 \u2211 i \u2208 Ico 1 b, n / p ^ i"}, {"line": "rw [\u2190 WithTop.coe_le_coe]", "tactic_state": "p n r b : \u2115\nhp : Nat.Prime p\nhbn : log p n < b\n\u22a2 p ^ r \u2223 n.factorial \u2194 \u2191r \u2264 \u2191(\u2211 i \u2208 Ico 1 b, n / p ^ i)"}, {"line": "rw [ENat.some_eq_coe]", "tactic_state": "p n r b : \u2115\nhp : Nat.Prime p\nhbn : log p n < b\n\u22a2 p ^ r \u2223 n.factorial \u2194 \u2191r \u2264 \u2191(\u2211 i \u2208 Ico 1 b, n / p ^ i)"}, {"line": "rw [\u2190 hp.emultiplicity_factorial hbn]", "tactic_state": "p n r b : \u2115\nhp : Nat.Prime p\nhbn : log p n < b\n\u22a2 p ^ r \u2223 n.factorial \u2194 \u2191r \u2264 emultiplicity p n.factorial"}, {"line": "rw [pow_dvd_iff_le_emultiplicity]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem emultiplicity_factorial_le_div_pred {p : \u2115} (hp : p.Prime) (n : \u2115) :\n    emultiplicity p n ! \u2264 (n / (p - 1) : \u2115) := by\n  rw [hp.emultiplicity_factorial (lt_succ_self _)]\n  apply WithTop.coe_mono\n  exact Nat.geom_sum_Ico_le hp.two_le _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Multiplicity.lean", "context": {"open": ["Finset Nat", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nn : \u2115\n\u22a2 emultiplicity p n.factorial \u2264 \u2191(n / (p - 1))"}, {"line": "rw [hp.emultiplicity_factorial (lt_succ_self _)]", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nn : \u2115\n\u22a2 \u2191(\u2211 i \u2208 Ico 1 (log p n).succ, n / p ^ i) \u2264 \u2191(n / (p - 1))"}, {"line": "apply WithTop.coe_mono", "tactic_state": "case a\np : \u2115\nhp : Nat.Prime p\nn : \u2115\n\u22a2 \u2211 i \u2208 Ico 1 (log p n).succ, n / p ^ i \u2264 n / (p - 1)"}, {"line": "exact Nat.geom_sum_Ico_le hp.two_le _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_choose_pow_iff (hp : Prime p) : p \u2223 (p ^ n).choose k \u2194 k \u2260 0 \u2227 k \u2260 p ^ n := by\n  refine \u27e8fun h => \u27e8?_, ?_\u27e9, fun h => dvd_choose_pow hp h.1 h.2\u27e9 <;> rintro rfl <;>\n    simp [hp.ne_one] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Multiplicity.lean", "context": {"open": ["Finset Nat", "Nat"], "variables": ["{p n k : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p n k : \u2115\nhp : sorry\n\u22a2 p \u2223 (p ^ n).choose k \u2194 k \u2260 0 \u2227 k \u2260 p ^ n"}, {"line": "refine \u27e8fun h => \u27e8?_, ?_\u27e9, fun h => dvd_choose_pow hp h.1 h.2\u27e9 <;> rintro rfl <;>\n    simp [hp.ne_one] at h", "tactic_state": "case refine_1\np n : \u2115\nhp : sorry\nh : p = 1\n\u22a2 False\n---\ncase refine_2\np n : \u2115\nhp : sorry\nh : p = 1\n\u22a2 False"}]}
{"declaration": "theorem nth_zero_of_zero (h : p 0) : nth p 0 = 0 := by simp [nth_zero, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Nth.lean", "context": {"open": ["Finset"], "variables": ["(p : \u2115 \u2192 Prop)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nh : p 0\n\u22a2 sorry = 0"}, {"line": "simp [nth_zero, h]", "tactic_state": "p : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nh : p 0\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma nth_comp_of_strictMono {n : \u2115} {f : \u2115 \u2192 \u2115} (hf : StrictMono f)\n    (h0 : \u2200 k, p k \u2192 k \u2208 Set.range f) (h : \u2200 hfi : (setOf p).Finite, n < hfi.toFinset.card) :\n    f (nth (fun i \u21a6 p (f i)) n) = nth p n := by\n  have hs {p' : \u2115 \u2192 Prop} (h0p' : \u2200 k, p' k \u2192 k \u2208 Set.range f) :\n      f '' {i | p' (f i)} = setOf p' := by\n    ext i\n    refine \u27e8fun \u27e8_, hi, h\u27e9 \u21a6 h \u25b8 hi, fun he \u21a6 ?_\u27e9\n    rcases h0p' _ he with \u27e8t, rfl\u27e9\n    exact \u27e8t, he, rfl\u27e9\n  induction n using Nat.case_strong_induction_on\n  case _ =>\n    simp_rw [nth_zero]\n    replace h := nth_mem _ h\n    rw [\u2190 hs h0]\n    rw [\u2190 hf.monotone.map_csInf]\n    rcases h0 _ h with \u27e8t, ht\u27e9\n    exact \u27e8t, Set.mem_setOf_eq \u25b8 ht \u25b8 h\u27e9\n  case _ n ih =>\n    repeat nth_rw 1 [nth_eq_sInf]\n    have h0' : \u2200 k', (p k' \u2227 \u2200 k < n + 1, nth p k < k') \u2192 k' \u2208 Set.range f := fun _ h \u21a6 h0 _ h.1\n    rw [\u2190 hs h0']\n    rw [\u2190 hf.monotone.map_csInf]\n    \u00b7 convert rfl using 8 with k m' hm\n      nth_rw 2 [\u2190 hf.lt_iff_lt]\n      convert Iff.rfl using 2\n      exact ih m' (Nat.lt_add_one_iff.mp hm) fun hfi \u21a6 hm.trans (h hfi)\n    \u00b7 rcases h0 _ (nth_mem _ h) with \u27e8t, ht\u27e9\n      exact \u27e8t, ht \u25b8 (nth_mem _ h), fun _ hk \u21a6 ht \u25b8 nth_lt_nth' hk h\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Nth.lean", "context": {"open": ["Finset"], "variables": ["(p : \u2115 \u2192 Prop)", "{p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nn : \u2115\nf : \u2115 \u2192 \u2115\nhf : StrictMono f\nh0 : \u2200 (k : \u2115), p k \u2192 k \u2208 Set.range f\nh : \u2200 (hfi : (setOf p).Finite), n < hfi.toFinset.card\n\u22a2 f sorry = sorry"}, {"line": "have hs {p' : \u2115 \u2192 Prop} (h0p' : \u2200 k, p' k \u2192 k \u2208 Set.range f) :\n      f '' {i | p' (f i)} = setOf p' := by\n    ext i\n    refine \u27e8fun \u27e8_, hi, h\u27e9 \u21a6 h \u25b8 hi, fun he \u21a6 ?_\u27e9\n    rcases h0p' _ he with \u27e8t, rfl\u27e9\n    exact \u27e8t, he, rfl\u27e9", "tactic_state": "p : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nn : \u2115\nf : \u2115 \u2192 \u2115\nhf : StrictMono f\nh0 : \u2200 (k : \u2115), p k \u2192 k \u2208 Set.range f\nh : \u2200 (hfi : (setOf p).Finite), n < hfi.toFinset.card\nhs : \u2200 {p' : \u2115 \u2192 Prop}, (\u2200 (k : \u2115), p' k \u2192 k \u2208 Set.range f) \u2192 f '' {i | p' (f i)} = setOf p'\n\u22a2 f sorry = sorry"}, {"line": "induction n using Nat.case_strong_induction_on", "tactic_state": "case hz\np : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nf : \u2115 \u2192 \u2115\nhf : StrictMono f\nh0 : \u2200 (k : \u2115), p k \u2192 k \u2208 Set.range f\nhs : \u2200 {p' : \u2115 \u2192 Prop}, (\u2200 (k : \u2115), p' k \u2192 k \u2208 Set.range f) \u2192 f '' {i | p' (f i)} = setOf p'\nh : \u2200 (hfi : (setOf p).Finite), 0 < hfi.toFinset.card\n\u22a2 f sorry = sorry\n---\ncase hi\np : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nf : \u2115 \u2192 \u2115\nhf : StrictMono f\nh0 : \u2200 (k : \u2115), p k \u2192 k \u2208 Set.range f\nhs : \u2200 {p' : \u2115 \u2192 Prop}, (\u2200 (k : \u2115), p' k \u2192 k \u2208 Set.range f) \u2192 f '' {i | p' (f i)} = setOf p'\nn\u271d : \u2115\na\u271d : \u2200 m \u2264 n\u271d, (\u2200 (hfi : (setOf p).Finite), m < hfi.toFinset.card) \u2192 f sorry = sorry\nh : \u2200 (hfi : (setOf p).Finite), n\u271d + 1 < hfi.toFinset.card\n\u22a2 f sorry = sorry"}, {"line": "case _ =>\n    simp_rw [nth_zero]\n    replace h := nth_mem _ h\n    rw [\u2190 hs h0]\n    rw [\u2190 hf.monotone.map_csInf]\n    rcases h0 _ h with \u27e8t, ht\u27e9\n    exact \u27e8t, Set.mem_setOf_eq \u25b8 ht \u25b8 h\u27e9", "tactic_state": "case hi\np : \u2115 \u2192 Prop\nx\u271d : Sort u_1\nnth : x\u271d\nf : \u2115 \u2192 \u2115\nhf : StrictMono f\nh0 : \u2200 (k : \u2115), p k \u2192 k \u2208 Set.range f\nhs : \u2200 {p' : \u2115 \u2192 Prop}, (\u2200 (k : \u2115), p' k \u2192 k \u2208 Set.range f) \u2192 f '' {i | p' (f i)} = setOf p'\nn\u271d : \u2115\na\u271d : \u2200 m \u2264 n\u271d, (\u2200 (hfi : (setOf p).Finite), m < hfi.toFinset.card) \u2192 f sorry = sorry\nh : \u2200 (hfi : (setOf p).Finite), n\u271d + 1 < hfi.toFinset.card\n\u22a2 f sorry = sorry"}, {"line": "case _ n ih =>\n    repeat nth_rw 1 [nth_eq_sInf]\n    have h0' : \u2200 k', (p k' \u2227 \u2200 k < n + 1, nth p k < k') \u2192 k' \u2208 Set.range f := fun _ h \u21a6 h0 _ h.1\n    rw [\u2190 hs h0']\n    rw [\u2190 hf.monotone.map_csInf]\n    \u00b7 convert rfl using 8 with k m' hm\n      nth_rw 2 [\u2190 hf.lt_iff_lt]\n      convert Iff.rfl using 2\n      exact ih m' (Nat.lt_add_one_iff.mp hm) fun hfi \u21a6 hm.trans (h hfi)\n    \u00b7 rcases h0 _ (nth_mem _ h) with \u27e8t, ht\u27e9\n      exact \u27e8t, ht \u25b8 (nth_mem _ h), fun _ hk \u21a6 ht \u25b8 nth_lt_nth' hk h\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem filter_range_nth_subset_insert (k : \u2115) :\n    {n \u2208 range (nth p (k + 1)) | p n} \u2286 insert (nth p k) {n \u2208 range (nth p k) | p n} := by\n  intro a ha\n  simp only [mem_insert] at ha \u22a2\n  simp only [mem_filter] at ha \u22a2\n  simp only [mem_range] at ha \u22a2\n  exact (le_nth_of_lt_nth_succ ha.1 ha.2).eq_or_lt.imp_right fun h => \u27e8h, ha.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Nth.lean", "context": {"open": ["Finset"], "variables": ["(p : \u2115 \u2192 Prop)", "{p}", "(p) [DecidablePred p]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nnth : x\u271d\nk : \u2115\n\u22a2 {n \u2208 range sorry | p n} \u2286 insert sorry ({n \u2208 range sorry | p n})"}, {"line": "intro a ha", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nnth : x\u271d\nk a : \u2115\nha : a \u2208 {n \u2208 range sorry | p n}\n\u22a2 a \u2208 insert sorry ({n \u2208 range sorry | p n})"}, {"line": "simp only [mem_insert] at ha \u22a2", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nnth : x\u271d\nk a : \u2115\nha : a \u2208 {n \u2208 range sorry | p n}\n\u22a2 a = sorry \u2228 a \u2208 {n \u2208 range sorry | p n}"}, {"line": "simp only [mem_filter] at ha \u22a2", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nnth : x\u271d\nk a : \u2115\nha : a \u2208 range sorry \u2227 p a\n\u22a2 a = sorry \u2228 a \u2208 range sorry \u2227 p a"}, {"line": "simp only [mem_range] at ha \u22a2", "tactic_state": "p : \u2115 \u2192 Prop\ninst\u271d : DecidablePred p\nx\u271d : Sort u_1\nnth : x\u271d\nk a : \u2115\nha : a < sorry \u2227 p a\n\u22a2 a = sorry \u2228 a < sorry \u2227 p a"}, {"line": "exact (le_nth_of_lt_nth_succ ha.1 ha.2).eq_or_lt.imp_right fun h => \u27e8h, ha.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_eq_ppred (n : \u2115) : pred n = (ppred n).getD 0 := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PSub.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\npred : x\u271d\u00b9\nx\u271d : Sort u_2\nppred : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pair_unpair' {n a b} (H : unpair n = (a, b)) : pair a b = n := by\n  simpa [H] using pair_unpair n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Pairing.lean", "context": {"open": ["Prod Decidable Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nunpair : x\u271d\u00b9\nx\u271d : Sort u_2\npair : x\u271d\nn : ?m.884\na : ?m.885\nb : ?m.886\nH : sorry = (a, b)\n\u22a2 sorry = n"}, {"line": "simpa [H] using pair_unpair n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem left_le_pair (a b : \u2115) : a \u2264 pair a b := by simpa using unpair_left_le (pair a b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Pairing.lean", "context": {"open": ["Prod Decidable Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npair : x\u271d\na b : \u2115\n\u22a2 a \u2264 sorry"}, {"line": "simpa using unpair_left_le (pair a b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem right_le_pair (a b : \u2115) : b \u2264 pair a b := by\n  by_cases h : a < b\n  \u00b7 simpa [pair, h] using le_trans (le_mul_self _) (Nat.le_add_right _ _)\n  \u00b7 simp [pair, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Pairing.lean", "context": {"open": ["Prod Decidable Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\npair : x\u271d\na b : \u2115\n\u22a2 b \u2264 sorry"}, {"line": "by_cases h : a < b", "tactic_state": "case pos\nx\u271d : Sort u_1\npair : x\u271d\na b : \u2115\nh : a < b\n\u22a2 b \u2264 sorry\n---\ncase neg\nx\u271d : Sort u_1\npair : x\u271d\na b : \u2115\nh : \u00aca < b\n\u22a2 b \u2264 sorry"}, {"line": "\u00b7 simpa [pair, h] using le_trans (le_mul_self _) (Nat.le_add_right _ _)", "tactic_state": "case neg\nx\u271d : Sort u_1\npair : x\u271d\na b : \u2115\nh : \u00aca < b\n\u22a2 b \u2264 sorry"}, {"line": "\u00b7 simp [pair, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unpair_right_le (n : \u2115) : (unpair n).2 \u2264 n := by\n  simpa using right_le_pair n.unpair.1 n.unpair.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Pairing.lean", "context": {"open": ["Prod Decidable Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nunpair : x\u271d\nn : \u2115\n\u22a2 sorry \u2264 n"}, {"line": "simpa using right_le_pair n.unpair.1 n.unpair.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iUnion_unpair_prod {\u03b1 \u03b2} {s : \u2115 \u2192 Set \u03b1} {t : \u2115 \u2192 Set \u03b2} :\n    \u22c3 n : \u2115, s n.unpair.fst \u00d7\u02e2 t n.unpair.snd = (\u22c3 n, s n) \u00d7\u02e2 \u22c3 n, t n := by\n  rw [\u2190 Set.iUnion_prod]\n  exact surjective_unpair.iUnion_comp (fun x => s x.fst \u00d7\u02e2 t x.snd)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Pairing.lean", "context": {"open": ["Prod Decidable Function", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : \u2115 \u2192 Set \u03b1\nt : \u2115 \u2192 Set \u03b2\n\u22a2 \u22c3 n, s (unpair n).1 \u00d7\u02e2 t (unpair n).2 = (\u22c3 n, s n) \u00d7\u02e2 \u22c3 n, t n"}, {"line": "rw [\u2190 Set.iUnion_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ns : \u2115 \u2192 Set \u03b1\nt : \u2115 \u2192 Set \u03b2\n\u22a2 \u22c3 n, s (unpair n).1 \u00d7\u02e2 t (unpair n).2 = \u22c3 x, s x.1 \u00d7\u02e2 t x.2"}, {"line": "exact surjective_unpair.iUnion_comp (fun x => s x.fst \u00d7\u02e2 t x.snd)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_top (x : PartENat) : x + \u22a4 = \u22a4 := by rw [add_comm, top_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PartENat\n\u22a2 x + \u22a4 = \u22a4"}, {"line": "rw [add_comm, top_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_get {x : PartENat} (h : x.Dom) : (x.get h : PartENat) = x := by\n  exact Part.ext' (iff_of_true trivial h) fun _ _ => rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PartENat\nh : x.Dom\n\u22a2 \u2191(x.get h) = x"}, {"line": "exact Part.ext' (iff_of_true trivial h) fun _ _ => rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_add_get {x : \u2115} {y : PartENat} (h : ((x : PartENat) + y).Dom) :\n    get ((x : PartENat) + y) h = x + get y h.2 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2115\ny : PartENat\nh : (\u2191x + y).Dom\n\u22a2 (\u2191x + y).get h = x + y.get \u22ef"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem get_eq_iff_eq_coe {a : PartENat} {ha : a.Dom} {b : \u2115} : a.get ha = b \u2194 a = b := by\n  rw [get_eq_iff_eq_some]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : PartENat\nha : a.Dom\nb : \u2115\n\u22a2 a.get ha = b \u2194 a = \u2191b"}, {"line": "rw [get_eq_iff_eq_some]", "tactic_state": "a : PartENat\nha : a.Dom\nb : \u2115\n\u22a2 a = Part.some b \u2194 a = \u2191b"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dom_of_le_natCast {x : PartENat} {y : \u2115} (h : x \u2264 y) : x.Dom := by\n  exact dom_of_le_some h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PartENat\ny : \u2115\nh : x \u2264 \u2191y\n\u22a2 x.Dom"}, {"line": "exact dom_of_le_some h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_top_iff_dom {x : PartENat} : x \u2260 \u22a4 \u2194 x.Dom := by\n  classical exact not_iff_comm.1 Part.eq_none_iff'.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PartENat\n\u22a2 x \u2260 \u22a4 \u2194 x.Dom"}, {"line": "classical exact not_iff_comm.1 Part.eq_none_iff'.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_add_one {x : PartENat} (hx : x \u2260 \u22a4) : x < x + 1 := by\n  rw [PartENat.lt_add_iff_pos_right hx]\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : PartENat\nhx : x \u2260 \u22a4\n\u22a2 x < x + 1"}, {"line": "rw [PartENat.lt_add_iff_pos_right hx]", "tactic_state": "x : PartENat\nhx : x \u2260 \u22a4\n\u22a2 0 < 1"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toWithTop_top' {h : Decidable (\u22a4 : PartENat).Dom} : toWithTop \u22a4 = \u22a4 := by\n  convert toWithTop_top\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoWithTop : x\u271d\nh : Decidable \u22a4.Dom\n\u22a2 sorry = \u22a4"}, {"line": "convert toWithTop_top", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toWithTop_zero' {h : Decidable (0 : PartENat).Dom} : toWithTop 0 = 0 := by\n  convert toWithTop_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoWithTop : x\u271d\nh : Decidable (Dom 0)\n\u22a2 sorry = 0"}, {"line": "convert toWithTop_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toWithTop_one' {h : Decidable (1 : PartENat).Dom} : toWithTop 1 = 1 := by\n  convert toWithTop_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoWithTop : x\u271d\nh : Decidable (Dom 1)\n\u22a2 sorry = 1"}, {"line": "convert toWithTop_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toWithTop_le {x y : PartENat} [hx : Decidable x.Dom] [hy : Decidable y.Dom] :\n    toWithTop x \u2264 toWithTop y \u2194 x \u2264 y := by\n  induction y using PartENat.casesOn generalizing hy\n  \u00b7 simp\n  induction x using PartENat.casesOn generalizing hx\n  \u00b7 simp\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoWithTop : x\u271d\nx y : PartENat\nhx : Decidable x.Dom\nhy : Decidable y.Dom\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 y"}, {"line": "induction y using PartENat.casesOn generalizing hy", "tactic_state": "case a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nx : PartENat\nhx : Decidable x.Dom\nhy : Decidable \u22a4.Dom\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 \u22a4\n---\ncase a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nx : PartENat\nhx : Decidable x.Dom\nn\u271d : \u2115\nhy : Decidable (\u2191n\u271d).Dom\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 \u2191n\u271d"}, {"line": "\u00b7 simp", "tactic_state": "case a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nx : PartENat\nhx : Decidable x.Dom\nn\u271d : \u2115\nhy : Decidable (\u2191n\u271d).Dom\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 \u2191n\u271d"}, {"line": "induction x using PartENat.casesOn generalizing hx", "tactic_state": "case a.a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nn\u271d : \u2115\nhy : Decidable (\u2191n\u271d).Dom\nhx : Decidable \u22a4.Dom\n\u22a2 sorry \u2264 sorry \u2194 \u22a4 \u2264 \u2191n\u271d\n---\ncase a.a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nn\u271d\u00b9 : \u2115\nhy : Decidable (\u2191n\u271d\u00b9).Dom\nn\u271d : \u2115\nhx : Decidable (\u2191n\u271d).Dom\n\u22a2 sorry \u2264 sorry \u2194 \u2191n\u271d \u2264 \u2191n\u271d\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case a.a\nx\u271d : Sort u_1\ntoWithTop : x\u271d\nn\u271d\u00b9 : \u2115\nhy : Decidable (\u2191n\u271d\u00b9).Dom\nn\u271d : \u2115\nhx : Decidable (\u2191n\u271d).Dom\n\u22a2 sorry \u2264 sorry \u2194 \u2191n\u271d \u2264 \u2191n\u271d\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofENat_toWithTop (x : PartENat) {_ : Decidable (x : PartENat).Dom} : toWithTop x = x := by\n  induction x using PartENat.casesOn <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ntoWithTop : x\u271d\u00b9\nx : PartENat\nx\u271d : Decidable x.Dom\n\u22a2 sorry = x"}, {"line": "induction x using PartENat.casesOn <;> simp", "tactic_state": "case a\nx\u271d\u00b9 : Sort u_1\ntoWithTop : x\u271d\u00b9\nx\u271d : Decidable \u22a4.Dom\n\u22a2 sorry () = \u22a4\n---\ncase a\nx\u271d\u00b9 : Sort u_1\ntoWithTop : x\u271d\u00b9\nn\u271d : \u2115\nx\u271d : Decidable (\u2191n\u271d).Dom\n\u22a2 sorry () = \u2191n\u271d"}]}
{"declaration": "theorem toWithTop_add {x y : PartENat} : toWithTop (x + y) = toWithTop x + toWithTop y := by\n  refine PartENat.casesOn y ?_ ?_ <;> refine PartENat.casesOn x ?_ ?_ <;>\n    simp [add_top, top_add, \u2190 Nat.cast_add, \u2190 ENat.coe_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntoWithTop : x\u271d\nx y : PartENat\n\u22a2 sorry = sorry + sorry"}, {"line": "refine PartENat.casesOn y ?_ ?_ <;> refine PartENat.casesOn x ?_ ?_ <;>\n    simp [add_top, top_add, \u2190 Nat.cast_add, \u2190 ENat.coe_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem withTopEquiv_top : withTopEquiv \u22a4 = \u22a4 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry = \u22a4"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem withTopEquiv_natCast (n : Nat) : withTopEquiv n = n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nn : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nn : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem withTopEquiv_zero : withTopEquiv 0 = 0 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem withTopEquiv_one : withTopEquiv 1 = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem withTopEquiv_ofNat (n : Nat) [n.AtLeastTwo] :\n    withTopEquiv ofNat(n) = OfNat.ofNat n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nn : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 sorry = OfNat.ofNat n"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nn : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 sorry () = OfNat.ofNat n"}]}
{"declaration": "theorem withTopEquiv_le {x y : PartENat} : withTopEquiv x \u2264 withTopEquiv y \u2194 x \u2264 y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nx y : PartENat\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 y"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nx y : PartENat\n\u22a2 sorry () \u2264 sorry () \u2194 x \u2264 y"}]}
{"declaration": "theorem withTopEquiv_lt {x y : PartENat} : withTopEquiv x < withTopEquiv y \u2194 x < y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nx y : PartENat\n\u22a2 sorry < sorry \u2194 x < y"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nwithTopEquiv : x\u271d\nx y : PartENat\n\u22a2 sorry () < sorry () \u2194 x < y"}]}
{"declaration": "theorem withTopEquiv_symm_top : withTopEquiv.symm \u22a4 = \u22a4 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = \u22a4"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = \u22a4"}]}
{"declaration": "theorem withTopEquiv_symm_coe (n : Nat) : withTopEquiv.symm n = n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sorry = n"}, {"line": "simp", "tactic_state": "n : \u2115\n\u22a2 sorry () = n"}]}
{"declaration": "theorem withTopEquiv_symm_zero : withTopEquiv.symm 0 = 0 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 0"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = 0"}]}
{"declaration": "theorem withTopEquiv_symm_one : withTopEquiv.symm 1 = 1 := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = 1"}, {"line": "simp", "tactic_state": "\u22a2 sorry () = 1"}]}
{"declaration": "theorem withTopEquiv_symm_ofNat (n : Nat) [n.AtLeastTwo] :\n    withTopEquiv.symm ofNat(n) = OfNat.ofNat n := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 sorry = OfNat.ofNat n"}, {"line": "simp", "tactic_state": "n : \u2115\ninst\u271d : n.AtLeastTwo\n\u22a2 sorry () = OfNat.ofNat n"}]}
{"declaration": "theorem withTopEquiv_symm_le {x y : \u2115\u221e} : withTopEquiv.symm x \u2264 withTopEquiv.symm y \u2194 x \u2264 y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\u221e\n\u22a2 sorry \u2264 sorry \u2194 x \u2264 y"}, {"line": "simp", "tactic_state": "x y : \u2115\u221e\n\u22a2 sorry () \u2264 sorry () \u2194 x \u2264 y"}]}
{"declaration": "theorem withTopEquiv_symm_lt {x y : \u2115\u221e} : withTopEquiv.symm x < withTopEquiv.symm y \u2194 x < y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/PartENat.lean", "context": {"open": ["Part hiding some", "scoped Classical in", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2115\u221e\n\u22a2 sorry < sorry \u2194 x < y"}, {"line": "simp", "tactic_state": "x y : \u2115\u221e\n\u22a2 sorry () < sorry () \u2194 x < y"}]}
{"declaration": "lemma sqrt_le' (n : \u2115) : sqrt n ^ 2 \u2264 n := by simpa [Nat.pow_two] using sqrt_le n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsqrt : x\u271d\nn : \u2115\n\u22a2 sorry ^ 2 \u2264 n"}, {"line": "simpa [Nat.pow_two] using sqrt_le n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_succ_sqrt' (n : \u2115) : n < succ (sqrt n) ^ 2 := by simpa [Nat.pow_two] using lt_succ_sqrt n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsucc : x\u271d\nn : \u2115\n\u22a2 n < sorry ^ 2"}, {"line": "simpa [Nat.pow_two] using lt_succ_sqrt n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_sqrt' : m \u2264 sqrt n \u2194 m ^ 2 \u2264 n := by simpa only [Nat.pow_two] using le_sqrt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 m \u2264 sorry \u2194 m ^ 2 \u2264 n"}, {"line": "simpa only [Nat.pow_two] using le_sqrt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sqrt_lt : sqrt m < n \u2194 m < n * n := by simp only [\u2190 not_le, le_sqrt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 sorry < n \u2194 m < n * n"}, {"line": "simp only [\u2190 not_le, le_sqrt]", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 \u00acn \u2264 sorry \u2194 \u00acn * n \u2264 m"}]}
{"declaration": "lemma sqrt_lt' : sqrt m < n \u2194 m < n ^ 2 := by simp only [\u2190 not_le, le_sqrt']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 sorry < n \u2194 m < n ^ 2"}, {"line": "simp only [\u2190 not_le, le_sqrt']", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 \u00acn \u2264 sorry \u2194 \u00acn ^ 2 \u2264 m"}]}
{"declaration": "lemma eq_sqrt' : a = sqrt n \u2194 a ^ 2 \u2264 n \u2227 n < (a + 1) ^ 2 := by\n  simpa only [Nat.pow_two] using eq_sqrt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\n\u22a2 a = sorry \u2194 a ^ 2 \u2264 n \u2227 n < (a + 1) ^ 2"}, {"line": "simpa only [Nat.pow_two] using eq_sqrt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sqrt_add_eq' (n : \u2115) (h : a \u2264 n + n) : sqrt (n ^ 2 + a) = n := by\n  simpa [Nat.pow_two] using sqrt_add_eq n h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\nx\u271d : Sort u_1\nsqrt : x\u271d\nn : \u2115\nh : a \u2264 n + n\n\u22a2 sorry = n"}, {"line": "simpa [Nat.pow_two] using sqrt_add_eq n h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_mul_self' (x : \u2115) : (\u2203 n, n ^ 2 = x) \u2194 sqrt x ^ 2 = x := by\n  simpa only [Nat.pow_two] using exists_mul_self x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsqrt : x\u271d\nx : \u2115\n\u22a2 (\u2203 n, n ^ 2 = x) \u2194 sorry ^ 2 = x"}, {"line": "simpa only [Nat.pow_two] using exists_mul_self x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_exists_sq' : m ^ 2 < n \u2192 n < (m + 1) ^ 2 \u2192 \u00ac\u2203 t, t ^ 2 = n := by\n  simpa only [Nat.pow_two] using not_exists_sq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Sqrt.lean", "context": {"open": [], "variables": ["{m n a : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 m ^ 2 < n \u2192 n < (m + 1) ^ 2 \u2192 \u00ac\u2203 t, t ^ 2 = n"}, {"line": "simpa only [Nat.pow_two] using not_exists_sq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem squarefree_iff_nodup_primeFactorsList {n : \u2115} (h0 : n \u2260 0) :\n    Squarefree n \u2194 n.primeFactorsList.Nodup := by\n  rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors h0]\n  rw [Nat.factors_eq]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Squarefree.lean", "context": {"open": ["Finset"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh0 : n \u2260 0\n\u22a2 Squarefree n \u2194 n.primeFactorsList.Nodup"}, {"line": "rw [UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors h0]", "tactic_state": "n : \u2115\nh0 : n \u2260 0\n\u22a2 (UniqueFactorizationMonoid.normalizedFactors n).Nodup \u2194 n.primeFactorsList.Nodup"}, {"line": "rw [Nat.factors_eq]", "tactic_state": "n : \u2115\nh0 : n \u2260 0\n\u22a2 (\u2191n.primeFactorsList).Nodup \u2194 n.primeFactorsList.Nodup"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem squarefree_pow_iff {n k : \u2115} (hn : n \u2260 1) (hk : k \u2260 0) :\n    Squarefree (n ^ k) \u2194 Squarefree n \u2227 k = 1 := by\n  refine \u27e8fun h => ?_, by rintro \u27e8hn, rfl\u27e9; simpa\u27e9\n  rcases eq_or_ne n 0 with (rfl | -)\n  \u00b7 simp [zero_pow hk] at h\n  refine \u27e8h.squarefree_of_dvd (dvd_pow_self _ hk), by_contradiction fun h\u2081 => ?_\u27e9\n  have : 2 \u2264 k := k.two_le_iff.mpr \u27e8hk, h\u2081\u27e9\n  apply hn (Nat.isUnit_iff.1 (h _ _))\n  rw [\u2190 sq]\n  exact pow_dvd_pow _ this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Squarefree.lean", "context": {"open": ["Finset"], "variables": ["{s : Finset \u2115} {m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\n\u22a2 Squarefree (n ^ k) \u2194 Squarefree n \u2227 k = 1"}, {"line": "refine \u27e8fun h => ?_, by rintro \u27e8hn, rfl\u27e9; simpa\u27e9", "tactic_state": "n k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\n\u22a2 Squarefree n \u2227 k = 1"}, {"line": "rcases eq_or_ne n 0 with (rfl | -)", "tactic_state": "case inl\nk : \u2115\nhk : k \u2260 0\nhn : 0 \u2260 1\nh : Squarefree (0 ^ k)\n\u22a2 Squarefree 0 \u2227 k = 1\n---\ncase inr\nn k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\n\u22a2 Squarefree n \u2227 k = 1"}, {"line": "\u00b7 simp [zero_pow hk] at h", "tactic_state": "case inr\nn k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\n\u22a2 Squarefree n \u2227 k = 1"}, {"line": "refine \u27e8h.squarefree_of_dvd (dvd_pow_self _ hk), by_contradiction fun h\u2081 => ?_\u27e9", "tactic_state": "case inr\nn k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\nh\u2081 : \u00ack = 1\n\u22a2 False"}, {"line": "have : 2 \u2264 k := k.two_le_iff.mpr \u27e8hk, h\u2081\u27e9", "tactic_state": "case inr\nn k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\nh\u2081 : \u00ack = 1\nthis : 2 \u2264 k\n\u22a2 False"}, {"line": "apply hn (Nat.isUnit_iff.1 (h _ _))", "tactic_state": "n k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\nh\u2081 : \u00ack = 1\nthis : 2 \u2264 k\n\u22a2 n * n \u2223 n ^ k"}, {"line": "rw [\u2190 sq]", "tactic_state": "n k : \u2115\nhn : n \u2260 1\nhk : k \u2260 0\nh : Squarefree (n ^ k)\nh\u2081 : \u00ack = 1\nthis : 2 \u2264 k\n\u22a2 n ^ 2 \u2223 n ^ k"}, {"line": "exact pow_dvd_pow _ this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sq_mul_squarefree (n : \u2115) : \u2203 a b : \u2115, b ^ 2 * a = n \u2227 Squarefree a := by\n  rcases n with - | n\n  \u00b7 exact \u27e81, 0, by simp, squarefree_one\u27e9\n  \u00b7 obtain \u27e8a, b, -, -, h\u2081, h\u2082\u27e9 := sq_mul_squarefree_of_pos (succ_pos n)\n    exact \u27e8a, b, h\u2081, h\u2082\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Squarefree.lean", "context": {"open": ["Finset", "UniqueFactorizationMonoid"], "variables": ["{s : Finset \u2115} {m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2203 a b, b ^ 2 * a = n \u2227 Squarefree a"}, {"line": "rcases n with - | n", "tactic_state": "case zero\n\u22a2 \u2203 a b, b ^ 2 * a = 0 \u2227 Squarefree a\n---\ncase succ\nn : \u2115\n\u22a2 \u2203 a b, b ^ 2 * a = n + 1 \u2227 Squarefree a"}, {"line": "\u00b7 exact \u27e81, 0, by simp, squarefree_one\u27e9", "tactic_state": "case succ\nn : \u2115\n\u22a2 \u2203 a b, b ^ 2 * a = n + 1 \u2227 Squarefree a"}, {"line": "\u00b7 obtain \u27e8a, b, -, -, h\u2081, h\u2082\u27e9 := sq_mul_squarefree_of_pos (succ_pos n)\n    exact \u27e8a, b, h\u2081, h\u2082\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coprime_div_gcd_of_squarefree (hm : Squarefree m) (hn : n \u2260 0) : Coprime (m / gcd m n) n := by\n  have : Coprime (m / gcd m n) (gcd m n) :=\n    coprime_of_squarefree_mul <| by simpa [Nat.div_mul_cancel, gcd_dvd_left]\n  simpa [Nat.div_mul_cancel, gcd_dvd_right] using\n    (coprime_div_gcd_div_gcd (m := m) (gcd_ne_zero_right hn).bot_lt).mul_right this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Squarefree.lean", "context": {"open": ["Finset", "UniqueFactorizationMonoid"], "variables": ["{s : Finset \u2115} {m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nCoprime : x\u271d\nhm : Squarefree m\nhn : n \u2260 0\n\u22a2 sorry"}, {"line": "have : Coprime (m / gcd m n) (gcd m n) :=\n    coprime_of_squarefree_mul <| by simpa [Nat.div_mul_cancel, gcd_dvd_left]", "tactic_state": "m n : \u2115\nx\u271d : Sort u_1\nCoprime : x\u271d\nhm : Squarefree m\nhn : n \u2260 0\nthis : sorry\n\u22a2 sorry"}, {"line": "simpa [Nat.div_mul_cancel, gcd_dvd_right] using\n    (coprime_div_gcd_div_gcd (m := m) (gcd_ne_zero_right hn).bot_lt).mul_right this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_squarefree_mul (a aa b n : \u2115) (ha : a * a = aa) (hb : aa * b = n) (h\u2081 : 1 < a) :\n    \u00acSquarefree n := by\n  rw [\u2190 hb]\n  rw [\u2190 ha]\n  exact fun H => ne_of_gt h\u2081 (Nat.isUnit_iff.1 <| H _ \u27e8_, rfl\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Squarefree.lean", "context": {"open": ["Finset", "UniqueFactorizationMonoid", "NormNum"], "variables": ["{s : Finset \u2115} {m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a aa b n : \u2115\nha : a * a = aa\nhb : aa * b = n\nh\u2081 : 1 < a\n\u22a2 \u00acSquarefree n"}, {"line": "rw [\u2190 hb]", "tactic_state": "a aa b n : \u2115\nha : a * a = aa\nhb : aa * b = n\nh\u2081 : 1 < a\n\u22a2 \u00acSquarefree (aa * b)"}, {"line": "rw [\u2190 ha]", "tactic_state": "a aa b n : \u2115\nha : a * a = aa\nhb : aa * b = n\nh\u2081 : 1 < a\n\u22a2 \u00acSquarefree (a * a * b)"}, {"line": "exact fun H => ne_of_gt h\u2081 (Nat.isUnit_iff.1 <| H _ \u27e8_, rfl\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totient_even {n : \u2115} (hn : 2 < n) : Even n.totient := by\n  haveI : Fact (1 < n) := \u27e8one_lt_two.trans hn\u27e9\n  haveI : NeZero n := NeZero.of_gt hn\n  suffices 2 = orderOf (-1 : (ZMod n)\u02e3) by\n    rw [\u2190 ZMod.card_units_eq_totient]\n    rw [even_iff_two_dvd]\n    rw [this]\n    exact orderOf_dvd_card\n  rw [\u2190 orderOf_units]\n  rw [Units.coe_neg_one]\n  rw [orderOf_neg_one]\n  rw [ringChar.eq (ZMod n) n]\n  rw [if_neg hn.ne']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Totient.lean", "context": {"open": ["Finset", "ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : 2 < n\n\u22a2 Even n.totient"}, {"line": "haveI : Fact (1 < n) := \u27e8one_lt_two.trans hn\u27e9", "tactic_state": "n : \u2115\nhn : 2 < n\nthis : Fact (1 < n)\n\u22a2 Even n.totient"}, {"line": "haveI : NeZero n := NeZero.of_gt hn", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 Even n.totient"}, {"line": "suffices 2 = orderOf (-1 : (ZMod n)\u02e3) by\n    rw [\u2190 ZMod.card_units_eq_totient]\n    rw [even_iff_two_dvd]\n    rw [this]\n    exact orderOf_dvd_card", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf (-1)"}, {"line": "rw [\u2190 orderOf_units]", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf \u2191(-1)"}, {"line": "rw [Units.coe_neg_one]", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf (-1)"}, {"line": "rw [orderOf_neg_one]", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = if ringChar (ZMod n) = 2 then 1 else 2"}, {"line": "rw [ringChar.eq (ZMod n) n]", "tactic_state": "n : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = if n = 2 then 1 else 2"}, {"line": "rw [if_neg hn.ne']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totient_prime_pow_succ {p : \u2115} (hp : p.Prime) (n : \u2115) : \u03c6 (p ^ (n + 1)) = p ^ n * (p - 1) :=\n  calc\n    \u03c6 (p ^ (n + 1)) = #{a \u2208 range (p ^ (n + 1)) | (p ^ (n + 1)).Coprime a} :=\n      totient_eq_card_coprime _\n    _ = #(range (p ^ (n + 1)) \\ (range (p ^ n)).image (\u00b7 * p)) :=\n      congr_arg card\n        (by\n          rw [sdiff_eq_filter]\n          apply filter_congr\n          simp only [mem_range]\n          simp only [mem_filter]\n          simp only [coprime_pow_left_iff n.succ_pos]\n          simp only [mem_image]\n          simp only [not_exists]\n          simp only [hp.coprime_iff_not_dvd]\n          intro a ha\n          constructor\n          \u00b7 intro hap b h; rcases h with \u27e8_, rfl\u27e9\n            exact hap (dvd_mul_left _ _)\n          \u00b7 rintro h \u27e8b, rfl\u27e9\n            rw [pow_succ'] at ha\n            exact h b \u27e8lt_of_mul_lt_mul_left ha (zero_le _), mul_comm _ _\u27e9)\n    _ = _ := by\n      have h1 : Function.Injective (\u00b7 * p) := mul_left_injective\u2080 hp.ne_zero\n      have h2 : (range (p ^ n)).image (\u00b7 * p) \u2286 range (p ^ (n + 1)) := fun a => by\n        simp only [mem_image]\n        simp only [mem_range]\n        simp only [exists_imp]\n        rintro b \u27e8h, rfl\u27e9\n        rw [Nat.pow_succ]\n        exact (mul_lt_mul_right hp.pos).2 h\n      rw [card_sdiff h2]\n      rw [Finset.card_image_of_injective _ h1]\n      rw [card_range]\n      rw [card_range]\n      rw [\u2190         one_mul (p ^ n)]\n      rw [pow_succ']\n      rw [\u2190 tsub_mul]\n      rw [one_mul]\n      rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Totient.lean", "context": {"open": ["Finset", "ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\n\u22a2 (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))).card = p ^ n * (p - 1)"}, {"line": "have h1 : Function.Injective (\u00b7 * p) := mul_left_injective\u2080 hp.ne_zero", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\n\u22a2 (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))).card = p ^ n * (p - 1)"}, {"line": "have h2 : (range (p ^ n)).image (\u00b7 * p) \u2286 range (p ^ (n + 1)) := fun a => by\n        simp only [mem_image]\n        simp only [mem_range]\n        simp only [exists_imp]\n        rintro b \u27e8h, rfl\u27e9\n        rw [Nat.pow_succ]\n        exact (mul_lt_mul_right hp.pos).2 h", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))).card = p ^ n * (p - 1)"}, {"line": "rw [card_sdiff h2]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 (range (p ^ (n + 1))).card - (image (fun x => x * p) (range (p ^ n))).card = p ^ n * (p - 1)"}, {"line": "rw [Finset.card_image_of_injective _ h1]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 (range (p ^ (n + 1))).card - (range (p ^ n)).card = p ^ n * (p - 1)"}, {"line": "rw [card_range]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 p ^ (n + 1) - (range (p ^ n)).card = p ^ n * (p - 1)"}, {"line": "rw [card_range]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 p ^ (n + 1) - p ^ n = p ^ n * (p - 1)"}, {"line": "rw [\u2190         one_mul (p ^ n)]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 p ^ (n + 1) - 1 * p ^ n = 1 * p ^ n * (p - 1)"}, {"line": "rw [pow_succ']", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 p * p ^ n - 1 * p ^ n = 1 * p ^ n * (p - 1)"}, {"line": "rw [\u2190 tsub_mul]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 (p - 1) * p ^ n = 1 * p ^ n * (p - 1)"}, {"line": "rw [one_mul]", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 (p - 1) * p ^ n = p ^ n * (p - 1)"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totient_prime_pow {p : \u2115} (hp : p.Prime) {n : \u2115} (hn : 0 < n) :\n    \u03c6 (p ^ n) = p ^ (n - 1) * (p - 1) := by\n  rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with \u27e8m, rfl\u27e9\n  exact totient_prime_pow_succ hp _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Totient.lean", "context": {"open": ["Finset", "ZMod"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nhn : 0 < n\n\u22a2 sorry = p ^ (n - 1) * (p - 1)"}, {"line": "rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with \u27e8m, rfl\u27e9", "tactic_state": "case zero\nx\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nhn : 0 < n\n\u22a2 0 = p ^ (n - 1) * (p - 1)\n---\ncase succ\nx\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nhn : 0 < n\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = p ^ (n - 1) * (p - 1)"}, {"line": "exact totient_prime_pow_succ hp _", "tactic_state": "case succ\nx\u271d : Sort u_1\n\u03c6 : x\u271d\np : \u2115\nhp : Nat.Prime p\nn : \u2115\nhn : 0 < n\nn\u271d : \u2115\n\u22a2 n\u271d + 1 = p ^ (n - 1) * (p - 1)"}]}
{"declaration": "theorem add_eq_zero_iff {n m : WithBot \u2115} : n + m = 0 \u2194 n = 0 \u2227 m = 0 := by\n  cases n\n  \u00b7 simp [WithBot.bot_add]\n  cases m\n  \u00b7 simp [WithBot.add_bot]\n  simp [\u2190 WithBot.coe_add, add_eq_zero_iff_of_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : WithBot \u2115\n\u22a2 n + m = 0 \u2194 n = 0 \u2227 m = 0"}, {"line": "cases n", "tactic_state": "case bot\nm : WithBot \u2115\n\u22a2 \u22a5 + m = 0 \u2194 \u22a5 = 0 \u2227 m = 0\n---\ncase coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 0 \u2194 \u2191a\u271d = 0 \u2227 m = 0"}, {"line": "\u00b7 simp [WithBot.bot_add]", "tactic_state": "case coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 0 \u2194 \u2191a\u271d = 0 \u2227 m = 0"}, {"line": "cases m", "tactic_state": "case coe.bot\na\u271d : \u2115\n\u22a2 \u2191a\u271d + \u22a5 = 0 \u2194 \u2191a\u271d = 0 \u2227 \u22a5 = 0\n---\ncase coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 0 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 0"}, {"line": "\u00b7 simp [WithBot.add_bot]", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 0 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 0"}, {"line": "simp [\u2190 WithBot.coe_add, add_eq_zero_iff_of_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_one_iff {n m : WithBot \u2115} : n + m = 1 \u2194 n = 0 \u2227 m = 1 \u2228 n = 1 \u2227 m = 0 := by\n  cases n\n  \u00b7 simp only [WithBot.bot_add, WithBot.bot_ne_one, WithBot.bot_ne_zero, false_and, or_self]\n  cases m\n  \u00b7 simp [WithBot.add_bot]\n  simp [\u2190 WithBot.coe_add, Nat.add_eq_one_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : WithBot \u2115\n\u22a2 n + m = 1 \u2194 n = 0 \u2227 m = 1 \u2228 n = 1 \u2227 m = 0"}, {"line": "cases n", "tactic_state": "case bot\nm : WithBot \u2115\n\u22a2 \u22a5 + m = 1 \u2194 \u22a5 = 0 \u2227 m = 1 \u2228 \u22a5 = 1 \u2227 m = 0\n---\ncase coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 1 \u2194 \u2191a\u271d = 0 \u2227 m = 1 \u2228 \u2191a\u271d = 1 \u2227 m = 0"}, {"line": "\u00b7 simp only [WithBot.bot_add, WithBot.bot_ne_one, WithBot.bot_ne_zero, false_and, or_self]", "tactic_state": "case coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 1 \u2194 \u2191a\u271d = 0 \u2227 m = 1 \u2228 \u2191a\u271d = 1 \u2227 m = 0"}, {"line": "cases m", "tactic_state": "case coe.bot\na\u271d : \u2115\n\u22a2 \u2191a\u271d + \u22a5 = 1 \u2194 \u2191a\u271d = 0 \u2227 \u22a5 = 1 \u2228 \u2191a\u271d = 1 \u2227 \u22a5 = 0\n---\ncase coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 1 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 0"}, {"line": "\u00b7 simp [WithBot.add_bot]", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 1 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 0"}, {"line": "simp [\u2190 WithBot.coe_add, Nat.add_eq_one_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_two_iff {n m : WithBot \u2115} :\n    n + m = 2 \u2194 n = 0 \u2227 m = 2 \u2228 n = 1 \u2227 m = 1 \u2228 n = 2 \u2227 m = 0 := by\n  cases n\n  \u00b7 simp [WithBot.bot_add]\n  cases m\n  \u00b7 simp [WithBot.add_bot]\n  simp [\u2190 WithBot.coe_add, Nat.add_eq_two_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : WithBot \u2115\n\u22a2 n + m = 2 \u2194 n = 0 \u2227 m = 2 \u2228 n = 1 \u2227 m = 1 \u2228 n = 2 \u2227 m = 0"}, {"line": "cases n", "tactic_state": "case bot\nm : WithBot \u2115\n\u22a2 \u22a5 + m = 2 \u2194 \u22a5 = 0 \u2227 m = 2 \u2228 \u22a5 = 1 \u2227 m = 1 \u2228 \u22a5 = 2 \u2227 m = 0\n---\ncase coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 2 \u2194 \u2191a\u271d = 0 \u2227 m = 2 \u2228 \u2191a\u271d = 1 \u2227 m = 1 \u2228 \u2191a\u271d = 2 \u2227 m = 0"}, {"line": "\u00b7 simp [WithBot.bot_add]", "tactic_state": "case coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 2 \u2194 \u2191a\u271d = 0 \u2227 m = 2 \u2228 \u2191a\u271d = 1 \u2227 m = 1 \u2228 \u2191a\u271d = 2 \u2227 m = 0"}, {"line": "cases m", "tactic_state": "case coe.bot\na\u271d : \u2115\n\u22a2 \u2191a\u271d + \u22a5 = 2 \u2194 \u2191a\u271d = 0 \u2227 \u22a5 = 2 \u2228 \u2191a\u271d = 1 \u2227 \u22a5 = 1 \u2228 \u2191a\u271d = 2 \u2227 \u22a5 = 0\n---\ncase coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 2 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 2 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 2 \u2227 \u2191a\u271d = 0"}, {"line": "\u00b7 simp [WithBot.add_bot]", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 2 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 2 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 2 \u2227 \u2191a\u271d = 0"}, {"line": "simp [\u2190 WithBot.coe_add, Nat.add_eq_two_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_eq_three_iff {n m : WithBot \u2115} :\n    n + m = 3 \u2194 n = 0 \u2227 m = 3 \u2228 n = 1 \u2227 m = 2 \u2228 n = 2 \u2227 m = 1 \u2228 n = 3 \u2227 m = 0 := by\n  cases n\n  \u00b7 simp [WithBot.bot_add]\n  cases m\n  \u00b7 simp [WithBot.add_bot]\n  simp [\u2190 WithBot.coe_add, Nat.add_eq_three_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : WithBot \u2115\n\u22a2 n + m = 3 \u2194 n = 0 \u2227 m = 3 \u2228 n = 1 \u2227 m = 2 \u2228 n = 2 \u2227 m = 1 \u2228 n = 3 \u2227 m = 0"}, {"line": "cases n", "tactic_state": "case bot\nm : WithBot \u2115\n\u22a2 \u22a5 + m = 3 \u2194 \u22a5 = 0 \u2227 m = 3 \u2228 \u22a5 = 1 \u2227 m = 2 \u2228 \u22a5 = 2 \u2227 m = 1 \u2228 \u22a5 = 3 \u2227 m = 0\n---\ncase coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 3 \u2194 \u2191a\u271d = 0 \u2227 m = 3 \u2228 \u2191a\u271d = 1 \u2227 m = 2 \u2228 \u2191a\u271d = 2 \u2227 m = 1 \u2228 \u2191a\u271d = 3 \u2227 m = 0"}, {"line": "\u00b7 simp [WithBot.bot_add]", "tactic_state": "case coe\nm : WithBot \u2115\na\u271d : \u2115\n\u22a2 \u2191a\u271d + m = 3 \u2194 \u2191a\u271d = 0 \u2227 m = 3 \u2228 \u2191a\u271d = 1 \u2227 m = 2 \u2228 \u2191a\u271d = 2 \u2227 m = 1 \u2228 \u2191a\u271d = 3 \u2227 m = 0"}, {"line": "cases m", "tactic_state": "case coe.bot\na\u271d : \u2115\n\u22a2 \u2191a\u271d + \u22a5 = 3 \u2194 \u2191a\u271d = 0 \u2227 \u22a5 = 3 \u2228 \u2191a\u271d = 1 \u2227 \u22a5 = 2 \u2228 \u2191a\u271d = 2 \u2227 \u22a5 = 1 \u2228 \u2191a\u271d = 3 \u2227 \u22a5 = 0\n---\ncase coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 3 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 3 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 2 \u2228 \u2191a\u271d\u00b9 = 2 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 3 \u2227 \u2191a\u271d = 0"}, {"line": "\u00b7 simp [WithBot.add_bot]", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u2115\n\u22a2 \u2191a\u271d\u00b9 + \u2191a\u271d = 3 \u2194 \u2191a\u271d\u00b9 = 0 \u2227 \u2191a\u271d = 3 \u2228 \u2191a\u271d\u00b9 = 1 \u2227 \u2191a\u271d = 2 \u2228 \u2191a\u271d\u00b9 = 2 \u2227 \u2191a\u271d = 1 \u2228 \u2191a\u271d\u00b9 = 3 \u2227 \u2191a\u271d = 0"}, {"line": "simp [\u2190 WithBot.coe_add, Nat.add_eq_three_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_iff_zero_lt {x : WithBot \u2115} : 1 \u2264 x \u2194 0 < x := by\n  refine \u27e8zero_lt_one.trans_le, fun h => ?_\u27e9\n  cases x\n  \u00b7 exact (not_lt_bot h).elim\n  \u00b7 rwa [\u2190 WithBot.coe_zero, WithBot.coe_lt_coe, \u2190 Nat.add_one_le_iff, zero_add,\n      \u2190 WithBot.coe_le_coe, WithBot.coe_one] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : WithBot \u2115\n\u22a2 1 \u2264 x \u2194 0 < x"}, {"line": "refine \u27e8zero_lt_one.trans_le, fun h => ?_\u27e9", "tactic_state": "x : WithBot \u2115\nh : 0 < x\n\u22a2 1 \u2264 x"}, {"line": "cases x", "tactic_state": "case bot\nh : 0 < \u22a5\n\u22a2 1 \u2264 \u22a5\n---\ncase coe\na\u271d : \u2115\nh : 0 < \u2191a\u271d\n\u22a2 1 \u2264 \u2191a\u271d"}, {"line": "\u00b7 exact (not_lt_bot h).elim", "tactic_state": "case coe\na\u271d : \u2115\nh : 0 < \u2191a\u271d\n\u22a2 1 \u2264 \u2191a\u271d"}, {"line": "\u00b7 rwa [\u2190 WithBot.coe_zero, WithBot.coe_lt_coe, \u2190 Nat.add_one_le_iff, zero_add,\n      \u2190 WithBot.coe_le_coe, WithBot.coe_one] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one_le_of_lt {n m : WithBot \u2115} (h : n < m) : n + 1 \u2264 m := by\n  cases n\n  \u00b7 simp only [WithBot.bot_add, bot_le]\n  cases m\n  \u00b7 exact (not_lt_bot h).elim\n  \u00b7 rwa [WithBot.coe_lt_coe, \u2190 Nat.add_one_le_iff, \u2190 WithBot.coe_le_coe, WithBot.coe_add,\n      WithBot.coe_one] at h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/WithBot.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : WithBot \u2115\nh : n < m\n\u22a2 n + 1 \u2264 m"}, {"line": "cases n", "tactic_state": "case bot\nm : WithBot \u2115\nh : \u22a5 < m\n\u22a2 \u22a5 + 1 \u2264 m\n---\ncase coe\nm : WithBot \u2115\na\u271d : \u2115\nh : \u2191a\u271d < m\n\u22a2 \u2191a\u271d + 1 \u2264 m"}, {"line": "\u00b7 simp only [WithBot.bot_add, bot_le]", "tactic_state": "case coe\nm : WithBot \u2115\na\u271d : \u2115\nh : \u2191a\u271d < m\n\u22a2 \u2191a\u271d + 1 \u2264 m"}, {"line": "cases m", "tactic_state": "case coe.bot\na\u271d : \u2115\nh : \u2191a\u271d < \u22a5\n\u22a2 \u2191a\u271d + 1 \u2264 \u22a5\n---\ncase coe.coe\na\u271d\u00b9 a\u271d : \u2115\nh : \u2191a\u271d\u00b9 < \u2191a\u271d\n\u22a2 \u2191a\u271d\u00b9 + 1 \u2264 \u2191a\u271d"}, {"line": "\u00b7 exact (not_lt_bot h).elim", "tactic_state": "case coe.coe\na\u271d\u00b9 a\u271d : \u2115\nh : \u2191a\u271d\u00b9 < \u2191a\u271d\n\u22a2 \u2191a\u271d\u00b9 + 1 \u2264 \u2191a\u271d"}, {"line": "\u00b7 rwa [WithBot.coe_lt_coe, \u2190 Nat.add_one_le_iff, \u2190 WithBot.coe_le_coe, WithBot.coe_add,\n      WithBot.coe_one] at h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fst_natCast (n : \u2115) : (n : \u03b1 \u00d7 \u03b2).fst = n := by induction n <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[AddMonoidWithOne \u03b1] [AddMonoidWithOne \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : AddMonoidWithOne \u03b2\nn : \u2115\n\u22a2 (\u2191n).1 = \u2191n"}, {"line": "induction n <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem snd_natCast (n : \u2115) : (n : \u03b1 \u00d7 \u03b2).snd = n := by induction n <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Prod.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*}", "[AddMonoidWithOne \u03b1] [AddMonoidWithOne \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : AddMonoidWithOne \u03b1\ninst\u271d : AddMonoidWithOne \u03b2\nn : \u2115\n\u22a2 (\u2191n).2 = \u2191n"}, {"line": "induction n <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_ite (P : Prop) [Decidable P] (m n : \u2115) :\n    ((ite P m n : \u2115) : R) = ite P (m : R) (n : R) := by\n  split_ifs <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Defs.lean", "context": {"open": [], "variables": ["{R : Type*}", "{n : \u2115} [n.AtLeastTwo]", "[AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : AddMonoidWithOne R\nP : Prop\ninst\u271d : Decidable P\nm n : \u2115\n\u22a2 \u2191(if P then m else n) = if P then \u2191m else \u2191n"}, {"line": "split_ifs <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_add_one_eq_two [AddMonoidWithOne R] : 1 + 1 = (2 : R) := by\n  rw [\u2190 Nat.cast_one]\n  rw [\u2190 Nat.cast_add]\n  apply congrArg\n  decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Defs.lean", "context": {"open": [], "variables": ["{R : Type*}", "{n : \u2115} [n.AtLeastTwo]", "[AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u21911 + \u21911 = 2"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1) = 2"}, {"line": "apply congrArg", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 = 2"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_add_one_eq_three [AddMonoidWithOne R] : 2 + 1 = (3 : R) := by\n  rw [\u2190 one_add_one_eq_two]\n  rw [\u2190 Nat.cast_one]\n  rw [\u2190 Nat.cast_add]\n  rw [\u2190 Nat.cast_add]\n  apply congrArg\n  decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Defs.lean", "context": {"open": [], "variables": ["{R : Type*}", "{n : \u2115} [n.AtLeastTwo]", "[AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 2 + 1 = 3"}, {"line": "rw [\u2190 one_add_one_eq_two]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 = 3"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u21911 + \u21911 + \u21911 = 3"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1) + \u21911 = 3"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1 + 1) = 3"}, {"line": "apply congrArg", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 = 3"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "theorem three_add_one_eq_four [AddMonoidWithOne R] : 3 + 1 = (4 : R) := by\n  rw [\u2190 two_add_one_eq_three]\n  rw [\u2190 one_add_one_eq_two]\n  rw [\u2190 Nat.cast_one]\n  rw [\u2190 Nat.cast_add]\n  rw [\u2190 Nat.cast_add]\n  rw [\u2190 Nat.cast_add]\n  apply congrArg\n  decide\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Defs.lean", "context": {"open": [], "variables": ["{R : Type*}", "{n : \u2115} [n.AtLeastTwo]", "[AddMonoidWithOne R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 3 + 1 = 4"}, {"line": "rw [\u2190 two_add_one_eq_three]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 2 + 1 + 1 = 4"}, {"line": "rw [\u2190 one_add_one_eq_two]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 + 1 = 4"}, {"line": "rw [\u2190 Nat.cast_one]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u21911 + \u21911 + \u21911 + \u21911 = 4"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1) + \u21911 + \u21911 = 4"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1 + 1) + \u21911 = 4"}, {"line": "rw [\u2190 Nat.cast_add]", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 \u2191(1 + 1 + 1 + 1) = 4"}, {"line": "apply congrArg", "tactic_state": "case h\nR : Type u_1\ninst\u271d\u00b9 inst\u271d : AddMonoidWithOne R\n\u22a2 1 + 1 + 1 + 1 = 4"}, {"line": "decide", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_div_charZero (hnm : n \u2223 m) : (\u2191(m / n) : K) = m / n := by\n  obtain rfl | hn := eq_or_ne n 0 <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Field.lean", "context": {"open": [], "variables": ["{K : Type*} [DivisionSemiring K] {d m n : \u2115}", "[CharZero K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d\u00b9 : DivisionSemiring K\nm n : \u2115\ninst\u271d : CharZero K\nhnm : n \u2223 m\n\u22a2 \u2191(m / n) = \u2191m / \u2191n"}, {"line": "obtain rfl | hn := eq_or_ne n 0 <;> simp [*]", "tactic_state": "case inl\nK : Type u_1\ninst\u271d\u00b9 : DivisionSemiring K\nm : \u2115\ninst\u271d : CharZero K\nhnm : 0 \u2223 m\n\u22a2 0 = \u2191m / 0"}]}
{"declaration": "theorem cast_pos' {n : \u2115} : (0 : \u03b1) < n \u2194 0 < n := by cases n <;> simp [cast_add_one_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Cast/Order/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[AddMonoidWithOne \u03b1] [PartialOrder \u03b1]", "[AddLeftMono \u03b1] [ZeroLEOneClass \u03b1]", "[NeZero (1 : \u03b1)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddLeftMono \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : NeZero 1\nn : \u2115\n\u22a2 0 < \u2191n \u2194 0 < n"}, {"line": "cases n <;> simp [cast_add_one_pos]", "tactic_state": "case succ\n\u03b1 : Type u_1\ninst\u271d\u2074 : AddMonoidWithOne \u03b1\ninst\u271d\u00b3 : PartialOrder \u03b1\ninst\u271d\u00b2 : AddLeftMono \u03b1\ninst\u271d\u00b9 : ZeroLEOneClass \u03b1\ninst\u271d : NeZero 1\nn\u271d : \u2115\n\u22a2 0 < \u2191n\u271d + 1"}]}
{"declaration": "lemma choose_le_descFactorial (n k : \u2115) : n.choose k \u2264 n.descFactorial k := by\n  rw [choose_eq_descFactorial_div_factorial]\n  exact Nat.div_le_self _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Bounds.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} [Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 n.choose k \u2264 n.descFactorial k"}, {"line": "rw [choose_eq_descFactorial_div_factorial]", "tactic_state": "n k : \u2115\n\u22a2 n.descFactorial k / k.factorial \u2264 n.descFactorial k"}, {"line": "exact Nat.div_le_self _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_succ_le_two_pow (n k : \u2115) : (n + 1).choose k \u2264 2 ^ n := by\n  by_cases lt : n + 1 < k\n  \u00b7 simp [choose_eq_zero_of_lt lt]\n  \u00b7 cases n with\n    | zero => cases k <;> simp_all\n    | succ n =>\n      rcases k with - | k\n      \u00b7 rw [choose_zero_right]\n        exact Nat.one_le_two_pow\n      \u00b7 rw [choose_succ_succ', two_pow_succ]\n        exact Nat.add_le_add (choose_succ_le_two_pow n k) (choose_succ_le_two_pow n (k + 1))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Bounds.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} [Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).choose k \u2264 2 ^ n"}, {"line": "by_cases lt : n + 1 < k", "tactic_state": "case pos\nn k : \u2115\nlt : n + 1 < k\n\u22a2 (n + 1).choose k \u2264 2 ^ n\n---\ncase neg\nn k : \u2115\nlt : \u00acn + 1 < k\n\u22a2 (n + 1).choose k \u2264 2 ^ n"}, {"line": "\u00b7 simp [choose_eq_zero_of_lt lt]", "tactic_state": "case neg\nn k : \u2115\nlt : \u00acn + 1 < k\n\u22a2 (n + 1).choose k \u2264 2 ^ n"}, {"line": "\u00b7 cases n with\n    | zero => cases k <;> simp_all\n    | succ n =>\n      rcases k with - | k\n      \u00b7 rw [choose_zero_right]\n        exact Nat.one_le_two_pow\n      \u00b7 rw [choose_succ_succ', two_pow_succ]\n        exact Nat.add_le_add (choose_succ_le_two_pow n k) (choose_succ_le_two_pow n (k + 1))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_le_two_pow (n k : \u2115) (p : 0 < n) : n.choose k < 2 ^ n := by\n  refine lt_of_le_of_lt ?_ (Nat.two_pow_pred_lt_two_pow p)\n  rw [\u2190 Nat.sub_add_cancel p]\n  exact choose_succ_le_two_pow (n - 1) k\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Bounds.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 : Type*} [Semifield \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\np : 0 < n\n\u22a2 n.choose k < 2 ^ n"}, {"line": "refine lt_of_le_of_lt ?_ (Nat.two_pow_pred_lt_two_pow p)", "tactic_state": "n k : \u2115\np : 0 < n\n\u22a2 n.choose k \u2264 2 ^ (n - 1)"}, {"line": "rw [\u2190 Nat.sub_add_cancel p]", "tactic_state": "n k : \u2115\np : 0 < n\n\u22a2 (n - succ 0 + succ 0).choose k \u2264 2 ^ (n - succ 0 + succ 0 - 1)"}, {"line": "exact choose_succ_le_two_pow (n - 1) k", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_le_centralBinom (r n : \u2115) : choose (2 * n) r \u2264 centralBinom n :=\n  calc\n    (2 * n).choose r \u2264 (2 * n).choose (2 * n / 2) := choose_le_middle r (2 * n)\n    _ = (2 * n).choose n := by rw [Nat.mul_div_cancel_left n zero_lt_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Central.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nchoose : x\u271d\u00b9\nx\u271d : Sort u_2\ncentralBinom : x\u271d\nr n : \u2115\n\u22a2 (2 * n).choose (2 * n / 2) = (2 * n).choose n"}, {"line": "rw [Nat.mul_div_cancel_left n zero_lt_two]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem four_pow_lt_mul_centralBinom (n : \u2115) (n_big : 4 \u2264 n) : 4 ^ n < n * centralBinom n := by\n  induction' n using Nat.strong_induction_on with n IH\n  rcases lt_trichotomy n 4 with (hn | rfl | hn)\n  \u00b7 clear IH; exact False.elim ((not_lt.2 n_big) hn)\n  \u00b7 norm_num [centralBinom, choose]\n  obtain \u27e8n, rfl\u27e9 : \u2203 m, n = m + 1 := Nat.exists_eq_succ_of_ne_zero (Nat.ne_zero_of_lt hn)\n  calc\n    4 ^ (n + 1) < 4 * (n * centralBinom n) := lt_of_eq_of_lt pow_succ' <|\n      (mul_lt_mul_left <| zero_lt_four' \u2115).mpr (IH n n.lt_succ_self (Nat.le_of_lt_succ hn))\n    _ \u2264 2 * (2 * n + 1) * centralBinom n := by rw [\u2190 mul_assoc]; linarith\n    _ = (n + 1) * centralBinom (n + 1) := (succ_mul_centralBinom_succ n).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Central.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nn_big : 4 \u2264 n\n\u22a2 4 ^ n < n * sorry"}, {"line": "induction' n using Nat.strong_induction_on with n IH", "tactic_state": "case h\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n\n\u22a2 4 ^ n < n * sorry"}, {"line": "rcases lt_trichotomy n 4 with (hn | rfl | hn)", "tactic_state": "case h.inl\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n\nhn : n < 4\n\u22a2 4 ^ n < n * sorry\n---\ncase h.inr.inl\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nIH : \u2200 m < 4, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 4\n\u22a2 4 ^ 4 < 4 * sorry\n---\ncase h.inr.inr\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n\nhn : 4 < n\n\u22a2 4 ^ n < n * sorry"}, {"line": "\u00b7 clear IH; exact False.elim ((not_lt.2 n_big) hn)", "tactic_state": "case h.inr.inl\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nIH : \u2200 m < 4, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 4\n\u22a2 4 ^ 4 < 4 * sorry\n---\ncase h.inr.inr\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n\nhn : 4 < n\n\u22a2 4 ^ n < n * sorry"}, {"line": "\u00b7 norm_num [centralBinom, choose]", "tactic_state": "case h.inr.inr\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n\nhn : 4 < n\n\u22a2 4 ^ n < n * sorry"}, {"line": "obtain \u27e8n, rfl\u27e9 : \u2203 m, n = m + 1 := Nat.exists_eq_succ_of_ne_zero (Nat.ne_zero_of_lt hn)", "tactic_state": "case h.inr.inr.intro\nx\u271d : Sort u_1\ncentralBinom : x\u271d\nn : \u2115\nIH : \u2200 m < n + 1, 4 \u2264 m \u2192 4 ^ m < m * sorry\nn_big : 4 \u2264 n + 1\nhn : 4 < n + 1\n\u22a2 4 ^ (n + 1) < (n + 1) * sorry"}, {"line": "calc\n    4 ^ (n + 1) < 4 * (n * centralBinom n) := lt_of_eq_of_lt pow_succ' <|\n      (mul_lt_mul_left <| zero_lt_four' \u2115).mpr (IH n n.lt_succ_self (Nat.le_of_lt_succ hn))\n    _ \u2264 2 * (2 * n + 1) * centralBinom n := by rw [\u2190 mul_assoc]; linarith\n    _ = (n + 1) * centralBinom (n + 1) := (succ_mul_centralBinom_succ n).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.add_choose_eq (m n k : \u2115) :\n    (m + n).choose k = \u2211 ij \u2208 antidiagonal k, m.choose ij.1 * n.choose ij.2 := by\n  calc\n    (m + n).choose k = ((X + 1) ^ (m + n)).coeff k := by rw [coeff_X_add_one_pow, Nat.cast_id]\n    _ = ((X + 1) ^ m * (X + 1) ^ n).coeff k := by rw [pow_add]\n    _ = \u2211 ij \u2208 antidiagonal k, m.choose ij.1 * n.choose ij.2 := by\n      rw [coeff_mul]\n      rw [Finset.sum_congr rfl]\n      simp only [coeff_X_add_one_pow]\n      simp only [Nat.cast_id]\n      simp only [eq_self_iff_true]\n      simp only [imp_true_iff]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Vandermonde.lean", "context": {"open": ["Polynomial Finset Finset.Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\n\u22a2 (m + n).choose k = \u2211 ij \u2208 antidiagonal k, m.choose ij.1 * n.choose ij.2"}, {"line": "calc\n    (m + n).choose k = ((X + 1) ^ (m + n)).coeff k := by rw [coeff_X_add_one_pow, Nat.cast_id]\n    _ = ((X + 1) ^ m * (X + 1) ^ n).coeff k := by rw [pow_add]\n    _ = \u2211 ij \u2208 antidiagonal k, m.choose ij.1 * n.choose ij.2 := by\n      rw [coeff_mul]\n      rw [Finset.sum_congr rfl]\n      simp only [coeff_X_add_one_pow]\n      simp only [Nat.cast_id]\n      simp only [eq_self_iff_true]\n      simp only [imp_true_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_zero_right (n : \u2115) : choose n 0 = 1 := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.choose 0 = 1"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_succ_left (n k : \u2115) (hk : 0 < k) :\n    choose (n + 1) k = choose n (k - 1) + choose n k := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l, k = l + 1 := Nat.exists_eq_add_of_le' hk\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhk : 0 < k\n\u22a2 (n + 1).choose k = n.choose (k - 1) + n.choose k"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l, k = l + 1 := Nat.exists_eq_add_of_le' hk", "tactic_state": "case intro\nn l : \u2115\nhk : 0 < l + 1\n\u22a2 (n + 1).choose (l + 1) = n.choose (l + 1 - 1) + n.choose (l + 1)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_succ_right (n k : \u2115) (hn : 0 < n) :\n    choose n (k + 1) = choose (n - 1) k + choose (n - 1) (k + 1) := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l, n = l + 1 := Nat.exists_eq_add_of_le' hn\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhn : 0 < n\n\u22a2 n.choose (k + 1) = (n - 1).choose k + (n - 1).choose (k + 1)"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l, n = l + 1 := Nat.exists_eq_add_of_le' hn", "tactic_state": "case intro\nk l : \u2115\nhn : 0 < l + 1\n\u22a2 (l + 1).choose (k + 1) = (l + 1 - 1).choose k + (l + 1 - 1).choose (k + 1)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_eq_choose_pred_add {n k : \u2115} (hn : 0 < n) (hk : 0 < k) :\n    choose n k = choose (n - 1) (k - 1) + choose (n - 1) k := by\n  obtain \u27e8l, rfl\u27e9 : \u2203 l, k = l + 1 := Nat.exists_eq_add_of_le' hk\n  rw [choose_succ_right _ _ hn]\n  rw [Nat.add_one_sub_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhn : 0 < n\nhk : 0 < k\n\u22a2 n.choose k = (n - 1).choose (k - 1) + (n - 1).choose k"}, {"line": "obtain \u27e8l, rfl\u27e9 : \u2203 l, k = l + 1 := Nat.exists_eq_add_of_le' hk", "tactic_state": "case intro\nn : \u2115\nhn : 0 < n\nl : \u2115\nhk : 0 < l + 1\n\u22a2 n.choose (l + 1) = (n - 1).choose (l + 1 - 1) + (n - 1).choose (l + 1)"}, {"line": "rw [choose_succ_right _ _ hn]", "tactic_state": "case intro\nn : \u2115\nhn : 0 < n\nl : \u2115\nhk : 0 < l + 1\n\u22a2 (n - 1).choose l + (n - 1).choose (l + 1) = (n - 1).choose (l + 1 - 1) + (n - 1).choose (l + 1)"}, {"line": "rw [Nat.add_one_sub_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_self (n : \u2115) : choose n n = 1 := by\n  induction n <;> simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.choose n = 1"}, {"line": "induction n <;> simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma choose_one_right (n : \u2115) : choose n 1 = n := by induction n <;> simp [*, choose, Nat.add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.choose 1 = n"}, {"line": "induction n <;> simp [*, choose, Nat.add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_eq_factorial_div_factorial {n k : \u2115} (hk : k \u2264 n) :\n    choose n k = n ! / (k ! * (n - k)!) := by\n  rw [\u2190 choose_mul_factorial_mul_factorial hk]\n  rw [Nat.mul_assoc]\n  exact (mul_div_left _ (Nat.mul_pos (factorial_pos _) (factorial_pos _))).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.choose k = n.factorial / (k.factorial * (n - k).factorial)"}, {"line": "rw [\u2190 choose_mul_factorial_mul_factorial hk]", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.choose k = n.choose k * k.factorial * (n - k).factorial / (k.factorial * (n - k).factorial)"}, {"line": "rw [Nat.mul_assoc]", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.choose k = n.choose k * (k.factorial * (n - k).factorial) / (k.factorial * (n - k).factorial)"}, {"line": "exact (mul_div_left _ (Nat.mul_pos (factorial_pos _) (factorial_pos _))).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_choose (i j : \u2115) : (i + j).choose j = (i + j)! / (i ! * j !) := by\n  rw [choose_eq_factorial_div_factorial (Nat.le_add_left j i)]\n  rw [Nat.add_sub_cancel_right]\n  rw [Nat.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j : \u2115\n\u22a2 (i + j).choose j = (i + j).factorial / (i.factorial * j.factorial)"}, {"line": "rw [choose_eq_factorial_div_factorial (Nat.le_add_left j i)]", "tactic_state": "i j : \u2115\n\u22a2 (i + j).factorial / (j.factorial * (i + j - j).factorial) = (i + j).factorial / (i.factorial * j.factorial)"}, {"line": "rw [Nat.add_sub_cancel_right]", "tactic_state": "i j : \u2115\n\u22a2 (i + j).factorial / (j.factorial * i.factorial) = (i + j).factorial / (i.factorial * j.factorial)"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_choose_mul_factorial_mul_factorial (i j : \u2115) :\n    (i + j).choose j * i ! * j ! = (i + j)! := by\n  rw [\u2190 choose_mul_factorial_mul_factorial (Nat.le_add_left _ _)]\n  rw [Nat.add_sub_cancel_right]\n  rw [Nat.mul_right_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "i j : \u2115\n\u22a2 (i + j).choose j * i.factorial * j.factorial = (i + j).factorial"}, {"line": "rw [\u2190 choose_mul_factorial_mul_factorial (Nat.le_add_left _ _)]", "tactic_state": "i j : \u2115\n\u22a2 (i + j).choose j * i.factorial * j.factorial = (i + j).choose j * j.factorial * (i + j - j).factorial"}, {"line": "rw [Nat.add_sub_cancel_right]", "tactic_state": "i j : \u2115\n\u22a2 (i + j).choose j * i.factorial * j.factorial = (i + j).choose j * j.factorial * i.factorial"}, {"line": "rw [Nat.mul_right_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_symm {n k : \u2115} (hk : k \u2264 n) : choose n (n - k) = choose n k := by\n  rw [choose_eq_factorial_div_factorial hk]\n  rw [choose_eq_factorial_div_factorial (Nat.sub_le _ _)]\n  rw [Nat.sub_sub_self hk]\n  rw [Nat.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.choose (n - k) = n.choose k"}, {"line": "rw [choose_eq_factorial_div_factorial hk]", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.choose (n - k) = n.factorial / (k.factorial * (n - k).factorial)"}, {"line": "rw [choose_eq_factorial_div_factorial (Nat.sub_le _ _)]", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.factorial / ((n - k).factorial * (n - (n - k)).factorial) = n.factorial / (k.factorial * (n - k).factorial)"}, {"line": "rw [Nat.sub_sub_self hk]", "tactic_state": "n k : \u2115\nhk : k \u2264 n\n\u22a2 n.factorial / ((n - k).factorial * k.factorial) = n.factorial / (k.factorial * (n - k).factorial)"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_symm_of_eq_add {n a b : \u2115} (h : n = a + b) : Nat.choose n a = Nat.choose n b := by\n  suffices choose n (n - b) = choose n b by\n    rw [h] at this; rwa [h]\n    rw [Nat.add_sub_cancel_right] at this; rwa [h]\n  exact choose_symm (h \u25b8 le_add_left _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n a b : \u2115\nh : n = a + b\n\u22a2 n.choose a = n.choose b"}, {"line": "suffices choose n (n - b) = choose n b by\n    rw [h] at this; rwa [h]\n    rw [Nat.add_sub_cancel_right] at this; rwa [h]", "tactic_state": "n a b : \u2115\nh : n = a + b\n\u22a2 n.choose (n - b) = n.choose b"}, {"line": "exact choose_symm (h \u25b8 le_add_left _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_symm_half (m : \u2115) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m := by\n  apply choose_symm_of_eq_add\n  rw [Nat.add_comm m 1]\n  rw [Nat.add_assoc 1 m m]\n  rw [Nat.add_comm (2 * m) 1]\n  rw [Nat.two_mul m]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m : \u2115\n\u22a2 (2 * m + 1).choose (m + 1) = (2 * m + 1).choose m"}, {"line": "apply choose_symm_of_eq_add", "tactic_state": "case h\nm : \u2115\n\u22a2 2 * m + 1 = m + 1 + m"}, {"line": "rw [Nat.add_comm m 1]", "tactic_state": "case h\nm : \u2115\n\u22a2 2 * m + 1 = 1 + m + m"}, {"line": "rw [Nat.add_assoc 1 m m]", "tactic_state": "case h\nm : \u2115\n\u22a2 2 * m + 1 = 1 + (m + m)"}, {"line": "rw [Nat.add_comm (2 * m) 1]", "tactic_state": "case h\nm : \u2115\n\u22a2 1 + 2 * m = 1 + (m + m)"}, {"line": "rw [Nat.two_mul m]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_succ_right_eq (n k : \u2115) : choose n (k + 1) * (k + 1) = choose n k * (n - k) := by\n  have e : (n + 1) * choose n k = choose n (k + 1) * (k + 1) + choose n k * (k + 1) := by\n    rw [\u2190 Nat.add_mul]\n    rw [Nat.add_comm (choose _ _)]\n    rw [\u2190 choose_succ_succ]\n    rw [succ_mul_choose_eq]\n  rw [\u2190 Nat.sub_eq_of_eq_add e]\n  rw [Nat.mul_comm]\n  rw [\u2190 Nat.mul_sub_left_distrib]\n  rw [Nat.add_sub_add_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 n.choose (k + 1) * (k + 1) = n.choose k * (n - k)"}, {"line": "have e : (n + 1) * choose n k = choose n (k + 1) * (k + 1) + choose n k * (k + 1) := by\n    rw [\u2190 Nat.add_mul]\n    rw [Nat.add_comm (choose _ _)]\n    rw [\u2190 choose_succ_succ]\n    rw [succ_mul_choose_eq]", "tactic_state": "n k : \u2115\ne : (n + 1) * n.choose k = n.choose (k + 1) * (k + 1) + n.choose k * (k + 1)\n\u22a2 n.choose (k + 1) * (k + 1) = n.choose k * (n - k)"}, {"line": "rw [\u2190 Nat.sub_eq_of_eq_add e]", "tactic_state": "n k : \u2115\ne : (n + 1) * n.choose k = n.choose (k + 1) * (k + 1) + n.choose k * (k + 1)\n\u22a2 (n + 1) * n.choose k - n.choose k * (k + 1) = n.choose k * (n - k)"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "n k : \u2115\ne : (n + 1) * n.choose k = n.choose (k + 1) * (k + 1) + n.choose k * (k + 1)\n\u22a2 n.choose k * (n + 1) - n.choose k * (k + 1) = n.choose k * (n - k)"}, {"line": "rw [\u2190 Nat.mul_sub_left_distrib]", "tactic_state": "n k : \u2115\ne : (n + 1) * n.choose k = n.choose (k + 1) * (k + 1) + n.choose k * (k + 1)\n\u22a2 n.choose k * (n + 1 - (k + 1)) = n.choose k * (n - k)"}, {"line": "rw [Nat.add_sub_add_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascFactorial_eq_factorial_mul_choose (n k : \u2115) :\n    (n + 1).ascFactorial k = k ! * (n + k).choose k := by\n  rw [Nat.mul_comm]\n  apply Nat.mul_right_cancel (n + k - k).factorial_pos\n  rw [choose_mul_factorial_mul_factorial <| Nat.le_add_left k n]\n  rw [Nat.add_sub_cancel_right]\n  rw [\u2190 factorial_mul_ascFactorial]\n  rw [Nat.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k = k.factorial * (n + k).choose k"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k = (n + k).choose k * k.factorial"}, {"line": "apply Nat.mul_right_cancel (n + k - k).factorial_pos", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k * (n + k - k).factorial = (n + k).choose k * k.factorial * (n + k - k).factorial"}, {"line": "rw [choose_mul_factorial_mul_factorial <| Nat.le_add_left k n]", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k * (n + k - k).factorial = (n + k).factorial"}, {"line": "rw [Nat.add_sub_cancel_right]", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k * n.factorial = (n + k).factorial"}, {"line": "rw [\u2190 factorial_mul_ascFactorial]", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k * n.factorial = n.factorial * (n + 1).ascFactorial k"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ascFactorial_eq_factorial_mul_choose' (n k : \u2115) :\n    n.ascFactorial k = k ! * (n + k - 1).choose k := by\n  cases n\n  \u00b7 cases k\n    \u00b7 rw [ascFactorial_zero, choose_zero_right, factorial_zero, Nat.mul_one]\n    \u00b7 simp only [zero_ascFactorial, zero_eq, Nat.zero_add, succ_sub_succ_eq_sub,\n        Nat.le_zero_eq, Nat.sub_zero, choose_succ_self, Nat.mul_zero]\n  rw [ascFactorial_eq_factorial_mul_choose]\n  simp only [succ_add_sub_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 n.ascFactorial k = k.factorial * (n + k - 1).choose k"}, {"line": "cases n", "tactic_state": "case zero\nk : \u2115\n\u22a2 ascFactorial 0 k = k.factorial * (0 + k - 1).choose k\n---\ncase succ\nk n\u271d : \u2115\n\u22a2 (n\u271d + 1).ascFactorial k = k.factorial * (n\u271d + 1 + k - 1).choose k"}, {"line": "\u00b7 cases k\n    \u00b7 rw [ascFactorial_zero, choose_zero_right, factorial_zero, Nat.mul_one]\n    \u00b7 simp only [zero_ascFactorial, zero_eq, Nat.zero_add, succ_sub_succ_eq_sub,\n        Nat.le_zero_eq, Nat.sub_zero, choose_succ_self, Nat.mul_zero]", "tactic_state": "case succ\nk n\u271d : \u2115\n\u22a2 (n\u271d + 1).ascFactorial k = k.factorial * (n\u271d + 1 + k - 1).choose k"}, {"line": "rw [ascFactorial_eq_factorial_mul_choose]", "tactic_state": "case succ\nk n\u271d : \u2115\n\u22a2 k.factorial * (n\u271d + k).choose k = k.factorial * (n\u271d + 1 + k - 1).choose k"}, {"line": "simp only [succ_add_sub_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_eq_asc_factorial_div_factorial (n k : \u2115) :\n    (n + k).choose k = (n + 1).ascFactorial k / k ! := by\n  apply Nat.mul_left_cancel k.factorial_pos\n  rw [\u2190 ascFactorial_eq_factorial_mul_choose]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_ascFactorial _ _).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (n + k).choose k = (n + 1).ascFactorial k / k.factorial"}, {"line": "apply Nat.mul_left_cancel k.factorial_pos", "tactic_state": "n k : \u2115\n\u22a2 k.factorial * (n + k).choose k = k.factorial * ((n + 1).ascFactorial k / k.factorial)"}, {"line": "rw [\u2190 ascFactorial_eq_factorial_mul_choose]", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).ascFactorial k = k.factorial * ((n + 1).ascFactorial k / k.factorial)"}, {"line": "exact (Nat.mul_div_cancel' <| factorial_dvd_ascFactorial _ _).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descFactorial_eq_factorial_mul_choose (n k : \u2115) : n.descFactorial k = k ! * n.choose k := by\n  obtain h | h := Nat.lt_or_ge n k\n  \u00b7 rw [descFactorial_eq_zero_iff_lt.2 h, choose_eq_zero_of_lt h, Nat.mul_zero]\n  rw [Nat.mul_comm]\n  apply Nat.mul_right_cancel (n - k).factorial_pos\n  rw [choose_mul_factorial_mul_factorial h]\n  rw [\u2190 factorial_mul_descFactorial h]\n  rw [Nat.mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 n.descFactorial k = k.factorial * n.choose k"}, {"line": "obtain h | h := Nat.lt_or_ge n k", "tactic_state": "case inl\nn k : \u2115\nh : n < k\n\u22a2 n.descFactorial k = k.factorial * n.choose k\n---\ncase inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k = k.factorial * n.choose k"}, {"line": "\u00b7 rw [descFactorial_eq_zero_iff_lt.2 h, choose_eq_zero_of_lt h, Nat.mul_zero]", "tactic_state": "case inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k = k.factorial * n.choose k"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "case inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k = n.choose k * k.factorial"}, {"line": "apply Nat.mul_right_cancel (n - k).factorial_pos", "tactic_state": "case inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k * (n - k).factorial = n.choose k * k.factorial * (n - k).factorial"}, {"line": "rw [choose_mul_factorial_mul_factorial h]", "tactic_state": "case inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k * (n - k).factorial = n.factorial"}, {"line": "rw [\u2190 factorial_mul_descFactorial h]", "tactic_state": "case inr\nn k : \u2115\nh : n \u2265 k\n\u22a2 n.descFactorial k * (n - k).factorial = (n - k).factorial * n.descFactorial k"}, {"line": "rw [Nat.mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_le_succ_of_lt_half_left {r n : \u2115} (h : r < n / 2) :\n    choose n r \u2264 choose n (r + 1) := by\n  refine Nat.le_of_mul_le_mul_right ?_ (Nat.sub_pos_of_lt (h.trans_le (n.div_le_self 2)))\n  rw [\u2190 choose_succ_right_eq]\n  apply Nat.mul_le_mul_left\n  rw [\u2190 Nat.lt_iff_add_one_le]\n  rw [Nat.lt_sub_iff_add_lt]\n  rw [\u2190 Nat.mul_two]\n  exact lt_of_lt_of_le (Nat.mul_lt_mul_of_pos_right h Nat.zero_lt_two) (n.div_mul_le_self 2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r n : \u2115\nh : r < n / 2\n\u22a2 n.choose r \u2264 n.choose (r + 1)"}, {"line": "refine Nat.le_of_mul_le_mul_right ?_ (Nat.sub_pos_of_lt (h.trans_le (n.div_le_self 2)))", "tactic_state": "r n : \u2115\nh : r < n / 2\n\u22a2 n.choose r * (n - r) \u2264 n.choose (r + 1) * (n - r)"}, {"line": "rw [\u2190 choose_succ_right_eq]", "tactic_state": "r n : \u2115\nh : r < n / 2\n\u22a2 n.choose (r + 1) * (r + 1) \u2264 n.choose (r + 1) * (n - r)"}, {"line": "apply Nat.mul_le_mul_left", "tactic_state": "case h\nr n : \u2115\nh : r < n / 2\n\u22a2 r + 1 \u2264 n - r"}, {"line": "rw [\u2190 Nat.lt_iff_add_one_le]", "tactic_state": "case h\nr n : \u2115\nh : r < n / 2\n\u22a2 r < n - r"}, {"line": "rw [Nat.lt_sub_iff_add_lt]", "tactic_state": "case h\nr n : \u2115\nh : r < n / 2\n\u22a2 r + r < n"}, {"line": "rw [\u2190 Nat.mul_two]", "tactic_state": "case h\nr n : \u2115\nh : r < n / 2\n\u22a2 r * 2 < n"}, {"line": "exact lt_of_lt_of_le (Nat.mul_lt_mul_of_pos_right h Nat.zero_lt_two) (n.div_mul_le_self 2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_le_succ (a c : \u2115) : choose a c \u2264 choose a.succ c := by\n  cases c <;> simp [Nat.choose_succ_succ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a c : \u2115\n\u22a2 a.choose c \u2264 a.succ.choose c"}, {"line": "cases c <;> simp [Nat.choose_succ_succ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_le_add (a b c : \u2115) : choose a c \u2264 choose (a + b) c := by\n  induction' b with b_n b_ih\n  \u00b7 simp\n  exact le_trans b_ih (choose_le_succ (a + b_n) c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\n\u22a2 a.choose c \u2264 (a + b).choose c"}, {"line": "induction' b with b_n b_ih", "tactic_state": "case zero\na c : \u2115\n\u22a2 a.choose c \u2264 (a + 0).choose c\n---\ncase succ\na c b_n : \u2115\nb_ih : a.choose c \u2264 (a + b_n).choose c\n\u22a2 a.choose c \u2264 (a + (b_n + 1)).choose c"}, {"line": "\u00b7 simp", "tactic_state": "case succ\na c b_n : \u2115\nb_ih : a.choose c \u2264 (a + b_n).choose c\n\u22a2 a.choose c \u2264 (a + (b_n + 1)).choose c"}, {"line": "exact le_trans b_ih (choose_le_succ (a + b_n) c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multichoose_zero_right (n : \u2115) : multichoose n 0 = 1 := by cases n <;> simp [multichoose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.multichoose 0 = 1"}, {"line": "cases n <;> simp [multichoose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multichoose_zero_succ (k : \u2115) : multichoose 0 (k + 1) = 0 := by simp [multichoose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 multichoose 0 (k + 1) = 0"}, {"line": "simp [multichoose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multichoose_succ_succ (n k : \u2115) :\n    multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k := by\n  simp [multichoose]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 (n + 1).multichoose (k + 1) = n.multichoose (k + 1) + (n + 1).multichoose k"}, {"line": "simp [multichoose]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_modEq_choose_mod_mul_choose_div_nat :\n    choose n k \u2261 choose (n % p) (k % p) * choose (n / p) (k / p) [MOD p] := by\n  rw [\u2190 Int.natCast_modEq_iff]\n  exact_mod_cast choose_modEq_choose_mod_mul_choose_div\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Lucas.lean", "context": {"open": ["Finset hiding choose", "Nat Polynomial"], "variables": ["{n k p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 n.choose k \u2261 (n % p).choose (k % p) * (n / p).choose (k / p) [MOD p]"}, {"line": "rw [\u2190 Int.natCast_modEq_iff]", "tactic_state": "n k p : \u2115\ninst\u271d : Fact (Nat.Prime p)\n\u22a2 \u2191(n.choose k) \u2261 \u2191((n % p).choose (k % p) * (n / p).choose (k / p)) [ZMOD \u2191p]"}, {"line": "exact_mod_cast choose_modEq_choose_mod_mul_choose_div", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_modEq_prod_range_choose_nat {a : \u2115} (ha\u2081 : n < p ^ a) (ha\u2082 : k < p ^ a) :\n    choose n k \u2261 \u220f i \u2208 range a, choose (n / p ^ i % p) (k / p ^ i % p) [MOD p] := by\n  rw [\u2190 Int.natCast_modEq_iff]\n  exact_mod_cast choose_modEq_prod_range_choose ha\u2081 ha\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Lucas.lean", "context": {"open": ["Finset hiding choose", "Nat Polynomial"], "variables": ["{n k p : \u2115} [Fact p.Prime]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha\u2081 : n < p ^ a\nha\u2082 : k < p ^ a\n\u22a2 n.choose k \u2261 \u220f i \u2208 range a, (n / p ^ i % p).choose (k / p ^ i % p) [MOD p]"}, {"line": "rw [\u2190 Int.natCast_modEq_iff]", "tactic_state": "n k p : \u2115\ninst\u271d : Fact (Nat.Prime p)\na : \u2115\nha\u2081 : n < p ^ a\nha\u2082 : k < p ^ a\n\u22a2 \u2191(n.choose k) \u2261 \u2191(\u220f i \u2208 range a, (n / p ^ i % p).choose (k / p ^ i % p)) [ZMOD \u2191p]"}, {"line": "exact_mod_cast choose_modEq_prod_range_choose ha\u2081 ha\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem binomial_eq [DecidableEq \u03b1] (h : a \u2260 b) :\n    multinomial {a, b} f = (f a + f b)! / ((f a)! * (f b)!) := by\n  simp [multinomial, Finset.sum_pair h, Finset.prod_pair h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Multinomial.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) {a b : \u03b1} (n : \u2115)", "{s f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\n\u22a2 sorry = (f a + f b).factorial / ((f a).factorial * (f b).factorial)"}, {"line": "simp [multinomial, Finset.sum_pair h, Finset.prod_pair h]", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\n\u22a2 sorry () = (f a + f b).factorial / ((f a).factorial * (f b).factorial)"}]}
{"declaration": "theorem binomial_eq_choose [DecidableEq \u03b1] (h : a \u2260 b) :\n    multinomial {a, b} f = (f a + f b).choose (f a) := by\n  simp [binomial_eq h, choose_eq_factorial_div_factorial (Nat.le_add_right _ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Multinomial.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) {a b : \u03b1} (n : \u2115)", "{s f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\n\u22a2 sorry = (f a + f b).choose (f a)"}, {"line": "simp [binomial_eq h, choose_eq_factorial_div_factorial (Nat.le_add_right _ _)]", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\n\u22a2 sorry () = (f a + f b).choose (f a)"}]}
{"declaration": "theorem binomial_spec [DecidableEq \u03b1] (hab : a \u2260 b) :\n    (f a)! * (f b)! * multinomial {a, b} f = (f a + f b)! := by\n  simpa [Finset.sum_pair hab, Finset.prod_pair hab] using multinomial_spec {a, b} f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Multinomial.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) {a b : \u03b1} (n : \u2115)", "{s f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nhab : a \u2260 b\n\u22a2 (f a).factorial * (f b).factorial * sorry = (f a + f b).factorial"}, {"line": "simpa [Finset.sum_pair hab, Finset.prod_pair hab] using multinomial_spec {a, b} f", "tactic_state": "No Goals!"}]}
{"declaration": "theorem binomial_one [DecidableEq \u03b1] (h : a \u2260 b) (h\u2081 : f a = 1) :\n    multinomial {a, b} f = (f b).succ := by\n  simp [multinomial_insert_one (Finset.not_mem_singleton.mpr h) h\u2081]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Multinomial.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) {a b : \u03b1} (n : \u2115)", "{s f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\nh\u2081 : f a = 1\n\u22a2 sorry = (f b).succ"}, {"line": "simp [multinomial_insert_one (Finset.not_mem_singleton.mpr h) h\u2081]", "tactic_state": "\u03b1 : Type u_1\nf : \u03b1 \u2192 \u2115\na b : \u03b1\nx\u271d : Sort u_2\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\nh : a \u2260 b\nh\u2081 : f a = 1\n\u22a2 sorry () = f b + 1"}]}
{"declaration": "theorem multinomial_zero [DecidableEq \u03b1] : multinomial (0 : Multiset \u03b1) = 1 := by\n  simp [multinomial, Finsupp.multinomial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Multinomial.lean", "context": {"open": ["Finset", "scoped Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) {a b : \u03b1} (n : \u2115)", "{s f}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nx\u271d : Sort u_4\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\n\u22a2 sorry = 1"}, {"line": "simp [multinomial, Finsupp.multinomial]", "tactic_state": "\u03b1 : Type u_3\nx\u271d : Sort u_4\nmultinomial : x\u271d\ninst\u271d : DecidableEq \u03b1\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem sum_range_choose (n : \u2115) : (\u2211 m \u2208 range (n + 1), n.choose m) = 2 ^ n := by\n  have := (add_pow 1 1 n).symm\n  simpa [one_add_one_eq_two] using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2211 m \u2208 range (n + 1), n.choose m = 2 ^ n"}, {"line": "have := (add_pow 1 1 n).symm", "tactic_state": "n : \u2115\nthis : \u2211 m \u2208 range (n + 1), 1 ^ m * 1 ^ (n - m) * \u2191(n.choose m) = (1 + 1) ^ n\n\u22a2 \u2211 m \u2208 range (n + 1), n.choose m = 2 ^ n"}, {"line": "simpa [one_add_one_eq_two] using this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem choose_middle_le_pow (n : \u2115) : (2 * n + 1).choose n \u2264 4 ^ n := by\n  have t : (2 * n + 1).choose n \u2264 \u2211 i \u2208 range (n + 1), (2 * n + 1).choose i :=\n    single_le_sum (fun x _ \u21a6 by omega) (self_mem_range_succ n)\n  simpa [sum_range_choose_halfway n] using t\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (2 * n + 1).choose n \u2264 4 ^ n"}, {"line": "have t : (2 * n + 1).choose n \u2264 \u2211 i \u2208 range (n + 1), (2 * n + 1).choose i :=\n    single_le_sum (fun x _ \u21a6 by omega) (self_mem_range_succ n)", "tactic_state": "n : \u2115\nt : (2 * n + 1).choose n \u2264 \u2211 i \u2208 range (n + 1), (2 * n + 1).choose i\n\u22a2 (2 * n + 1).choose n \u2264 4 ^ n"}, {"line": "simpa [sum_range_choose_halfway n] using t", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_Icc_choose (n k : \u2115) : \u2211 m \u2208 Icc k n, m.choose k = (n + 1).choose (k + 1) := by\n  rcases lt_or_le n k with h | h\n  \u00b7 rw [choose_eq_zero_of_lt (by omega), Icc_eq_empty_of_lt h, sum_empty]\n  \u00b7 induction n, h using le_induction with\n    | base => simp\n    | succ n _ ih =>\n      rw [\u2190 Ico_insert_right (by omega)]\n      rw [sum_insert (by simp)]\n      rw [Ico_succ_right]\n      rw [ih]\n      rw [choose_succ_succ' (n + 1)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 \u2211 m \u2208 Icc k n, m.choose k = (n + 1).choose (k + 1)"}, {"line": "rcases lt_or_le n k with h | h", "tactic_state": "case inl\nn k : \u2115\nh : n < k\n\u22a2 \u2211 m \u2208 Icc k n, m.choose k = (n + 1).choose (k + 1)\n---\ncase inr\nn k : \u2115\nh : k \u2264 n\n\u22a2 \u2211 m \u2208 Icc k n, m.choose k = (n + 1).choose (k + 1)"}, {"line": "\u00b7 rw [choose_eq_zero_of_lt (by omega), Icc_eq_empty_of_lt h, sum_empty]", "tactic_state": "case inr\nn k : \u2115\nh : k \u2264 n\n\u22a2 \u2211 m \u2208 Icc k n, m.choose k = (n + 1).choose (k + 1)"}, {"line": "\u00b7 induction n, h using le_induction with\n    | base => simp\n    | succ n _ ih =>\n      rw [\u2190 Ico_insert_right (by omega)]\n      rw [sum_insert (by simp)]\n      rw [Ico_succ_right]\n      rw [ih]\n      rw [choose_succ_succ' (n + 1)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_range_add_choose (n k : \u2115) :\n    \u2211 i \u2208 Finset.range (n + 1), (i + k).choose k = (n + k + 1).choose (k + 1) := by\n  rw [\u2190 sum_Icc_choose]\n  rw [range_eq_Ico]\n  convert (sum_map _ (addRightEmbedding k) (\u00b7.choose k)).symm using 2\n  rw [map_add_right_Ico]\n  rw [zero_add]\n  rw [add_right_comm]\n  rw [Nat.Ico_succ_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\n\u22a2 \u2211 i \u2208 range (n + 1), (i + k).choose k = (n + k + 1).choose (k + 1)"}, {"line": "rw [\u2190 sum_Icc_choose]", "tactic_state": "n k : \u2115\n\u22a2 \u2211 i \u2208 range (n + 1), (i + k).choose k = \u2211 m \u2208 Icc k (n + k), m.choose k"}, {"line": "rw [range_eq_Ico]", "tactic_state": "n k : \u2115\n\u22a2 \u2211 i \u2208 Ico 0 (n + 1), (i + k).choose k = \u2211 m \u2208 Icc k (n + k), m.choose k"}, {"line": "convert (sum_map _ (addRightEmbedding k) (\u00b7.choose k)).symm using 2", "tactic_state": "case h.e'_3.h\nn k : \u2115\n\u22a2 Icc k (n + k) = map (addRightEmbedding k) (Ico 0 (n + 1))"}, {"line": "rw [map_add_right_Ico]", "tactic_state": "case h.e'_3.h\nn k : \u2115\n\u22a2 Icc k (n + k) = Ico (0 + k) (n + 1 + k)"}, {"line": "rw [zero_add]", "tactic_state": "case h.e'_3.h\nn k : \u2115\n\u22a2 Icc k (n + k) = Ico k (n + 1 + k)"}, {"line": "rw [add_right_comm]", "tactic_state": "case h.e'_3.h\nn k : \u2115\n\u22a2 Icc k (n + k) = Ico k (n + k + 1)"}, {"line": "rw [Nat.Ico_succ_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_antidiagonal_pow_choose_succ {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) (n : \u2115) :\n    (\u220f ij \u2208 antidiagonal (n + 1), f ij.1 ij.2 ^ (n + 1).choose ij.1) =\n      (\u220f ij \u2208 antidiagonal n, f ij.1 (ij.2 + 1) ^ n.choose ij.1) *\n        \u220f ij \u2208 antidiagonal n, f (ij.1 + 1) ij.2 ^ n.choose ij.2 := by\n  simp only [Nat.prod_antidiagonal_eq_prod_range_succ_mk]\n  simp only [prod_pow_choose_succ]\n  have : \u2200 i \u2208 range (n + 1), i \u2264 n := fun i hi \u21a6 by simpa [Nat.lt_succ_iff] using hi\n  congr 1\n  \u00b7 refine prod_congr rfl fun i hi \u21a6 ?_\n    rw [tsub_add_eq_add_tsub (this _ hi)]\n  \u00b7 refine prod_congr rfl fun i hi \u21a6 ?_\n    rw [choose_symm (this _ hi)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\n\u22a2 \u220f ij \u2208 antidiagonal (n + 1), f ij.1 ij.2 ^ (n + 1).choose ij.1 =\n    (\u220f ij \u2208 antidiagonal n, f ij.1 (ij.2 + 1) ^ n.choose ij.1) *\n      \u220f ij \u2208 antidiagonal n, f (ij.1 + 1) ij.2 ^ n.choose ij.2"}, {"line": "simp only [Nat.prod_antidiagonal_eq_prod_range_succ_mk]", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\n\u22a2 \u220f x \u2208 range (n + 1).succ, f x (n + 1 - x) ^ (n + 1).choose x =\n    (\u220f x \u2208 range n.succ, f x (n - x + 1) ^ n.choose x) * \u220f x \u2208 range n.succ, f (x + 1) (n - x) ^ n.choose (n - x)"}, {"line": "simp only [prod_pow_choose_succ]", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\n\u22a2 (\u220f i \u2208 range (n + 1), f i (n + 1 - i) ^ n.choose i) * \u220f i \u2208 range (n + 1), f (i + 1) (n - i) ^ n.choose i =\n    (\u220f x \u2208 range n.succ, f x (n - x + 1) ^ n.choose x) * \u220f x \u2208 range n.succ, f (x + 1) (n - x) ^ n.choose (n - x)"}, {"line": "have : \u2200 i \u2208 range (n + 1), i \u2264 n := fun i hi \u21a6 by simpa [Nat.lt_succ_iff] using hi", "tactic_state": "M : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\nthis : \u2200 i \u2208 range (n + 1), i \u2264 n\n\u22a2 (\u220f i \u2208 range (n + 1), f i (n + 1 - i) ^ n.choose i) * \u220f i \u2208 range (n + 1), f (i + 1) (n - i) ^ n.choose i =\n    (\u220f x \u2208 range n.succ, f x (n - x + 1) ^ n.choose x) * \u220f x \u2208 range n.succ, f (x + 1) (n - x) ^ n.choose (n - x)"}, {"line": "congr 1", "tactic_state": "case e_a\nM : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\nthis : \u2200 i \u2208 range (n + 1), i \u2264 n\n\u22a2 \u220f i \u2208 range (n + 1), f i (n + 1 - i) ^ n.choose i = \u220f x \u2208 range n.succ, f x (n - x + 1) ^ n.choose x\n---\ncase e_a\nM : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\nthis : \u2200 i \u2208 range (n + 1), i \u2264 n\n\u22a2 \u220f i \u2208 range (n + 1), f (i + 1) (n - i) ^ n.choose i = \u220f x \u2208 range n.succ, f (x + 1) (n - x) ^ n.choose (n - x)"}, {"line": "\u00b7 refine prod_congr rfl fun i hi \u21a6 ?_\n    rw [tsub_add_eq_add_tsub (this _ hi)]", "tactic_state": "case e_a\nM : Type u_2\ninst\u271d : CommMonoid M\nf : \u2115 \u2192 \u2115 \u2192 M\nn : \u2115\nthis : \u2200 i \u2208 range (n + 1), i \u2264 n\n\u22a2 \u220f i \u2208 range (n + 1), f (i + 1) (n - i) ^ n.choose i = \u220f x \u2208 range n.succ, f (x + 1) (n - x) ^ n.choose (n - x)"}, {"line": "\u00b7 refine prod_congr rfl fun i hi \u21a6 ?_\n    rw [choose_symm (this _ hi)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_choose_succ_mul (f : \u2115 \u2192 \u2115 \u2192 R) (n : \u2115) :\n    (\u2211 i \u2208 range (n + 2), ((n + 1).choose i : R) * f i (n + 1 - i)) =\n      (\u2211 i \u2208 range (n + 1), (n.choose i : R) * f i (n + 1 - i)) +\n        \u2211 i \u2208 range (n + 1), (n.choose i : R) * f (i + 1) (n - i) := by\n  simpa only [nsmul_eq_mul] using sum_choose_succ_nsmul f n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nf : \u2115 \u2192 \u2115 \u2192 R\nn : \u2115\n\u22a2 \u2211 i \u2208 range (n + 2), \u2191((n + 1).choose i) * f i (n + 1 - i) =\n    \u2211 i \u2208 range (n + 1), \u2191(n.choose i) * f i (n + 1 - i) + \u2211 i \u2208 range (n + 1), \u2191(n.choose i) * f (i + 1) (n - i)"}, {"line": "simpa only [nsmul_eq_mul] using sum_choose_succ_nsmul f n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_antidiagonal_choose_succ_mul (f : \u2115 \u2192 \u2115 \u2192 R) (n : \u2115) :\n    (\u2211 ij \u2208 antidiagonal (n + 1), ((n + 1).choose ij.1 : R) * f ij.1 ij.2) =\n      (\u2211 ij \u2208 antidiagonal n, (n.choose ij.1 : R) * f ij.1 (ij.2 + 1)) +\n        \u2211 ij \u2208 antidiagonal n, (n.choose ij.2 : R) * f (ij.1 + 1) ij.2 := by\n  simpa only [nsmul_eq_mul] using sum_antidiagonal_choose_succ_nsmul f n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Choose/Sum.lean", "context": {"open": ["Nat Finset"], "variables": ["{R : Type*}", "[Semiring R] {x y : R}", "[NonAssocSemiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : Semiring R\ninst\u271d : NonAssocSemiring R\nf : \u2115 \u2192 \u2115 \u2192 R\nn : \u2115\n\u22a2 \u2211 ij \u2208 antidiagonal (n + 1), \u2191((n + 1).choose ij.1) * f ij.1 ij.2 =\n    \u2211 ij \u2208 antidiagonal n, \u2191(n.choose ij.1) * f ij.1 (ij.2 + 1) +\n      \u2211 ij \u2208 antidiagonal n, \u2191(n.choose ij.2) * f (ij.1 + 1) ij.2"}, {"line": "simpa only [nsmul_eq_mul] using sum_antidiagonal_choose_succ_nsmul f n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_ascFactorial : a.ascFactorial b = (ascPochhammer S b).eval (a : S) := by\n  rw [\u2190 ascPochhammer_nat_eq_ascFactorial]\n  rw [ascPochhammer_eval_cast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/Cast.lean", "context": {"open": ["Nat"], "variables": ["(S : Type*)", "[Semiring S] (a b : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na b : \u2115\n\u22a2 \u2191(a.ascFactorial b) = Polynomial.eval (\u2191a) (ascPochhammer S b)"}, {"line": "rw [\u2190 ascPochhammer_nat_eq_ascFactorial]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na b : \u2115\n\u22a2 \u2191(Polynomial.eval a (ascPochhammer \u2115 b)) = Polynomial.eval (\u2191a) (ascPochhammer S b)"}, {"line": "rw [ascPochhammer_eval_cast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_factorial : (a ! : S) = (ascPochhammer S a).eval 1 := by\n  rw [\u2190 one_ascFactorial]\n  rw [cast_ascFactorial]\n  rw [cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/Cast.lean", "context": {"open": ["Nat"], "variables": ["(S : Type*)", "[Semiring S] (a b : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na : \u2115\n\u22a2 \u2191a.factorial = Polynomial.eval 1 (ascPochhammer S a)"}, {"line": "rw [\u2190 one_ascFactorial]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na : \u2115\n\u22a2 \u2191(ascFactorial 1 a) = Polynomial.eval 1 (ascPochhammer S a)"}, {"line": "rw [cast_ascFactorial]", "tactic_state": "S : Type u_1\ninst\u271d : Semiring S\na : \u2115\n\u22a2 Polynomial.eval (\u21911) (ascPochhammer S a) = Polynomial.eval 1 (ascPochhammer S a)"}, {"line": "rw [cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_descFactorial_two : (a.descFactorial 2 : S) = a * (a - 1) := by\n  rw [cast_descFactorial]\n  cases a\n  \u00b7 simp\n  \u00b7 rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right, ascPochhammer_succ_right,\n      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,\n      Polynomial.eval_X, cast_one, Polynomial.eval_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/Cast.lean", "context": {"open": ["Nat"], "variables": ["(S : Type*)", "[Semiring S] (a b : \u2115)", "[Ring S] (a b : \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Ring S\na : \u2115\n\u22a2 \u2191(a.descFactorial 2) = \u2191a * (\u2191a - 1)"}, {"line": "rw [cast_descFactorial]", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Ring S\na : \u2115\n\u22a2 Polynomial.eval (\u2191(a - (2 - 1))) (ascPochhammer S 2) = \u2191a * (\u2191a - 1)"}, {"line": "cases a", "tactic_state": "case zero\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Ring S\n\u22a2 Polynomial.eval (\u2191(0 - (2 - 1))) (ascPochhammer S 2) = \u21910 * (\u21910 - 1)\n---\ncase succ\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Ring S\nn\u271d : \u2115\n\u22a2 Polynomial.eval (\u2191(n\u271d + 1 - (2 - 1))) (ascPochhammer S 2) = \u2191(n\u271d + 1) * (\u2191(n\u271d + 1) - 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nS : Type u_1\ninst\u271d\u00b9 : Semiring S\ninst\u271d : Ring S\nn\u271d : \u2115\n\u22a2 Polynomial.eval (\u2191(n\u271d + 1 - (2 - 1))) (ascPochhammer S 2) = \u2191(n\u271d + 1) * (\u2191(n\u271d + 1) - 1)"}, {"line": "\u00b7 rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right, ascPochhammer_succ_right,\n      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,\n      Polynomial.eval_X, cast_one, Polynomial.eval_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem doubleFactorial_add_one (n : \u2115) : (n + 1)\u203c = (n + 1) * (n - 1)\u203c := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/DoubleFactorial.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (n + 1).doubleFactorial = (n + 1) * (n - 1).doubleFactorial"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "example (n : \u2115) : 0 < n\u203c := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/DoubleFactorial.lean", "context": {"open": ["Nat", "Lean Meta Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 0 < n.doubleFactorial"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descFactorial_one (n : \u2115) : n.descFactorial 1 = n := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/Basic.lean", "context": {"open": [], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.descFactorial 1 = n"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_factorial_pos : 0 < \u220f i \u2208 s, (f i)! := by positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/BigOperators.lean", "context": {"open": ["Finset Nat"], "variables": ["{\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u2115\n\u22a2 0 < \u220f i \u2208 s, (f i).factorial"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem superFactorial_dvd_vandermonde_det {n : \u2115} (v : Fin (n + 1) \u2192 \u2124) :\n    \u2191(Nat.superFactorial n) \u2223 (Matrix.vandermonde v).det := by\n  let m := inf' univ \u27e80, mem_univ _\u27e9 v\n  let w' := fun i \u21a6 (v i - m).toNat\n  have hw' : \u2200 i, (w' i : \u2124) = v i - m := fun i \u21a6 Int.toNat_sub_of_le (inf'_le _ (mem_univ _))\n  have h := Matrix.det_eval_matrixOfPolynomials_eq_det_vandermonde (fun i \u21a6 \u2191(w' i))\n      (fun i => descPochhammer \u2124 i)\n      (fun i => descPochhammer_natDegree \u2124 i)\n      (fun i => monic_descPochhammer \u2124 i)\n  conv_lhs at h => simp only [hw', Matrix.det_vandermonde_sub]\n  use (Matrix.of (fun (i j : Fin (n + 1)) => (Nat.choose (w' i) (j : \u2115) : \u2124))).det\n  simp [h, matrixOf_eval_descPochhammer_eq_mul_matrixOf_choose w', Fin.prod_univ_eq_prod_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorial/SuperFactorial.lean", "context": {"open": ["Finset"], "variables": ["{R : Type*} [CommRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "let m := inf' univ \u27e80, mem_univ _\u27e9 v", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "let w' := fun i \u21a6 (v i - m).toNat", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "have hw' : \u2200 i, (w' i : \u2124) = v i - m := fun i \u21a6 Int.toNat_sub_of_le (inf'_le _ (mem_univ _))", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\nhw' : \u2200 (i : Fin (n + 1)), \u2191(w' i) = v i - m\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "have h := Matrix.det_eval_matrixOfPolynomials_eq_det_vandermonde (fun i \u21a6 \u2191(w' i))\n      (fun i => descPochhammer \u2124 i)\n      (fun i => descPochhammer_natDegree \u2124 i)\n      (fun i => monic_descPochhammer \u2124 i)", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\nhw' : \u2200 (i : Fin (n + 1)), \u2191(w' i) = v i - m\nh :\n  (Matrix.vandermonde fun i => \u2191(w' i)).det =\n    (Matrix.of fun i j => Polynomial.eval ((fun i => \u2191(w' i)) i) ((fun i => descPochhammer \u2124 \u2191i) j)).det\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "conv_lhs at h => simp only [hw', Matrix.det_vandermonde_sub]", "tactic_state": "n : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\nhw' : \u2200 (i : Fin (n + 1)), \u2191(w' i) = v i - m\nh :\n  (Matrix.vandermonde v).det =\n    (Matrix.of fun i j => Polynomial.eval ((fun i => \u2191(w' i)) i) ((fun i => descPochhammer \u2124 \u2191i) j)).det\n\u22a2 \u2191n.superFactorial \u2223 (Matrix.vandermonde v).det"}, {"line": "use (Matrix.of (fun (i j : Fin (n + 1)) => (Nat.choose (w' i) (j : \u2115) : \u2124))).det", "tactic_state": "case h\nn : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\nhw' : \u2200 (i : Fin (n + 1)), \u2191(w' i) = v i - m\nh :\n  (Matrix.vandermonde v).det =\n    (Matrix.of fun i j => Polynomial.eval ((fun i => \u2191(w' i)) i) ((fun i => descPochhammer \u2124 \u2191i) j)).det\n\u22a2 (Matrix.vandermonde v).det = \u2191n.superFactorial * (Matrix.of fun i j => \u2191((w' i).choose \u2191j)).det"}, {"line": "simp [h, matrixOf_eval_descPochhammer_eq_mul_matrixOf_choose w', Fin.prod_univ_eq_prod_range]", "tactic_state": "case h\nn : \u2115\nv : Fin (n + 1) \u2192 \u2124\nm : \u2124 := univ.inf' \u22ef v\nw' : Fin (n + 1) \u2192 \u2115 := fun i => (v i - m).toNat\nhw' : \u2200 (i : Fin (n + 1)), \u2191(w' i) = v i - m\nh :\n  (Matrix.vandermonde v).det =\n    (Matrix.of fun i j => Polynomial.eval ((fun i => \u2191(w' i)) i) ((fun i => descPochhammer \u2124 \u2191i) j)).det\n\u22a2 (Matrix.of fun i j => Polynomial.eval (\u2191(w' i)) (descPochhammer \u2124 \u2191j)).det =\n    \u2191n.superFactorial * (Matrix.of fun i j => \u2191((w' i).choose \u2191j)).det"}]}
{"declaration": "theorem eq_pow_of_factorization_eq_single {n p k : \u2115} (hn : n \u2260 0)\n    (h : n.factorization = Finsupp.single p k) : n = p ^ k := by\n  rw [\u2190 Nat.factorization_prod_pow_eq_self hn]\n  rw [h]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p k : \u2115\nhn : n \u2260 0\nh : n.factorization = fun\u2080 | p => k\n\u22a2 n = p ^ k"}, {"line": "rw [\u2190 Nat.factorization_prod_pow_eq_self hn]", "tactic_state": "n p k : \u2115\nhn : n \u2260 0\nh : n.factorization = fun\u2080 | p => k\n\u22a2 (n.factorization.prod fun x1 x2 => x1 ^ x2) = p ^ k"}, {"line": "rw [h]", "tactic_state": "n p k : \u2115\nhn : n \u2260 0\nh : n.factorization = fun\u2080 | p => k\n\u22a2 ((fun\u2080 | p => k).prod fun x1 x2 => x1 ^ x2) = p ^ k"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ordProj_of_not_prime (n p : \u2115) (hp : \u00acp.Prime) : ordProj[p] n = 1 := by\n  simp [factorization_eq_zero_of_non_prime n hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhp : \u00acNat.Prime p\n\u22a2 p ^ n.factorization p = 1"}, {"line": "simp [factorization_eq_zero_of_non_prime n hp]", "tactic_state": "n p : \u2115\nhp : \u00acNat.Prime p\n\u22a2 p = 1 \u2228 n.factorization p = 0"}]}
{"declaration": "theorem ordProj_pos (n p : \u2115) : 0 < ordProj[p] n := by\n  if pp : p.Prime then simp [pow_pos pp.pos] else simp [pp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\n\u22a2 0 < p ^ n.factorization p"}, {"line": "if pp : p.Prime then simp [pow_pos pp.pos] else simp [pp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_lt {n : \u2115} (p : \u2115) (hn : n \u2260 0) : n.factorization p < n := by\n  by_cases pp : p.Prime\n  \u00b7 exact (Nat.pow_lt_pow_iff_right pp.one_lt).1 <| (ordProj_le p hn).trans_lt <|\n      Nat.lt_pow_self pp.one_lt\n  \u00b7 simpa only [factorization_eq_zero_of_non_prime n pp] using hn.bot_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhn : n \u2260 0\n\u22a2 n.factorization p < n"}, {"line": "by_cases pp : p.Prime", "tactic_state": "case pos\nn p : \u2115\nhn : n \u2260 0\npp : Nat.Prime p\n\u22a2 n.factorization p < n\n---\ncase neg\nn p : \u2115\nhn : n \u2260 0\npp : \u00acNat.Prime p\n\u22a2 n.factorization p < n"}, {"line": "\u00b7 exact (Nat.pow_lt_pow_iff_right pp.one_lt).1 <| (ordProj_le p hn).trans_lt <|\n      Nat.lt_pow_self pp.one_lt", "tactic_state": "case neg\nn p : \u2115\nhn : n \u2260 0\npp : \u00acNat.Prime p\n\u22a2 n.factorization p < n"}, {"line": "\u00b7 simpa only [factorization_eq_zero_of_non_prime n pp] using hn.bot_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_le_factorization_mul_right {a b : \u2115} (ha : a \u2260 0) :\n    b.factorization \u2264 (a * b).factorization := by\n  rw [mul_comm]\n  apply factorization_le_factorization_mul_left ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : a \u2260 0\n\u22a2 b.factorization \u2264 (a * b).factorization"}, {"line": "rw [mul_comm]", "tactic_state": "a b : \u2115\nha : a \u2260 0\n\u22a2 b.factorization \u2264 (b * a).factorization"}, {"line": "apply factorization_le_factorization_mul_left ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_primeFactors_dvd (n : \u2115) : \u220f p \u2208 n.primeFactors, p \u2223 n := by\n  by_cases hn : n = 0\n  \u00b7 subst hn\n    simp\n  \u00b7 simpa [prod_primeFactorsList hn] using (n.primeFactorsList : Multiset \u2115).toFinset_prod_dvd_prod\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u220f p \u2208 n.primeFactors, p \u2223 n"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nn : \u2115\nhn : n = 0\n\u22a2 \u220f p \u2208 n.primeFactors, p \u2223 n\n---\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 \u220f p \u2208 n.primeFactors, p \u2223 n"}, {"line": "\u00b7 subst hn\n    simp", "tactic_state": "case neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 \u220f p \u2208 n.primeFactors, p \u2223 n"}, {"line": "\u00b7 simpa [prod_primeFactorsList hn] using (n.primeFactorsList : Multiset \u2115).toFinset_prod_dvd_prod", "tactic_state": "No Goals!"}]}
{"declaration": "lemma factorizationLCMLeft_zero_left : factorizationLCMLeft 0 b = 1 := by\n  simp [factorizationLCMLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMLeft : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [factorizationLCMLeft]", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMLeft : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma factorizationLCMLeft_zero_right : factorizationLCMLeft a 0 = 1 := by\n  simp [factorizationLCMLeft]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMLeft : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [factorizationLCMLeft]", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMLeft : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma factorizationLCMRight_zero_right : factorizationLCMRight a 0 = 1 := by\n  simp [factorizationLCMRight]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMRight : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [factorizationLCMRight]", "tactic_state": "x\u271d : Sort u_1\nfactorizationLCMRight : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem prod_primeFactors_gcd_mul_prod_primeFactors_mul {\u03b2 : Type*} [CommMonoid \u03b2] (m n : \u2115)\n    (f : \u2115 \u2192 \u03b2) :\n    (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f =\n      m.primeFactors.prod f * n.primeFactors.prod f := by\n  obtain rfl | hm\u2080 := eq_or_ne m 0\n  \u00b7 simp\n  obtain rfl | hn\u2080 := eq_or_ne n 0\n  \u00b7 simp\n  \u00b7 rw [primeFactors_mul hm\u2080 hn\u2080, primeFactors_gcd hm\u2080 hn\u2080, mul_comm, Finset.prod_union_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm n : \u2115\nf : \u2115 \u2192 \u03b2\n\u22a2 (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f = m.primeFactors.prod f * n.primeFactors.prod f"}, {"line": "obtain rfl | hm\u2080 := eq_or_ne m 0", "tactic_state": "case inl\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nn : \u2115\nf : \u2115 \u2192 \u03b2\n\u22a2 (Nat.gcd 0 n).primeFactors.prod f * (0 * n).primeFactors.prod f = (Nat.primeFactors 0).prod f * n.primeFactors.prod f\n---\ncase inr\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm n : \u2115\nf : \u2115 \u2192 \u03b2\nhm\u2080 : m \u2260 0\n\u22a2 (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f = m.primeFactors.prod f * n.primeFactors.prod f"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm n : \u2115\nf : \u2115 \u2192 \u03b2\nhm\u2080 : m \u2260 0\n\u22a2 (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f = m.primeFactors.prod f * n.primeFactors.prod f"}, {"line": "obtain rfl | hn\u2080 := eq_or_ne n 0", "tactic_state": "case inr.inl\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm : \u2115\nf : \u2115 \u2192 \u03b2\nhm\u2080 : m \u2260 0\n\u22a2 (m.gcd 0).primeFactors.prod f * (m * 0).primeFactors.prod f = m.primeFactors.prod f * (Nat.primeFactors 0).prod f\n---\ncase inr.inr\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm n : \u2115\nf : \u2115 \u2192 \u03b2\nhm\u2080 : m \u2260 0\nhn\u2080 : n \u2260 0\n\u22a2 (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f = m.primeFactors.prod f * n.primeFactors.prod f"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nm n : \u2115\nf : \u2115 \u2192 \u03b2\nhm\u2080 : m \u2260 0\nhn\u2080 : n \u2260 0\n\u22a2 (m.gcd n).primeFactors.prod f * (m * n).primeFactors.prod f = m.primeFactors.prod f * n.primeFactors.prod f"}, {"line": "\u00b7 rw [primeFactors_mul hm\u2080 hn\u2080, primeFactors_gcd hm\u2080 hn\u2080, mul_comm, Finset.prod_union_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem setOf_pow_dvd_eq_Icc_factorization {n p : \u2115} (pp : p.Prime) (hn : n \u2260 0) :\n    { i : \u2115 | i \u2260 0 \u2227 p ^ i \u2223 n } = Set.Icc 1 (n.factorization p) := by\n  ext\n  simp [Nat.lt_succ_iff, one_le_iff_ne_zero, pp.pow_dvd_iff_le_factorization hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\npp : Nat.Prime p\nhn : n \u2260 0\n\u22a2 {i | i \u2260 0 \u2227 p ^ i \u2223 n} = Set.Icc 1 (n.factorization p)"}, {"line": "ext", "tactic_state": "case h\nn p : \u2115\npp : Nat.Prime p\nhn : n \u2260 0\nx\u271d : \u2115\n\u22a2 x\u271d \u2208 {i | i \u2260 0 \u2227 p ^ i \u2223 n} \u2194 x\u271d \u2208 Set.Icc 1 (n.factorization p)"}, {"line": "simp [Nat.lt_succ_iff, one_le_iff_ne_zero, pp.pow_dvd_iff_le_factorization hn]", "tactic_state": "case h\nn p : \u2115\npp : Nat.Prime p\nhn : n \u2260 0\nx\u271d : \u2115\n\u22a2 x\u271d \u2264 n.factorization p \u2192 (\u00acx\u271d = 0 \u2194 1 \u2264 x\u271d)"}]}
{"declaration": "theorem factorization_eq_of_coprime_right {p a b : \u2115} (hab : Coprime a b)\n    (hpb : p \u2208 b.primeFactorsList) : (a * b).factorization p = b.factorization p := by\n  rw [mul_comm]\n  exact factorization_eq_of_coprime_left (coprime_comm.mp hab) hpb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\np a b : \u2115\nhab : sorry\nhpb : p \u2208 b.primeFactorsList\n\u22a2 (a * b).factorization p = b.factorization p"}, {"line": "rw [mul_comm]", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\np a b : \u2115\nhab : sorry\nhpb : p \u2208 b.primeFactorsList\n\u22a2 (b * a).factorization p = b.factorization p"}, {"line": "exact factorization_eq_of_coprime_left (coprime_comm.mp hab) hpb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_multiples (n p : \u2115) : #{e \u2208 range n | p \u2223 e + 1} = n / p := by\n  induction' n with n hn\n  \u00b7 simp\n  simp [Nat.succ_div, add_ite, add_zero, Finset.range_succ, filter_insert, apply_ite card,\n    card_insert_of_not_mem, hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\n\u22a2 {e \u2208 Finset.range n | p \u2223 e + 1}.card = n / p"}, {"line": "induction' n with n hn", "tactic_state": "case zero\np : \u2115\n\u22a2 {e \u2208 Finset.range 0 | p \u2223 e + 1}.card = 0 / p\n---\ncase succ\np n : \u2115\nhn : {e \u2208 Finset.range n | p \u2223 e + 1}.card = n / p\n\u22a2 {e \u2208 Finset.range (n + 1) | p \u2223 e + 1}.card = (n + 1) / p"}, {"line": "\u00b7 simp", "tactic_state": "case succ\np n : \u2115\nhn : {e \u2208 Finset.range n | p \u2223 e + 1}.card = n / p\n\u22a2 {e \u2208 Finset.range (n + 1) | p \u2223 e + 1}.card = (n + 1) / p"}, {"line": "simp [Nat.succ_div, add_ite, add_zero, Finset.range_succ, filter_insert, apply_ite card,\n    card_insert_of_not_mem, hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Ioc_filter_dvd_card_eq_div (n p : \u2115) : #{x \u2208 Ioc 0 n | p \u2223 x} = n / p := by\n  induction' n with n IH\n  \u00b7 simp\n  -- TODO: Golf away `h1` after Ya\u00ebl PRs a lemma asserting this\n  have h1 : Ioc 0 n.succ = insert n.succ (Ioc 0 n) := by\n    rcases n.eq_zero_or_pos with (rfl | hn)\n    \u00b7 simp\n    simp_rw [\u2190 Ico_succ_succ, Ico_insert_right (succ_le_succ hn.le), Ico_succ_right]\n  simp [Nat.succ_div, add_ite, add_zero, h1, filter_insert, apply_ite card, card_insert_eq_ite, IH,\n    Finset.mem_filter, mem_Ioc, not_le.2 (lt_add_one n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\n\u22a2 {x \u2208 Ioc 0 n | p \u2223 x}.card = n / p"}, {"line": "induction' n with n IH", "tactic_state": "case zero\np : \u2115\n\u22a2 {x \u2208 Ioc 0 0 | p \u2223 x}.card = 0 / p\n---\ncase succ\np n : \u2115\nIH : {x \u2208 Ioc 0 n | p \u2223 x}.card = n / p\n\u22a2 {x \u2208 Ioc 0 (n + 1) | p \u2223 x}.card = (n + 1) / p"}, {"line": "\u00b7 simp", "tactic_state": "case succ\np n : \u2115\nIH : {x \u2208 Ioc 0 n | p \u2223 x}.card = n / p\n\u22a2 {x \u2208 Ioc 0 (n + 1) | p \u2223 x}.card = (n + 1) / p"}, {"line": "have h1 : Ioc 0 n.succ = insert n.succ (Ioc 0 n) := by\n    rcases n.eq_zero_or_pos with (rfl | hn)\n    \u00b7 simp\n    simp_rw [\u2190 Ico_succ_succ, Ico_insert_right (succ_le_succ hn.le), Ico_succ_right]", "tactic_state": "case succ\np n : \u2115\nIH : {x \u2208 Ioc 0 n | p \u2223 x}.card = n / p\nh1 : Ioc 0 n.succ = insert n.succ (Ioc 0 n)\n\u22a2 {x \u2208 Ioc 0 (n + 1) | p \u2223 x}.card = (n + 1) / p"}, {"line": "simp [Nat.succ_div, add_ite, add_zero, h1, filter_insert, apply_ite card, card_insert_eq_ite, IH,\n    Finset.mem_filter, mem_Ioc, not_le.2 (lt_add_one n)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma card_multiples' (N n : \u2115) : #{k \u2208 range N.succ | k \u2260 0 \u2227 n \u2223 k} = N / n := by\n  induction N with\n    | zero => simp [Finset.filter_false_of_mem]\n    | succ N ih =>\n        rw [Finset.range_succ]\n        rw [Finset.filter_insert]\n        by_cases h : n \u2223 N.succ\n        \u00b7 simp [h, succ_div_of_dvd, ih]\n        \u00b7 simp [h, succ_div_of_not_dvd, ih]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Basic.lean", "context": {"open": ["Finset List Finsupp"], "variables": ["{a b m n p : \u2115}", "(a b)", "{a b}", "(a b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N n : \u2115\n\u22a2 {k \u2208 Finset.range N.succ | k \u2260 0 \u2227 n \u2223 k}.card = N / n"}, {"line": "induction N with\n    | zero => simp [Finset.filter_false_of_mem]\n    | succ N ih =>\n        rw [Finset.range_succ]\n        rw [Finset.filter_insert]\n        by_cases h : n \u2223 N.succ\n        \u00b7 simp [h, succ_div_of_dvd, ih]\n        \u00b7 simp [h, succ_div_of_not_dvd, ih]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_eq_primeFactorsList_multiset (n : \u2115) :\n    n.factorization = Multiset.toFinsupp (n.primeFactorsList : Multiset \u2115) := by\n  ext p\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n.factorization = Multiset.toFinsupp \u2191n.primeFactorsList"}, {"line": "ext p", "tactic_state": "case h\nn p : \u2115\n\u22a2 n.factorization p = (Multiset.toFinsupp \u2191n.primeFactorsList) p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.factorization_pos_of_dvd {n p : \u2115} (hp : p.Prime) (hn : n \u2260 0) (h : p \u2223 n) :\n    0 < n.factorization p := by\n  rwa [\u2190 primeFactorsList_count_eq, count_pos_iff, mem_primeFactorsList_iff_dvd hn hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\nhn : n \u2260 0\nh : p \u2223 n\n\u22a2 0 < n.factorization p"}, {"line": "rwa [\u2190 primeFactorsList_count_eq, count_pos_iff, mem_primeFactorsList_iff_dvd hn hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_eq_zero_iff (n p : \u2115) :\n    n.factorization p = 0 \u2194 \u00acp.Prime \u2228 \u00acp \u2223 n \u2228 n = 0 := by\n  simp_rw [\u2190 not_mem_support_iff, support_factorization, mem_primeFactors, not_and_or, not_ne_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\n\u22a2 n.factorization p = 0 \u2194 \u00acNat.Prime p \u2228 \u00acp \u2223 n \u2228 n = 0"}, {"line": "simp_rw [\u2190 not_mem_support_iff, support_factorization, mem_primeFactors, not_and_or, not_ne_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_eq_zero_of_non_prime (n : \u2115) {p : \u2115} (hp : \u00acp.Prime) :\n    n.factorization p = 0 := by simp [factorization_eq_zero_iff, hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhp : \u00acNat.Prime p\n\u22a2 n.factorization p = 0"}, {"line": "simp [factorization_eq_zero_iff, hp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_eq_zero_of_not_dvd {n p : \u2115} (h : \u00acp \u2223 n) : n.factorization p = 0 := by\n  simp [factorization_eq_zero_iff, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nh : \u00acp \u2223 n\n\u22a2 n.factorization p = 0"}, {"line": "simp [factorization_eq_zero_iff, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_eq_zero_of_remainder {p r : \u2115} (i : \u2115) (hr : \u00acp \u2223 r) :\n    (p * i + r).factorization p = 0 := by\n  apply factorization_eq_zero_of_not_dvd\n  rwa [\u2190 Nat.dvd_add_iff_right (Dvd.intro i rfl)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p r i : \u2115\nhr : \u00acp \u2223 r\n\u22a2 (p * i + r).factorization p = 0"}, {"line": "apply factorization_eq_zero_of_not_dvd", "tactic_state": "case h\np r i : \u2115\nhr : \u00acp \u2223 r\n\u22a2 \u00acp \u2223 p * i + r"}, {"line": "rwa [\u2190 Nat.dvd_add_iff_right (Dvd.intro i rfl)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_mul {a b : \u2115} (ha : a \u2260 0) (hb : b \u2260 0) :\n    (a * b).factorization = a.factorization + b.factorization := by\n  ext p\n  simp only [add_apply]\n  simp only [\u2190 primeFactorsList_count_eq]\n  simp only [perm_iff_count.mp (perm_primeFactorsList_mul ha hb) p]\n  simp only [count_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\n\u22a2 (a * b).factorization = a.factorization + b.factorization"}, {"line": "ext p", "tactic_state": "case h\na b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\n\u22a2 (a * b).factorization p = (a.factorization + b.factorization) p"}, {"line": "simp only [add_apply]", "tactic_state": "case h\na b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\n\u22a2 (a * b).factorization p = a.factorization p + b.factorization p"}, {"line": "simp only [\u2190 primeFactorsList_count_eq]", "tactic_state": "case h\na b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\n\u22a2 List.count p (a * b).primeFactorsList = List.count p a.primeFactorsList + List.count p b.primeFactorsList"}, {"line": "simp only [perm_iff_count.mp (perm_primeFactorsList_mul ha hb) p]", "tactic_state": "case h\na b : \u2115\nha : a \u2260 0\nhb : b \u2260 0\np : \u2115\n\u22a2 List.count p (a.primeFactorsList ++ b.primeFactorsList) =\n    List.count p a.primeFactorsList + List.count p b.primeFactorsList"}, {"line": "simp only [count_append]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_prod {\u03b1 : Type*} {S : Finset \u03b1} {g : \u03b1 \u2192 \u2115} (hS : \u2200 x \u2208 S, g x \u2260 0) :\n    (S.prod g).factorization = S.sum fun x => (g x).factorization := by\n  classical\n    ext p\n    refine Finset.induction_on' S ?_ ?_\n    \u00b7 simp\n    \u00b7 intro x T hxS hTS hxT IH\n      have hT : T.prod g \u2260 0 := prod_ne_zero_iff.mpr fun x hx => hS x (hTS hx)\n      simp [prod_insert hxT, sum_insert hxT, IH, factorization_mul (hS x hxS) hT]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Finset \u03b1\ng : \u03b1 \u2192 \u2115\nhS : \u2200 x \u2208 S, g x \u2260 0\n\u22a2 (S.prod g).factorization = \u2211 x \u2208 S, (g x).factorization"}, {"line": "classical\n    ext p\n    refine Finset.induction_on' S ?_ ?_\n    \u00b7 simp\n    \u00b7 intro x T hxS hTS hxT IH\n      have hT : T.prod g \u2260 0 := prod_ne_zero_iff.mpr fun x hx => hS x (hTS hx)\n      simp [prod_insert hxT, sum_insert hxT, IH, factorization_mul (hS x hxS) hT]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.factorization_pow {p k : \u2115} (hp : Prime p) : (p ^ k).factorization = single p k := by\n  simp [hp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p k : \u2115\nhp : sorry\n\u22a2 (p ^ k).factorization = fun\u2080 | p => k"}, {"line": "simp [hp]", "tactic_state": "p k : \u2115\nhp : sorry\n\u22a2 k \u2022 p.factorization = fun\u2080 | p => k"}]}
{"declaration": "theorem pow_succ_factorization_not_dvd {n p : \u2115} (hn : n \u2260 0) (hp : p.Prime) :\n    \u00acp ^ (n.factorization p + 1) \u2223 n := by\n  intro h\n  rw [\u2190 factorization_le_iff_dvd (pow_pos hp.pos _).ne' hn] at h\n  simpa [hp.factorization] using h p\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\nhn : n \u2260 0\nhp : Nat.Prime p\n\u22a2 \u00acp ^ (n.factorization p + 1) \u2223 n"}, {"line": "intro h", "tactic_state": "n p : \u2115\nhn : n \u2260 0\nhp : Nat.Prime p\nh : p ^ (n.factorization p + 1) \u2223 n\n\u22a2 False"}, {"line": "rw [\u2190 factorization_le_iff_dvd (pow_pos hp.pos _).ne' hn] at h", "tactic_state": "n p : \u2115\nhn : n \u2260 0\nhp : Nat.Prime p\nh : (p ^ (n.factorization p + 1)).factorization \u2264 n.factorization\n\u22a2 False"}, {"line": "simpa [hp.factorization] using h p", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_pow_factorization_eq_self {f : \u2115 \u2192\u2080 \u2115} (hf : \u2200 p : \u2115, p \u2208 f.support \u2192 Prime p) :\n    (f.prod (\u00b7 ^ \u00b7)).factorization = f := by\n  have h : \u2200 x : \u2115, x \u2208 f.support \u2192 x ^ f x \u2260 0 := fun p hp =>\n    pow_ne_zero _ (Prime.ne_zero (hf p hp))\n  simp only [Finsupp.prod]\n  simp only [factorization_prod h]\n  conv =>\n    rhs\n    rw [(sum_single f).symm]\n  exact sum_congr rfl fun p hp => Prime.factorization_pow (hf p hp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nhf : \u2200 p \u2208 f.support, sorry\n\u22a2 (f.prod fun x1 x2 => x1 ^ x2).factorization = f"}, {"line": "have h : \u2200 x : \u2115, x \u2208 f.support \u2192 x ^ f x \u2260 0 := fun p hp =>\n    pow_ne_zero _ (Prime.ne_zero (hf p hp))", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nhf : \u2200 p \u2208 f.support, sorry\nh : \u2200 x \u2208 f.support, x ^ f x \u2260 0\n\u22a2 (f.prod fun x1 x2 => x1 ^ x2).factorization = f"}, {"line": "simp only [Finsupp.prod]", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nhf : \u2200 p \u2208 f.support, sorry\nh : \u2200 x \u2208 f.support, x ^ f x \u2260 0\n\u22a2 (\u220f x \u2208 f.support, x ^ f x).factorization = f"}, {"line": "simp only [factorization_prod h]", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nhf : \u2200 p \u2208 f.support, sorry\nh : \u2200 x \u2208 f.support, x ^ f x \u2260 0\n\u22a2 \u2211 x \u2208 f.support, (x ^ f x).factorization = f"}, {"line": "conv =>\n    rhs\n    rw [(sum_single f).symm]", "tactic_state": "f : \u2115 \u2192\u2080 \u2115\nhf : \u2200 p \u2208 f.support, sorry\nh : \u2200 x \u2208 f.support, x ^ f x \u2260 0\n\u22a2 \u2211 x \u2208 f.support, (x ^ f x).factorization = f.sum single"}, {"line": "exact sum_congr rfl fun p hp => Prime.factorization_pow (hf p hp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_mul_apply_of_coprime {p a b : \u2115} (hab : Coprime a b) :\n    (a * b).factorization p = a.factorization p + b.factorization p := by\n  simp only [\u2190 primeFactorsList_count_eq]\n  simp only [perm_iff_count.mp (perm_primeFactorsList_mul_of_coprime hab)]\n  simp only [count_append]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a b : \u2115\nhab : a.Coprime b\n\u22a2 (a * b).factorization p = a.factorization p + b.factorization p"}, {"line": "simp only [\u2190 primeFactorsList_count_eq]", "tactic_state": "p a b : \u2115\nhab : a.Coprime b\n\u22a2 List.count p (a * b).primeFactorsList = List.count p a.primeFactorsList + List.count p b.primeFactorsList"}, {"line": "simp only [perm_iff_count.mp (perm_primeFactorsList_mul_of_coprime hab)]", "tactic_state": "p a b : \u2115\nhab : a.Coprime b\n\u22a2 List.count p (a.primeFactorsList ++ b.primeFactorsList) =\n    List.count p a.primeFactorsList + List.count p b.primeFactorsList"}, {"line": "simp only [count_append]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorization_mul_of_coprime {a b : \u2115} (hab : Coprime a b) :\n    (a * b).factorization = a.factorization + b.factorization := by\n  ext q\n  rw [Finsupp.add_apply]\n  rw [factorization_mul_apply_of_coprime hab]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhab : a.Coprime b\n\u22a2 (a * b).factorization = a.factorization + b.factorization"}, {"line": "ext q", "tactic_state": "case h\na b : \u2115\nhab : a.Coprime b\nq : \u2115\n\u22a2 (a * b).factorization q = (a.factorization + b.factorization) q"}, {"line": "rw [Finsupp.add_apply]", "tactic_state": "case h\na b : \u2115\nhab : a.Coprime b\nq : \u2115\n\u22a2 (a * b).factorization q = a.factorization q + b.factorization q"}, {"line": "rw [factorization_mul_apply_of_coprime hab]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ordProj_dvd (n p : \u2115) : ordProj[p] n \u2223 n := by\n  if hp : p.Prime then ?_ else simp [hp]\n  rw [\u2190 primeFactorsList_count_eq]\n  apply dvd_of_primeFactorsList_subperm (pow_ne_zero _ hp.ne_zero)\n  rw [hp.primeFactorsList_pow]\n  rw [List.subperm_ext_iff]\n  intro q hq\n  simp [List.eq_of_mem_replicate hq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Defs.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n p : \u2115\n\u22a2 p ^ n.factorization p \u2223 n"}, {"line": "if hp : p.Prime then ?_ else simp [hp]", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 p ^ n.factorization p \u2223 n"}, {"line": "rw [\u2190 primeFactorsList_count_eq]", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 p ^ List.count p n.primeFactorsList \u2223 n"}, {"line": "apply dvd_of_primeFactorsList_subperm (pow_ne_zero _ hp.ne_zero)", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 (p ^ List.count p n.primeFactorsList).primeFactorsList.Subperm n.primeFactorsList"}, {"line": "rw [hp.primeFactorsList_pow]", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 (replicate (List.count p n.primeFactorsList) p).Subperm n.primeFactorsList"}, {"line": "rw [List.subperm_ext_iff]", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\n\u22a2 \u2200 x \u2208 replicate (List.count p n.primeFactorsList) p,\n    List.count x (replicate (List.count p n.primeFactorsList) p) \u2264 List.count x n.primeFactorsList"}, {"line": "intro q hq", "tactic_state": "n p : \u2115\nhp : Nat.Prime p\nq : \u2115\nhq : q \u2208 replicate (List.count p n.primeFactorsList) p\n\u22a2 List.count q (replicate (List.count p n.primeFactorsList) p) \u2264 List.count q n.primeFactorsList"}, {"line": "simp [List.eq_of_mem_replicate hq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma prime_composite_induction {P : \u2115 \u2192 Prop} (zero : P 0) (one : P 1)\n    (prime : \u2200 p : \u2115, p.Prime \u2192 P p) (composite : \u2200 a, 2 \u2264 a \u2192 P a \u2192 \u2200 b, 2 \u2264 b \u2192 P b \u2192 P (a * b))\n    (n : \u2115) : P n := by\n  refine induction_on_primes zero one ?_ _\n  rintro p (_ | _ | a) hp ha\n  \u00b7 simpa\n  \u00b7 simpa using prime _ hp\n  \u00b7 exact composite _ hp.two_le (prime _ hp) _ a.one_lt_succ_succ ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Induction.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn : \u2115\n\u22a2 P n"}, {"line": "refine induction_on_primes zero one ?_ _", "tactic_state": "P : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn : \u2115\n\u22a2 \u2200 (p a : \u2115), Nat.Prime p \u2192 P a \u2192 P (p * a)"}, {"line": "rintro p (_ | _ | a) hp ha", "tactic_state": "case zero\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p : \u2115\nhp : Nat.Prime p\nha : P 0\n\u22a2 P (p * 0)\n---\ncase succ.zero\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p : \u2115\nhp : Nat.Prime p\nha : P (0 + 1)\n\u22a2 P (p * (0 + 1))\n---\ncase succ.succ\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p a : \u2115\nhp : Nat.Prime p\nha : P (a + 1 + 1)\n\u22a2 P (p * (a + 1 + 1))"}, {"line": "\u00b7 simpa", "tactic_state": "case succ.zero\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p : \u2115\nhp : Nat.Prime p\nha : P (0 + 1)\n\u22a2 P (p * (0 + 1))\n---\ncase succ.succ\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p a : \u2115\nhp : Nat.Prime p\nha : P (a + 1 + 1)\n\u22a2 P (p * (a + 1 + 1))"}, {"line": "\u00b7 simpa using prime _ hp", "tactic_state": "case succ.succ\nP : \u2115 \u2192 Prop\nzero : P 0\none : P 1\nprime : \u2200 (p : \u2115), Nat.Prime p \u2192 P p\ncomposite : \u2200 (a : \u2115), 2 \u2264 a \u2192 P a \u2192 \u2200 (b : \u2115), 2 \u2264 b \u2192 P b \u2192 P (a * b)\nn p a : \u2115\nhp : Nat.Prime p\nha : P (a + 1 + 1)\n\u22a2 P (p * (a + 1 + 1))"}, {"line": "\u00b7 exact composite _ hp.two_le (prime _ hp) _ a.one_lt_succ_succ ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem multiplicative_factorization' {\u03b2 : Type*} [CommMonoid \u03b2] (f : \u2115 \u2192 \u03b2)\n    (h_mult : \u2200 x y : \u2115, Coprime x y \u2192 f (x * y) = f x * f y) (hf0 : f 0 = 1) (hf1 : f 1 = 1) :\n    f n = n.factorization.prod fun p k => f (p ^ k) := by\n  obtain rfl | hn := eq_or_ne n 0\n  \u00b7 simpa\n  \u00b7 exact multiplicative_factorization _ h_mult hf1 hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Induction.lean", "context": {"open": ["Nat Finset List Finsupp"], "variables": ["{a b m n p : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nf : \u2115 \u2192 \u03b2\nh_mult : \u2200 (x y : \u2115), x.Coprime y \u2192 f (x * y) = f x * f y\nhf0 : f 0 = 1\nhf1 : f 1 = 1\n\u22a2 f n = n.factorization.prod fun p k => f (p ^ k)"}, {"line": "obtain rfl | hn := eq_or_ne n 0", "tactic_state": "case inl\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nf : \u2115 \u2192 \u03b2\nh_mult : \u2200 (x y : \u2115), x.Coprime y \u2192 f (x * y) = f x * f y\nhf0 : f 0 = 1\nhf1 : f 1 = 1\n\u22a2 f 0 = (Nat.factorization 0).prod fun p k => f (p ^ k)\n---\ncase inr\nn : \u2115\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nf : \u2115 \u2192 \u03b2\nh_mult : \u2200 (x y : \u2115), x.Coprime y \u2192 f (x * y) = f x * f y\nhf0 : f 0 = 1\nhf1 : f 1 = 1\nhn : n \u2260 0\n\u22a2 f n = n.factorization.prod fun p k => f (p ^ k)"}, {"line": "\u00b7 simpa", "tactic_state": "case inr\nn : \u2115\n\u03b2 : Type u_1\ninst\u271d : CommMonoid \u03b2\nf : \u2115 \u2192 \u03b2\nh_mult : \u2200 (x y : \u2115), x.Coprime y \u2192 f (x * y) = f x * f y\nhf0 : f 0 = 1\nhf1 : f 1 = 1\nhn : n \u2260 0\n\u22a2 f n = n.factorization.prod fun p k => f (p ^ k)"}, {"line": "\u00b7 exact multiplicative_factorization _ h_mult hf1 hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPrimePow.minFac_pow_factorization_eq {n : \u2115} (hn : IsPrimePow n) :\n    n.minFac ^ n.factorization n.minFac = n := by\n  obtain \u27e8p, k, hp, hk, rfl\u27e9 := hn\n  rw [\u2190 Nat.prime_iff] at hp\n  rw [hp.pow_minFac hk.ne']\n  rw [hp.factorization_pow]\n  rw [Finsupp.single_eq_same]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : IsPrimePow n\n\u22a2 n.minFac ^ n.factorization n.minFac = n"}, {"line": "obtain \u27e8p, k, hp, hk, rfl\u27e9 := hn", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Prime p\nhk : 0 < k\n\u22a2 (p ^ k).minFac ^ (p ^ k).factorization (p ^ k).minFac = p ^ k"}, {"line": "rw [\u2190 Nat.prime_iff] at hp", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 (p ^ k).minFac ^ (p ^ k).factorization (p ^ k).minFac = p ^ k"}, {"line": "rw [hp.pow_minFac hk.ne']", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 p ^ (p ^ k).factorization p = p ^ k"}, {"line": "rw [hp.factorization_pow]", "tactic_state": "case intro.intro.intro.intro\np k : \u2115\nhp : Nat.Prime p\nhk : 0 < k\n\u22a2 p ^ (fun\u2080 | p => k) p = p ^ k"}, {"line": "rw [Finsupp.single_eq_same]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimePow_of_minFac_pow_factorization_eq {n : \u2115}\n    (h : n.minFac ^ n.factorization n.minFac = n) (hn : n \u2260 1) : IsPrimePow n := by\n  rcases eq_or_ne n 0 with (rfl | hn')\n  \u00b7 simp_all\n  refine \u27e8_, _, (Nat.minFac_prime hn).prime, ?_, h\u27e9\n  simp [pos_iff_ne_zero, \u2190 Finsupp.mem_support_iff, Nat.support_factorization, hn',\n    Nat.minFac_prime hn, Nat.minFac_dvd]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : n.minFac ^ n.factorization n.minFac = n\nhn : n \u2260 1\n\u22a2 IsPrimePow n"}, {"line": "rcases eq_or_ne n 0 with (rfl | hn')", "tactic_state": "case inl\nh : Nat.minFac 0 ^ (Nat.factorization 0) (Nat.minFac 0) = 0\nhn : 0 \u2260 1\n\u22a2 IsPrimePow 0\n---\ncase inr\nn : \u2115\nh : n.minFac ^ n.factorization n.minFac = n\nhn : n \u2260 1\nhn' : n \u2260 0\n\u22a2 IsPrimePow n"}, {"line": "\u00b7 simp_all", "tactic_state": "case inr\nn : \u2115\nh : n.minFac ^ n.factorization n.minFac = n\nhn : n \u2260 1\nhn' : n \u2260 0\n\u22a2 IsPrimePow n"}, {"line": "refine \u27e8_, _, (Nat.minFac_prime hn).prime, ?_, h\u27e9", "tactic_state": "case inr\nn : \u2115\nh : n.minFac ^ n.factorization n.minFac = n\nhn : n \u2260 1\nhn' : n \u2260 0\n\u22a2 0 < n.factorization n.minFac"}, {"line": "simp [pos_iff_ne_zero, \u2190 Finsupp.mem_support_iff, Nat.support_factorization, hn',\n    Nat.minFac_prime hn, Nat.minFac_dvd]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimePow_iff_card_primeFactors_eq_one {n : \u2115} :\n    IsPrimePow n \u2194 n.primeFactors.card = 1 := by\n  simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 IsPrimePow n \u2194 n.primeFactors.card = 1"}, {"line": "simp_rw [isPrimePow_iff_factorization_eq_single, \u2190 Nat.support_factorization,\n    Finsupp.card_support_eq_one', pos_iff_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_ordCompl_eq_one_iff_isPrimePow {n : \u2115} (hn : n \u2260 1) :\n    IsPrimePow n \u2194 \u2203 p : \u2115, p.Prime \u2227 ordCompl[p] n = 1 := by\n  refine \u27e8fun h => IsPrimePow.exists_ordCompl_eq_one h, fun h => ?_\u27e9\n  rcases h with \u27e8p, pp, h\u27e9\n  rw [isPrimePow_nat_iff]\n  rw [\u2190 Nat.eq_of_dvd_of_div_eq_one (Nat.ordProj_dvd n p) h] at hn \u22a2\n  refine \u27e8p, n.factorization p, pp, ?_, by simp\u27e9\n  contrapose! hn\n  simp [Nat.le_zero.1 hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 1\n\u22a2 IsPrimePow n \u2194 \u2203 p, Nat.Prime p \u2227 n / p ^ n.factorization p = 1"}, {"line": "refine \u27e8fun h => IsPrimePow.exists_ordCompl_eq_one h, fun h => ?_\u27e9", "tactic_state": "n : \u2115\nhn : n \u2260 1\nh : \u2203 p, Nat.Prime p \u2227 n / p ^ n.factorization p = 1\n\u22a2 IsPrimePow n"}, {"line": "rcases h with \u27e8p, pp, h\u27e9", "tactic_state": "case intro.intro\nn : \u2115\nhn : n \u2260 1\np : \u2115\npp : Nat.Prime p\nh : n / p ^ n.factorization p = 1\n\u22a2 IsPrimePow n"}, {"line": "rw [isPrimePow_nat_iff]", "tactic_state": "case intro.intro\nn : \u2115\nhn : n \u2260 1\np : \u2115\npp : Nat.Prime p\nh : n / p ^ n.factorization p = 1\n\u22a2 \u2203 p k, Nat.Prime p \u2227 0 < k \u2227 p ^ k = n"}, {"line": "rw [\u2190 Nat.eq_of_dvd_of_div_eq_one (Nat.ordProj_dvd n p) h] at hn \u22a2", "tactic_state": "case intro.intro\nn p : \u2115\nhn : p ^ n.factorization p \u2260 1\npp : Nat.Prime p\nh : n / p ^ n.factorization p = 1\n\u22a2 \u2203 p_1 k, Nat.Prime p_1 \u2227 0 < k \u2227 p_1 ^ k = p ^ n.factorization p"}, {"line": "refine \u27e8p, n.factorization p, pp, ?_, by simp\u27e9", "tactic_state": "case intro.intro\nn p : \u2115\nhn : p ^ n.factorization p \u2260 1\npp : Nat.Prime p\nh : n / p ^ n.factorization p = 1\n\u22a2 0 < n.factorization p"}, {"line": "contrapose! hn", "tactic_state": "case intro.intro\nn p : \u2115\npp : Nat.Prime p\nh : n / p ^ n.factorization p = 1\nhn : n.factorization p \u2264 0\n\u22a2 p ^ n.factorization p = 1"}, {"line": "simp [Nat.le_zero.1 hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPrimePow_pow_iff {n k : \u2115} (hk : k \u2260 0) : IsPrimePow (n ^ k) \u2194 IsPrimePow n := by\n  simp only [isPrimePow_iff_unique_prime_dvd]\n  apply existsUnique_congr\n  simp only [and_congr_right_iff]\n  intro p hp\n  exact \u27e8hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhk : k \u2260 0\n\u22a2 IsPrimePow (n ^ k) \u2194 IsPrimePow n"}, {"line": "simp only [isPrimePow_iff_unique_prime_dvd]", "tactic_state": "n k : \u2115\nhk : k \u2260 0\n\u22a2 (\u2203! p, Nat.Prime p \u2227 p \u2223 n ^ k) \u2194 \u2203! p, Nat.Prime p \u2227 p \u2223 n"}, {"line": "apply existsUnique_congr", "tactic_state": "case h\nn k : \u2115\nhk : k \u2260 0\n\u22a2 \u2200 (a : \u2115), Nat.Prime a \u2227 a \u2223 n ^ k \u2194 Nat.Prime a \u2227 a \u2223 n"}, {"line": "simp only [and_congr_right_iff]", "tactic_state": "case h\nn k : \u2115\nhk : k \u2260 0\n\u22a2 \u2200 (a : \u2115), Nat.Prime a \u2192 (a \u2223 n ^ k \u2194 a \u2223 n)"}, {"line": "intro p hp", "tactic_state": "case h\nn k : \u2115\nhk : k \u2260 0\np : \u2115\nhp : Nat.Prime p\n\u22a2 p \u2223 n ^ k \u2194 p \u2223 n"}, {"line": "exact \u27e8hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsPrimePow.factorization_minFac_ne_zero {n : \u2115} (hn : IsPrimePow n) :\n    n.factorization n.minFac \u2260 0 := by\n  refine mt (Nat.factorization_eq_zero_iff _ _).mp ?_\n  push_neg\n  exact \u27e8n.minFac_prime hn.ne_one, n.minFac_dvd, hn.ne_zero\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : IsPrimePow n\n\u22a2 n.factorization n.minFac \u2260 0"}, {"line": "refine mt (Nat.factorization_eq_zero_iff _ _).mp ?_", "tactic_state": "n : \u2115\nhn : IsPrimePow n\n\u22a2 \u00ac(\u00acNat.Prime n.minFac \u2228 \u00acn.minFac \u2223 n \u2228 n = 0)"}, {"line": "push_neg", "tactic_state": "n : \u2115\nhn : IsPrimePow n\n\u22a2 Nat.Prime n.minFac \u2227 n.minFac \u2223 n \u2227 n \u2260 0"}, {"line": "exact \u27e8n.minFac_prime hn.ne_one, n.minFac_dvd, hn.ne_zero\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Nat.Primes.prodNatEquiv_apply (p : Nat.Primes) (k : \u2115) :\n    prodNatEquiv (p, k) = \u27e8p ^ (k + 1), p, k + 1, prime_iff.mp p.prop, k.add_one_pos, rfl\u27e9 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/PrimePow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Primes\nk : \u2115\n\u22a2 prodNatEquiv (p, k) = \u27e8\u2191p ^ (k + 1), \u22ef\u27e9"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma floorRoot_ne_zero : floorRoot n a \u2260 0 \u2194 n \u2260 0 \u2227 a \u2260 0 := by\n  simp +contextual [floorRoot, not_imp_not, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Root.lean", "context": {"open": ["Finsupp"], "variables": ["{a b n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\nx\u271d : Sort u_1\nfloorRoot : x\u271d\n\u22a2 sorry \u2260 0 \u2194 n \u2260 0 \u2227 a \u2260 0"}, {"line": "simp +contextual [floorRoot, not_imp_not, not_or]", "tactic_state": "a n : \u2115\nx\u271d : Sort u_1\nfloorRoot : x\u271d\n\u22a2 \u00acsorry () = 0 \u2194 \u00acn = 0 \u2227 \u00aca = 0"}]}
{"declaration": "lemma ceilRoot_ne_zero : ceilRoot n a \u2260 0 \u2194 n \u2260 0 \u2227 a \u2260 0 := by\n  simp +contextual [ceilRoot_def, not_imp_not, not_or]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Factorization/Root.lean", "context": {"open": ["Finsupp"], "variables": ["{a b n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a n : \u2115\nx\u271d : Sort u_1\nceilRoot : x\u271d\n\u22a2 sorry \u2260 0 \u2194 n \u2260 0 \u2227 a \u2260 0"}, {"line": "simp +contextual [ceilRoot_def, not_imp_not, not_or]", "tactic_state": "a n : \u2115\nx\u271d : Sort u_1\nceilRoot : x\u271d\n\u22a2 \u00acsorry () = 0 \u2194 \u00acn = 0 \u2227 \u00aca = 0"}]}
{"declaration": "theorem fib_add_two {n : \u2115} : fib (n + 2) = fib n + fib (n + 1) := by\n  simp [fib, Function.iterate_succ_apply']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [fib, Function.iterate_succ_apply']", "tactic_state": "x\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "theorem fib_le_fib_succ {n : \u2115} : fib n \u2264 fib (n + 1) := by cases n <;> simp [fib_add_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\n\u22a2 sorry \u2264 sorry"}, {"line": "cases n <;> simp [fib_add_two]", "tactic_state": "case zero\nx\u271d : Sort u_1\nfib : x\u271d\n\u22a2 sorry () \u2264 sorry ()\n---\ncase succ\nx\u271d : Sort u_1\nfib : x\u271d\nn\u271d : \u2115\n\u22a2 sorry () \u2264 sorry ()"}]}
{"declaration": "theorem le_fib_self {n : \u2115} (five_le_n : 5 \u2264 n) : n \u2264 fib n := by\n  induction' five_le_n with n five_le_n IH\n  \u00b7 -- 5 \u2264 fib 5\n    rfl\n  \u00b7 -- n + 1 \u2264 fib (n + 1) for 5 \u2264 n\n    rw [succ_le_iff]\n    calc\n      n \u2264 fib n := IH\n      _ < fib (n + 1) := fib_lt_fib_succ (le_trans (by decide) five_le_n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\nfive_le_n : 5 \u2264 n\n\u22a2 n \u2264 sorry"}, {"line": "induction' five_le_n with n five_le_n IH", "tactic_state": "case refl\nx\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\n\u22a2 5 \u2264 sorry\n---\ncase step\nx\u271d : Sort u_1\nfib : x\u271d\nn\u271d n : \u2115\nfive_le_n : Nat.le 5 n\nIH : n \u2264 sorry\n\u22a2 n.succ \u2264 sorry"}, {"line": "\u00b7 -- 5 \u2264 fib 5\n    rfl", "tactic_state": "case step\nx\u271d : Sort u_1\nfib : x\u271d\nn\u271d n : \u2115\nfive_le_n : Nat.le 5 n\nIH : n \u2264 sorry\n\u22a2 n.succ \u2264 sorry"}, {"line": "\u00b7 -- n + 1 \u2264 fib (n + 1) for 5 \u2264 n\n    rw [succ_le_iff]\n    calc\n      n \u2264 fib n := IH\n      _ < fib (n + 1) := fib_lt_fib_succ (le_trans (by decide) five_le_n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fib_coprime_fib_succ (n : \u2115) : Nat.Coprime (fib n) (fib (n + 1)) := by\n  induction' n with n ih\n  \u00b7 simp\n  \u00b7 simp only [fib_add_two, coprime_add_self_right, Coprime, ih.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Basic.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\n\u22a2 sorry.Coprime sorry"}, {"line": "induction' n with n ih", "tactic_state": "case zero\nx\u271d : Sort u_1\nfib : x\u271d\n\u22a2 sorry.Coprime sorry\n---\ncase succ\nx\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\nih : sorry.Coprime sorry\n\u22a2 sorry.Coprime sorry"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nx\u271d : Sort u_1\nfib : x\u271d\nn : \u2115\nih : sorry.Coprime sorry\n\u22a2 sorry.Coprime sorry"}, {"line": "\u00b7 simp only [fib_add_two, coprime_add_self_right, Coprime, ih.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsZeckendorfRep_nil : IsZeckendorfRep [] := by simp [IsZeckendorfRep]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Zeckendorf.lean", "context": {"open": ["List Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 [].IsZeckendorfRep"}, {"line": "simp [IsZeckendorfRep]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma greatestFib_sub_fib_greatestFib_le_greatestFib (hn : n \u2260 0) :\n    greatestFib (n - fib (greatestFib n)) \u2264 greatestFib n - 2 := by\n  rw [\u2190 Nat.lt_succ_iff]\n  rw [greatestFib_lt]\n  rw [tsub_lt_iff_right n.fib_greatestFib_le]\n  rw [Nat.sub_succ]\n  rw [succ_pred]\n  rw [\u2190 fib_add_one]\n  \u00b7 exact n.lt_fib_greatestFib_add_one\n  \u00b7 simpa\n  \u00b7 simpa [\u2190 succ_le_iff, tsub_eq_zero_iff_le] using hn.bot_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Fib/Zeckendorf.lean", "context": {"open": ["List Nat"], "variables": ["{m n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 (n - fib n.greatestFib).greatestFib \u2264 n.greatestFib - 2"}, {"line": "rw [\u2190 Nat.lt_succ_iff]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 (n - fib n.greatestFib).greatestFib < (n.greatestFib - 2).succ"}, {"line": "rw [greatestFib_lt]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n - fib n.greatestFib < fib (n.greatestFib - 2).succ"}, {"line": "rw [tsub_lt_iff_right n.fib_greatestFib_le]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n < fib (n.greatestFib - 2).succ + fib n.greatestFib"}, {"line": "rw [Nat.sub_succ]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n < fib (n.greatestFib - 1).pred.succ + fib n.greatestFib"}, {"line": "rw [succ_pred]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n < fib (n.greatestFib - 1) + fib n.greatestFib\n---\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib - 1 \u2260 0"}, {"line": "rw [\u2190 fib_add_one]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n < fib (n.greatestFib + 1)\n---\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib \u2260 0\n---\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib - 1 \u2260 0"}, {"line": "\u00b7 exact n.lt_fib_greatestFib_add_one", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib \u2260 0\n---\nn : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib - 1 \u2260 0"}, {"line": "\u00b7 simpa", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 n.greatestFib - 1 \u2260 0"}, {"line": "\u00b7 simpa [\u2190 succ_le_iff, tsub_eq_zero_iff_le] using hn.bot_lt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_prod_left_iff {t : Finset \u03b9} {s : \u03b9 \u2192 \u2115} {x : \u2115} :\n    Coprime (\u220f i \u2208 t, s i) x \u2194 \u2200 i \u2208 t, Coprime (s i) x := by\n  simpa using coprime_multiset_prod_left_iff (m := t.val.map s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\nt : Finset \u03b9\ns : \u03b9 \u2192 \u2115\nx : \u2115\n\u22a2 sorry \u2194 \u2200 i \u2208 t, sorry"}, {"line": "simpa using coprime_multiset_prod_left_iff (m := t.val.map s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_prod_right_iff {x : \u2115} {t : Finset \u03b9} {s : \u03b9 \u2192 \u2115} :\n    Coprime x (\u220f i \u2208 t, s i) \u2194 \u2200 i \u2208 t, Coprime x (s i) := by\n  simpa using coprime_multiset_prod_right_iff (m := t.val.map s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\nx : \u2115\nt : Finset \u03b9\ns : \u03b9 \u2192 \u2115\n\u22a2 sorry \u2194 \u2200 i \u2208 t, sorry"}, {"line": "simpa using coprime_multiset_prod_right_iff (m := t.val.map s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_fintype_prod_left_iff [Fintype \u03b9] {s : \u03b9 \u2192 \u2115} {x : \u2115} :\n    Coprime (\u220f i, s i) x \u2194 \u2200 i, Coprime (s i) x := by\n  simp [coprime_prod_left_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\ninst\u271d : Fintype \u03b9\ns : \u03b9 \u2192 \u2115\nx : \u2115\n\u22a2 sorry \u2194 ?m.860 \u2192 sorry"}, {"line": "simp [coprime_prod_left_iff]", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\ninst\u271d : Fintype \u03b9\ns : \u03b9 \u2192 \u2115\nx : \u2115\n\u22a2 sorry () \u2194 ?m.860 \u2192 sorry ()"}]}
{"declaration": "theorem coprime_fintype_prod_right_iff [Fintype \u03b9] {x : \u2115} {s : \u03b9 \u2192 \u2115} :\n    Coprime x (\u220f i, s i) \u2194 \u2200 i, Coprime x (s i) := by\n  simp [coprime_prod_right_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/BigOperators.lean", "context": {"open": [], "variables": ["{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\ninst\u271d : Fintype \u03b9\nx : \u2115\ns : \u03b9 \u2192 \u2115\n\u22a2 sorry \u2194 ?m.860 \u2192 sorry"}, {"line": "simp [coprime_prod_right_iff]", "tactic_state": "\u03b9 : Type u_1\nx\u271d : Sort u_2\nCoprime : x\u271d\ninst\u271d : Fintype \u03b9\nx : \u2115\ns : \u03b9 \u2192 \u2115\n\u22a2 sorry () \u2194 ?m.860 \u2192 sorry ()"}]}
{"declaration": "theorem lcm_pos {m n : \u2115} : 0 < m \u2192 0 < n \u2192 0 < m.lcm n := by\n  simp_rw [Nat.pos_iff_ne_zero]\n  exact lcm_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 0 < m \u2192 0 < n \u2192 0 < m.lcm n"}, {"line": "simp_rw [Nat.pos_iff_ne_zero]", "tactic_state": "m n : \u2115\n\u22a2 m \u2260 0 \u2192 n \u2260 0 \u2192 m.lcm n \u2260 0"}, {"line": "exact lcm_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lcm_mul_left {m n k : \u2115} : (m * n).lcm (m * k) = m * n.lcm k := by\n  apply dvd_antisymm\n  \u00b7 exact lcm_dvd (mul_dvd_mul_left m (dvd_lcm_left n k)) (mul_dvd_mul_left m (dvd_lcm_right n k))\n  \u00b7 have h : m \u2223 lcm (m * n) (m * k) := (dvd_mul_right m n).trans (dvd_lcm_left (m * n) (m * k))\n    rw [\u2190 dvd_div_iff_mul_dvd h]\n    rw [lcm_dvd_iff]\n    rw [dvd_div_iff_mul_dvd h]\n    rw [dvd_div_iff_mul_dvd h]\n    rw [\u2190 lcm_dvd_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n k : \u2115\n\u22a2 (m * n).lcm (m * k) = m * n.lcm k"}, {"line": "apply dvd_antisymm", "tactic_state": "case a\nm n k : \u2115\n\u22a2 (m * n).lcm (m * k) \u2223 m * n.lcm k\n---\ncase a\nm n k : \u2115\n\u22a2 m * n.lcm k \u2223 (m * n).lcm (m * k)"}, {"line": "\u00b7 exact lcm_dvd (mul_dvd_mul_left m (dvd_lcm_left n k)) (mul_dvd_mul_left m (dvd_lcm_right n k))", "tactic_state": "case a\nm n k : \u2115\n\u22a2 m * n.lcm k \u2223 (m * n).lcm (m * k)"}, {"line": "\u00b7 have h : m \u2223 lcm (m * n) (m * k) := (dvd_mul_right m n).trans (dvd_lcm_left (m * n) (m * k))\n    rw [\u2190 dvd_div_iff_mul_dvd h]\n    rw [lcm_dvd_iff]\n    rw [dvd_div_iff_mul_dvd h]\n    rw [dvd_div_iff_mul_dvd h]\n    rw [\u2190 lcm_dvd_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_coprime_zero_zero : \u00acCoprime 0 0 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\n\u22a2 \u00acsorry"}, {"line": "simp", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem coprime_one_left_iff (n : \u2115) : Coprime 1 n \u2194 True := by simp [Coprime]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\nn : \u2115\n\u22a2 sorry \u2194 True"}, {"line": "simp [Coprime]", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\nn : \u2115\n\u22a2 sorry ()"}]}
{"declaration": "theorem coprime_one_right_iff (n : \u2115) : Coprime n 1 \u2194 True := by simp [Coprime]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\nn : \u2115\n\u22a2 sorry \u2194 True"}, {"line": "simp [Coprime]", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\nn : \u2115\n\u22a2 sorry ()"}]}
{"declaration": "theorem gcd_mul_of_coprime_of_dvd {a b c : \u2115} (hac : Coprime a c) (b_dvd_c : b \u2223 c) :\n    gcd (a * b) c = b := by\n  rcases exists_eq_mul_left_of_dvd b_dvd_c with \u27e8d, rfl\u27e9\n  rw [gcd_mul_right]\n  convert one_mul b\n  exact Coprime.coprime_mul_right_right hac\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nCoprime : x\u271d\na b c : \u2115\nhac : sorry\nb_dvd_c : b \u2223 c\n\u22a2 gcd (a * b) c = b"}, {"line": "rcases exists_eq_mul_left_of_dvd b_dvd_c with \u27e8d, rfl\u27e9", "tactic_state": "case intro\nx\u271d : Sort u_1\nCoprime : x\u271d\na b : \u2115\nhac : sorry\nd : \u2115\nb_dvd_c : b \u2223 d * b\n\u22a2 gcd (a * b) (d * b) = b"}, {"line": "rw [gcd_mul_right]", "tactic_state": "case intro\nx\u271d : Sort u_1\nCoprime : x\u271d\na b : \u2115\nhac : sorry\nd : \u2115\nb_dvd_c : b \u2223 d * b\n\u22a2 gcd a d * normalize b = b"}, {"line": "convert one_mul b", "tactic_state": "case h.e'_2.h.e'_5\nx\u271d : Sort u_1\nCoprime : x\u271d\na b : \u2115\nhac : sorry\nd : \u2115\nb_dvd_c : b \u2223 d * b\n\u22a2 gcd a d = 1\n---\ncase h.e'_2.h.e'_6\nx\u271d : Sort u_1\nCoprime : x\u271d\na b : \u2115\nhac : sorry\nd : \u2115\nb_dvd_c : b \u2223 d * b\n\u22a2 normalize b = b"}, {"line": "exact Coprime.coprime_mul_right_right hac", "tactic_state": "case h.e'_2.h.e'_6\nx\u271d : Sort u_1\nCoprime : x\u271d\na b : \u2115\nhac : sorry\nd : \u2115\nb_dvd_c : b \u2223 d * b\n\u22a2 normalize b = b"}]}
{"declaration": "theorem gcd_mul_gcd_eq_iff_dvd_mul_of_coprime (hcop : Coprime n m) :\n    gcd x n * gcd x m = x \u2194 x \u2223 n * m := by\n  refine \u27e8fun h \u21a6 ?_, (dvd_antisymm ?_ <| dvd_gcd_mul_gcd_iff_dvd_mul.mpr \u00b7)\u27e9\n  refine h \u25b8 Nat.mul_dvd_mul ?_ ?_ <;> exact x.gcd_dvd_right _\n  refine (hcop.gcd_both x x).mul_dvd_of_dvd_of_dvd ?_ ?_ <;> exact x.gcd_dvd_left _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/GCD/Basic.lean", "context": {"open": [], "variables": ["{a a\u2081 a\u2082 b b\u2081 b\u2082 c : \u2115}", "{x n m : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x n m : \u2115\nx\u271d : Sort u_1\nCoprime : x\u271d\nhcop : sorry\n\u22a2 gcd x n * gcd x m = x \u2194 x \u2223 n * m"}, {"line": "refine \u27e8fun h \u21a6 ?_, (dvd_antisymm ?_ <| dvd_gcd_mul_gcd_iff_dvd_mul.mpr \u00b7)\u27e9", "tactic_state": "case refine_1\nx n m : \u2115\nx\u271d : Sort u_1\nCoprime : x\u271d\nhcop : sorry\nh : gcd x n * gcd x m = x\n\u22a2 x \u2223 n * m\n---\ncase refine_2\nx n m : \u2115\nx\u271d\u00b9 : Sort u_1\nCoprime : x\u271d\u00b9\nhcop : sorry\nx\u271d : x \u2223 n * m\n\u22a2 gcd x n * gcd x m \u2223 x"}, {"line": "refine h \u25b8 Nat.mul_dvd_mul ?_ ?_ <;> exact x.gcd_dvd_right _", "tactic_state": "case refine_2\nx n m : \u2115\nx\u271d\u00b9 : Sort u_1\nCoprime : x\u271d\u00b9\nhcop : sorry\nx\u271d : x \u2223 n * m\n\u22a2 gcd x n * gcd x m \u2223 x"}, {"line": "refine (hcop.gcd_both x x).mul_dvd_of_dvd_of_dvd ?_ ?_ <;> exact x.gcd_dvd_left _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_bddAbove_setOf_prime : \u00acBddAbove { p | Prime p } := by\n  rw [not_bddAbove_iff]\n  intro n\n  obtain \u27e8p, hi, hp\u27e9 := exists_infinite_primes n.succ\n  exact \u27e8p, hp, hi\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Infinite.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u00acBddAbove {p | Nat.Prime p}"}, {"line": "rw [not_bddAbove_iff]", "tactic_state": "\u22a2 \u2200 (x : \u2115), \u2203 y \u2208 {p | Nat.Prime p}, x < y"}, {"line": "intro n", "tactic_state": "n : \u2115\n\u22a2 \u2203 y \u2208 {p | Nat.Prime p}, n < y"}, {"line": "obtain \u27e8p, hi, hp\u27e9 := exists_infinite_primes n.succ", "tactic_state": "case intro.intro\nn p : \u2115\nhi : n.succ \u2264 p\nhp : Nat.Prime p\n\u22a2 \u2203 y \u2208 {p | Nat.Prime p}, n < y"}, {"line": "exact \u27e8p, hp, hi\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Prime.pow_inj {p q m n : \u2115} (hp : p.Prime) (hq : q.Prime)\n    (h : p ^ (m + 1) = q ^ (n + 1)) : p = q \u2227 m = n := by\n  have H := dvd_antisymm (Prime.dvd_of_dvd_pow hp <| h \u25b8 dvd_pow_self p (succ_ne_zero m))\n    (Prime.dvd_of_dvd_pow hq <| h.symm \u25b8 dvd_pow_self q (succ_ne_zero n))\n  exact \u27e8H, succ_inj.mp <| Nat.pow_right_injective hq.two_le (H \u25b8 h)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Int.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q m n : \u2115\nhp : Nat.Prime p\nhq : Nat.Prime q\nh : p ^ (m + 1) = q ^ (n + 1)\n\u22a2 p = q \u2227 m = n"}, {"line": "have H := dvd_antisymm (Prime.dvd_of_dvd_pow hp <| h \u25b8 dvd_pow_self p (succ_ne_zero m))\n    (Prime.dvd_of_dvd_pow hq <| h.symm \u25b8 dvd_pow_self q (succ_ne_zero n))", "tactic_state": "p q m n : \u2115\nhp : Nat.Prime p\nhq : Nat.Prime q\nh : p ^ (m + 1) = q ^ (n + 1)\nH : p = q\n\u22a2 p = q \u2227 m = n"}, {"line": "exact \u27e8H, succ_inj.mp <| Nat.pow_right_injective hq.two_le (H \u25b8 h)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.pow_minFac {p k : \u2115} (hp : p.Prime) (hk : k \u2260 0) : (p ^ k).minFac = p := by\n  rw [Nat.pow_minFac hk]\n  rw [hp.minFac_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Pow.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p k : \u2115\nhp : Nat.Prime p\nhk : k \u2260 0\n\u22a2 (p ^ k).minFac = p"}, {"line": "rw [Nat.pow_minFac hk]", "tactic_state": "p k : \u2115\nhp : Nat.Prime p\nhk : k \u2260 0\n\u22a2 p.minFac = p"}, {"line": "rw [hp.minFac_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_prime_mul {a b : \u2115} (a1 : a \u2260 1) (b1 : b \u2260 1) : \u00acPrime (a * b) := by\n  simp [prime_mul_iff, _root_.not_or, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\na1 : a \u2260 1\nb1 : b \u2260 1\n\u22a2 \u00acsorry"}, {"line": "simp [prime_mul_iff, _root_.not_or, *]", "tactic_state": "a b : \u2115\na1 : a \u2260 1\nb1 : b \u2260 1\n\u22a2 \u00acsorry ()"}]}
{"declaration": "theorem Prime.dvd_iff_eq {p a : \u2115} (hp : p.Prime) (a1 : a \u2260 1) : a \u2223 p \u2194 p = a := by\n  refine \u27e8?_, by rintro rfl; rfl\u27e9\n  rintro \u27e8j, rfl\u27e9\n  rcases prime_mul_iff.mp hp with (\u27e8_, rfl\u27e9 | \u27e8_, rfl\u27e9)\n  \u00b7 exact mul_one _\n  \u00b7 exact (a1 rfl).elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a : \u2115\nhp : Nat.Prime p\na1 : a \u2260 1\n\u22a2 a \u2223 p \u2194 p = a"}, {"line": "refine \u27e8?_, by rintro rfl; rfl\u27e9", "tactic_state": "p a : \u2115\nhp : Nat.Prime p\na1 : a \u2260 1\n\u22a2 a \u2223 p \u2192 p = a"}, {"line": "rintro \u27e8j, rfl\u27e9", "tactic_state": "case intro\na : \u2115\na1 : a \u2260 1\nj : \u2115\nhp : Nat.Prime (a * j)\n\u22a2 a * j = a"}, {"line": "rcases prime_mul_iff.mp hp with (\u27e8_, rfl\u27e9 | \u27e8_, rfl\u27e9)", "tactic_state": "case intro.inl.intro\na : \u2115\na1 : a \u2260 1\nleft\u271d : Nat.Prime a\nhp : Nat.Prime (a * 1)\n\u22a2 a * 1 = a\n---\ncase intro.inr.intro\nj : \u2115\nleft\u271d : Nat.Prime j\na1 : 1 \u2260 1\nhp : Nat.Prime (1 * j)\n\u22a2 1 * j = 1"}, {"line": "\u00b7 exact mul_one _", "tactic_state": "case intro.inr.intro\nj : \u2115\nleft\u271d : Nat.Prime j\na1 : 1 \u2260 1\nhp : Nat.Prime (1 * j)\n\u22a2 1 * j = 1"}, {"line": "\u00b7 exact (a1 rfl).elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.five_le_of_ne_two_of_ne_three {p : \u2115} (hp : p.Prime) (h_two : p \u2260 2)\n    (h_three : p \u2260 3) : 5 \u2264 p := by\n  by_contra! h\n  revert h_two h_three hp\n  decide +revert\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nh_two : p \u2260 2\nh_three : p \u2260 3\n\u22a2 5 \u2264 p"}, {"line": "by_contra! h", "tactic_state": "p : \u2115\nhp : Nat.Prime p\nh_two : p \u2260 2\nh_three : p \u2260 3\nh : p < 5\n\u22a2 False"}, {"line": "revert h_two h_three hp", "tactic_state": "p : \u2115\nh : p < 5\n\u22a2 Nat.Prime p \u2192 p \u2260 2 \u2192 p \u2260 3 \u2192 False"}, {"line": "decide +revert", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_of_forall_prime_mul_dvd {a b : \u2115}\n    (hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 a \u2192 p * a \u2223 b) : a \u2223 b := by\n  obtain rfl | ha := eq_or_ne a 1\n  \u00b7 apply one_dvd\n  obtain \u27e8p, hp\u27e9 := exists_prime_and_dvd ha\n  exact _root_.trans (dvd_mul_left a p) (hdvd p hp.1 hp.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nhdvd : \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 a \u2192 p * a \u2223 b\n\u22a2 a \u2223 b"}, {"line": "obtain rfl | ha := eq_or_ne a 1", "tactic_state": "case inl\nb : \u2115\nhdvd : \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 1 \u2192 p * 1 \u2223 b\n\u22a2 1 \u2223 b\n---\ncase inr\na b : \u2115\nhdvd : \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 a \u2192 p * a \u2223 b\nha : a \u2260 1\n\u22a2 a \u2223 b"}, {"line": "\u00b7 apply one_dvd", "tactic_state": "case inr\na b : \u2115\nhdvd : \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 a \u2192 p * a \u2223 b\nha : a \u2260 1\n\u22a2 a \u2223 b"}, {"line": "obtain \u27e8p, hp\u27e9 := exists_prime_and_dvd ha", "tactic_state": "case inr.intro\na b : \u2115\nhdvd : \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 a \u2192 p * a \u2223 b\nha : a \u2260 1\np : \u2115\nhp : Nat.Prime p \u2227 p \u2223 a\n\u22a2 a \u2223 b"}, {"line": "exact _root_.trans (dvd_mul_left a p) (hdvd p hp.1 hp.2)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma coprime_of_lt_minFac {n m : \u2115} (h\u2080 : m \u2260 0) (h : m < minFac n) : Coprime n m  := by\n  rw [\u2190 not_not (a := n.Coprime m)]\n  rw [Prime.not_coprime_iff_dvd]\n  push_neg\n  exact fun p hp hn hm \u21a6\n    ((le_of_dvd (by omega) hm).trans_lt <| h.trans_le <| minFac_le_of_dvd hp.two_le hn).false\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m : \u2115\nh\u2080 : m \u2260 0\nh : m < n.minFac\n\u22a2 n.Coprime m"}, {"line": "rw [\u2190 not_not (a := n.Coprime m)]", "tactic_state": "n m : \u2115\nh\u2080 : m \u2260 0\nh : m < n.minFac\n\u22a2 \u00ac\u00acn.Coprime m"}, {"line": "rw [Prime.not_coprime_iff_dvd]", "tactic_state": "n m : \u2115\nh\u2080 : m \u2260 0\nh : m < n.minFac\n\u22a2 \u00ac\u2203 p, Nat.Prime p \u2227 p \u2223 n \u2227 p \u2223 m"}, {"line": "push_neg", "tactic_state": "n m : \u2115\nh\u2080 : m \u2260 0\nh : m < n.minFac\n\u22a2 \u2200 (p : \u2115), Nat.Prime p \u2192 p \u2223 n \u2192 \u00acp \u2223 m"}, {"line": "exact fun p hp hn hm \u21a6\n    ((le_of_dvd (by omega) hm).trans_lt <| h.trans_le <| minFac_le_of_dvd hp.two_le hn).false", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.pow_eq_iff {p a k : \u2115} (hp : p.Prime) : a ^ k = p \u2194 a = p \u2227 k = 1 := by\n  refine \u27e8fun h => ?_, fun h => by rw [h.1, h.2, pow_one]\u27e9\n  rw [\u2190 h] at hp\n  rw [\u2190 h]\n  rw [hp.eq_one_of_pow]\n  rw [eq_self_iff_true]\n  rw [_root_.and_true]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p a k : \u2115\nhp : Nat.Prime p\n\u22a2 a ^ k = p \u2194 a = p \u2227 k = 1"}, {"line": "refine \u27e8fun h => ?_, fun h => by rw [h.1, h.2, pow_one]\u27e9", "tactic_state": "p a k : \u2115\nhp : Nat.Prime p\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1"}, {"line": "rw [\u2190 h] at hp", "tactic_state": "p a k : \u2115\nhp : Nat.Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = p \u2227 k = 1"}, {"line": "rw [\u2190 h]", "tactic_state": "p a k : \u2115\nhp : Nat.Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = a ^ k \u2227 k = 1"}, {"line": "rw [hp.eq_one_of_pow]", "tactic_state": "p a k : \u2115\nhp : Nat.Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = a ^ 1 \u2227 1 = 1"}, {"line": "rw [eq_self_iff_true]", "tactic_state": "p a k : \u2115\nhp : Nat.Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = a ^ 1 \u2227 True"}, {"line": "rw [_root_.and_true]", "tactic_state": "p a k : \u2115\nhp : Nat.Prime (a ^ k)\nh : a ^ k = p\n\u22a2 a = a ^ 1"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_iff_not_exists_prime_dvd {n : \u2115} : n = 1 \u2194 \u2200 p : \u2115, p.Prime \u2192 \u00acp \u2223 n := by\n  simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 n = 1 \u2194 \u2200 (p : \u2115), Nat.Prime p \u2192 \u00acp \u2223 n"}, {"line": "simpa using not_iff_not.mpr ne_one_iff_exists_prime_dvd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul {p : \u2115} (p_prime : Prime p) {m n k l : \u2115}\n    (hpm : p ^ k \u2223 m) (hpn : p ^ l \u2223 n) (hpmn : p ^ (k + l + 1) \u2223 m * n) :\n    p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n := by\n  have hpd : p ^ (k + l) * p \u2223 m * n := by\n      let hpmn' : p ^ (succ (k + l)) \u2223 m * n := hpmn\n      rwa [pow_succ'] at hpmn'\n  have hpd2 : p \u2223 m * n / p ^ (k + l) := dvd_div_of_mul_dvd hpd\n  have hpd3 : p \u2223 m * n / (p ^ k * p ^ l) := by simpa [pow_add] using hpd2\n  have hpd4 : p \u2223 m / p ^ k * (n / p ^ l) := by simpa [Nat.div_mul_div_comm hpm hpn] using hpd3\n  have hpd5 : p \u2223 m / p ^ k \u2228 p \u2223 n / p ^ l :=\n    (Prime.dvd_mul p_prime).1 hpd4\n  suffices p ^ k * p \u2223 m \u2228 p ^ l * p \u2223 n by rwa [_root_.pow_succ, _root_.pow_succ]\n  exact hpd5.elim (fun h : p \u2223 m / p ^ k => Or.inl <| mul_dvd_of_dvd_div hpm h)\n    fun h : p \u2223 n / p ^ l => Or.inr <| mul_dvd_of_dvd_div hpn h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Basic.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "have hpd : p ^ (k + l) * p \u2223 m * n := sorry", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "have hpd2 : p \u2223 m * n / p ^ (k + l) := dvd_div_of_mul_dvd hpd", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\nhpd2 : p \u2223 m * n / p ^ (k + l)\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "have hpd3 : p \u2223 m * n / (p ^ k * p ^ l) := sorry", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\nhpd2 : p \u2223 m * n / p ^ (k + l)\nhpd3 : p \u2223 m * n / (p ^ k * p ^ l)\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "have hpd4 : p \u2223 m / p ^ k * (n / p ^ l) := sorry", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\nhpd2 : p \u2223 m * n / p ^ (k + l)\nhpd3 : p \u2223 m * n / (p ^ k * p ^ l)\nhpd4 : p \u2223 m / p ^ k * (n / p ^ l)\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "have hpd5 : p \u2223 m / p ^ k \u2228 p \u2223 n / p ^ l :=\n    (Prime.dvd_mul p_prime).1 hpd4", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\nhpd2 : p \u2223 m * n / p ^ (k + l)\nhpd3 : p \u2223 m * n / (p ^ k * p ^ l)\nhpd4 : p \u2223 m / p ^ k * (n / p ^ l)\nhpd5 : p \u2223 m / p ^ k \u2228 p \u2223 n / p ^ l\n\u22a2 p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n"}, {"line": "suffices p ^ k * p \u2223 m \u2228 p ^ l * p \u2223 n by rwa [_root_.pow_succ, _root_.pow_succ]", "tactic_state": "p : \u2115\np_prime : sorry\nm n k l : \u2115\nhpm : p ^ k \u2223 m\nhpn : p ^ l \u2223 n\nhpmn : p ^ (k + l + 1) \u2223 m * n\nhpd : p ^ (k + l) * p \u2223 m * n\nhpd2 : p \u2223 m * n / p ^ (k + l)\nhpd3 : p \u2223 m * n / (p ^ k * p ^ l)\nhpd4 : p \u2223 m / p ^ k * (n / p ^ l)\nhpd5 : p \u2223 m / p ^ k \u2228 p \u2223 n / p ^ l\n\u22a2 p ^ k * p \u2223 m \u2228 p ^ l * p \u2223 n"}, {"line": "exact hpd5.elim (fun h : p \u2223 m / p ^ k => Or.inl <| mul_dvd_of_dvd_div hpm h)\n    fun h : p \u2223 n / p ^ l => Or.inr <| mul_dvd_of_dvd_div hpn h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.eq_one_or_self_of_dvd {p : \u2115} (pp : p.Prime) (m : \u2115) (hm : m \u2223 p) :\n    m = 1 \u2228 m = p := by\n  obtain \u27e8n, hn\u27e9 := hm\n  have := pp.isUnit_or_isUnit hn\n  rw [Nat.isUnit_iff] at this\n  rw [Nat.isUnit_iff] at this\n  apply Or.imp_right _ this\n  rintro rfl\n  rw [hn]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115\npp : Nat.Prime p\nm : \u2115\nhm : m \u2223 p\n\u22a2 m = 1 \u2228 m = p"}, {"line": "obtain \u27e8n, hn\u27e9 := hm", "tactic_state": "case intro\np : \u2115\npp : Nat.Prime p\nm n : \u2115\nhn : p = m * n\n\u22a2 m = 1 \u2228 m = p"}, {"line": "have := pp.isUnit_or_isUnit hn", "tactic_state": "case intro\np : \u2115\npp : Nat.Prime p\nm n : \u2115\nhn : p = m * n\nthis : IsUnit m \u2228 IsUnit n\n\u22a2 m = 1 \u2228 m = p"}, {"line": "rw [Nat.isUnit_iff] at this", "tactic_state": "case intro\np : \u2115\npp : Nat.Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 IsUnit n\n\u22a2 m = 1 \u2228 m = p"}, {"line": "rw [Nat.isUnit_iff] at this", "tactic_state": "case intro\np : \u2115\npp : Nat.Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 m = 1 \u2228 m = p"}, {"line": "apply Or.imp_right _ this", "tactic_state": "p : \u2115\npp : Nat.Prime p\nm n : \u2115\nhn : p = m * n\nthis : m = 1 \u2228 n = 1\n\u22a2 n = 1 \u2192 m = p"}, {"line": "rintro rfl", "tactic_state": "p : \u2115\npp : Nat.Prime p\nm : \u2115\nhn : p = m * 1\nthis : m = 1 \u2228 1 = 1\n\u22a2 m = p"}, {"line": "rw [hn]", "tactic_state": "p : \u2115\npp : Nat.Prime p\nm : \u2115\nhn : p = m * 1\nthis : m = 1 \u2228 1 = 1\n\u22a2 m = m * 1"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minFac_one : minFac 1 = 1 := by\n  simp [minFac, minFacAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 minFac 1 = 1"}, {"line": "simp [minFac, minFacAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minFac_two : minFac 2 = 2 := by\n  simp [minFac, minFacAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 minFac 2 = 2"}, {"line": "simp [minFac, minFacAux]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minFac_le_of_dvd {n : \u2115} : \u2200 {m : \u2115}, 2 \u2264 m \u2192 m \u2223 n \u2192 minFac n \u2264 m := by\n  by_cases n1 : n = 1\n  \u00b7 exact fun m2 _ => n1.symm \u25b8 le_trans (by simp) m2\n  \u00b7 apply (minFac_has_prop n1).2.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n m\u271d : \u2115\n\u22a2 2 \u2264 m\u271d \u2192 m\u271d \u2223 n \u2192 n.minFac \u2264 m\u271d"}, {"line": "by_cases n1 : n = 1", "tactic_state": "case pos\nn m\u271d : \u2115\nn1 : n = 1\n\u22a2 2 \u2264 m\u271d \u2192 m\u271d \u2223 n \u2192 n.minFac \u2264 m\u271d\n---\ncase neg\nn m\u271d : \u2115\nn1 : \u00acn = 1\n\u22a2 2 \u2264 m\u271d \u2192 m\u271d \u2223 n \u2192 n.minFac \u2264 m\u271d"}, {"line": "\u00b7 exact fun m2 _ => n1.symm \u25b8 le_trans (by simp) m2", "tactic_state": "case neg\nn m\u271d : \u2115\nn1 : \u00acn = 1\n\u22a2 2 \u2264 m\u271d \u2192 m\u271d \u2223 n \u2192 n.minFac \u2264 m\u271d"}, {"line": "\u00b7 apply (minFac_has_prop n1).2.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem minFac_pos (n : \u2115) : 0 < minFac n := by\n  by_cases n1 : n = 1\n  \u00b7 simp [n1]\n  \u00b7 exact (minFac_prime n1).pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 0 < n.minFac"}, {"line": "by_cases n1 : n = 1", "tactic_state": "case pos\nn : \u2115\nn1 : n = 1\n\u22a2 0 < n.minFac\n---\ncase neg\nn : \u2115\nn1 : \u00acn = 1\n\u22a2 0 < n.minFac"}, {"line": "\u00b7 simp [n1]", "tactic_state": "case neg\nn : \u2115\nn1 : \u00acn = 1\n\u22a2 0 < n.minFac"}, {"line": "\u00b7 exact (minFac_prime n1).pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_of_dvd {m n : \u2115} (H : \u2200 k, Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n) : Coprime m n := by\n  rw [coprime_iff_gcd_eq_one]\n  by_contra g2\n  obtain \u27e8p, hp, hpdvd\u27e9 := exists_prime_and_dvd g2\n  apply H p hp <;> apply dvd_trans hpdvd\n  \u00b7 exact gcd_dvd_left _ _\n  \u00b7 exact gcd_dvd_right _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Defs.lean", "context": {"open": ["Bool Subtype Nat"], "variables": ["{n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\n\u22a2 m.Coprime n"}, {"line": "rw [coprime_iff_gcd_eq_one]", "tactic_state": "m n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\n\u22a2 m.gcd n = 1"}, {"line": "by_contra g2", "tactic_state": "m n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\ng2 : \u00acm.gcd n = 1\n\u22a2 False"}, {"line": "obtain \u27e8p, hp, hpdvd\u27e9 := exists_prime_and_dvd g2", "tactic_state": "case intro.intro\nm n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\ng2 : \u00acm.gcd n = 1\np : \u2115\nhp : Nat.Prime p\nhpdvd : p \u2223 m.gcd n\n\u22a2 False"}, {"line": "apply H p hp <;> apply dvd_trans hpdvd", "tactic_state": "case intro.intro.a\nm n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\ng2 : \u00acm.gcd n = 1\np : \u2115\nhp : Nat.Prime p\nhpdvd : p \u2223 m.gcd n\n\u22a2 m.gcd n \u2223 m\n---\ncase intro.intro.a\nm n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\ng2 : \u00acm.gcd n = 1\np : \u2115\nhp : Nat.Prime p\nhpdvd : p \u2223 m.gcd n\n\u22a2 m.gcd n \u2223 n"}, {"line": "\u00b7 exact gcd_dvd_left _ _", "tactic_state": "case intro.intro.a\nm n : \u2115\nH : \u2200 (k : \u2115), Nat.Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n\ng2 : \u00acm.gcd n = 1\np : \u2115\nhp : Nat.Prime p\nhpdvd : p \u2223 m.gcd n\n\u22a2 m.gcd n \u2223 n"}, {"line": "\u00b7 exact gcd_dvd_right _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coprime_factorial_iff {m n : \u2115} (hm : m \u2260 1) :\n    m.Coprime n ! \u2194 n < m.minFac := by\n  rw [\u2190 not_le]\n  rw [iff_not_comm]\n  rw [Nat.Prime.not_coprime_iff_dvd]\n  constructor\n  \u00b7 intro h\n    exact \u27e8m.minFac, minFac_prime hm, minFac_dvd m, Nat.dvd_factorial (minFac_pos m) h\u27e9\n  \u00b7 rintro \u27e8p, hp, hdvd, hdvd'\u27e9\n    exact le_trans (minFac_le_of_dvd hp.two_le hdvd) (hp.dvd_factorial.mp hdvd')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Nat/Prime/Factorial.lean", "context": {"open": ["Bool Subtype", "Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\nhm : m \u2260 1\n\u22a2 m.Coprime n.factorial \u2194 n < m.minFac"}, {"line": "rw [\u2190 not_le]", "tactic_state": "m n : \u2115\nhm : m \u2260 1\n\u22a2 m.Coprime n.factorial \u2194 \u00acm.minFac \u2264 n"}, {"line": "rw [iff_not_comm]", "tactic_state": "m n : \u2115\nhm : m \u2260 1\n\u22a2 m.minFac \u2264 n \u2194 \u00acm.Coprime n.factorial"}, {"line": "rw [Nat.Prime.not_coprime_iff_dvd]", "tactic_state": "m n : \u2115\nhm : m \u2260 1\n\u22a2 m.minFac \u2264 n \u2194 \u2203 p, Nat.Prime p \u2227 p \u2223 m \u2227 p \u2223 n.factorial"}, {"line": "constructor", "tactic_state": "case mp\nm n : \u2115\nhm : m \u2260 1\n\u22a2 m.minFac \u2264 n \u2192 \u2203 p, Nat.Prime p \u2227 p \u2223 m \u2227 p \u2223 n.factorial\n---\ncase mpr\nm n : \u2115\nhm : m \u2260 1\n\u22a2 (\u2203 p, Nat.Prime p \u2227 p \u2223 m \u2227 p \u2223 n.factorial) \u2192 m.minFac \u2264 n"}, {"line": "\u00b7 intro h\n    exact \u27e8m.minFac, minFac_prime hm, minFac_dvd m, Nat.dvd_factorial (minFac_pos m) h\u27e9", "tactic_state": "case mpr\nm n : \u2115\nhm : m \u2260 1\n\u22a2 (\u2203 p, Nat.Prime p \u2227 p \u2223 m \u2227 p \u2223 n.factorial) \u2192 m.minFac \u2264 n"}, {"line": "\u00b7 rintro \u27e8p, hp, hdvd, hdvd'\u27e9\n    exact le_trans (minFac_le_of_dvd hp.two_le hdvd) (hp.dvd_factorial.mp hdvd')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bit_zero (b : Bool) : (b :: zero b) = zero b := by cases b <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Bitwise.lean", "context": {"open": ["List (Vector)", "NzsNum"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nzero : x\u271d\nb : Bool\n\u22a2 sorry = sorry"}, {"line": "cases b <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_one (n : PosNum) : n + 1 = succ n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : PosNum\n\u22a2 \u2191n + 1 = (\u2191n).succ"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_zero (n : Num) : n + 0 = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Num\n\u22a2 n + 0 = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_add (n : Num) : 0 + n = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Num\n\u22a2 0 + n = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofNat'_zero : Num.ofNat' 0 = 0 := by simp [Num.ofNat']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Num.ofNat' 0 = 0"}, {"line": "simp [Num.ofNat']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_ofNat' (m n) : Num.ofNat' (m + n) = Num.ofNat' m + Num.ofNat' n := by\n  induction n\n  \u00b7 simp only [Nat.add_zero, ofNat'_zero, add_zero]\n  \u00b7 simp only [Nat.add_succ, Nat.add_zero, ofNat'_succ, add_one, add_succ, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : \u2115\n\u22a2 Num.ofNat' (m + n) = Num.ofNat' m + Num.ofNat' n"}, {"line": "induction n", "tactic_state": "case zero\nm : \u2115\n\u22a2 Num.ofNat' (m + 0) = Num.ofNat' m + Num.ofNat' 0\n---\ncase succ\nm n\u271d : \u2115\na\u271d : Num.ofNat' (m + n\u271d) = Num.ofNat' m + Num.ofNat' n\u271d\n\u22a2 Num.ofNat' (m + (n\u271d + 1)) = Num.ofNat' m + Num.ofNat' (n\u271d + 1)"}, {"line": "\u00b7 simp only [Nat.add_zero, ofNat'_zero, add_zero]", "tactic_state": "case succ\nm n\u271d : \u2115\na\u271d : Num.ofNat' (m + n\u271d) = Num.ofNat' m + Num.ofNat' n\u271d\n\u22a2 Num.ofNat' (m + (n\u271d + 1)) = Num.ofNat' m + Num.ofNat' (n\u271d + 1)"}, {"line": "\u00b7 simp only [Nat.add_succ, Nat.add_zero, ofNat'_succ, add_one, add_succ, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bit_to_nat (b n) : (bit b n : \u2115) = Nat.bit b n := by cases b <;> simp [bit, two_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : Bool\nn : PosNum\n\u22a2 sorry = Nat.bit b \u2191n"}, {"line": "cases b <;> simp [bit, two_mul]", "tactic_state": "case false\nn : PosNum\n\u22a2 sorry () = \u2191n + \u2191n\n---\ncase true\nn : PosNum\n\u22a2 sorry () = \u2191n + \u2191n + 1"}]}
{"declaration": "theorem zneg_toZNum (n : Num) : -n.toZNum = n.toZNumNeg := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Num\n\u22a2 -n.toZNum = n.toZNumNeg"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zneg_toZNumNeg (n : Num) : -n.toZNumNeg = n.toZNum := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : Num\n\u22a2 -n.toZNumNeg = n.toZNum"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_toZNum (m n : Num) : Num.toZNum (m + n) = m.toZNum + n.toZNum := by\n  cases m <;> cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "m n : Num\n\u22a2 (m + n).toZNum = m.toZNum + n.toZNum"}, {"line": "cases m <;> cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castNum_and : \u2200 m n : Num, \u2191(m &&& n) = (\u2191m &&& \u2191n : \u2115) := by\n  apply castNum_eq_bitwise PosNum.land <;> intros <;> (try cases_type* Bool) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (m n : Num), \u2191(m &&& n) = \u2191m &&& \u2191n"}, {"line": "apply castNum_eq_bitwise PosNum.land <;> intros <;> (try cases_type* Bool) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castNum_ldiff : \u2200 m n : Num, (ldiff m n : \u2115) = Nat.ldiff m n := by\n  apply castNum_eq_bitwise PosNum.ldiff <;> intros <;> (try cases_type* Bool) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (m n : Num), \u2191(m.ldiff n) = (\u2191m).ldiff \u2191n"}, {"line": "apply castNum_eq_bitwise PosNum.ldiff <;> intros <;> (try cases_type* Bool) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem castNum_xor : \u2200 m n : Num, \u2191(m ^^^ n) = (\u2191m ^^^ \u2191n : \u2115) := by\n  apply castNum_eq_bitwise PosNum.lxor <;> intros <;> (try cases_type* Bool) <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/Lemmas.lean", "context": {"open": ["Int", "PosNum", "Num", "PosNum", "Num", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (m n : Num), \u2191(m ^^^ n) = \u2191m ^^^ \u2191n"}, {"line": "apply castNum_eq_bitwise PosNum.lxor <;> intros <;> (try cases_type* Bool) <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zneg_zneg (n : ZNum) : - -n = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZNum\n\u22a2 - -n = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zneg_bit1 (n : ZNum) : -n.bit1 = (-n).bitm1 := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZNum\n\u22a2 -n.bit1 = (-n).bitm1"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zneg_bitm1 (n : ZNum) : -n.bitm1 = (-n).bit1 := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZNum\n\u22a2 -n.bitm1 = (-n).bit1"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_zero (n : ZNum) : n + 0 = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZNum\n\u22a2 n + 0 = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_add (n : ZNum) : 0 + n = n := by cases n <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : ZNum\n\u22a2 0 + n = n"}, {"line": "cases n <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem to_nat_eq_succ_pred (n : PosNum) : (n : \u2115) = n.pred' + 1 := by\n  rw [\u2190 Num.succ'_to_nat]\n  rw [n.succ'_pred']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : PosNum\n\u22a2 \u2191n = \u2191n.pred' + 1"}, {"line": "rw [\u2190 Num.succ'_to_nat]", "tactic_state": "n : PosNum\n\u22a2 \u2191n = \u2191n.pred'.succ'"}, {"line": "rw [n.succ'_pred']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_sub [AddCommGroupWithOne \u03b1] (m n) : ((m - n : ZNum) : \u03b1) = m - n := by\n  simp [sub_eq_neg_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Num/ZNum.lean", "context": {"open": ["Int", "PosNum"], "variables": ["{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}", "{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : AddCommGroupWithOne \u03b1\nm n : ZNum\n\u22a2 \u2191(m - n) = \u2191m - \u2191n"}, {"line": "simp [sub_eq_neg_add]", "tactic_state": "\u03b1 : Type u_4\ninst\u271d : AddCommGroupWithOne \u03b1\nm n : ZNum\n\u22a2 \u2191(-n + m) = \u2191m - \u2191n"}]}
{"declaration": "theorem mem_map {f : \u03b1 \u2192 \u03b2} {y : \u03b2} {o : Option \u03b1} : y \u2208 o.map f \u2194 \u2203 x \u2208 o, f x = y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\ny : \u03b2\no : Option \u03b1\n\u22a2 y \u2208 Option.map f o \u2194 \u2203 x \u2208 o, f x = y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_map_of_injective {f : \u03b1 \u2192 \u03b2} (H : Function.Injective f) {a : \u03b1} {o : Option \u03b1} :\n    f a \u2208 o.map f \u2194 a \u2208 o := by\n  aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\nH : Function.Injective f\na : \u03b1\no : Option \u03b1\n\u22a2 f a \u2208 Option.map f o \u2194 a \u2208 o"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_mem_map {f : \u03b1 \u2192 \u03b2} {o : Option \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2200 y \u2208 o.map f, p y) \u2194 \u2200 x \u2208 o, p (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\no : Option \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2200 y \u2208 Option.map f o, p y) \u2194 \u2200 x \u2208 o, p (f x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_mem_map {f : \u03b1 \u2192 \u03b2} {o : Option \u03b1} {p : \u03b2 \u2192 Prop} :\n    (\u2203 y \u2208 o.map f, p y) \u2194 \u2203 x \u2208 o, p (f x) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b2\no : Option \u03b1\np : \u03b2 \u2192 Prop\n\u22a2 (\u2203 y \u2208 Option.map f o, p y) \u2194 \u2203 x \u2208 o, p (f x)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_bind' (f : \u03b2 \u2192 \u03b3) (x : Option \u03b1) (g : \u03b1 \u2192 Option \u03b2) :\n    Option.map f (x.bind g) = x.bind fun a \u21a6 Option.map f (g a) := by cases x <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b2 \u2192 \u03b3\nx : Option \u03b1\ng : \u03b1 \u2192 Option \u03b2\n\u22a2 Option.map f (x.bind g) = x.bind fun a => Option.map f (g a)"}, {"line": "cases x <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem none_orElse' (x : Option \u03b1) : none.orElse (fun _ \u21a6 x) = x := by cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : Option \u03b1\n\u22a2 (none.orElse fun x_1 => x) = x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orElse_none' (x : Option \u03b1) : x.orElse (fun _ \u21a6 none) = x := by cases x <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : Option \u03b1\n\u22a2 (x.orElse fun x => none) = x"}, {"line": "cases x <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem getD_default_eq_iget [Inhabited \u03b1] (o : Option \u03b1) :\n    o.getD default = o.iget := by cases o <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Inhabited \u03b1\no : Option \u03b1\n\u22a2 o.getD default = o.iget"}, {"line": "cases o <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem guard_eq_some' {p : Prop} [Decidable p] (u) : _root_.guard p = some u \u2194 p := by\n  cases u\n  by_cases h : p <;> simp [_root_.guard, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : Prop\ninst\u271d : Decidable p\nu : Unit\n\u22a2 guard p = some u \u2194 p"}, {"line": "cases u", "tactic_state": "case unit\np : Prop\ninst\u271d : Decidable p\n\u22a2 guard p = some PUnit.unit \u2194 p"}, {"line": "by_cases h : p <;> simp [_root_.guard, h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma casesOn'_eq_elim (b : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : Option \u03b1) :\n    Option.casesOn' a b f = Option.elim a b f := by cases a <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nb : \u03b2\nf : \u03b1 \u2192 \u03b2\na : Option \u03b1\n\u22a2 a.casesOn' b f = a.elim b f"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orElse_eq_some (o o' : Option \u03b1) (x : \u03b1) :\n    (o <|> o') = some x \u2194 o = some x \u2228 o = none \u2227 o' = some x := by\n  cases o\n  \u00b7 simp only [true_and, false_or, eq_self_iff_true, none_orElse, reduceCtorEq]\n  \u00b7 simp only [some_orElse, or_false, false_and, reduceCtorEq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\no o' : Option \u03b1\nx : \u03b1\n\u22a2 (o <|> o') = some x \u2194 o = some x \u2228 o = none \u2227 o' = some x"}, {"line": "cases o", "tactic_state": "case none\n\u03b1 : Type u_1\no' : Option \u03b1\nx : \u03b1\n\u22a2 (none <|> o') = some x \u2194 none = some x \u2228 none = none \u2227 o' = some x\n---\ncase some\n\u03b1 : Type u_1\no' : Option \u03b1\nx val\u271d : \u03b1\n\u22a2 (some val\u271d <|> o') = some x \u2194 some val\u271d = some x \u2228 some val\u271d = none \u2227 o' = some x"}, {"line": "\u00b7 simp only [true_and, false_or, eq_self_iff_true, none_orElse, reduceCtorEq]", "tactic_state": "case some\n\u03b1 : Type u_1\no' : Option \u03b1\nx val\u271d : \u03b1\n\u22a2 (some val\u271d <|> o') = some x \u2194 some val\u271d = some x \u2228 some val\u271d = none \u2227 o' = some x"}, {"line": "\u00b7 simp only [some_orElse, or_false, false_and, reduceCtorEq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem orElse_eq_none (o o' : Option \u03b1) : (o <|> o') = none \u2194 o = none \u2227 o' = none := by\n  cases o\n  \u00b7 simp only [true_and, none_orElse, eq_self_iff_true]\n  \u00b7 simp only [some_orElse, reduceCtorEq, false_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\no o' : Option \u03b1\n\u22a2 (o <|> o') = none \u2194 o = none \u2227 o' = none"}, {"line": "cases o", "tactic_state": "case none\n\u03b1 : Type u_1\no' : Option \u03b1\n\u22a2 (none <|> o') = none \u2194 none = none \u2227 o' = none\n---\ncase some\n\u03b1 : Type u_1\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (some val\u271d <|> o') = none \u2194 some val\u271d = none \u2227 o' = none"}, {"line": "\u00b7 simp only [true_and, none_orElse, eq_self_iff_true]", "tactic_state": "case some\n\u03b1 : Type u_1\no' : Option \u03b1\nval\u271d : \u03b1\n\u22a2 (some val\u271d <|> o') = none \u2194 some val\u271d = none \u2227 o' = none"}, {"line": "\u00b7 simp only [some_orElse, reduceCtorEq, false_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_none_some (f : Option \u03b1 \u2192 \u03b2) (i : Option \u03b1) : i.elim (f none) (f \u2218 some) = f i := by\n  cases i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Option \u03b1 \u2192 \u03b2\ni : Option \u03b1\n\u22a2 i.elim (f none) (f \u2218 some) = f i"}, {"line": "cases i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_comp (h : \u03b1 \u2192 \u03b2) {f : \u03b3 \u2192 \u03b1} {x : \u03b1} {i : Option \u03b3} :\n    (i.elim (h x) fun j => h (f j)) = h (i.elim x f) := by cases i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nh : \u03b1 \u2192 \u03b2\nf : \u03b3 \u2192 \u03b1\nx : \u03b1\ni : Option \u03b3\n\u22a2 (i.elim (h x) fun j => h (f j)) = h (i.elim x f)"}, {"line": "cases i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_comp\u2082 (h : \u03b1 \u2192 \u03b2 \u2192 \u03b3) {f : \u03b3 \u2192 \u03b1} {x : \u03b1} {g : \u03b3 \u2192 \u03b2} {y : \u03b2}\n    {i : Option \u03b3} : (i.elim (h x y) fun j => h (f j) (g j)) = h (i.elim x f) (i.elim y g) := by\n  cases i <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nh : \u03b1 \u2192 \u03b2 \u2192 \u03b3\nf : \u03b3 \u2192 \u03b1\nx : \u03b1\ng : \u03b3 \u2192 \u03b2\ny : \u03b2\ni : Option \u03b3\n\u22a2 (i.elim (h x y) fun j => h (f j) (g j)) = h (i.elim x f) (i.elim y g)"}, {"line": "cases i <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bnot_isSome (a : Option \u03b1) : (! a.isSome) = a.isNone := by\n  cases a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : Option \u03b1\n\u22a2 (!a.isSome) = a.isNone"}, {"line": "cases a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bnot_comp_isSome : (! \u00b7) \u2218 @Option.isSome \u03b1 = Option.isNone := by\n  funext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (fun x => !x) \u2218 Option.isSome = Option.isNone"}, {"line": "funext", "tactic_state": "case h\n\u03b1 : Type u_1\nx\u271d : Option \u03b1\n\u22a2 ((fun x => !x) \u2218 Option.isSome) x\u271d = x\u271d.isNone"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bnot_isNone (a : Option \u03b1) : (! a.isNone) = a.isSome := by\n  cases a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : Option \u03b1\n\u22a2 (!a.isNone) = a.isSome"}, {"line": "cases a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma bnot_comp_isNone : (! \u00b7) \u2218 @Option.isNone \u03b1 = Option.isSome := by\n  funext x\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u22a2 (fun x => !x) \u2218 Option.isNone = Option.isSome"}, {"line": "funext x", "tactic_state": "case h\n\u03b1 : Type u_1\nx : Option \u03b1\n\u22a2 ((fun x => !x) \u2218 Option.isNone) x = x.isSome"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNone_eq_false_iff (a : Option \u03b1) : Option.isNone a = false \u2194 Option.isSome a := by\n  cases a <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\na : Option \u03b1\n\u22a2 a.isNone = false \u2194 a.isSome = true"}, {"line": "cases a <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_none_iff_forall_some_ne {o : Option \u03b1} : o = none \u2194 \u2200 a : \u03b1, some a \u2260 o := by\n  apply not_iff_not.1\n  simpa only [not_forall,not_not] using Option.ne_none_iff_exists\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "{p : \u03b1 \u2192 Prop} (f : \u2200 a : \u03b1, p a \u2192 \u03b2) (x : Option \u03b1)", "{f x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\no : Option \u03b1\n\u22a2 o = none \u2194 \u2200 (a : \u03b1), some a \u2260 o"}, {"line": "apply not_iff_not.1", "tactic_state": "\u03b1 : Type u_1\no : Option \u03b1\n\u22a2 \u00aco = none \u2194 \u00ac\u2200 (a : \u03b1), some a \u2260 o"}, {"line": "simpa only [not_forall,not_not] using Option.ne_none_iff_exists", "tactic_state": "No Goals!"}]}
{"declaration": "lemma elim'_eq_elim {\u03b1 \u03b2 : Type*} (b : \u03b2) (f : \u03b1 \u2192 \u03b2) (a : Option \u03b1) :\n    Option.elim' b f a = Option.elim a b f := by\n  cases a <;> rfl\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nb : \u03b2\nf : \u03b1 \u2192 \u03b2\na : Option \u03b1\n\u22a2 Option.elim' b f a = a.elim b f"}, {"line": "cases a <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_some_iff {\u03b1 : Type*} {a b : \u03b1} : a \u2208 some b \u2194 b = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/Defs.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\na b : \u03b1\n\u22a2 a \u2208 some b \u2194 b = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map\u2082_eq_some_iff {c : \u03b3} :\n    map\u2082 f a b = some c \u2194 \u2203 a' b', a' \u2208 a \u2227 b' \u2208 b \u2227 f a' b' = c := by\n  simp [map\u2082, bind_eq_some]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : Option \u03b1} {b : Option \u03b2} {c : Option \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : Option \u03b1\nb : Option \u03b2\nx\u271d : Sort u_5\nmap\u2082 : x\u271d\nc : \u03b3\n\u22a2 sorry = some c \u2194 \u2203 a' b', a' \u2208 a \u2227 b' \u2208 b \u2227 f a' b' = c"}, {"line": "simp [map\u2082, bind_eq_some]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : Option \u03b1\nb : Option \u03b2\nx\u271d : Sort u_5\nmap\u2082 : x\u271d\nc : \u03b3\n\u22a2 sorry () = some c \u2194 \u2203 a', a = some a' \u2227 \u2203 x, b = some x \u2227 f a' x = c"}]}
{"declaration": "theorem map\u2082_swap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (a : Option \u03b1) (b : Option \u03b2) :\n    map\u2082 f a b = map\u2082 (fun a b => f b a) b a := by cases a <;> cases b <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : Option \u03b1} {b : Option \u03b2} {c : Option \u03b3}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\nx\u271d : Sort u_5\nmap\u2082 : x\u271d\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\na : Option \u03b1\nb : Option \u03b2\n\u22a2 sorry = sorry"}, {"line": "cases a <;> cases b <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma map\u2082_right_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {b : \u03b2} (h : \u2200 a, f a b = a) (o : Option \u03b1) :\n    map\u2082 f o (some b) = o := by\n  simp [h, map\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Option/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : Option \u03b1} {b : Option \u03b2} {c : Option \u03b3}", "{\u03b1' \u03b2' \u03b4' \u03b5 \u03b5' : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_10\nmap\u2082 : x\u271d\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\nb : \u03b2\nh : \u2200 (a : \u03b1), f a b = a\no : Option \u03b1\n\u22a2 sorry = o"}, {"line": "simp [h, map\u2082]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_10\nmap\u2082 : x\u271d\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b1\nb : \u03b2\nh : \u2200 (a : \u03b1), f a b = a\no : Option \u03b1\n\u22a2 sorry () = o"}]}
{"declaration": "theorem ite_eq_lt_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.lt) = if c then a = Ordering.lt else b = Ordering.lt := by\n  by_cases c <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordering/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop\ninst\u271d : Decidable c\na b : Ordering\n\u22a2 ((if c then a else b) = Ordering.lt) = if c then a = Ordering.lt else b = Ordering.lt"}, {"line": "by_cases c <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_eq_eq_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.eq) = if c then a = Ordering.eq else b = Ordering.eq := by\n  by_cases c <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordering/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop\ninst\u271d : Decidable c\na b : Ordering\n\u22a2 ((if c then a else b) = Ordering.eq) = if c then a = Ordering.eq else b = Ordering.eq"}, {"line": "by_cases c <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_eq_gt_distrib (c : Prop) [Decidable c] (a b : Ordering) :\n    ((if c then a else b) = Ordering.gt) = if c then a = Ordering.gt else b = Ordering.gt := by\n  by_cases c <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordering/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : Prop\ninst\u271d : Decidable c\na b : Ordering\n\u22a2 ((if c then a else b) = Ordering.gt) = if c then a = Ordering.gt else b = Ordering.gt"}, {"line": "by_cases c <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dthen_eq_then (o\u2081 o\u2082 : Ordering) : o\u2081.dthen (fun _ => o\u2082) = o\u2081.then o\u2082 := by\n  cases o\u2081 <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordering/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "o\u2081 o\u2082 : Ordering\n\u22a2 (o\u2081.dthen fun x => o\u2082) = o\u2081.then o\u2082"}, {"line": "cases o\u2081 <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cmpUsing_eq_eq (a b : \u03b1) : cmpUsing lt a b = Ordering.eq \u2194 \u00aclt a b \u2227 \u00aclt b a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordering/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} [DecidableRel lt]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nlt : \u03b1 \u2192 \u03b1 \u2192 Prop\ninst\u271d : DecidableRel lt\na b : \u03b1\n\u22a2 cmpUsing lt a b = Ordering.eq \u2194 \u00aclt a b \u2227 \u00aclt b a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Sized.size_eq_zero {t : Ordnode \u03b1} (ht : Sized t) : size t = 0 \u2194 t = nil := by\n  cases t <;> [simp;simp [ht.1]]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nSized : x\u271d\u00b9\nx\u271d : Sort u_3\nsize : x\u271d\nnil t : Ordnode \u03b1\nht : sorry\n\u22a2 sorry = 0 \u2194 t = nil"}, {"line": "cases t <;> [simp;simp [ht.1]]", "tactic_state": "case nil\n\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\nSized : x\u271d\u00b9\nx\u271d : Sort u_3\nsize : x\u271d\nnil : Ordnode \u03b1\nht : sorry\n\u22a2 sorry () = 0 \u2194 Ordnode.nil = nil\n---\ncase node\n\u03b1 : Type u_1\nx\u271d\u00b2 : Sort u_2\nSized : x\u271d\u00b2\nx\u271d\u00b9 : Sort u_3\nsize : x\u271d\u00b9\nnil : Ordnode \u03b1\nht : sorry\nsize\u271d : \u2115\nl\u271d : Ordnode \u03b1\nx\u271d : \u03b1\nr\u271d : Ordnode \u03b1\n\u22a2 sorry () = 0 \u2194 Ordnode.node size\u271d l\u271d x\u271d r\u271d = nil"}]}
{"declaration": "theorem size_dual (t : Ordnode \u03b1) : size (dual t) = size t := by cases t <;> rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d : Sort u_2\nsize : x\u271d\nt : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "cases t <;> rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem balancedSz_zero {l : \u2115} : BalancedSz l 0 \u2194 l \u2264 1 := by\n  simp +contextual [BalancedSz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nBalancedSz : x\u271d\nl : \u2115\n\u22a2 sorry \u2194 l \u2264 1"}, {"line": "simp +contextual [BalancedSz]", "tactic_state": "x\u271d : Sort u_2\nBalancedSz : x\u271d\nl : \u2115\n\u22a2 sorry () \u2194 l \u2264 1"}]}
{"declaration": "theorem dual_node' (l : Ordnode \u03b1) (x : \u03b1) (r : Ordnode \u03b1) :\n    dual (node' l x r) = node' (dual r) x (dual l) := by simp [node', add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\ndual : x\u271d\u00b9\nx\u271d : Sort u_3\nnode' : x\u271d\nl : Ordnode \u03b1\nx : \u03b1\nr : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp [node', add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dual_node3L (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node3L l x m y r) = node3R (dual r) y (dual m) x (dual l) := by\n  simp [node3L, node3R, dual_node', add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\ndual : x\u271d\u00b9\nx\u271d : Sort u_3\nnode3R : x\u271d\nl : Ordnode \u03b1\nx : \u03b1\nm : Ordnode \u03b1\ny : \u03b1\nr : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp [node3L, node3R, dual_node', add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dual_node3R (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node3R l x m y r) = node3L (dual r) y (dual m) x (dual l) := by\n  simp [node3L, node3R, dual_node', add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\ndual : x\u271d\u00b9\nx\u271d : Sort u_3\nnode3L : x\u271d\nl : Ordnode \u03b1\nx : \u03b1\nm : Ordnode \u03b1\ny : \u03b1\nr : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "simp [node3L, node3R, dual_node', add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dual_node4L (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node4L l x m y r) = node4R (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4L, node4R, node3R, dual_node3L, dual_node', add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\ndual : x\u271d\u00b9\nx\u271d : Sort u_3\nnode4R : x\u271d\nl : Ordnode \u03b1\nx : \u03b1\nm : Ordnode \u03b1\ny : \u03b1\nr : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "cases m <;> simp [node4L, node4R, node3R, dual_node3L, dual_node', add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dual_node4R (l : Ordnode \u03b1) (x : \u03b1) (m : Ordnode \u03b1) (y : \u03b1) (r : Ordnode \u03b1) :\n    dual (node4R l x m y r) = node4L (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4L, node4R, node3L, dual_node3R, dual_node', add_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx\u271d\u00b9 : Sort u_2\ndual : x\u271d\u00b9\nx\u271d : Sort u_3\nnode4L : x\u271d\nl : Ordnode \u03b1\nx : \u03b1\nm : Ordnode \u03b1\ny : \u03b1\nr : Ordnode \u03b1\n\u22a2 sorry = sorry"}, {"line": "cases m <;> simp [node4L, node4R, node3L, dual_node3R, dual_node', add_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem all_node3L {P l x m y r} :\n    @All \u03b1 P (node3L l x m y r) \u2194 All P l \u2227 P x \u2227 All P m \u2227 P y \u2227 All P r := by\n  simp [node3L, all_node', and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Invariants.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nAll : x\u271d\nP : ?m.2480\nl : ?m.2481\nx : ?m.2482\nm : ?m.2483\ny : ?m.2484\nr : ?m.2485\n\u22a2 sorry \u2194 sorry \u2227 sorry \u2227 sorry \u2227 sorry \u2227 sorry"}, {"line": "simp [node3L, all_node', and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.node4L_lemma\u2081 {a b c d : \u2115} (lr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9)\n    (mr\u2082 : b + c + 1 \u2264 3 * d) (mm\u2081 : b \u2264 3 * c) : b < 3 * a + 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nlr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9\nmr\u2082 : b + c + 1 \u2264 3 * d\nmm\u2081 : b \u2264 3 * c\n\u22a2 b < 3 * a + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.node4L_lemma\u2082 {b c d : \u2115} (mr\u2082 : b + c + 1 \u2264 3 * d) : c \u2264 3 * d := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c d : \u2115\nmr\u2082 : b + c + 1 \u2264 3 * d\n\u22a2 c \u2264 3 * d"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.node4L_lemma\u2083 {b c d : \u2115} (mr\u2081 : 2 * d \u2264 b + c + 1) (mm\u2081 : b \u2264 3 * c) :\n    d \u2264 3 * c := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b c d : \u2115\nmr\u2081 : 2 * d \u2264 b + c + 1\nmm\u2081 : b \u2264 3 * c\n\u22a2 d \u2264 3 * c"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.node4L_lemma\u2084 {a b c d : \u2115} (lr\u2081 : 3 * a \u2264 b + c + 1 + d) (mr\u2082 : b + c + 1 \u2264 3 * d)\n    (mm\u2081 : b \u2264 3 * c) : a + b + 1 \u2264 3 * (c + d + 1) := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nlr\u2081 : 3 * a \u2264 b + c + 1 + d\nmr\u2082 : b + c + 1 \u2264 3 * d\nmm\u2081 : b \u2264 3 * c\n\u22a2 a + b + 1 \u2264 3 * (c + d + 1)"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.node4L_lemma\u2085 {a b c d : \u2115} (lr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9)\n    (mr\u2081 : 2 * d \u2264 b + c + 1) (mm\u2082 : c \u2264 3 * b) : c + d + 1 \u2264 3 * (a + b + 1) := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2115\nlr\u2082 : 3 * (b + c + 1 + d) \u2264 16 * a + 9\nmr\u2081 : 2 * d \u2264 b + c + 1\nmm\u2082 : c \u2264 3 * b\n\u22a2 c + d + 1 \u2264 3 * (a + b + 1)"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.rotateL_lemma\u2081 {a b c : \u2115} (H2 : 3 * a \u2264 b + c) (hb\u2082 : c \u2264 3 * b) : a \u2264 3 * b := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nH2 : 3 * a \u2264 b + c\nhb\u2082 : c \u2264 3 * b\n\u22a2 a \u2264 3 * b"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.rotateL_lemma\u2082 {a b c : \u2115} (H3 : 2 * (b + c) \u2264 9 * a + 3) (h : b < 2 * c) :\n    b < 3 * a + 1 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nH3 : 2 * (b + c) \u2264 9 * a + 3\nh : b < 2 * c\n\u22a2 b < 3 * a + 1"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.rotateL_lemma\u2083 {a b c : \u2115} (H2 : 3 * a \u2264 b + c) (h : b < 2 * c) : a + b < 3 * c := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nH2 : 3 * a \u2264 b + c\nh : b < 2 * c\n\u22a2 a + b < 3 * c"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.rotateL_lemma\u2084 {a b : \u2115} (H3 : 2 * b \u2264 9 * a + 3) : 3 * b \u2264 16 * a + 9 := by\n  omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\nH3 : 2 * b \u2264 9 * a + 3\n\u22a2 3 * b \u2264 16 * a + 9"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Valid'.merge_lemma {a b c : \u2115} (h\u2081 : 3 * a < b + c + 1) (h\u2082 : b \u2264 3 * c) :\n    2 * (a + b) \u2264 9 * c + 5 := by omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Ordmap/Ordset.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Preorder \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u2115\nh\u2081 : 3 * a < b + c + 1\nh\u2082 : b \u2264 3 * c\n\u22a2 2 * (a + b) \u2264 9 * c + 5"}, {"line": "omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Icc : #(Icc a b) = b + 1 - a := by\n  rw [\u2190 Nat.card_Icc]\n  rw [\u2190 map_subtype_embedding_Icc]\n  rw [card_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 (Icc a b).card = \u2191b + 1 - \u2191a"}, {"line": "rw [\u2190 Nat.card_Icc]", "tactic_state": "a b : \u2115+\n\u22a2 (Icc a b).card = (Icc \u2191a \u2191b).card"}, {"line": "rw [\u2190 map_subtype_embedding_Icc]", "tactic_state": "a b : \u2115+\n\u22a2 (Icc a b).card = (map (Embedding.subtype fun n => 0 < n) (Icc a b)).card"}, {"line": "rw [card_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ico : #(Ico a b) = b - a := by\n  rw [\u2190 Nat.card_Ico]\n  rw [\u2190 map_subtype_embedding_Ico]\n  rw [card_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 (Ico a b).card = \u2191b - \u2191a"}, {"line": "rw [\u2190 Nat.card_Ico]", "tactic_state": "a b : \u2115+\n\u22a2 (Ico a b).card = (Ico \u2191a \u2191b).card"}, {"line": "rw [\u2190 map_subtype_embedding_Ico]", "tactic_state": "a b : \u2115+\n\u22a2 (Ico a b).card = (map (Embedding.subtype fun n => 0 < n) (Ico a b)).card"}, {"line": "rw [card_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ioc : #(Ioc a b) = b - a := by\n  rw [\u2190 Nat.card_Ioc]\n  rw [\u2190 map_subtype_embedding_Ioc]\n  rw [card_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 (Ioc a b).card = \u2191b - \u2191a"}, {"line": "rw [\u2190 Nat.card_Ioc]", "tactic_state": "a b : \u2115+\n\u22a2 (Ioc a b).card = (Ioc \u2191a \u2191b).card"}, {"line": "rw [\u2190 map_subtype_embedding_Ioc]", "tactic_state": "a b : \u2115+\n\u22a2 (Ioc a b).card = (map (Embedding.subtype fun n => 0 < n) (Ioc a b)).card"}, {"line": "rw [card_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_Ioo : #(Ioo a b) = b - a - 1 := by\n  rw [\u2190 Nat.card_Ioo]\n  rw [\u2190 map_subtype_embedding_Ioo]\n  rw [card_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 (Ioo a b).card = \u2191b - \u2191a - 1"}, {"line": "rw [\u2190 Nat.card_Ioo]", "tactic_state": "a b : \u2115+\n\u22a2 (Ioo a b).card = (Ioo \u2191a \u2191b).card"}, {"line": "rw [\u2190 map_subtype_embedding_Ioo]", "tactic_state": "a b : \u2115+\n\u22a2 (Ioo a b).card = (map (Embedding.subtype fun n => 0 < n) (Ioo a b)).card"}, {"line": "rw [card_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_uIcc : #(uIcc a b) = (b - a : \u2124).natAbs + 1 := by\n  rw [\u2190 Nat.card_uIcc]\n  rw [\u2190 map_subtype_embedding_uIcc]\n  rw [card_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 (uIcc a b).card = (\u2191\u2191b - \u2191\u2191a).natAbs + 1"}, {"line": "rw [\u2190 Nat.card_uIcc]", "tactic_state": "a b : \u2115+\n\u22a2 (uIcc a b).card = (uIcc \u2191a \u2191b).card"}, {"line": "rw [\u2190 map_subtype_embedding_uIcc]", "tactic_state": "a b : \u2115+\n\u22a2 (uIcc a b).card = (map (Embedding.subtype fun n => 0 < n) (uIcc a b)).card"}, {"line": "rw [card_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = b + 1 - a := by\n  rw [\u2190 card_Icc]\n  rw [Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Icc a b) = \u2191b + 1 - \u2191a"}, {"line": "rw [\u2190 card_Icc]", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Icc a b) = (Icc a b).card"}, {"line": "rw [Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ico : Fintype.card (Set.Ico a b) = b - a := by\n  rw [\u2190 card_Ico]\n  rw [Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ico a b) = \u2191b - \u2191a"}, {"line": "rw [\u2190 card_Ico]", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ico a b) = (Ico a b).card"}, {"line": "rw [Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioc : Fintype.card (Set.Ioc a b) = b - a := by\n  rw [\u2190 card_Ioc]\n  rw [Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ioc a b) = \u2191b - \u2191a"}, {"line": "rw [\u2190 card_Ioc]", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ioc a b) = (Ioc a b).card"}, {"line": "rw [Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_Ioo : Fintype.card (Set.Ioo a b) = b - a - 1 := by\n  rw [\u2190 card_Ioo]\n  rw [Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = \u2191b - \u2191a - 1"}, {"line": "rw [\u2190 card_Ioo]", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.Ioo a b) = (Ioo a b).card"}, {"line": "rw [Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a : \u2124).natAbs + 1 := by\n  rw [\u2190 card_uIcc]\n  rw [Fintype.card_ofFinset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Interval.lean", "context": {"open": ["Finset Function PNat"], "variables": ["(a b : \u2115+)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.uIcc a b) = (\u2191\u2191b - \u2191\u2191a).natAbs + 1"}, {"line": "rw [\u2190 card_uIcc]", "tactic_state": "a b : \u2115+\n\u22a2 Fintype.card \u2191(Set.uIcc a b) = (uIcc a b).card"}, {"line": "rw [Fintype.card_ofFinset]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dvd_prime {p m : \u2115+} (pp : p.Prime) : m \u2223 p \u2194 m = 1 \u2228 m = p := by\n  rw [PNat.dvd_iff]\n  rw [Nat.dvd_prime pp]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Prime.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p m : \u2115+\npp : p.Prime\n\u22a2 m \u2223 p \u2194 m = 1 \u2228 m = p"}, {"line": "rw [PNat.dvd_iff]", "tactic_state": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m \u2223 \u2191p \u2194 m = 1 \u2228 m = p"}, {"line": "rw [Nat.dvd_prime pp]", "tactic_state": "p m : \u2115+\npp : p.Prime\n\u22a2 \u2191m = 1 \u2228 \u2191m = \u2191p \u2194 m = 1 \u2228 m = p"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prime.ne_one {p : \u2115+} : p.Prime \u2192 p \u2260 1 := by\n  intro pp\n  intro contra\n  apply Nat.Prime.ne_one pp\n  rw [PNat.coe_eq_one_iff]\n  apply contra\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Prime.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115+\n\u22a2 p.Prime \u2192 p \u2260 1"}, {"line": "intro pp", "tactic_state": "p : \u2115+\npp : p.Prime\n\u22a2 p \u2260 1"}, {"line": "intro contra", "tactic_state": "p : \u2115+\npp : p.Prime\ncontra : p = 1\n\u22a2 False"}, {"line": "apply Nat.Prime.ne_one pp", "tactic_state": "p : \u2115+\npp : p.Prime\ncontra : p = 1\n\u22a2 \u2191p = 1"}, {"line": "rw [PNat.coe_eq_one_iff]", "tactic_state": "p : \u2115+\npp : p.Prime\ncontra : p = 1\n\u22a2 p = 1"}, {"line": "apply contra", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_gcd {n : \u2115+} : gcd 1 n = 1 := by\n  rw [gcd_eq_left_iff_dvd]\n  apply one_dvd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Prime.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115+\n\u22a2 Nat.gcd 1 \u2191n = 1"}, {"line": "rw [gcd_eq_left_iff_dvd]", "tactic_state": "n : \u2115+\n\u22a2 1 \u2223 \u2191n"}, {"line": "apply one_dvd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gcd_one {n : \u2115+} : gcd n 1 = 1 := by\n  rw [gcd_comm]\n  apply one_gcd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Prime.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115+\n\u22a2 (\u2191n).gcd 1 = 1"}, {"line": "rw [gcd_comm]", "tactic_state": "n : \u2115+\n\u22a2 Nat.gcd 1 \u2191n = 1"}, {"line": "apply one_gcd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem recOn_succ (n : \u2115+) {p : \u2115+ \u2192 Sort*} (one succ) :\n    @PNat.recOn (n + 1) p one succ = succ n (@PNat.recOn n p one succ) := by\n  obtain \u27e8n, h\u27e9 := n\n  cases n <;> [exact absurd h (by decide); rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115+\np : \u2115+ \u2192 Sort u_1\none : p 1\nsucc : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\n\u22a2 (n + 1).recOn one succ = succ n (n.recOn one succ)"}, {"line": "obtain \u27e8n, h\u27e9 := n", "tactic_state": "case mk\np : \u2115+ \u2192 Sort u_1\none : p 1\nsucc : (n : \u2115+) \u2192 p n \u2192 p (n + 1)\nn : \u2115\nh : 0 < n\n\u22a2 (\u27e8n, h\u27e9 + 1).recOn one succ = succ \u27e8n, h\u27e9 (PNat.recOn \u27e8n, h\u27e9 one succ)"}, {"line": "cases n <;> [exact absurd h (by decide); rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pos_of_div_pos {n : \u2115+} {a : \u2115} (h : a \u2223 n) : 0 < a := by\n  apply pos_iff_ne_zero.2\n  intro hzero\n  rw [hzero] at h\n  exact PNat.ne_zero n (eq_zero_of_zero_dvd h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Basic.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115+\na : \u2115\nh : a \u2223 \u2191n\n\u22a2 0 < a"}, {"line": "apply pos_iff_ne_zero.2", "tactic_state": "n : \u2115+\na : \u2115\nh : a \u2223 \u2191n\n\u22a2 a \u2260 0"}, {"line": "intro hzero", "tactic_state": "n : \u2115+\na : \u2115\nh : a \u2223 \u2191n\nhzero : a = 0\n\u22a2 False"}, {"line": "rw [hzero] at h", "tactic_state": "n : \u2115+\na : \u2115\nh : 0 \u2223 \u2191n\nhzero : a = 0\n\u22a2 False"}, {"line": "exact PNat.ne_zero n (eq_zero_of_zero_dvd h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_le_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) : (\u27e8n, hn\u27e9 : \u2115+) \u2264 \u27e8k, hk\u27e9 \u2194 n \u2264 k := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Defs.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhn : 0 < n\nhk : 0 < k\n\u22a2 \u27e8n, hn\u27e9 \u2264 \u27e8k, hk\u27e9 \u2194 n \u2264 k"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_lt_mk (n k : \u2115) (hn : 0 < n) (hk : 0 < k) : (\u27e8n, hn\u27e9 : \u2115+) < \u27e8k, hk\u27e9 \u2194 n < k := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Defs.lean", "context": {"open": ["Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n k : \u2115\nhn : 0 < n\nhk : 0 < k\n\u22a2 \u27e8n, hn\u27e9 < \u27e8k, hk\u27e9 \u2194 n < k"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeNat_prime (v : PrimeMultiset) (p : \u2115) (h : p \u2208 (v : Multiset \u2115)) : p.Prime := by\n  rcases Multiset.mem_map.mp h with \u27e8\u27e8_, hp'\u27e9, \u27e8_, h_eq\u27e9\u27e9\n  exact h_eq \u25b8 hp'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : PrimeMultiset\np : \u2115\nh : p \u2208 v.toNatMultiset\n\u22a2 Nat.Prime p"}, {"line": "rcases Multiset.mem_map.mp h with \u27e8\u27e8_, hp'\u27e9, \u27e8_, h_eq\u27e9\u27e9", "tactic_state": "case intro.mk.intro\nv : PrimeMultiset\np : \u2115\nh : p \u2208 v.toNatMultiset\nval\u271d : \u2115\nhp' : Nat.Prime val\u271d\nleft\u271d : \u27e8val\u271d, hp'\u27e9 \u2208 v\nh_eq : \u2191\u27e8val\u271d, hp'\u27e9 = p\n\u22a2 Nat.Prime p"}, {"line": "exact h_eq \u25b8 hp'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coePNat_prime (v : PrimeMultiset) (p : \u2115+) (h : p \u2208 (v : Multiset \u2115+)) : p.Prime := by\n  rcases Multiset.mem_map.mp h with \u27e8\u27e8_, hp'\u27e9, \u27e8_, h_eq\u27e9\u27e9\n  exact h_eq \u25b8 hp'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : PrimeMultiset\np : \u2115+\nh : p \u2208 v.toPNatMultiset\n\u22a2 p.Prime"}, {"line": "rcases Multiset.mem_map.mp h with \u27e8\u27e8_, hp'\u27e9, \u27e8_, h_eq\u27e9\u27e9", "tactic_state": "case intro.mk.intro\nv : PrimeMultiset\np : \u2115+\nh : p \u2208 v.toPNatMultiset\nval\u271d : \u2115\nhp' : Nat.Prime val\u271d\nleft\u271d : \u27e8val\u271d, hp'\u27e9 \u2208 v\nh_eq : \u2191\u27e8val\u271d, hp'\u27e9 = p\n\u22a2 p.Prime"}, {"line": "exact h_eq \u25b8 hp'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_prod (v : PrimeMultiset) : (v.prod : \u2115) = (v : Multiset \u2115).prod := by\n  have h : (v.prod : \u2115) = ((v.map (\u2191) : Multiset \u2115+).map (\u2191)).prod :=\n    PNat.coeMonoidHom.map_multiset_prod v.toPNatMultiset\n  simpa [Multiset.map_map] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "v : PrimeMultiset\n\u22a2 \u2191v.prod = v.toNatMultiset.prod"}, {"line": "have h : (v.prod : \u2115) = ((v.map (\u2191) : Multiset \u2115+).map (\u2191)).prod :=\n    PNat.coeMonoidHom.map_multiset_prod v.toPNatMultiset", "tactic_state": "v : PrimeMultiset\nh : \u2191v.prod = (Multiset.map PNat.val (Multiset.map Nat.Primes.toPNat v)).prod\n\u22a2 \u2191v.prod = v.toNatMultiset.prod"}, {"line": "simpa [Multiset.map_map] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_zero : (0 : PrimeMultiset).prod = 1 := by\n  exact Multiset.prod_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 PrimeMultiset.prod 0 = 1"}, {"line": "exact Multiset.prod_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem factorMultiset_one : factorMultiset 1 = 0 := by\n  simp [factorMultiset, PrimeMultiset.ofNatList, PrimeMultiset.ofNatMultiset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfactorMultiset : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [factorMultiset, PrimeMultiset.ofNatList, PrimeMultiset.ofNatMultiset]", "tactic_state": "x\u271d : Sort u_1\nfactorMultiset : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem factorMultiset_le_iff {m n : \u2115+} : factorMultiset m \u2264 factorMultiset n \u2194 m \u2223 n := by\n  constructor\n  \u00b7 intro h\n    rw [\u2190 prod_factorMultiset m]\n    rw [\u2190 prod_factorMultiset m]\n    apply Dvd.intro (n.factorMultiset - m.factorMultiset).prod\n    rw [\u2190 PrimeMultiset.prod_add]\n    rw [PrimeMultiset.factorMultiset_prod]\n    rw [add_tsub_cancel_of_le h]\n    rw [prod_factorMultiset]\n  \u00b7 intro h\n    rw [\u2190 mul_div_exact h]\n    rw [factorMultiset_mul]\n    exact le_self_add\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nfactorMultiset : x\u271d\nm n : \u2115+\n\u22a2 sorry \u2264 sorry \u2194 m \u2223 n"}, {"line": "constructor", "tactic_state": "case mp\nx\u271d : Sort u_1\nfactorMultiset : x\u271d\nm n : \u2115+\n\u22a2 sorry \u2264 sorry \u2192 m \u2223 n\n---\ncase mpr\nx\u271d : Sort u_1\nfactorMultiset : x\u271d\nm n : \u2115+\n\u22a2 m \u2223 n \u2192 sorry \u2264 sorry"}, {"line": "\u00b7 intro h\n    rw [\u2190 prod_factorMultiset m]\n    rw [\u2190 prod_factorMultiset m]\n    apply Dvd.intro (n.factorMultiset - m.factorMultiset).prod\n    rw [\u2190 PrimeMultiset.prod_add]\n    rw [PrimeMultiset.factorMultiset_prod]\n    rw [add_tsub_cancel_of_le h]\n    rw [prod_factorMultiset]", "tactic_state": "case mpr\nx\u271d : Sort u_1\nfactorMultiset : x\u271d\nm n : \u2115+\n\u22a2 m \u2223 n \u2192 sorry \u2264 sorry"}, {"line": "\u00b7 intro h\n    rw [\u2190 mul_div_exact h]\n    rw [factorMultiset_mul]\n    exact le_self_add", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_dvd_iff {u v : PrimeMultiset} : u.prod \u2223 v.prod \u2194 u \u2264 v := by\n  let h := @PNat.factorMultiset_le_iff' u.prod v\n  rw [u.factorMultiset_prod] at h\n  exact h.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Factors.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "u v : PrimeMultiset\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v"}, {"line": "let h := @PNat.factorMultiset_le_iff' u.prod v", "tactic_state": "u v : PrimeMultiset\nh : u.prod.factorMultiset \u2264 v \u2194 u.prod \u2223 v.prod := PNat.factorMultiset_le_iff'\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v"}, {"line": "rw [u.factorMultiset_prod] at h", "tactic_state": "u v : PrimeMultiset\nh : u \u2264 v \u2194 u.prod \u2223 v.prod\n\u22a2 u.prod \u2223 v.prod \u2194 u \u2264 v"}, {"line": "exact h.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem find_eq_one : PNat.find h = 1 \u2194 p 1 := by simp [find_eq_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Find.lean", "context": {"open": [], "variables": ["{p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)", "{n m : \u2115+}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115+ \u2192 Prop\ninst\u271d : DecidablePred p\nh : \u2203 n, p n\n\u22a2 PNat.find h = 1 \u2194 p 1"}, {"line": "simp [find_eq_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_find : 1 < PNat.find h \u2194 \u00acp 1 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Find.lean", "context": {"open": [], "variables": ["{p q : \u2115+ \u2192 Prop} [DecidablePred p] [DecidablePred q] (h : \u2203 n, p n)", "{n m : \u2115+}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2115+ \u2192 Prop\ninst\u271d : DecidablePred p\nh : \u2203 n, p n\n\u22a2 1 < PNat.find h \u2194 \u00acp 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem start_isSpecial (a b : \u2115+) : (start a b).IsSpecial := by\n  dsimp [start, IsSpecial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/PNat/Xgcd.lean", "context": {"open": ["Nat"], "variables": ["(u : XgcdType)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nstart : x\u271d\na b : \u2115+\n\u22a2 sorry"}, {"line": "dsimp [start, IsSpecial]", "tactic_state": "x\u271d : Sort u_1\nstart : x\u271d\na b : \u2115+\n\u22a2 sorry ()"}]}
{"declaration": "lemma swap_eq_iff_eq_swap {x : \u03b1 \u00d7 \u03b2} {y : \u03b2 \u00d7 \u03b1} : x.swap = y \u2194 x = y.swap := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx : \u03b1 \u00d7 \u03b2\ny : \u03b2 \u00d7 \u03b1\n\u22a2 x.swap = y \u2194 x = y.swap"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_inj {a\u2081 a\u2082 : \u03b1} {b\u2081 b\u2082 : \u03b2} : (a\u2081, b\u2081) = (a\u2082, b\u2082) \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\na\u2081 a\u2082 : \u03b1\nb\u2081 b\u2082 : \u03b2\n\u22a2 (a\u2081, b\u2081) = (a\u2082, b\u2082) \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_iterate (f : \u03b1 \u2192 \u03b1) (g : \u03b2 \u2192 \u03b2) (n : \u2115) :\n    (Prod.map f g)^[n] = Prod.map f^[n] g^[n] := by induction n <;> simp [*, Prod.map_comp_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/Basic.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : \u03b1 \u2192 \u03b1\ng : \u03b2 \u2192 \u03b2\nn : \u2115\n\u22a2 (Prod.map f g)^[n] = Prod.map f^[n] g^[n]"}, {"line": "induction n <;> simp [*, Prod.map_comp_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toLex_strictMono : StrictMono (toLex : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7\u2097 \u03b2) := by\n  rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 h\n  obtain rfl | ha : a\u2081 = a\u2082 \u2228 _ := h.le.1.eq_or_lt\n  \u00b7 exact right _ (Prod.mk_lt_mk_iff_right.1 h)\n  \u00b7 exact left _ _ ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/Lex.lean", "context": {"open": ["Batteries"], "variables": ["{\u03b1 \u03b2 : Type*}", "[Preorder \u03b1] [Preorder \u03b2]", "[PartialOrder \u03b1] [Preorder \u03b2] {x y : \u03b1 \u00d7 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\n\u22a2 StrictMono \u21d1toLex"}, {"line": "rintro \u27e8a\u2081, b\u2081\u27e9 \u27e8a\u2082, b\u2082\u27e9 h", "tactic_state": "case mk.mk\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)"}, {"line": "obtain rfl | ha : a\u2081 = a\u2082 \u2228 _ := h.le.1.eq_or_lt", "tactic_state": "case mk.mk.inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 b\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2081, b\u2082)\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2081, b\u2082)\n---\ncase mk.mk.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\nha : ?m.389\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)"}, {"line": "\u00b7 exact right _ (Prod.mk_lt_mk_iff_right.1 h)", "tactic_state": "case mk.mk.inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : Preorder \u03b2\na\u2081 : \u03b1\nb\u2081 : \u03b2\na\u2082 : \u03b1\nb\u2082 : \u03b2\nh : (a\u2081, b\u2081) < (a\u2082, b\u2082)\nha : ?m.389\n\u22a2 toLex (a\u2081, b\u2081) < toLex (a\u2082, b\u2082)"}, {"line": "\u00b7 exact left _ _ ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem elim_self (v : TProd \u03b1 (i :: l)) : v.elim mem_cons_self = v.1 := by simp [TProd.elim]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/TProd.lean", "context": {"open": ["List Function", "List"], "variables": ["{\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} {i j : \u03b9} {l : List \u03b9}", "(\u03b1) in", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b1 : \u03b9 \u2192 Type v\ni : \u03b9\nl : List \u03b9\nv : TProd \u03b1 (i :: l)\n\u22a2 sorry = v.1"}, {"line": "simp [TProd.elim]", "tactic_state": "\u03b9 : Type u\n\u03b1 : \u03b9 \u2192 Type v\ni : \u03b9\nl : List \u03b9\nv : TProd \u03b1 (i :: l)\n\u22a2 sorry () = v.1"}]}
{"declaration": "theorem elim_of_ne (hj : j \u2208 i :: l) (hji : j \u2260 i) (v : TProd \u03b1 (i :: l)) :\n    v.elim hj = TProd.elim v.2 ((List.mem_cons.mp hj).resolve_left hji) := by simp [TProd.elim, hji]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Prod/TProd.lean", "context": {"open": ["List Function", "List"], "variables": ["{\u03b9 : Type u} {\u03b1 : \u03b9 \u2192 Type v} {i j : \u03b9} {l : List \u03b9}", "(\u03b1) in", "[DecidableEq \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\n\u03b1 : \u03b9 \u2192 Type v\ni j : \u03b9\nl : List \u03b9\nhj : j \u2208 i :: l\nhji : j \u2260 i\nv : TProd \u03b1 (i :: l)\n\u22a2 sorry = sorry"}, {"line": "simp [TProd.elim, hji]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Wequiv.refl (x : q.P.W) : Wequiv x x := by\n  obtain \u27e8a, f\u27e9 := x\n  exact Wequiv.abs a f a f rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/QPF/Univariate/Basic.lean", "context": {"open": ["Functor (Liftp Liftr)", "Functor"], "variables": ["{F : Type u \u2192 Type u} [q : QPF F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u \u2192 Type u\nq : QPF F\nx\u271d : Sort u_1\nWequiv : x\u271d\nx : (QPF.P F).W\n\u22a2 sorry"}, {"line": "obtain \u27e8a, f\u27e9 := x", "tactic_state": "case mk\nF : Type u \u2192 Type u\nq : QPF F\nx\u271d : Sort u_1\nWequiv : x\u271d\na : (QPF.P F).A\nf : (QPF.P F).B a \u2192 WType (QPF.P F).B\n\u22a2 sorry"}, {"line": "exact Wequiv.abs a f a f rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem floor_intCast_div_natCast (n : \u2124) (d : \u2115) : \u230a(\u2191n / \u2191d : \u211a)\u230b = n / (\u2191d : \u2124) := by\n  rw [Rat.floor_def]\n  obtain rfl | hd := eq_zero_or_pos (a := d)\n  \u00b7 simp\n  set q := (n : \u211a) / d with q_eq\n  obtain \u27e8c, n_eq_c_mul_num, d_eq_c_mul_denom\u27e9 : \u2203 c, n = c * q.num \u2227 (d : \u2124) = c * q.den := by\n    rw [q_eq]\n    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')\n  rw [n_eq_c_mul_num]\n  rw [d_eq_c_mul_denom]\n  refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm\n  rwa [\u2190 d_eq_c_mul_denom, Int.natCast_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Floor.lean", "context": {"open": ["Int"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nd : \u2115\n\u22a2 \u230a\u2191n / \u2191d\u230b = n / \u2191d"}, {"line": "rw [Rat.floor_def]", "tactic_state": "n : \u2124\nd : \u2115\n\u22a2 (\u2191n / \u2191d).num / \u2191(\u2191n / \u2191d).den = n / \u2191d"}, {"line": "obtain rfl | hd := eq_zero_or_pos (a := d)", "tactic_state": "case inl\nn : \u2124\n\u22a2 (\u2191n / \u21910).num / \u2191(\u2191n / \u21910).den = n / \u21910\n---\ncase inr\nn : \u2124\nd : \u2115\nhd : 0 < d\n\u22a2 (\u2191n / \u2191d).num / \u2191(\u2191n / \u2191d).den = n / \u2191d"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nn : \u2124\nd : \u2115\nhd : 0 < d\n\u22a2 (\u2191n / \u2191d).num / \u2191(\u2191n / \u2191d).den = n / \u2191d"}, {"line": "set q := (n : \u211a) / d with q_eq", "tactic_state": "case inr\nn : \u2124\nd : \u2115\nhd : 0 < d\nq : \u211a := \u2191n / \u2191d\nq_eq : q = \u2191n / \u2191d\n\u22a2 q.num / \u2191q.den = n / \u2191d"}, {"line": "obtain \u27e8c, n_eq_c_mul_num, d_eq_c_mul_denom\u27e9 : \u2203 c, n = c * q.num \u2227 (d : \u2124) = c * q.den := by\n    rw [q_eq]\n    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')", "tactic_state": "case inr.intro.intro\nn : \u2124\nd : \u2115\nhd : 0 < d\nq : \u211a := \u2191n / \u2191d\nq_eq : q = \u2191n / \u2191d\nc : \u2124\nn_eq_c_mul_num : n = c * q.num\nd_eq_c_mul_denom : \u2191d = c * \u2191q.den\n\u22a2 q.num / \u2191q.den = n / \u2191d"}, {"line": "rw [n_eq_c_mul_num]", "tactic_state": "case inr.intro.intro\nn : \u2124\nd : \u2115\nhd : 0 < d\nq : \u211a := \u2191n / \u2191d\nq_eq : q = \u2191n / \u2191d\nc : \u2124\nn_eq_c_mul_num : n = c * q.num\nd_eq_c_mul_denom : \u2191d = c * \u2191q.den\n\u22a2 q.num / \u2191q.den = c * q.num / \u2191d"}, {"line": "rw [d_eq_c_mul_denom]", "tactic_state": "case inr.intro.intro\nn : \u2124\nd : \u2115\nhd : 0 < d\nq : \u211a := \u2191n / \u2191d\nq_eq : q = \u2191n / \u2191d\nc : \u2124\nn_eq_c_mul_num : n = c * q.num\nd_eq_c_mul_denom : \u2191d = c * \u2191q.den\n\u22a2 q.num / \u2191q.den = c * q.num / (c * \u2191q.den)"}, {"line": "refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm", "tactic_state": "case inr.intro.intro\nn : \u2124\nd : \u2115\nhd : 0 < d\nq : \u211a := \u2191n / \u2191d\nq_eq : q = \u2191n / \u2191d\nc : \u2124\nn_eq_c_mul_num : n = c * q.num\nd_eq_c_mul_denom : \u2191d = c * \u2191q.den\n\u22a2 0 < c * \u2191q.den"}, {"line": "rwa [\u2190 d_eq_c_mul_denom, Int.natCast_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natFloor_natCast_div_natCast (n d : \u2115) : \u230a(\u2191n / \u2191d : \u211a)\u230b\u208a = n / d := by\n  rw [\u2190 Int.ofNat_inj]\n  rw [Int.natCast_floor_eq_floor (by positivity)]\n  push_cast\n  exact floor_intCast_div_natCast n d\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Floor.lean", "context": {"open": ["Int"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2115\n\u22a2 \u230a\u2191n / \u2191d\u230b\u208a = n / d"}, {"line": "rw [\u2190 Int.ofNat_inj]", "tactic_state": "n d : \u2115\n\u22a2 \u2191\u230a\u2191n / \u2191d\u230b\u208a = \u2191(n / d)"}, {"line": "rw [Int.natCast_floor_eq_floor (by positivity)]", "tactic_state": "n d : \u2115\n\u22a2 \u230a\u2191n / \u2191d\u230b = \u2191(n / d)"}, {"line": "push_cast", "tactic_state": "n d : \u2115\n\u22a2 \u230a\u2191n / \u2191d\u230b = \u2191n / \u2191d"}, {"line": "exact floor_intCast_div_natCast n d", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Int.mod_nat_eq_sub_mul_floor_rat_div {n : \u2124} {d : \u2115} : n % d = n - d * \u230a(n : \u211a) / d\u230b := by\n  rw [eq_sub_of_add_eq <| Int.emod_add_ediv n d]\n  rw [Rat.floor_intCast_div_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Floor.lean", "context": {"open": ["Int", "Mathlib.Meta.NormNum Qq"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nd : \u2115\n\u22a2 n % \u2191d = n - \u2191d * \u230a\u2191n / \u2191d\u230b"}, {"line": "rw [eq_sub_of_add_eq <| Int.emod_add_ediv n d]", "tactic_state": "n : \u2124\nd : \u2115\n\u22a2 n - \u2191d * (n / \u2191d) = n - \u2191d * \u230a\u2191n / \u2191d\u230b"}, {"line": "rw [Rat.floor_intCast_div_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nat.coprime_sub_mul_floor_rat_div_of_coprime {n d : \u2115} (n_coprime_d : n.Coprime d) :\n    ((n : \u2124) - d * \u230a(n : \u211a) / d\u230b).natAbs.Coprime d := by\n  have : (n : \u2124) % d = n - d * \u230a(n : \u211a) / d\u230b := Int.mod_nat_eq_sub_mul_floor_rat_div\n  rw [\u2190 this]\n  have : d.Coprime n := n_coprime_d.symm\n  rwa [Nat.Coprime, Nat.gcd_rec] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Floor.lean", "context": {"open": ["Int", "Mathlib.Meta.NormNum Qq"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2115\nn_coprime_d : n.Coprime d\n\u22a2 (\u2191n - \u2191d * \u230a\u2191n / \u2191d\u230b).natAbs.Coprime d"}, {"line": "have : (n : \u2124) % d = n - d * \u230a(n : \u211a) / d\u230b := Int.mod_nat_eq_sub_mul_floor_rat_div", "tactic_state": "n d : \u2115\nn_coprime_d : n.Coprime d\nthis : \u2191n % \u2191d = \u2191n - \u2191d * \u230a\u2191n / \u2191d\u230b\n\u22a2 (\u2191n - \u2191d * \u230a\u2191n / \u2191d\u230b).natAbs.Coprime d"}, {"line": "rw [\u2190 this]", "tactic_state": "n d : \u2115\nn_coprime_d : n.Coprime d\nthis : \u2191n % \u2191d = \u2191n - \u2191d * \u230a\u2191n / \u2191d\u230b\n\u22a2 (\u2191n % \u2191d).natAbs.Coprime d"}, {"line": "have : d.Coprime n := n_coprime_d.symm", "tactic_state": "n d : \u2115\nn_coprime_d : n.Coprime d\nthis\u271d : \u2191n % \u2191d = \u2191n - \u2191d * \u230a\u2191n / \u2191d\u230b\nthis : d.Coprime n\n\u22a2 (\u2191n % \u2191d).natAbs.Coprime d"}, {"line": "rwa [Nat.Coprime, Nat.gcd_rec] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fract_inv_num_lt_num_of_pos {q : \u211a} (q_pos : 0 < q) : (fract q\u207b\u00b9).num < q.num := by\n  -- we know that the numerator must be positive\n  have q_num_pos : 0 < q.num := Rat.num_pos.mpr q_pos\n  -- we will work with the absolute value of the numerator, which is equal to the numerator\n  have q_num_abs_eq_q_num : (q.num.natAbs : \u2124) = q.num := Int.natAbs_of_nonneg q_num_pos.le\n  set q_inv : \u211a := q.den / q.num with q_inv_def\n  have q_inv_eq : q\u207b\u00b9 = q_inv := by rw [q_inv_def, inv_def', divInt_eq_div, Int.cast_natCast]\n  suffices (q_inv - \u230aq_inv\u230b).num < q.num by rwa [q_inv_eq]\n  suffices ((q.den - q.num * \u230aq_inv\u230b : \u211a) / q.num).num < q.num by\n    field_simp [q_inv, this, ne_of_gt q_num_pos]\n  suffices (q.den : \u2124) - q.num * \u230aq_inv\u230b < q.num by\n    -- use that `q.num` and `q.den` are coprime to show that the numerator stays unreduced\n    have : ((q.den - q.num * \u230aq_inv\u230b : \u211a) / q.num).num = q.den - q.num * \u230aq_inv\u230b := by\n      suffices ((q.den : \u2124) - q.num * \u230aq_inv\u230b).natAbs.Coprime q.num.natAbs from\n        mod_cast Rat.num_div_eq_of_coprime q_num_pos this\n      have tmp := Nat.coprime_sub_mul_floor_rat_div_of_coprime q.reduced.symm\n      simpa only [Nat.cast_natAbs,abs_of_nonneg q_num_pos.le] using tmp\n    rwa [this]\n  -- to show the claim, start with the following inequality\n  have q_inv_num_denom_ineq : q\u207b\u00b9.num - \u230aq\u207b\u00b9\u230b * q\u207b\u00b9.den < q\u207b\u00b9.den := by\n    have : q\u207b\u00b9.num < (\u230aq\u207b\u00b9\u230b + 1) * q\u207b\u00b9.den := Rat.num_lt_succ_floor_mul_den q\u207b\u00b9\n    have : q\u207b\u00b9.num < \u230aq\u207b\u00b9\u230b * q\u207b\u00b9.den + q\u207b\u00b9.den := by rwa [right_distrib, one_mul] at this\n    rwa [\u2190 sub_lt_iff_lt_add'] at this\n  -- use that `q.num` and `q.den` are coprime to show that q_inv is the unreduced reciprocal\n  -- of `q`\n  have : q_inv.num = q.den \u2227 q_inv.den = q.num.natAbs := by\n    have coprime_q_denom_q_num : q.den.Coprime q.num.natAbs := q.reduced.symm\n    have : Int.natAbs q.den = q.den := by simp\n    rw [\u2190 this] at coprime_q_denom_q_num\n    rw [q_inv_def]\n    constructor\n    \u00b7 exact mod_cast Rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n    \u00b7 suffices (((q.den : \u211a) / q.num).den : \u2124) = q.num.natAbs by exact mod_cast this\n      rw [q_num_abs_eq_q_num]\n      exact mod_cast Rat.den_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n  rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Floor.lean", "context": {"open": ["Int", "Mathlib.Meta.NormNum Qq"], "variables": ["{\u03b1 : Type*} [Field \u03b1] [LinearOrder \u03b1] [IsStrictOrderedRing \u03b1] [FloorRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\nq_pos : 0 < q\n\u22a2 (fract q\u207b\u00b9).num < q.num"}, {"line": "have q_num_pos : 0 < q.num := Rat.num_pos.mpr q_pos", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\n\u22a2 (fract q\u207b\u00b9).num < q.num"}, {"line": "have q_num_abs_eq_q_num : (q.num.natAbs : \u2124) = q.num := Int.natAbs_of_nonneg q_num_pos.le", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\n\u22a2 (fract q\u207b\u00b9).num < q.num"}, {"line": "set q_inv : \u211a := q.den / q.num with q_inv_def", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\n\u22a2 (fract q\u207b\u00b9).num < q.num"}, {"line": "have q_inv_eq : q\u207b\u00b9 = q_inv := by rw [q_inv_def, inv_def', divInt_eq_div, Int.cast_natCast]", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\n\u22a2 (fract q\u207b\u00b9).num < q.num"}, {"line": "suffices (q_inv - \u230aq_inv\u230b).num < q.num by rwa [q_inv_eq]", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\n\u22a2 (q_inv - \u2191\u230aq_inv\u230b).num < q.num"}, {"line": "suffices ((q.den - q.num * \u230aq_inv\u230b : \u211a) / q.num).num < q.num by\n    field_simp [q_inv, this, ne_of_gt q_num_pos]", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\n\u22a2 ((\u2191q.den - \u2191q.num * \u2191\u230aq_inv\u230b) / \u2191q.num).num < q.num"}, {"line": "suffices (q.den : \u2124) - q.num * \u230aq_inv\u230b < q.num by\n    have : ((q.den - q.num * \u230aq_inv\u230b : \u211a) / q.num).num = q.den - q.num * \u230aq_inv\u230b := by\n      suffices ((q.den : \u2124) - q.num * \u230aq_inv\u230b).natAbs.Coprime q.num.natAbs from\n        mod_cast Rat.num_div_eq_of_coprime q_num_pos this\n      have tmp := Nat.coprime_sub_mul_floor_rat_div_of_coprime q.reduced.symm\n      simpa only [Nat.cast_natAbs,abs_of_nonneg q_num_pos.le] using tmp\n    rwa [this]", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\n\u22a2 \u2191q.den - q.num * \u230aq_inv\u230b < q.num"}, {"line": "have q_inv_num_denom_ineq : q\u207b\u00b9.num - \u230aq\u207b\u00b9\u230b * q\u207b\u00b9.den < q\u207b\u00b9.den := sorry", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\nq_inv_num_denom_ineq : q\u207b\u00b9.num - \u230aq\u207b\u00b9\u230b * \u2191q\u207b\u00b9.den < \u2191q\u207b\u00b9.den\n\u22a2 \u2191q.den - q.num * \u230aq_inv\u230b < q.num"}, {"line": "have : q_inv.num = q.den \u2227 q_inv.den = q.num.natAbs := by\n    have coprime_q_denom_q_num : q.den.Coprime q.num.natAbs := q.reduced.symm\n    have : Int.natAbs q.den = q.den := by simp\n    rw [\u2190 this] at coprime_q_denom_q_num\n    rw [q_inv_def]\n    constructor\n    \u00b7 exact mod_cast Rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n    \u00b7 suffices (((q.den : \u211a) / q.num).den : \u2124) = q.num.natAbs by exact mod_cast this\n      rw [q_num_abs_eq_q_num]\n      exact mod_cast Rat.den_div_eq_of_coprime q_num_pos coprime_q_denom_q_num", "tactic_state": "q : \u211a\nq_pos : 0 < q\nq_num_pos : 0 < q.num\nq_num_abs_eq_q_num : \u2191q.num.natAbs = q.num\nq_inv : \u211a := \u2191q.den / \u2191q.num\nq_inv_def : q_inv = \u2191q.den / \u2191q.num\nq_inv_eq : q\u207b\u00b9 = q_inv\nq_inv_num_denom_ineq : q\u207b\u00b9.num - \u230aq\u207b\u00b9\u230b * \u2191q\u207b\u00b9.den < \u2191q\u207b\u00b9.den\nthis : q_inv.num = \u2191q.den \u2227 q_inv.den = q.num.natAbs\n\u22a2 \u2191q.den - q.num * \u230aq_inv\u230b < q.num"}, {"line": "rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq", "tactic_state": "No Goals!"}]}
{"declaration": "lemma addSubmonoid_closure_range_mul_self : closure (range fun x : \u211a \u21a6 x * x) = nonneg _ := by\n  simpa only [sq] using addSubmonoid_closure_range_pow two_ne_zero even_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Star.lean", "context": {"open": ["AddSubmonoid Set", "scoped NNRat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry = nonneg ?m.262"}, {"line": "simpa only [sq] using addSubmonoid_closure_range_pow two_ne_zero even_two", "tactic_state": "No Goals!"}]}
{"declaration": "lemma num_eq_zero {q : \u211a} : q.num = 0 \u2194 q = 0 := by\n  induction q\n  constructor\n  \u00b7 rintro rfl\n    exact mk'_zero _ _ _\n  \u00b7 exact congr_arg num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Defs.lean", "context": {"open": ["Function"], "variables": ["{q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\n\u22a2 q.num = 0 \u2194 q = 0"}, {"line": "induction q", "tactic_state": "case div\nn\u271d : \u2124\nd\u271d : \u2115\na\u271d\u00b9 : d\u271d \u2260 0\na\u271d : n\u271d.natAbs.Coprime d\u271d\n\u22a2 (\u2191n\u271d / \u2191d\u271d).num = 0 \u2194 \u2191n\u271d / \u2191d\u271d = 0"}, {"line": "constructor", "tactic_state": "case div.mp\nn\u271d : \u2124\nd\u271d : \u2115\na\u271d\u00b9 : d\u271d \u2260 0\na\u271d : n\u271d.natAbs.Coprime d\u271d\n\u22a2 (\u2191n\u271d / \u2191d\u271d).num = 0 \u2192 \u2191n\u271d / \u2191d\u271d = 0\n---\ncase div.mpr\nn\u271d : \u2124\nd\u271d : \u2115\na\u271d\u00b9 : d\u271d \u2260 0\na\u271d : n\u271d.natAbs.Coprime d\u271d\n\u22a2 \u2191n\u271d / \u2191d\u271d = 0 \u2192 (\u2191n\u271d / \u2191d\u271d).num = 0"}, {"line": "\u00b7 rintro rfl\n    exact mk'_zero _ _ _", "tactic_state": "case div.mpr\nn\u271d : \u2124\nd\u271d : \u2115\na\u271d\u00b9 : d\u271d \u2260 0\na\u271d : n\u271d.natAbs.Coprime d\u271d\n\u22a2 \u2191n\u271d / \u2191d\u271d = 0 \u2192 (\u2191n\u271d / \u2191d\u271d).num = 0"}, {"line": "\u00b7 exact congr_arg num", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zero_of_num_zero {q : \u211a} (hq : q.num = 0) : q = 0 := by simpa [hq] using q.num_divInt_den.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Defs.lean", "context": {"open": ["Function"], "variables": ["{q : \u211a}", "(a b c : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\nhq : q.num = 0\n\u22a2 q = 0"}, {"line": "simpa [hq] using q.num_divInt_den.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem divInt_eq_div (n d : \u2124) : n /. d = (n : \u211a) / d := by simp [div_def']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Defs.lean", "context": {"open": ["Function"], "variables": ["{q : \u211a}", "(a b c : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2124\n\u22a2 \u2191n / sorry = \u2191n / \u2191d"}, {"line": "simp [div_def']", "tactic_state": "n d : \u2124\n\u22a2 \u2191n / sorry () = \u2191n / \u2191d"}]}
{"declaration": "lemma eq_num_of_isInt {q : \u211a} (h : q.isInt) : q = q.num := by\n  rw [Rat.isInt] at h\n  rw [Nat.beq_eq_true_eq] at h\n  exact (Rat.coe_int_num_of_den_eq_one h).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Defs.lean", "context": {"open": ["Function"], "variables": ["{q : \u211a}", "(a b c : \u211a)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\nh : q.isInt = true\n\u22a2 q = \u2191q.num"}, {"line": "rw [Rat.isInt] at h", "tactic_state": "q : \u211a\nh : (q.den == 1) = true\n\u22a2 q = \u2191q.num"}, {"line": "rw [Nat.beq_eq_true_eq] at h", "tactic_state": "q : \u211a\nh : q.den = 1\n\u22a2 q = \u2191q.num"}, {"line": "exact (Rat.coe_int_num_of_den_eq_one h).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem num_den_mk {q : \u211a} {n d : \u2124} (hd : d \u2260 0) (qdf : q = n /. d) :\n    \u2203 c : \u2124, n = c * q.num \u2227 d = c * q.den := by\n  obtain rfl | hn := eq_or_ne n 0\n  \u00b7 simp [qdf]\n  have : q.num * d = n * \u2191q.den := by\n    refine (divInt_eq_iff ?_ hd).mp ?_\n    \u00b7 exact Int.natCast_ne_zero.mpr (Rat.den_nz _)\n    \u00b7 rwa [num_divInt_den]\n  have hqdn : q.num \u2223 n := by\n    rw [qdf]\n    exact Rat.num_dvd _ hd\n  refine \u27e8n / q.num, ?_, ?_\u27e9\n  \u00b7 rw [Int.ediv_mul_cancel hqdn]\n  \u00b7 refine Int.eq_mul_div_of_mul_eq_mul_of_dvd_left ?_ hqdn this\n    rw [qdf]\n    exact Rat.num_ne_zero.2 ((divInt_ne_zero hd).mpr hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\n\u22a2 \u2203 c, n = c * q.num \u2227 d = c * \u2191q.den"}, {"line": "obtain rfl | hn := eq_or_ne n 0", "tactic_state": "case inl\nq : \u211a\nd : \u2124\nhd : d \u2260 0\nqdf : q = \u21910 / sorry\n\u22a2 \u2203 c, 0 = c * q.num \u2227 d = c * \u2191q.den\n---\ncase inr\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\n\u22a2 \u2203 c, n = c * q.num \u2227 d = c * \u2191q.den"}, {"line": "\u00b7 simp [qdf]", "tactic_state": "case inr\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\n\u22a2 \u2203 c, n = c * q.num \u2227 d = c * \u2191q.den"}, {"line": "have : q.num * d = n * \u2191q.den := by\n    refine (divInt_eq_iff ?_ hd).mp ?_\n    \u00b7 exact Int.natCast_ne_zero.mpr (Rat.den_nz _)\n    \u00b7 rwa [num_divInt_den]", "tactic_state": "case inr\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\nthis : q.num * d = n * \u2191q.den\n\u22a2 \u2203 c, n = c * q.num \u2227 d = c * \u2191q.den"}, {"line": "have hqdn : q.num \u2223 n := sorry", "tactic_state": "case inr\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\nthis : q.num * d = n * \u2191q.den\nhqdn : q.num \u2223 n\n\u22a2 \u2203 c, n = c * q.num \u2227 d = c * \u2191q.den"}, {"line": "refine \u27e8n / q.num, ?_, ?_\u27e9", "tactic_state": "case inr.refine_1\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\nthis : q.num * d = n * \u2191q.den\nhqdn : q.num \u2223 n\n\u22a2 n = n / q.num * q.num\n---\ncase inr.refine_2\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\nthis : q.num * d = n * \u2191q.den\nhqdn : q.num \u2223 n\n\u22a2 d = n / q.num * \u2191q.den"}, {"line": "\u00b7 rw [Int.ediv_mul_cancel hqdn]", "tactic_state": "case inr.refine_2\nq : \u211a\nn d : \u2124\nhd : d \u2260 0\nqdf : q = \u2191n / sorry\nhn : n \u2260 0\nthis : q.num * d = n * \u2191q.den\nhqdn : q.num \u2223 n\n\u22a2 d = n / q.num * \u2191q.den"}, {"line": "\u00b7 refine Int.eq_mul_div_of_mul_eq_mul_of_dvd_left ?_ hqdn this\n    rw [qdf]\n    exact Rat.num_ne_zero.2 ((divInt_ne_zero hd).mpr hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem den_mk (n d : \u2124) : (n /. d).den = if d = 0 then 1 else d.natAbs / n.gcd d := by\n  have (m : \u2115) : Int.natAbs (m + 1) = m + 1 := by\n    rw [\u2190 Nat.cast_one]\n    rw [\u2190 Nat.cast_add]\n    rw [Int.natAbs_cast]\n  rcases d with ((_ | _) | _) <;>\n    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,\n      if_neg (Nat.cast_add_one_ne_zero _), this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n d : \u2124\n\u22a2 sorry = if d = 0 then 1 else d.natAbs / n.gcd d"}, {"line": "have (m : \u2115) : Int.natAbs (m + 1) = m + 1 := by\n    rw [\u2190 Nat.cast_one]\n    rw [\u2190 Nat.cast_add]\n    rw [Int.natAbs_cast]", "tactic_state": "n d : \u2124\nthis : \u2200 (m : \u2115), (\u2191m + 1).natAbs = m + 1\n\u22a2 sorry = if d = 0 then 1 else d.natAbs / n.gcd d"}, {"line": "rcases d with ((_ | _) | _) <;>\n    simp [divInt, mkRat, Rat.normalize, Nat.succPNat, Int.sign, Int.gcd,\n      if_neg (Nat.cast_add_one_ne_zero _), this]", "tactic_state": "case ofNat.zero\nn : \u2124\nthis : \u2200 (m : \u2115), (\u2191m + 1).natAbs = m + 1\n\u22a2 sorry () = 1\n---\ncase ofNat.succ\nn : \u2124\nthis : \u2200 (m : \u2115), (\u2191m + 1).natAbs = m + 1\nn\u271d : \u2115\n\u22a2 sorry () = (n\u271d + 1) / n.natAbs.gcd (n\u271d + 1)\n---\ncase negSucc\nn : \u2124\nthis : \u2200 (m : \u2115), (\u2191m + 1).natAbs = m + 1\na\u271d : \u2115\n\u22a2 sorry () = (a\u271d + 1) / n.natAbs.gcd (a\u271d + 1)"}]}
{"declaration": "theorem mul_self_den (q : \u211a) : (q * q).den = q.den * q.den := by\n  rw [Rat.mul_den]\n  rw [Int.natAbs_mul]\n  rw [Nat.Coprime.gcd_eq_one]\n  rw [Nat.div_one]\n  exact (q.reduced.mul_right q.reduced).mul (q.reduced.mul_right q.reduced)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\n\u22a2 (q * q).den = q.den * q.den"}, {"line": "rw [Rat.mul_den]", "tactic_state": "q : \u211a\n\u22a2 q.den * q.den / (q.num * q.num).natAbs.gcd (q.den * q.den) = q.den * q.den"}, {"line": "rw [Int.natAbs_mul]", "tactic_state": "q : \u211a\n\u22a2 q.den * q.den / (q.num.natAbs * q.num.natAbs).gcd (q.den * q.den) = q.den * q.den"}, {"line": "rw [Nat.Coprime.gcd_eq_one]", "tactic_state": "q : \u211a\n\u22a2 q.den * q.den / 1 = q.den * q.den\n---\nq : \u211a\n\u22a2 (q.num.natAbs * q.num.natAbs).Coprime (q.den * q.den)"}, {"line": "rw [Nat.div_one]", "tactic_state": "q : \u211a\n\u22a2 (q.num.natAbs * q.num.natAbs).Coprime (q.den * q.den)"}, {"line": "exact (q.reduced.mul_right q.reduced).mul (q.reduced.mul_right q.reduced)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_int_inj {a b c d : \u2124} (hb0 : 0 < b) (hd0 : 0 < d) (h1 : Nat.Coprime a.natAbs b.natAbs)\n    (h2 : Nat.Coprime c.natAbs d.natAbs) (h : (a : \u211a) / b = (c : \u211a) / d) : a = c \u2227 b = d := by\n  apply And.intro\n  \u00b7 rw [\u2190 num_div_eq_of_coprime hb0 h1, h, num_div_eq_of_coprime hd0 h2]\n  \u00b7 rw [\u2190 den_div_eq_of_coprime hb0 h1, h, den_div_eq_of_coprime hd0 h2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c d : \u2124\nhb0 : 0 < b\nhd0 : 0 < d\nh1 : a.natAbs.Coprime b.natAbs\nh2 : c.natAbs.Coprime d.natAbs\nh : \u2191a / \u2191b = \u2191c / \u2191d\n\u22a2 a = c \u2227 b = d"}, {"line": "apply And.intro", "tactic_state": "case left\na b c d : \u2124\nhb0 : 0 < b\nhd0 : 0 < d\nh1 : a.natAbs.Coprime b.natAbs\nh2 : c.natAbs.Coprime d.natAbs\nh : \u2191a / \u2191b = \u2191c / \u2191d\n\u22a2 a = c\n---\ncase right\na b c d : \u2124\nhb0 : 0 < b\nhd0 : 0 < d\nh1 : a.natAbs.Coprime b.natAbs\nh2 : c.natAbs.Coprime d.natAbs\nh : \u2191a / \u2191b = \u2191c / \u2191d\n\u22a2 b = d"}, {"line": "\u00b7 rw [\u2190 num_div_eq_of_coprime hb0 h1, h, num_div_eq_of_coprime hd0 h2]", "tactic_state": "case right\na b c d : \u2124\nhb0 : 0 < b\nhd0 : 0 < d\nh1 : a.natAbs.Coprime b.natAbs\nh2 : c.natAbs.Coprime d.natAbs\nh : \u2191a / \u2191b = \u2191c / \u2191d\n\u22a2 b = d"}, {"line": "\u00b7 rw [\u2190 den_div_eq_of_coprime hb0 h1, h, den_div_eq_of_coprime hd0 h2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_natCast_den (a : \u2115) : (a : \u211a)\u207b\u00b9.den = if a = 0 then 1 else a := by\n  simpa [-inv_intCast_den, ofInt_eq_cast] using inv_intCast_den a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Lemmas.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 (\u2191a)\u207b\u00b9.den = if a = 0 then 1 else a"}, {"line": "simpa [-inv_intCast_den, ofInt_eq_cast] using inv_intCast_den a", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cast_commute (q : \u211a\u22650) (a : \u03b1) : Commute (\u2191q) a := by\n  simpa only [cast_def] using (q.num.cast_commute a).div_left (q.den.cast_commute a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Cast/Defs.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 : Type*}", "[DivisionSemiring \u03b1] {q r : \u211a\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : DivisionSemiring \u03b1\nq : \u211a\u22650\na : \u03b1\n\u22a2 Commute (\u2191q) a"}, {"line": "simpa only [cast_def] using (q.num.cast_commute a).div_left (q.den.cast_commute a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_commute (r : \u211a) (a : \u03b1) : Commute (\u2191r) a := by\n  simpa only [cast_def] using (r.1.cast_commute a).div_left (r.2.cast_commute a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Cast/Defs.lean", "context": {"open": [], "variables": ["{F \u03b9 \u03b1 \u03b2 : Type*}", "[DivisionSemiring \u03b1] {q r : \u211a\u22650}", "[DivisionRing \u03b1] {p q : \u211a}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : DivisionSemiring \u03b1\ninst\u271d : DivisionRing \u03b1\nr : \u211a\na : \u03b1\n\u22a2 Commute (\u2191r) a"}, {"line": "simpa only [cast_def] using (r.1.cast_commute a).div_left (r.2.cast_commute a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cast_inv_int (n : \u2124) : ((n\u207b\u00b9 : \u211a) : \u03b1) = (n : \u03b1)\u207b\u00b9 := by\n  rcases n with n | n\n  \u00b7 simp [ofInt_eq_cast, cast_inv_nat]\n  \u00b7 simp only [ofInt_eq_cast, Int.cast_negSucc, \u2190 Nat.cast_succ, cast_neg, inv_neg, cast_inv_nat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Rat/Cast/Lemmas.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} [DivisionRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : DivisionRing \u03b1\nn : \u2124\n\u22a2 \u2191(\u2191n)\u207b\u00b9 = (\u2191n)\u207b\u00b9"}, {"line": "rcases n with n | n", "tactic_state": "case ofNat\n\u03b1 : Type u_1\ninst\u271d : DivisionRing \u03b1\nn : \u2115\n\u22a2 \u2191(\u2191(Int.ofNat n))\u207b\u00b9 = (\u2191(Int.ofNat n))\u207b\u00b9\n---\ncase negSucc\n\u03b1 : Type u_1\ninst\u271d : DivisionRing \u03b1\nn : \u2115\n\u22a2 \u2191(\u2191(Int.negSucc n))\u207b\u00b9 = (\u2191(Int.negSucc n))\u207b\u00b9"}, {"line": "\u00b7 simp [ofInt_eq_cast, cast_inv_nat]", "tactic_state": "case negSucc\n\u03b1 : Type u_1\ninst\u271d : DivisionRing \u03b1\nn : \u2115\n\u22a2 \u2191(\u2191(Int.negSucc n))\u207b\u00b9 = (\u2191(Int.negSucc n))\u207b\u00b9"}, {"line": "\u00b7 simp only [ofInt_eq_cast, Int.cast_negSucc, \u2190 Nat.cast_succ, cast_neg, inv_neg, cast_inv_nat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_true (h : f n = true) : cantorFunctionAux c f n = c ^ n := by\n  simp [cantorFunctionAux, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : f n = true\n\u22a2 cantorFunctionAux c f n = c ^ n"}, {"line": "simp [cantorFunctionAux, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_false (h : f n = false) : cantorFunctionAux c f n = 0 := by\n  simp [cantorFunctionAux, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : f n = false\n\u22a2 cantorFunctionAux c f n = 0"}, {"line": "simp [cantorFunctionAux, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_nonneg (h : 0 \u2264 c) : 0 \u2264 cantorFunctionAux c f n := by\n  cases h' : f n\n  \u00b7 simp [h']\n  \u00b7 simpa [h'] using pow_nonneg h _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\n\u22a2 0 \u2264 cantorFunctionAux c f n"}, {"line": "cases h' : f n", "tactic_state": "case false\nc : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\nh' : f n = false\n\u22a2 0 \u2264 cantorFunctionAux c f n\n---\ncase true\nc : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\nh' : f n = true\n\u22a2 0 \u2264 cantorFunctionAux c f n"}, {"line": "\u00b7 simp [h']", "tactic_state": "case true\nc : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\nh : 0 \u2264 c\nh' : f n = true\n\u22a2 0 \u2264 cantorFunctionAux c f n"}, {"line": "\u00b7 simpa [h'] using pow_nonneg h _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_eq (h : f n = g n) :\n    cantorFunctionAux c f n = cantorFunctionAux c g n := by simp [cantorFunctionAux, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf g : \u2115 \u2192 Bool\nn : \u2115\nh : f n = g n\n\u22a2 cantorFunctionAux c f n = cantorFunctionAux c g n"}, {"line": "simp [cantorFunctionAux, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_zero (f : \u2115 \u2192 Bool) : cantorFunctionAux c f 0 = cond (f 0) 1 0 := by\n  cases h : f 0 <;> simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\n\u22a2 cantorFunctionAux c f 0 = bif f 0 then 1 else 0"}, {"line": "cases h : f 0 <;> simp [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunctionAux_succ (f : \u2115 \u2192 Bool) :\n    (fun n => cantorFunctionAux c f (n + 1)) = fun n =>\n      c * cantorFunctionAux c (fun n => f (n + 1)) n := by\n  ext n\n  cases h : f (n + 1) <;> simp [h, _root_.pow_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\n\u22a2 (fun n => cantorFunctionAux c f (n + 1)) = fun n => c * cantorFunctionAux c (fun n => f (n + 1)) n"}, {"line": "ext n", "tactic_state": "case h\nc : \u211d\nf : \u2115 \u2192 Bool\nn : \u2115\n\u22a2 cantorFunctionAux c f (n + 1) = c * cantorFunctionAux c (fun n => f (n + 1)) n"}, {"line": "cases h : f (n + 1) <;> simp [h, _root_.pow_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunction_succ (f : \u2115 \u2192 Bool) (h1 : 0 \u2264 c) (h2 : c < 1) :\n    cantorFunction c f = cond (f 0) 1 0 + c * cantorFunction c fun n => f (n + 1) := by\n  rw [cantorFunction]\n  rw [(summable_cantor_function f h1 h2).tsum_eq_zero_add]\n  rw [cantorFunctionAux_succ]\n  rw [tsum_mul_left]\n  rw [cantorFunctionAux]\n  rw [pow_zero]\n  rw [cantorFunction]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 cantorFunction c f = (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [cantorFunction]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 \u2211' (n : \u2115), cantorFunctionAux c f n = (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [(summable_cantor_function f h1 h2).tsum_eq_zero_add]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 cantorFunctionAux c f 0 + \u2211' (b : \u2115), cantorFunctionAux c f (b + 1) =\n    (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [cantorFunctionAux_succ]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 cantorFunctionAux c f 0 + \u2211' (n : \u2115), c * cantorFunctionAux c (fun n => f (n + 1)) n =\n    (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [tsum_mul_left]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 cantorFunctionAux c f 0 + c * \u2211' (x : \u2115), cantorFunctionAux c (fun n => f (n + 1)) x =\n    (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [cantorFunctionAux]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 (bif f 0 then c ^ 0 else 0) + c * \u2211' (x : \u2115), cantorFunctionAux c (fun n => f (n + 1)) x =\n    (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [pow_zero]", "tactic_state": "c : \u211d\nf : \u2115 \u2192 Bool\nh1 : 0 \u2264 c\nh2 : c < 1\n\u22a2 (bif f 0 then 1 else 0) + c * \u2211' (x : \u2115), cantorFunctionAux c (fun n => f (n + 1)) x =\n    (bif f 0 then 1 else 0) + c * cantorFunction c fun n => f (n + 1)"}, {"line": "rw [cantorFunction]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cantorFunction_injective (h1 : 0 < c) (h2 : c < 1 / 2) :\n    Function.Injective (cantorFunction c) := by\n  intro f g hfg\n  classical\n    contrapose hfg with h\n    have : \u2203 n, f n \u2260 g n := Function.ne_iff.mp h\n    let n := Nat.find this\n    have hn : \u2200 k : \u2115, k < n \u2192 f k = g k := by\n      intro k hk\n      apply of_not_not\n      exact Nat.find_min this hk\n    cases fn : f n\n    \u00b7 apply _root_.ne_of_lt\n      refine increasing_cantorFunction h1 h2 hn fn ?_\n      apply Bool.eq_true_of_not_eq_false\n      rw [\u2190 fn]\n      apply Ne.symm\n      exact Nat.find_spec this\n    \u00b7 apply _root_.ne_of_gt\n      refine increasing_cantorFunction h1 h2 (fun k hk => (hn k hk).symm) ?_ fn\n      apply Bool.eq_false_of_not_eq_true\n      rw [\u2190 fn]\n      apply Ne.symm\n      exact Nat.find_spec this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\nh1 : 0 < c\nh2 : c < 1 / 2\n\u22a2 Function.Injective (cantorFunction c)"}, {"line": "intro f g hfg", "tactic_state": "c : \u211d\nh1 : 0 < c\nh2 : c < 1 / 2\nf g : \u2115 \u2192 Bool\nhfg : cantorFunction c f = cantorFunction c g\n\u22a2 f = g"}, {"line": "classical\n    contrapose hfg with h\n    have : \u2203 n, f n \u2260 g n := Function.ne_iff.mp h\n    let n := Nat.find this\n    have hn : \u2200 k : \u2115, k < n \u2192 f k = g k := by\n      intro k hk\n      apply of_not_not\n      exact Nat.find_min this hk\n    cases fn : f n\n    \u00b7 apply _root_.ne_of_lt\n      refine increasing_cantorFunction h1 h2 hn fn ?_\n      apply Bool.eq_true_of_not_eq_false\n      rw [\u2190 fn]\n      apply Ne.symm\n      exact Nat.find_spec this\n    \u00b7 apply _root_.ne_of_gt\n      refine increasing_cantorFunction h1 h2 (fun k hk => (hn k hk).symm) ?_ fn\n      apply Bool.eq_false_of_not_eq_true\n      rw [\u2190 fn]\n      apply Ne.symm\n      exact Nat.find_spec this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_univ_real : #(Set.univ : Set \u211d) = \ud835\udd20 := by rw [mk_univ, mk_real]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 mk \u2191Set.univ = continuum"}, {"line": "rw [mk_univ, mk_real]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_Ioi_real (a : \u211d) : #(Ioi a) = \ud835\udd20 := by\n  refine le_antisymm (mk_real \u25b8 mk_set_le _) ?_\n  rw [\u2190 not_lt]\n  intro h\n  refine _root_.ne_of_lt ?_ mk_univ_real\n  have hu : Iio a \u222a {a} \u222a Ioi a = Set.univ := by\n    convert @Iic_union_Ioi \u211d _ _\n    exact Iio_union_right\n  rw [\u2190 hu]\n  refine lt_of_le_of_lt (mk_union_le _ _) ?_\n  refine lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) ?_\n  have h2 : (fun x => a + a - x) '' Ioi a = Iio a := by\n    convert @image_const_sub_Ioi \u211d _ _ _\n    simp\n  rw [\u2190 h2]\n  refine add_lt_of_lt (cantor _).le ?_ h\n  refine add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) ?_\n  rw [mk_singleton]\n  exact one_lt_aleph0.trans (cantor _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 mk \u2191(Ioi a) = continuum"}, {"line": "refine le_antisymm (mk_real \u25b8 mk_set_le _) ?_", "tactic_state": "a : \u211d\n\u22a2 continuum \u2264 mk \u2191(Ioi a)"}, {"line": "rw [\u2190 not_lt]", "tactic_state": "a : \u211d\n\u22a2 \u00acmk \u2191(Ioi a) < continuum"}, {"line": "intro h", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\n\u22a2 False"}, {"line": "refine _root_.ne_of_lt ?_ mk_univ_real", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\n\u22a2 mk \u2191Set.univ < continuum"}, {"line": "have hu : Iio a \u222a {a} \u222a Ioi a = Set.univ := by\n    convert @Iic_union_Ioi \u211d _ _\n    exact Iio_union_right", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 mk \u2191Set.univ < continuum"}, {"line": "rw [\u2190 hu]", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 mk \u2191(Iio a \u222a {a} \u222a Ioi a) < continuum"}, {"line": "refine lt_of_le_of_lt (mk_union_le _ _) ?_", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 mk \u2191(Iio a \u222a {a}) + mk \u2191(Ioi a) < continuum"}, {"line": "refine lt_of_le_of_lt (add_le_add_right (mk_union_le _ _) _) ?_", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\n\u22a2 mk \u2191(Iio a) + mk \u2191{a} + mk \u2191(Ioi a) < continuum"}, {"line": "have h2 : (fun x => a + a - x) '' Ioi a = Iio a := by\n    convert @image_const_sub_Ioi \u211d _ _ _\n    simp", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 mk \u2191(Iio a) + mk \u2191{a} + mk \u2191(Ioi a) < continuum"}, {"line": "rw [\u2190 h2]", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 mk \u2191((fun x => a + a - x) '' Ioi a) + mk \u2191{a} + mk \u2191(Ioi a) < continuum"}, {"line": "refine add_lt_of_lt (cantor _).le ?_ h", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 mk \u2191((fun x => a + a - x) '' Ioi a) + mk \u2191{a} < continuum"}, {"line": "refine add_lt_of_lt (cantor _).le (mk_image_le.trans_lt h) ?_", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 mk \u2191{a} < continuum"}, {"line": "rw [mk_singleton]", "tactic_state": "a : \u211d\nh : mk \u2191(Ioi a) < continuum\nhu : Iio a \u222a {a} \u222a Ioi a = Set.univ\nh2 : (fun x => a + a - x) '' Ioi a = Iio a\n\u22a2 1 < continuum"}, {"line": "exact one_lt_aleph0.trans (cantor _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_Iio_real (a : \u211d) : #(Iio a) = \ud835\udd20 := by\n  refine le_antisymm (mk_real \u25b8 mk_set_le _) ?_\n  have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by\n    simp only [image_const_sub_Iio]\n    simp only [add_sub_cancel_right]\n  exact mk_Ioi_real a \u25b8 h2 \u25b8 mk_image_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Cardinality.lean", "context": {"open": ["Nat Set", "Cardinal"], "variables": ["{c : \u211d} {f g : \u2115 \u2192 Bool} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 mk \u2191(Iio a) = continuum"}, {"line": "refine le_antisymm (mk_real \u25b8 mk_set_le _) ?_", "tactic_state": "a : \u211d\n\u22a2 continuum \u2264 mk \u2191(Iio a)"}, {"line": "have h2 : (fun x => a + a - x) '' Iio a = Ioi a := by\n    simp only [image_const_sub_Iio]\n    simp only [add_sub_cancel_right]", "tactic_state": "a : \u211d\nh2 : (fun x => a + a - x) '' Iio a = Ioi a\n\u22a2 continuum \u2264 mk \u2191(Iio a)"}, {"line": "exact mk_Ioi_real a \u25b8 h2 \u25b8 mk_image_le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_div_add_one_div : 1 / p + 1 / q = 1 / r := by simpa using h.inv_add_inv_eq_inv", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u211d\n\u22a2 1 / p + 1 / q = 1 / r"}, {"line": "simpa using h.inv_add_inv_eq_inv", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_sub_one : p\u207b\u00b9 - 1 = -q\u207b\u00b9 := by simpa using congr(-$(h.one_sub_inv))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\n\u22a2 p\u207b\u00b9 - 1 = -q\u207b\u00b9"}, {"line": "simpa using congr(-$(h.one_sub_inv))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_add : p * q = p + q := by\n  simpa only [sub_mul,sub_eq_iff_eq_add,one_mul] using h.sub_one_mul_conj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\n\u22a2 p * q = p + q"}, {"line": "simpa only [sub_mul,sub_eq_iff_eq_add,one_mul] using h.sub_one_mul_conj", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Real.holderConjugate_iff : p.HolderConjugate q \u2194 1 < p \u2227 p\u207b\u00b9 + q\u207b\u00b9 = 1 := by\n  refine \u27e8fun h \u21a6 \u27e8h.lt, h.inv_add_inv_eq_one\u27e9, ?_\u27e9\n  rintro \u27e8hp, h\u27e9\n  have hp' := zero_lt_one.trans hp\n  refine \u27e8inv_one (G := \u211d) |>.symm \u25b8 h, hp', ?_\u27e9\n  rw [\u2190 inv_lt_one\u2080 hp'] at hp\n  rw [\u2190 sub_pos] at hp\n  exact inv_pos.mp <| eq_sub_of_add_eq' h \u25b8 hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\n\u22a2 p.HolderConjugate q \u2194 1 < p \u2227 p\u207b\u00b9 + q\u207b\u00b9 = 1"}, {"line": "refine \u27e8fun h \u21a6 \u27e8h.lt, h.inv_add_inv_eq_one\u27e9, ?_\u27e9", "tactic_state": "p q : \u211d\n\u22a2 1 < p \u2227 p\u207b\u00b9 + q\u207b\u00b9 = 1 \u2192 p.HolderConjugate q"}, {"line": "rintro \u27e8hp, h\u27e9", "tactic_state": "case intro\np q : \u211d\nhp : 1 < p\nh : p\u207b\u00b9 + q\u207b\u00b9 = 1\n\u22a2 p.HolderConjugate q"}, {"line": "have hp' := zero_lt_one.trans hp", "tactic_state": "case intro\np q : \u211d\nhp : 1 < p\nh : p\u207b\u00b9 + q\u207b\u00b9 = 1\nhp' : 0 < p\n\u22a2 p.HolderConjugate q"}, {"line": "refine \u27e8inv_one (G := \u211d) |>.symm \u25b8 h, hp', ?_\u27e9", "tactic_state": "case intro\np q : \u211d\nhp : 1 < p\nh : p\u207b\u00b9 + q\u207b\u00b9 = 1\nhp' : 0 < p\n\u22a2 0 < q"}, {"line": "rw [\u2190 inv_lt_one\u2080 hp'] at hp", "tactic_state": "case intro\np q : \u211d\nhp : p\u207b\u00b9 < 1\nh : p\u207b\u00b9 + q\u207b\u00b9 = 1\nhp' : 0 < p\n\u22a2 0 < q"}, {"line": "rw [\u2190 sub_pos] at hp", "tactic_state": "case intro\np q : \u211d\nhp : 0 < 1 - p\u207b\u00b9\nh : p\u207b\u00b9 + q\u207b\u00b9 = 1\nhp' : 0 < p\n\u22a2 0 < q"}, {"line": "exact inv_pos.mp <| eq_sub_of_add_eq' h \u25b8 hp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma holderConjugate_one_div (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    (1 / a).HolderConjugate (1 / b) := by simpa using HolderConjugate.inv_inv ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 (1 / a).HolderConjugate (1 / b)"}, {"line": "simpa using HolderConjugate.inv_inv ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_inv_add_inv : (p\u207b\u00b9 + q\u207b\u00b9)\u207b\u00b9 = r := by exact_mod_cast h.coe.inv_inv_add_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : NNReal\n\u22a2 (p\u207b\u00b9 + q\u207b\u00b9)\u207b\u00b9 = r"}, {"line": "exact_mod_cast h.coe.inv_inv_add_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conjugate_eq : q = p / (p - 1) := by\n  have : ((1 : \u211d\u22650) : \u211d) \u2264 p := h.coe.lt.le\n  exact_mod_cast NNReal.coe_sub this \u25b8 coe_one \u25b8 h.coe.conjugate_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : NNReal\n\u22a2 q = p / (p - 1)"}, {"line": "have : ((1 : \u211d\u22650) : \u211d) \u2264 p := h.coe.lt.le", "tactic_state": "p q : NNReal\nthis : sorry \u2264 p\n\u22a2 q = p / (p - 1)"}, {"line": "exact_mod_cast NNReal.coe_sub this \u25b8 coe_one \u25b8 h.coe.conjugate_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_eq_add : p * q = p + q := by\n  simpa [mul_add, add_mul, h.ne_zero, h.symm.ne_zero, add_comm q] using congr(p * $(h.inv_eq) * q)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : NNReal\n\u22a2 p * q = p + q"}, {"line": "simpa [mul_add, add_mul, h.ne_zero, h.symm.ne_zero, add_comm q] using congr(p * $(h.inv_eq) * q)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma holderConjugate_one_div (ha : 0 < a) (hb : 0 < b) (hab : a + b = 1) :\n    (1 / a).HolderConjugate (1 / b) := by simpa using HolderConjugate.inv_inv ha hb hab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : NNReal\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 (1 / a).HolderConjugate (1 / b)"}, {"line": "simpa using HolderConjugate.inv_inv ha hb hab", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Real.HolderTriple.toNNReal {p q r : \u211d} (h : p.HolderTriple q r) :\n    p.toNNReal.HolderTriple q.toNNReal r.toNNReal := by\n  simpa [\u2190 NNReal.holderTriple_coe_iff, h.nonneg, h.symm.nonneg, h.nonneg']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q r : \u211d\nh : p.HolderTriple q r\n\u22a2 p.toNNReal.HolderTriple q.toNNReal r.toNNReal"}, {"line": "simpa [\u2190 NNReal.holderTriple_coe_iff, h.nonneg, h.symm.nonneg, h.nonneg']", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Real.HolderConjugate.toNNReal {p q : \u211d} (h : p.HolderConjugate q) :\n    p.toNNReal.HolderConjugate q.toNNReal := by\n  simpa using Real.HolderTriple.toNNReal h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : \u211d\nh : p.HolderConjugate q\n\u22a2 p.toNNReal.HolderConjugate q.toNNReal"}, {"line": "simpa using Real.HolderTriple.toNNReal h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma of_toReal (h : p.toReal.HolderConjugate q.toReal) : p.HolderConjugate q := by\n  rw [Real.HolderConjugate] at h\n  exact HolderTriple.of_toReal (toReal_one \u25b8 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650\u221e}", "(r) in", "(r) in", "(r) in", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : ENNReal\nh : p.toReal.HolderConjugate q.toReal\n\u22a2 p.HolderConjugate q"}, {"line": "rw [Real.HolderConjugate] at h", "tactic_state": "p q : ENNReal\nh : p.toReal.HolderTriple q.toReal 1\n\u22a2 p.HolderConjugate q"}, {"line": "exact HolderTriple.of_toReal (toReal_one \u25b8 h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_iff (hp : 1 < p.toReal) :\n    p.toReal.HolderConjugate q.toReal \u2194 p.HolderConjugate q := by\n  refine \u27e8of_toReal, fun h \u21a6 ?_\u27e9\n  have hq : 0 < q.toReal := by\n    rw [toReal_pos_iff]\n    refine \u27e8pos q p, lt_top_iff_one_lt q p |>.mpr ?_\u27e9\n    contrapose! hp\n    exact toReal_mono one_ne_top hp\n  simpa using HolderTriple.toReal 1 (zero_lt_one.trans hp) hq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ConjExponents.lean", "context": {"open": ["scoped ENNReal NNReal"], "variables": ["{a b p q r : \u211d}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650}", "(h : p.HolderTriple q r)", "(h : p.HolderConjugate q)", "{a b p q r : \u211d\u22650\u221e}", "(r) in", "(r) in", "(r) in", "(r) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p q : ENNReal\nhp : 1 < p.toReal\n\u22a2 p.toReal.HolderConjugate q.toReal \u2194 p.HolderConjugate q"}, {"line": "refine \u27e8of_toReal, fun h \u21a6 ?_\u27e9", "tactic_state": "p q : ENNReal\nhp : 1 < p.toReal\nh : p.HolderConjugate q\n\u22a2 p.toReal.HolderConjugate q.toReal"}, {"line": "have hq : 0 < q.toReal := sorry", "tactic_state": "p q : ENNReal\nhp : 1 < p.toReal\nh : p.HolderConjugate q\nhq : 0 < q.toReal\n\u22a2 p.toReal.HolderConjugate q.toReal"}, {"line": "simpa using HolderTriple.toReal 1 (zero_lt_one.trans hp) hq", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toENNReal_lt_top : (n : \u211d\u22650\u221e) < \u221e \u2194 n < \u22a4 := by simp [\u2190 toENNReal_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/ENatENNReal.lean", "context": {"open": ["NNReal ENNReal"], "variables": ["{m n : \u2115\u221e}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\u221e\n\u22a2 \u2191n < \u22a4 \u2194 n < \u22a4"}, {"line": "simp [\u2190 toENNReal_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_isGLB (hne : s.Nonempty) (hbdd : BddBelow s) : \u2203 x, IsGLB s x := by\n  have hne' : (-s).Nonempty := Set.nonempty_neg.mpr hne\n  have hbdd' : BddAbove (-s) := bddAbove_neg.mpr hbdd\n  use -Classical.choose (Real.exists_isLUB hne' hbdd')\n  rw [\u2190 isLUB_neg]\n  exact Classical.choose_spec (Real.exists_isLUB hne' hbdd')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\nhne : s.Nonempty\nhbdd : BddBelow s\n\u22a2 \u2203 x, IsGLB s x"}, {"line": "have hne' : (-s).Nonempty := Set.nonempty_neg.mpr hne", "tactic_state": "s : Set \u211d\nhne : s.Nonempty\nhbdd : BddBelow s\nhne' : (-s).Nonempty\n\u22a2 \u2203 x, IsGLB s x"}, {"line": "have hbdd' : BddAbove (-s) := bddAbove_neg.mpr hbdd", "tactic_state": "s : Set \u211d\nhne : s.Nonempty\nhbdd : BddBelow s\nhne' : (-s).Nonempty\nhbdd' : BddAbove (-s)\n\u22a2 \u2203 x, IsGLB s x"}, {"line": "use -Classical.choose (Real.exists_isLUB hne' hbdd')", "tactic_state": "case h\ns : Set \u211d\nhne : s.Nonempty\nhbdd : BddBelow s\nhne' : (-s).Nonempty\nhbdd' : BddAbove (-s)\n\u22a2 IsGLB s (-Classical.choose \u22ef)"}, {"line": "rw [\u2190 isLUB_neg]", "tactic_state": "case h\ns : Set \u211d\nhne : s.Nonempty\nhbdd : BddBelow s\nhne' : (-s).Nonempty\nhbdd' : BddAbove (-s)\n\u22a2 IsLUB (-s) (Classical.choose \u22ef)"}, {"line": "exact Classical.choose_spec (Real.exists_isLUB hne' hbdd')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iSup_const_zero : \u2a06 _ : \u03b9, (0 : \u211d) = 0 := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 exact Real.iSup_of_isEmpty _\n  \u00b7 exact ciSup_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u22a2 \u2a06 x, 0 = 0"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Sort u_1\nh\u271d : IsEmpty \u03b9\n\u22a2 \u2a06 x, 0 = 0\n---\ncase inr\n\u03b9 : Sort u_1\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a06 x, 0 = 0"}, {"line": "\u00b7 exact Real.iSup_of_isEmpty _", "tactic_state": "case inr\n\u03b9 : Sort u_1\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a06 x, 0 = 0"}, {"line": "\u00b7 exact ciSup_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInf_empty : sInf (\u2205 : Set \u211d) = 0 := by simp [sInf_def, sSup_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sInf \u2205 = 0"}, {"line": "simp [sInf_def, sSup_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iInf_const_zero : \u2a05 _ : \u03b9, (0 : \u211d) = 0 := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 exact Real.iInf_of_isEmpty _\n  \u00b7 exact ciInf_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\n\u22a2 \u2a05 x, 0 = 0"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Sort u_1\nh\u271d : IsEmpty \u03b9\n\u22a2 \u2a05 x, 0 = 0\n---\ncase inr\n\u03b9 : Sort u_1\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a05 x, 0 = 0"}, {"line": "\u00b7 exact Real.iInf_of_isEmpty _", "tactic_state": "case inr\n\u03b9 : Sort u_1\nh\u271d : Nonempty \u03b9\n\u22a2 \u2a05 x, 0 = 0"}, {"line": "\u00b7 exact ciInf_const", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sSup_nonneg (hs : \u2200 x \u2208 s, 0 \u2264 x) : 0 \u2264 sSup s := by\n  obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty\n  \u00b7 exact sSup_empty.ge\n  \u00b7 exact sSup_nonneg' \u27e8x, hx, hs _ hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2115\nhs : \u2200 x \u2208 s, 0 \u2264 x\n\u22a2 0 \u2264 sSup s"}, {"line": "obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty", "tactic_state": "case inl\nhs : \u2200 x \u2208 \u2205, 0 \u2264 x\n\u22a2 0 \u2264 sSup \u2205\n---\ncase inr.intro\ns : Set \u2115\nhs : \u2200 x \u2208 s, 0 \u2264 x\nx : \u2115\nhx : x \u2208 s\n\u22a2 0 \u2264 sSup s"}, {"line": "\u00b7 exact sSup_empty.ge", "tactic_state": "case inr.intro\ns : Set \u2115\nhs : \u2200 x \u2208 s, 0 \u2264 x\nx : \u2115\nhx : x \u2208 s\n\u22a2 0 \u2264 sSup s"}, {"line": "\u00b7 exact sSup_nonneg' \u27e8x, hx, hs _ hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sInf_nonpos (hs : \u2200 x \u2208 s, x \u2264 0) : sInf s \u2264 0 := by\n  obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty\n  \u00b7 exact sInf_empty.le\n  \u00b7 exact sInf_nonpos' \u27e8x, hx, hs _ hx\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u2115\nhs : \u2200 x \u2208 s, x \u2264 0\n\u22a2 sInf s \u2264 0"}, {"line": "obtain rfl | \u27e8x, hx\u27e9 := s.eq_empty_or_nonempty", "tactic_state": "case inl\nhs : \u2200 x \u2208 \u2205, x \u2264 0\n\u22a2 sInf \u2205 \u2264 0\n---\ncase inr.intro\ns : Set \u2115\nhs : \u2200 x \u2208 s, x \u2264 0\nx : \u2115\nhx : x \u2208 s\n\u22a2 sInf s \u2264 0"}, {"line": "\u00b7 exact sInf_empty.le", "tactic_state": "case inr.intro\ns : Set \u2115\nhs : \u2200 x \u2208 s, x \u2264 0\nx : \u2115\nhx : x \u2208 s\n\u22a2 sInf s \u2264 0"}, {"line": "\u00b7 exact sInf_nonpos' \u27e8x, hx, hs _ hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sInf_le_sSup (s : Set \u211d) (h\u2081 : BddBelow s) (h\u2082 : BddAbove s) : sInf s \u2264 sSup s := by\n  rcases s.eq_empty_or_nonempty with (rfl | hne)\n  \u00b7 rw [sInf_empty, sSup_empty]\n  \u00b7 exact csInf_le_csSup h\u2081 h\u2082 hne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\n\u22a2 sInf s \u2264 sSup s"}, {"line": "rcases s.eq_empty_or_nonempty with (rfl | hne)", "tactic_state": "case inl\nh\u2081 : BddBelow \u2205\nh\u2082 : BddAbove \u2205\n\u22a2 sInf \u2205 \u2264 sSup \u2205\n---\ncase inr\ns : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\nhne : s.Nonempty\n\u22a2 sInf s \u2264 sSup s"}, {"line": "\u00b7 rw [sInf_empty, sSup_empty]", "tactic_state": "case inr\ns : Set \u211d\nh\u2081 : BddBelow s\nh\u2082 : BddAbove s\nhne : s.Nonempty\n\u22a2 sInf s \u2264 sSup s"}, {"line": "\u00b7 exact csInf_le_csSup h\u2081 h\u2082 hne", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_natCast_add_one_lt_pow_of_one_lt (ha : 1 < a) : \u2203 m : \u2115, (m + 1 : \u211d) < a ^ m := by\n  obtain \u27e8k, posk, hk\u27e9 : \u2203 k : \u2115, 0 < k \u2227 1 / k + 1 < a := by\n    contrapose! ha\n    refine le_of_forall_lt_rat_imp_le ?_\n    intro q hq\n    refine (ha q.den (by positivity)).trans ?_\n    rw [\u2190 le_sub_iff_add_le]\n    rw [div_le_iff\u2080 (by positivity)]\n    rw [sub_mul]\n    rw [one_mul]\n    norm_cast at hq \u22a2\n    rw [\u2190 q.num_div_den] at hq\n    rw [one_lt_div (by positivity)] at hq\n    rw [q.mul_den_eq_num]\n    norm_cast at hq \u22a2\n    omega\n  use 2 * k ^ 2\n  calc\n    ((2 * k ^ 2 : \u2115) + 1 : \u211d) \u2264 2 ^ (2 * k) := mod_cast Nat.two_mul_sq_add_one_le_two_pow_two_mul _\n    _ = (1 / k * k + 1 : \u211d) ^ (2 * k) := by simp [posk.ne']; norm_num\n    _ \u2264 ((1 / k + 1) ^ k : \u211d) ^ (2 * k) := by gcongr; exact mul_add_one_le_add_one_pow (by simp) _\n    _ = (1 / k + 1 : \u211d) ^ (2 * k ^ 2) := by rw [\u2190 pow_mul, mul_left_comm, sq]\n    _ < a ^ (2 * k ^ 2) := by gcongr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in", "Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : 1 < a\n\u22a2 \u2203 m, \u2191m + 1 < a ^ m"}, {"line": "obtain \u27e8k, posk, hk\u27e9 : \u2203 k : \u2115, 0 < k \u2227 1 / k + 1 < a := by\n    contrapose! ha\n    refine le_of_forall_lt_rat_imp_le ?_\n    intro q hq\n    refine (ha q.den (by positivity)).trans ?_\n    rw [\u2190 le_sub_iff_add_le]\n    rw [div_le_iff\u2080 (by positivity)]\n    rw [sub_mul]\n    rw [one_mul]\n    norm_cast at hq \u22a2\n    rw [\u2190 q.num_div_den] at hq\n    rw [one_lt_div (by positivity)] at hq\n    rw [q.mul_den_eq_num]\n    norm_cast at hq \u22a2\n    omega", "tactic_state": "case intro.intro\na : \u211d\nha : 1 < a\nk : \u2115\nposk : 0 < k\nhk : 1 / \u2191k + 1 < a\n\u22a2 \u2203 m, \u2191m + 1 < a ^ m"}, {"line": "use 2 * k ^ 2", "tactic_state": "case h\na : \u211d\nha : 1 < a\nk : \u2115\nposk : 0 < k\nhk : 1 / \u2191k + 1 < a\n\u22a2 \u2191(2 * k ^ 2) + 1 < a ^ (2 * k ^ 2)"}, {"line": "calc\n    ((2 * k ^ 2 : \u2115) + 1 : \u211d) \u2264 2 ^ (2 * k) := mod_cast Nat.two_mul_sq_add_one_le_two_pow_two_mul _\n    _ = (1 / k * k + 1 : \u211d) ^ (2 * k) := by simp [posk.ne']; norm_num\n    _ \u2264 ((1 / k + 1) ^ k : \u211d) ^ (2 * k) := by gcongr; exact mul_add_one_le_add_one_pow (by simp) _\n    _ = (1 / k + 1 : \u211d) ^ (2 * k ^ 2) := by rw [\u2190 pow_mul, mul_left_comm, sq]\n    _ < a ^ (2 * k ^ 2) := by gcongr", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_nat_pos_inv_lt {b : \u211d} (hb : 0 < b) :\n    \u2203 (n : \u2115), 0 < n \u2227 (n : \u211d)\u207b\u00b9 < b := by\n  refine (exists_nat_gt b\u207b\u00b9).imp fun k hk \u21a6 ?_\n  have := (inv_pos_of_pos hb).trans hk\n  refine \u27e8Nat.cast_pos.mp this, ?_\u27e9\n  rwa [inv_lt_comm\u2080 this hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Archimedean.lean", "context": {"open": ["Pointwise CauSeq", "scoped Classical in", "scoped Classical in", "Set"], "variables": ["{\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {s : Set \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\n\u22a2 \u2203 n, 0 < n \u2227 (\u2191n)\u207b\u00b9 < b"}, {"line": "refine (exists_nat_gt b\u207b\u00b9).imp fun k hk \u21a6 ?_", "tactic_state": "b : \u211d\nhb : 0 < b\nk : \u2115\nhk : b\u207b\u00b9 < \u2191k\n\u22a2 0 < k \u2227 (\u2191k)\u207b\u00b9 < b"}, {"line": "have := (inv_pos_of_pos hb).trans hk", "tactic_state": "b : \u211d\nhb : 0 < b\nk : \u2115\nhk : b\u207b\u00b9 < \u2191k\nthis : 0 < \u2191k\n\u22a2 0 < k \u2227 (\u2191k)\u207b\u00b9 < b"}, {"line": "refine \u27e8Nat.cast_pos.mp this, ?_\u27e9", "tactic_state": "b : \u211d\nhb : 0 < b\nk : \u2115\nhk : b\u207b\u00b9 < \u2191k\nthis : 0 < \u2191k\n\u22a2 (\u2191k)\u207b\u00b9 < b"}, {"line": "rwa [inv_lt_comm\u2080 this hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_gold : \u03c6\u207b\u00b9 = -\u03c8 := by\n  have : 1 + \u221a5 \u2260 0 := ne_of_gt (add_pos (by norm_num) <| Real.sqrt_pos.mpr (by norm_num))\n  field_simp [sub_mul, mul_add]\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenRatio\u207b\u00b9 = -goldenConj"}, {"line": "have : 1 + \u221a5 \u2260 0 := ne_of_gt (add_pos (by norm_num) <| Real.sqrt_pos.mpr (by norm_num))", "tactic_state": "this : 1 + \u221a5 \u2260 0\n\u22a2 goldenRatio\u207b\u00b9 = -goldenConj"}, {"line": "field_simp [sub_mul, mul_add]", "tactic_state": "this : 1 + \u221a5 \u2260 0\n\u22a2 2 * 2 = 5 - 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_goldConj : \u03c8\u207b\u00b9 = -\u03c6 := by\n  rw [inv_eq_iff_eq_inv]\n  rw [\u2190 neg_inv]\n  rw [\u2190 neg_eq_iff_eq_neg]\n  exact inv_gold.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenConj\u207b\u00b9 = -goldenRatio"}, {"line": "rw [inv_eq_iff_eq_inv]", "tactic_state": "\u22a2 goldenConj = (-goldenRatio)\u207b\u00b9"}, {"line": "rw [\u2190 neg_inv]", "tactic_state": "\u22a2 goldenConj = -goldenRatio\u207b\u00b9"}, {"line": "rw [\u2190 neg_eq_iff_eq_neg]", "tactic_state": "\u22a2 -goldenConj = goldenRatio\u207b\u00b9"}, {"line": "exact inv_gold.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gold_mul_goldConj : \u03c6 * \u03c8 = -1 := by\n  field_simp\n  rw [\u2190 sq_sub_sq]\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenRatio * goldenConj = -1"}, {"line": "field_simp", "tactic_state": "\u22a2 (1 + \u221a5) * (1 - \u221a5) = -(2 * 2)"}, {"line": "rw [\u2190 sq_sub_sq]", "tactic_state": "\u22a2 1 ^ 2 - \u221a5 ^ 2 = -(2 * 2)"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem goldConj_mul_gold : \u03c8 * \u03c6 = -1 := by\n  rw [mul_comm]\n  exact gold_mul_goldConj\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenConj * goldenRatio = -1"}, {"line": "rw [mul_comm]", "tactic_state": "\u22a2 goldenRatio * goldenConj = -1"}, {"line": "exact gold_mul_goldConj", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gold_add_goldConj : \u03c6 + \u03c8 = 1 := by\n  rw [goldenRatio]\n  rw [goldenConj]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenRatio + goldenConj = 1"}, {"line": "rw [goldenRatio]", "tactic_state": "\u22a2 (1 + \u221a5) / 2 + goldenConj = 1"}, {"line": "rw [goldenConj]", "tactic_state": "\u22a2 (1 + \u221a5) / 2 + (1 - \u221a5) / 2 = 1"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_sub_goldConj : 1 - \u03c6 = \u03c8 := by\n  linarith [gold_add_goldConj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 - goldenRatio = goldenConj"}, {"line": "linarith [gold_add_goldConj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_sub_gold : 1 - \u03c8 = \u03c6 := by\n  linarith [gold_add_goldConj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 - goldenConj = goldenRatio"}, {"line": "linarith [gold_add_goldConj]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gold_sq : \u03c6 ^ 2 = \u03c6 + 1 := by\n  rw [goldenRatio]\n  rw [\u2190 sub_eq_zero]\n  ring_nf\n  rw [Real.sq_sqrt] <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenRatio ^ 2 = goldenRatio + 1"}, {"line": "rw [goldenRatio]", "tactic_state": "\u22a2 ((1 + \u221a5) / 2) ^ 2 = (1 + \u221a5) / 2 + 1"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "\u22a2 ((1 + \u221a5) / 2) ^ 2 - ((1 + \u221a5) / 2 + 1) = 0"}, {"line": "ring_nf", "tactic_state": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0"}, {"line": "rw [Real.sq_sqrt] <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem goldConj_sq : \u03c8 ^ 2 = \u03c8 + 1 := by\n  rw [goldenConj]\n  rw [\u2190 sub_eq_zero]\n  ring_nf\n  rw [Real.sq_sqrt] <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenConj ^ 2 = goldenConj + 1"}, {"line": "rw [goldenConj]", "tactic_state": "\u22a2 ((1 - \u221a5) / 2) ^ 2 = (1 - \u221a5) / 2 + 1"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "\u22a2 ((1 - \u221a5) / 2) ^ 2 - ((1 - \u221a5) / 2 + 1) = 0"}, {"line": "ring_nf", "tactic_state": "\u22a2 -5 / 4 + \u221a5 ^ 2 * (1 / 4) = 0"}, {"line": "rw [Real.sq_sqrt] <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_gold : 1 < \u03c6 := by\n  refine lt_of_mul_lt_mul_left ?_ (le_of_lt gold_pos)\n  simp [\u2190 sq, gold_pos, zero_lt_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < goldenRatio"}, {"line": "refine lt_of_mul_lt_mul_left ?_ (le_of_lt gold_pos)", "tactic_state": "\u22a2 goldenRatio * 1 < goldenRatio * goldenRatio"}, {"line": "simp [\u2190 sq, gold_pos, zero_lt_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gold_lt_two : \u03c6 < 2 := by calc\n  (1 + sqrt 5) / 2 < (1 + 3) / 2 := by gcongr; rw [sqrt_lt'] <;> norm_num\n  _ = 2 := by norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenRatio < 2"}, {"line": "calc\n  (1 + sqrt 5) / 2 < (1 + 3) / 2 := by gcongr; rw [sqrt_lt'] <;> norm_num\n  _ = 2 := by norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem goldConj_neg : \u03c8 < 0 := by\n  linarith [one_sub_goldConj, one_lt_gold]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 goldenConj < 0"}, {"line": "linarith [one_sub_goldConj, one_lt_gold]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_one_lt_goldConj : -1 < \u03c8 := by\n  rw [neg_lt]\n  rw [\u2190 inv_gold]\n  exact inv_lt_one_of_one_lt\u2080 one_lt_gold\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 -1 < goldenConj"}, {"line": "rw [neg_lt]", "tactic_state": "\u22a2 -goldenConj < 1"}, {"line": "rw [\u2190 inv_gold]", "tactic_state": "\u22a2 goldenRatio\u207b\u00b9 < 1"}, {"line": "exact inv_lt_one_of_one_lt\u2080 one_lt_gold", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gold_irrational : Irrational \u03c6 := by\n  have := Nat.Prime.irrational_sqrt (show Nat.Prime 5 by norm_num)\n  have := this.ratCast_add 1\n  convert this.ratCast_mul (show (0.5 : \u211a) \u2260 0 by norm_num)\n  norm_num\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Irrational goldenRatio"}, {"line": "have := Nat.Prime.irrational_sqrt (show Nat.Prime 5 by norm_num)", "tactic_state": "this : Irrational \u221a\u21915\n\u22a2 Irrational goldenRatio"}, {"line": "have := this.ratCast_add 1", "tactic_state": "this\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 + \u221a\u21915)\n\u22a2 Irrational goldenRatio"}, {"line": "convert this.ratCast_mul (show (0.5 : \u211a) \u2260 0 by norm_num)", "tactic_state": "case h.e'_1\nthis\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 + \u221a\u21915)\n\u22a2 goldenRatio = \u21910.5 * (\u21911 + \u221a\u21915)"}, {"line": "norm_num", "tactic_state": "case h.e'_1\nthis\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 + \u221a\u21915)\n\u22a2 goldenRatio = 1 / 2 * (1 + \u221a5)"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem goldConj_irrational : Irrational \u03c8 := by\n  have := Nat.Prime.irrational_sqrt (show Nat.Prime 5 by norm_num)\n  have := this.ratCast_sub 1\n  convert this.ratCast_mul (show (0.5 : \u211a) \u2260 0 by norm_num)\n  norm_num\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Irrational goldenConj"}, {"line": "have := Nat.Prime.irrational_sqrt (show Nat.Prime 5 by norm_num)", "tactic_state": "this : Irrational \u221a\u21915\n\u22a2 Irrational goldenConj"}, {"line": "have := this.ratCast_sub 1", "tactic_state": "this\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 - \u221a\u21915)\n\u22a2 Irrational goldenConj"}, {"line": "convert this.ratCast_mul (show (0.5 : \u211a) \u2260 0 by norm_num)", "tactic_state": "case h.e'_1\nthis\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 - \u221a\u21915)\n\u22a2 goldenConj = \u21910.5 * (\u21911 - \u221a\u21915)"}, {"line": "norm_num", "tactic_state": "case h.e'_1\nthis\u271d : Irrational \u221a\u21915\nthis : Irrational (\u21911 - \u221a\u21915)\n\u22a2 goldenConj = 1 / 2 * (1 - \u221a5)"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fib_isSol_fibRec : fibRec.IsSolution (fun x => x.fib : \u2115 \u2192 \u03b1) := by\n  rw [fibRec]\n  intro n\n  simp only\n  rw [Nat.fib_add_two]\n  rw [add_comm]\n  simp [Finset.sum_fin_eq_sum_range, Finset.sum_range_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\n\u22a2 fibRec.IsSolution fun x => \u2191(Nat.fib x)"}, {"line": "rw [fibRec]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\n\u22a2 { order := 2, coeffs := ![1, 1] }.IsSolution fun x => \u2191(Nat.fib x)"}, {"line": "intro n", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nn : \u2115\n\u22a2 (fun x => \u2191(Nat.fib x)) (n + { order := 2, coeffs := ![1, 1] }.order) =\n    \u2211 i, { order := 2, coeffs := ![1, 1] }.coeffs i * (fun x => \u2191(Nat.fib x)) (n + \u2191i)"}, {"line": "simp only", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nn : \u2115\n\u22a2 \u2191(Nat.fib (n + 2)) = \u2211 x, ![1, 1] x * \u2191(Nat.fib (n + \u2191x))"}, {"line": "rw [Nat.fib_add_two]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nn : \u2115\n\u22a2 \u2191(Nat.fib n + Nat.fib (n + 1)) = \u2211 x, ![1, 1] x * \u2191(Nat.fib (n + \u2191x))"}, {"line": "rw [add_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nn : \u2115\n\u22a2 \u2191(Nat.fib (n + 1) + Nat.fib n) = \u2211 x, ![1, 1] x * \u2191(Nat.fib (n + \u2191x))"}, {"line": "simp [Finset.sum_fin_eq_sum_range, Finset.sum_range_succ']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : CommSemiring \u03b1\nn : \u2115\n\u22a2 \u2191(Nat.fib (n + 1)) + \u2191(Nat.fib n) = 1 * \u2191(Nat.fib (n + 1)) + 1 * \u2191(Nat.fib n)"}]}
{"declaration": "theorem geom_gold_isSol_fibRec : fibRec.IsSolution (\u03c6 ^ \u00b7) := by\n  rw [fibRec.geom_sol_iff_root_charPoly]\n  rw [fibRec_charPoly_eq]\n  simp [sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 fibRec.IsSolution fun x => goldenRatio ^ x"}, {"line": "rw [fibRec.geom_sol_iff_root_charPoly]", "tactic_state": "\u22a2 fibRec.charPoly.IsRoot goldenRatio"}, {"line": "rw [fibRec_charPoly_eq]", "tactic_state": "\u22a2 (X ^ 2 - (X + 1)).IsRoot goldenRatio"}, {"line": "simp [sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem geom_goldConj_isSol_fibRec : fibRec.IsSolution (\u03c8 ^ \u00b7) := by\n  rw [fibRec.geom_sol_iff_root_charPoly]\n  rw [fibRec_charPoly_eq]\n  simp [sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 fibRec.IsSolution fun x => goldenConj ^ x"}, {"line": "rw [fibRec.geom_sol_iff_root_charPoly]", "tactic_state": "\u22a2 fibRec.charPoly.IsRoot goldenConj"}, {"line": "rw [fibRec_charPoly_eq]", "tactic_state": "\u22a2 (X ^ 2 - (X + 1)).IsRoot goldenConj"}, {"line": "simp [sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.coe_fib_eq : \u2200 n, (Nat.fib n : \u211d) = (\u03c6 ^ n - \u03c8 ^ n) / \u221a5 := by\n  rw [\u2190 funext_iff]\n  rw [Real.coe_fib_eq']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u2200 (n : \u2115), \u2191(Nat.fib n) = (goldenRatio ^ n - goldenConj ^ n) / \u221a5"}, {"line": "rw [\u2190 funext_iff]", "tactic_state": "\u22a2 (fun n => \u2191(Nat.fib n)) = fun n => (goldenRatio ^ n - goldenConj ^ n) / \u221a5"}, {"line": "rw [Real.coe_fib_eq']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem fib_golden_conj_exp (n : \u2115) : Nat.fib (n + 1) - \u03c6 * Nat.fib n = \u03c8 ^ n := by\n  repeat rw [coe_fib_eq]\n  rw [mul_div]\n  rw [div_sub_div_same]\n  rw [mul_sub]\n  rw [\u2190 pow_succ']\n  ring_nf\n  have nz : sqrt 5 \u2260 0 := by norm_num\n  rw [\u2190 (mul_inv_cancel\u2080 nz).symm]\n  rw [one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/GoldenRatio.lean", "context": {"open": ["Polynomial", "Real goldenRatio", "Polynomial"], "variables": ["{\u03b1 : Type*} [CommSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2191(Nat.fib (n + 1)) - goldenRatio * \u2191(Nat.fib n) = goldenConj ^ n"}, {"line": "repeat rw [coe_fib_eq]", "tactic_state": "n : \u2115\n\u22a2 (goldenRatio ^ (n + 1) - goldenConj ^ (n + 1)) / \u221a5 - goldenRatio * ((goldenRatio ^ n - goldenConj ^ n) / \u221a5) =\n    goldenConj ^ n"}, {"line": "rw [mul_div]", "tactic_state": "n : \u2115\n\u22a2 (goldenRatio ^ (n + 1) - goldenConj ^ (n + 1)) / \u221a5 - goldenRatio * (goldenRatio ^ n - goldenConj ^ n) / \u221a5 =\n    goldenConj ^ n"}, {"line": "rw [div_sub_div_same]", "tactic_state": "n : \u2115\n\u22a2 (goldenRatio ^ (n + 1) - goldenConj ^ (n + 1) - goldenRatio * (goldenRatio ^ n - goldenConj ^ n)) / \u221a5 =\n    goldenConj ^ n"}, {"line": "rw [mul_sub]", "tactic_state": "n : \u2115\n\u22a2 (goldenRatio ^ (n + 1) - goldenConj ^ (n + 1) - (goldenRatio * goldenRatio ^ n - goldenRatio * goldenConj ^ n)) / \u221a5 =\n    goldenConj ^ n"}, {"line": "rw [\u2190 pow_succ']", "tactic_state": "n : \u2115\n\u22a2 (goldenRatio ^ (n + 1) - goldenConj ^ (n + 1) - (goldenRatio ^ (n + 1) - goldenRatio * goldenConj ^ n)) / \u221a5 =\n    goldenConj ^ n"}, {"line": "ring_nf", "tactic_state": "n : \u2115\n\u22a2 \u221a5 * (\u221a5)\u207b\u00b9 * (1 / 2 + \u221a5 * (-1 / 2)) ^ n = (1 / 2 + \u221a5 * (-1 / 2)) ^ n"}, {"line": "have nz : sqrt 5 \u2260 0 := sorry", "tactic_state": "n : \u2115\nnz : \u221a5 \u2260 0\n\u22a2 \u221a5 * (\u221a5)\u207b\u00b9 * (1 / 2 + \u221a5 * (-1 / 2)) ^ n = (1 / 2 + \u221a5 * (-1 / 2)) ^ n"}, {"line": "rw [\u2190 (mul_inv_cancel\u2080 nz).symm]", "tactic_state": "n : \u2115\nnz : \u221a5 \u2260 0\n\u22a2 1 * (1 / 2 + \u221a5 * (-1 / 2)) ^ n = (1 / 2 + \u221a5 * (-1 / 2)) ^ n"}, {"line": "rw [one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinitesimal_def {x : \u211d*} : Infinitesimal x \u2194 \u2200 r : \u211d, 0 < r \u2192 -(r : \u211d*) < x \u2227 x < r := by\n  simp [Infinitesimal, IsSt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Hyperreal.lean", "context": {"open": ["Filter Germ Topology", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\n\u22a2 sorry \u2194 \u2200 (r : \u211d), 0 < r \u2192 -\u2191r < x \u2227 x < \u2191r"}, {"line": "simp [Infinitesimal, IsSt]", "tactic_state": "x\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\n\u22a2 sorry () \u2194 \u2200 (r : \u211d), 0 < r \u2192 -\u2191r < x \u2227 x < \u2191r"}]}
{"declaration": "theorem IsSt.infinitesimal_sub {x : \u211d*} {r : \u211d} (hxr : IsSt x r) : Infinitesimal (x - \u2191r) := by\n  simpa only [sub_self] using hxr.sub (isSt_refl_real r)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Hyperreal.lean", "context": {"open": ["Filter Germ Topology", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nIsSt : x\u271d\u00b9\nx\u271d : Sort u_2\nInfinitesimal : x\u271d\nx : \u211d*\nr : \u211d\nhxr : sorry\n\u22a2 sorry"}, {"line": "simpa only [sub_self] using hxr.sub (isSt_refl_real r)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem infinite_of_infinitesimal_inv {x : \u211d*} (h0 : x \u2260 0) (hi : Infinitesimal x\u207b\u00b9) :\n    Infinite x := by\n  rcases lt_or_gt_of_ne h0 with hn | hp\n  \u00b7 exact Or.inr (infiniteNeg_iff_infinitesimal_inv_neg.mpr \u27e8hi, inv_lt_zero.mpr hn\u27e9)\n  \u00b7 exact Or.inl (infinitePos_iff_infinitesimal_inv_pos.mpr \u27e8hi, inv_pos.mpr hp\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Hyperreal.lean", "context": {"open": ["Filter Germ Topology", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\nh0 : x \u2260 0\nhi : sorry\n\u22a2 Infinite sorry"}, {"line": "rcases lt_or_gt_of_ne h0 with hn | hp", "tactic_state": "case inl\nx\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\nh0 : x \u2260 0\nhi : sorry\nhn : x < 0\n\u22a2 Infinite sorry\n---\ncase inr\nx\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\nh0 : x \u2260 0\nhi : sorry\nhp : x > 0\n\u22a2 Infinite sorry"}, {"line": "\u00b7 exact Or.inr (infiniteNeg_iff_infinitesimal_inv_neg.mpr \u27e8hi, inv_lt_zero.mpr hn\u27e9)", "tactic_state": "case inr\nx\u271d : Sort u_1\nInfinitesimal : x\u271d\nx : \u211d*\nh0 : x \u2260 0\nhi : sorry\nhp : x > 0\n\u22a2 Infinite sorry"}, {"line": "\u00b7 exact Or.inl (infinitePos_iff_infinitesimal_inv_pos.mpr \u27e8hi, inv_pos.mpr hp\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem st_inv (x : \u211d*) : st x\u207b\u00b9 = (st x)\u207b\u00b9 := by\n  by_cases h0 : x = 0\n  \u00b7 rw [h0, inv_zero, \u2190 coe_zero, st_id_real, inv_zero]\n  by_cases h1 : Infinitesimal x\n  \u00b7 rw [((infinitesimal_iff_infinite_inv h0).mp h1).st_eq, h1.st_eq, inv_zero]\n  by_cases h2 : Infinite x\n  \u00b7 rw [(infinitesimal_inv_of_infinite h2).st_eq, h2.st_eq, inv_zero]\n  exact ((isSt_st' h2).inv h1).st_eq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Hyperreal.lean", "context": {"open": ["Filter Germ Topology", "scoped Classical in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "by_cases h0 : x = 0", "tactic_state": "case pos\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : x = 0\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 rw [h0, inv_zero, \u2190 coe_zero, st_id_real, inv_zero]", "tactic_state": "case neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "by_cases h1 : Infinitesimal x", "tactic_state": "case pos\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : sorry\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : \u00acsorry\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 rw [((infinitesimal_iff_infinite_inv h0).mp h1).st_eq, h1.st_eq, inv_zero]", "tactic_state": "case neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : \u00acsorry\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "by_cases h2 : Infinite x", "tactic_state": "case pos\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : \u00acsorry\nh2 : Infinite sorry\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : \u00acsorry\nh2 : \u00acInfinite sorry\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 rw [(infinitesimal_inv_of_infinite h2).st_eq, h2.st_eq, inv_zero]", "tactic_state": "case neg\nx\u271d : Sort u_1\nst : x\u271d\nx : \u211d*\nh0 : \u00acx = 0\nh1 : \u00acsorry\nh2 : \u00acInfinite sorry\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "exact ((isSt_st' h2).inv h1).st_eq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Transcendental.irrational {r : \u211d} (tr : Transcendental \u211a r) : Irrational r := by\n  rintro \u27e8a, rfl\u27e9\n  exact tr (isAlgebraic_algebraMap a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\ntr : Transcendental \u211a r\n\u22a2 Irrational r"}, {"line": "rintro \u27e8a, rfl\u27e9", "tactic_state": "case intro\na : \u211a\ntr : Transcendental \u211a \u2191a\n\u22a2 False"}, {"line": "exact tr (isAlgebraic_algebraMap a)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_nrt_of_notint_nrt {x : \u211d} (n : \u2115) (m : \u2124) (hxr : x ^ n = m)\n    (hv : \u00ac\u2203 y : \u2124, x = y) (hnpos : 0 < n) : Irrational x := by\n  rintro \u27e8\u27e8N, D, P, C\u27e9, rfl\u27e9\n  rw [\u2190 cast_pow] at hxr\n  have c1 : ((D : \u2124) : \u211d) \u2260 0 := by\n    rw [Int.cast_ne_zero]\n    rw [Int.natCast_ne_zero]\n    exact P\n  have c2 : ((D : \u2124) : \u211d) ^ n \u2260 0 := pow_ne_zero _ c1\n  rw [mk'_eq_divInt] at hxr\n  rw [cast_pow] at hxr\n  rw [cast_mk] at hxr\n  rw [div_pow] at hxr\n  rw [div_eq_iff_mul_eq c2] at hxr\n  rw [\u2190 Int.cast_pow] at hxr\n  rw [\u2190 Int.cast_pow] at hxr\n  rw [\u2190 Int.cast_mul] at hxr\n  rw [Int.cast_inj] at hxr\n  have hdivn : (D : \u2124) ^ n \u2223 N ^ n := Dvd.intro_left m hxr\n  rw [\u2190 Int.dvd_natAbs] at hdivn\n  rw [\u2190 Int.natCast_pow] at hdivn\n  rw [Int.natCast_dvd_natCast] at hdivn\n  rw [Int.natAbs_pow] at hdivn\n  rw [Nat.pow_dvd_pow_iff hnpos.ne'] at hdivn\n  obtain rfl : D = 1 := by rw [\u2190 Nat.gcd_eq_right hdivn, C.gcd_eq_one]\n  refine hv \u27e8N, ?_\u27e9\n  rw [mk'_eq_divInt]\n  rw [Int.ofNat_one]\n  rw [divInt_one]\n  rw [cast_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\nm : \u2124\nhxr : x ^ n = \u2191m\nhv : \u00ac\u2203 y, x = \u2191y\nhnpos : 0 < n\n\u22a2 Irrational x"}, {"line": "rintro \u27e8\u27e8N, D, P, C\u27e9, rfl\u27e9", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191{ num := N, den := D, den_nz := P, reduced := C } ^ n = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\n\u22a2 False"}, {"line": "rw [\u2190 cast_pow] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191({ num := N, den := D, den_nz := P, reduced := C } ^ n) = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\n\u22a2 False"}, {"line": "have c1 : ((D : \u2124) : \u211d) \u2260 0 := sorry", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191({ num := N, den := D, den_nz := P, reduced := C } ^ n) = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\n\u22a2 False"}, {"line": "have c2 : ((D : \u2124) : \u211d) ^ n \u2260 0 := pow_ne_zero _ c1", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191({ num := N, den := D, den_nz := P, reduced := C } ^ n) = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [mk'_eq_divInt] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191(divInt N \u2191D ^ n) = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [cast_pow] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191(divInt N \u2191D) ^ n = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [cast_mk] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : (\u2191N / \u2191\u2191D) ^ n = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [div_pow] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191N ^ n / \u2191\u2191D ^ n = \u2191m\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [div_eq_iff_mul_eq c2] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191m * \u2191\u2191D ^ n = \u2191N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [\u2190 Int.cast_pow] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191m * \u2191(\u2191D ^ n) = \u2191N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [\u2190 Int.cast_pow] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191m * \u2191(\u2191D ^ n) = \u2191(N ^ n)\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [\u2190 Int.cast_mul] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : \u2191(m * \u2191D ^ n) = \u2191(N ^ n)\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "rw [Int.cast_inj] at hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\n\u22a2 False"}, {"line": "have hdivn : (D : \u2124) ^ n \u2223 N ^ n := Dvd.intro_left m hxr", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : \u2191D ^ n \u2223 N ^ n\n\u22a2 False"}, {"line": "rw [\u2190 Int.dvd_natAbs] at hdivn", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : \u2191D ^ n \u2223 \u2191(N ^ n).natAbs\n\u22a2 False"}, {"line": "rw [\u2190 Int.natCast_pow] at hdivn", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : \u2191(D ^ n) \u2223 \u2191(N ^ n).natAbs\n\u22a2 False"}, {"line": "rw [Int.natCast_dvd_natCast] at hdivn", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : D ^ n \u2223 (N ^ n).natAbs\n\u22a2 False"}, {"line": "rw [Int.natAbs_pow] at hdivn", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : D ^ n \u2223 N.natAbs ^ n\n\u22a2 False"}, {"line": "rw [Nat.pow_dvd_pow_iff hnpos.ne'] at hdivn", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nD : \u2115\nP : D \u2260 0\nC : N.natAbs.Coprime D\nhxr : m * \u2191D ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den := D, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u2191D \u2260 0\nc2 : \u2191\u2191D ^ n \u2260 0\nhdivn : D \u2223 N.natAbs\n\u22a2 False"}, {"line": "obtain rfl : D = 1 := by rw [\u2190 Nat.gcd_eq_right hdivn, C.gcd_eq_one]", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nP : 1 \u2260 0\nC : N.natAbs.Coprime 1\nhxr : m * \u21911 ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u21911 \u2260 0\nc2 : \u2191\u21911 ^ n \u2260 0\nhdivn : 1 \u2223 N.natAbs\n\u22a2 False"}, {"line": "refine hv \u27e8N, ?_\u27e9", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nP : 1 \u2260 0\nC : N.natAbs.Coprime 1\nhxr : m * \u21911 ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u21911 \u2260 0\nc2 : \u2191\u21911 ^ n \u2260 0\nhdivn : 1 \u2223 N.natAbs\n\u22a2 \u2191{ num := N, den_nz := P, reduced := C } = \u2191N"}, {"line": "rw [mk'_eq_divInt]", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nP : 1 \u2260 0\nC : N.natAbs.Coprime 1\nhxr : m * \u21911 ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u21911 \u2260 0\nc2 : \u2191\u21911 ^ n \u2260 0\nhdivn : 1 \u2223 N.natAbs\n\u22a2 \u2191(divInt N \u21911) = \u2191N"}, {"line": "rw [Int.ofNat_one]", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nP : 1 \u2260 0\nC : N.natAbs.Coprime 1\nhxr : m * \u21911 ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u21911 \u2260 0\nc2 : \u2191\u21911 ^ n \u2260 0\nhdivn : 1 \u2223 N.natAbs\n\u22a2 \u2191(divInt N 1) = \u2191N"}, {"line": "rw [divInt_one]", "tactic_state": "case intro.mk'\nn : \u2115\nm : \u2124\nhnpos : 0 < n\nN : \u2124\nP : 1 \u2260 0\nC : N.natAbs.Coprime 1\nhxr : m * \u21911 ^ n = N ^ n\nhv : \u00ac\u2203 y, \u2191{ num := N, den_nz := P, reduced := C } = \u2191y\nc1 : \u2191\u21911 \u2260 0\nc2 : \u2191\u21911 ^ n \u2260 0\nhdivn : 1 \u2223 N.natAbs\n\u22a2 \u2191\u2191N = \u2191N"}, {"line": "rw [cast_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_sqrt_intCast_iff_of_nonneg {z : \u2124} (hz : 0 \u2264 z) :\n    Irrational (\u221az) \u2194 \u00acIsSquare z := by\n  rw [\u2190 Rat.isSquare_intCast_iff]\n  rw [\u2190 irrational_sqrt_ratCast_iff_of_nonneg (mod_cast hz)]\n  rw [Rat.cast_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\nhz : 0 \u2264 z\n\u22a2 Irrational \u221a\u2191z \u2194 \u00acIsSquare z"}, {"line": "rw [\u2190 Rat.isSquare_intCast_iff]", "tactic_state": "z : \u2124\nhz : 0 \u2264 z\n\u22a2 Irrational \u221a\u2191z \u2194 \u00acIsSquare \u2191z"}, {"line": "rw [\u2190 irrational_sqrt_ratCast_iff_of_nonneg (mod_cast hz)]", "tactic_state": "z : \u2124\nhz : 0 \u2264 z\n\u22a2 Irrational \u221a\u2191z \u2194 Irrational \u221a\u2191\u2191z"}, {"line": "rw [Rat.cast_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_sqrt_intCast_iff {z : \u2124} :\n    Irrational (\u221az) \u2194 \u00acIsSquare z \u2227 0 \u2264 z := by\n  rw [\u2190 Rat.cast_intCast]\n  rw [irrational_sqrt_ratCast_iff]\n  rw [Rat.isSquare_intCast_iff]\n  rw [Int.cast_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\n\u22a2 Irrational \u221a\u2191z \u2194 \u00acIsSquare z \u2227 0 \u2264 z"}, {"line": "rw [\u2190 Rat.cast_intCast]", "tactic_state": "z : \u2124\n\u22a2 Irrational \u221a\u2191\u2191z \u2194 \u00acIsSquare z \u2227 0 \u2264 z"}, {"line": "rw [irrational_sqrt_ratCast_iff]", "tactic_state": "z : \u2124\n\u22a2 \u00acIsSquare \u2191z \u2227 0 \u2264 \u2191z \u2194 \u00acIsSquare z \u2227 0 \u2264 z"}, {"line": "rw [Rat.isSquare_intCast_iff]", "tactic_state": "z : \u2124\n\u22a2 \u00acIsSquare z \u2227 0 \u2264 \u2191z \u2194 \u00acIsSquare z \u2227 0 \u2264 z"}, {"line": "rw [Int.cast_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_sqrt_natCast_iff {n : \u2115} : Irrational (\u221an) \u2194 \u00acIsSquare n := by\n  rw [\u2190 Rat.isSquare_natCast_iff]\n  rw [\u2190 irrational_sqrt_ratCast_iff_of_nonneg n.cast_nonneg]\n  rw [Rat.cast_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Irrational \u221a\u2191n \u2194 \u00acIsSquare n"}, {"line": "rw [\u2190 Rat.isSquare_natCast_iff]", "tactic_state": "n : \u2115\n\u22a2 Irrational \u221a\u2191n \u2194 \u00acIsSquare \u2191n"}, {"line": "rw [\u2190 irrational_sqrt_ratCast_iff_of_nonneg n.cast_nonneg]", "tactic_state": "n : \u2115\n\u22a2 Irrational \u221a\u2191n \u2194 Irrational \u221a\u2191\u2191n"}, {"line": "rw [Rat.cast_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_sqrt_two : Irrational (\u221a2) := by\n  simpa using Nat.prime_two.irrational_sqrt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Irrational \u221a2"}, {"line": "simpa using Nat.prime_two.irrational_sqrt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_int (h : Irrational x) (m : \u2124) : x \u2260 m := by\n  rw [\u2190 Rat.cast_intCast]\n  exact h.ne_rat _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 x \u2260 \u2191m"}, {"line": "rw [\u2190 Rat.cast_intCast]", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 x \u2260 \u2191\u2191m"}, {"line": "exact h.ne_rat _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_one (h : Irrational x) : x \u2260 1 := by simpa only [Nat.cast_one] using h.ne_nat 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\n\u22a2 x \u2260 1"}, {"line": "simpa only [Nat.cast_one] using h.ne_nat 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem add_cases : Irrational (x + y) \u2192 Irrational x \u2228 Irrational y := by\n  delta Irrational\n  contrapose!\n  rintro \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9\n  exact \u27e8rx + ry, cast_add rx ry\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Irrational (x + y) \u2192 Irrational x \u2228 Irrational y"}, {"line": "delta Irrational", "tactic_state": "x y : \u211d\n\u22a2 x + y \u2209 Set.range Rat.cast \u2192 x \u2209 Set.range Rat.cast \u2228 y \u2209 Set.range Rat.cast"}, {"line": "contrapose!", "tactic_state": "x y : \u211d\n\u22a2 x \u2208 Set.range Rat.cast \u2227 y \u2208 Set.range Rat.cast \u2192 x + y \u2208 Set.range Rat.cast"}, {"line": "rintro \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9", "tactic_state": "case intro.intro.intro\nrx ry : \u211a\n\u22a2 \u2191rx + \u2191ry \u2208 Set.range Rat.cast"}, {"line": "exact \u27e8rx + ry, cast_add rx ry\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem of_intCast_add (m : \u2124) (h : Irrational (m + x)) : Irrational x := by\n  rw [\u2190 cast_intCast] at h\n  exact h.of_ratCast_add m", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nm : \u2124\nh : Irrational (\u2191m + x)\n\u22a2 Irrational x"}, {"line": "rw [\u2190 cast_intCast] at h", "tactic_state": "x : \u211d\nm : \u2124\nh : Irrational (\u2191\u2191m + x)\n\u22a2 Irrational x"}, {"line": "exact h.of_ratCast_add m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_add (h : Irrational x) (m : \u2124) : Irrational (m + x) := by\n  rw [\u2190 cast_intCast]\n  exact h.ratCast_add m", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 Irrational (\u2191m + x)"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 Irrational (\u2191\u2191m + x)"}, {"line": "exact h.ratCast_add m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ratCast_sub (h : Irrational x) : Irrational (q - x) := by\n  simpa only [sub_eq_add_neg] using h.neg.ratCast_add q", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\nx : \u211d\nh : Irrational x\n\u22a2 Irrational (\u2191q - x)"}, {"line": "simpa only [sub_eq_add_neg] using h.neg.ratCast_add q", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub_intCast (h : Irrational x) (m : \u2124) : Irrational (x - m) := by\n  simpa only [Rat.cast_intCast] using h.sub_ratCast m", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 Irrational (x - \u2191m)"}, {"line": "simpa only [Rat.cast_intCast] using h.sub_ratCast m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_sub (h : Irrational x) (m : \u2124) : Irrational (m - x) := by\n  simpa only [Rat.cast_intCast] using h.ratCast_sub m", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\n\u22a2 Irrational (\u2191m - x)"}, {"line": "simpa only [Rat.cast_intCast] using h.ratCast_sub m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_cases : Irrational (x * y) \u2192 Irrational x \u2228 Irrational y := by\n  delta Irrational\n  contrapose!\n  rintro \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9\n  exact \u27e8rx * ry, cast_mul rx ry\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 Irrational (x * y) \u2192 Irrational x \u2228 Irrational y"}, {"line": "delta Irrational", "tactic_state": "x y : \u211d\n\u22a2 x * y \u2209 Set.range Rat.cast \u2192 x \u2209 Set.range Rat.cast \u2228 y \u2209 Set.range Rat.cast"}, {"line": "contrapose!", "tactic_state": "x y : \u211d\n\u22a2 x \u2208 Set.range Rat.cast \u2227 y \u2208 Set.range Rat.cast \u2192 x * y \u2208 Set.range Rat.cast"}, {"line": "rintro \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9", "tactic_state": "case intro.intro.intro\nrx ry : \u211a\n\u22a2 \u2191rx * \u2191ry \u2208 Set.range Rat.cast"}, {"line": "exact \u27e8rx * ry, cast_mul rx ry\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_intCast (h : Irrational x) {m : \u2124} (hm : m \u2260 0) : Irrational (x * m) := by\n  rw [\u2190 cast_intCast]\n  refine h.mul_ratCast ?_\n  rwa [Int.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x * \u2191m)"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x * \u2191\u2191m)"}, {"line": "refine h.mul_ratCast ?_", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0"}, {"line": "rwa [Int.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_ratCast (h : Irrational x) {q : \u211a} (hq : q \u2260 0) : Irrational (x / q) := by\n  rw [div_eq_mul_inv]\n  rw [\u2190 cast_inv]\n  exact h.mul_ratCast (inv_ne_zero hq)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nq : \u211a\nhq : q \u2260 0\n\u22a2 Irrational (x / \u2191q)"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "x : \u211d\nh : Irrational x\nq : \u211a\nhq : q \u2260 0\n\u22a2 Irrational (x * (\u2191q)\u207b\u00b9)"}, {"line": "rw [\u2190 cast_inv]", "tactic_state": "x : \u211d\nh : Irrational x\nq : \u211a\nhq : q \u2260 0\n\u22a2 Irrational (x * \u2191q\u207b\u00b9)"}, {"line": "exact h.mul_ratCast (inv_ne_zero hq)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_intCast (h : Irrational x) {m : \u2124} (hm : m \u2260 0) : Irrational (x / m) := by\n  rw [\u2190 cast_intCast]\n  refine h.div_ratCast ?_\n  rwa [Int.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x / \u2191m)"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 Irrational (x / \u2191\u2191m)"}, {"line": "refine h.div_ratCast ?_", "tactic_state": "x : \u211d\nh : Irrational x\nm : \u2124\nhm : m \u2260 0\n\u22a2 \u2191m \u2260 0"}, {"line": "rwa [Int.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_mul_ratCast_iff : Irrational (x * q) \u2194 q \u2260 0 \u2227 Irrational x := by\n  rw [mul_comm]\n  rw [irrational_ratCast_mul_iff]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (x * \u2191q) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [mul_comm]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (\u2191q * x) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_ratCast_mul_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_intCast_mul_iff : Irrational (m * x) \u2194 m \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_intCast]\n  rw [irrational_ratCast_mul_iff]\n  rw [Int.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (\u2191m * x) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (\u2191\u2191m * x) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_ratCast_mul_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 \u2191m \u2260 0 \u2227 Irrational x \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [Int.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_mul_intCast_iff : Irrational (x * m) \u2194 m \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_intCast]\n  rw [irrational_mul_ratCast_iff]\n  rw [Int.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (x * \u2191m) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (x * \u2191\u2191m) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_mul_ratCast_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 \u2191m \u2260 0 \u2227 Irrational x \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [Int.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_natCast_mul_iff : Irrational (n * x) \u2194 n \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_natCast]\n  rw [irrational_ratCast_mul_iff]\n  rw [Nat.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (\u2191n * x) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_natCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (\u2191\u2191n * x) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_ratCast_mul_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 \u2191n \u2260 0 \u2227 Irrational x \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [Nat.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_mul_natCast_iff : Irrational (x * n) \u2194 n \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_natCast]\n  rw [irrational_mul_ratCast_iff]\n  rw [Nat.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (x * \u2191n) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_natCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (x * \u2191\u2191n) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_mul_ratCast_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 \u2191n \u2260 0 \u2227 Irrational x \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [Nat.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_ratCast_div_iff : Irrational (q / x) \u2194 q \u2260 0 \u2227 Irrational x := by\n  simp [div_eq_mul_inv]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (\u2191q / x) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_div_ratCast_iff : Irrational (x / q) \u2194 q \u2260 0 \u2227 Irrational x := by\n  rw [div_eq_mul_inv]\n  rw [\u2190 cast_inv]\n  rw [irrational_mul_ratCast_iff]\n  rw [Ne]\n  rw [inv_eq_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (x / \u2191q) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [div_eq_mul_inv]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (x * (\u2191q)\u207b\u00b9) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_inv]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 Irrational (x * \u2191q\u207b\u00b9) \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_mul_ratCast_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 q\u207b\u00b9 \u2260 0 \u2227 Irrational x \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [Ne]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d\u00b9 : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq\u271d : \u211a\nm : \u2124\nn : \u2115\nx\u271d : \u211d\nq : \u211a\nx : \u211d\n\u22a2 \u00acq\u207b\u00b9 = 0 \u2227 Irrational x \u2194 q \u2260 0 \u2227 Irrational x"}, {"line": "rw [inv_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_intCast_div_iff : Irrational (m / x) \u2194 m \u2260 0 \u2227 Irrational x := by\n  simp [div_eq_mul_inv]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (\u2191m / x) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_div_intCast_iff : Irrational (x / m) \u2194 m \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_intCast]\n  rw [irrational_div_ratCast_iff]\n  rw [Int.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (x / \u2191m) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_intCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 Irrational (x / \u2191\u2191m) \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_div_ratCast_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm\u271d : \u2124\nn : \u2115\nx\u271d : \u211d\nm : \u2124\nx : \u211d\n\u22a2 \u2191m \u2260 0 \u2227 Irrational x \u2194 m \u2260 0 \u2227 Irrational x"}, {"line": "rw [Int.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_natCast_div_iff : Irrational (n / x) \u2194 n \u2260 0 \u2227 Irrational x := by\n  simp [div_eq_mul_inv]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (\u2191n / x) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem irrational_div_natCast_iff : Irrational (x / n) \u2194 n \u2260 0 \u2227 Irrational x := by\n  rw [\u2190 cast_natCast]\n  rw [irrational_div_ratCast_iff]\n  rw [Nat.cast_ne_zero]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Irrational.lean", "context": {"open": ["Rat Real", "Int in", "Polynomial", "Irrational"], "variables": ["{x : \u211d}", "(q : \u211a) {x y : \u211d}", "(x : \u211d) (p : \u2124[X])", "{q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (x / \u2191n) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [\u2190 cast_natCast]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 Irrational (x / \u2191\u2191n) \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [irrational_div_ratCast_iff]", "tactic_state": "X : ?m.1872\nx\u271d\u00b3 : \u211d\nq\u271d : \u211a\nx\u271d\u00b2 y x\u271d\u00b9 : \u211d\np : \u2124[X]\nq : \u211a\nm : \u2124\nn\u271d : \u2115\nx\u271d : \u211d\nn : \u2115\nx : \u211d\n\u22a2 \u2191n \u2260 0 \u2227 Irrational x \u2194 n \u2260 0 \u2227 Irrational x"}, {"line": "rw [Nat.cast_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_apply_eq (r : \u211d) : sign r = -1 \u2228 sign r = 0 \u2228 sign r = 1 := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : \u211d)\n  \u00b7 exact Or.inl <| sign_of_neg hn\n  \u00b7 exact Or.inr <| Or.inl <| sign_zero\n  \u00b7 exact Or.inr <| Or.inr <| sign_of_pos hp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1"}, {"line": "obtain hn | rfl | hp := lt_trichotomy r (0 : \u211d)", "tactic_state": "case inl\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhn : r < 0\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1\n---\ncase inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1"}, {"line": "\u00b7 exact Or.inl <| sign_of_neg hn", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1"}, {"line": "\u00b7 exact Or.inr <| Or.inl <| sign_zero", "tactic_state": "case inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -1 \u2228 sorry = 0 \u2228 sorry = 1"}, {"line": "\u00b7 exact Or.inr <| Or.inr <| sign_of_pos hp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_intCast (z : \u2124) : sign (z : \u211d) = \u2191(Int.sign z) := by\n  obtain hn | rfl | hp := lt_trichotomy z (0 : \u2124)\n  \u00b7 rw [sign_of_neg (Int.cast_lt_zero.mpr hn), Int.sign_eq_neg_one_of_neg hn, Int.cast_neg,\n      Int.cast_one]\n  \u00b7 rw [Int.cast_zero, sign_zero, Int.sign_zero, Int.cast_zero]\n  \u00b7 rw [sign_of_pos (Int.cast_pos.mpr hp), Int.sign_eq_one_of_pos hp, Int.cast_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nz : \u2124\n\u22a2 sorry = z.sign"}, {"line": "obtain hn | rfl | hp := lt_trichotomy z (0 : \u2124)", "tactic_state": "case inl\nx\u271d : Sort u_1\nsign : x\u271d\nz : \u2124\nhn : z < 0\n\u22a2 sorry = z.sign\n---\ncase inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = Int.sign 0\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nz : \u2124\nhp : 0 < z\n\u22a2 sorry = z.sign"}, {"line": "\u00b7 rw [sign_of_neg (Int.cast_lt_zero.mpr hn), Int.sign_eq_neg_one_of_neg hn, Int.cast_neg,\n      Int.cast_one]", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = Int.sign 0\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nz : \u2124\nhp : 0 < z\n\u22a2 sorry = z.sign"}, {"line": "\u00b7 rw [Int.cast_zero, sign_zero, Int.sign_zero, Int.cast_zero]", "tactic_state": "case inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nz : \u2124\nhp : 0 < z\n\u22a2 sorry = z.sign"}, {"line": "\u00b7 rw [sign_of_pos (Int.cast_pos.mpr hp), Int.sign_eq_one_of_pos hp, Int.cast_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_neg {r : \u211d} : sign (-r) = -sign r := by\n  obtain hn | rfl | hp := lt_trichotomy r (0 : \u211d)\n  \u00b7 rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg]\n  \u00b7 rw [sign_zero, neg_zero, sign_zero]\n  \u00b7 rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\n\u22a2 sorry = -sorry"}, {"line": "obtain hn | rfl | hp := lt_trichotomy r (0 : \u211d)", "tactic_state": "case inl\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhn : r < 0\n\u22a2 sorry = -sorry\n---\ncase inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = -sorry\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -sorry"}, {"line": "\u00b7 rw [sign_of_neg hn, sign_of_pos (neg_pos.mpr hn), neg_neg]", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nsign : x\u271d\n\u22a2 sorry = -sorry\n---\ncase inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -sorry"}, {"line": "\u00b7 rw [sign_zero, neg_zero, sign_zero]", "tactic_state": "case inr.inr\nx\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhp : 0 < r\n\u22a2 sorry = -sorry"}, {"line": "\u00b7 rw [sign_of_pos hp, sign_of_neg (neg_lt_zero.mpr hp)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_mul_pos_of_ne_zero (r : \u211d) (hr : r \u2260 0) : 0 < sign r * r := by\n  refine lt_of_le_of_ne (sign_mul_nonneg r) fun h => hr ?_\n  have hs0 := (zero_eq_mul.mp h).resolve_right hr\n  exact sign_eq_zero_iff.mp hs0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sign.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhr : r \u2260 0\n\u22a2 0 < sorry * r"}, {"line": "refine lt_of_le_of_ne (sign_mul_nonneg r) fun h => hr ?_", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhr : r \u2260 0\nh : 0 = sorry * r\n\u22a2 r = 0"}, {"line": "have hs0 := (zero_eq_mul.mp h).resolve_right hr", "tactic_state": "x\u271d : Sort u_1\nsign : x\u271d\nr : \u211d\nhr : r \u2260 0\nh : 0 = sorry * r\nhs0 : sorry = 0\n\u22a2 r = 0"}, {"line": "exact sign_eq_zero_iff.mp hs0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_sqrt {x : \u211d\u22650} : (NNReal.sqrt x : \u211d) = \u221a(x : \u211d) := by\n  rw [Real.sqrt]\n  rw [Real.toNNReal_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\n\u22a2 \u2191(NNReal.sqrt x) = \u221a\u2191x"}, {"line": "rw [Real.sqrt]", "tactic_state": "x : NNReal\n\u22a2 \u2191(NNReal.sqrt x) = \u2191(NNReal.sqrt (\u2191x).toNNReal)"}, {"line": "rw [Real.toNNReal_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_self_sqrt (h : 0 \u2264 x) : \u221ax * \u221ax = x := by\n  rw [Real.sqrt]\n  rw [\u2190 NNReal.coe_mul]\n  rw [NNReal.mul_self_sqrt]\n  rw [Real.coe_toNNReal _ h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 \u221ax * \u221ax = x"}, {"line": "rw [Real.sqrt]", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 \u2191(NNReal.sqrt x.toNNReal) * \u2191(NNReal.sqrt x.toNNReal) = x"}, {"line": "rw [\u2190 NNReal.coe_mul]", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 \u2191(NNReal.sqrt x.toNNReal * NNReal.sqrt x.toNNReal) = x"}, {"line": "rw [NNReal.mul_self_sqrt]", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 \u2191x.toNNReal = x"}, {"line": "rw [Real.coe_toNNReal _ h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_eq_one : \u221ax = 1 \u2194 x = 1 :=\n  calc\n    \u221ax = 1 \u2194 1 * 1 = x := sqrt_eq_iff_mul_self_eq_of_pos zero_lt_one\n    _ \u2194 x = 1 := by rw [eq_comm, mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 1 * 1 = x \u2194 x = 1"}, {"line": "rw [eq_comm, mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_zero : \u221a0 = 0 := by simp [Real.sqrt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u221a0 = 0"}, {"line": "simp [Real.sqrt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_one : \u221a1 = 1 := by simp [Real.sqrt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u221a1 = 1"}, {"line": "simp [Real.sqrt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_le_sqrt (h : x \u2264 y) : \u221ax \u2264 \u221ay := by\n  rw [Real.sqrt]\n  rw [Real.sqrt]\n  rw [NNReal.coe_le_coe]\n  rw [NNReal.sqrt_le_sqrt]\n  exact toNNReal_le_toNNReal h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh : x \u2264 y\n\u22a2 \u221ax \u2264 \u221ay"}, {"line": "rw [Real.sqrt]", "tactic_state": "x y : \u211d\nh : x \u2264 y\n\u22a2 \u2191(NNReal.sqrt x.toNNReal) \u2264 \u221ay"}, {"line": "rw [Real.sqrt]", "tactic_state": "x y : \u211d\nh : x \u2264 y\n\u22a2 \u2191(NNReal.sqrt x.toNNReal) \u2264 \u2191(NNReal.sqrt y.toNNReal)"}, {"line": "rw [NNReal.coe_le_coe]", "tactic_state": "x y : \u211d\nh : x \u2264 y\n\u22a2 NNReal.sqrt x.toNNReal \u2264 NNReal.sqrt y.toNNReal"}, {"line": "rw [NNReal.sqrt_le_sqrt]", "tactic_state": "x y : \u211d\nh : x \u2264 y\n\u22a2 x.toNNReal \u2264 y.toNNReal"}, {"line": "exact toNNReal_le_toNNReal h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_inj (hx : 0 \u2264 x) (hy : 0 \u2264 y) : \u221ax = \u221ay \u2194 x = y := by\n  simp [le_antisymm_iff, hx, hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 \u221ax = \u221ay \u2194 x = y"}, {"line": "simp [le_antisymm_iff, hx, hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_eq_zero (h : 0 \u2264 x) : \u221ax = 0 \u2194 x = 0 := by simpa using sqrt_inj h le_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : 0 \u2264 x\n\u22a2 \u221ax = 0 \u2194 x = 0"}, {"line": "simpa using sqrt_inj h le_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sqrt_le_sqrt_iff' (hx : 0 < x) : \u221ax \u2264 \u221ay \u2194 x \u2264 y := by\n  obtain hy | hy := le_total y 0\n  \u00b7 exact iff_of_false ((sqrt_eq_zero_of_nonpos hy).trans_lt <| sqrt_pos.2 hx).not_le\n      (hy.trans_lt hx).not_le\n  \u00b7 exact sqrt_le_sqrt_iff hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 \u221ax \u2264 \u221ay \u2194 x \u2264 y"}, {"line": "obtain hy | hy := le_total y 0", "tactic_state": "case inl\nx y : \u211d\nhx : 0 < x\nhy : y \u2264 0\n\u22a2 \u221ax \u2264 \u221ay \u2194 x \u2264 y\n---\ncase inr\nx y : \u211d\nhx : 0 < x\nhy : 0 \u2264 y\n\u22a2 \u221ax \u2264 \u221ay \u2194 x \u2264 y"}, {"line": "\u00b7 exact iff_of_false ((sqrt_eq_zero_of_nonpos hy).trans_lt <| sqrt_pos.2 hx).not_le\n      (hy.trans_lt hx).not_le", "tactic_state": "case inr\nx y : \u211d\nhx : 0 < x\nhy : 0 \u2264 y\n\u22a2 \u221ax \u2264 \u221ay \u2194 x \u2264 y"}, {"line": "\u00b7 exact sqrt_le_sqrt_iff hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_mul {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) : \u221a(x * y) = \u221ax * \u221ay := by\n  simp_rw [Real.sqrt, \u2190 NNReal.coe_mul, NNReal.coe_inj, Real.toNNReal_mul hx, NNReal.sqrt_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 \u221a(x * y) = \u221ax * \u221ay"}, {"line": "simp_rw [Real.sqrt, \u2190 NNReal.coe_mul, NNReal.coe_inj, Real.toNNReal_mul hx, NNReal.sqrt_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrt_inv (x : \u211d) : \u221ax\u207b\u00b9 = (\u221ax)\u207b\u00b9 := by\n  rw [Real.sqrt]\n  rw [Real.toNNReal_inv]\n  rw [NNReal.sqrt_inv]\n  rw [NNReal.coe_inv]\n  rw [Real.sqrt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u221ax\u207b\u00b9 = (\u221ax)\u207b\u00b9"}, {"line": "rw [Real.sqrt]", "tactic_state": "x : \u211d\n\u22a2 \u2191(NNReal.sqrt x\u207b\u00b9.toNNReal) = (\u221ax)\u207b\u00b9"}, {"line": "rw [Real.toNNReal_inv]", "tactic_state": "x : \u211d\n\u22a2 \u2191(NNReal.sqrt x.toNNReal\u207b\u00b9) = (\u221ax)\u207b\u00b9"}, {"line": "rw [NNReal.sqrt_inv]", "tactic_state": "x : \u211d\n\u22a2 \u2191(NNReal.sqrt x.toNNReal)\u207b\u00b9 = (\u221ax)\u207b\u00b9"}, {"line": "rw [NNReal.coe_inv]", "tactic_state": "x : \u211d\n\u22a2 (\u2191(NNReal.sqrt x.toNNReal))\u207b\u00b9 = (\u221ax)\u207b\u00b9"}, {"line": "rw [Real.sqrt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_sqrt : x / \u221ax = \u221ax := by\n  rcases le_or_lt x 0 with h | h\n  \u00b7 rw [sqrt_eq_zero'.mpr h, div_zero]\n  \u00b7 rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x / \u221ax = \u221ax"}, {"line": "rcases le_or_lt x 0 with h | h", "tactic_state": "case inl\nx : \u211d\nh : x \u2264 0\n\u22a2 x / \u221ax = \u221ax\n---\ncase inr\nx : \u211d\nh : 0 < x\n\u22a2 x / \u221ax = \u221ax"}, {"line": "\u00b7 rw [sqrt_eq_zero'.mpr h, div_zero]", "tactic_state": "case inr\nx : \u211d\nh : 0 < x\n\u22a2 x / \u221ax = \u221ax"}, {"line": "\u00b7 rw [div_eq_iff (sqrt_ne_zero'.mpr h), mul_self_sqrt h.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nat_sqrt_le_real_sqrt {a : \u2115} : \u2191(Nat.sqrt a) \u2264 \u221a(a : \u211d) := by\n  rw [Real.le_sqrt (Nat.cast_nonneg _) (Nat.cast_nonneg _)]\n  norm_cast\n  exact Nat.sqrt_le' a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 \u2191a.sqrt \u2264 \u221a\u2191a"}, {"line": "rw [Real.le_sqrt (Nat.cast_nonneg _) (Nat.cast_nonneg _)]", "tactic_state": "a : \u2115\n\u22a2 \u2191a.sqrt ^ 2 \u2264 \u2191a"}, {"line": "norm_cast", "tactic_state": "a : \u2115\n\u22a2 a.sqrt ^ 2 \u2264 a"}, {"line": "exact Nat.sqrt_le' a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem floor_real_sqrt_eq_nat_sqrt {a : \u2115} : \u230a\u221a(a : \u211d)\u230b = Nat.sqrt a := by\n  rw [Int.floor_eq_iff]\n  exact \u27e8nat_sqrt_le_real_sqrt, real_sqrt_lt_nat_sqrt_succ\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}", "{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2115\n\u22a2 \u230a\u221a\u2191a\u230b = \u2191a.sqrt"}, {"line": "rw [Int.floor_eq_iff]", "tactic_state": "a : \u2115\n\u22a2 \u2191\u2191a.sqrt \u2264 \u221a\u2191a \u2227 \u221a\u2191a < \u2191\u2191a.sqrt + 1"}, {"line": "exact \u27e8nat_sqrt_le_real_sqrt, real_sqrt_lt_nat_sqrt_succ\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_sqrt_mul_sqrt_le (s : Finset \u03b9) (f g : \u03b9 \u2192 \u211d\u22650) :\n    \u2211 i \u2208 s, sqrt (f i) * sqrt (g i) \u2264 sqrt (\u2211 i \u2208 s, f i) * sqrt (\u2211 i \u2208 s, g i) := by\n  simpa [*] using sum_mul_le_sqrt_mul_sqrt _ (fun x \u21a6 sqrt (f x)) (fun x \u21a6 sqrt (g x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function", "Real", "Finset"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}", "{x y : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ns : Finset \u03b9\nf g : \u03b9 \u2192 NNReal\n\u22a2 \u2211 i \u2208 s, \u221a\u2191(f i) * \u221a\u2191(g i) \u2264 \u221a(\u2211 i \u2208 s, \u2191(f i)) * \u221a(\u2211 i \u2208 s, \u2191(g i))"}, {"line": "simpa [*] using sum_mul_le_sqrt_mul_sqrt _ (fun x \u21a6 sqrt (f x)) (fun x \u21a6 sqrt (g x))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sum_sqrt_mul_sqrt_le (s : Finset \u03b9) (hf : \u2200 i, 0 \u2264 f i) (hg : \u2200 i, 0 \u2264 g i) :\n    \u2211 i \u2208 s, \u221a(f i) * \u221a(g i) \u2264 \u221a(\u2211 i \u2208 s, f i) * \u221a(\u2211 i \u2208 s, g i) := by\n  simpa [*] using sum_mul_le_sqrt_mul_sqrt _ (fun x \u21a6 \u221a(f x)) (fun x \u21a6 \u221a(g x))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Sqrt.lean", "context": {"open": ["Set Filter", "scoped Filter NNReal Topology", "Lean Meta Qq Function", "Real", "Finset", "Finset"], "variables": ["{x y : \u211d\u22650}", "{x y : \u211d}", "{x y : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "{\u03b9 : Type*} {f g : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nf g : \u03b9 \u2192 \u211d\ns : Finset \u03b9\nhf : \u2200 (i : \u03b9), 0 \u2264 f i\nhg : \u2200 (i : \u03b9), 0 \u2264 g i\n\u22a2 \u2211 i \u2208 s, \u221a(f i) * \u221a(g i) \u2264 \u221a(\u2211 i \u2208 s, f i) * \u221a(\u2211 i \u2208 s, g i)"}, {"line": "simpa [*] using sum_mul_le_sqrt_mul_sqrt _ (fun x \u21a6 \u221a(f x)) (fun x \u21a6 \u221a(g x))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_gt_three : 3 < \u03c0 := by\n  -- bound[3, Iters -> 1, Rounding -> 2, Precision -> 3]\n  pi_lower_bound [23 / 16]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3 < Real.pi"}, {"line": "pi_lower_bound [23 / 16]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_lt_four : \u03c0 < 4 := by\n  -- bound[4, Iters -> 1, Rounding -> 1, Precision -> 1]\n  pi_upper_bound [4 / 3]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.pi < 4"}, {"line": "pi_upper_bound [4 / 3]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_gt_d2 : 3.14 < \u03c0 := by\n  -- bound[314*^-2, Iters -> 4, Rounding -> 1.5, Precision -> 8]\n  pi_lower_bound [338 / 239, 704 / 381, 1940 / 989, 1447 / 727]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3.14 < Real.pi"}, {"line": "pi_lower_bound [338 / 239, 704 / 381, 1940 / 989, 1447 / 727]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_lt_d2 : \u03c0 < 3.15 := by\n  -- bound[315*^-2, Iters -> 4, Rounding -> 1.4, Precision -> 7]\n  pi_upper_bound [41 / 29, 109 / 59, 865 / 441, 412 / 207]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.pi < 3.15"}, {"line": "pi_upper_bound [41 / 29, 109 / 59, 865 / 441, 412 / 207]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_gt_d4 : 3.1415 < \u03c0 := by\n  -- bound[31415*^-4, Iters -> 6, Rounding -> 1.1, Precision -> 10]\n  pi_lower_bound [\n    1970 / 1393, 3010 / 1629, 11689 / 5959, 10127 / 5088, 33997 / 17019, 23235 / 11621]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3.1415 < Real.pi"}, {"line": "pi_lower_bound [\n    1970 / 1393, 3010 / 1629, 11689 / 5959, 10127 / 5088, 33997 / 17019, 23235 / 11621]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_lt_d4 : \u03c0 < 3.1416 := by\n  -- bound[31416*^-4, Iters -> 9, Rounding -> .9, Precision -> 16]\n  pi_upper_bound [\n    4756/3363, 14965/8099, 21183/10799, 49188/24713, 2-53/22000, 2-71/117869, 2-47/312092,\n    2-17/451533, 2-4/424971]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.pi < 3.1416"}, {"line": "pi_upper_bound [\n    4756/3363, 14965/8099, 21183/10799, 49188/24713, 2-53/22000, 2-71/117869, 2-47/312092,\n    2-17/451533, 2-4/424971]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_gt_d6 : 3.141592 < \u03c0 := by\n  -- bound[3141592*^-6, Iters -> 10, Rounding -> .8, Precision -> 16]\n  pi_lower_bound [\n    11482/8119, 7792/4217, 54055/27557, 2-623/64690, 2-337/139887, 2-208/345307, 2-167/1108925,\n    2-64/1699893, 2-31/3293535, 2-48/20398657]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3.141592 < Real.pi"}, {"line": "pi_lower_bound [\n    11482/8119, 7792/4217, 54055/27557, 2-623/64690, 2-337/139887, 2-208/345307, 2-167/1108925,\n    2-64/1699893, 2-31/3293535, 2-48/20398657]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_lt_d6 : \u03c0 < 3.141593 := by\n  -- bound[3141593*^-6, Iters -> 11, Rounding -> .5, Precision -> 17]\n  pi_upper_bound [\n    35839/25342, 49143/26596, 145729/74292, 294095/147759, 2-137/56868, 2-471/781921, 2-153/1015961,\n    2-157/4170049, 2-28/2974805, 2-9/3824747, 2-7/11899211]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.pi < 3.141593"}, {"line": "pi_upper_bound [\n    35839/25342, 49143/26596, 145729/74292, 294095/147759, 2-137/56868, 2-471/781921, 2-153/1015961,\n    2-157/4170049, 2-28/2974805, 2-9/3824747, 2-7/11899211]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_gt_d20 : 3.14159265358979323846 < \u03c0 := by\n  -- bound[314159265358979323846*^-20, Iters -> 34, Rounding -> .6, Precision -> 46]\n  pi_lower_bound [\n    671574048197/474874563549, 58134718954/31462283181, 3090459598621/1575502640777,\n    2-7143849599/741790664068, 8431536490061/4220852446654, 2-2725579171/4524814682468,\n    2-2494895647/16566776788806, 2-608997841/16175484287402, 2-942567063/100141194694075,\n    2-341084060/144951150987041, 2-213717653/363295959742218, 2-71906926/488934711121807,\n    2-29337101/797916288104986, 2-45326311/4931175952730065, 2-7506877/3266776448781479,\n    2-5854787/10191338039232571, 2-4538642/31601378399861717, 2-276149/7691013341581098,\n    2-350197/39013283396653714, 2-442757/197299283738495963, 2-632505/1127415566199968707,\n    2-1157/8249230030392285, 2-205461/5859619883403334178, 2-33721/3846807755987625852,\n    2-11654/5317837263222296743, 2-8162/14897610345776687857, 2-731/5337002285107943372,\n    2-1320/38549072592845336201, 2-707/82588467645883795866, 2-53/24764858756615791675,\n    2-237/442963888703240952920, 2-128/956951523274512100791, 2-32/956951523274512100783,\n    2-27/3229711391051478340136]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 3.14159265358979323846 < Real.pi"}, {"line": "pi_lower_bound [\n    671574048197/474874563549, 58134718954/31462283181, 3090459598621/1575502640777,\n    2-7143849599/741790664068, 8431536490061/4220852446654, 2-2725579171/4524814682468,\n    2-2494895647/16566776788806, 2-608997841/16175484287402, 2-942567063/100141194694075,\n    2-341084060/144951150987041, 2-213717653/363295959742218, 2-71906926/488934711121807,\n    2-29337101/797916288104986, 2-45326311/4931175952730065, 2-7506877/3266776448781479,\n    2-5854787/10191338039232571, 2-4538642/31601378399861717, 2-276149/7691013341581098,\n    2-350197/39013283396653714, 2-442757/197299283738495963, 2-632505/1127415566199968707,\n    2-1157/8249230030392285, 2-205461/5859619883403334178, 2-33721/3846807755987625852,\n    2-11654/5317837263222296743, 2-8162/14897610345776687857, 2-731/5337002285107943372,\n    2-1320/38549072592845336201, 2-707/82588467645883795866, 2-53/24764858756615791675,\n    2-237/442963888703240952920, 2-128/956951523274512100791, 2-32/956951523274512100783,\n    2-27/3229711391051478340136]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_lt_d20 : \u03c0 < 3.14159265358979323847 := by\n  -- bound[314159265358979323847*^-20, Iters -> 34, Rounding -> .5, Precision -> 46]\n  pi_upper_bound [\n    215157040700/152139002499, 936715022285/506946517009, 1760670193473/897581880893,\n    2-6049918861/628200981455, 2-8543385003/3546315642356, 2-2687504973/4461606579043,\n    2-1443277808/9583752057175, 2-546886849/14525765179168, 2-650597193/69121426717657,\n    2-199969519/84981432264454, 2-226282901/384655467333100, 2-60729699/412934601558121,\n    2-25101251/682708800188252, 2-7156464/778571703825145, 2-7524725/3274543383827551,\n    2-4663362/8117442793616861, 2-1913009/13319781840326041, 2-115805/3225279830894912,\n    2-708749/78957345705688293, 2-131255/58489233342660393, 2-101921/181670219085488669,\n    2-44784/319302953916238627, 2-82141/2342610212364552264, 2-4609/525783249231842696,\n    2-4567/2083967975041722089, 2-2273/4148770928197796067, 2-563/4110440884426500846,\n    2-784/22895812812720260289, 2-1717/200571992854289218531, 2-368/171952226838388893139,\n    2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Bounds.lean", "context": {"open": ["scoped Real", "Lean Elab Tactic Qq"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Real.pi < 3.14159265358979323847"}, {"line": "pi_upper_bound [\n    215157040700/152139002499, 936715022285/506946517009, 1760670193473/897581880893,\n    2-6049918861/628200981455, 2-8543385003/3546315642356, 2-2687504973/4461606579043,\n    2-1443277808/9583752057175, 2-546886849/14525765179168, 2-650597193/69121426717657,\n    2-199969519/84981432264454, 2-226282901/384655467333100, 2-60729699/412934601558121,\n    2-25101251/682708800188252, 2-7156464/778571703825145, 2-7524725/3274543383827551,\n    2-4663362/8117442793616861, 2-1913009/13319781840326041, 2-115805/3225279830894912,\n    2-708749/78957345705688293, 2-131255/58489233342660393, 2-101921/181670219085488669,\n    2-44784/319302953916238627, 2-82141/2342610212364552264, 2-4609/525783249231842696,\n    2-4567/2083967975041722089, 2-2273/4148770928197796067, 2-563/4110440884426500846,\n    2-784/22895812812720260289, 2-1717/200571992854289218531, 2-368/171952226838388893139,\n    2-149/278487845640434185590, 2-207/1547570041545500037992, 2-20/598094702046570062987,\n    2-7/837332582865198088180]", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma tendsto_pow_div_factorial_at_top_aux (a : \u211d) :\n    Tendsto (fun n => (a : \u211d) ^ (2 * n + 1) / n !) atTop (nhds 0) := by\n  rw [\u2190 mul_zero a]\n  refine ((FloorSemiring.tendsto_pow_div_factorial_atTop (a ^ 2)).const_mul a).congr (fun x => ?_)\n  rw [\u2190 pow_mul]\n  rw [mul_div_assoc']\n  rw [_root_.pow_succ']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Irrational.lean", "context": {"open": ["intervalIntegral MeasureTheory.MeasureSpace Set Polynomial Real", "scoped Nat", "Filter"], "variables": ["{n : \u2115} {\u03b8 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 Tendsto (fun n => a ^ (2 * n + 1) / \u2191n.factorial) atTop (nhds 0)"}, {"line": "rw [\u2190 mul_zero a]", "tactic_state": "a : \u211d\n\u22a2 Tendsto (fun n => a ^ (2 * n + 1) / \u2191n.factorial) atTop (nhds (a * 0))"}, {"line": "refine ((FloorSemiring.tendsto_pow_div_factorial_atTop (a ^ 2)).const_mul a).congr (fun x => ?_)", "tactic_state": "a : \u211d\nx : \u2115\n\u22a2 a * ((a ^ 2) ^ x / \u2191x.factorial) = a ^ (2 * x + 1) / \u2191x.factorial"}, {"line": "rw [\u2190 pow_mul]", "tactic_state": "a : \u211d\nx : \u2115\n\u22a2 a * (a ^ (2 * x) / \u2191x.factorial) = a ^ (2 * x + 1) / \u2191x.factorial"}, {"line": "rw [mul_div_assoc']", "tactic_state": "a : \u211d\nx : \u2115\n\u22a2 a * a ^ (2 * x) / \u2191x.factorial = a ^ (2 * x + 1) / \u2191x.factorial"}, {"line": "rw [_root_.pow_succ']", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma not_irrational_exists_rep {x : \u211d} :\n    \u00acIrrational x \u2192 \u2203 (a : \u2124) (b : \u2115), 0 < b \u2227 x = a / b := by\n  rw [Irrational]\n  rw [not_not]\n  rw [mem_range]\n  rintro \u27e8q, rfl\u27e9\n  exact \u27e8q.num, q.den, q.pos, by exact_mod_cast (Rat.num_div_den _).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Real/Pi/Irrational.lean", "context": {"open": ["intervalIntegral MeasureTheory.MeasureSpace Set Polynomial Real", "scoped Nat", "Filter"], "variables": ["{n : \u2115} {\u03b8 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u00acIrrational x \u2192 \u2203 a b, 0 < b \u2227 x = \u2191a / \u2191b"}, {"line": "rw [Irrational]", "tactic_state": "x : \u211d\n\u22a2 \u00acx \u2209 range Rat.cast \u2192 \u2203 a b, 0 < b \u2227 x = \u2191a / \u2191b"}, {"line": "rw [not_not]", "tactic_state": "x : \u211d\n\u22a2 x \u2208 range Rat.cast \u2192 \u2203 a b, 0 < b \u2227 x = \u2191a / \u2191b"}, {"line": "rw [mem_range]", "tactic_state": "x : \u211d\n\u22a2 (\u2203 y, \u2191y = x) \u2192 \u2203 a b, 0 < b \u2227 x = \u2191a / \u2191b"}, {"line": "rintro \u27e8q, rfl\u27e9", "tactic_state": "case intro\nq : \u211a\n\u22a2 \u2203 a b, 0 < b \u2227 \u2191q = \u2191a / \u2191b"}, {"line": "exact \u27e8q.num, q.den, q.pos, by exact_mod_cast (Rat.num_div_den _).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_stable (s : Computation \u03b1) {a m n} (h : m \u2264 n) : s.1 m = some a \u2192 s.1 n = some a := by\n  obtain \u27e8f, al\u27e9 := s\n  induction' h with n _ IH\n  exacts [id, fun h2 => al (IH h2)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Computation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Computation \u03b1 \u2192 Computation \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Computation \u03b1\na : \u03b1\nm n : \u2115\nh : m \u2264 n\n\u22a2 \u2191s m = some a \u2192 \u2191s n = some a"}, {"line": "obtain \u27e8f, al\u27e9 := s", "tactic_state": "case mk\n\u03b1 : Type u\na : \u03b1\nm n : \u2115\nh : m \u2264 n\nf : Stream' (Option \u03b1)\nal : \u2200 \u2983n : \u2115\u2984 \u2983a : \u03b1\u2984, f n = some a \u2192 f (n + 1) = some a\n\u22a2 \u2191\u27e8f, al\u27e9 m = some a \u2192 \u2191\u27e8f, al\u27e9 n = some a"}, {"line": "induction' h with n _ IH", "tactic_state": "case mk.refl\n\u03b1 : Type u\na : \u03b1\nm n : \u2115\nf : Stream' (Option \u03b1)\nal : \u2200 \u2983n : \u2115\u2984 \u2983a : \u03b1\u2984, f n = some a \u2192 f (n + 1) = some a\n\u22a2 \u2191\u27e8f, al\u27e9 m = some a \u2192 \u2191\u27e8f, al\u27e9 m = some a\n---\ncase mk.step\n\u03b1 : Type u\na : \u03b1\nm n\u271d : \u2115\nf : Stream' (Option \u03b1)\nal : \u2200 \u2983n : \u2115\u2984 \u2983a : \u03b1\u2984, f n = some a \u2192 f (n + 1) = some a\nn : \u2115\na\u271d : m.le n\nIH : \u2191\u27e8f, al\u27e9 m = some a \u2192 \u2191\u27e8f, al\u27e9 n = some a\n\u22a2 \u2191\u27e8f, al\u27e9 m = some a \u2192 \u2191\u27e8f, al\u27e9 n.succ = some a"}, {"line": "exacts [id, fun h2 => al (IH h2)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem bind_pure' (s : Computation \u03b1) : bind s pure = s := by\n  simpa using bind_pure id s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Computation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Computation \u03b1 \u2192 Computation \u03b1 \u2192 Prop)", "(s : Computation \u03b1) [h : Terminates s]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Computation \u03b1\n\u22a2 s >>= pure = s"}, {"line": "simpa using bind_pure id s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem liftRel_pure (R : \u03b1 \u2192 \u03b2 \u2192 Prop) (a : \u03b1) (b : \u03b2) :\n    LiftRel R (pure a) (pure b) \u2194 R a b := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Computation.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Computation \u03b1 \u2192 Computation \u03b1 \u2192 Prop)", "(s : Computation \u03b1) [h : Terminates s]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nLiftRel : x\u271d\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\n\u22a2 sorry \u2194 R a b"}, {"line": "simp", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nLiftRel : x\u271d\nR : \u03b1 \u2192 \u03b2 \u2192 Prop\na : \u03b1\nb : \u03b2\n\u22a2 sorry () \u2194 R a b"}]}
{"declaration": "theorem val_eq_get (s : Seq \u03b1) (n : \u2115) : s.val n = s.get? n := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : Seq sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem terminatedAt_ofList (l : List \u03b1) :\n    (ofList l).TerminatedAt l.length := by\n  simp [ofList, TerminatedAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nofList : x\u271d\nl : List \u03b1\n\u22a2 sorry"}, {"line": "simp [ofList, TerminatedAt]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\nofList : x\u271d\nl : List \u03b1\n\u22a2 sorry ()"}]}
{"declaration": "theorem cons_terminatedAt_succ_iff {x : \u03b1} {s : Seq \u03b1} {n : \u2115} :\n    (cons x s).TerminatedAt (n + 1) \u2194 s.TerminatedAt n := by\n  simp [TerminatedAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ncons : x\u271d\nx : \u03b1\ns : Seq sorry\nn : \u2115\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [TerminatedAt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem terminatedAt_map_iff {f : \u03b1 \u2192 \u03b2} {s : Seq \u03b1} {n : \u2115} :\n    (map f s).TerminatedAt n \u2194 s.TerminatedAt n := by\n  simp [TerminatedAt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\ns : Seq sorry\nn : \u2115\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [TerminatedAt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem terminates_map_iff {f : \u03b1 \u2192 \u03b2} {s : Seq \u03b1} :\n    (map f s).Terminates \u2194 s.Terminates := by\n  simp [Terminates]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\nx\u271d : Sort u_1\nmap : x\u271d\nf : \u03b1 \u2192 \u03b2\ns : Seq sorry\n\u22a2 sorry \u2194 sorry"}, {"line": "simp [Terminates]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofList_append (l l' : List \u03b1) : ofList (l ++ l') = append (ofList l) (ofList l') := by\n  induction l <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofList : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\nl l' : List \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction l <;> simp [*]", "tactic_state": "case nil\n\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofList : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\nl' : List \u03b1\n\u22a2 sorry () = sorry ()\n---\ncase cons\n\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofList : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\nl' : List \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : sorry = sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem ofStream_append (l : List \u03b1) (s : Stream' \u03b1) :\n    ofStream (l ++\u209b s) = append (ofList l) (ofStream s) := by\n  induction l <;> simp [*, Stream'.nil_append_stream, Stream'.cons_append_stream]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofStream : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\nl : List \u03b1\ns : Stream' \u03b1\n\u22a2 sorry = sorry"}, {"line": "induction l <;> simp [*, Stream'.nil_append_stream, Stream'.cons_append_stream]", "tactic_state": "case nil\n\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofStream : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\ns : Stream' \u03b1\n\u22a2 sorry () = sorry ()\n---\ncase cons\n\u03b1 : Type u\nx\u271d\u00b9 : Sort u_1\nofStream : x\u271d\u00b9\nx\u271d : Sort u_2\nappend : x\u271d\ns : Stream' \u03b1\nhead\u271d : \u03b1\ntail\u271d : List \u03b1\ntail_ih\u271d : sorry = sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem drop_succ_cons {x : \u03b1} {s : Seq \u03b1} {n : \u2115} :\n    (cons x s).drop (n + 1) = s.drop n := by\n  simp [\u2190 dropn_tail]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ncons : x\u271d\nx : \u03b1\ns : Seq sorry\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "simp [\u2190 dropn_tail]", "tactic_state": "\u03b1 : Type u\nx\u271d : Sort u_1\ncons : x\u271d\nx : \u03b1\ns : Seq sorry\nn : \u2115\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem fold_head (init : \u03b2) (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (s : Seq \u03b1) :\n    (s.fold init f).head = init := by\n  simp [fold]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Seq/Seq.lean", "context": {"open": [], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "(R : Seq \u03b1 \u2192 Seq \u03b1 \u2192 Prop)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninit : \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\ns : Seq sorry\n\u22a2 sorry = init"}, {"line": "simp [fold]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninit : \u03b2\nf : \u03b2 \u2192 \u03b1 \u2192 \u03b2\ns : Seq sorry\n\u22a2 sorry () = init"}]}
{"declaration": "lemma accumulate_bot [PartialOrder \u03b1] [OrderBot \u03b1] (s : \u03b1 \u2192 Set \u03b2) : Accumulate s \u22a5 = s \u22a5 := by\n  simp [Set.accumulate_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Accumulate.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {s : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nAccumulate : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 sorry = s \u22a5"}, {"line": "simp [Set.accumulate_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nx\u271d : Sort u_3\nAccumulate : x\u271d\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : OrderBot \u03b1\ns : \u03b1 \u2192 Set \u03b2\n\u22a2 sorry () = s \u22a5"}]}
{"declaration": "lemma accumulate_zero_nat (s : \u2115 \u2192 Set \u03b2) : Accumulate s 0 = s 0 := by\n  simp [accumulate_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Accumulate.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {s : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\nx\u271d : Sort u_3\nAccumulate : x\u271d\ns : \u2115 \u2192 Set \u03b2\n\u22a2 sorry = s 0"}, {"line": "simp [accumulate_def]", "tactic_state": "\u03b2 : Type u_2\nx\u271d : Sort u_3\nAccumulate : x\u271d\ns : \u2115 \u2192 Set \u03b2\n\u22a2 sorry () = s 0"}]}
{"declaration": "theorem finiteInter_mem (cond : FiniteInter S) (F : Finset (Set \u03b1)) :\n    \u2191F \u2286 S \u2192 \u22c2\u2080 (\u2191F : Set (Set \u03b1)) \u2208 S := by\n  classical\n    refine Finset.induction_on F (fun _ => ?_) ?_\n    \u00b7 simp [cond.univ_mem]\n    \u00b7 intro a s _ h1 h2\n      suffices a \u2229 \u22c2\u2080 \u2191s \u2208 S by simpa\n      exact\n        cond.inter_mem (h2 (Finset.mem_insert_self a s))\n          (h1 fun x hx => h2 <| Finset.mem_insert_of_mem hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Constructions.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} (S : Set (Set \u03b1))", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\ncond : FiniteInter S\nF : Finset (Set \u03b1)\n\u22a2 \u2191F \u2286 S \u2192 \u22c2\u2080 \u2191F \u2208 S"}, {"line": "classical\n    refine Finset.induction_on F (fun _ => ?_) ?_\n    \u00b7 simp [cond.univ_mem]\n    \u00b7 intro a s _ h1 h2\n      suffices a \u2229 \u22c2\u2080 \u2191s \u2208 S by simpa\n      exact\n        cond.inter_mem (h2 (Finset.mem_insert_self a s))\n          (h1 fun x hx => h2 <| Finset.mem_insert_of_mem hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk\u2082 (h : \u2200 \u2983s\u2984, s \u2208 S \u2192 \u2200 \u2983t\u2984, t \u2208 S \u2192 s \u2229 t \u2208 S) :\n    FiniteInter (insert (univ : Set \u03b1) S) where\n  univ_mem := Set.mem_insert Set.univ S\n  inter_mem s hs t ht := by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Constructions.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 : Type*} (S : Set (Set \u03b1))", "{S}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nS : Set (Set \u03b1)\nh : \u2200 \u2983s : Set \u03b1\u2984, s \u2208 S \u2192 \u2200 \u2983t : Set \u03b1\u2984, t \u2208 S \u2192 s \u2229 t \u2208 S\ns : Set \u03b1\nhs : s \u2208 insert univ S\nt : Set \u03b1\nht : t \u2208 insert univ S\n\u22a2 s \u2229 t \u2208 insert univ S"}, {"line": "aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem image2_def {\u03b1 \u03b2 \u03b3 : Type u} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) :\n    image2 f s t = f <$> s <*> t := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Functor.lean", "context": {"open": ["Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type u} {s : Set \u03b1} {f : \u03b1 \u2192 Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nimage2 : x\u271d\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 sorry = f <$> s <*> t"}, {"line": "ext", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_1\nimage2 : x\u271d\u00b9\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : \u03b3\n\u22a2 x\u271d \u2208 sorry \u2194 x\u271d \u2208 f <$> s <*> t"}, {"line": "simp", "tactic_state": "case h\nx\u271d\u00b9 : Sort u_1\nimage2 : x\u271d\u00b9\n\u03b1 \u03b2 \u03b3 : Type u\nf : \u03b1 \u2192 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : \u03b3\n\u22a2 x\u271d \u2208 sorry () \u2194 \u2203 a \u2208 s, \u2203 a_1 \u2208 t, f a a_1 = x\u271d"}]}
{"declaration": "theorem coe_eq_image_val (t : Set s) :\n    @Lean.Internal.coeM Set s \u03b1 _ Set.monad t = (t : Set \u03b1) := by\n  change \u22c3 (x \u2208 t), {x.1} = _\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Functor.lean", "context": {"open": ["Function Set.Notation"], "variables": ["{\u03b1 \u03b2 : Type u} {s : Set \u03b1} {f : \u03b1 \u2192 Set \u03b2}", "{\u03b2 : Set \u03b1} {\u03b3 : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nt : Set \u2191s\n\u22a2 Lean.Internal.coeM t = Subtype.val '' t"}, {"line": "change \u22c3 (x \u2208 t), {x.1} = _", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nt : Set \u2191s\n\u22a2 \u22c3 x \u2208 t, {\u2191x} = Subtype.val '' t"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u\ns : Set \u03b1\nt : Set \u2191s\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 \u22c3 x \u2208 t, {\u2191x} \u2194 x\u271d \u2208 Subtype.val '' t"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inclusion_inclusion (hst : s \u2286 t) (htu : t \u2286 u) (x : s) :\n    inclusion htu (inclusion hst x) = inclusion (hst.trans htu) x := by\n  cases x\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Inclusion.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type*} {s t u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t u : Set \u03b1\nx\u271d : Sort u_2\ninclusion : x\u271d\nhst : s \u2286 t\nhtu : t \u2286 u\nx : \u2191s\n\u22a2 sorry = sorry"}, {"line": "cases x", "tactic_state": "case mk\n\u03b1 : Type u_1\ns t u : Set \u03b1\nx\u271d : Sort u_2\ninclusion : x\u271d\nhst : s \u2286 t\nhtu : t \u2286 u\nval\u271d : \u03b1\nproperty\u271d : val\u271d \u2208 s\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma memPartitionSet_zero (f : \u2115 \u2192 Set \u03b1) (a : \u03b1) : memPartitionSet f 0 a = univ := by\n  simp [memPartitionSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/MemPartition.lean", "context": {"open": ["Set", "Classical in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\na : \u03b1\n\u22a2 memPartitionSet f 0 a = univ"}, {"line": "simp [memPartitionSet]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma memPartitionSet_succ (f : \u2115 \u2192 Set \u03b1) (n : \u2115) (a : \u03b1) [Decidable (a \u2208 f n)] :\n    memPartitionSet f (n + 1) a\n      = if a \u2208 f n then memPartitionSet f n a \u2229 f n else memPartitionSet f n a \\ f n := by\n  simp [memPartitionSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/MemPartition.lean", "context": {"open": ["Set", "Classical in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ninst\u271d : Decidable (a \u2208 f n)\n\u22a2 memPartitionSet f (n + 1) a = if a \u2208 f n then memPartitionSet f n a \u2229 f n else memPartitionSet f n a \\ f n"}, {"line": "simp [memPartitionSet]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma memPartitionSet_eq_iff {f : \u2115 \u2192 Set \u03b1} {n : \u2115} (a : \u03b1) {s : Set \u03b1}\n    (hs : s \u2208 memPartition f n) :\n    memPartitionSet f n a = s \u2194 a \u2208 s := by\n  refine \u27e8fun h \u21a6 h \u25b8 mem_memPartitionSet f n a, fun h \u21a6 ?_\u27e9\n  by_contra h_ne\n  have h_disj : Disjoint s (memPartitionSet f n a) :=\n    disjoint_memPartition f n hs (memPartitionSet_mem f n a) (Ne.symm h_ne)\n  refine absurd h_disj ?_\n  rw [not_disjoint_iff_nonempty_inter]\n  exact \u27e8a, h, mem_memPartitionSet f n a\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/MemPartition.lean", "context": {"open": ["Set", "Classical in"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\n\u22a2 memPartitionSet f n a = s \u2194 a \u2208 s"}, {"line": "refine \u27e8fun h \u21a6 h \u25b8 mem_memPartitionSet f n a, fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\nh : a \u2208 s\n\u22a2 memPartitionSet f n a = s"}, {"line": "by_contra h_ne", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\nh : a \u2208 s\nh_ne : \u00acmemPartitionSet f n a = s\n\u22a2 False"}, {"line": "have h_disj : Disjoint s (memPartitionSet f n a) :=\n    disjoint_memPartition f n hs (memPartitionSet_mem f n a) (Ne.symm h_ne)", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\nh : a \u2208 s\nh_ne : \u00acmemPartitionSet f n a = s\nh_disj : Disjoint s (memPartitionSet f n a)\n\u22a2 False"}, {"line": "refine absurd h_disj ?_", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\nh : a \u2208 s\nh_ne : \u00acmemPartitionSet f n a = s\nh_disj : Disjoint s (memPartitionSet f n a)\n\u22a2 \u00acDisjoint s (memPartitionSet f n a)"}, {"line": "rw [not_disjoint_iff_nonempty_inter]", "tactic_state": "\u03b1 : Type u_1\nf : \u2115 \u2192 Set \u03b1\nn : \u2115\na : \u03b1\ns : Set \u03b1\nhs : s \u2208 memPartition f n\nh : a \u2208 s\nh_ne : \u00acmemPartitionSet f n a = s\nh_disj : Disjoint s (memPartitionSet f n a)\n\u22a2 (s \u2229 memPartitionSet f n a).Nonempty"}, {"line": "exact \u27e8a, h, mem_memPartitionSet f n a\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem swap_mem_mulAntidiagonal [CommMagma \u03b1] {s t : Set \u03b1} {a : \u03b1} {x : \u03b1 \u00d7 \u03b1} :\n    x.swap \u2208 Set.mulAntidiagonal s t a \u2194 x \u2208 Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/MulAntidiagonal.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {a : \u03b1} {x : \u03b1 \u00d7 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : CommMagma \u03b1\ns t : Set \u03b1\na : \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x.swap \u2208 s.mulAntidiagonal t a \u2194 x \u2208 t.mulAntidiagonal s a"}, {"line": "simp [mul_comm, and_left_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : CommMagma \u03b1\ns t : Set \u03b1\na : \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x.2 \u2208 s \u2192 x.1 \u2208 t \u2192 (x.2 * x.1 = a \u2194 x.1 * x.2 = a)"}]}
{"declaration": "theorem swap_mem_mulAntidiagonal_aux [CommMagma \u03b1] {s t : Set \u03b1} {a : \u03b1} {x : \u03b1 \u00d7 \u03b1} :\n    x.snd \u2208 s \u2227 x.fst \u2208 t \u2227 x.snd * x.fst = a\n      \u2194 x \u2208 Set.mulAntidiagonal t s a := by\n  simp [mul_comm, and_left_comm]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/MulAntidiagonal.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*}", "[Mul \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {a : \u03b1} {x : \u03b1 \u00d7 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : CommMagma \u03b1\ns t : Set \u03b1\na : \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x.2 \u2208 s \u2227 x.1 \u2208 t \u2227 x.2 * x.1 = a \u2194 x \u2208 t.mulAntidiagonal s a"}, {"line": "simp [mul_comm, and_left_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : Mul \u03b1\ninst\u271d : CommMagma \u03b1\ns t : Set \u03b1\na : \u03b1\nx : \u03b1 \u00d7 \u03b1\n\u22a2 x.2 \u2208 s \u2192 x.1 \u2208 t \u2192 (x.2 * x.1 = a \u2194 x.1 * x.2 = a)"}]}
{"declaration": "lemma image2_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) :\n    image2 (fun a b \u21a6 f (a, b)) s t = f '' s \u00d7\u02e2 t := by\n  simp [\u2190 image_uncurry_prod, uncurry]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' \u03b6 \u03b6' \u03bd : Type*} {f f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{s s' : Set \u03b1} {t t' : Set \u03b2} {u : Set \u03b3} {v : Set \u03b4} {a : \u03b1} {b : \u03b2}", "(f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nx\u271d : Sort u_14\nimage2 : x\u271d\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 sorry = f '' s \u00d7\u02e2 t"}, {"line": "simp [\u2190 image_uncurry_prod, uncurry]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\n\u03b3 : Type u_5\nx\u271d : Sort u_14\nimage2 : x\u271d\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\ns : Set \u03b1\nt : Set \u03b2\n\u22a2 sorry () = f '' s \u00d7\u02e2 t"}]}
{"declaration": "theorem image2_left (h : t.Nonempty) : image2 (fun x _ => x) s t = s := by\n  simp [nonempty_def.mp h, Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' \u03b6 \u03b6' \u03bd : Type*} {f f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{s s' : Set \u03b1} {t t' : Set \u03b2} {u : Set \u03b3} {v : Set \u03b4} {a : \u03b1} {b : \u03b2}", "(f)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : Sort u_14\nimage2 : x\u271d\nh : t.Nonempty\n\u22a2 sorry = s"}, {"line": "simp [nonempty_def.mp h, Set.ext_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : Sort u_14\nimage2 : x\u271d\nh : t.Nonempty\n\u22a2 \u2200 (x : \u03b1), x \u2208 sorry () \u2194 x \u2208 s"}]}
{"declaration": "theorem image2_right (h : s.Nonempty) : image2 (fun _ y => y) s t = t := by\n  simp [nonempty_def.mp h, Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/NAry.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 \u03b1' \u03b2 \u03b2' \u03b3 \u03b3' \u03b4 \u03b4' \u03b5 \u03b5' \u03b6 \u03b6' \u03bd : Type*} {f f' : \u03b1 \u2192 \u03b2 \u2192 \u03b3}", "{s s' : Set \u03b1} {t t' : Set \u03b2} {u : Set \u03b3} {v : Set \u03b4} {a : \u03b1} {b : \u03b2}", "(f)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : Sort u_14\nimage2 : x\u271d\nh : s.Nonempty\n\u22a2 sorry = t"}, {"line": "simp [nonempty_def.mp h, Set.ext_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_3\ns : Set \u03b1\nt : Set \u03b2\nx\u271d : Sort u_14\nimage2 : x\u271d\nh : s.Nonempty\n\u22a2 \u2200 (x : \u03b2), x \u2208 sorry () \u2194 x \u2208 t"}]}
{"declaration": "theorem op_mem_op {s : Set \u03b1} {a : \u03b1} : op a \u2208 s.op \u2194 a \u2208 s := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\n\u22a2 op a \u2208 s.op \u2194 a \u2208 s"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem unop_mem_unop {s : Set \u03b1\u1d52\u1d56} {a : \u03b1\u1d52\u1d56} : unop a \u2208 s.unop \u2194 a \u2208 s := by rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\u1d52\u1d56\na : \u03b1\u1d52\u1d56\n\u22a2 unop a \u2208 s.unop \u2194 a \u2208 s"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_op (x : \u03b1) : ({x} : Set \u03b1).op = {op x} := by\n  ext\n  constructor\n  \u00b7 apply unop_injective\n  \u00b7 apply op_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 {x}.op = {op x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx : \u03b1\nx\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {x}.op \u2194 x\u271d \u2208 {op x}"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_1\nx : \u03b1\nx\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {x}.op \u2192 x\u271d \u2208 {op x}\n---\ncase h.mpr\n\u03b1 : Type u_1\nx : \u03b1\nx\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {op x} \u2192 x\u271d \u2208 {x}.op"}, {"line": "\u00b7 apply unop_injective", "tactic_state": "case h.mpr\n\u03b1 : Type u_1\nx : \u03b1\nx\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {op x} \u2192 x\u271d \u2208 {x}.op"}, {"line": "\u00b7 apply op_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_unop (x : \u03b1\u1d52\u1d56) : ({x} : Set \u03b1\u1d52\u1d56).unop = {unop x} := by\n  ext\n  constructor\n  \u00b7 apply op_injective\n  \u00b7 apply unop_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\n\u22a2 {x}.unop = {unop x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 {x}.unop \u2194 x\u271d \u2208 {unop x}"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 {x}.unop \u2192 x\u271d \u2208 {unop x}\n---\ncase h.mpr\n\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 {unop x} \u2192 x\u271d \u2208 {x}.unop"}, {"line": "\u00b7 apply op_injective", "tactic_state": "case h.mpr\n\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 {unop x} \u2192 x\u271d \u2208 {x}.unop"}, {"line": "\u00b7 apply unop_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_op_unop (x : \u03b1) : ({op x} : Set \u03b1\u1d52\u1d56).unop = {x} := by\n  ext\n  constructor\n  \u00b7 apply op_injective\n  \u00b7 apply unop_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\n\u22a2 {op x}.unop = {x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {op x}.unop \u2194 x\u271d \u2208 {x}"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_1\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {op x}.unop \u2192 x\u271d \u2208 {x}\n---\ncase h.mpr\n\u03b1 : Type u_1\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {x} \u2192 x\u271d \u2208 {op x}.unop"}, {"line": "\u00b7 apply op_injective", "tactic_state": "case h.mpr\n\u03b1 : Type u_1\nx x\u271d : \u03b1\n\u22a2 x\u271d \u2208 {x} \u2192 x\u271d \u2208 {op x}.unop"}, {"line": "\u00b7 apply unop_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_unop_op (x : \u03b1\u1d52\u1d56) : ({unop x} : Set \u03b1).op = {x} := by\n  ext\n  constructor\n  \u00b7 apply unop_injective\n  \u00b7 apply op_injective\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Opposite.lean", "context": {"open": ["Opposite"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\u1d52\u1d56\n\u22a2 {unop x}.op = {x}"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\nx x\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {unop x}.op \u2194 x\u271d \u2208 {x}"}, {"line": "constructor", "tactic_state": "case h.mp\n\u03b1 : Type u_1\nx x\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {unop x}.op \u2192 x\u271d \u2208 {x}\n---\ncase h.mpr\n\u03b1 : Type u_1\nx x\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {x} \u2192 x\u271d \u2208 {unop x}.op"}, {"line": "\u00b7 apply unop_injective", "tactic_state": "case h.mpr\n\u03b1 : Type u_1\nx x\u271d : \u03b1\u1d52\u1d56\n\u22a2 x\u271d \u2208 {x} \u2192 x\u271d \u2208 {unop x}.op"}, {"line": "\u00b7 apply op_injective", "tactic_state": "No Goals!"}]}
{"declaration": "theorem monotoneOn_iff_monotone : MonotoneOn f s \u2194\n    Monotone fun a : s => f a := by\n  simp [Monotone, MonotoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 MonotoneOn f s \u2194 Monotone fun a => f \u2191a"}, {"line": "simp [Monotone, MonotoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem antitoneOn_iff_antitone : AntitoneOn f s \u2194\n    Antitone fun a : s => f a := by\n  simp [Antitone, AntitoneOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 AntitoneOn f s \u2194 Antitone fun a => f \u2191a"}, {"line": "simp [Antitone, AntitoneOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMonoOn_iff_strictMono : StrictMonoOn f s \u2194\n    StrictMono fun a : s => f a := by\n  simp [StrictMono, StrictMonoOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictMonoOn f s \u2194 StrictMono fun a => f \u2191a"}, {"line": "simp [StrictMono, StrictMonoOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictAntiOn_iff_strictAnti : StrictAntiOn f s \u2194\n    StrictAnti fun a : s => f a := by\n  simp [StrictAnti, StrictAntiOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : Preorder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 StrictAntiOn f s \u2194 StrictAnti fun a => f \u2191a"}, {"line": "simp [StrictAnti, StrictAntiOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_monotoneOn_not_antitoneOn_iff_exists_le_le :\n    \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n      \u2203\u1d49 (a \u2208 s) (b \u2208 s) (c \u2208 s), a \u2264 b \u2227 b \u2264 c \u2227\n        (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c) := by\n  simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n    \u2203 a \u2208 s, \u2203 b \u2208 s, \u2203 c \u2208 s, a \u2264 b \u2227 b \u2264 c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)"}, {"line": "simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_le_le, @and_left_comm (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n    \u2203 a \u2208 s, \u2203 b, a \u2264 b \u2227 b \u2208 s \u2227 \u2203 x, b \u2264 x \u2227 x \u2208 s \u2227 (f a < f b \u2227 f x < f b \u2228 f b < f a \u2227 f b < f x)"}]}
{"declaration": "theorem not_monotoneOn_not_antitoneOn_iff_exists_lt_lt :\n    \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n      \u2203\u1d49 (a \u2208 s) (b \u2208 s) (c \u2208 s), a < b \u2227 b < c \u2227\n        (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c) := by\n  simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ \u2208 s)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Order.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "[Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}", "[LinearOrder \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n    \u2203 a \u2208 s, \u2203 b \u2208 s, \u2203 c \u2208 s, a < b \u2227 b < c \u2227 (f a < f b \u2227 f c < f b \u2228 f b < f a \u2227 f b < f c)"}, {"line": "simp [monotoneOn_iff_monotone, antitoneOn_iff_antitone, and_assoc, exists_and_left,\n    not_monotone_not_antitone_iff_exists_lt_lt, @and_left_comm (_ \u2208 s)]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\ninst\u271d\u00b3 : Preorder \u03b1\ninst\u271d\u00b2 : Preorder \u03b2\ninst\u271d\u00b9 : LinearOrder \u03b1\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 \u00acMonotoneOn f s \u2227 \u00acAntitoneOn f s \u2194\n    \u2203 a \u2208 s, \u2203 b, a < b \u2227 b \u2208 s \u2227 \u2203 x, b < x \u2227 x \u2208 s \u2227 (f a < f b \u2227 f x < f b \u2228 f b < f a \u2227 f b < f x)"}]}
{"declaration": "theorem image_val_preimage_restrictPreimage {u : Set t} :\n    Subtype.val '' (t.restrictPreimage f \u207b\u00b9' u) = f \u207b\u00b9' (Subtype.val '' u) := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Restrict.lean", "context": {"open": ["Equiv Equiv.Perm Function"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} {\u03b9 : Sort*} {\u03c0 : \u03b1 \u2192 Type*}", "{s : Set \u03b1} {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2}", "{s s\u2081 s\u2082 : Set \u03b1} {t t\u2081 t\u2082 : Set \u03b2} {p : Set \u03b3} {f f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {g g\u2081 g\u2082 : \u03b2 \u2192 \u03b3}", "(t)", "(f s) in", "(f) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u2191t\n\u22a2 Subtype.val '' (t.restrictPreimage f \u207b\u00b9' u) = f \u207b\u00b9' (Subtype.val '' u)"}, {"line": "ext", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\nt : Set \u03b2\nf : \u03b1 \u2192 \u03b2\nu : Set \u2191t\nx\u271d : \u03b1\n\u22a2 x\u271d \u2208 Subtype.val '' (t.restrictPreimage f \u207b\u00b9' u) \u2194 x\u271d \u2208 f \u207b\u00b9' (Subtype.val '' u)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Subsingleton.induction_on {p : Set \u03b1 \u2192 Prop} (hs : s.Subsingleton) (he : p \u2205)\n    (h\u2081 : \u2200 x, p {x}) : p s := by\n  rcases hs.eq_empty_or_singleton with (rfl | \u27e8x, rfl\u27e9)\n  exacts [he, h\u2081 _]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subsingleton.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\np : Set \u03b1 \u2192 Prop\nhs : s.Subsingleton\nhe : p \u2205\nh\u2081 : \u2200 (x : \u03b1), p {x}\n\u22a2 p s"}, {"line": "rcases hs.eq_empty_or_singleton with (rfl | \u27e8x, rfl\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u\np : Set \u03b1 \u2192 Prop\nhe : p \u2205\nh\u2081 : \u2200 (x : \u03b1), p {x}\nhs : \u2205.Subsingleton\n\u22a2 p \u2205\n---\ncase inr.intro\n\u03b1 : Type u\np : Set \u03b1 \u2192 Prop\nhe : p \u2205\nh\u2081 : \u2200 (x : \u03b1), p {x}\nx : \u03b1\nhs : {x}.Subsingleton\n\u22a2 p {x}"}, {"line": "exacts [he, h\u2081 _]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subsingleton_coe (s : Set \u03b1) : Subsingleton s \u2194 s.Subsingleton := by\n  constructor\n  \u00b7 refine fun h => fun a ha b hb => ?_\n    exact SetCoe.ext_iff.2 (@Subsingleton.elim s h \u27e8a, ha\u27e9 \u27e8b, hb\u27e9)\n  \u00b7 exact fun h => Subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subsingleton.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 Subsingleton \u2191s \u2194 s.Subsingleton"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 Subsingleton \u2191s \u2192 s.Subsingleton\n---\ncase mpr\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 s.Subsingleton \u2192 Subsingleton \u2191s"}, {"line": "\u00b7 refine fun h => fun a ha b hb => ?_\n    exact SetCoe.ext_iff.2 (@Subsingleton.elim s h \u27e8a, ha\u27e9 \u27e8b, hb\u27e9)", "tactic_state": "case mpr\n\u03b1 : Type u\ns : Set \u03b1\n\u22a2 s.Subsingleton \u2192 Subsingleton \u2191s"}, {"line": "\u00b7 exact fun h => Subsingleton.intro fun a b => SetCoe.ext (h a.property b.property)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Nontrivial.exists_ne (hs : s.Nontrivial) (z) : \u2203 x \u2208 s, x \u2260 z := by\n  by_contra! H\n  rcases hs with \u27e8x, hx, y, hy, hxy\u27e9\n  rw [H x hx] at hxy\n  rw [H y hy] at hxy\n  exact hxy rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subsingleton.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Nontrivial\nz : \u03b1\n\u22a2 \u2203 x \u2208 s, x \u2260 z"}, {"line": "by_contra! H", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhs : s.Nontrivial\nz : \u03b1\nH : \u2200 x \u2208 s, x = z\n\u22a2 False"}, {"line": "rcases hs with \u27e8x, hx, y, hy, hxy\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\ns : Set \u03b1\nz : \u03b1\nH : \u2200 x \u2208 s, x = z\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : x \u2260 y\n\u22a2 False"}, {"line": "rw [H x hx] at hxy", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\ns : Set \u03b1\nz : \u03b1\nH : \u2200 x \u2208 s, x = z\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : z \u2260 y\n\u22a2 False"}, {"line": "rw [H y hy] at hxy", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\ns : Set \u03b1\nz : \u03b1\nH : \u2200 x \u2208 s, x = z\nx : \u03b1\nhx : x \u2208 s\ny : \u03b1\nhy : y \u2208 s\nhxy : z \u2260 z\n\u22a2 False"}, {"line": "exact hxy rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nontrivial_coe_sort {s : Set \u03b1} : Nontrivial s \u2194 s.Nontrivial := by\n  simp [\u2190 nontrivial_univ_iff, Set.Nontrivial]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subsingleton.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 Nontrivial \u2191s \u2194 s.Nontrivial"}, {"line": "simp [\u2190 nontrivial_univ_iff, Set.Nontrivial]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_subsingleton_iff : \u00acs.Subsingleton \u2194 s.Nontrivial := by\n  simp_rw [Set.Subsingleton, Set.Nontrivial, not_forall, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Subsingleton.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}", "{\u03b1 : Type u} {a : \u03b1} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 \u00acs.Subsingleton \u2194 s.Nontrivial"}, {"line": "simp_rw [Set.Subsingleton, Set.Nontrivial, not_forall, exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_sups : c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c := by simp [(\u00b7 \u22bb \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sups.lean", "context": {"open": ["Function", "SetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Set \u03b1)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : SemilatticeSup \u03b1\ns t : Set \u03b1\nc : \u03b1\n\u22a2 c \u2208 s \u22bb t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2294 b = c"}, {"line": "simp [(\u00b7 \u22bb \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_infs : c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c := by simp [(\u00b7 \u22bc \u00b7)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Sups.lean", "context": {"open": ["Function", "SetFamily", "SetFamily"], "variables": ["{F \u03b1 \u03b2 : Type*}", "[SemilatticeSup \u03b1] [SemilatticeSup \u03b2] [FunLike F \u03b1 \u03b2] [SupHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Set \u03b1)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u} {a b c : \u03b1}", "(s t u)", "[SemilatticeInf \u03b1] [SemilatticeInf \u03b2] [FunLike F \u03b1 \u03b2] [InfHomClass F \u03b1 \u03b2]", "(s s\u2081 s\u2082 t t\u2081 t\u2082 u v : Set \u03b1)", "{s s\u2081 s\u2082 t t\u2081 t\u2082 u} {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : SemilatticeSup \u03b1\ninst\u271d : SemilatticeInf \u03b1\ns t : Set \u03b1\nc : \u03b1\n\u22a2 c \u2208 s \u22bc t \u2194 \u2203 a \u2208 s, \u2203 b \u2208 t, a \u2293 b = c"}, {"line": "simp [(\u00b7 \u22bc \u00b7)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_in_swap {p : \u03b1 \u2192 \u03b2 \u2192 Prop} : (\u2200 a \u2208 s, \u2200 (b), p a b) \u2194 \u2200 (b), \u2200 a \u2208 s, p a b := by\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\np : \u03b1 \u2192 \u03b2 \u2192 Prop\n\u22a2 (\u2200 a \u2208 s, \u2200 (b : \u03b2), p a b) \u2194 \u2200 (b : \u03b2), \u2200 a \u2208 s, p a b"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_top_subset : \u00ac\u22a4 \u2286 s \u2194 \u2203 a, a \u2209 s := by\n  simp [not_subset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 \u00ac\u22a4 \u2286 s \u2194 \u2203 a, a \u2209 s"}, {"line": "simp [not_subset]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\n\u22a2 \u00acs = Set.univ \u2194 \u2203 a, a \u2209 s"}]}
{"declaration": "theorem Nonempty.eq_univ [Subsingleton \u03b1] : s.Nonempty \u2192 s = univ := by\n  rintro \u27e8x, hx\u27e9\n  exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns univ : Set \u03b1\ninst\u271d : Subsingleton \u03b1\n\u22a2 s.Nonempty \u2192 s = univ"}, {"line": "rintro \u27e8x, hx\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ns univ : Set \u03b1\ninst\u271d : Subsingleton \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 s = univ"}, {"line": "exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_dite_univ_right (p : Prop) [Decidable p] (t : p \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then t h else univ) \u2194 \u2200 h : p, x \u2208 t h := by\n  simp [mem_dite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniv : Set \u03b1\np : Prop\ninst\u271d : Decidable p\nt : p \u2192 Set \u03b1\nx : \u03b1\n\u22a2 (x \u2208 if h : p then t h else univ) \u2194 \u2200 (h : p), x \u2208 t h"}, {"line": "simp [mem_dite]", "tactic_state": "\u03b1 : Type u\nuniv : Set \u03b1\np : Prop\ninst\u271d : Decidable p\nt : p \u2192 Set \u03b1\nx : \u03b1\n\u22a2 (\u2200 (h : p), x \u2208 t h) \u2192 \u00acp \u2192 x \u2208 univ"}]}
{"declaration": "theorem mem_dite_univ_left (p : Prop) [Decidable p] (t : \u00acp \u2192 Set \u03b1) (x : \u03b1) :\n    (x \u2208 if h : p then univ else t h) \u2194 \u2200 h : \u00acp, x \u2208 t h := by\n  split_ifs <;> simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniv : Set \u03b1\np : Prop\ninst\u271d : Decidable p\nt : \u00acp \u2192 Set \u03b1\nx : \u03b1\n\u22a2 (x \u2208 if h : p then univ else t h) \u2194 \u2200 (h : \u00acp), x \u2208 t h"}, {"line": "split_ifs <;> simp_all", "tactic_state": "case pos\n\u03b1 : Type u\nuniv : Set \u03b1\np : Prop\ninst\u271d : Decidable p\nt : \u00acp \u2192 Set \u03b1\nx : \u03b1\nh\u271d : p\n\u22a2 x \u2208 univ"}]}
{"declaration": "theorem ite_left (s t : Set \u03b1) : s.ite s t = s \u222a t := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 s.ite s t = s \u222a t"}, {"line": "simp [Set.ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_right (s t : Set \u03b1) : s.ite t s = t \u2229 s := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 s.ite t s = t \u2229 s"}, {"line": "simp [Set.ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_empty (s s' : Set \u03b1) : Set.ite \u2205 s s' = s' := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns s' : Set \u03b1\n\u22a2 \u2205.ite s s' = s'"}, {"line": "simp [Set.ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_univ (s s' : Set \u03b1) : Set.ite univ s s' = s := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nuniv s s' : Set \u03b1\n\u22a2 univ.ite s s' = s"}, {"line": "simp [Set.ite]", "tactic_state": "\u03b1 : Type u\nuniv s s' : Set \u03b1\n\u22a2 s \u2229 univ \u222a s' \\ univ = s"}]}
{"declaration": "theorem ite_empty_left (t s : Set \u03b1) : t.ite \u2205 s = s \\ t := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt s : Set \u03b1\n\u22a2 t.ite \u2205 s = s \\ t"}, {"line": "simp [Set.ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_empty_right (t s : Set \u03b1) : t.ite s \u2205 = s \u2229 t := by simp [Set.ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt s : Set \u03b1\n\u22a2 t.ite s \u2205 = s \u2229 t"}, {"line": "simp [Set.ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_eq_of_subset_left (t : Set \u03b1) {s\u2081 s\u2082 : Set \u03b1} (h : s\u2081 \u2286 s\u2082) :\n    t.ite s\u2081 s\u2082 = s\u2081 \u222a (s\u2082 \\ t) := by\n  ext x\n  by_cases hx : x \u2208 t <;> simp [*, Set.ite, or_iff_right_of_imp (@h x)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt s\u2081 s\u2082 : Set \u03b1\nh : s\u2081 \u2286 s\u2082\n\u22a2 t.ite s\u2081 s\u2082 = s\u2081 \u222a s\u2082 \\ t"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\nt s\u2081 s\u2082 : Set \u03b1\nh : s\u2081 \u2286 s\u2082\nx : \u03b1\n\u22a2 x \u2208 t.ite s\u2081 s\u2082 \u2194 x \u2208 s\u2081 \u222a s\u2082 \\ t"}, {"line": "by_cases hx : x \u2208 t <;> simp [*, Set.ite, or_iff_right_of_imp (@h x)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ite_eq_of_subset_right (t : Set \u03b1) {s\u2081 s\u2082 : Set \u03b1} (h : s\u2082 \u2286 s\u2081) :\n    t.ite s\u2081 s\u2082 = (s\u2081 \u2229 t) \u222a s\u2082 := by\n  ext x\n  by_cases hx : x \u2208 t <;> simp [*, Set.ite, or_iff_left_of_imp (@h x)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt s\u2081 s\u2082 : Set \u03b1\nh : s\u2082 \u2286 s\u2081\n\u22a2 t.ite s\u2081 s\u2082 = s\u2081 \u2229 t \u222a s\u2082"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u\nt s\u2081 s\u2082 : Set \u03b1\nh : s\u2082 \u2286 s\u2081\nx : \u03b1\n\u22a2 x \u2208 t.ite s\u2081 s\u2082 \u2194 x \u2208 s\u2081 \u2229 t \u222a s\u2082"}, {"line": "by_cases hx : x \u2208 t <;> simp [*, Set.ite, or_iff_left_of_imp (@h x)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Injective.nonempty_apply_iff {f : Set \u03b1 \u2192 Set \u03b2} (hf : Injective f) (h2 : f \u2205 = \u2205)\n    {s : Set \u03b1} : (f s).Nonempty \u2194 s.Nonempty := by\n  rw [nonempty_iff_ne_empty]\n  rw [\u2190 h2]\n  rw [nonempty_iff_ne_empty]\n  rw [hf.ne_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Basic.lean", "context": {"open": ["Function", "Set"], "variables": ["{\u03b1 : Type u} {s t : Set \u03b1}", "{\u03b1 : Type u}", "{\u03b1 : Type u} {\u03b2 : Type v} {a b : \u03b1} {s s\u2081 s\u2082 t t\u2081 t\u2082 u : Set \u03b1}", "{p q : \u03b1 \u2192 Prop} {x : \u03b1}", "{\u03b1 : Type*} {\u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Set \u03b1 \u2192 Set \u03b2\nhf : Injective f\nh2 : f \u2205 = \u2205\ns : Set \u03b1\n\u22a2 (f s).Nonempty \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Set \u03b1 \u2192 Set \u03b2\nhf : Injective f\nh2 : f \u2205 = \u2205\ns : Set \u03b1\n\u22a2 f s \u2260 \u2205 \u2194 s.Nonempty"}, {"line": "rw [\u2190 h2]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Set \u03b1 \u2192 Set \u03b2\nhf : Injective f\nh2 : f \u2205 = \u2205\ns : Set \u03b1\n\u22a2 f s \u2260 f \u2205 \u2194 s.Nonempty"}, {"line": "rw [nonempty_iff_ne_empty]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nf : Set \u03b1 \u2192 Set \u03b2\nhf : Injective f\nh2 : f \u2205 = \u2205\ns : Set \u03b1\n\u22a2 f s \u2260 f \u2205 \u2194 s \u2260 \u2205"}, {"line": "rw [hf.ne_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem encard_ne_top_iff : s.encard \u2260 \u22a4 \u2194 s.Finite := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\n\u22a2 s.encard \u2260 \u22a4 \u2194 s.Finite"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem encard_prod : (s \u00d7\u02e2 t).encard = s.encard * t.encard := by\n  simp [Set.encard, ENat.card_congr (Equiv.Set.prod ..)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": [], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns t : Set \u03b1\n\u22a2 (s \u00d7\u02e2 t).encard = s.encard * t.encard"}, {"line": "simp [Set.encard, ENat.card_congr (Equiv.Set.prod ..)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ncard_eq_toFinset_card' (s : Set \u03b1) [Fintype s] :\n    s.ncard = s.toFinset.card := by\n  simp [\u2190 Nat.card_coe_set_eq, Nat.card_eq_fintype_card]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}", "{a b : \u03b1}", "{s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.ncard = s.toFinset.card"}, {"line": "simp [\u2190 Nat.card_coe_set_eq, Nat.card_eq_fintype_card]", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\ninst\u271d : Fintype \u2191s\n\u22a2 s.ncard = Fintype.card \u2191s"}]}
{"declaration": "theorem ncard_diff_singleton_le (s : Set \u03b1) (a : \u03b1) : (s \\ {a}).ncard \u2264 s.ncard := by\n  obtain hs | hs := s.finite_or_infinite\n  \u00b7 apply ncard_le_ncard diff_subset hs\n  convert zero_le (\u03b1 := \u2115) _\n  exact (hs.diff (by simp : Set.Finite {a})).ncard\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}", "{a b : \u03b1}", "{s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\n\u22a2 (s \\ {a}).ncard \u2264 s.ncard"}, {"line": "obtain hs | hs := s.finite_or_infinite", "tactic_state": "case inl\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Finite\n\u22a2 (s \\ {a}).ncard \u2264 s.ncard\n---\ncase inr\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 (s \\ {a}).ncard \u2264 s.ncard"}, {"line": "\u00b7 apply ncard_le_ncard diff_subset hs", "tactic_state": "case inr\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 (s \\ {a}).ncard \u2264 s.ncard"}, {"line": "convert zero_le (\u03b1 := \u2115) _", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 (s \\ {a}).ncard = 0"}, {"line": "exact (hs.diff (by simp : Set.Finite {a})).ncard", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pred_ncard_le_ncard_diff_singleton (s : Set \u03b1) (a : \u03b1) : s.ncard - 1 \u2264 (s \\ {a}).ncard := by\n  rcases s.finite_or_infinite with hs | hs\n  \u00b7 by_cases h : a \u2208 s\n    \u00b7 rw [ncard_diff_singleton_of_mem h hs]\n    rw [diff_singleton_eq_self h]\n    apply Nat.pred_le\n  convert Nat.zero_le _\n  rw [hs.ncard]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}", "{a b : \u03b1}", "{s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\n\u22a2 s.ncard - 1 \u2264 (s \\ {a}).ncard"}, {"line": "rcases s.finite_or_infinite with hs | hs", "tactic_state": "case inl\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Finite\n\u22a2 s.ncard - 1 \u2264 (s \\ {a}).ncard\n---\ncase inr\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 s.ncard - 1 \u2264 (s \\ {a}).ncard"}, {"line": "\u00b7 by_cases h : a \u2208 s\n    \u00b7 rw [ncard_diff_singleton_of_mem h hs]\n    rw [diff_singleton_eq_self h]\n    apply Nat.pred_le", "tactic_state": "case inr\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 s.ncard - 1 \u2264 (s \\ {a}).ncard"}, {"line": "convert Nat.zero_le _", "tactic_state": "case h.e'_3\n\u03b1 : Type u_1\ns : Set \u03b1\na : \u03b1\nhs : s.Infinite\n\u22a2 s.ncard - 1 = 0"}, {"line": "rw [hs.ncard]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_subset_card_eq {n : \u2115} (hns : n \u2264 s.ncard) : \u2203 t \u2286 s, t.ncard = n := by\n  simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Card.lean", "context": {"open": ["Nat"], "variables": ["{\u03b1 \u03b2 : Type*} {s t : Set \u03b1}", "{a b : \u03b1}", "{s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ns : Set \u03b1\nn : \u2115\nhns : n \u2264 s.ncard\n\u22a2 \u2203 t \u2286 s, t.ncard = n"}, {"line": "simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enumerateCountable_mem {s : Set \u03b1} (h : s.Countable) {default : \u03b1} (h_mem : default \u2208 s)\n    (n : \u2115) :\n    enumerateCountable h default n \u2208 s := by\n  convert mem_range_self n\n  exact (range_enumerateCountable_of_mem h h_mem).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nh : s.Countable\ndefault : \u03b1\nh_mem : default \u2208 s\nn : \u2115\n\u22a2 enumerateCountable h default n \u2208 s"}, {"line": "convert mem_range_self n", "tactic_state": "case h.e'_4\n\u03b1 : Type u\ns : Set \u03b1\nh : s.Countable\ndefault : \u03b1\nh_mem : default \u2208 s\nn : \u2115\n\u22a2 s = range (enumerateCountable h default)"}, {"line": "exact (range_enumerateCountable_of_mem h h_mem).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_countable_univ_iff : \u00ac (univ : Set \u03b1).Countable \u2194 Uncountable \u03b1 := by\n  rw [countable_univ_iff]\n  rw [not_countable_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u22a2 \u00acuniv.Countable \u2194 Uncountable \u03b1"}, {"line": "rw [countable_univ_iff]", "tactic_state": "\u03b1 : Type u\n\u22a2 \u00acCountable \u03b1 \u2194 Uncountable \u03b1"}, {"line": "rw [not_countable_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Countable.exists_eq_range {s : Set \u03b1} (hc : s.Countable) (hs : s.Nonempty) :\n    \u2203 f : \u2115 \u2192 \u03b1, s = range f := by\n  rcases hc.exists_surjective hs with \u27e8f, hf\u27e9\n  refine \u27e8(\u2191) \u2218 f, ?_\u27e9\n  rw [hf.range_comp]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\n\u22a2 \u2203 f, s = range f"}, {"line": "rcases hc.exists_surjective hs with \u27e8f, hf\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 \u2203 f, s = range f"}, {"line": "refine \u27e8(\u2191) \u2218 f, ?_\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range (Subtype.val \u2218 f)"}, {"line": "rw [hf.range_comp]", "tactic_state": "case intro\n\u03b1 : Type u\ns : Set \u03b1\nhc : s.Countable\nhs : s.Nonempty\nf : \u2115 \u2192 \u2191s\nhf : Surjective f\n\u22a2 s = range Subtype.val"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Countable.image {s : Set \u03b1} (hs : s.Countable) (f : \u03b1 \u2192 \u03b2) : (f '' s).Countable := by\n  rw [image_eq_range]\n  have := hs.to_subtype\n  apply countable_range\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\n\u22a2 (f '' s).Countable"}, {"line": "rw [image_eq_range]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\n\u22a2 (range fun x => f \u2191x).Countable"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nhs : s.Countable\nf : \u03b1 \u2192 \u03b2\nthis : Countable \u2191s\n\u22a2 (range fun x => f \u2191x).Countable"}, {"line": "apply countable_range", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Countable.biUnion_iff {s : Set \u03b1} {t : \u2200 a \u2208 s, Set \u03b2} (hs : s.Countable) :\n    (\u22c3 a \u2208 s, t a \u2039_\u203a).Countable \u2194 \u2200 a (ha : a \u2208 s), (t a ha).Countable := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion]\n  rw [countable_iUnion_iff]\n  rw [SetCoe.forall']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nhs : s.Countable\n\u22a2 (\u22c3 a, \u22c3 (h : a \u2208 s), t a h).Countable \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), (t a ha).Countable"}, {"line": "have := hs.to_subtype", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nhs : s.Countable\nthis : Countable \u2191s\n\u22a2 (\u22c3 a, \u22c3 (h : a \u2208 s), t a h).Countable \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), (t a ha).Countable"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nhs : s.Countable\nthis : Countable \u2191s\n\u22a2 (\u22c3 x, t \u2191x \u22ef).Countable \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), (t a ha).Countable"}, {"line": "rw [countable_iUnion_iff]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ns : Set \u03b1\nt : (a : \u03b1) \u2192 a \u2208 s \u2192 Set \u03b2\nhs : s.Countable\nthis : Countable \u2191s\n\u22a2 (\u2200 (i : \u2191s), (t \u2191i \u22ef).Countable) \u2194 \u2200 (a : \u03b1) (ha : a \u2208 s), (t a ha).Countable"}, {"line": "rw [SetCoe.forall']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Countable.sUnion_iff {s : Set (Set \u03b1)} (hs : s.Countable) :\n    (\u22c3\u2080 s).Countable \u2194 \u2200 a \u2208 s, a.Countable := by rw [sUnion_eq_biUnion, hs.biUnion_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set (Set \u03b1)\nhs : s.Countable\n\u22a2 (\u22c3\u2080 s).Countable \u2194 \u2200 a \u2208 s, a.Countable"}, {"line": "rw [sUnion_eq_biUnion, hs.biUnion_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countable_union {s t : Set \u03b1} : (s \u222a t).Countable \u2194 s.Countable \u2227 t.Countable := by\n  simp [union_eq_iUnion, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns t : Set \u03b1\n\u22a2 (s \u222a t).Countable \u2194 s.Countable \u2227 t.Countable"}, {"line": "simp [union_eq_iUnion, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem countable_insert {s : Set \u03b1} {a : \u03b1} : (insert a s).Countable \u2194 s.Countable := by\n  simp only [insert_eq]\n  simp only [countable_union]\n  simp only [countable_singleton]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Data/Set/Countable.lean", "context": {"open": ["Function Set Encodable"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Sort x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 (insert a s).Countable \u2194 s.Countable"}, {"line": "simp only [insert_eq]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 ({a} \u222a s).Countable \u2194 s.Countable"}, {"line": "simp only [countable_union]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 {a}.Countable \u2227 s.Countable \u2194 s.Countable"}, {"line": "simp only [countable_singleton]", "tactic_state": "\u03b1 : Type u\ns : Set \u03b1\na : \u03b1\n\u22a2 True \u2227 s.Countable \u2194 s.Countable"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
