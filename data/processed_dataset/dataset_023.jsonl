{"declaration": "theorem refl_range {a : X} : range (Path.refl a) = {a} := by simp [Path.refl, CoeFun.coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na : X\n\u22a2 range \u21d1(Path.refl a) = {a}"}, {"line": "simp [Path.refl, CoeFun.coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extend_zero : \u03b3.extend 0 = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 \u03b3.extend 0 = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem extend_one : \u03b3.extend 1 = y := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\n\u22a2 \u03b3.extend 1 = y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_coe (\u03b3 : Path x y) {f : X \u2192 Y} (h : Continuous f) :\n    (\u03b3.map h : I \u2192 Y) = f \u2218 \u03b3 := by\n  ext t\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\n\u03b3 : Path x y\nf : X \u2192 Y\nh : Continuous f\n\u22a2 \u21d1(\u03b3.map h) = f \u2218 \u21d1\u03b3"}, {"line": "ext t", "tactic_state": "case h\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\n\u03b3 : Path x y\nf : X \u2192 Y\nh : Continuous f\nt : \u2191unitInterval\n\u22a2 (\u03b3.map h) t = (f \u2218 \u21d1\u03b3) t"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_trans {x y z : X} : Continuous fun \u03c1 : Path x y \u00d7 Path y z => \u03c1.1.trans \u03c1.2 := by\n  fun_prop\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y z : X\n\u22a2 Continuous fun \u03c1 => \u03c1.1.trans \u03c1.2"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem truncate_const_continuous_family {a b : X} (\u03b3 : Path a b)\n    (t : \u211d) : Continuous \u21bf(\u03b3.truncate t) := by\n  have key : Continuous (fun x => (t, x) : \u211d \u00d7 I \u2192 \u211d \u00d7 \u211d \u00d7 I) := by fun_prop\n  exact \u03b3.truncate_continuous_family.comp key\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)", "{a\u2081 a\u2082 a\u2083 : X} {b\u2081 b\u2082 b\u2083 : Y}", "{\u03c7 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c7 i)] {as bs cs : \u2200 i, \u03c7 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\nt : \u211d\n\u22a2 Continuous \u21bf(\u03b3.truncate t)"}, {"line": "have key : Continuous (fun x => (t, x) : \u211d \u00d7 I \u2192 \u211d \u00d7 \u211d \u00d7 I) := by fun_prop", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\nt : \u211d\nkey : sorry\n\u22a2 Continuous \u21bf(\u03b3.truncate t)"}, {"line": "exact \u03b3.truncate_continuous_family.comp key", "tactic_state": "No Goals!"}]}
{"declaration": "theorem truncate_zero_zero {a b : X} (\u03b3 : Path a b) :\n    \u03b3.truncate 0 0 = (Path.refl a).cast (by rw [min_self, \u03b3.extend_zero]) \u03b3.extend_zero := by\n  convert \u03b3.truncate_self 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)", "{a\u2081 a\u2082 a\u2083 : X} {b\u2081 b\u2082 b\u2083 : Y}", "{\u03c7 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c7 i)] {as bs cs : \u2200 i, \u03c7 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\n\u22a2 \u03b3.truncate 0 0 = (Path.refl a).cast \u22ef \u22ef"}, {"line": "convert \u03b3.truncate_self 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem truncate_one_one {a b : X} (\u03b3 : Path a b) :\n    \u03b3.truncate 1 1 = (Path.refl b).cast (by rw [min_self, \u03b3.extend_one]) \u03b3.extend_one := by\n  convert \u03b3.truncate_self 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)", "{a\u2081 a\u2082 a\u2083 : X} {b\u2081 b\u2082 b\u2083 : Y}", "{\u03c7 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c7 i)] {as bs cs : \u2200 i, \u03c7 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\na b : X\n\u03b3 : Path a b\n\u22a2 \u03b3.truncate 1 1 = (Path.refl b).cast \u22ef \u22ef"}, {"line": "convert \u03b3.truncate_self 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_reparam (\u03b3 : Path x y) {f : I \u2192 I} (hfcont : Continuous f) (hf\u2080 : f 0 = 0)\n    (hf\u2081 : f 1 = 1) : range (\u03b3.reparam f hfcont hf\u2080 hf\u2081) = range \u03b3 := by\n  change range (\u03b3 \u2218 f) = range \u03b3\n  have : range f = univ := by\n    rw [range_eq_univ]\n    intro t\n    have h\u2081 : Continuous (Set.IccExtend (zero_le_one' \u211d) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' \u211d) h\u2081.continuousOn\n    \u00b7 rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hf\u2080, hf\u2081] at this\n      rcases this t.2 with \u27e8w, hw\u2081, hw\u2082\u27e9\n      rw [IccExtend_of_mem _ _ hw\u2081] at hw\u2082\n      exact \u27e8_, hw\u2082\u27e9\n  rw [range_comp]\n  rw [this]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Path.lean", "context": {"open": ["Topology Filter unitInterval Set Function", "ContinuousMap"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(\u03b3 : Path x y)", "{a\u2081 a\u2082 a\u2083 : X} {b\u2081 b\u2082 b\u2083 : Y}", "{\u03c7 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c7 i)] {as bs cs : \u2200 i, \u03c7 i}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\nf : \u2191unitInterval \u2192 \u2191unitInterval\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\n\u22a2 range \u21d1(\u03b3.reparam f hfcont hf\u2080 hf\u2081) = range \u21d1\u03b3"}, {"line": "change range (\u03b3 \u2218 f) = range \u03b3", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\nf : \u2191unitInterval \u2192 \u2191unitInterval\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\n\u22a2 range (\u21d1\u03b3 \u2218 f) = range \u21d1\u03b3"}, {"line": "have : range f = univ := by\n    rw [range_eq_univ]\n    intro t\n    have h\u2081 : Continuous (Set.IccExtend (zero_le_one' \u211d) f) := by continuity\n    have := intermediate_value_Icc (zero_le_one' \u211d) h\u2081.continuousOn\n    \u00b7 rw [IccExtend_left, IccExtend_right, Icc.mk_zero, Icc.mk_one, hf\u2080, hf\u2081] at this\n      rcases this t.2 with \u27e8w, hw\u2081, hw\u2082\u27e9\n      rw [IccExtend_of_mem _ _ hw\u2081] at hw\u2082\n      exact \u27e8_, hw\u2082\u27e9", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\nf : \u2191unitInterval \u2192 \u2191unitInterval\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\nthis : range f = univ\n\u22a2 range (\u21d1\u03b3 \u2218 f) = range \u21d1\u03b3"}, {"line": "rw [range_comp]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\nf : \u2191unitInterval \u2192 \u2191unitInterval\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\nthis : range f = univ\n\u22a2 \u21d1\u03b3 '' range f = range \u21d1\u03b3"}, {"line": "rw [this]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u03b3 : Path x y\nf : \u2191unitInterval \u2192 \u2191unitInterval\nhfcont : Continuous f\nhf\u2080 : f 0 = 0\nhf\u2081 : f 1 = 1\nthis : range f = univ\n\u22a2 \u21d1\u03b3 '' univ = range \u21d1\u03b3"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preperfect_iff_nhds : Preperfect C \u2194 \u2200 x \u2208 C, \u2200 U \u2208 \ud835\udcdd x, \u2203 y \u2208 U \u2229 C, y \u2260 x := by\n  simp only [Preperfect]\n  simp only [accPt_iff_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Perfect.lean", "context": {"open": ["Topology Filter Set TopologicalSpace"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {C : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC : Set \u03b1\n\u22a2 Preperfect C \u2194 \u2200 x \u2208 C, \u2200 U \u2208 nhds x, \u2203 y \u2208 U \u2229 C, y \u2260 x"}, {"line": "simp only [Preperfect]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nC : Set \u03b1\n\u22a2 (\u2200 x \u2208 C, AccPt x (principal C)) \u2194 \u2200 x \u2208 C, \u2200 U \u2208 nhds x, \u2203 y \u2208 U \u2229 C, y \u2260 x"}, {"line": "simp only [accPt_iff_nhds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem perfectSpace_iff_forall_not_isolated : PerfectSpace X \u2194 \u2200 x : X, Filter.NeBot (\ud835\udcdd[\u2260] x) := by\n  simp [perfectSpace_def, Preperfect, AccPt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Perfect.lean", "context": {"open": ["Topology Filter Set TopologicalSpace"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {C : Set \u03b1}", "(\u03b1)", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\n\u22a2 PerfectSpace X \u2194 \u2200 (x : X), (nhdsWithin x {x}\u1d9c).NeBot"}, {"line": "simp [perfectSpace_def, Preperfect, AccPt]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exists_tsupport_one_of_isOpen_isClosed [T2Space X] {s t : Set X}\n    (hs : IsOpen s) (hscp : IsCompact (closure s)) (ht : IsClosed t) (hst : t \u2286 s) :\n    \u2203 f : C(X, \u211d), tsupport f \u2286 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1 := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/UrysohnsLemma.lean", "context": {"open": ["Set Filter TopologicalSpace Topology Filter", "scoped Pointwise"], "variables": ["{X : Type*} [TopologicalSpace X]", "{P : Set X \u2192 Set X \u2192 Prop}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\ns t : Set X\nhs : IsOpen s\nhscp : IsCompact (closure s)\nht : IsClosed t\nhst : t \u2286 s\n\u22a2 \u2203 f, tsupport \u21d1f \u2286 s \u2227 EqOn (\u21d1f) 1 t \u2227 \u2200 (x : X), f x \u2208 Icc 0 1"}]}
{"declaration": "theorem isQuasiSeparated_univ_iff {\u03b1 : Type*} [TopologicalSpace \u03b1] :\n    IsQuasiSeparated (Set.univ : Set \u03b1) \u2194 QuasiSeparatedSpace \u03b1 := by\n  rw [quasiSeparatedSpace_iff]\n  simp [IsQuasiSeparated]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/QuasiSeparated.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsQuasiSeparated univ \u2194 QuasiSeparatedSpace \u03b1"}, {"line": "rw [quasiSeparatedSpace_iff]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsQuasiSeparated univ \u2194 \u2200 (U V : Set \u03b1), IsOpen U \u2192 IsCompact U \u2192 IsOpen V \u2192 IsCompact V \u2192 IsCompact (U \u2229 V)"}, {"line": "simp [IsQuasiSeparated]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isQuasiSeparated_iff_quasiSeparatedSpace (s : Set \u03b1) (hs : IsOpen s) :\n    IsQuasiSeparated s \u2194 QuasiSeparatedSpace s := by\n  rw [\u2190 isQuasiSeparated_univ_iff]\n  convert (hs.isOpenEmbedding_subtypeVal.isQuasiSeparated_iff (s := Set.univ)).symm\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/QuasiSeparated.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nhs : IsOpen s\n\u22a2 IsQuasiSeparated s \u2194 QuasiSeparatedSpace \u2191s"}, {"line": "rw [\u2190 isQuasiSeparated_univ_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nhs : IsOpen s\n\u22a2 IsQuasiSeparated s \u2194 IsQuasiSeparated univ"}, {"line": "convert (hs.isOpenEmbedding_subtypeVal.isQuasiSeparated_iff (s := Set.univ)).symm", "tactic_state": "case h.e'_1.h.e'_3\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nhs : IsOpen s\n\u22a2 s = Subtype.val '' univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsQuasiSeparated.of_subset {s t : Set \u03b1} (ht : IsQuasiSeparated t) (h : s \u2286 t) :\n    IsQuasiSeparated s := by\n  intro U V hU hU' hU'' hV hV' hV''\n  exact ht U V (hU.trans h) hU' hU'' (hV.trans h) hV' hV''\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/QuasiSeparated.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nht : IsQuasiSeparated t\nh : s \u2286 t\n\u22a2 IsQuasiSeparated s"}, {"line": "intro U V hU hU' hU'' hV hV' hV''", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nht : IsQuasiSeparated t\nh : s \u2286 t\nU V : Set \u03b1\nhU : U \u2286 s\nhU' : IsOpen U\nhU'' : IsCompact U\nhV : V \u2286 s\nhV' : IsOpen V\nhV'' : IsCompact V\n\u22a2 IsCompact (U \u2229 V)"}, {"line": "exact ht U V (hU.trans h) hU' hU'' (hV.trans h) hV' hV''", "tactic_state": "No Goals!"}]}
{"declaration": "lemma QuasiSeparatedSpace.of_isTopologicalBasis {\u03b9 : Type*} {b : \u03b9 \u2192 Set \u03b1}\n    (basis : IsTopologicalBasis (range b)) (isCompact_inter : \u2200 i j, IsCompact (b i \u2229 b j)) :\n    QuasiSeparatedSpace \u03b1 where\n  inter_isCompact U V hUopen hUcomp hVopen hVcomp := by\n    have aux := isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis b basis fun i \u21a6 by\n      simpa using isCompact_inter i i\n    obtain \u27e8s, hs, rfl\u27e9 := (aux _).1 \u27e8hUcomp, hUopen\u27e9\n    obtain \u27e8t, ht, rfl\u27e9 := (aux _).1 \u27e8hVcomp, hVopen\u27e9\n    rw [iUnion\u2082_inter_iUnion\u2082]\n    exact hs.isCompact_biUnion fun i hi \u21a6 ht.isCompact_biUnion fun j hj \u21a6 isCompact_inter ..\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/QuasiSeparated.lean", "context": {"open": ["Set TopologicalSpace Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b9 \u2192 Set \u03b1\nbasis : IsTopologicalBasis (range b)\nisCompact_inter : \u2200 (i j : \u03b9), IsCompact (b i \u2229 b j)\nU V : Set \u03b1\nhUopen : IsOpen U\nhUcomp : IsCompact U\nhVopen : IsOpen V\nhVcomp : IsCompact V\n\u22a2 IsCompact (U \u2229 V)"}, {"line": "have aux := isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis b basis fun i \u21a6 by\n      simpa using isCompact_inter i i", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b9 \u2192 Set \u03b1\nbasis : IsTopologicalBasis (range b)\nisCompact_inter : \u2200 (i j : \u03b9), IsCompact (b i \u2229 b j)\nU V : Set \u03b1\nhUopen : IsOpen U\nhUcomp : IsCompact U\nhVopen : IsOpen V\nhVcomp : IsCompact V\naux : \u2200 (U : Set \u03b1), IsCompact U \u2227 IsOpen U \u2194 \u2203 s, s.Finite \u2227 U = \u22c3 i \u2208 s, b i\n\u22a2 IsCompact (U \u2229 V)"}, {"line": "obtain \u27e8s, hs, rfl\u27e9 := (aux _).1 \u27e8hUcomp, hUopen\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b9 \u2192 Set \u03b1\nbasis : IsTopologicalBasis (range b)\nisCompact_inter : \u2200 (i j : \u03b9), IsCompact (b i \u2229 b j)\nV : Set \u03b1\nhVopen : IsOpen V\nhVcomp : IsCompact V\naux : \u2200 (U : Set \u03b1), IsCompact U \u2227 IsOpen U \u2194 \u2203 s, s.Finite \u2227 U = \u22c3 i \u2208 s, b i\ns : Set \u03b9\nhs : s.Finite\nhUopen : IsOpen (\u22c3 i \u2208 s, b i)\nhUcomp : IsCompact (\u22c3 i \u2208 s, b i)\n\u22a2 IsCompact ((\u22c3 i \u2208 s, b i) \u2229 V)"}, {"line": "obtain \u27e8t, ht, rfl\u27e9 := (aux _).1 \u27e8hVcomp, hVopen\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b9 \u2192 Set \u03b1\nbasis : IsTopologicalBasis (range b)\nisCompact_inter : \u2200 (i j : \u03b9), IsCompact (b i \u2229 b j)\naux : \u2200 (U : Set \u03b1), IsCompact U \u2227 IsOpen U \u2194 \u2203 s, s.Finite \u2227 U = \u22c3 i \u2208 s, b i\ns : Set \u03b9\nhs : s.Finite\nhUopen : IsOpen (\u22c3 i \u2208 s, b i)\nhUcomp : IsCompact (\u22c3 i \u2208 s, b i)\nt : Set \u03b9\nht : t.Finite\nhVopen : IsOpen (\u22c3 i \u2208 t, b i)\nhVcomp : IsCompact (\u22c3 i \u2208 t, b i)\n\u22a2 IsCompact ((\u22c3 i \u2208 s, b i) \u2229 \u22c3 i \u2208 t, b i)"}, {"line": "rw [iUnion\u2082_inter_iUnion\u2082]", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b9 \u2192 Set \u03b1\nbasis : IsTopologicalBasis (range b)\nisCompact_inter : \u2200 (i j : \u03b9), IsCompact (b i \u2229 b j)\naux : \u2200 (U : Set \u03b1), IsCompact U \u2227 IsOpen U \u2194 \u2203 s, s.Finite \u2227 U = \u22c3 i \u2208 s, b i\ns : Set \u03b9\nhs : s.Finite\nhUopen : IsOpen (\u22c3 i \u2208 s, b i)\nhUcomp : IsCompact (\u22c3 i \u2208 s, b i)\nt : Set \u03b9\nht : t.Finite\nhVopen : IsOpen (\u22c3 i \u2208 t, b i)\nhVcomp : IsCompact (\u22c3 i \u2208 t, b i)\n\u22a2 IsCompact (\u22c3 i\u2081 \u2208 s, \u22c3 j\u2081 \u2208 t, b i\u2081 \u2229 b j\u2081)"}, {"line": "exact hs.isCompact_biUnion fun i hi \u21a6 ht.isCompact_biUnion fun j hj \u21a6 isCompact_inter ..", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Continuous.mapPullback {X\u2081 X\u2082 Y\u2081 Y\u2082 Z\u2081 Z\u2082}\n    [TopologicalSpace X\u2081] [TopologicalSpace X\u2082] [TopologicalSpace Z\u2081] [TopologicalSpace Z\u2082]\n    {f\u2081 : X\u2081 \u2192 Y\u2081} {g\u2081 : Z\u2081 \u2192 Y\u2081} {f\u2082 : X\u2082 \u2192 Y\u2082} {g\u2082 : Z\u2082 \u2192 Y\u2082}\n    {mapX : X\u2081 \u2192 X\u2082} (contX : Continuous mapX) {mapY : Y\u2081 \u2192 Y\u2082}\n    {mapZ : Z\u2081 \u2192 Z\u2082} (contZ : Continuous mapZ)\n    {commX : f\u2082 \u2218 mapX = mapY \u2218 f\u2081} {commZ : g\u2082 \u2218 mapZ = mapY \u2218 g\u2081} :\n    Continuous (Function.mapPullback mapX mapY mapZ commX commZ) := by\n  refine continuous_induced_rng.mpr (.prodMk ?_ ?_) <;>\n    apply_rules [continuous_fst, continuous_snd, continuous_subtype_val, Continuous.comp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/SeparatedMap.lean", "context": {"open": ["Topology"], "variables": ["{X Y A} [TopologicalSpace X] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X\u2081 : Type u_1\nX\u2082 : Type u_2\nY\u2081 : Sort u_3\nY\u2082 : Sort u_4\nZ\u2081 : Type u_5\nZ\u2082 : Type u_6\ninst\u271d\u00b3 : TopologicalSpace X\u2081\ninst\u271d\u00b2 : TopologicalSpace X\u2082\ninst\u271d\u00b9 : TopologicalSpace Z\u2081\ninst\u271d : TopologicalSpace Z\u2082\nf\u2081 : X\u2081 \u2192 Y\u2081\ng\u2081 : Z\u2081 \u2192 Y\u2081\nf\u2082 : X\u2082 \u2192 Y\u2082\ng\u2082 : Z\u2082 \u2192 Y\u2082\nmapX : X\u2081 \u2192 X\u2082\ncontX : Continuous mapX\nmapY : Y\u2081 \u2192 Y\u2082\nmapZ : Z\u2081 \u2192 Z\u2082\ncontZ : Continuous mapZ\ncommX : f\u2082 \u2218 mapX = mapY \u2218 f\u2081\ncommZ : g\u2082 \u2218 mapZ = mapY \u2218 g\u2081\n\u22a2 Continuous (Function.mapPullback mapX mapY mapZ commX commZ)"}, {"line": "refine continuous_induced_rng.mpr (.prodMk ?_ ?_) <;>\n    apply_rules [continuous_fst, continuous_snd, continuous_subtype_val, Continuous.comp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSeparatedMap_iff_nhds {f : X \u2192 Y} : IsSeparatedMap f \u2194\n    \u2200 x\u2081 x\u2082, f x\u2081 = f x\u2082 \u2192 x\u2081 \u2260 x\u2082 \u2192 \u2203 s\u2081 \u2208 \ud835\udcdd x\u2081, \u2203 s\u2082 \u2208 \ud835\udcdd x\u2082, Disjoint s\u2081 s\u2082 := by\n  simp_rw [isSeparatedMap_iff_disjoint_nhds, Filter.disjoint_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/SeparatedMap.lean", "context": {"open": ["Topology"], "variables": ["{X Y A} [TopologicalSpace X] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Sort u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\n\u22a2 IsSeparatedMap f \u2194 \u2200 (x\u2081 x\u2082 : X), f x\u2081 = f x\u2082 \u2192 x\u2081 \u2260 x\u2082 \u2192 \u2203 s\u2081 \u2208 nhds x\u2081, \u2203 s\u2082 \u2208 nhds x\u2082, Disjoint s\u2081 s\u2082"}, {"line": "simp_rw [isSeparatedMap_iff_disjoint_nhds, Filter.disjoint_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eqOn_of_comp_eqOn (hs : IsPreconnected s) (h\u2081 : ContinuousOn g\u2081 s) (h\u2082 : ContinuousOn g\u2082 s)\n    (he : s.EqOn (p \u2218 g\u2081) (p \u2218 g\u2082)) {a : A} (has : a \u2208 s) (ha : g\u2081 a = g\u2082 a) : s.EqOn g\u2081 g\u2082 := by\n  rw [\u2190 Set.restrict_eq_restrict_iff] at he \u22a2\n  rw [continuousOn_iff_continuous_restrict] at h\u2081 h\u2082\n  rw [isPreconnected_iff_preconnectedSpace] at hs\n  exact sep.eq_of_comp_eq inj h\u2081 h\u2082 he \u27e8a, has\u27e9 ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/SeparatedMap.lean", "context": {"open": ["Topology", "Set Filter in", "Function.Pullback in"], "variables": ["{X Y A} [TopologicalSpace X] [TopologicalSpace A]", "{f : X \u2192 Y} {g\u2081 g\u2082 : A \u2192 X} (h\u2081 : Continuous g\u2081) (h\u2082 : Continuous g\u2082)", "{X E A : Type*} [TopologicalSpace E] [TopologicalSpace A] {p : E \u2192 X}", "{s : Set A} {g g\u2081 g\u2082 : A \u2192 E} (sep : IsSeparatedMap p) (inj : IsLocallyInjective p)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nE : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace A\np : E \u2192 X\ns : Set A\ng\u2081 g\u2082 : A \u2192 E\nhs : IsPreconnected s\nh\u2081 : ContinuousOn g\u2081 s\nh\u2082 : ContinuousOn g\u2082 s\nhe : Set.EqOn (p \u2218 g\u2081) (p \u2218 g\u2082) s\na : A\nhas : a \u2208 s\nha : g\u2081 a = g\u2082 a\n\u22a2 Set.EqOn g\u2081 g\u2082 s"}, {"line": "rw [\u2190 Set.restrict_eq_restrict_iff] at he \u22a2", "tactic_state": "X : Type u_1\nE : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace A\np : E \u2192 X\ns : Set A\ng\u2081 g\u2082 : A \u2192 E\nhs : IsPreconnected s\nh\u2081 : ContinuousOn g\u2081 s\nh\u2082 : ContinuousOn g\u2082 s\nhe : s.restrict (p \u2218 g\u2081) = s.restrict (p \u2218 g\u2082)\na : A\nhas : a \u2208 s\nha : g\u2081 a = g\u2082 a\n\u22a2 s.restrict g\u2081 = s.restrict g\u2082"}, {"line": "rw [continuousOn_iff_continuous_restrict] at h\u2081 h\u2082", "tactic_state": "X : Type u_1\nE : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace A\np : E \u2192 X\ns : Set A\ng\u2081 g\u2082 : A \u2192 E\nhs : IsPreconnected s\nh\u2081 : Continuous (s.restrict g\u2081)\nh\u2082 : Continuous (s.restrict g\u2082)\nhe : s.restrict (p \u2218 g\u2081) = s.restrict (p \u2218 g\u2082)\na : A\nhas : a \u2208 s\nha : g\u2081 a = g\u2082 a\n\u22a2 s.restrict g\u2081 = s.restrict g\u2082"}, {"line": "rw [isPreconnected_iff_preconnectedSpace] at hs", "tactic_state": "X : Type u_1\nE : Type u_2\nA : Type u_3\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : TopologicalSpace A\np : E \u2192 X\ns : Set A\ng\u2081 g\u2082 : A \u2192 E\nhs : PreconnectedSpace \u2191s\nh\u2081 : Continuous (s.restrict g\u2081)\nh\u2082 : Continuous (s.restrict g\u2082)\nhe : s.restrict (p \u2218 g\u2081) = s.restrict (p \u2218 g\u2082)\na : A\nhas : a \u2208 s\nha : g\u2081 a = g\u2082 a\n\u22a2 s.restrict g\u2081 = s.restrict g\u2082"}, {"line": "exact sep.eq_of_comp_eq inj h\u2081 h\u2082 he \u27e8a, has\u27e9 ha", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closure_iff_seq_limit [FrechetUrysohnSpace X] {s : Set X} {a : X} :\n    a \u2208 closure s \u2194 \u2203 x : \u2115 \u2192 X, (\u2200 n : \u2115, x n \u2208 s) \u2227 Tendsto x atTop (\ud835\udcdd a) := by\n  rw [\u2190 seqClosure_eq_closure]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sequences.lean", "context": {"open": ["Bornology Filter Function Set TopologicalSpace Topology", "scoped Uniformity"], "variables": ["{X Y : Type*}", "[TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : FrechetUrysohnSpace X\ns : Set X\na : X\n\u22a2 a \u2208 closure s \u2194 \u2203 x, (\u2200 (n : \u2115), x n \u2208 s) \u2227 Tendsto x atTop (nhds a)"}, {"line": "rw [\u2190 seqClosure_eq_closure]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : FrechetUrysohnSpace X\ns : Set X\na : X\n\u22a2 a \u2208 seqClosure s \u2194 \u2203 x, (\u2200 (n : \u2115), x n \u2208 s) \u2227 Tendsto x atTop (nhds a)\n---\nX : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : FrechetUrysohnSpace X\ns : Set X\na : X\n\u22a2 FrechetUrysohnSpace X"}, {"line": "rfl", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : FrechetUrysohnSpace X\ns : Set X\na : X\n\u22a2 FrechetUrysohnSpace X"}]}
{"declaration": "protected theorem SequentialSpace.iSup {X} {\u03b9 : Sort*} {t : \u03b9 \u2192 TopologicalSpace X}\n    (h : \u2200 i, @SequentialSpace X (t i)) : @SequentialSpace X (\u2a06 i, t i) := by\n  letI : TopologicalSpace X := \u2a06 i, t i\n  refine \u27e8fun s hs \u21a6 isClosed_iSup_iff.2 fun i \u21a6 ?_\u27e9\n  letI := t i\n  exact IsSeqClosed.isClosed fun u x hus hux \u21a6 hs hus <| hux.mono_right <| nhds_mono <| le_iSup _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sequences.lean", "context": {"open": ["Bornology Filter Function Set TopologicalSpace Topology", "scoped Uniformity"], "variables": ["{X Y : Type*}", "[TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_4\n\u03b9 : Sort u_3\nt : \u03b9 \u2192 TopologicalSpace X\nh : \u2200 (i : \u03b9), SequentialSpace X\n\u22a2 SequentialSpace X"}, {"line": "letI : TopologicalSpace X := \u2a06 i, t i", "tactic_state": "X : Type u_4\n\u03b9 : Sort u_3\nt : \u03b9 \u2192 TopologicalSpace X\nh : \u2200 (i : \u03b9), SequentialSpace X\nthis : TopologicalSpace X := \u2a06 i, t i\n\u22a2 SequentialSpace X"}, {"line": "refine \u27e8fun s hs \u21a6 isClosed_iSup_iff.2 fun i \u21a6 ?_\u27e9", "tactic_state": "X : Type u_4\n\u03b9 : Sort u_3\nt : \u03b9 \u2192 TopologicalSpace X\nh : \u2200 (i : \u03b9), SequentialSpace X\nthis : TopologicalSpace X := \u2a06 i, t i\ns : Set X\nhs : IsSeqClosed s\ni : \u03b9\n\u22a2 IsClosed s"}, {"line": "letI := t i", "tactic_state": "X : Type u_4\n\u03b9 : Sort u_3\nt : \u03b9 \u2192 TopologicalSpace X\nh : \u2200 (i : \u03b9), SequentialSpace X\nthis\u271d : TopologicalSpace X := \u2a06 i, t i\ns : Set X\nhs : IsSeqClosed s\ni : \u03b9\nthis : TopologicalSpace X := t i\n\u22a2 IsClosed s"}, {"line": "exact IsSeqClosed.isClosed fun u x hus hux \u21a6 hs hus <| hux.mono_right <| nhds_mono <| le_iSup _ _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem SequentialSpace.sup {X} {t\u2081 t\u2082 : TopologicalSpace X}\n    (h\u2081 : @SequentialSpace X t\u2081) (h\u2082 : @SequentialSpace X t\u2082) :\n    @SequentialSpace X (t\u2081 \u2294 t\u2082) := by\n  rw [sup_eq_iSup]\n  exact .iSup <| Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sequences.lean", "context": {"open": ["Bornology Filter Function Set TopologicalSpace Topology", "scoped Uniformity"], "variables": ["{X Y : Type*}", "[TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : SequentialSpace X\nh\u2082 : SequentialSpace X\n\u22a2 SequentialSpace X"}, {"line": "rw [sup_eq_iSup]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : SequentialSpace X\nh\u2082 : SequentialSpace X\n\u22a2 SequentialSpace X"}, {"line": "exact .iSup <| Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSeqCompact.image (f_cont : SeqContinuous f) {K : Set X} (K_cpt : IsSeqCompact K) :\n    IsSeqCompact (f '' K) := by\n  intro ys ys_in_fK\n  choose xs xs_in_K fxs_eq_ys using ys_in_fK\n  obtain \u27e8a, a_in_K, phi, phi_mono, xs_phi_lim\u27e9 := K_cpt xs_in_K\n  refine \u27e8f a, mem_image_of_mem f a_in_K, phi, phi_mono, ?_\u27e9\n  exact (f_cont xs_phi_lim).congr fun x \u21a6 fxs_eq_ys (phi x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sequences.lean", "context": {"open": ["Bornology Filter Function Set TopologicalSpace Topology", "scoped Uniformity", "TopologicalSpace FirstCountableTopology", "FirstCountableTopology"], "variables": ["{X Y : Type*}", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X]", "[FirstCountableTopology X]", "[TopologicalSpace Y] {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : FirstCountableTopology X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\n\u22a2 IsSeqCompact (f '' K)"}, {"line": "intro ys ys_in_fK", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : FirstCountableTopology X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\nys : \u2115 \u2192 Y\nys_in_fK : \u2200 (n : \u2115), ys n \u2208 f '' K\n\u22a2 \u2203 a \u2208 f '' K, \u2203 \u03c6, StrictMono \u03c6 \u2227 Tendsto (ys \u2218 \u03c6) atTop (nhds a)"}, {"line": "choose xs xs_in_K fxs_eq_ys using ys_in_fK", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : FirstCountableTopology X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\nys : \u2115 \u2192 Y\nxs : \u2115 \u2192 X\nxs_in_K : \u2200 (n : \u2115), xs n \u2208 K\nfxs_eq_ys : \u2200 (n : \u2115), f (xs n) = ys n\n\u22a2 \u2203 a \u2208 f '' K, \u2203 \u03c6, StrictMono \u03c6 \u2227 Tendsto (ys \u2218 \u03c6) atTop (nhds a)"}, {"line": "obtain \u27e8a, a_in_K, phi, phi_mono, xs_phi_lim\u27e9 := K_cpt xs_in_K", "tactic_state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : FirstCountableTopology X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\nys : \u2115 \u2192 Y\nxs : \u2115 \u2192 X\nxs_in_K : \u2200 (n : \u2115), xs n \u2208 K\nfxs_eq_ys : \u2200 (n : \u2115), f (xs n) = ys n\na : X\na_in_K : a \u2208 K\nphi : \u2115 \u2192 \u2115\nphi_mono : StrictMono phi\nxs_phi_lim : Tendsto (xs \u2218 phi) atTop (nhds a)\n\u22a2 \u2203 a \u2208 f '' K, \u2203 \u03c6, StrictMono \u03c6 \u2227 Tendsto (ys \u2218 \u03c6) atTop (nhds a)"}, {"line": "refine \u27e8f a, mem_image_of_mem f a_in_K, phi, phi_mono, ?_\u27e9", "tactic_state": "case intro.intro.intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u2074 : TopologicalSpace X\ninst\u271d\u00b3 : TopologicalSpace Y\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : FirstCountableTopology X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nf_cont : SeqContinuous f\nK : Set X\nK_cpt : IsSeqCompact K\nys : \u2115 \u2192 Y\nxs : \u2115 \u2192 X\nxs_in_K : \u2200 (n : \u2115), xs n \u2208 K\nfxs_eq_ys : \u2200 (n : \u2115), f (xs n) = ys n\na : X\na_in_K : a \u2208 K\nphi : \u2115 \u2192 \u2115\nphi_mono : StrictMono phi\nxs_phi_lim : Tendsto (xs \u2218 phi) atTop (nhds a)\n\u22a2 Tendsto (ys \u2218 phi) atTop (nhds (f a))"}, {"line": "exact (f_cont xs_phi_lim).congr fun x \u21a6 fxs_eq_ys (phi x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSeqCompact.range [SeqCompactSpace X] (f_cont : SeqContinuous f) :\n    IsSeqCompact (Set.range f) := by\n  simpa using isSeqCompact_univ.image f_cont\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sequences.lean", "context": {"open": ["Bornology Filter Function Set TopologicalSpace Topology", "scoped Uniformity", "TopologicalSpace FirstCountableTopology", "FirstCountableTopology"], "variables": ["{X Y : Type*}", "[TopologicalSpace X] [TopologicalSpace Y]", "[TopologicalSpace X]", "[FirstCountableTopology X]", "[TopologicalSpace Y] {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : FirstCountableTopology X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : SeqCompactSpace X\nf_cont : SeqContinuous f\n\u22a2 IsSeqCompact (Set.range f)"}, {"line": "simpa using isSeqCompact_univ.image f_cont", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isGenericPoint_iff_specializes : IsGenericPoint x S \u2194 \u2200 y, x \u2933 y \u2194 y \u2208 S := by\n  simp only [specializes_iff_mem_closure]\n  simp only [IsGenericPoint]\n  simp only [Set.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sober.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{x y : \u03b1} {S U Z : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\nS : Set \u03b1\n\u22a2 IsGenericPoint x S \u2194 \u2200 (y : \u03b1), x \u2933 y \u2194 y \u2208 S"}, {"line": "simp only [specializes_iff_mem_closure]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\nS : Set \u03b1\n\u22a2 IsGenericPoint x S \u2194 \u2200 (y : \u03b1), y \u2208 closure {x} \u2194 y \u2208 S"}, {"line": "simp only [IsGenericPoint]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\nS : Set \u03b1\n\u22a2 closure {x} = S \u2194 \u2200 (y : \u03b1), y \u2208 closure {x} \u2194 y \u2208 S"}, {"line": "simp only [Set.ext_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem genericPoint_spec [QuasiSober \u03b1] [IrreducibleSpace \u03b1] :\n    IsGenericPoint (genericPoint \u03b1) univ := by\n  simpa using (IrreducibleSpace.isIrreducible_univ \u03b1).isGenericPoint_genericPoint_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sober.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{x y : \u03b1} {S U Z : Set \u03b1}", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : QuasiSober \u03b1\ninst\u271d : IrreducibleSpace \u03b1\n\u22a2 IsGenericPoint (genericPoint \u03b1) univ"}, {"line": "simpa using (IrreducibleSpace.isIrreducible_univ \u03b1).isGenericPoint_genericPoint_closure", "tactic_state": "No Goals!"}]}
{"declaration": "lemma genericPoints_eq_singleton [QuasiSober \u03b1] [IrreducibleSpace \u03b1] [T0Space \u03b1] :\n    genericPoints \u03b1 = {genericPoint \u03b1} := by\n  ext x\n  rw [genericPoints]\n  rw [irreducibleComponents_eq_singleton]\n  exact \u27e8((genericPoint_spec \u03b1).eq \u00b7 |>.symm), (\u00b7 \u25b8 genericPoint_spec \u03b1)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Sober.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{x y : \u03b1} {S U Z : Set \u03b1}", "(\u03b1)", "{\u03b1}", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\n\u22a2 genericPoints \u03b1 = {genericPoint \u03b1}"}, {"line": "ext x", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\nx : \u03b1\n\u22a2 x \u2208 genericPoints \u03b1 \u2194 x \u2208 {genericPoint \u03b1}"}, {"line": "rw [genericPoints]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | closure {x} \u2208 irreducibleComponents \u03b1} \u2194 x \u2208 {genericPoint \u03b1}"}, {"line": "rw [irreducibleComponents_eq_singleton]", "tactic_state": "case h\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\nx : \u03b1\n\u22a2 x \u2208 {x | closure {x} \u2208 {univ}} \u2194 x \u2208 {genericPoint \u03b1}\n---\n\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\nx : \u03b1\n\u22a2 IrreducibleSpace \u03b1"}, {"line": "exact \u27e8((genericPoint_spec \u03b1).eq \u00b7 |>.symm), (\u00b7 \u25b8 genericPoint_spec \u03b1)\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : QuasiSober \u03b1\ninst\u271d\u00b9 : IrreducibleSpace \u03b1\ninst\u271d : T0Space \u03b1\nx : \u03b1\n\u22a2 IrreducibleSpace \u03b1"}]}
{"declaration": "theorem IsTopologicalBasis.isOpen_iff {s : Set \u03b1} {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) :\n    IsOpen s \u2194 \u2200 a \u2208 s, \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s := by simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : TopologicalSpace \u03b1\nx\u271d : Sort u_2\nIsTopologicalBasis : x\u271d\ns : Set \u03b1\nb : Set (Set \u03b1)\nhb : sorry\n\u22a2 IsOpen s \u2194 \u2200 a \u2208 s, \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s"}, {"line": "simp [isOpen_iff_mem_nhds, hb.mem_nhds_iff]", "tactic_state": "\u03b1 : Type u\nt : TopologicalSpace \u03b1\nx\u271d : Sort u_2\nIsTopologicalBasis : x\u271d\ns : Set \u03b1\nb : Set (Set \u03b1)\nhb : sorry\n\u22a2 (\u2200 x \u2208 s, s \u2208 nhds x) \u2194 \u2200 a \u2208 s, \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s"}]}
{"declaration": "theorem IsTopologicalBasis.inf_induced {\u03b3} [s : TopologicalSpace \u03b2] {B\u2081 : Set (Set \u03b1)}\n    {B\u2082 : Set (Set \u03b2)} (h\u2081 : IsTopologicalBasis B\u2081) (h\u2082 : IsTopologicalBasis B\u2082) (f\u2081 : \u03b3 \u2192 \u03b1)\n    (f\u2082 : \u03b3 \u2192 \u03b2) :\n    IsTopologicalBasis (t := induced f\u2081 t \u2293 induced f\u2082 s) (image2 (f\u2081 \u207b\u00b9' \u00b7 \u2229 f\u2082 \u207b\u00b9' \u00b7) B\u2081 B\u2082) := by\n  simpa only [image2_image_left,image2_image_right] using (h\u2081.induced f\u2081).inf (h\u2082.induced f\u2082)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type u_1\nt : TopologicalSpace \u03b1\nx\u271d : Sort u_2\nIsTopologicalBasis : x\u271d\n\u03b3 : Sort u_3\ns : TopologicalSpace \u03b2\nB\u2081 : Set (Set \u03b1)\nB\u2082 : Set (Set \u03b2)\nh\u2081 : sorry\nh\u2082 : sorry\nf\u2081 : \u03b3 \u2192 \u03b1\nf\u2082 : \u03b3 \u2192 \u03b2\n\u22a2 sorry"}, {"line": "simpa only [image2_image_left,image2_image_right] using (h\u2081.induced f\u2081).inf (h\u2082.induced f\u2082)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isSeparable_union {s t : Set \u03b1} : IsSeparable (s \u222a t) \u2194 IsSeparable s \u2227 IsSeparable t := by\n  simp [union_eq_iUnion, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\n\u22a2 sorry \u2194 sorry \u2227 sorry"}, {"line": "simp [union_eq_iUnion, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSeparable_pi {\u03b9 : Type*} [Countable \u03b9] {\u03b1 : \u03b9 \u2192 Type*} {s : \u2200 i, Set (\u03b1 i)}\n    [\u2200 i, TopologicalSpace (\u03b1 i)] (h : \u2200 i, IsSeparable (s i)) :\n    IsSeparable {f : \u2200 i, \u03b1 i | \u2200 i, f i \u2208 s i} := by\n  simpa only [\u2190 mem_univ_pi] using IsSeparable.univ_pi h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Countable \u03b9\n\u03b1 : \u03b9 \u2192 Type u_3\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03b1 i)\nh : \u03b9 \u2192 sorry\n\u22a2 sorry"}, {"line": "simpa only [\u2190 mem_univ_pi] using IsSeparable.univ_pi h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTopologicalBasis.iInf_induced {\u03b2 : Type*} {\u03b9 : Type*} {X : \u03b9 \u2192 Type*}\n    [t : \u03a0 i, TopologicalSpace (X i)] {T : \u03a0 i, Set (Set (X i))}\n    (cond : \u2200 i, IsTopologicalBasis (T i)) (f : \u03a0 i, \u03b2 \u2192 X i) :\n    IsTopologicalBasis (t := \u2a05 i, induced (f i) (t i))\n      { S | \u2203 (U : \u2200 i, Set (X i)) (F : Finset \u03b9),\n        (\u2200 i, i \u2208 F \u2192 U i \u2208 T i) \u2227 S = \u22c2 (i) (_ : i \u2208 F), f i \u207b\u00b9' U i } := by\n  convert IsTopologicalBasis.iInf (fun i \u21a6 (cond i).induced (f i)) with S\n  constructor <;> rintro \u27e8U, F, hUT, hSU\u27e9\n  \u00b7 exact \u27e8fun i \u21a6 (f i) \u207b\u00b9' (U i), F, fun i hi \u21a6 mem_image_of_mem _ (hUT i hi), hSU\u27e9\n  \u00b7 choose! U' hU' hUU' using hUT\n    exact \u27e8U', F, hU', hSU \u25b8 (.symm <| iInter\u2082_congr hUU')\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\n\u03b9 : Type u_3\nX : \u03b9 \u2192 Type u_4\nt : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\nf : (i : \u03b9) \u2192 \u03b2 \u2192 X i\n\u22a2 IsTopologicalBasis {S | \u2203 U F, (\u2200 i \u2208 F, U i \u2208 T i) \u2227 S = \u22c2 i \u2208 F, f i \u207b\u00b9' U i}"}, {"line": "convert IsTopologicalBasis.iInf (fun i \u21a6 (cond i).induced (f i)) with S", "tactic_state": "case h.e'_3.h.e'_2.h.a\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nX : \u03b9 \u2192 Type u_4\nt : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\nf : (i : \u03b9) \u2192 \u03b2 \u2192 X i\nS : Set \u03b2\n\u22a2 (\u2203 U F, (\u2200 i \u2208 F, U i \u2208 T i) \u2227 S = \u22c2 i \u2208 F, f i \u207b\u00b9' U i) \u2194\n    \u2203 U F, (\u2200 i \u2208 F, U i \u2208 preimage (f i) '' T i) \u2227 S = \u22c2 i \u2208 F, U i"}, {"line": "constructor <;> rintro \u27e8U, F, hUT, hSU\u27e9", "tactic_state": "case h.e'_3.h.e'_2.h.a.mp.intro.intro.intro\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nX : \u03b9 \u2192 Type u_4\nt : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\nf : (i : \u03b9) \u2192 \u03b2 \u2192 X i\nS : Set \u03b2\nU : (i : \u03b9) \u2192 Set (X i)\nF : Finset \u03b9\nhUT : \u2200 i \u2208 F, U i \u2208 T i\nhSU : S = \u22c2 i \u2208 F, f i \u207b\u00b9' U i\n\u22a2 \u2203 U F, (\u2200 i \u2208 F, U i \u2208 preimage (f i) '' T i) \u2227 S = \u22c2 i \u2208 F, U i\n---\ncase h.e'_3.h.e'_2.h.a.mpr.intro.intro.intro\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nX : \u03b9 \u2192 Type u_4\nt : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\nf : (i : \u03b9) \u2192 \u03b2 \u2192 X i\nS : Set \u03b2\nU : \u03b9 \u2192 Set \u03b2\nF : Finset \u03b9\nhUT : \u2200 i \u2208 F, U i \u2208 preimage (f i) '' T i\nhSU : S = \u22c2 i \u2208 F, U i\n\u22a2 \u2203 U F, (\u2200 i \u2208 F, U i \u2208 T i) \u2227 S = \u22c2 i \u2208 F, f i \u207b\u00b9' U i"}, {"line": "\u00b7 exact \u27e8fun i \u21a6 (f i) \u207b\u00b9' (U i), F, fun i hi \u21a6 mem_image_of_mem _ (hUT i hi), hSU\u27e9", "tactic_state": "case h.e'_3.h.e'_2.h.a.mpr.intro.intro.intro\n\u03b2 : Type u_2\n\u03b9 : Type u_3\nX : \u03b9 \u2192 Type u_4\nt : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\nf : (i : \u03b9) \u2192 \u03b2 \u2192 X i\nS : Set \u03b2\nU : \u03b9 \u2192 Set \u03b2\nF : Finset \u03b9\nhUT : \u2200 i \u2208 F, U i \u2208 preimage (f i) '' T i\nhSU : S = \u22c2 i \u2208 F, U i\n\u22a2 \u2203 U F, (\u2200 i \u2208 F, U i \u2208 T i) \u2227 S = \u22c2 i \u2208 F, f i \u207b\u00b9' U i"}, {"line": "\u00b7 choose! U' hU' hUU' using hUT\n    exact \u27e8U', F, hU', hSU \u25b8 (.symm <| iInter\u2082_congr hUU')\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTopologicalBasis_pi {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]\n    {T : \u2200 i, Set (Set (X i))} (cond : \u2200 i, IsTopologicalBasis (T i)) :\n    IsTopologicalBasis { S | \u2203 (U : \u2200 i, Set (X i)) (F : Finset \u03b9),\n      (\u2200 i, i \u2208 F \u2192 U i \u2208 T i) \u2227 S = (F : Set \u03b9).pi U } := by\n  simpa only [Set.pi_def] using IsTopologicalBasis.iInf_induced cond eval\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\nX : \u03b9 \u2192 Type u_3\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (X i)\nT : (i : \u03b9) \u2192 Set (Set (X i))\ncond : \u2200 (i : \u03b9), IsTopologicalBasis (T i)\n\u22a2 IsTopologicalBasis {S | \u2203 U F, (\u2200 i \u2208 F, U i \u2208 T i) \u2227 S = (\u2191F).pi U}"}, {"line": "simpa only [Set.pi_def] using IsTopologicalBasis.iInf_induced cond eval", "tactic_state": "No Goals!"}]}
{"declaration": "lemma secondCountableTopology_iInf {\u03b1 \u03b9} [Countable \u03b9] {t : \u03b9 \u2192 TopologicalSpace \u03b1}\n    (ht : \u2200 i, @SecondCountableTopology \u03b1 (t i)) : @SecondCountableTopology \u03b1 (\u2a05 i, t i) := by\n  rw [funext fun i => @eq_generateFrom_countableBasis \u03b1 (t i) (ht i)]\n  rw [\u2190 generateFrom_iUnion]\n  exact SecondCountableTopology.mk' <|\n    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "(\u03b1 : Type u) [t : TopologicalSpace \u03b1]", "{\u03b1}", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht : \u2200 (i : \u03b9), SecondCountableTopology \u03b1\n\u22a2 SecondCountableTopology \u03b1"}, {"line": "rw [funext fun i => @eq_generateFrom_countableBasis \u03b1 (t i) (ht i)]", "tactic_state": "\u03b1 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht : \u2200 (i : \u03b9), SecondCountableTopology \u03b1\n\u22a2 SecondCountableTopology \u03b1"}, {"line": "rw [\u2190 generateFrom_iUnion]", "tactic_state": "\u03b1 : Type u_4\n\u03b9 : Sort u_5\ninst\u271d : Countable \u03b9\nt : \u03b9 \u2192 TopologicalSpace \u03b1\nht : \u2200 (i : \u03b9), SecondCountableTopology \u03b1\n\u22a2 SecondCountableTopology \u03b1"}, {"line": "exact SecondCountableTopology.mk' <|\n    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_sUnion_countable [SecondCountableTopology \u03b1] (S : Set (Set \u03b1))\n    (H : \u2200 s \u2208 S, IsOpen s) : \u2203 T : Set (Set \u03b1), T.Countable \u2227 T \u2286 S \u2227 \u22c3\u2080 T = \u22c3\u2080 S := by\n  simpa only [and_left_comm,sUnion_eq_biUnion] using isOpen_biUnion_countable S id H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology", "TopologicalSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "(\u03b1 : Type u) [t : TopologicalSpace \u03b1]", "{\u03b1}", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\nt : TopologicalSpace \u03b1\ninst\u271d : SecondCountableTopology \u03b1\nS : Set (Set \u03b1)\nH : \u2200 s \u2208 S, IsOpen s\n\u22a2 \u2203 T, T.Countable \u2227 T \u2286 S \u2227 \u22c3\u2080 T = \u22c3\u2080 S"}, {"line": "simpa only [and_left_comm,sUnion_eq_biUnion] using isOpen_biUnion_countable S id H", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Topology.IsEmbedding.separableSpace\n    [TopologicalSpace \u03b2] [SecondCountableTopology \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : IsEmbedding f) :\n    TopologicalSpace.SeparableSpace \u03b1 := by\n  have := hf.secondCountableTopology\n  exact SecondCountableTopology.to_separableSpace", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bases.lean", "context": {"open": ["Set Filter Function Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type*} [t : TopologicalSpace \u03b1] {B : Set (Set \u03b1)} {s : Set \u03b1}", "(\u03b1)", "{\u03b1}", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "(\u03b1 : Type u) [t : TopologicalSpace \u03b1]", "{\u03b1}", "(\u03b1) in", "(\u03b1)", "{\u03b1}", "(\u03b1)", "{\u03b1}", "{\u03b9 : Type*} {E : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (E i)]", "{\u03b2 : Type*} [TopologicalSpace \u03b2]", "{X : Type*} [TopologicalSpace X] {Y : Type*} [TopologicalSpace Y] {\u03c0 : X \u2192 Y}", "{S : Setoid X}", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : SecondCountableTopology \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : IsEmbedding f\n\u22a2 SeparableSpace \u03b1"}, {"line": "have := hf.secondCountableTopology", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : SecondCountableTopology \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : IsEmbedding f\nthis : SecondCountableTopology \u03b1\n\u22a2 SeparableSpace \u03b1"}, {"line": "exact SecondCountableTopology.to_separableSpace", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isOpen_iff_of_cover {f : \u03b1 \u2192 Set X} (ho : \u2200 i, IsOpen (f i)) (hU : (\u22c3 i, f i) = univ) :\n    IsOpen s \u2194 \u2200 i, IsOpen (f i \u2229 s) := by\n  refine \u27e8fun h i \u21a6 (ho i).inter h, fun h \u21a6 ?_\u27e9\n  rw [\u2190 s.inter_univ]\n  rw [inter_comm]\n  rw [\u2190 hU]\n  rw [iUnion_inter]\n  exact isOpen_iUnion fun i \u21a6 h i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\n\u22a2 IsOpen s \u2194 \u2200 (i : \u03b1), IsOpen (f i \u2229 s)"}, {"line": "refine \u27e8fun h i \u21a6 (ho i).inter h, fun h \u21a6 ?_\u27e9", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\nh : \u2200 (i : \u03b1), IsOpen (f i \u2229 s)\n\u22a2 IsOpen s"}, {"line": "rw [\u2190 s.inter_univ]", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\nh : \u2200 (i : \u03b1), IsOpen (f i \u2229 s)\n\u22a2 IsOpen (s \u2229 univ)"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\nh : \u2200 (i : \u03b1), IsOpen (f i \u2229 s)\n\u22a2 IsOpen (univ \u2229 s)"}, {"line": "rw [\u2190 hU]", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\nh : \u2200 (i : \u03b1), IsOpen (f i \u2229 s)\n\u22a2 IsOpen ((\u22c3 i, f i) \u2229 s)"}, {"line": "rw [iUnion_inter]", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ns : Set X\ninst\u271d : TopologicalSpace X\nf : \u03b1 \u2192 Set X\nho : \u2200 (i : \u03b1), IsOpen (f i)\nhU : \u22c3 i, f i = univ\nh : \u2200 (i : \u03b1), IsOpen (f i \u2229 s)\n\u22a2 IsOpen (\u22c3 i, f i \u2229 s)"}, {"line": "exact isOpen_iUnion fun i \u21a6 h i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_const {p : Prop} : IsOpen { _x : X | p } := by by_cases p <;> simp [*]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\np : Prop\n\u22a2 IsOpen {_x | p}"}, {"line": "by_cases p <;> simp [*]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem TopologicalSpace.ext_iff_isClosed {X} {t\u2081 t\u2082 : TopologicalSpace X} :\n    t\u2081 = t\u2082 \u2194 \u2200 s, IsClosed[t\u2081] s \u2194 IsClosed[t\u2082] s := by\n  rw [TopologicalSpace.ext_iff]\n  rw [compl_surjective.forall]\n  simp only [@isOpen_compl_iff _ _ t\u2081]\n  simp only [@isOpen_compl_iff _ _ t\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nt\u2081 t\u2082 : TopologicalSpace X\n\u22a2 t\u2081 = t\u2082 \u2194 \u2200 (s : Set X), IsClosed s \u2194 IsClosed s"}, {"line": "rw [TopologicalSpace.ext_iff]", "tactic_state": "X : Type u_2\nt\u2081 t\u2082 : TopologicalSpace X\n\u22a2 (\u2200 (s : Set X), IsOpen s \u2194 IsOpen s) \u2194 \u2200 (s : Set X), IsClosed s \u2194 IsClosed s"}, {"line": "rw [compl_surjective.forall]", "tactic_state": "X : Type u_2\nt\u2081 t\u2082 : TopologicalSpace X\n\u22a2 (\u2200 (x : Set X), IsOpen x\u1d9c \u2194 IsOpen x\u1d9c) \u2194 \u2200 (s : Set X), IsClosed s \u2194 IsClosed s"}, {"line": "simp only [@isOpen_compl_iff _ _ t\u2081]", "tactic_state": "X : Type u_2\nt\u2081 t\u2082 : TopologicalSpace X\n\u22a2 (\u2200 (x : Set X), IsClosed x \u2194 IsOpen x\u1d9c) \u2194 \u2200 (s : Set X), IsClosed s \u2194 IsClosed s"}, {"line": "simp only [@isOpen_compl_iff _ _ t\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.union : IsClosed s\u2081 \u2192 IsClosed s\u2082 \u2192 IsClosed (s\u2081 \u222a s\u2082) := by\n  simpa only [\u2190 isOpen_compl_iff,compl_union] using IsOpen.inter\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ns\u2081 s\u2082 : Set X\ninst\u271d : TopologicalSpace X\n\u22a2 IsClosed s\u2081 \u2192 IsClosed s\u2082 \u2192 IsClosed (s\u2081 \u222a s\u2082)"}, {"line": "simpa only [\u2190 isOpen_compl_iff,compl_union] using IsOpen.inter", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_sInter {s : Set (Set X)} : (\u2200 t \u2208 s, IsClosed t) \u2192 IsClosed (\u22c2\u2080 s) := by\n  simpa only [\u2190 isOpen_compl_iff,compl_sInter,sUnion_image] using isOpen_biUnion\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set (Set X)\n\u22a2 (\u2200 t \u2208 s, IsClosed t) \u2192 IsClosed (\u22c2\u2080 s)"}, {"line": "simpa only [\u2190 isOpen_compl_iff,compl_sInter,sUnion_image] using isOpen_biUnion", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_compl_iff {s : Set X} : IsClosed s\u1d9c \u2194 IsOpen s := by\n  rw [\u2190 isOpen_compl_iff]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed s\u1d9c \u2194 IsOpen s"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsOpen s\u1d9c\u1d9c \u2194 IsOpen s"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.inter (h\u2081 : IsClosed s\u2081) (h\u2082 : IsClosed s\u2082) : IsClosed (s\u2081 \u2229 s\u2082) := by\n  rw [\u2190 isOpen_compl_iff] at *\n  rw [compl_inter]\n  exact IsOpen.union h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ns\u2081 s\u2082 : Set X\ninst\u271d : TopologicalSpace X\nh\u2081 : IsClosed s\u2081\nh\u2082 : IsClosed s\u2082\n\u22a2 IsClosed (s\u2081 \u2229 s\u2082)"}, {"line": "rw [\u2190 isOpen_compl_iff] at *", "tactic_state": "X : Type u\ns\u2081 s\u2082 : Set X\ninst\u271d : TopologicalSpace X\nh\u2081 : IsOpen s\u2081\u1d9c\nh\u2082 : IsOpen s\u2082\u1d9c\n\u22a2 IsOpen (s\u2081 \u2229 s\u2082)\u1d9c"}, {"line": "rw [compl_inter]", "tactic_state": "X : Type u\ns\u2081 s\u2082 : Set X\ninst\u271d : TopologicalSpace X\nh\u2081 : IsOpen s\u2081\u1d9c\nh\u2082 : IsOpen s\u2082\u1d9c\n\u22a2 IsOpen (s\u2081\u1d9c \u222a s\u2082\u1d9c)"}, {"line": "exact IsOpen.union h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.isClosed_biUnion {s : Set \u03b1} {f : \u03b1 \u2192 Set X} (hs : s.Finite)\n    (h : \u2200 i \u2208 s, IsClosed (f i)) :\n    IsClosed (\u22c3 i \u2208 s, f i) := by\n  simp only [\u2190 isOpen_compl_iff] at *\n  simp only [compl_iUnion] at *\n  exact hs.isOpen_biInter h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set \u03b1\nf : \u03b1 \u2192 Set X\nhs : s.Finite\nh : \u2200 i \u2208 s, IsClosed (f i)\n\u22a2 IsClosed (\u22c3 i \u2208 s, f i)"}, {"line": "simp only [\u2190 isOpen_compl_iff] at *", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set \u03b1\nf : \u03b1 \u2192 Set X\nhs : s.Finite\nh : \u2200 i \u2208 s, IsOpen (f i)\u1d9c\n\u22a2 IsOpen (\u22c3 i \u2208 s, f i)\u1d9c"}, {"line": "simp only [compl_iUnion] at *", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set \u03b1\nf : \u03b1 \u2192 Set X\nhs : s.Finite\nh : \u2200 i \u2208 s, IsOpen (f i)\u1d9c\n\u22a2 IsOpen (\u22c2 i \u2208 s, (f i)\u1d9c)"}, {"line": "exact hs.isOpen_biInter h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_iUnion_of_finite [Finite \u03b9] {s : \u03b9 \u2192 Set X} (h : \u2200 i, IsClosed (s i)) :\n    IsClosed (\u22c3 i, s i) := by\n  simp only [\u2190 isOpen_compl_iff] at *\n  simp only [compl_iUnion] at *\n  exact isOpen_iInter_of_finite h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03b9 : Sort v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Finite \u03b9\ns : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsClosed (s i)\n\u22a2 IsClosed (\u22c3 i, s i)"}, {"line": "simp only [\u2190 isOpen_compl_iff] at *", "tactic_state": "X : Type u\n\u03b9 : Sort v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Finite \u03b9\ns : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (s i)\u1d9c\n\u22a2 IsOpen (\u22c3 i, s i)\u1d9c"}, {"line": "simp only [compl_iUnion] at *", "tactic_state": "X : Type u\n\u03b9 : Sort v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Finite \u03b9\ns : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (s i)\u1d9c\n\u22a2 IsOpen (\u22c2 i, (s i)\u1d9c)"}, {"line": "exact isOpen_iInter_of_finite h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_imp {p q : X \u2192 Prop} (hp : IsOpen { x | p x }) (hq : IsClosed { x | q x }) :\n    IsClosed { x | p x \u2192 q x } := by\n  simpa only [imp_iff_not_or] using hp.isClosed_compl.union hq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\np q : X \u2192 Prop\nhp : IsOpen {x | p x}\nhq : IsClosed {x | q x}\n\u22a2 IsClosed {x | p x \u2192 q x}"}, {"line": "simpa only [imp_iff_not_or] using hp.isClosed_compl.union hq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem limUnder_of_not_tendsto [hX : Nonempty X] {f : Filter \u03b1} {g : \u03b1 \u2192 X}\n    (h : \u00ac \u2203 x, Tendsto g f (\ud835\udcdd x)) :\n    limUnder f g = Classical.choice hX := by\n  simp_rw [Tendsto] at h\n  simp_rw [limUnder, lim, Classical.epsilon, Classical.strongIndefiniteDescription, dif_neg h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Basic.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} {\u03b9 : Sort v} {\u03b1 : Type*} {x : X} {s s\u2081 s\u2082 t : Set X} {p p\u2081 p\u2082 : X \u2192 Prop}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace X\nhX : Nonempty X\nf : Filter \u03b1\ng : \u03b1 \u2192 X\nh : \u00ac\u2203 x, Tendsto g f (nhds x)\n\u22a2 limUnder f g = Classical.choice hX"}, {"line": "simp_rw [Tendsto] at h", "tactic_state": "X : Type u\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace X\nhX : Nonempty X\nf : Filter \u03b1\ng : \u03b1 \u2192 X\nh : \u00ac\u2203 x, map g f \u2264 nhds x\n\u22a2 limUnder f g = Classical.choice hX"}, {"line": "simp_rw [limUnder, lim, Classical.epsilon, Classical.strongIndefiniteDescription, dif_neg h]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsClopen.himp (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u21e8 t) := by\n  simpa [himp_eq] using ht.union hs.compl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Clopen.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsClopen s\nht : IsClopen t\n\u22a2 IsClopen (s \u21e8 t)"}, {"line": "simpa [himp_eq] using ht.union hs.compl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_boolIndicator_iff_isClopen (U : Set X) :\n    Continuous U.boolIndicator \u2194 IsClopen U := by\n  rw [continuous_bool_rng true]\n  rw [preimage_boolIndicator_true]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Clopen.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 Continuous U.boolIndicator \u2194 IsClopen U"}, {"line": "rw [continuous_bool_rng true]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nU : Set X\n\u22a2 IsClopen (U.boolIndicator \u207b\u00b9' {true}) \u2194 IsClopen U"}, {"line": "rw [preimage_boolIndicator_true]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousOn_boolIndicator_iff_isClopen (s U : Set X) :\n    ContinuousOn U.boolIndicator s \u2194 IsClopen (((\u2191) : s \u2192 X) \u207b\u00b9' U) := by\n  rw [continuousOn_iff_continuous_restrict]\n  rw [\u2190 continuous_boolIndicator_iff_isClopen]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Clopen.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 ContinuousOn U.boolIndicator s \u2194 IsClopen (Subtype.val \u207b\u00b9' U)"}, {"line": "rw [continuousOn_iff_continuous_restrict]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 Continuous (s.restrict U.boolIndicator) \u2194 IsClopen (Subtype.val \u207b\u00b9' U)"}, {"line": "rw [\u2190 continuous_boolIndicator_iff_isClopen]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 Continuous (s.restrict U.boolIndicator) \u2194 Continuous (Subtype.val \u207b\u00b9' U).boolIndicator"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_interior : x \u2208 interior s \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t := by\n  simp only [interior]\n  simp only [mem_sUnion]\n  simp only [mem_setOf_eq]\n  simp only [and_assoc]\n  simp only [and_left_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 interior s \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [interior]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 \u22c3\u2080 {t | IsOpen t \u2227 t \u2286 s} \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [mem_sUnion]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2203 t \u2208 {t | IsOpen t \u2227 t \u2286 s}, x \u2208 t) \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2203 t, (IsOpen t \u2227 t \u2286 s) \u2227 x \u2208 t) \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [and_assoc]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2203 t, IsOpen t \u2227 t \u2286 s \u2227 x \u2208 t) \u2194 \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [and_left_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem subset_interior_iff_isOpen : s \u2286 interior s \u2194 IsOpen s := by\n  simp only [interior_eq_iff_isOpen.symm]\n  simp only [Subset.antisymm_iff]\n  simp only [interior_subset]\n  simp only [true_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 IsOpen s"}, {"line": "simp only [interior_eq_iff_isOpen.symm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 interior s = s"}, {"line": "simp only [Subset.antisymm_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 interior s \u2286 s \u2227 s \u2286 interior s"}, {"line": "simp only [interior_subset]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 True \u2227 s \u2286 interior s"}, {"line": "simp only [true_and]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma interior_subset_iff : interior s \u2286 t \u2194 \u2200 U, IsOpen U \u2192 U \u2286 s \u2192 U \u2286 t := by\n  simp [interior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 interior s \u2286 t \u2194 \u2200 (U : Set X), IsOpen U \u2192 U \u2286 s \u2192 U \u2286 t"}, {"line": "simp [interior]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.interior_sInter {S : Set (Set X)} (hS : S.Finite) :\n    interior (\u22c2\u2080 S) = \u22c2 s \u2208 S, interior s := by\n  rw [sInter_eq_biInter]\n  rw [hS.interior_biInter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n\u22a2 interior (\u22c2\u2080 S) = \u22c2 s \u2208 S, interior s"}, {"line": "rw [sInter_eq_biInter]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n\u22a2 interior (\u22c2 i \u2208 S, i) = \u22c2 s \u2208 S, interior s"}, {"line": "rw [hS.interior_biInter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff_forall_mem_open : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 t, t \u2286 s \u2227 IsOpen t \u2227 x \u2208 t := by\n  rw [\u2190 subset_interior_iff_isOpen]\n  simp only [subset_def]\n  simp only [mem_interior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "rw [\u2190 subset_interior_iff_isOpen]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2286 interior s \u2194 \u2200 x \u2208 s, \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [subset_def]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2200 x \u2208 s, x \u2208 interior s) \u2194 \u2200 x \u2208 s, \u2203 t, (\u2200 x \u2208 t, x \u2208 s) \u2227 IsOpen t \u2227 x \u2208 t"}, {"line": "simp only [mem_interior]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2200 x \u2208 s, \u2203 t \u2286 s, IsOpen t \u2227 x \u2208 t) \u2194 \u2200 x \u2208 s, \u2203 t, (\u2200 x \u2208 t, x \u2208 s) \u2227 IsOpen t \u2227 x \u2208 t"}]}
{"declaration": "theorem diff_subset_closure_iff : s \\ t \u2286 closure t \u2194 s \u2286 closure t := by\n  rw [diff_subset_iff]\n  rw [union_eq_self_of_subset_left subset_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \\ t \u2286 closure t \u2194 s \u2286 closure t"}, {"line": "rw [diff_subset_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2286 t \u222a closure t \u2194 s \u2286 closure t"}, {"line": "rw [union_eq_self_of_subset_left subset_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_nonempty_iff : (closure s).Nonempty \u2194 s.Nonempty := by\n  simp only [nonempty_iff_ne_empty]\n  simp only [Ne]\n  simp only [closure_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (closure s).Nonempty \u2194 s.Nonempty"}, {"line": "simp only [nonempty_iff_ne_empty]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2260 \u2205 \u2194 s \u2260 \u2205"}, {"line": "simp only [Ne]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u00acclosure s = \u2205 \u2194 \u00acs = \u2205"}, {"line": "simp only [closure_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_eq_compl_interior_compl : closure s = (interior s\u1d9c)\u1d9c := by\n  rw [interior]\n  rw [closure]\n  rw [compl_sUnion]\n  rw [compl_image_set_of]\n  simp only [compl_subset_compl]\n  simp only [isOpen_compl_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s = (interior s\u1d9c)\u1d9c"}, {"line": "rw [interior]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s = (\u22c3\u2080 {t | IsOpen t \u2227 t \u2286 s\u1d9c})\u1d9c"}, {"line": "rw [closure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u22c2\u2080 {t | IsClosed t \u2227 s \u2286 t} = (\u22c3\u2080 {t | IsOpen t \u2227 t \u2286 s\u1d9c})\u1d9c"}, {"line": "rw [compl_sUnion]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u22c2\u2080 {t | IsClosed t \u2227 s \u2286 t} = \u22c2\u2080 (compl '' {t | IsOpen t \u2227 t \u2286 s\u1d9c})"}, {"line": "rw [compl_image_set_of]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u22c2\u2080 {t | IsClosed t \u2227 s \u2286 t} = \u22c2\u2080 {s_1 | IsOpen s_1\u1d9c \u2227 s_1\u1d9c \u2286 s\u1d9c}"}, {"line": "simp only [compl_subset_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u22c2\u2080 {t | IsClosed t \u2227 s \u2286 t} = \u22c2\u2080 {s_1 | IsOpen s_1\u1d9c \u2227 s \u2286 s_1}"}, {"line": "simp only [isOpen_compl_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Set.Finite.closure_sUnion {S : Set (Set X)} (hS : S.Finite) :\n    closure (\u22c3\u2080 S) = \u22c3 s \u2208 S, closure s := by\n  rw [sUnion_eq_biUnion]\n  rw [hS.closure_biUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n\u22a2 closure (\u22c3\u2080 S) = \u22c3 s \u2208 S, closure s"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : S.Finite\n\u22a2 closure (\u22c3 i \u2208 S, i) = \u22c3 s \u2208 S, closure s"}, {"line": "rw [hS.closure_biUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_iUnion_of_finite [Finite \u03b9] (f : \u03b9 \u2192 Set X) :\n    closure (\u22c3 i, f i) = \u22c3 i, closure (f i) := by\n  rw [\u2190 sUnion_range]\n  rw [(finite_range _).closure_sUnion]\n  rw [biUnion_range]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Sort v\ninst\u271d : Finite \u03b9\nf : \u03b9 \u2192 Set X\n\u22a2 closure (\u22c3 i, f i) = \u22c3 i, closure (f i)"}, {"line": "rw [\u2190 sUnion_range]", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Sort v\ninst\u271d : Finite \u03b9\nf : \u03b9 \u2192 Set X\n\u22a2 closure (\u22c3\u2080 range f) = \u22c3 i, closure (f i)"}, {"line": "rw [(finite_range _).closure_sUnion]", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Sort v\ninst\u271d : Finite \u03b9\nf : \u03b9 \u2192 Set X\n\u22a2 \u22c3 s \u2208 range f, closure s = \u22c3 i, closure (f i)\n---\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Sort v\ninst\u271d : Finite \u03b9\nf : \u03b9 \u2192 Set X\n\u22a2 Finite \u03b9"}, {"line": "rw [biUnion_range]", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\n\u03b9 : Sort v\ninst\u271d : Finite \u03b9\nf : \u03b9 \u2192 Set X\n\u22a2 Finite \u03b9"}]}
{"declaration": "theorem closure_compl : closure s\u1d9c = (interior s)\u1d9c := by\n  simp [closure_eq_compl_interior_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s\u1d9c = (interior s)\u1d9c"}, {"line": "simp [closure_eq_compl_interior_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_eq_empty_iff_dense_compl : interior s = \u2205 \u2194 Dense s\u1d9c := by\n  rw [dense_iff_closure_eq]\n  rw [closure_compl]\n  rw [compl_univ_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s = \u2205 \u2194 Dense s\u1d9c"}, {"line": "rw [dense_iff_closure_eq]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s = \u2205 \u2194 closure s\u1d9c = univ"}, {"line": "rw [closure_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s = \u2205 \u2194 (interior s)\u1d9c = univ"}, {"line": "rw [compl_univ_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma disjoint_interior_frontier : Disjoint (interior s) (frontier s) := by\n  rw [disjoint_iff_inter_eq_empty]\n  rw [\u2190 closure_diff_interior]\n  rw [diff_eq]\n  rw [\u2190 inter_assoc]\n  rw [inter_comm]\n  rw [\u2190 inter_assoc]\n  rw [compl_inter_self]\n  rw [empty_inter]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint (interior s) (frontier s)"}, {"line": "rw [disjoint_iff_inter_eq_empty]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s \u2229 frontier s = \u2205"}, {"line": "rw [\u2190 closure_diff_interior]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s \u2229 (closure s \\ interior s) = \u2205"}, {"line": "rw [diff_eq]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s \u2229 (closure s \u2229 (interior s)\u1d9c) = \u2205"}, {"line": "rw [\u2190 inter_assoc]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 interior s \u2229 closure s \u2229 (interior s)\u1d9c = \u2205"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (interior s)\u1d9c \u2229 (interior s \u2229 closure s) = \u2205"}, {"line": "rw [\u2190 inter_assoc]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (interior s)\u1d9c \u2229 interior s \u2229 closure s = \u2205"}, {"line": "rw [compl_inter_self]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u2205 \u2229 closure s = \u2205"}, {"line": "rw [empty_inter]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_diff_frontier (s : Set X) : closure s \\ frontier s = interior s := by\n  rw [frontier]\n  rw [diff_diff_right_self]\n  rw [inter_eq_self_of_subset_right interior_subset_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \\ frontier s = interior s"}, {"line": "rw [frontier]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \\ (closure s \\ interior s) = interior s"}, {"line": "rw [diff_diff_right_self]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2229 interior s = interior s"}, {"line": "rw [inter_eq_self_of_subset_right interior_subset_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_diff_frontier (s : Set X) : s \\ frontier s = interior s := by\n  rw [frontier]\n  rw [diff_diff_right]\n  rw [diff_eq_empty.2 subset_closure]\n  rw [inter_eq_self_of_subset_right interior_subset]\n  rw [empty_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \\ frontier s = interior s"}, {"line": "rw [frontier]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \\ (closure s \\ interior s) = interior s"}, {"line": "rw [diff_diff_right]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \\ closure s \u222a s \u2229 interior s = interior s"}, {"line": "rw [diff_eq_empty.2 subset_closure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u2205 \u222a s \u2229 interior s = interior s"}, {"line": "rw [inter_eq_self_of_subset_right interior_subset]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 \u2205 \u222a interior s = interior s"}, {"line": "rw [empty_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_eq_closure_inter_closure : frontier s = closure s \u2229 closure s\u1d9c := by\n  rw [closure_compl]\n  rw [frontier]\n  rw [diff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s = closure s \u2229 closure s\u1d9c"}, {"line": "rw [closure_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s = closure s \u2229 (interior s)\u1d9c"}, {"line": "rw [frontier]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \\ interior s = closure s \u2229 (interior s)\u1d9c"}, {"line": "rw [diff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_subset_iff_isClosed : frontier s \u2286 s \u2194 IsClosed s := by\n  rw [frontier]\n  rw [diff_subset_iff]\n  rw [union_eq_right.mpr interior_subset]\n  rw [closure_subset_iff_isClosed]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s \u2286 s \u2194 IsClosed s"}, {"line": "rw [frontier]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \\ interior s \u2286 s \u2194 IsClosed s"}, {"line": "rw [diff_subset_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2286 interior s \u222a s \u2194 IsClosed s"}, {"line": "rw [union_eq_right.mpr interior_subset]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s \u2286 s \u2194 IsClosed s"}, {"line": "rw [closure_subset_iff_isClosed]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_compl (s : Set X) : frontier s\u1d9c = frontier s := by\n  simp only [frontier_eq_closure_inter_closure]\n  simp only [compl_compl]\n  simp only [inter_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s\u1d9c = frontier s"}, {"line": "simp only [frontier_eq_closure_inter_closure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s\u1d9c \u2229 closure s\u1d9c\u1d9c = closure s \u2229 closure s\u1d9c"}, {"line": "simp only [compl_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 closure s\u1d9c \u2229 closure s = closure s \u2229 closure s\u1d9c"}, {"line": "simp only [inter_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_univ : frontier (univ : Set X) = \u2205 := by simp [frontier]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 frontier univ = \u2205"}, {"line": "simp [frontier]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_empty : frontier (\u2205 : Set X) = \u2205 := by simp [frontier]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 frontier \u2205 = \u2205"}, {"line": "simp [frontier]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_union_subset (s t : Set X) :\n    frontier (s \u222a t) \u2286 frontier s \u2229 closure t\u1d9c \u222a closure s\u1d9c \u2229 frontier t := by\n  simpa only [frontier_compl,\u2190 compl_union] using frontier_inter_subset s\u1d9c t\u1d9c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 frontier (s \u222a t) \u2286 frontier s \u2229 closure t\u1d9c \u222a closure s\u1d9c \u2229 frontier t"}, {"line": "simpa only [frontier_compl,\u2190 compl_union] using frontier_inter_subset s\u1d9c t\u1d9c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_frontier_iff_isOpen : Disjoint (frontier s) s \u2194 IsOpen s := by\n  rw [\u2190 isClosed_compl_iff]\n  rw [\u2190 frontier_subset_iff_isClosed]\n  rw [frontier_compl]\n  rw [subset_compl_iff_disjoint_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint (frontier s) s \u2194 IsOpen s"}, {"line": "rw [\u2190 isClosed_compl_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint (frontier s) s \u2194 IsClosed s\u1d9c"}, {"line": "rw [\u2190 frontier_subset_iff_isClosed]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint (frontier s) s \u2194 frontier s\u1d9c \u2286 s\u1d9c"}, {"line": "rw [frontier_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 Disjoint (frontier s) s \u2194 frontier s \u2286 s\u1d9c"}, {"line": "rw [subset_compl_iff_disjoint_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_eq_inter_compl_interior : frontier s = (interior s)\u1d9c \u2229 (interior s\u1d9c)\u1d9c := by\n  rw [\u2190 frontier_compl]\n  rw [\u2190 closure_compl]\n  rw [\u2190 diff_eq]\n  rw [closure_diff_interior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s = (interior s)\u1d9c \u2229 (interior s\u1d9c)\u1d9c"}, {"line": "rw [\u2190 frontier_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s\u1d9c = (interior s)\u1d9c \u2229 (interior s\u1d9c)\u1d9c"}, {"line": "rw [\u2190 closure_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s\u1d9c = closure s\u1d9c \u2229 (interior s\u1d9c)\u1d9c"}, {"line": "rw [\u2190 diff_eq]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 frontier s\u1d9c = closure s\u1d9c \\ interior s\u1d9c"}, {"line": "rw [closure_diff_interior]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_frontier_eq_union_interior : (frontier s)\u1d9c = interior s \u222a interior s\u1d9c := by\n  rw [frontier_eq_inter_compl_interior]\n  simp only [compl_inter]\n  simp only [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Closure.lean", "context": {"open": ["Set"], "variables": ["{X : Type u} [TopologicalSpace X] {\u03b9 : Sort v} {x : X} {s s\u2081 s\u2082 t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (frontier s)\u1d9c = interior s \u222a interior s\u1d9c"}, {"line": "rw [frontier_eq_inter_compl_interior]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 ((interior s)\u1d9c \u2229 (interior s\u1d9c)\u1d9c)\u1d9c = interior s \u222a interior s\u1d9c"}, {"line": "simp only [compl_inter]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (interior s)\u1d9c\u1d9c \u222a (interior s\u1d9c)\u1d9c\u1d9c = interior s \u222a interior s\u1d9c"}, {"line": "simp only [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem clusterPt_sup {F G : Filter X} : ClusterPt x (F \u2294 G) \u2194 ClusterPt x F \u2228 ClusterPt x G := by\n  simp only [ClusterPt]\n  simp only [inf_sup_left]\n  simp only [sup_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 ClusterPt x (F \u2294 G) \u2194 ClusterPt x F \u2228 ClusterPt x G"}, {"line": "simp only [ClusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 (nhds x \u2293 (F \u2294 G)).NeBot \u2194 (nhds x \u2293 F).NeBot \u2228 (nhds x \u2293 G).NeBot"}, {"line": "simp only [inf_sup_left]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 (nhds x \u2293 F \u2294 nhds x \u2293 G).NeBot \u2194 (nhds x \u2293 F).NeBot \u2228 (nhds x \u2293 G).NeBot"}, {"line": "simp only [sup_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem clusterPt_iff_not_disjoint {F : Filter X} :\n    ClusterPt x F \u2194 \u00acDisjoint (\ud835\udcdd x) F := by\n  rw [disjoint_iff]\n  rw [ClusterPt]\n  rw [neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 ClusterPt x F \u2194 \u00acDisjoint (nhds x) F"}, {"line": "rw [disjoint_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 ClusterPt x F \u2194 \u00acnhds x \u2293 F = \u22a5"}, {"line": "rw [ClusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 (nhds x \u2293 F).NeBot \u2194 \u00acnhds x \u2293 F = \u22a5"}, {"line": "rw [neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClusterPt.of_le_nhds {f : Filter X} (H : f \u2264 \ud835\udcdd x) [NeBot f] : ClusterPt x f := by\n  rwa [ClusterPt, inf_eq_right.mpr H]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\nf : Filter X\nH : f \u2264 nhds x\ninst\u271d : f.NeBot\n\u22a2 ClusterPt x f"}, {"line": "rwa [ClusterPt, inf_eq_right.mpr H]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ClusterPt.of_nhds_le {f : Filter X} (H : \ud835\udcdd x \u2264 f) : ClusterPt x f := by\n  simp only [ClusterPt]\n  simp only [inf_eq_left.mpr H]\n  simp only [nhds_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nf : Filter X\nH : nhds x \u2264 f\n\u22a2 ClusterPt x f"}, {"line": "simp only [ClusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nf : Filter X\nH : nhds x \u2264 f\n\u22a2 (nhds x \u2293 f).NeBot"}, {"line": "simp only [inf_eq_left.mpr H]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nf : Filter X\nH : nhds x \u2264 f\n\u22a2 (nhds x).NeBot"}, {"line": "simp only [nhds_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.mapClusterPt_iff {v : \u03b1 \u2192 X} (h : u =\u1da0[F] v) :\n    MapClusterPt x F u \u2194 MapClusterPt x F v := by\n  simp only [mapClusterPt_def]\n  simp only [map_congr h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b1 : Type u_1\nF : Filter \u03b1\nu : \u03b1 \u2192 X\nx : X\nv : \u03b1 \u2192 X\nh : u =\u1da0[F] v\n\u22a2 MapClusterPt x F u \u2194 MapClusterPt x F v"}, {"line": "simp only [mapClusterPt_def]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b1 : Type u_1\nF : Filter \u03b1\nu : \u03b1 \u2192 X\nx : X\nv : \u03b1 \u2192 X\nh : u =\u1da0[F] v\n\u22a2 ClusterPt x (map u F) \u2194 ClusterPt x (map v F)"}, {"line": "simp only [map_congr h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_sup {x : X} {F G : Filter X} :\n    AccPt x (F \u2294 G) \u2194 AccPt x F \u2228 AccPt x G := by\n  simp only [AccPt]\n  simp only [inf_sup_left]\n  simp only [sup_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 AccPt x (F \u2294 G) \u2194 AccPt x F \u2228 AccPt x G"}, {"line": "simp only [AccPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 (nhdsWithin x {x}\u1d9c \u2293 (F \u2294 G)).NeBot \u2194 (nhdsWithin x {x}\u1d9c \u2293 F).NeBot \u2228 (nhdsWithin x {x}\u1d9c \u2293 G).NeBot"}, {"line": "simp only [inf_sup_left]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF G : Filter X\n\u22a2 (nhdsWithin x {x}\u1d9c \u2293 F \u2294 nhdsWithin x {x}\u1d9c \u2293 G).NeBot \u2194 (nhdsWithin x {x}\u1d9c \u2293 F).NeBot \u2228 (nhdsWithin x {x}\u1d9c \u2293 G).NeBot"}, {"line": "simp only [sup_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_iff_clusterPt {x : X} {F : Filter X} : AccPt x F \u2194 ClusterPt x (\ud835\udcdf {x}\u1d9c \u2293 F) := by\n  rw [AccPt]\n  rw [nhdsWithin]\n  rw [ClusterPt]\n  rw [inf_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 AccPt x F \u2194 ClusterPt x (principal {x}\u1d9c \u2293 F)"}, {"line": "rw [AccPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 (nhdsWithin x {x}\u1d9c \u2293 F).NeBot \u2194 ClusterPt x (principal {x}\u1d9c \u2293 F)"}, {"line": "rw [nhdsWithin]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 (nhds x \u2293 principal {x}\u1d9c \u2293 F).NeBot \u2194 ClusterPt x (principal {x}\u1d9c \u2293 F)"}, {"line": "rw [ClusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 (nhds x \u2293 principal {x}\u1d9c \u2293 F).NeBot \u2194 (nhds x \u2293 (principal {x}\u1d9c \u2293 F)).NeBot"}, {"line": "rw [inf_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_principal_iff_clusterPt {x : X} {C : Set X} :\n    AccPt x (\ud835\udcdf C) \u2194 ClusterPt x (\ud835\udcdf (C \\ { x })) := by\n  rw [accPt_iff_clusterPt]\n  rw [inf_principal]\n  rw [inter_comm]\n  rw [diff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 AccPt x (principal C) \u2194 ClusterPt x (principal (C \\ {x}))"}, {"line": "rw [accPt_iff_clusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 ClusterPt x (principal {x}\u1d9c \u2293 principal C) \u2194 ClusterPt x (principal (C \\ {x}))"}, {"line": "rw [inf_principal]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 ClusterPt x (principal ({x}\u1d9c \u2229 C)) \u2194 ClusterPt x (principal (C \\ {x}))"}, {"line": "rw [inter_comm]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 ClusterPt x (principal (C \u2229 {x}\u1d9c)) \u2194 ClusterPt x (principal (C \\ {x}))"}, {"line": "rw [diff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_iff_nhds {x : X} {C : Set X} : AccPt x (\ud835\udcdf C) \u2194 \u2200 U \u2208 \ud835\udcdd x, \u2203 y \u2208 U \u2229 C, y \u2260 x := by\n  simp [accPt_principal_iff_clusterPt, clusterPt_principal_iff, Set.Nonempty, exists_prop,\n    and_assoc, @and_comm (\u00ac_ = x)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 AccPt x (principal C) \u2194 \u2200 U \u2208 nhds x, \u2203 y \u2208 U \u2229 C, y \u2260 x"}, {"line": "simp [accPt_principal_iff_clusterPt, clusterPt_principal_iff, Set.Nonempty, exists_prop,\n    and_assoc, @and_comm (\u00ac_ = x)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_iff_frequently {x : X} {C : Set X} : AccPt x (\ud835\udcdf C) \u2194 \u2203\u1da0 y in \ud835\udcdd x, y \u2260 x \u2227 y \u2208 C := by\n  simp [accPt_principal_iff_clusterPt, clusterPt_principal_iff_frequently, and_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nC : Set X\n\u22a2 AccPt x (principal C) \u2194 \u2203\u1da0 (y : X) in nhds x, y \u2260 x \u2227 y \u2208 C"}, {"line": "simp [accPt_principal_iff_clusterPt, clusterPt_principal_iff_frequently, and_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem accPt_principal_iff_nhdsWithin : AccPt x (\ud835\udcdf s) \u2194 (\ud835\udcdd[s \\ {x}] x).NeBot := by\n  rw [accPt_principal_iff_clusterPt]\n  rw [ClusterPt]\n  rw [nhdsWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 AccPt x (principal s) \u2194 (nhdsWithin x (s \\ {x})).NeBot"}, {"line": "rw [accPt_principal_iff_clusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 ClusterPt x (principal (s \\ {x})) \u2194 (nhdsWithin x (s \\ {x})).NeBot"}, {"line": "rw [ClusterPt]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (nhds x \u2293 principal (s \\ {x})).NeBot \u2194 (nhdsWithin x (s \\ {x})).NeBot"}, {"line": "rw [nhdsWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_setOf_clusterPt {f : Filter X} : IsClosed { x | ClusterPt x f } := by\n  simp only [clusterPt_iff_forall_mem_closure]\n  simp only [setOf_forall]\n  exact isClosed_biInter fun _ _ \u21a6 isClosed_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 IsClosed {x | ClusterPt x f}"}, {"line": "simp only [clusterPt_iff_forall_mem_closure]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 IsClosed {x | \u2200 s \u2208 f, x \u2208 closure s}"}, {"line": "simp only [setOf_forall]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 IsClosed (\u22c2 i \u2208 f, {x | x \u2208 closure i})"}, {"line": "exact isClosed_biInter fun _ _ \u21a6 isClosed_closure", "tactic_state": "No Goals!"}]}
{"declaration": "lemma not_mem_closure_iff_nhdsWithin_eq_bot : x \u2209 closure s \u2194 \ud835\udcdd[s] x = \u22a5 := by\n  rw [mem_closure_iff_nhdsWithin_neBot]\n  rw [not_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2209 closure s \u2194 nhdsWithin x s = \u22a5"}, {"line": "rw [mem_closure_iff_nhdsWithin_neBot]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 \u00ac(nhdsWithin x s).NeBot \u2194 nhdsWithin x s = \u22a5"}, {"line": "rw [not_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dense_compl_singleton (x : X) [NeBot (\ud835\udcdd[\u2260] x)] : Dense ({x}\u1d9c : Set X) := by\n  intro y\n  rcases eq_or_ne y x with (rfl | hne)\n  \u00b7 rwa [mem_closure_iff_nhdsWithin_neBot]\n  \u00b7 exact subset_closure hne\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\ninst\u271d : (nhdsWithin x {x}\u1d9c).NeBot\n\u22a2 Dense {x}\u1d9c"}, {"line": "intro y", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\ninst\u271d : (nhdsWithin x {x}\u1d9c).NeBot\ny : X\n\u22a2 y \u2208 closure {x}\u1d9c"}, {"line": "rcases eq_or_ne y x with (rfl | hne)", "tactic_state": "case inl\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ny : X\ninst\u271d : (nhdsWithin y {y}\u1d9c).NeBot\n\u22a2 y \u2208 closure {y}\u1d9c\n---\ncase inr\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\ninst\u271d : (nhdsWithin x {x}\u1d9c).NeBot\ny : X\nhne : y \u2260 x\n\u22a2 y \u2208 closure {x}\u1d9c"}, {"line": "\u00b7 rwa [mem_closure_iff_nhdsWithin_neBot]", "tactic_state": "case inr\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\ninst\u271d : (nhdsWithin x {x}\u1d9c).NeBot\ny : X\nhne : y \u2260 x\n\u22a2 y \u2208 closure {x}\u1d9c"}, {"line": "\u00b7 exact subset_closure hne", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closure_iff_nhds' : x \u2208 closure s \u2194 \u2200 t \u2208 \ud835\udcdd x, \u2203 y : s, \u2191y \u2208 t := by\n  simp only [mem_closure_iff_nhds]\n  simp only [Set.inter_nonempty_iff_exists_right]\n  simp only [SetCoe.exists]\n  simp only [exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 \u2200 t \u2208 nhds x, \u2203 y, \u2191y \u2208 t"}, {"line": "simp only [mem_closure_iff_nhds]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2200 t \u2208 nhds x, (t \u2229 s).Nonempty) \u2194 \u2200 t \u2208 nhds x, \u2203 y, \u2191y \u2208 t"}, {"line": "simp only [Set.inter_nonempty_iff_exists_right]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2200 t \u2208 nhds x, \u2203 x \u2208 s, x \u2208 t) \u2194 \u2200 t \u2208 nhds x, \u2203 y, \u2191y \u2208 t"}, {"line": "simp only [SetCoe.exists]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 (\u2200 t \u2208 nhds x, \u2203 x \u2208 s, x \u2208 t) \u2194 \u2200 t \u2208 nhds x, \u2203 x, \u2203 (_ : x \u2208 s), x \u2208 t"}, {"line": "simp only [exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closure_iff_comap_neBot :\n    x \u2208 closure s \u2194 NeBot (comap ((\u2191) : s \u2192 X) (\ud835\udcdd x)) := by\n  simp_rw [mem_closure_iff_nhds, comap_neBot_iff, Set.inter_nonempty_iff_exists_right,\n    SetCoe.exists, exists_prop]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 x \u2208 closure s \u2194 (comap Subtype.val (nhds x)).NeBot"}, {"line": "simp_rw [mem_closure_iff_nhds, comap_neBot_iff, Set.inter_nonempty_iff_exists_right,\n    SetCoe.exists, exists_prop]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem clusterPt_lift'_closure_iff {F : Filter X} :\n    ClusterPt x (F.lift' closure) \u2194 ClusterPt x F := by\n  simp [clusterPt_iff_lift'_closure, lift'_lift'_assoc (monotone_closure X) (monotone_closure X)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 ClusterPt x (F.lift' closure) \u2194 ClusterPt x F"}, {"line": "simp [clusterPt_iff_lift'_closure, lift'_lift'_assoc (monotone_closure X) (monotone_closure X)]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\nF : Filter X\n\u22a2 pure x \u2264 (F.lift' closure).lift' closure \u2194 pure x \u2264 F.lift' closure"}]}
{"declaration": "theorem mem_closure_of_mem_closure_union (h : x \u2208 closure (s\u2081 \u222a s\u2082))\n    (h\u2081 : s\u2081\u1d9c \u2208 \ud835\udcdd x) : x \u2208 closure s\u2082 := by\n  rw [mem_closure_iff_nhds_ne_bot] at *\n  rwa [\u2190 sup_principal, inf_sup_left, inf_principal_eq_bot.mpr h\u2081, bot_sup_eq] at h", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ClusterPt.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X : Type u} [TopologicalSpace X] {Y : Type v} {\u03b9 : Sort w} {\u03b1 \u03b2 : Type*}", "{F : Filter \u03b1} {u : \u03b1 \u2192 X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns\u2081 s\u2082 : Set X\nh : x \u2208 closure (s\u2081 \u222a s\u2082)\nh\u2081 : s\u2081\u1d9c \u2208 nhds x\n\u22a2 x \u2208 closure s\u2082"}, {"line": "rw [mem_closure_iff_nhds_ne_bot] at *", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nx : X\ns\u2081 s\u2082 : Set X\nh : nhds x \u2293 principal (s\u2081 \u222a s\u2082) \u2260 \u22a5\nh\u2081 : s\u2081\u1d9c \u2208 nhds x\n\u22a2 nhds x \u2293 principal s\u2082 \u2260 \u22a5"}, {"line": "rwa [\u2190 sup_principal, inf_sup_left, inf_principal_eq_bot.mpr h\u2081, bot_sup_eq] at h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma specializes_coe {f g : C(X, Y)} : \u21d1f \u2933 \u21d1g \u2194 f \u2933 g := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.map continuous_coeFun\u27e9\n  suffices \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 MapsTo g K U \u2192 MapsTo f K U by\n    simpa [specializes_iff_pure, nhds_compactOpen]\n  exact fun K _ U hU hg x hx \u21a6 (h.map (continuous_apply x)).mem_open hU (hg hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/CompactOpen.lean", "context": {"open": ["Set Filter TopologicalSpace Topology"], "variables": ["{\u03b1 X Y Z T : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]", "{K : Set X} {U : Set Y}", "(Z) in", "[LocallyCompactPair Y Z]", "{X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\n\u22a2 \u21d1f \u2933 \u21d1g \u2194 f \u2933 g"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 h.map continuous_coeFun\u27e9", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 f \u2933 g"}, {"line": "suffices \u2200 K, IsCompact K \u2192 \u2200 U, IsOpen U \u2192 MapsTo g K U \u2192 MapsTo f K U by\n    simpa [specializes_iff_pure, nhds_compactOpen]", "tactic_state": "case refine_3\nX : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 \u2200 (K : Set X), IsCompact K \u2192 \u2200 (U : Set Y), IsOpen U \u2192 MapsTo (\u21d1g) K U \u2192 MapsTo (\u21d1f) K U\n---\ncase refine_1\nX : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 Set X \u2192 TopologicalSpace X\n---\ncase refine_2\nX : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 Set X \u2192 Set Y \u2192 TopologicalSpace Y"}, {"line": "exact fun K _ U hU hg x hx \u21a6 (h.map (continuous_apply x)).mem_open hU (hg hx)", "tactic_state": "case refine_1\nX : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 Set X \u2192 TopologicalSpace X\n---\ncase refine_2\nX : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf g : C(X, Y)\nh : \u21d1f \u2933 \u21d1g\n\u22a2 Set X \u2192 Set Y \u2192 TopologicalSpace Y"}]}
{"declaration": "theorem image_coev {y : Y} (s : Set X) : coev X Y y '' s = {y} \u00d7\u02e2 s := by simp [singleton_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/CompactOpen.lean", "context": {"open": ["Set Filter TopologicalSpace Topology"], "variables": ["{\u03b1 X Y Z T : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]", "{K : Set X} {U : Set Y}", "(Z) in", "[LocallyCompactPair Y Z]", "{X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}", "(X Y)", "{X Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u271d : Sort u_7\ncoev : x\u271d\ny : Y\ns : Set X\n\u22a2 sorry '' s = {y} \u00d7\u02e2 s"}, {"line": "simp [singleton_prod]", "tactic_state": "X : Type u_2\nY : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u271d : Sort u_7\ncoev : x\u271d\ny : Y\ns : Set X\n\u22a2 (fun a => sorry () a) '' s = Prod.mk y '' s"}]}
{"declaration": "theorem Topology.IsQuotientMap.continuous_lift_prod_right (hf : IsQuotientMap f) {g : Y \u00d7 X \u2192 Z}\n    (hg : Continuous fun p : Y \u00d7 X\u2080 => g (p.1, f p.2)) : Continuous g := by\n  have : Continuous fun p : X\u2080 \u00d7 Y => g ((Prod.swap p).1, f (Prod.swap p).2) :=\n    hg.comp continuous_swap\n  have : Continuous fun p : X\u2080 \u00d7 Y => (g \u2218 Prod.swap) (f p.1, p.2) := this\n  exact (hf.continuous_lift_prod_left this).comp continuous_swap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/CompactOpen.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "ContinuousMap"], "variables": ["{\u03b1 X Y Z T : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace T]", "{K : Set X} {U : Set Y}", "(Z) in", "[LocallyCompactPair Y Z]", "{X' : Type*} [TopologicalSpace X'] {a : X'} {g : X' \u2192 C(Y, Z)} {f : X' \u2192 C(X, Y)}", "(X Y)", "{X Y}", "{X : Type*} {Y : Type*} {Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]", "{X\u2080 X Y Z : Type*} [TopologicalSpace X\u2080] [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X\u271d : Type u_2\nY\u271d : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\u271d\ninst\u271d\u00b3 : TopologicalSpace Y\u271d\nX' : Type u_6\ninst\u271d\u00b2 : TopologicalSpace X'\nf : X' \u2192 C(X\u271d, Y\u271d)\nX : Type u_11\nY : Type u_12\nZ : Type u_13\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nhf : IsQuotientMap f\ng : Y \u00d7 X \u2192 Z\nhg : sorry\n\u22a2 sorry"}, {"line": "have : Continuous fun p : X\u2080 \u00d7 Y => g ((Prod.swap p).1, f (Prod.swap p).2) :=\n    hg.comp continuous_swap", "tactic_state": "X\u271d : Type u_2\nY\u271d : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\u271d\ninst\u271d\u00b3 : TopologicalSpace Y\u271d\nX' : Type u_6\ninst\u271d\u00b2 : TopologicalSpace X'\nf : X' \u2192 C(X\u271d, Y\u271d)\nX : Type u_11\nY : Type u_12\nZ : Type u_13\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nhf : IsQuotientMap f\ng : Y \u00d7 X \u2192 Z\nhg : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "have : Continuous fun p : X\u2080 \u00d7 Y => (g \u2218 Prod.swap) (f p.1, p.2) := this", "tactic_state": "X\u271d : Type u_2\nY\u271d : Type u_3\ninst\u271d\u2074 : TopologicalSpace X\u271d\ninst\u271d\u00b3 : TopologicalSpace Y\u271d\nX' : Type u_6\ninst\u271d\u00b2 : TopologicalSpace X'\nf : X' \u2192 C(X\u271d, Y\u271d)\nX : Type u_11\nY : Type u_12\nZ : Type u_13\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nhf : IsQuotientMap f\ng : Y \u00d7 X \u2192 Z\nhg : sorry\nthis\u271d : sorry\nthis : sorry\n\u22a2 sorry"}, {"line": "exact (hf.continuous_lift_prod_left this).comp continuous_swap", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closure_ne_iff_frequently_within {z : \u03b1} {s : Set \u03b1} :\n    z \u2208 closure (s \\ {z}) \u2194 \u2203\u1da0 x in \ud835\udcdd[\u2260] z, x \u2208 s := by\n  simp [mem_closure_iff_frequently, frequently_nhdsWithin_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nz : \u03b1\ns : Set \u03b1\n\u22a2 z \u2208 closure (s \\ {z}) \u2194 \u2203\u1da0 (x : \u03b1) in nhdsWithin z {z}\u1d9c, x \u2208 s"}, {"line": "simp [mem_closure_iff_frequently, frequently_nhdsWithin_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_eventually_nhdsWithin {a : \u03b1} {s : Set \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 y in \ud835\udcdd[s] a, \u2200\u1da0 x in \ud835\udcdd[s] y, p x) \u2194 \u2200\u1da0 x in \ud835\udcdd[s] a, p x := by\n  refine \u27e8fun h => ?_, fun h => (eventually_nhds_nhdsWithin.2 h).filter_mono inf_le_left\u27e9\n  simp only [eventually_nhdsWithin_iff] at h \u22a2\n  exact h.mono fun x hx hxs => (hx hxs).self_of_nhds hxs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 (\u2200\u1da0 (y : \u03b1) in nhdsWithin a s, \u2200\u1da0 (x : \u03b1) in nhdsWithin y s, p x) \u2194 \u2200\u1da0 (x : \u03b1) in nhdsWithin a s, p x"}, {"line": "refine \u27e8fun h => ?_, fun h => (eventually_nhds_nhdsWithin.2 h).filter_mono inf_le_left\u27e9", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (y : \u03b1) in nhdsWithin a s, \u2200\u1da0 (x : \u03b1) in nhdsWithin y s, p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in nhdsWithin a s, p x"}, {"line": "simp only [eventually_nhdsWithin_iff] at h \u22a2", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns : Set \u03b1\np : \u03b1 \u2192 Prop\nh : \u2200\u1da0 (x : \u03b1) in nhds a, x \u2208 s \u2192 \u2200\u1da0 (x : \u03b1) in nhds x, x \u2208 s \u2192 p x\n\u22a2 \u2200\u1da0 (x : \u03b1) in nhds a, x \u2208 s \u2192 p x"}, {"line": "exact h.mono fun x hx hxs => (hx hxs).self_of_nhds hxs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsWithin {t : Set \u03b1} {a : \u03b1} {s : Set \u03b1} :\n    t \u2208 \ud835\udcdd[s] a \u2194 \u2203 u, IsOpen u \u2227 a \u2208 u \u2227 u \u2229 s \u2286 t := by\n  simpa only [and_assoc,and_left_comm] using (nhdsWithin_basis_open a s).mem_iff\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nt : Set \u03b1\na : \u03b1\ns : Set \u03b1\n\u22a2 t \u2208 nhdsWithin a s \u2194 \u2203 u, IsOpen u \u2227 a \u2208 u \u2227 u \u2229 s \u2286 t"}, {"line": "simpa only [and_assoc,and_left_comm] using (nhdsWithin_basis_open a s).mem_iff", "tactic_state": "No Goals!"}]}
{"declaration": "theorem diff_mem_nhdsWithin_diff {x : \u03b1} {s t : Set \u03b1} (hs : s \u2208 \ud835\udcdd[t] x) (t' : Set \u03b1) :\n    s \\ t' \u2208 \ud835\udcdd[t \\ t'] x := by\n  rw [nhdsWithin]\n  rw [diff_eq]\n  rw [diff_eq]\n  rw [\u2190 inf_principal]\n  rw [\u2190 inf_assoc]\n  exact inter_mem_inf hs (mem_principal_self _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \\ t' \u2208 nhdsWithin x (t \\ t')"}, {"line": "rw [nhdsWithin]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \\ t' \u2208 nhds x \u2293 principal (t \\ t')"}, {"line": "rw [diff_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \\ t' \u2208 nhds x \u2293 principal (t \u2229 t'\u1d9c)"}, {"line": "rw [diff_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \u2229 t'\u1d9c \u2208 nhds x \u2293 principal (t \u2229 t'\u1d9c)"}, {"line": "rw [\u2190 inf_principal]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \u2229 t'\u1d9c \u2208 nhds x \u2293 (principal t \u2293 principal t'\u1d9c)"}, {"line": "rw [\u2190 inf_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhs : s \u2208 nhdsWithin x t\nt' : Set \u03b1\n\u22a2 s \u2229 t'\u1d9c \u2208 nhds x \u2293 principal t \u2293 principal t'\u1d9c"}, {"line": "exact inter_mem_inf hs (mem_principal_self _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_of_nhdsWithin_of_nhds {s t : Set \u03b1} {a : \u03b1} (h1 : s \u2208 \ud835\udcdd a) (h2 : t \u2208 \ud835\udcdd[s] a) :\n    t \u2208 \ud835\udcdd a := by\n  rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.mp h2 with \u27e8_, Hw, hw\u27e9\n  exact (\ud835\udcdd a).sets_of_superset ((\ud835\udcdd a).inter_sets Hw h1) hw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\na : \u03b1\nh1 : s \u2208 nhds a\nh2 : t \u2208 nhdsWithin a s\n\u22a2 t \u2208 nhds a"}, {"line": "rcases mem_nhdsWithin_iff_exists_mem_nhds_inter.mp h2 with \u27e8_, Hw, hw\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\na : \u03b1\nh1 : s \u2208 nhds a\nh2 : t \u2208 nhdsWithin a s\nw\u271d : Set \u03b1\nHw : w\u271d \u2208 nhds a\nhw : w\u271d \u2229 s \u2286 t\n\u22a2 t \u2208 nhds a"}, {"line": "exact (\ud835\udcdd a).sets_of_superset ((\ud835\udcdd a).inter_sets Hw h1) hw", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsWithin_iff_eventuallyEq {s t : Set \u03b1} {x : \u03b1} :\n    t \u2208 \ud835\udcdd[s] x \u2194 s =\u1da0[\ud835\udcdd x] (s \u2229 t : Set \u03b1) := by\n  simp_rw [mem_nhdsWithin_iff_eventually, eventuallyEq_set, mem_inter_iff, iff_self_and]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nx : \u03b1\n\u22a2 t \u2208 nhdsWithin x s \u2194 s =\u1da0[nhds x] s \u2229 t"}, {"line": "simp_rw [mem_nhdsWithin_iff_eventually, eventuallyEq_set, mem_inter_iff, iff_self_and]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_empty (a : \u03b1) : \ud835\udcdd[\u2205] a = \u22a5 := by rw [nhdsWithin, principal_empty, inf_bot_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 nhdsWithin a \u2205 = \u22a5"}, {"line": "rw [nhdsWithin, principal_empty, inf_bot_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_union (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u222a t] a = \ud835\udcdd[s] a \u2294 \ud835\udcdd[t] a := by\n  delta nhdsWithin\n  rw [\u2190 inf_sup_left]\n  rw [sup_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhdsWithin a (s \u222a t) = nhdsWithin a s \u2294 nhdsWithin a t"}, {"line": "delta nhdsWithin", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u222a t) = nhds a \u2293 principal s \u2294 nhds a \u2293 principal t"}, {"line": "rw [\u2190 inf_sup_left]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u222a t) = nhds a \u2293 (principal s \u2294 principal t)"}, {"line": "rw [sup_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma punctured_nhds_eq_nhdsWithin_sup_nhdsWithin [LinearOrder \u03b1] {x : \u03b1} :\n    \ud835\udcdd[\u2260] x = \ud835\udcdd[<] x \u2294 \ud835\udcdd[>] x := by\n  rw [\u2190 Iio_union_Ioi]\n  rw [nhdsWithin_union]\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\nx : \u03b1\n\u22a2 nhdsWithin x {x}\u1d9c = nhdsWithin x (Iio x) \u2294 nhdsWithin x (Ioi x)"}, {"line": "rw [\u2190 Iio_union_Ioi]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\nx : \u03b1\n\u22a2 nhdsWithin x (Iio x \u222a Ioi x) = nhdsWithin x (Iio x) \u2294 nhdsWithin x (Ioi x)\n---\n\u03b1 : Type u_1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LinearOrder \u03b1\nx : \u03b1\n\u22a2 LinearOrder \u03b1"}, {"line": "rw [nhdsWithin_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_sUnion {S : Set (Set \u03b1)} (hS : S.Finite) (a : \u03b1) :\n    \ud835\udcdd[\u22c3\u2080 S] a = \u2a06 s \u2208 S, \ud835\udcdd[s] a := by\n  rw [sUnion_eq_biUnion]\n  rw [nhdsWithin_biUnion hS]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nhS : S.Finite\na : \u03b1\n\u22a2 nhdsWithin a (\u22c3\u2080 S) = \u2a06 s \u2208 S, nhdsWithin a s"}, {"line": "rw [sUnion_eq_biUnion]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nhS : S.Finite\na : \u03b1\n\u22a2 nhdsWithin a (\u22c3 i \u2208 S, i) = \u2a06 s \u2208 S, nhdsWithin a s"}, {"line": "rw [nhdsWithin_biUnion hS]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_inter (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[s] a \u2293 \ud835\udcdd[t] a := by\n  delta nhdsWithin\n  rw [inf_left_comm]\n  rw [inf_assoc]\n  rw [inf_principal]\n  rw [\u2190 inf_assoc]\n  rw [inf_idem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhdsWithin a (s \u2229 t) = nhdsWithin a s \u2293 nhdsWithin a t"}, {"line": "delta nhdsWithin", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 principal s \u2293 (nhds a \u2293 principal t)"}, {"line": "rw [inf_left_comm]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 (nhds a \u2293 principal s \u2293 principal t)"}, {"line": "rw [inf_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 (nhds a \u2293 (principal s \u2293 principal t))"}, {"line": "rw [inf_principal]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 (nhds a \u2293 principal (s \u2229 t))"}, {"line": "rw [\u2190 inf_assoc]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 nhds a \u2293 principal (s \u2229 t)"}, {"line": "rw [inf_idem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_inter' (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[s] a \u2293 \ud835\udcdf t := by\n  delta nhdsWithin\n  rw [\u2190 inf_principal]\n  rw [inf_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhdsWithin a (s \u2229 t) = nhdsWithin a s \u2293 principal t"}, {"line": "delta nhdsWithin", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 principal (s \u2229 t) = nhds a \u2293 principal s \u2293 principal t"}, {"line": "rw [\u2190 inf_principal]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 nhds a \u2293 (principal s \u2293 principal t) = nhds a \u2293 principal s \u2293 principal t"}, {"line": "rw [inf_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_inter_of_mem {a : \u03b1} {s t : Set \u03b1} (h : s \u2208 \ud835\udcdd[t] a) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[t] a := by\n  rw [nhdsWithin_inter]\n  rw [inf_eq_right]\n  exact nhdsWithin_le_of_mem h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\nh : s \u2208 nhdsWithin a t\n\u22a2 nhdsWithin a (s \u2229 t) = nhdsWithin a t"}, {"line": "rw [nhdsWithin_inter]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\nh : s \u2208 nhdsWithin a t\n\u22a2 nhdsWithin a s \u2293 nhdsWithin a t = nhdsWithin a t"}, {"line": "rw [inf_eq_right]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\nh : s \u2208 nhdsWithin a t\n\u22a2 nhdsWithin a t \u2264 nhdsWithin a s"}, {"line": "exact nhdsWithin_le_of_mem h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsWithin_insert {a : \u03b1} {s t : Set \u03b1} : t \u2208 \ud835\udcdd[insert a s] a \u2194 a \u2208 t \u2227 t \u2208 \ud835\udcdd[s] a := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\n\u22a2 t \u2208 nhdsWithin a (insert a s) \u2194 a \u2208 t \u2227 t \u2208 nhdsWithin a s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem insert_mem_nhdsWithin_insert {a : \u03b1} {s t : Set \u03b1} (h : t \u2208 \ud835\udcdd[s] a) :\n    insert a t \u2208 \ud835\udcdd[insert a s] a := by simp [mem_of_superset h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\ns t : Set \u03b1\nh : t \u2208 nhdsWithin a s\n\u22a2 insert a t \u2208 nhdsWithin a (insert a s)"}, {"line": "simp [mem_of_superset h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsNE_sup_pure (a : \u03b1) : \ud835\udcdd[\u2260] a \u2294 pure a = \ud835\udcdd a := by\n  rw [\u2190 nhdsWithin_singleton]\n  rw [\u2190 nhdsWithin_union]\n  rw [compl_union_self]\n  rw [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 nhdsWithin a {a}\u1d9c \u2294 pure a = nhds a"}, {"line": "rw [\u2190 nhdsWithin_singleton]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 nhdsWithin a {a}\u1d9c \u2294 nhdsWithin a {a} = nhds a\n---\n\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 TopologicalSpace \u03b1"}, {"line": "rw [\u2190 nhdsWithin_union]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 nhdsWithin a ({a}\u1d9c \u222a {a}) = nhds a"}, {"line": "rw [compl_union_self]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 nhdsWithin a univ = nhds a"}, {"line": "rw [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pure_sup_nhdsNE (a : \u03b1) : pure a \u2294 \ud835\udcdd[\u2260] a = \ud835\udcdd a := by rw [\u2190 sup_comm, nhdsNE_sup_pure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\na : \u03b1\n\u22a2 pure a \u2294 nhdsWithin a {a}\u1d9c = nhds a"}, {"line": "rw [\u2190 sup_comm, nhdsNE_sup_pure]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_prod [TopologicalSpace \u03b2]\n    {s u : Set \u03b1} {t v : Set \u03b2} {a : \u03b1} {b : \u03b2} (hu : u \u2208 \ud835\udcdd[s] a) (hv : v \u2208 \ud835\udcdd[t] b) :\n    u \u00d7\u02e2 v \u2208 \ud835\udcdd[s \u00d7\u02e2 t] (a, b) := by\n  rw [nhdsWithin_prod_eq]\n  exact prod_mem_prod hu hv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ns u : Set \u03b1\nt v : Set \u03b2\na : \u03b1\nb : \u03b2\nhu : u \u2208 nhdsWithin a s\nhv : v \u2208 nhdsWithin b t\n\u22a2 u \u00d7\u02e2 v \u2208 nhdsWithin (a, b) (s \u00d7\u02e2 t)"}, {"line": "rw [nhdsWithin_prod_eq]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ns u : Set \u03b1\nt v : Set \u03b2\na : \u03b1\nb : \u03b2\nhu : u \u2208 nhdsWithin a s\nhv : v \u2208 nhdsWithin b t\n\u22a2 u \u00d7\u02e2 v \u2208 nhdsWithin a s \u00d7\u02e2 nhdsWithin b t"}, {"line": "exact prod_mem_prod hu hv", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Filter.EventuallyEq.mem_interior {x : \u03b1} {s t : Set \u03b1} (hst : s =\u1da0[\ud835\udcdd x] t)\n    (h : x \u2208 interior s) : x \u2208 interior t := by\n  rw [\u2190 nhdsWithin_eq_iff_eventuallyEq] at hst\n  simpa [mem_interior_iff_mem_nhds, \u2190 nhdsWithin_eq_nhds, hst] using h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhst : s =\u1da0[nhds x] t\nh : x \u2208 interior s\n\u22a2 x \u2208 interior t"}, {"line": "rw [\u2190 nhdsWithin_eq_iff_eventuallyEq] at hst", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\nx : \u03b1\ns t : Set \u03b1\nhst : nhdsWithin x s = nhdsWithin x t\nh : x \u2208 interior s\n\u22a2 x \u2208 interior t"}, {"line": "simpa [mem_interior_iff_mem_nhds, \u2190 nhdsWithin_eq_nhds, hst] using h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_pi_eq' {I : Set \u03b9} (hI : I.Finite) (s : \u2200 i, Set (\u03c0 i)) (x : \u2200 i, \u03c0 i) :\n    \ud835\udcdd[pi I s] x = \u2a05 i, comap (fun x => x i) (\ud835\udcdd (x i) \u2293 \u2a05 (_ : i \u2208 I), \ud835\udcdf (s i)) := by\n  simp only [nhdsWithin]\n  simp only [nhds_pi]\n  simp only [Filter.pi]\n  simp only [comap_inf]\n  simp only [comap_iInf]\n  simp only [pi_def]\n  simp only [comap_principal]\n  simp only [\u2190     iInf_principal_finite hI]\n  simp only [\u2190 iInf_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 nhdsWithin x (I.pi s) = \u2a05 i, comap (fun x => x i) (nhds (x i) \u2293 \u2a05 (_ : i \u2208 I), principal (s i))"}, {"line": "simp only [nhdsWithin]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 nhds x \u2293 principal (I.pi s) = \u2a05 i, comap (fun x => x i) (nhds (x i) \u2293 \u2a05 (_ : i \u2208 I), principal (s i))"}, {"line": "simp only [nhds_pi]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (Filter.pi fun i => nhds (x i)) \u2293 principal (I.pi s) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i) \u2293 \u2a05 (_ : i \u2208 I), principal (s i))"}, {"line": "simp only [Filter.pi]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 principal (I.pi s) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i) \u2293 \u2a05 (_ : i \u2208 I), principal (s i))"}, {"line": "simp only [comap_inf]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 principal (I.pi s) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i)) \u2293 comap (fun x => x i) (\u2a05 (_ : i \u2208 I), principal (s i))"}, {"line": "simp only [comap_iInf]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 principal (I.pi s) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i)) \u2293 \u2a05 (_ : i \u2208 I), comap (fun x => x i) (principal (s i))"}, {"line": "simp only [pi_def]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 principal (\u22c2 a \u2208 I, eval a \u207b\u00b9' s a) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i)) \u2293 \u2a05 (_ : i \u2208 I), comap (fun x => x i) (principal (s i))"}, {"line": "simp only [comap_principal]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 principal (\u22c2 a \u2208 I, eval a \u207b\u00b9' s a) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i)) \u2293 \u2a05 (_ : i \u2208 I), principal ((fun x => x i) \u207b\u00b9' s i)"}, {"line": "simp only [\u2190     iInf_principal_finite hI]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\nhI : I.Finite\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (\u2a05 i, comap (eval i) (nhds (x i))) \u2293 \u2a05 i \u2208 I, principal (eval i \u207b\u00b9' s i) =\n    \u2a05 i, comap (fun x => x i) (nhds (x i)) \u2293 \u2a05 (_ : i \u2208 I), principal ((fun x => x i) \u207b\u00b9' s i)"}, {"line": "simp only [\u2190 iInf_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_pi_univ_eq [Finite \u03b9] (s : \u2200 i, Set (\u03c0 i)) (x : \u2200 i, \u03c0 i) :\n    \ud835\udcdd[pi univ s] x = \u2a05 i, comap (fun x => x i) (\ud835\udcdd[s i] x i) := by\n  simpa [nhdsWithin] using nhdsWithin_pi_eq finite_univ s x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d\u00b9 : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ninst\u271d : Finite \u03b9\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 nhdsWithin x (univ.pi s) = \u2a05 i, comap (fun x => x i) (nhdsWithin (x i) (s i))"}, {"line": "simpa [nhdsWithin] using nhdsWithin_pi_eq finite_univ s x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_pi_eq_bot {I : Set \u03b9} {s : \u2200 i, Set (\u03c0 i)} {x : \u2200 i, \u03c0 i} :\n    \ud835\udcdd[pi I s] x = \u22a5 \u2194 \u2203 i \u2208 I, \ud835\udcdd[s i] x i = \u22a5 := by\n  simp only [nhdsWithin]\n  simp only [nhds_pi]\n  simp only [pi_inf_principal_pi_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 nhdsWithin x (I.pi s) = \u22a5 \u2194 \u2203 i \u2208 I, nhdsWithin (x i) (s i) = \u22a5"}, {"line": "simp only [nhdsWithin]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 nhds x \u2293 principal (I.pi s) = \u22a5 \u2194 \u2203 i \u2208 I, nhds (x i) \u2293 principal (s i) = \u22a5"}, {"line": "simp only [nhds_pi]", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (Filter.pi fun i => nhds (x i)) \u2293 principal (I.pi s) = \u22a5 \u2194 \u2203 i \u2208 I, nhds (x i) \u2293 principal (s i) = \u22a5"}, {"line": "simp only [pi_inf_principal_pi_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_pi_neBot {I : Set \u03b9} {s : \u2200 i, Set (\u03c0 i)} {x : \u2200 i, \u03c0 i} :\n    (\ud835\udcdd[pi I s] x).NeBot \u2194 \u2200 i \u2208 I, (\ud835\udcdd[s i] x i).NeBot := by\n  simp [neBot_iff, nhdsWithin_pi_eq_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\n\u03c0 : \u03b9 \u2192 Type u_6\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03c0 i)\nx : (i : \u03b9) \u2192 \u03c0 i\n\u22a2 (nhdsWithin x (I.pi s)).NeBot \u2194 \u2200 i \u2208 I, (nhdsWithin (x i) (s i)).NeBot"}, {"line": "simp [neBot_iff, nhdsWithin_pi_eq_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_mem_of_tendsto_nhdsWithin {f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b2}\n    (h : Tendsto f l (\ud835\udcdd[s] a)) : \u2200\u1da0 i in l, f i \u2208 s := by\n  simp_rw [nhdsWithin_eq, tendsto_iInf, mem_setOf_eq, tendsto_principal, mem_inter_iff,\n    eventually_and] at h\n  exact (h univ \u27e8mem_univ a, isOpen_univ\u27e9).2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b1\nl : Filter \u03b2\nh : Tendsto f l (nhdsWithin a s)\n\u22a2 \u2200\u1da0 (i : \u03b2) in l, f i \u2208 s"}, {"line": "simp_rw [nhdsWithin_eq, tendsto_iInf, mem_setOf_eq, tendsto_principal, mem_inter_iff,\n    eventually_and] at h", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b1\nl : Filter \u03b2\nh : \u2200 (i : Set \u03b1), a \u2208 i \u2227 IsOpen i \u2192 (\u2200\u1da0 (x : \u03b2) in l, f x \u2208 i) \u2227 \u2200\u1da0 (x : \u03b2) in l, f x \u2208 s\n\u22a2 \u2200\u1da0 (i : \u03b2) in l, f i \u2208 s"}, {"line": "exact (h univ \u27e8mem_univ a, isOpen_univ\u27e9).2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closure_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    {s : \u2200 i, Set (\u03b1 i)} {x : \u2200 i, \u03b1 i} : x \u2208 closure (pi I s) \u2194 \u2200 i \u2208 I, x i \u2208 closure (s i) := by\n  simp only [mem_closure_iff_nhdsWithin_neBot]\n  simp only [nhdsWithin_pi_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03b1 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 x \u2208 closure (I.pi s) \u2194 \u2200 i \u2208 I, x i \u2208 closure (s i)"}, {"line": "simp only [mem_closure_iff_nhdsWithin_neBot]", "tactic_state": "\u03b9 : Type u_7\n\u03b1 : \u03b9 \u2192 Type u_8\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03b1 i)\nI : Set \u03b9\ns : (i : \u03b9) \u2192 Set (\u03b1 i)\nx : (i : \u03b9) \u2192 \u03b1 i\n\u22a2 (nhdsWithin x (I.pi s)).NeBot \u2194 \u2200 i \u2208 I, (nhdsWithin (x i) (s i)).NeBot"}, {"line": "simp only [nhdsWithin_pi_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.piMap {\u03b9 : Type*} {X Y : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (Y i)]\n    {f : (i : \u03b9) \u2192 (X i) \u2192 (Y i)} (hf : \u2200 i, DenseRange (f i)):\n    DenseRange (Pi.map f) := by\n  rw [DenseRange]\n  rw [Set.range_piMap]\n  exact dense_pi Set.univ (fun i _ => hf i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_7\nX : \u03b9 \u2192 Type u_8\nY : \u03b9 \u2192 Type u_9\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (Y i)\nf : (i : \u03b9) \u2192 X i \u2192 Y i\nhf : \u2200 (i : \u03b9), DenseRange (f i)\n\u22a2 DenseRange (Pi.map f)"}, {"line": "rw [DenseRange]", "tactic_state": "\u03b9 : Type u_7\nX : \u03b9 \u2192 Type u_8\nY : \u03b9 \u2192 Type u_9\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (Y i)\nf : (i : \u03b9) \u2192 X i \u2192 Y i\nhf : \u2200 (i : \u03b9), DenseRange (f i)\n\u22a2 Dense (range (Pi.map f))"}, {"line": "rw [Set.range_piMap]", "tactic_state": "\u03b9 : Type u_7\nX : \u03b9 \u2192 Type u_8\nY : \u03b9 \u2192 Type u_9\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (Y i)\nf : (i : \u03b9) \u2192 X i \u2192 Y i\nhf : \u2200 (i : \u03b9), DenseRange (f i)\n\u22a2 Dense (univ.pi fun i => range (f i))"}, {"line": "exact dense_pi Set.univ (fun i _ => hf i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventuallyEq_nhds_of_eventuallyEq_nhdsNE {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h\u2081 : f =\u1da0[\ud835\udcdd[\u2260] a] g)\n    (h\u2082 : f a = g a) :\n    f =\u1da0[\ud835\udcdd a] g := by\n  filter_upwards [eventually_nhdsWithin_iff.1 h\u2081]\n  intro x hx\n  by_cases h\u2082x : x = a\n  \u00b7 simp [h\u2082x, h\u2082]\n  \u00b7 tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\n\u22a2 f =\u1da0[nhds a] g"}, {"line": "filter_upwards [eventually_nhdsWithin_iff.1 h\u2081]", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\n\u22a2 \u2200 (a_1 : \u03b1), (a_1 \u2208 {a}\u1d9c \u2192 f a_1 = g a_1) \u2192 f a_1 = g a_1"}, {"line": "intro x hx", "tactic_state": "case h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\nx : \u03b1\nhx : x \u2208 {a}\u1d9c \u2192 f x = g x\n\u22a2 f x = g x"}, {"line": "by_cases h\u2082x : x = a", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\nx : \u03b1\nhx : x \u2208 {a}\u1d9c \u2192 f x = g x\nh\u2082x : x = a\n\u22a2 f x = g x\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\nx : \u03b1\nhx : x \u2208 {a}\u1d9c \u2192 f x = g x\nh\u2082x : \u00acx = a\n\u22a2 f x = g x"}, {"line": "\u00b7 simp [h\u2082x, h\u2082]", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nf g : \u03b1 \u2192 \u03b2\na : \u03b1\nh\u2081 : f =\u1da0[nhdsWithin a {a}\u1d9c] g\nh\u2082 : f a = g a\nx : \u03b1\nhx : x \u2208 {a}\u1d9c \u2192 f x = g x\nh\u2082x : \u00acx = a\n\u22a2 f x = g x"}, {"line": "\u00b7 tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsWithin_subtype {s : Set \u03b1} {a : { x // x \u2208 s }} {t u : Set { x // x \u2208 s }} :\n    t \u2208 \ud835\udcdd[u] a \u2194 t \u2208 comap ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd[(\u2191) '' u] a) := by\n  rw [nhdsWithin]\n  rw [nhds_subtype]\n  rw [principal_subtype]\n  rw [\u2190 comap_inf]\n  rw [\u2190 nhdsWithin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : { x // x \u2208 s }\nt u : Set { x // x \u2208 s }\n\u22a2 t \u2208 nhdsWithin a u \u2194 t \u2208 comap Subtype.val (nhdsWithin (\u2191a) (Subtype.val '' u))"}, {"line": "rw [nhdsWithin]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : { x // x \u2208 s }\nt u : Set { x // x \u2208 s }\n\u22a2 t \u2208 nhds a \u2293 principal u \u2194 t \u2208 comap Subtype.val (nhdsWithin (\u2191a) (Subtype.val '' u))"}, {"line": "rw [nhds_subtype]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : { x // x \u2208 s }\nt u : Set { x // x \u2208 s }\n\u22a2 t \u2208 comap Subtype.val (nhds \u2191a) \u2293 principal u \u2194 t \u2208 comap Subtype.val (nhdsWithin (\u2191a) (Subtype.val '' u))"}, {"line": "rw [principal_subtype]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : { x // x \u2208 s }\nt u : Set { x // x \u2208 s }\n\u22a2 t \u2208 comap Subtype.val (nhds \u2191a) \u2293 comap Subtype.val (principal (Subtype.val '' u)) \u2194\n    t \u2208 comap Subtype.val (nhdsWithin (\u2191a) (Subtype.val '' u))"}, {"line": "rw [\u2190 comap_inf]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : { x // x \u2208 s }\nt u : Set { x // x \u2208 s }\n\u22a2 t \u2208 comap Subtype.val (nhds \u2191a \u2293 principal (Subtype.val '' u)) \u2194\n    t \u2208 comap Subtype.val (nhdsWithin (\u2191a) (Subtype.val '' u))"}, {"line": "rw [\u2190 nhdsWithin]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhds_subtype_iff_nhdsWithin {s : Set \u03b1} {a : s} {t : Set s} :\n    t \u2208 \ud835\udcdd a \u2194 (\u2191) '' t \u2208 \ud835\udcdd[s] (a : \u03b1) := by\n  rw [\u2190 map_nhds_subtype_val]\n  rw [image_mem_map_iff Subtype.val_injective]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : \u2191s\nt : Set \u2191s\n\u22a2 t \u2208 nhds a \u2194 Subtype.val '' t \u2208 nhdsWithin (\u2191a) s"}, {"line": "rw [\u2190 map_nhds_subtype_val]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\na : \u2191s\nt : Set \u2191s\n\u22a2 t \u2208 nhds a \u2194 Subtype.val '' t \u2208 map Subtype.val (nhds a)"}, {"line": "rw [image_mem_map_iff Subtype.val_injective]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem preimage_coe_mem_nhds_subtype {s t : Set \u03b1} {a : s} : (\u2191) \u207b\u00b9' t \u2208 \ud835\udcdd a \u2194 t \u2208 \ud835\udcdd[s] \u2191a := by\n  rw [\u2190 map_nhds_subtype_val]\n  rw [mem_map]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\na : \u2191s\n\u22a2 Subtype.val \u207b\u00b9' t \u2208 nhds a \u2194 t \u2208 nhdsWithin (\u2191a) s"}, {"line": "rw [\u2190 map_nhds_subtype_val]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\na : \u2191s\n\u22a2 Subtype.val \u207b\u00b9' t \u2208 nhds a \u2194 t \u2208 map Subtype.val (nhds a)"}, {"line": "rw [mem_map]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousWithinAt_univ (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n    ContinuousWithinAt f Set.univ x \u2194 ContinuousAt f x := by\n  rw [ContinuousAt]\n  rw [ContinuousWithinAt]\n  rw [nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 ContinuousWithinAt f univ x \u2194 ContinuousAt f x"}, {"line": "rw [ContinuousAt]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 ContinuousWithinAt f univ x \u2194 Tendsto f (nhds x) (nhds (f x))"}, {"line": "rw [ContinuousWithinAt]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 Tendsto f (nhdsWithin x univ) (nhds (f x)) \u2194 Tendsto f (nhds x) (nhds (f x))"}, {"line": "rw [nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_iff_continuousOn_univ {f : \u03b1 \u2192 \u03b2} : Continuous f \u2194 ContinuousOn f univ := by\n  simp [continuous_iff_continuousAt, ContinuousOn, ContinuousAt, ContinuousWithinAt,\n    nhdsWithin_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Continuous f \u2194 ContinuousOn f univ"}, {"line": "simp [continuous_iff_continuousAt, ContinuousOn, ContinuousAt, ContinuousWithinAt,\n    nhdsWithin_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousAt.comp\u2082_continuousWithinAt_of_eq {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b4} {g : \u03b1 \u2192 \u03b2}\n    {h : \u03b1 \u2192 \u03b3} {x : \u03b1} {s : Set \u03b1} {y : \u03b2 \u00d7 \u03b3} (hf : ContinuousAt f y)\n    (hg : ContinuousWithinAt g s x) (hh : ContinuousWithinAt h s x) (e : (g x, h x) = y) :\n    ContinuousWithinAt (fun x \u21a6 f (g x, h x)) s x := by\n  rw [\u2190 e] at hf\n  exact hf.comp\u2082_continuousWithinAt hg hh\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b4\ng : \u03b1 \u2192 \u03b2\nh : \u03b1 \u2192 \u03b3\nx : \u03b1\ns : Set \u03b1\ny : \u03b2 \u00d7 \u03b3\nhf : ContinuousAt f y\nhg : ContinuousWithinAt g s x\nhh : ContinuousWithinAt h s x\ne : (g x, h x) = y\n\u22a2 ContinuousWithinAt (fun x => f (g x, h x)) s x"}, {"line": "rw [\u2190 e] at hf", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\n\u03b4 : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b3\ninst\u271d : TopologicalSpace \u03b4\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b4\ng : \u03b1 \u2192 \u03b2\nh : \u03b1 \u2192 \u03b3\nx : \u03b1\ns : Set \u03b1\ny : \u03b2 \u00d7 \u03b3\nhf : ContinuousAt f (g x, h x)\nhg : ContinuousWithinAt g s x\nhh : ContinuousWithinAt h s x\ne : (g x, h x) = y\n\u22a2 ContinuousWithinAt (fun x => f (g x, h x)) s x"}, {"line": "exact hf.comp\u2082_continuousWithinAt hg hh", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.LeftInverse.map_nhds_eq {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {x : \u03b2}\n    (h : Function.LeftInverse f g) (hf : ContinuousWithinAt f (range g) (g x))\n    (hg : ContinuousAt g x) : map g (\ud835\udcdd x) = \ud835\udcdd[range g] g x := by\n  simpa only [nhdsWithin_univ,image_univ] using\n    (h.leftInvOn univ).map_nhdsWithin_eq (h x) (by rwa [image_univ]) hg.continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ng : \u03b2 \u2192 \u03b1\nx : \u03b2\nh : LeftInverse f g\nhf : ContinuousWithinAt f (range g) (g x)\nhg : ContinuousAt g x\n\u22a2 map g (nhds x) = nhdsWithin (g x) (range g)"}, {"line": "simpa only [nhdsWithin_univ,image_univ] using\n    (h.leftInvOn univ).map_nhdsWithin_eq (h x) (by rwa [image_univ]) hg.continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpenMap.continuousOn_range_of_leftInverse {f : \u03b1 \u2192 \u03b2} (hf : IsOpenMap f) {finv : \u03b2 \u2192 \u03b1}\n    (hleft : Function.LeftInverse finv f) : ContinuousOn finv (range f) := by\n  rw [\u2190 image_univ]\n  exact (hf.restrict isOpen_univ).continuousOn_image_of_leftInvOn fun x _ => hleft x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : IsOpenMap f\nfinv : \u03b2 \u2192 \u03b1\nhleft : LeftInverse finv f\n\u22a2 ContinuousOn finv (range f)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : IsOpenMap f\nfinv : \u03b2 \u2192 \u03b1\nhleft : LeftInverse finv f\n\u22a2 ContinuousOn finv (f '' univ)"}, {"line": "exact (hf.restrict isOpen_univ).continuousOn_image_of_leftInvOn fun x _ => hleft x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Continuous.tendsto_nhdsSet_nhds\n    {b : \u03b2} {f : \u03b1 \u2192 \u03b2} (h : Continuous f) (h' : EqOn f (fun _ \u21a6 b) s) :\n    Tendsto f (\ud835\udcdd\u02e2 s) (\ud835\udcdd b) := by\n  rw [\u2190 nhdsSet_singleton]\n  exact h.tendsto_nhdsSet h'", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousOn.lean", "context": {"open": ["Set Filter Function Topology Filter", "Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 \u03b4 : Type*}", "[TopologicalSpace \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]", "{n : \u2115} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Continuous f\nh' : EqOn f (fun x => b) s\n\u22a2 Tendsto f (nhdsSet s) (nhds b)"}, {"line": "rw [\u2190 nhdsSet_singleton]", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nb : \u03b2\nf : \u03b1 \u2192 \u03b2\nh : Continuous f\nh' : EqOn f (fun x => b) s\n\u22a2 Tendsto f (nhdsSet s) (nhdsSet {b})"}, {"line": "exact h.tendsto_nhdsSet h'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_property [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} (he : DenseRange e)\n    (hp : IsClosed { x | p x }) (h : \u2200 a, p (e a)) : \u2200 b, p b := by\n  have : univ \u2286 { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ \u2286 closure { b | p b } := closure_mono <| range_subset_iff.mpr h\n      _ = _ := hp.closure_eq\n  simpa only [univ_subset_iff,eq_univ_iff_forall,mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DenseEmbedding.lean", "context": {"open": ["Filter Set Topology", "TopologicalSpace", "TopologicalSpace"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*} {\u03b4 : Type*}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{i : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b4] {f : \u03b3 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b4} {h : \u03b4 \u2192 \u03b2}", "[TopologicalSpace \u03b3]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {s : Set \u03b1}", "{f : s \u2192 \u03b2}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]", "{e : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace \u03b2\ne : \u03b1 \u2192 \u03b2\np : \u03b2 \u2192 Prop\nhe : DenseRange e\nhp : IsClosed {x | p x}\nh : \u2200 (a : \u03b1), p (e a)\n\u22a2 \u2200 (b : \u03b2), p b"}, {"line": "have : univ \u2286 { b | p b } :=\n    calc\n      univ = closure (range e) := he.closure_range.symm\n      _ \u2286 closure { b | p b } := closure_mono <| range_subset_iff.mpr h\n      _ = _ := hp.closure_eq", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b2\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace \u03b2\ne : \u03b1 \u2192 \u03b2\np : \u03b2 \u2192 Prop\nhe : DenseRange e\nhp : IsClosed {x | p x}\nh : \u2200 (a : \u03b1), p (e a)\nthis : univ \u2286 {b | p b}\n\u22a2 \u2200 (b : \u03b2), p b"}, {"line": "simpa only [univ_subset_iff,eq_univ_iff_forall,mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_cofinite_cocompact_iff :\n    Tendsto f cofinite (cocompact _) \u2194 \u2200 K, IsCompact K \u2192 Set.Finite (f \u207b\u00b9' K) := by\n  rw [hasBasis_cocompact.tendsto_right_iff]\n  refine forall\u2082_congr (fun K _ \u21a6 ?_)\n  simp only [mem_compl_iff]\n  simp only [eventually_cofinite]\n  simp only [not_not]\n  simp only [preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\n\u22a2 Tendsto f cofinite (cocompact Y) \u2194 \u2200 (K : Set Y), IsCompact K \u2192 (f \u207b\u00b9' K).Finite"}, {"line": "rw [hasBasis_cocompact.tendsto_right_iff]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\n\u22a2 (\u2200 (i : Set Y), IsCompact i \u2192 \u2200\u1da0 (x : X) in cofinite, f x \u2208 i\u1d9c) \u2194 \u2200 (K : Set Y), IsCompact K \u2192 (f \u207b\u00b9' K).Finite"}, {"line": "refine forall\u2082_congr (fun K _ \u21a6 ?_)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nK : Set Y\nx\u271d : IsCompact K\n\u22a2 (\u2200\u1da0 (x : X) in cofinite, f x \u2208 K\u1d9c) \u2194 (f \u207b\u00b9' K).Finite"}, {"line": "simp only [mem_compl_iff]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nK : Set Y\nx\u271d : IsCompact K\n\u22a2 (\u2200\u1da0 (x : X) in cofinite, f x \u2209 K) \u2194 (f \u207b\u00b9' K).Finite"}, {"line": "simp only [eventually_cofinite]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nK : Set Y\nx\u271d : IsCompact K\n\u22a2 {x | \u00acf x \u2209 K}.Finite \u2194 (f \u207b\u00b9' K).Finite"}, {"line": "simp only [not_not]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\nK : Set Y\nx\u271d : IsCompact K\n\u22a2 {x | f x \u2208 K}.Finite \u2194 (f \u207b\u00b9' K).Finite"}, {"line": "simp only [preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_codiscreteWithin_accPt {S T : Set X} :\n    S \u2208 codiscreteWithin T \u2194 \u2200 x \u2208 T, \u00acAccPt x (\ud835\udcdf (T \\ S)) := by\n  simp only [mem_codiscreteWithin]\n  simp only [disjoint_iff]\n  simp only [AccPt]\n  simp only [not_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS T : Set X\n\u22a2 S \u2208 codiscreteWithin T \u2194 \u2200 x \u2208 T, \u00acAccPt x (principal (T \\ S))"}, {"line": "simp only [mem_codiscreteWithin]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS T : Set X\n\u22a2 (\u2200 x \u2208 T, Disjoint (nhdsWithin x {x}\u1d9c) (principal (T \\ S))) \u2194 \u2200 x \u2208 T, \u00acAccPt x (principal (T \\ S))"}, {"line": "simp only [disjoint_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS T : Set X\n\u22a2 (\u2200 x \u2208 T, nhdsWithin x {x}\u1d9c \u2293 principal (T \\ S) = \u22a5) \u2194 \u2200 x \u2208 T, \u00acAccPt x (principal (T \\ S))"}, {"line": "simp only [AccPt]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS T : Set X\n\u22a2 (\u2200 x \u2208 T, nhdsWithin x {x}\u1d9c \u2293 principal (T \\ S) = \u22a5) \u2194 \u2200 x \u2208 T, \u00ac(nhdsWithin x {x}\u1d9c \u2293 principal (T \\ S)).NeBot"}, {"line": "simp only [not_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem discreteTopology_of_codiscreteWithin {U s : Set X} (h : s \u2208 Filter.codiscreteWithin U) :\n    DiscreteTopology ((s\u1d9c \u2229 U) : Set X) := by\n  rw [(by simp : ((s\u1d9c \u2229 U) : Set X) = ((s \u222a U\u1d9c)\u1d9c : Set X))]\n  rw [discreteTopology_subtype_iff]\n  simp_rw [mem_codiscreteWithin, Filter.disjoint_principal_right] at h\n  intro x hx\n  rw [\u2190 Filter.mem_iff_inf_principal_compl]\n  rw [\u2190 Set.compl_diff]\n  simp_all only [h x, Set.compl_union, compl_compl, Set.mem_inter_iff, Set.mem_compl_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : s \u2208 codiscreteWithin U\n\u22a2 DiscreteTopology \u2191(s\u1d9c \u2229 U)"}, {"line": "rw [(by simp : ((s\u1d9c \u2229 U) : Set X) = ((s \u222a U\u1d9c)\u1d9c : Set X))]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : s \u2208 codiscreteWithin U\n\u22a2 DiscreteTopology \u2191(s \u222a U\u1d9c)\u1d9c"}, {"line": "rw [discreteTopology_subtype_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : s \u2208 codiscreteWithin U\n\u22a2 \u2200 x \u2208 (s \u222a U\u1d9c)\u1d9c, nhdsWithin x {x}\u1d9c \u2293 principal (s \u222a U\u1d9c)\u1d9c = \u22a5"}, {"line": "simp_rw [mem_codiscreteWithin, Filter.disjoint_principal_right] at h", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : \u2200 x \u2208 U, (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c\n\u22a2 \u2200 x \u2208 (s \u222a U\u1d9c)\u1d9c, nhdsWithin x {x}\u1d9c \u2293 principal (s \u222a U\u1d9c)\u1d9c = \u22a5"}, {"line": "intro x hx", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : \u2200 x \u2208 U, (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c\nx : X\nhx : x \u2208 (s \u222a U\u1d9c)\u1d9c\n\u22a2 nhdsWithin x {x}\u1d9c \u2293 principal (s \u222a U\u1d9c)\u1d9c = \u22a5"}, {"line": "rw [\u2190 Filter.mem_iff_inf_principal_compl]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : \u2200 x \u2208 U, (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c\nx : X\nhx : x \u2208 (s \u222a U\u1d9c)\u1d9c\n\u22a2 s \u222a U\u1d9c \u2208 nhdsWithin x {x}\u1d9c"}, {"line": "rw [\u2190 Set.compl_diff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nU s : Set X\nh : \u2200 x \u2208 U, (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c\nx : X\nhx : x \u2208 (s \u222a U\u1d9c)\u1d9c\n\u22a2 (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c"}, {"line": "simp_all only [h x, Set.compl_union, compl_compl, Set.mem_inter_iff, Set.mem_compl_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma codiscreteWithin_iff_locallyEmptyComplementWithin {s U : Set X} :\n    s \u2208 codiscreteWithin U \u2194 \u2200 z \u2208 U, \u2203 t \u2208 \ud835\udcdd[\u2260] z, t \u2229 (U \\ s) = \u2205 := by\n  simp only [mem_codiscreteWithin]\n  simp only [disjoint_principal_right]\n  refine \u27e8fun h z hz \u21a6 \u27e8(U \\ s)\u1d9c, h z hz, by simp\u27e9, fun h z hz \u21a6 ?_\u27e9\n  rw [\u2190 exists_mem_subset_iff]\n  obtain \u27e8t, h\u2081t, h\u2082t\u27e9 := h z hz\n  use t, h\u2081t, (disjoint_iff_inter_eq_empty.mpr h\u2082t).subset_compl_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 s \u2208 codiscreteWithin U \u2194 \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205"}, {"line": "simp only [mem_codiscreteWithin]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 (\u2200 x \u2208 U, Disjoint (nhdsWithin x {x}\u1d9c) (principal (U \\ s))) \u2194 \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205"}, {"line": "simp only [disjoint_principal_right]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\n\u22a2 (\u2200 x \u2208 U, (U \\ s)\u1d9c \u2208 nhdsWithin x {x}\u1d9c) \u2194 \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205"}, {"line": "refine \u27e8fun h z hz \u21a6 \u27e8(U \\ s)\u1d9c, h z hz, by simp\u27e9, fun h z hz \u21a6 ?_\u27e9", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\nh : \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205\nz : X\nhz : z \u2208 U\n\u22a2 (U \\ s)\u1d9c \u2208 nhdsWithin z {z}\u1d9c"}, {"line": "rw [\u2190 exists_mem_subset_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\nh : \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205\nz : X\nhz : z \u2208 U\n\u22a2 \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2286 (U \\ s)\u1d9c"}, {"line": "obtain \u27e8t, h\u2081t, h\u2082t\u27e9 := h z hz", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns U : Set X\nh : \u2200 z \u2208 U, \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2229 (U \\ s) = \u2205\nz : X\nhz : z \u2208 U\nt : Set X\nh\u2081t : t \u2208 nhdsWithin z {z}\u1d9c\nh\u2082t : t \u2229 (U \\ s) = \u2205\n\u22a2 \u2203 t \u2208 nhdsWithin z {z}\u1d9c, t \u2286 (U \\ s)\u1d9c"}, {"line": "use t, h\u2081t, (disjoint_iff_inter_eq_empty.mpr h\u2082t).subset_compl_right", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_codiscrete {S : Set X} :\n    S \u2208 codiscrete X \u2194 \u2200 x, Disjoint (\ud835\udcdd[\u2260] x) (\ud835\udcdf S\u1d9c) := by\n  simp [codiscrete, mem_codiscreteWithin, compl_eq_univ_diff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 S \u2208 codiscrete X \u2194 \u2200 (x : X), Disjoint (nhdsWithin x {x}\u1d9c) (principal S\u1d9c)"}, {"line": "simp [codiscrete, mem_codiscreteWithin, compl_eq_univ_diff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_codiscrete_accPt {S : Set X} :\n    S \u2208 codiscrete X \u2194 \u2200 x, \u00acAccPt x (\ud835\udcdf S\u1d9c) := by\n  simp only [mem_codiscrete]\n  simp only [disjoint_iff]\n  simp only [AccPt]\n  simp only [not_neBot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 S \u2208 codiscrete X \u2194 \u2200 (x : X), \u00acAccPt x (principal S\u1d9c)"}, {"line": "simp only [mem_codiscrete]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 (\u2200 (x : X), Disjoint (nhdsWithin x {x}\u1d9c) (principal S\u1d9c)) \u2194 \u2200 (x : X), \u00acAccPt x (principal S\u1d9c)"}, {"line": "simp only [disjoint_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 (\u2200 (x : X), nhdsWithin x {x}\u1d9c \u2293 principal S\u1d9c = \u22a5) \u2194 \u2200 (x : X), \u00acAccPt x (principal S\u1d9c)"}, {"line": "simp only [AccPt]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 (\u2200 (x : X), nhdsWithin x {x}\u1d9c \u2293 principal S\u1d9c = \u22a5) \u2194 \u2200 (x : X), \u00ac(nhdsWithin x {x}\u1d9c \u2293 principal S\u1d9c).NeBot"}, {"line": "simp only [not_neBot]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_codiscrete' {S : Set X} :\n    S \u2208 codiscrete X \u2194 IsOpen S \u2227 DiscreteTopology \u2191S\u1d9c := by\n  rw [mem_codiscrete]\n  rw [\u2190 isClosed_compl_iff]\n  rw [isClosed_and_discrete_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/DiscreteSubset.lean", "context": {"open": ["Set Filter Function Topology"], "variables": ["{X Y : Type*} [TopologicalSpace Y] {f : X \u2192 Y}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 S \u2208 codiscrete X \u2194 IsOpen S \u2227 DiscreteTopology \u2191S\u1d9c"}, {"line": "rw [mem_codiscrete]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 (\u2200 (x : X), Disjoint (nhdsWithin x {x}\u1d9c) (principal S\u1d9c)) \u2194 IsOpen S \u2227 DiscreteTopology \u2191S\u1d9c"}, {"line": "rw [\u2190 isClosed_compl_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nS : Set X\n\u22a2 (\u2200 (x : X), Disjoint (nhdsWithin x {x}\u1d9c) (principal S\u1d9c)) \u2194 IsClosed S\u1d9c \u2227 DiscreteTopology \u2191S\u1d9c"}, {"line": "rw [isClosed_and_discrete_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exterior_singleton_eq_ker_nhds (x : X) : exterior {x} = (\ud835\udcdd x).ker := by simp [exterior]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 exterior {x} = (nhds x).ker"}, {"line": "simp [exterior]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_exterior_singleton : x \u2208 exterior {y} \u2194 x \u2933 y := by\n  rw [exterior_singleton_eq_ker_nhds]\n  rw [ker_nhds_eq_specializes]\n  rw [mem_setOf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 x \u2208 exterior {y} \u2194 x \u2933 y"}, {"line": "rw [exterior_singleton_eq_ker_nhds]", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 x \u2208 (nhds y).ker \u2194 x \u2933 y"}, {"line": "rw [ker_nhds_eq_specializes]", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 x \u2208 {y_1 | y_1 \u2933 y} \u2194 x \u2933 y"}, {"line": "rw [mem_setOf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_exterior : x \u2208 exterior s \u2194 \u2200 U, IsOpen U \u2192 s \u2286 U \u2192 x \u2208 U := by simp [exterior_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns : Set X\nx : X\n\u22a2 x \u2208 exterior s \u2194 \u2200 (U : Set X), IsOpen U \u2192 s \u2286 U \u2192 x \u2208 U"}, {"line": "simp [exterior_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma subset_exterior_iff : s \u2286 exterior t \u2194 \u2200 U, IsOpen U \u2192 t \u2286 U \u2192 s \u2286 U := by\n  simp [exterior_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 s \u2286 exterior t \u2194 \u2200 (U : Set X), IsOpen U \u2192 t \u2286 U \u2192 s \u2286 U"}, {"line": "simp [exterior_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exterior_iUnion (s : \u03b9 \u2192 Set X) : exterior (\u22c3 i, s i) = \u22c3 i, exterior (s i) := by\n  simp only [exterior]\n  simp only [nhdsSet_iUnion]\n  simp only [ker_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Sort u_1\nX : Type u_2\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\n\u22a2 exterior (\u22c3 i, s i) = \u22c3 i, exterior (s i)"}, {"line": "simp only [exterior]", "tactic_state": "\u03b9 : Sort u_1\nX : Type u_2\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\n\u22a2 (nhdsSet (\u22c3 i, s i)).ker = \u22c3 i, (nhdsSet (s i)).ker"}, {"line": "simp only [nhdsSet_iUnion]", "tactic_state": "\u03b9 : Sort u_1\nX : Type u_2\ninst\u271d : TopologicalSpace X\ns : \u03b9 \u2192 Set X\n\u22a2 (\u2a06 i, nhdsSet (s i)).ker = \u22c3 i, (nhdsSet (s i)).ker"}, {"line": "simp only [ker_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exterior_union (s t : Set X) : exterior (s \u222a t) = exterior s \u222a exterior t := by\n  simp only [exterior]\n  simp only [nhdsSet_union]\n  simp only [ker_sup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 exterior (s \u222a t) = exterior s \u222a exterior t"}, {"line": "simp only [exterior]", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 (nhdsSet (s \u222a t)).ker = (nhdsSet s).ker \u222a (nhdsSet t).ker"}, {"line": "simp only [nhdsSet_union]", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 (nhdsSet s \u2294 nhdsSet t).ker = (nhdsSet s).ker \u222a (nhdsSet t).ker"}, {"line": "simp only [ker_sup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exterior_sUnion (S : Set (Set X)) : exterior (\u22c3\u2080 S) = \u22c3 s \u2208 S, exterior s := by\n  simp only [sUnion_eq_biUnion]\n  simp only [exterior_iUnion]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\n\u22a2 exterior (\u22c3\u2080 S) = \u22c3 s \u2208 S, exterior s"}, {"line": "simp only [sUnion_eq_biUnion]", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\n\u22a2 exterior (\u22c3 i \u2208 S, i) = \u22c3 s \u2208 S, exterior s"}, {"line": "simp only [exterior_iUnion]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exterior_eq_exterior_iff_nhdsSet : exterior s = exterior t \u2194 \ud835\udcdd\u02e2 s = \ud835\udcdd\u02e2 t := by\n  simp [le_antisymm_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 exterior s = exterior t \u2194 nhdsSet s = nhdsSet t"}, {"line": "simp [le_antisymm_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma specializes_iff_exterior_subset : x \u2933 y \u2194 exterior {x} \u2286 exterior {y} := by\n  simp [Specializes]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Exterior.lean", "context": {"open": ["Set Filter", "scoped Topology"], "variables": ["{\u03b9 : Sort*} {X : Type*} [TopologicalSpace X] {s t : Set X} {x y : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 x \u2933 y \u2194 exterior {x} \u2286 exterior {y}"}, {"line": "simp [Specializes]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Eventually.germ_congr_set\n    {P : \u2200 x : X, Germ (\ud835\udcdd x) Y \u2192 Prop} (hf : \u2200\u1da0 x in \ud835\udcdd\u02e2 A, P x f)\n    (h : \u2200\u1da0 z in \ud835\udcdd\u02e2 A, g z = f z) : \u2200\u1da0 x in \ud835\udcdd\u02e2 A, P x g := by\n  rw [eventually_nhdsSet_iff_forall] at *\n  intro x hx\n  apply ((hf x hx).and (h x hx).eventually_nhds).mono\n  intro y hy\n  convert hy.1 using 1\n  exact Germ.coe_eq.mpr hy.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Germ.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] {f g : X \u2192 Y} {A : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200\u1da0 (x : X) in nhdsSet A, P x \u2191f\nh : \u2200\u1da0 (z : X) in nhdsSet A, g z = f z\n\u22a2 \u2200\u1da0 (x : X) in nhdsSet A, P x \u2191g"}, {"line": "rw [eventually_nhdsSet_iff_forall] at *", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f\nh : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, g y = f y\n\u22a2 \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191g"}, {"line": "intro x hx", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f\nh : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, g y = f y\nx : X\nhx : x \u2208 A\n\u22a2 \u2200\u1da0 (y : X) in nhds x, P y \u2191g"}, {"line": "apply ((hf x hx).and (h x hx).eventually_nhds).mono", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f\nh : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, g y = f y\nx : X\nhx : x \u2208 A\n\u22a2 \u2200 (x : X), (P x \u2191f \u2227 \u2200\u1da0 (x : X) in nhds x, g x = f x) \u2192 P x \u2191g"}, {"line": "intro y hy", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f\nh : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, g y = f y\nx : X\nhx : x \u2208 A\ny : X\nhy : P y \u2191f \u2227 \u2200\u1da0 (x : X) in nhds y, g x = f x\n\u22a2 P y \u2191g"}, {"line": "convert hy.1 using 1", "tactic_state": "case h.e'_2\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f\nh : \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, g y = f y\nx : X\nhx : x \u2208 A\ny : X\nhy : P y \u2191f \u2227 \u2200\u1da0 (x : X) in nhds y, g x = f x\n\u22a2 \u2191g = \u2191f"}, {"line": "exact Germ.coe_eq.mpr hy.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem restrictGermPredicate_congr {P : \u2200 x : X, Germ (\ud835\udcdd x) Y \u2192 Prop}\n    (hf : RestrictGermPredicate P A x f) (h : \u2200\u1da0 z in \ud835\udcdd\u02e2 A, g z = f z) :\n    RestrictGermPredicate P A x g := by\n  intro hx\n  apply ((hf hx).and <| (eventually_nhdsSet_iff_forall.mp h x hx).eventually_nhds).mono\n  rintro y \u27e8hy, h'y\u27e9\n  rwa [Germ.coe_eq.mpr h'y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Germ.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] {f g : X \u2192 Y} {A : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nx : X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : RestrictGermPredicate P A x \u2191f\nh : \u2200\u1da0 (z : X) in nhdsSet A, g z = f z\n\u22a2 RestrictGermPredicate P A x \u2191g"}, {"line": "intro hx", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nx : X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : RestrictGermPredicate P A x \u2191f\nh : \u2200\u1da0 (z : X) in nhdsSet A, g z = f z\nhx : x \u2208 A\n\u22a2 \u2200\u1da0 (y : X) in nhds x, P y \u2191g"}, {"line": "apply ((hf hx).and <| (eventually_nhdsSet_iff_forall.mp h x hx).eventually_nhds).mono", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nx : X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : RestrictGermPredicate P A x \u2191f\nh : \u2200\u1da0 (z : X) in nhdsSet A, g z = f z\nhx : x \u2208 A\n\u22a2 \u2200 (x : X), (P x \u2191f \u2227 \u2200\u1da0 (x : X) in nhds x, g x = f x) \u2192 P x \u2191g"}, {"line": "rintro y \u27e8hy, h'y\u27e9", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf g : X \u2192 Y\nA : Set X\nx : X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\nhf : RestrictGermPredicate P A x \u2191f\nh : \u2200\u1da0 (z : X) in nhdsSet A, g z = f z\nhx : x \u2208 A\ny : X\nhy : P y \u2191f\nh'y : \u2200\u1da0 (x : X) in nhds y, g x = f x\n\u22a2 P y \u2191g"}, {"line": "rwa [Germ.coe_eq.mpr h'y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem forall_restrictGermPredicate_iff {P : \u2200 x : X, Germ (\ud835\udcdd x) Y \u2192 Prop} :\n    (\u2200 x, RestrictGermPredicate P A x f) \u2194 \u2200\u1da0 x in \ud835\udcdd\u02e2 A, P x f := by\n  rw [eventually_nhdsSet_iff_forall]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Germ.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] {f g : X \u2192 Y} {A : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\n\u22a2 (\u2200 (x : X), RestrictGermPredicate P A x \u2191f) \u2194 \u2200\u1da0 (x : X) in nhdsSet A, P x \u2191f"}, {"line": "rw [eventually_nhdsSet_iff_forall]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nA : Set X\nP : (x : X) \u2192 (nhds x).Germ Y \u2192 Prop\n\u22a2 (\u2200 (x : X), RestrictGermPredicate P A x \u2191f) \u2194 \u2200 x \u2208 A, \u2200\u1da0 (y : X) in nhds x, P y \u2191f"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsLocallyConstant.of_germ_isConstant (h : \u2200 x : X, (f : Germ (\ud835\udcdd x) Y).IsConstant) :\n    IsLocallyConstant f := by\n  intro s\n  rw [isOpen_iff_mem_nhds]\n  intro a ha\n  obtain \u27e8b, hb\u27e9 := h a\n  apply mem_of_superset hb\n  intro x hx\n  have : f x = f a := (mem_of_mem_nhds hb) \u25b8 hx\n  rw [mem_preimage]\n  rw [this]\n  exact ha\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Germ.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] {f g : X \u2192 Y} {A : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\n\u22a2 IsLocallyConstant f"}, {"line": "intro s", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\n\u22a2 IsOpen (f \u207b\u00b9' s)"}, {"line": "rw [isOpen_iff_mem_nhds]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\n\u22a2 \u2200 x \u2208 f \u207b\u00b9' s, f \u207b\u00b9' s \u2208 nhds x"}, {"line": "intro a ha", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\n\u22a2 f \u207b\u00b9' s \u2208 nhds a"}, {"line": "obtain \u27e8b, hb\u27e9 := h a", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\n\u22a2 f \u207b\u00b9' s \u2208 nhds a"}, {"line": "apply mem_of_superset hb", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\n\u22a2 {x | (fun x => f x = (fun x => b) x) x} \u2286 f \u207b\u00b9' s"}, {"line": "intro x hx", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\nx : X\nhx : x \u2208 {x | (fun x => f x = (fun x => b) x) x}\n\u22a2 x \u2208 f \u207b\u00b9' s"}, {"line": "have : f x = f a := (mem_of_mem_nhds hb) \u25b8 hx", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\nx : X\nhx : x \u2208 {x | (fun x => f x = (fun x => b) x) x}\nthis : f x = f a\n\u22a2 x \u2208 f \u207b\u00b9' s"}, {"line": "rw [mem_preimage]", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\nx : X\nhx : x \u2208 {x | (fun x => f x = (fun x => b) x) x}\nthis : f x = f a\n\u22a2 f x \u2208 s"}, {"line": "rw [this]", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nh : \u2200 (x : X), (\u2191f).IsConstant\ns : Set Y\na : X\nha : a \u2208 f \u207b\u00b9' s\nb : Y\nhb : f =\u1da0[nhds a] fun x => b\nx : X\nhx : x \u2208 {x | (fun x => f x = (fun x => b) x) x}\nthis : f x = f a\n\u22a2 f a \u2208 s"}, {"line": "exact ha", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_of_germ_isConstant_on {s : Set X} (h : \u2200 x \u2208 s, (f : Germ (\ud835\udcdd x) Y).IsConstant)\n    (hs : IsPreconnected s) {x' : X} (x_in : x \u2208 s) (x'_in : x' \u2208 s) : f x = f x' := by\n  let i : s \u2192 X := fun x \u21a6 x\n  show (f \u2218 i) (\u27e8x, x_in\u27e9 : s) = (f \u2218 i) (\u27e8x', x'_in\u27e9 : s)\n  have : PreconnectedSpace s := Subtype.preconnectedSpace hs\n  exact eq_of_germ_isConstant (fun y \u21a6 Germ.isConstant_comp_subtype (h y y.2)) _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Germ.lean", "context": {"open": ["scoped Topology", "Filter Set"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] {f g : X \u2192 Y} {A : Set X} {x : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nx : X\ns : Set X\nh : \u2200 x \u2208 s, (\u2191f).IsConstant\nhs : IsPreconnected s\nx' : X\nx_in : x \u2208 s\nx'_in : x' \u2208 s\n\u22a2 f x = f x'"}, {"line": "let i : s \u2192 X := fun x \u21a6 x", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nx : X\ns : Set X\nh : \u2200 x \u2208 s, (\u2191f).IsConstant\nhs : IsPreconnected s\nx' : X\nx_in : x \u2208 s\nx'_in : x' \u2208 s\ni : \u2191s \u2192 X := fun x => \u2191x\n\u22a2 f x = f x'"}, {"line": "show (f \u2218 i) (\u27e8x, x_in\u27e9 : s) = (f \u2218 i) (\u27e8x', x'_in\u27e9 : s)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nx : X\ns : Set X\nh : \u2200 x \u2208 s, (\u2191f).IsConstant\nhs : IsPreconnected s\nx' : X\nx_in : x \u2208 s\nx'_in : x' \u2208 s\ni : \u2191s \u2192 X := fun x => \u2191x\n\u22a2 (f \u2218 i) \u27e8x, x_in\u27e9 = (f \u2218 i) \u27e8x', x'_in\u27e9"}, {"line": "have : PreconnectedSpace s := Subtype.preconnectedSpace hs", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d : TopologicalSpace X\nf : X \u2192 Y\nx : X\ns : Set X\nh : \u2200 x \u2208 s, (\u2191f).IsConstant\nhs : IsPreconnected s\nx' : X\nx_in : x \u2208 s\nx'_in : x' \u2208 s\ni : \u2191s \u2192 X := fun x => \u2191x\nthis : sorry\n\u22a2 (f \u2218 i) \u27e8x, x_in\u27e9 = (f \u2218 i) \u27e8x', x'_in\u27e9"}, {"line": "exact eq_of_germ_isConstant (fun y \u21a6 Germ.isConstant_comp_subtype (h y y.2)) _ _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_indicator_const_iff_forall_eventually'\n    (b : \u03b2) (nhd_b : {0}\u1d9c \u2208 \ud835\udcdd b) (nhd_o : {b}\u1d9c \u2208 \ud835\udcdd 0) :\n    Tendsto (fun i \u21a6 (As i).indicator (fun (_ : \u03b1) \u21a6 b)) L (\ud835\udcdd (A.indicator (fun (_ : \u03b1) \u21a6 b)))\n      \u2194 \u2200 x, \u2200\u1da0 i in L, (x \u2208 As i \u2194 x \u2208 A) := by\n  simp_rw [tendsto_pi_nhds]\n  apply forall_congr'\n  exact tendsto_indicator_const_apply_iff_eventually' L b nhd_b nhd_o\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/IndicatorConstPointwise.lean", "context": {"open": ["Filter Topology"], "variables": ["{\u03b1 : Type*} {A : Set \u03b1}", "{\u03b2 : Type*} [Zero \u03b2] [TopologicalSpace \u03b2]", "{\u03b9 : Type*} (L : Filter \u03b9) {As : \u03b9 \u2192 Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nA : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nL : Filter \u03b9\nAs : \u03b9 \u2192 Set \u03b1\nb : \u03b2\nnhd_b : {0}\u1d9c \u2208 nhds b\nnhd_o : {b}\u1d9c \u2208 nhds 0\n\u22a2 Tendsto (fun i => (As i).indicator fun x => b) L (nhds (A.indicator fun x => b)) \u2194\n    \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in L, x \u2208 As i \u2194 x \u2208 A"}, {"line": "simp_rw [tendsto_pi_nhds]", "tactic_state": "\u03b1 : Type u_1\nA : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nL : Filter \u03b9\nAs : \u03b9 \u2192 Set \u03b1\nb : \u03b2\nnhd_b : {0}\u1d9c \u2208 nhds b\nnhd_o : {b}\u1d9c \u2208 nhds 0\n\u22a2 (\u2200 (x : \u03b1), Tendsto (fun i => (As i).indicator (fun x => b) x) L (nhds (A.indicator (fun x => b) x))) \u2194\n    \u2200 (x : \u03b1), \u2200\u1da0 (i : \u03b9) in L, x \u2208 As i \u2194 x \u2208 A"}, {"line": "apply forall_congr'", "tactic_state": "case h\n\u03b1 : Type u_1\nA : Set \u03b1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : Zero \u03b2\ninst\u271d : TopologicalSpace \u03b2\n\u03b9 : Type u_3\nL : Filter \u03b9\nAs : \u03b9 \u2192 Set \u03b1\nb : \u03b2\nnhd_b : {0}\u1d9c \u2208 nhds b\nnhd_o : {b}\u1d9c \u2208 nhds 0\n\u22a2 \u2200 (a : \u03b1),\n    Tendsto (fun i => (As i).indicator (fun x => b) a) L (nhds (A.indicator (fun x => b) a)) \u2194\n      \u2200\u1da0 (i : \u03b9) in L, a \u2208 As i \u2194 a \u2208 A"}, {"line": "exact tendsto_indicator_const_apply_iff_eventually' L b nhd_b nhd_o", "tactic_state": "No Goals!"}]}
{"declaration": "theorem specializes_TFAE (x y : X) :\n    TFAE [x \u2933 y,\n      pure x \u2264 \ud835\udcdd y,\n      \u2200 s : Set X , IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s,\n      \u2200 s : Set X , IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure ({ x } : Set X),\n      closure ({ y } : Set X) \u2286 closure { x },\n      ClusterPt y (pure x)] := by\n  tfae_have 1 \u2192 2 := (pure_le_nhds _).trans\n  tfae_have 2 \u2192 3 := fun h s hso hy => h (hso.mem_nhds hy)\n  tfae_have 3 \u2192 4 := fun h s hsc hx => of_not_not fun hy => h s\u1d9c hsc.isOpen_compl hy hx\n  tfae_have 4 \u2192 5 := fun h => h _ isClosed_closure (subset_closure <| mem_singleton _)\n  tfae_have 6 \u2194 5 := isClosed_closure.closure_subset_iff.trans singleton_subset_iff\n  tfae_have 5 \u2194 7 := by\n    rw [mem_closure_iff_clusterPt]\n    rw [principal_singleton]\n  tfae_have 5 \u2192 1 := by\n    refine fun h => (nhds_basis_opens _).ge_iff.2 ?_\n    rintro s \u27e8hy, ho\u27e9\n    rcases mem_closure_iff.1 h s ho hy with \u27e8z, hxs, rfl : z = x\u27e9\n    exact ho.mem_nhds hxs\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 1 \u2192 2 := (pure_le_nhds _).trans", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 2 \u2192 3 := fun h s hso hy => h (hso.mem_nhds hy)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 3 \u2192 4 := fun h s hsc hx => of_not_not fun hy => h s\u1d9c hsc.isOpen_compl hy hx", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\ntfae_3_to_4 : (\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2192 \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 4 \u2192 5 := fun h => h _ isClosed_closure (subset_closure <| mem_singleton _)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\ntfae_3_to_4 : (\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2192 \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s\ntfae_4_to_5 : (\u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s) \u2192 y \u2208 closure {x}\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 6 \u2194 5 := isClosed_closure.closure_subset_iff.trans singleton_subset_iff", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\ntfae_3_to_4 : (\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2192 \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s\ntfae_4_to_5 : (\u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s) \u2192 y \u2208 closure {x}\ntfae_6_iff_5 : closure {y} \u2286 closure {x} \u2194 y \u2208 closure {x}\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 5 \u2194 7 := by\n    rw [mem_closure_iff_clusterPt]\n    rw [principal_singleton]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\ntfae_3_to_4 : (\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2192 \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s\ntfae_4_to_5 : (\u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s) \u2192 y \u2208 closure {x}\ntfae_6_iff_5 : closure {y} \u2286 closure {x} \u2194 y \u2208 closure {x}\ntfae_5_iff_7 : y \u2208 closure {x} \u2194 ClusterPt y (pure x)\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_have 5 \u2192 1 := by\n    refine fun h => (nhds_basis_opens _).ge_iff.2 ?_\n    rintro s \u27e8hy, ho\u27e9\n    rcases mem_closure_iff.1 h s ho hy with \u27e8z, hxs, rfl : z = x\u27e9\n    exact ho.mem_nhds hxs", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\ntfae_1_to_2 : x \u2933 y \u2192 pure x \u2264 nhds y\ntfae_2_to_3 : pure x \u2264 nhds y \u2192 \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s\ntfae_3_to_4 : (\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2192 \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s\ntfae_4_to_5 : (\u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s) \u2192 y \u2208 closure {x}\ntfae_6_iff_5 : closure {y} \u2286 closure {x} \u2194 y \u2208 closure {x}\ntfae_5_iff_7 : y \u2208 closure {x} \u2194 ClusterPt y (pure x)\ntfae_5_to_1 : y \u2208 closure {x} \u2192 x \u2933 y\n\u22a2 [x \u2933 y, pure x \u2264 nhds y, \u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s, \u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure {x}, closure {y} \u2286 closure {x}, ClusterPt y (pure x)].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem specializes_prod {x\u2081 x\u2082 : X} {y\u2081 y\u2082 : Y} : (x\u2081, y\u2081) \u2933 (x\u2082, y\u2082) \u2194 x\u2081 \u2933 x\u2082 \u2227 y\u2081 \u2933 y\u2082 := by\n  simp only [Specializes]\n  simp only [nhds_prod_eq]\n  simp only [prod_le_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2081 x\u2082 : X\ny\u2081 y\u2082 : Y\n\u22a2 (x\u2081, y\u2081) \u2933 (x\u2082, y\u2082) \u2194 x\u2081 \u2933 x\u2082 \u2227 y\u2081 \u2933 y\u2082"}, {"line": "simp only [Specializes]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2081 x\u2082 : X\ny\u2081 y\u2082 : Y\n\u22a2 nhds (x\u2081, y\u2081) \u2264 nhds (x\u2082, y\u2082) \u2194 nhds x\u2081 \u2264 nhds x\u2082 \u2227 nhds y\u2081 \u2264 nhds y\u2082"}, {"line": "simp only [nhds_prod_eq]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx\u2081 x\u2082 : X\ny\u2081 y\u2082 : Y\n\u22a2 nhds x\u2081 \u00d7\u02e2 nhds y\u2081 \u2264 nhds x\u2082 \u00d7\u02e2 nhds y\u2082 \u2194 nhds x\u2081 \u2264 nhds x\u2082 \u2227 nhds y\u2081 \u2264 nhds y\u2082"}, {"line": "simp only [prod_le_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_specializes_iff_exists_open : \u00acx \u2933 y \u2194 \u2203 S : Set X, IsOpen S \u2227 y \u2208 S \u2227 x \u2209 S := by\n  rw [specializes_iff_forall_open]\n  push_neg\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 \u00acx \u2933 y \u2194 \u2203 S, IsOpen S \u2227 y \u2208 S \u2227 x \u2209 S"}, {"line": "rw [specializes_iff_forall_open]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 (\u00ac\u2200 (s : Set X), IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s) \u2194 \u2203 S, IsOpen S \u2227 y \u2208 S \u2227 x \u2209 S"}, {"line": "push_neg", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 (\u2203 s, IsOpen s \u2227 y \u2208 s \u2227 x \u2209 s) \u2194 \u2203 S, IsOpen S \u2227 y \u2208 S \u2227 x \u2209 S"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_specializes_iff_exists_closed : \u00acx \u2933 y \u2194 \u2203 S : Set X, IsClosed S \u2227 x \u2208 S \u2227 y \u2209 S := by\n  rw [specializes_iff_forall_closed]\n  push_neg\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 \u00acx \u2933 y \u2194 \u2203 S, IsClosed S \u2227 x \u2208 S \u2227 y \u2209 S"}, {"line": "rw [specializes_iff_forall_closed]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 (\u00ac\u2200 (s : Set X), IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s) \u2194 \u2203 S, IsClosed S \u2227 x \u2208 S \u2227 y \u2209 S"}, {"line": "push_neg", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 (\u2203 s, IsClosed s \u2227 x \u2208 s \u2227 y \u2209 s) \u2194 \u2203 S, IsClosed S \u2227 x \u2208 S \u2227 y \u2209 S"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma stableUnderGeneralization_iff_exists_sInter_eq {s : Set X} :\n    StableUnderGeneralization s \u2194 \u2203 (S : Set (Set X)), (\u2200 s \u2208 S, IsOpen s) \u2227 \u22c2\u2080 S = s := by\n  refine \u27e8?_, fun \u27e8S, hS, e\u27e9 \u21a6 e \u25b8\n    stableUnderGeneralization_sInter S (fun x hx \u21a6 (hS x hx).stableUnderGeneralization)\u27e9\n  rw [\u2190 stableUnderSpecialization_compl_iff]\n  rw [stableUnderSpecialization_iff_exists_sUnion_eq]\n  exact fun \u27e8S, h\u2081, h\u2082\u27e9 \u21a6 \u27e8(\u00b7\u1d9c) '' S, fun s \u27e8t, ht, e\u27e9 \u21a6 e \u25b8 (h\u2081 t ht).isOpen_compl,\n    compl_injective ((sUnion_eq_compl_sInter_compl S).symm.trans h\u2082)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 StableUnderGeneralization s \u2194 \u2203 S, (\u2200 s \u2208 S, IsOpen s) \u2227 \u22c2\u2080 S = s"}, {"line": "refine \u27e8?_, fun \u27e8S, hS, e\u27e9 \u21a6 e \u25b8\n    stableUnderGeneralization_sInter S (fun x hx \u21a6 (hS x hx).stableUnderGeneralization)\u27e9", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 StableUnderGeneralization s \u2192 \u2203 S, (\u2200 s \u2208 S, IsOpen s) \u2227 \u22c2\u2080 S = s"}, {"line": "rw [\u2190 stableUnderSpecialization_compl_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 StableUnderSpecialization s\u1d9c \u2192 \u2203 S, (\u2200 s \u2208 S, IsOpen s) \u2227 \u22c2\u2080 S = s"}, {"line": "rw [stableUnderSpecialization_iff_exists_sUnion_eq]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2203 S, (\u2200 s \u2208 S, IsClosed s) \u2227 \u22c3\u2080 S = s\u1d9c) \u2192 \u2203 S, (\u2200 s \u2208 S, IsOpen s) \u2227 \u22c2\u2080 S = s"}, {"line": "exact fun \u27e8S, h\u2081, h\u2082\u27e9 \u21a6 \u27e8(\u00b7\u1d9c) '' S, fun s \u27e8t, ht, e\u27e9 \u21a6 e \u25b8 (h\u2081 t ht).isOpen_compl,\n    compl_injective ((sUnion_eq_compl_sInter_compl S).symm.trans h\u2082)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_inseparable_iff_exists_open :\n    \u00ac(x ~\u1d62 y) \u2194 \u2203 s : Set X, IsOpen s \u2227 Xor' (x \u2208 s) (y \u2208 s) := by\n  simp [inseparable_iff_forall_isOpen, \u2190 xor_iff_not_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Inseparable.lean", "context": {"open": ["Set Filter Function Topology List"], "variables": ["{X Y Z \u03b1 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace X] [TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b1\u271d : Type u_7\nx : List \u03b1\u271d\ny : X\n\u22a2 \u00acx.Perm sorry \u2194 \u2203 s, IsOpen s \u2227 Xor' sorry (y \u2208 s)"}, {"line": "simp [inseparable_iff_forall_isOpen, \u2190 xor_iff_not_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b1\u271d : Type u_7\nx : List \u03b1\u271d\ny : X\n\u22a2 \u00acx.Perm (sorry ()) \u2194 \u2203 s, IsOpen s \u2227 Xor' (sorry ()) (y \u2208 s)"}]}
{"declaration": "theorem isLocalHomeomorph_iff_isOpenEmbedding_restrict {f : X \u2192 Y} :\n    IsLocalHomeomorph f \u2194 \u2200 x : X, \u2203 U \u2208 \ud835\udcdd x, IsOpenEmbedding (U.restrict f) := by\n  simp_rw [isLocalHomeomorph_iff_isLocalHomeomorphOn_univ,\n    isLocalHomeomorphOn_iff_isOpenEmbedding_restrict, imp_iff_right (Set.mem_univ _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/IsLocalHomeomorph.lean", "context": {"open": ["Topology"], "variables": ["{X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] (g : Y \u2192 Z)", "{g f s t}", "{f s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\n\u22a2 IsLocalHomeomorph f \u2194 \u2200 (x : X), \u2203 U \u2208 nhds x, IsOpenEmbedding (U.restrict f)"}, {"line": "simp_rw [isLocalHomeomorph_iff_isLocalHomeomorphOn_univ,\n    isLocalHomeomorphOn_iff_isOpenEmbedding_restrict, imp_iff_right (Set.mem_univ _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_diagonal (X) [TopologicalSpace (X \u00d7 X)] :\n    \ud835\udcdd\u02e2 (diagonal X) = \u2a06 (x : X), \ud835\udcdd (x, x) := by\n  rw [nhdsSet]\n  rw [\u2190 range_diag]\n  rw [\u2190 range_comp]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\ninst\u271d : TopologicalSpace (X \u00d7 X)\n\u22a2 nhdsSet (diagonal X) = \u2a06 x, nhds (x, x)"}, {"line": "rw [nhdsSet]", "tactic_state": "X : Type u_3\ninst\u271d : TopologicalSpace (X \u00d7 X)\n\u22a2 sSup (nhds '' diagonal X) = \u2a06 x, nhds (x, x)"}, {"line": "rw [\u2190 range_diag]", "tactic_state": "X : Type u_3\ninst\u271d : TopologicalSpace (X \u00d7 X)\n\u22a2 sSup (nhds '' range fun x => (x, x)) = \u2a06 x, nhds (x, x)"}, {"line": "rw [\u2190 range_comp]", "tactic_state": "X : Type u_3\ninst\u271d : TopologicalSpace (X \u00d7 X)\n\u22a2 sSup (range (nhds \u2218 fun x => (x, x))) = \u2a06 x, nhds (x, x)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsSet_iff_forall : s \u2208 \ud835\udcdd\u02e2 t \u2194 \u2200 x : X, x \u2208 t \u2192 s \u2208 \ud835\udcdd x := by\n  simp_rw [nhdsSet, Filter.mem_sSup, forall_mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nt s : Set X\n\u22a2 s \u2208 nhdsSet t \u2194 \u2200 x \u2208 t, s \u2208 nhds x"}, {"line": "simp_rw [nhdsSet, Filter.mem_sSup, forall_mem_image]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nhdsSet_le : \ud835\udcdd\u02e2 s \u2264 f \u2194 \u2200 x \u2208 s, \ud835\udcdd x \u2264 f := by simp [nhdsSet]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nf : Filter X\ns : Set X\n\u22a2 nhdsSet s \u2264 f \u2194 \u2200 x \u2208 s, nhds x \u2264 f"}, {"line": "simp [nhdsSet]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsSet_iff_exists : s \u2208 \ud835\udcdd\u02e2 t \u2194 \u2203 U : Set X, IsOpen U \u2227 t \u2286 U \u2227 U \u2286 s := by\n  rw [\u2190 subset_interior_iff_mem_nhdsSet]\n  rw [subset_interior_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nt s : Set X\n\u22a2 s \u2208 nhdsSet t \u2194 \u2203 U, IsOpen U \u2227 t \u2286 U \u2227 U \u2286 s"}, {"line": "rw [\u2190 subset_interior_iff_mem_nhdsSet]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nt s : Set X\n\u22a2 t \u2286 interior s \u2194 \u2203 U, IsOpen U \u2227 t \u2286 U \u2227 U \u2286 s"}, {"line": "rw [subset_interior_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_empty : \ud835\udcdd\u02e2 (\u2205 : Set X) = \u22a5 := by rw [isOpen_empty.nhdsSet_eq, principal_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 nhdsSet \u2205 = \u22a5"}, {"line": "rw [isOpen_empty.nhdsSet_eq, principal_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsSet_empty : s \u2208 \ud835\udcdd\u02e2 (\u2205 : Set X) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2208 nhdsSet \u2205"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_univ : \ud835\udcdd\u02e2 (univ : Set X) = \u22a4 := by rw [isOpen_univ.nhdsSet_eq, principal_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 nhdsSet univ = \u22a4"}, {"line": "rw [isOpen_univ.nhdsSet_eq, principal_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_union (s t : Set X) : \ud835\udcdd\u02e2 (s \u222a t) = \ud835\udcdd\u02e2 s \u2294 \ud835\udcdd\u02e2 t := by\n  simp only [nhdsSet]\n  simp only [image_union]\n  simp only [sSup_union]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 nhdsSet (s \u222a t) = nhdsSet s \u2294 nhdsSet t"}, {"line": "simp only [nhdsSet]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 sSup (nhds '' (s \u222a t)) = sSup (nhds '' s) \u2294 sSup (nhds '' t)"}, {"line": "simp only [image_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\n\u22a2 sSup (nhds '' s \u222a nhds '' t) = sSup (nhds '' s) \u2294 sSup (nhds '' t)"}, {"line": "simp only [sSup_union]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_insert (x : X) (s : Set X) : \ud835\udcdd\u02e2 (insert x s) = \ud835\udcdd x \u2294 \ud835\udcdd\u02e2 s := by\n  rw [insert_eq]\n  rw [nhdsSet_union]\n  rw [nhdsSet_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 nhdsSet (insert x s) = nhds x \u2294 nhdsSet s"}, {"line": "rw [insert_eq]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 nhdsSet ({x} \u222a s) = nhds x \u2294 nhdsSet s"}, {"line": "rw [nhdsSet_union]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\ns : Set X\n\u22a2 nhdsSet {x} \u2294 nhdsSet s = nhds x \u2294 nhdsSet s"}, {"line": "rw [nhdsSet_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsSet_iUnion {\u03b9 : Sort*} (s : \u03b9 \u2192 Set X) : \ud835\udcdd\u02e2 (\u22c3 i, s i) = \u2a06 i, \ud835\udcdd\u02e2 (s i) := by\n  simp only [nhdsSet]\n  simp only [image_iUnion]\n  simp only [sSup_iUnion (\u03b2 := Filter X)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}", "(s) in", "(s) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\n\u22a2 nhdsSet (\u22c3 i, s i) = \u2a06 i, nhdsSet (s i)"}, {"line": "simp only [nhdsSet]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\n\u22a2 sSup (nhds '' \u22c3 i, s i) = \u2a06 i, sSup (nhds '' s i)"}, {"line": "simp only [image_iUnion]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\n\u22a2 sSup (\u22c3 i, nhds '' s i) = \u2a06 i, sSup (nhds '' s i)"}, {"line": "simp only [sSup_iUnion (\u03b2 := Filter X)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_nhdsSet_iUnion\u2082 {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set X} {P : X \u2192 Prop} :\n    (\u2200\u1da0 x in \ud835\udcdd\u02e2 (\u22c3 (i) (_ : p i), s i), P x) \u2194 \u2200 i, p i \u2192 \u2200\u1da0 x in \ud835\udcdd\u02e2 (s i), P x := by\n  simp only [nhdsSet_iUnion]\n  simp only [eventually_iSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}", "(s) in", "(s) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set X\nP : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in nhdsSet (\u22c3 i, \u22c3 (_ : p i), s i), P x) \u2194 \u2200 (i : \u03b9), p i \u2192 \u2200\u1da0 (x : X) in nhdsSet (s i), P x"}, {"line": "simp only [nhdsSet_iUnion]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set X\nP : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in \u2a06 i, \u2a06 (_ : p i), nhdsSet (s i), P x) \u2194 \u2200 (i : \u03b9), p i \u2192 \u2200\u1da0 (x : X) in nhdsSet (s i), P x"}, {"line": "simp only [eventually_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_nhdsSet_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set X} {P : X \u2192 Prop} :\n    (\u2200\u1da0 x in \ud835\udcdd\u02e2 (\u22c3 i, s i), P x) \u2194 \u2200 i, \u2200\u1da0 x in \ud835\udcdd\u02e2 (s i), P x := by\n  simp only [nhdsSet_iUnion]\n  simp only [eventually_iSup]", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/NhdsSet.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {f : Filter X}", "(s) in", "(s) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\nP : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in nhdsSet (\u22c3 i, s i), P x) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : X) in nhdsSet (s i), P x"}, {"line": "simp only [nhdsSet_iUnion]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Sort u_3\ns : \u03b9 \u2192 Set X\nP : X \u2192 Prop\n\u22a2 (\u2200\u1da0 (x : X) in \u2a06 i, nhdsSet (s i), P x) \u2194 \u2200 (i : \u03b9), \u2200\u1da0 (x : X) in nhdsSet (s i), P x"}, {"line": "simp only [eventually_iSup]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_iff {f : E \u2192\u1d43[R] F} : Continuous f \u2194 Continuous f.linear := by\n  constructor\n  \u00b7 intro hc\n    rw [decomp' f]\n    exact hc.sub continuous_const\n  \u00b7 intro hc\n    rw [decomp f]\n    exact hc.add continuous_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Affine.lean", "context": {"open": [], "variables": ["{R E F : Type*}", "[AddCommGroup E] [TopologicalSpace E]", "[AddCommGroup F] [TopologicalSpace F] [IsTopologicalAddGroup F]", "[Ring R] [Module R E] [Module R F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Module R E\ninst\u271d : Module R F\nf : E \u2192\u1d43[R] F\n\u22a2 Continuous \u21d1f \u2194 Continuous \u21d1f.linear"}, {"line": "constructor", "tactic_state": "case mp\nR : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Module R E\ninst\u271d : Module R F\nf : E \u2192\u1d43[R] F\n\u22a2 Continuous \u21d1f \u2192 Continuous \u21d1f.linear\n---\ncase mpr\nR : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Module R E\ninst\u271d : Module R F\nf : E \u2192\u1d43[R] F\n\u22a2 Continuous \u21d1f.linear \u2192 Continuous \u21d1f"}, {"line": "\u00b7 intro hc\n    rw [decomp' f]\n    exact hc.sub continuous_const", "tactic_state": "case mpr\nR : Type u_1\nE : Type u_2\nF : Type u_3\ninst\u271d\u2077 : AddCommGroup E\ninst\u271d\u2076 : TopologicalSpace E\ninst\u271d\u2075 : AddCommGroup F\ninst\u271d\u2074 : TopologicalSpace F\ninst\u271d\u00b3 : IsTopologicalAddGroup F\ninst\u271d\u00b2 : Ring R\ninst\u271d\u00b9 : Module R E\ninst\u271d : Module R F\nf : E \u2192\u1d43[R] F\n\u22a2 Continuous \u21d1f.linear \u2192 Continuous \u21d1f"}, {"line": "\u00b7 intro hc\n    rw [decomp f]\n    exact hc.add continuous_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem affineHomeomorph_image_Icc {\ud835\udd5c : Type*}\n    [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c]\n    [IsTopologicalRing \ud835\udd5c] (a b c d : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Icc c d = Set.Icc (a * c + b) (a * d + b) := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Field.lean", "context": {"open": [], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 \u21d1(affineHomeomorph a b \u22ef) '' Set.Icc c d = Set.Icc (a * c + b) (a * d + b)"}, {"line": "simp [h]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 (fun a_1 => a * a_1 + b) '' Set.Icc c d = Set.Icc (a * c + b) (a * d + b)"}]}
{"declaration": "theorem affineHomeomorph_image_Ico {\ud835\udd5c : Type*}\n    [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c]\n    [IsTopologicalRing \ud835\udd5c] (a b c d : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ico c d = Set.Ico (a * c + b) (a * d + b) := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Field.lean", "context": {"open": [], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 \u21d1(affineHomeomorph a b \u22ef) '' Set.Ico c d = Set.Ico (a * c + b) (a * d + b)"}, {"line": "simp [h]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 (fun a_1 => a * a_1 + b) '' Set.Ico c d = Set.Ico (a * c + b) (a * d + b)"}]}
{"declaration": "theorem affineHomeomorph_image_Ioc {\ud835\udd5c : Type*}\n    [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c]\n    [IsTopologicalRing \ud835\udd5c] (a b c d : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioc c d = Set.Ioc (a * c + b) (a * d + b) := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Field.lean", "context": {"open": [], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 \u21d1(affineHomeomorph a b \u22ef) '' Set.Ioc c d = Set.Ioc (a * c + b) (a * d + b)"}, {"line": "simp [h]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 (fun a_1 => a * a_1 + b) '' Set.Ioc c d = Set.Ioc (a * c + b) (a * d + b)"}]}
{"declaration": "theorem affineHomeomorph_image_Ioo {\ud835\udd5c : Type*}\n    [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] [TopologicalSpace \ud835\udd5c]\n    [IsTopologicalRing \ud835\udd5c] (a b c d : \ud835\udd5c) (h : 0 < a) :\n    affineHomeomorph a b h.ne' '' Set.Ioo c d = Set.Ioo (a * c + b) (a * d + b) := by\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Field.lean", "context": {"open": [], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 \u21d1(affineHomeomorph a b \u22ef) '' Set.Ioo c d = Set.Ioo (a * c + b) (a * d + b)"}, {"line": "simp [h]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u2074 : Field \ud835\udd5c\ninst\u271d\u00b3 : LinearOrder \ud835\udd5c\ninst\u271d\u00b2 : IsStrictOrderedRing \ud835\udd5c\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd5c\ninst\u271d : IsTopologicalRing \ud835\udd5c\na b c d : \ud835\udd5c\nh : 0 < a\n\u22a2 (fun a_1 => a * a_1 + b) '' Set.Ioo c d = Set.Ioo (a * c + b) (a * d + b)"}]}
{"declaration": "theorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring \ud835\udd5c] [NoZeroDivisors \ud835\udd5c]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) :\n    EqOn f 1 S \u2228 EqOn f (-1) S := by\n  have : DiscreteTopology ({1, -1} : Set \ud835\udd5c) := Finite.instDiscreteTopology\n  have hmaps : MapsTo f S {1, -1} := by\n    simpa only [EqOn,Pi.one_apply,Pi.pow_apply,sq_eq_one_iff] using hsq\n  simpa using hS.eqOn_const_of_mapsTo hf hmaps\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Field.lean", "context": {"open": ["Topology", "Set"], "variables": ["{K : Type*} [DivisionRing K] [TopologicalSpace K]", "(K)", "{\u03b1 : Type*} [Field \u03b1] [TopologicalSpace \u03b1] [IsTopologicalDivisionRing \u03b1]", "{\ud835\udd5c : Type*} [Field \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [IsTopologicalRing \ud835\udd5c]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1]", "{\u03b1 \ud835\udd5c : Type*} {f g : \u03b1 \u2192 \ud835\udd5c} {S : Set \u03b1} [TopologicalSpace \u03b1] [TopologicalSpace \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 EqOn f 1 S \u2228 EqOn f (-1) S"}, {"line": "have : DiscreteTopology ({1, -1} : Set \ud835\udd5c) := Finite.instDiscreteTopology", "tactic_state": "case refine_6\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 EqOn f 1 S \u2228 EqOn f (-1) S\n---\ncase refine_1\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_2\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_3\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 Neg \ud835\udd5c\n---\ncase refine_4\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 TopologicalSpace \u2191{1, -1}\n---\ncase refine_5\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 T1Space \u2191{1, -1}"}, {"line": "have hmaps : MapsTo f S {1, -1} := sorry", "tactic_state": "case refine_6.refine_4\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\nhmaps : MapsTo f S {1, -1}\n\u22a2 EqOn f 1 S \u2228 EqOn f (-1) S\n---\ncase refine_6.refine_1\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_6.refine_2\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_6.refine_3\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 Neg \ud835\udd5c\n---\ncase refine_1\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_2\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_3\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 Neg \ud835\udd5c\n---\ncase refine_4\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 TopologicalSpace \u2191{1, -1}\n---\ncase refine_5\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 T1Space \u2191{1, -1}"}, {"line": "simpa using hS.eqOn_const_of_mapsTo hf hmaps", "tactic_state": "case refine_6.refine_1\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_6.refine_2\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_6.refine_3\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\nthis : DiscreteTopology \u2191{1, -1}\n\u22a2 Neg \ud835\udd5c\n---\ncase refine_1\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_2\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 OfNat \ud835\udd5c 1\n---\ncase refine_3\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 Neg \ud835\udd5c\n---\ncase refine_4\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 TopologicalSpace \u2191{1, -1}\n---\ncase refine_5\n\u03b1 : Type u_6\n\ud835\udd5c : Type u_7\nf : \u03b1 \u2192 \ud835\udd5c\nS : Set \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \ud835\udd5c\ninst\u271d\u00b9 : Ring \ud835\udd5c\ninst\u271d : NoZeroDivisors \ud835\udd5c\nhS : IsPreconnected S\nhf : ContinuousOn f S\nhsq : EqOn (f ^ 2) 1 S\n\u22a2 T1Space \u2191{1, -1}"}]}
{"declaration": "lemma continuous_mulIndicator (hs : \u2200 a \u2208 frontier s, f a = 1) (hf : ContinuousOn f (closure s)) :\n    Continuous (mulIndicator s f) := by\n  classical exact continuous_piecewise hs hf continuousOn_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Indicator.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} [One \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhs : \u2200 a \u2208 frontier s, f a = 1\nhf : ContinuousOn f (closure s)\n\u22a2 Continuous (s.mulIndicator f)"}, {"line": "classical exact continuous_piecewise hs hf continuousOn_const", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Continuous.mulIndicator (hs : \u2200 a \u2208 frontier s, f a = 1) (hf : Continuous f) :\n    Continuous (mulIndicator s f) := by\n  classical exact hf.piecewise hs continuous_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Indicator.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} [One \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhs : \u2200 a \u2208 frontier s, f a = 1\nhf : Continuous f\n\u22a2 Continuous (s.mulIndicator f)"}, {"line": "classical exact hf.piecewise hs continuous_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousOn.continuousAt_mulIndicator (hf : ContinuousOn f (interior s)) {x : \u03b1}\n    (hx : x \u2209 frontier s) :\n    ContinuousAt (s.mulIndicator f) x := by\n  rw [\u2190 Set.mem_compl_iff] at hx\n  rw [compl_frontier_eq_union_interior] at hx\n  obtain h | h := hx\n  \u00b7 have hs : interior s \u2208 \ud835\udcdd x := mem_interior_iff_mem_nhds.mp (by rwa [interior_interior])\n    exact ContinuousAt.congr (hf.continuousAt hs) <| Filter.eventuallyEq_iff_exists_mem.mpr\n      \u27e8interior s, hs, Set.eqOn_mulIndicator.symm.mono interior_subset\u27e9\n  \u00b7 exact ContinuousAt.congr continuousAt_const <| Filter.eventuallyEq_iff_exists_mem.mpr\n      \u27e8s\u1d9c, mem_interior_iff_mem_nhds.mp h, Set.eqOn_mulIndicator'.symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Indicator.lean", "context": {"open": ["Set", "scoped Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} [One \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nhx : x \u2209 frontier s\n\u22a2 ContinuousAt (s.mulIndicator f) x"}, {"line": "rw [\u2190 Set.mem_compl_iff] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nhx : x \u2208 (frontier s)\u1d9c\n\u22a2 ContinuousAt (s.mulIndicator f) x"}, {"line": "rw [compl_frontier_eq_union_interior] at hx", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nhx : x \u2208 interior s \u222a interior s\u1d9c\n\u22a2 ContinuousAt (s.mulIndicator f) x"}, {"line": "obtain h | h := hx", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nh : x \u2208 interior s\n\u22a2 ContinuousAt (s.mulIndicator f) x\n---\ncase inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nh : x \u2208 interior s\u1d9c\n\u22a2 ContinuousAt (s.mulIndicator f) x"}, {"line": "\u00b7 have hs : interior s \u2208 \ud835\udcdd x := mem_interior_iff_mem_nhds.mp (by rwa [interior_interior])\n    exact ContinuousAt.congr (hf.continuousAt hs) <| Filter.eventuallyEq_iff_exists_mem.mpr\n      \u27e8interior s, hs, Set.eqOn_mulIndicator.symm.mono interior_subset\u27e9", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2\ns : Set \u03b1\ninst\u271d : One \u03b2\nhf : ContinuousOn f (interior s)\nx : \u03b1\nh : x \u2208 interior s\u1d9c\n\u22a2 ContinuousAt (s.mulIndicator f) x"}, {"line": "\u00b7 exact ContinuousAt.congr continuousAt_const <| Filter.eventuallyEq_iff_exists_mem.mpr\n      \u27e8s\u1d9c, mem_interior_iff_mem_nhds.mp h, Set.eqOn_mulIndicator'.symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_nhds_mul (a b : M) : \ud835\udcdd a * \ud835\udcdd b \u2264 \ud835\udcdd (a * b) := by\n  rw [\u2190 map\u2082_mul]\n  rw [\u2190 map_uncurry_prod]\n  rw [\u2190 nhds_prod_eq]\n  exact continuous_mul.tendsto _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Mul M\ninst\u271d : ContinuousMul M\na b : M\n\u22a2 nhds a * nhds b \u2264 nhds (a * b)"}, {"line": "rw [\u2190 map\u2082_mul]", "tactic_state": "M : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Mul M\ninst\u271d : ContinuousMul M\na b : M\n\u22a2 map\u2082 (fun x1 x2 => x1 * x2) (nhds a) (nhds b) \u2264 nhds (a * b)"}, {"line": "rw [\u2190 map_uncurry_prod]", "tactic_state": "M : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Mul M\ninst\u271d : ContinuousMul M\na b : M\n\u22a2 map (Function.uncurry fun x1 x2 => x1 * x2) (nhds a \u00d7\u02e2 nhds b) \u2264 nhds (a * b)"}, {"line": "rw [\u2190 nhds_prod_eq]", "tactic_state": "M : Type u_3\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Mul M\ninst\u271d : ContinuousMul M\na b : M\n\u22a2 map (Function.uncurry fun x1 x2 => x1 * x2) (nhds (a, b)) \u2264 nhds (a * b)"}, {"line": "exact continuous_mul.tendsto _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_nhds_zero_of_disjoint_cocompact {l : Filter (M \u00d7 M)}\n    (hl : Disjoint l (cocompact (M \u00d7 M))) (h'l : l \u2264 (\ud835\udcdd 0).coprod (\ud835\udcdd 0)) :\n    Tendsto (fun x : M \u00d7 M \u21a6 x.1 * x.2) l (\ud835\udcdd 0) := by\n  simpa [inf_eq_right.mpr h'l] using tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nl : Filter (M \u00d7 M)\nhl : Disjoint l (cocompact (M \u00d7 M))\nh'l : l \u2264 (nhds 0).coprod (nhds 0)\n\u22a2 Tendsto (fun x => x.1 * x.2) l (nhds 0)"}, {"line": "simpa [inf_eq_right.mpr h'l] using tendsto_mul_coprod_nhds_zero_inf_of_disjoint_cocompact hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_mul_cofinite_nhds_zero {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M}\n    (hf : Tendsto f cofinite (\ud835\udcdd 0)) (hg : Tendsto g cofinite (\ud835\udcdd 0)) :\n    Tendsto (fun i : \u03b1 \u00d7 \u03b2 \u21a6 f i.1 * g i.2) cofinite (\ud835\udcdd 0) := by\n  letI : TopologicalSpace \u03b1 := \u22a5\n  haveI : DiscreteTopology \u03b1 := discreteTopology_bot \u03b1\n  letI : TopologicalSpace \u03b2 := \u22a5\n  haveI : DiscreteTopology \u03b2 := discreteTopology_bot \u03b2\n  rw [\u2190 cocompact_eq_cofinite] at *\n  exact tendsto_mul_cocompact_nhds_zero\n    continuous_of_discreteTopology continuous_of_discreteTopology hf hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nhf : Tendsto f cofinite (nhds 0)\nhg : Tendsto g cofinite (nhds 0)\n\u22a2 Tendsto (fun i => f i.1 * g i.2) cofinite (nhds 0)"}, {"line": "letI : TopologicalSpace \u03b1 := \u22a5", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nhf : Tendsto f cofinite (nhds 0)\nhg : Tendsto g cofinite (nhds 0)\nthis : TopologicalSpace \u03b1 := \u22a5\n\u22a2 Tendsto (fun i => f i.1 * g i.2) cofinite (nhds 0)"}, {"line": "haveI : DiscreteTopology \u03b1 := discreteTopology_bot \u03b1", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nhf : Tendsto f cofinite (nhds 0)\nhg : Tendsto g cofinite (nhds 0)\nthis\u271d : TopologicalSpace \u03b1 := \u22a5\nthis : DiscreteTopology \u03b1\n\u22a2 Tendsto (fun i => f i.1 * g i.2) cofinite (nhds 0)"}, {"line": "letI : TopologicalSpace \u03b2 := \u22a5", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nhf : Tendsto f cofinite (nhds 0)\nhg : Tendsto g cofinite (nhds 0)\nthis\u271d\u00b9 : TopologicalSpace \u03b1 := \u22a5\nthis\u271d : DiscreteTopology \u03b1\nthis : TopologicalSpace \u03b2 := \u22a5\n\u22a2 Tendsto (fun i => f i.1 * g i.2) cofinite (nhds 0)"}, {"line": "haveI : DiscreteTopology \u03b2 := discreteTopology_bot \u03b2", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nhf : Tendsto f cofinite (nhds 0)\nhg : Tendsto g cofinite (nhds 0)\nthis\u271d\u00b2 : TopologicalSpace \u03b1 := \u22a5\nthis\u271d\u00b9 : DiscreteTopology \u03b1\nthis\u271d : TopologicalSpace \u03b2 := \u22a5\nthis : DiscreteTopology \u03b2\n\u22a2 Tendsto (fun i => f i.1 * g i.2) cofinite (nhds 0)"}, {"line": "rw [\u2190 cocompact_eq_cofinite] at *", "tactic_state": "M : Type u_3\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Mul M\ninst\u271d\u00b3 : ContinuousMul M\n\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulZeroClass M\ninst\u271d : ContinuousMul M\nf : \u03b1 \u2192 M\ng : \u03b2 \u2192 M\nthis\u271d\u00b2 : TopologicalSpace \u03b1 := \u22a5\nhf : Tendsto f (cocompact \u03b1) (nhds 0)\nthis\u271d\u00b9 : DiscreteTopology \u03b1\nthis\u271d : TopologicalSpace \u03b2 := \u22a5\nhg : Tendsto g (cocompact \u03b2) (nhds 0)\nthis : DiscreteTopology \u03b2\n\u22a2 Tendsto (fun i => f i.1 * g i.2) (cocompact (\u03b1 \u00d7 \u03b2)) (nhds 0)"}, {"line": "exact tendsto_mul_cocompact_nhds_zero\n    continuous_of_discreteTopology continuous_of_discreteTopology hf hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U \u2208 \ud835\udcdd (1 : M)) :\n    \u2203 V : Set M, IsOpen V \u2227 (1 : M) \u2208 V \u2227 V * V \u2286 U := by\n  simpa only [mul_subset_iff] using exists_open_nhds_one_split hU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : Mul M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : MulZeroClass M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : MulOneClass M\ninst\u271d : ContinuousMul M\nU : Set M\nhU : U \u2208 nhds 1\n\u22a2 \u2203 V, IsOpen V \u2227 1 \u2208 V \u2227 V * V \u2286 U"}, {"line": "simpa only [mul_subset_iff] using exists_open_nhds_one_split hU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t) := by\n  rw [\u2190 image_mul_prod]\n  exact (hs.prod ht).image continuous_mul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]", "[TopologicalSpace M] [Semigroup M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : Mul M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulZeroClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : MulOneClass M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Semigroup M\ninst\u271d : ContinuousMul M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\n\u22a2 IsCompact (s * t)"}, {"line": "rw [\u2190 image_mul_prod]", "tactic_state": "M : Type u_3\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : Mul M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulZeroClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : MulOneClass M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Semigroup M\ninst\u271d : ContinuousMul M\ns t : Set M\nhs : IsCompact s\nht : IsCompact t\n\u22a2 IsCompact ((fun x => x.1 * x.2) '' s \u00d7\u02e2 t)"}, {"line": "exact (hs.prod ht).image continuous_mul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M) := by\n  refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_left b))\n  convert Filter.tendsto_id\n  ext x\n  simp [\u2190 mul_assoc, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]", "[TopologicalSpace M] [Semigroup M] [ContinuousMul M]", "[TopologicalSpace M] [Monoid M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Tendsto (fun x => a * x) (cocompact M) (cocompact M)"}, {"line": "refine Filter.Tendsto.of_tendsto_comp ?_ (Filter.comap_cocompact_le (continuous_mul_left b))", "tactic_state": "case refine_1\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Tendsto ((fun b_1 => b * b_1) \u2218 fun x => a * x) (cocompact M) (cocompact M)\n---\ncase refine_2\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Mul M"}, {"line": "convert Filter.tendsto_id", "tactic_state": "case h.e'_3\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 ((fun b_1 => b * b_1) \u2218 fun x => a * x) = id\n---\ncase refine_2\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Mul M"}, {"line": "ext x", "tactic_state": "case h.e'_3.h\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\nx : M\n\u22a2 ((fun b_1 => b * b_1) \u2218 fun x => a * x) x = id x\n---\ncase refine_2\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Mul M"}, {"line": "simp [\u2190 mul_assoc, ha]", "tactic_state": "case h.e'_3.h\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\nx : M\n\u22a2 b * (a * x) = x\n---\ncase refine_2\nM : Type u_3\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : Mul M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulZeroClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : MulOneClass M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Semigroup M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : Monoid M\ninst\u271d : ContinuousMul M\na b : M\nha : b * a = 1\n\u22a2 Mul M"}]}
{"declaration": "theorem LocallyFinite.exists_finset_mulSupport {M : Type*} [One M] {f : \u03b9 \u2192 X \u2192 M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x\u2080 : X) :\n    \u2203 I : Finset \u03b9, \u2200\u1da0 x in \ud835\udcdd x\u2080, (mulSupport fun i => f i x) \u2286 I := by\n  rcases hf x\u2080 with \u27e8U, hxU, hUf\u27e9\n  refine \u27e8hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_\u27e9\n  rw [hUf.coe_toFinset]\n  exact \u27e8y, hi, hy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter", "MulOpposite", "Function"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]", "[TopologicalSpace M] [Semigroup M] [ContinuousMul M]", "[TopologicalSpace M] [Monoid M] [ContinuousMul M]", "[TopologicalSpace \u03b1] [Monoid \u03b1] [ContinuousMul \u03b1]", "[TopologicalSpace M] [CommMonoid M]", "[ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nM : Type u_11\ninst\u271d : One M\nf : \u03b9 \u2192 X \u2192 M\nhf : LocallyFinite fun i => mulSupport (f i)\nx\u2080 : X\n\u22a2 \u2203 I, \u2200\u1da0 (x : X) in nhds x\u2080, (mulSupport fun i => f i x) \u2286 \u2191I"}, {"line": "rcases hf x\u2080 with \u27e8U, hxU, hUf\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nM : Type u_11\ninst\u271d : One M\nf : \u03b9 \u2192 X \u2192 M\nhf : LocallyFinite fun i => mulSupport (f i)\nx\u2080 : X\nU : Set X\nhxU : U \u2208 nhds x\u2080\nhUf : {i | ((fun i => mulSupport (f i)) i \u2229 U).Nonempty}.Finite\n\u22a2 \u2203 I, \u2200\u1da0 (x : X) in nhds x\u2080, (mulSupport fun i => f i x) \u2286 \u2191I"}, {"line": "refine \u27e8hUf.toFinset, mem_of_superset hxU fun y hy i hi => ?_\u27e9", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nM : Type u_11\ninst\u271d : One M\nf : \u03b9 \u2192 X \u2192 M\nhf : LocallyFinite fun i => mulSupport (f i)\nx\u2080 : X\nU : Set X\nhxU : U \u2208 nhds x\u2080\nhUf : {i | ((fun i => mulSupport (f i)) i \u2229 U).Nonempty}.Finite\ny : X\nhy : y \u2208 U\ni : \u03b9\nhi : i \u2208 mulSupport fun i => f i y\n\u22a2 i \u2208 \u2191hUf.toFinset"}, {"line": "rw [hUf.coe_toFinset]", "tactic_state": "case intro.intro\n\u03b9 : Type u_1\nX : Type u_5\ninst\u271d\u00b9 : TopologicalSpace X\nM : Type u_11\ninst\u271d : One M\nf : \u03b9 \u2192 X \u2192 M\nhf : LocallyFinite fun i => mulSupport (f i)\nx\u2080 : X\nU : Set X\nhxU : U \u2208 nhds x\u2080\nhUf : {i | ((fun i => mulSupport (f i)) i \u2229 U).Nonempty}.Finite\ny : X\nhy : y \u2208 U\ni : \u03b9\nhi : i \u2208 mulSupport fun i => f i y\n\u22a2 i \u2208 {i | ((fun i => mulSupport (f i)) i \u2229 U).Nonempty}"}, {"line": "exact \u27e8y, hi, hy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_finprod_cond {f : \u03b9 \u2192 X \u2192 M} {p : \u03b9 \u2192 Prop} (hc : \u2200 i, p i \u2192 Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => \u220f\u1da0 (i) (_ : p i), f i x := by\n  simp only [\u2190 finprod_subtype_eq_finprod_cond]\n  exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter", "MulOpposite", "Function"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]", "[TopologicalSpace M] [Semigroup M] [ContinuousMul M]", "[TopologicalSpace M] [Monoid M] [ContinuousMul M]", "[TopologicalSpace \u03b1] [Monoid \u03b1] [ContinuousMul \u03b1]", "[TopologicalSpace M] [CommMonoid M]", "[ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\nX : Type u_5\ninst\u271d\u00b9\u2078 : TopologicalSpace X\ninst\u271d\u00b9\u2077 : TopologicalSpace M\ninst\u271d\u00b9\u2076 : Mul M\ninst\u271d\u00b9\u2075 : ContinuousMul M\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : MulZeroClass M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulOneClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : Semigroup M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : ContinuousMul M\nf : \u03b9 \u2192 X \u2192 M\np : \u03b9 \u2192 Prop\nhc : \u2200 (i : \u03b9), p i \u2192 Continuous (f i)\nhf : LocallyFinite fun i => mulSupport (f i)\n\u22a2 Continuous fun x => \u220f\u1da0 (i : \u03b9) (_ : p i), f i x"}, {"line": "simp only [\u2190 finprod_subtype_eq_finprod_cond]", "tactic_state": "\u03b9 : Type u_1\nM : Type u_3\nX : Type u_5\ninst\u271d\u00b9\u2078 : TopologicalSpace X\ninst\u271d\u00b9\u2077 : TopologicalSpace M\ninst\u271d\u00b9\u2076 : Mul M\ninst\u271d\u00b9\u2075 : ContinuousMul M\ninst\u271d\u00b9\u2074 : TopologicalSpace M\ninst\u271d\u00b9\u00b3 : MulZeroClass M\ninst\u271d\u00b9\u00b2 : ContinuousMul M\ninst\u271d\u00b9\u00b9 : TopologicalSpace M\ninst\u271d\u00b9\u2070 : MulOneClass M\ninst\u271d\u2079 : ContinuousMul M\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : Semigroup M\ninst\u271d\u2076 : ContinuousMul M\ninst\u271d\u2075 : TopologicalSpace M\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : ContinuousMul M\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : CommMonoid M\ninst\u271d : ContinuousMul M\nf : \u03b9 \u2192 X \u2192 M\np : \u03b9 \u2192 Prop\nhc : \u2200 (i : \u03b9), p i \u2192 Continuous (f i)\nhf : LocallyFinite fun i => mulSupport (f i)\n\u22a2 Continuous fun x => \u220f\u1da0 (j : Subtype p), f (\u2191j) x"}, {"line": "exact continuous_finprod (fun i => hc i i.2) (hf.comp_injective Subtype.coe_injective)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousMul_iInf {ts : \u03b9' \u2192 TopologicalSpace M}\n    (h' : \u2200 i, @ContinuousMul M (ts i) _) : @ContinuousMul M (\u2a05 i, ts i) _ := by\n  rw [\u2190 sInf_range]\n  exact continuousMul_sInf (Set.forall_mem_range.mpr h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Monoid.lean", "context": {"open": ["Set Filter TopologicalSpace Topology", "scoped Topology Pointwise", "Filter", "Function", "Filter", "MulOpposite", "Function"], "variables": ["{\u03b9 \u03b1 M N X : Type*} [TopologicalSpace X]", "[TopologicalSpace M] [Mul M] [ContinuousMul M]", "{\ud835\udd5c : Type*} [Preorder \ud835\udd5c] [Zero \ud835\udd5c] [Mul \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousMul \ud835\udd5c]", "(M\u2081 M\u2082 : Type*) [TopologicalSpace M\u2082] [T2Space M\u2082]", "{M\u2081 M\u2082} [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{M\u2081 M\u2082} [MulOneClass M\u2081] [MulOneClass M\u2082] [ContinuousMul M\u2082]", "(M\u2081 M\u2082)", "{\u03b1 \u03b2 : Type*}", "[TopologicalSpace M] [MulZeroClass M] [ContinuousMul M]", "[TopologicalSpace M] [MulOneClass M] [ContinuousMul M]", "[TopologicalSpace M] [Semigroup M] [ContinuousMul M]", "[TopologicalSpace M] [Monoid M] [ContinuousMul M]", "[TopologicalSpace \u03b1] [Monoid \u03b1] [ContinuousMul \u03b1]", "[TopologicalSpace M] [CommMonoid M]", "[ContinuousMul M]", "{\u03b9' : Sort*} [Mul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\ninst\u271d\u00b9\u2078 : TopologicalSpace M\ninst\u271d\u00b9\u2077 : Mul M\ninst\u271d\u00b9\u2076 : ContinuousMul M\ninst\u271d\u00b9\u2075 : TopologicalSpace M\ninst\u271d\u00b9\u2074 : MulZeroClass M\ninst\u271d\u00b9\u00b3 : ContinuousMul M\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\ninst\u271d\u00b9\u00b9 : MulOneClass M\ninst\u271d\u00b9\u2070 : ContinuousMul M\ninst\u271d\u2079 : TopologicalSpace M\ninst\u271d\u2078 : Semigroup M\ninst\u271d\u2077 : ContinuousMul M\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : ContinuousMul M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : ContinuousMul M\n\u03b9' : Sort u_11\ninst\u271d : Mul M\nts : \u03b9' \u2192 TopologicalSpace M\nh' : \u2200 (i : \u03b9'), ContinuousMul M\n\u22a2 ContinuousMul M"}, {"line": "rw [\u2190 sInf_range]", "tactic_state": "M : Type u_3\ninst\u271d\u00b9\u2078 : TopologicalSpace M\ninst\u271d\u00b9\u2077 : Mul M\ninst\u271d\u00b9\u2076 : ContinuousMul M\ninst\u271d\u00b9\u2075 : TopologicalSpace M\ninst\u271d\u00b9\u2074 : MulZeroClass M\ninst\u271d\u00b9\u00b3 : ContinuousMul M\ninst\u271d\u00b9\u00b2 : TopologicalSpace M\ninst\u271d\u00b9\u00b9 : MulOneClass M\ninst\u271d\u00b9\u2070 : ContinuousMul M\ninst\u271d\u2079 : TopologicalSpace M\ninst\u271d\u2078 : Semigroup M\ninst\u271d\u2077 : ContinuousMul M\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : Monoid M\ninst\u271d\u2074 : ContinuousMul M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : CommMonoid M\ninst\u271d\u00b9 : ContinuousMul M\n\u03b9' : Sort u_11\ninst\u271d : Mul M\nts : \u03b9' \u2192 TopologicalSpace M\nh' : \u2200 (i : \u03b9'), ContinuousMul M\n\u22a2 ContinuousMul M"}, {"line": "exact continuousMul_sInf (Set.forall_mem_range.mpr h')", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsCompact.smul_set {k : Set M} {u : Set X} (hk : IsCompact k) (hu : IsCompact u) :\n    IsCompact (k \u2022 u) := by\n  rw [\u2190 Set.image_smul_prod]\n  exact IsCompact.image (hk.prod hu) continuous_smul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/MulAction.lean", "context": {"open": ["Topology Pointwise", "Filter"], "variables": ["{M X Y \u03b1 : Type*} [TopologicalSpace M] [TopologicalSpace X] [TopologicalSpace Y]", "[SMul M X] [ContinuousSMul M X]", "{f : Y \u2192 M} {g : Y \u2192 X} {b : Y} {s : Set Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nX : Type u_2\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : SMul M X\ninst\u271d : ContinuousSMul M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n\u22a2 IsCompact (k \u2022 u)"}, {"line": "rw [\u2190 Set.image_smul_prod]", "tactic_state": "M : Type u_1\nX : Type u_2\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : SMul M X\ninst\u271d : ContinuousSMul M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n\u22a2 IsCompact ((fun x => x.1 \u2022 x.2) '' k \u00d7\u02e2 u)"}, {"line": "exact IsCompact.image (hk.prod hu) continuous_smul", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Topology.IsInducing.continuousSMul {N : Type*} [SMul N Y] [TopologicalSpace N] {f : N \u2192 M}\n    (hg : IsInducing g) (hf : Continuous f) (hsmul : \u2200 {c x}, g (c \u2022 x) = f c \u2022 g x) :\n    ContinuousSMul N Y where\n  continuous_smul := by\n    simpa only [hg.continuous_iff,Function.comp_def,hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/MulAction.lean", "context": {"open": ["Topology Pointwise", "Filter"], "variables": ["{M X Y \u03b1 : Type*} [TopologicalSpace M] [TopologicalSpace X] [TopologicalSpace Y]", "[SMul M X] [ContinuousSMul M X]", "{f : Y \u2192 M} {g : Y \u2192 X} {b : Y} {s : Set Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nX : Type u_2\nY : Type u_3\ninst\u271d\u2076 : TopologicalSpace M\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : SMul M X\ninst\u271d\u00b2 : ContinuousSMul M X\ng : Y \u2192 X\nN : Type u_5\ninst\u271d\u00b9 : SMul N Y\ninst\u271d : TopologicalSpace N\nf : N \u2192 M\nhg : IsInducing g\nhf : Continuous f\nhsmul : \u2200 {c : N} {x : Y}, g (c \u2022 x) = f c \u2022 g x\n\u22a2 Continuous fun p => p.1 \u2022 p.2"}, {"line": "simpa only [hg.continuous_iff,Function.comp_def,hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N \u2192* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X := by\n  let _ : MulAction N X := MulAction.compHom _ f\n  exact \u27e8(hf.comp continuous_fst).smul continuous_snd\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/MulAction.lean", "context": {"open": ["Topology Pointwise", "Filter"], "variables": ["{M X Y \u03b1 : Type*} [TopologicalSpace M] [TopologicalSpace X] [TopologicalSpace Y]", "[SMul M X] [ContinuousSMul M X]", "{f : Y \u2192 M} {g : Y \u2192 X} {b : Y} {s : Set Y}", "[Monoid M] [MulAction M X] [ContinuousSMul M X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\nX : Type u_2\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : SMul M X\ninst\u271d\u2075 : ContinuousSMul M X\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : MulAction M X\ninst\u271d\u00b2 : ContinuousSMul M X\nN : Type u_5\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : Monoid N\nf : N \u2192* M\nhf : Continuous \u21d1f\n\u22a2 ContinuousSMul N X"}, {"line": "let _ : MulAction N X := MulAction.compHom _ f", "tactic_state": "M : Type u_1\nX : Type u_2\ninst\u271d\u2078 : TopologicalSpace M\ninst\u271d\u2077 : TopologicalSpace X\ninst\u271d\u2076 : SMul M X\ninst\u271d\u2075 : ContinuousSMul M X\ninst\u271d\u2074 : Monoid M\ninst\u271d\u00b3 : MulAction M X\ninst\u271d\u00b2 : ContinuousSMul M X\nN : Type u_5\ninst\u271d\u00b9 : TopologicalSpace N\ninst\u271d : Monoid N\nf : N \u2192* M\nhf : Continuous \u21d1f\nx\u271d : sorry := sorry\n\u22a2 ContinuousSMul N X"}, {"line": "exact \u27e8(hf.comp continuous_fst).smul continuous_snd\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedEmbedding_coe (x : A) : Topology.IsClosedEmbedding ((\u2191) : elemental R x \u2192 A) where\n  eq_induced := rfl\n  injective := Subtype.coe_injective\n  isClosed_range := by simpa using isClosed R x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/NonUnitalAlgebra.lean", "context": {"open": ["NonUnitalSubalgebra"], "variables": ["{R A : Type*} [CommSemiring R] [TopologicalSpace A]", "[NonUnitalSemiring A] [Module R A] [IsTopologicalSemiring A]", "[ContinuousConstSMul R A]", "{R A : Type*} [CommRing R] [TopologicalSpace A]", "[NonUnitalRing A] [Module R A] [IsTopologicalRing A]", "[ContinuousConstSMul R A]", "(R : Type*) {A : Type*} [CommSemiring R] [NonUnitalSemiring A]", "[Module R A] [IsScalarTower R A A] [SMulCommClass R A A]", "[TopologicalSpace A] [IsTopologicalSemiring A] [ContinuousConstSMul R A]", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_6\ninst\u271d\u00b2 : NonUnitalSemiring A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : IsTopologicalSemiring A\nx\u271d : Sort u_7\nelemental : x\u271d\nx : A\n\u22a2 IsClosed (Set.range fun a => \u2191a)"}, {"line": "simpa using isClosed R x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedEmbedding_coe (x : A) : Topology.IsClosedEmbedding ((\u2191) : elemental R x \u2192 A) where\n  eq_induced := rfl\n  injective := Subtype.coe_injective\n  isClosed_range := by simpa using isClosed R x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/NonUnitalStarAlgebra.lean", "context": {"open": ["NonUnitalStarSubalgebra"], "variables": ["{R A : Type*} [CommSemiring R] [TopologicalSpace A] [Star A]", "[NonUnitalSemiring A] [Module R A] [IsTopologicalSemiring A] [ContinuousStar A]", "[ContinuousConstSMul R A]", "{R A : Type*} [CommRing R] [TopologicalSpace A]", "[NonUnitalRing A] [Module R A] [Star A] [IsTopologicalRing A] [ContinuousStar A]", "[ContinuousConstSMul R A]", "(R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [NonUnitalSemiring A] [StarRing A]", "[Module R A] [IsScalarTower R A A] [SMulCommClass R A A] [StarModule R A]", "[TopologicalSpace A] [IsTopologicalSemiring A] [ContinuousConstSMul R A] [ContinuousStar A]", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_6\ninst\u271d\u2074 : NonUnitalSemiring A\ninst\u271d\u00b3 : StarRing A\ninst\u271d\u00b2 : TopologicalSpace A\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : ContinuousStar A\nx\u271d : Sort u_7\nelemental : x\u271d\nx : A\n\u22a2 IsClosed (Set.range fun a => \u2191a)"}, {"line": "simpa using isClosed R x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedEmbedding_coe (x : A) : IsClosedEmbedding ((\u2191) : elemental R x \u2192 A) where\n  eq_induced := rfl\n  injective := Subtype.coe_injective\n  isClosed_range := by simpa using isClosed R x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/StarSubalgebra.lean", "context": {"open": ["Topology", "StarSubalgebra"], "variables": ["{R A B : Type*} [CommSemiring R] [StarRing R]", "[TopologicalSpace A] [Semiring A] [Algebra R A] [StarRing A] [StarModule R A]", "[IsTopologicalSemiring A] [ContinuousStar A]", "[TopologicalSpace B] [Semiring B] [Algebra R B] [StarRing B]", "(R : Type*) {A B : Type*} [CommSemiring R] [StarRing R]", "[TopologicalSpace A] [Semiring A] [StarRing A] [IsTopologicalSemiring A]", "[ContinuousStar A] [Algebra R A] [StarModule R A]", "[TopologicalSpace B] [Semiring B] [StarRing B] [Algebra R B]", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_5\ninst\u271d\u2074 : TopologicalSpace A\ninst\u271d\u00b3 : Semiring A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : ContinuousStar A\nx\u271d : Sort u_7\nelemental : x\u271d\nx : A\n\u22a2 IsClosed (Set.range fun a => \u2191a)"}, {"line": "simpa using isClosed R x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem UniformContinuous.div_const' {R \u03b2 : Type*} [DivisionRing R] [UniformSpace R]\n    [UniformContinuousConstSMul R\u1d50\u1d52\u1d56 R] [UniformSpace \u03b2] {f : \u03b2 \u2192 R}\n    (hf : UniformContinuous f) (a : R) :\n    UniformContinuous fun x \u21a6 f x / a := by\n  simpa [div_eq_mul_inv] using hf.mul_const' a\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/UniformMulAction.lean", "context": {"open": [], "variables": ["(R : Type u) (M : Type v) (N : Type w) (X : Type x) (Y : Type y) [UniformSpace X]", "[SMul M X]", "{M X Y}", "{R \u03b2 : Type*} [Ring R] [UniformSpace R] [UniformSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\n\u03b2 : Type u_4\ninst\u271d\u00b3 : DivisionRing R\ninst\u271d\u00b2 : UniformSpace R\ninst\u271d\u00b9 : UniformContinuousConstSMul R\u1d50\u1d52\u1d56 R\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 R\nhf : UniformContinuous f\na : R\n\u22a2 UniformContinuous fun x => f x / a"}, {"line": "simpa [div_eq_mul_inv] using hf.mul_const' a\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_algebraMap [ContinuousSMul R A] : Continuous (algebraMap R A) := by\n  rw [algebraMap_eq_smul_one']\n  exact continuous_id.smul continuous_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Algebra.lean", "context": {"open": ["Algebra Set TopologicalSpace Topology"], "variables": ["(R : Type*) (A : Type u)", "[CommSemiring R] [Semiring A] [Algebra R A]", "[TopologicalSpace R] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Semiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : ContinuousSMul R A\n\u22a2 Continuous \u21d1(algebraMap R A)"}, {"line": "rw [algebraMap_eq_smul_one']", "tactic_state": "R : Type u_1\nA : Type u\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Semiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : ContinuousSMul R A\n\u22a2 Continuous fun r => r \u2022 1"}, {"line": "exact continuous_id.smul continuous_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_algebraMap_iff_smul [ContinuousMul A] :\n    Continuous (algebraMap R A) \u2194 Continuous fun p : R \u00d7 A => p.1 \u2022 p.2 := by\n  refine \u27e8fun h => ?_, fun h => have : ContinuousSMul R A := \u27e8h\u27e9; continuous_algebraMap _ _\u27e9\n  simp only [Algebra.smul_def]\n  exact (h.comp continuous_fst).mul continuous_snd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Algebra.lean", "context": {"open": ["Algebra Set TopologicalSpace Topology"], "variables": ["(R : Type*) (A : Type u)", "[CommSemiring R] [Semiring A] [Algebra R A]", "[TopologicalSpace R] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nA : Type u\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Semiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : ContinuousMul A\n\u22a2 Continuous \u21d1(algebraMap R A) \u2194 Continuous fun p => p.1 \u2022 p.2"}, {"line": "refine \u27e8fun h => ?_, fun h => have : ContinuousSMul R A := \u27e8h\u27e9; continuous_algebraMap _ _\u27e9", "tactic_state": "R : Type u_1\nA : Type u\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Semiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : ContinuousMul A\nh : Continuous \u21d1(algebraMap R A)\n\u22a2 Continuous fun p => p.1 \u2022 p.2"}, {"line": "simp only [Algebra.smul_def]", "tactic_state": "R : Type u_1\nA : Type u\ninst\u271d\u2075 : CommSemiring R\ninst\u271d\u2074 : Semiring A\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : ContinuousMul A\nh : Continuous \u21d1(algebraMap R A)\n\u22a2 Continuous fun p => (algebraMap R A) p.1 * p.2"}, {"line": "exact (h.comp continuous_fst).mul continuous_snd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.DenseRange.topologicalClosure_map_subalgebra\n    [IsTopologicalSemiring B] {f : A \u2192A[R] B} (hf' : DenseRange f) {s : Subalgebra R A}\n    (hs : s.topologicalClosure = \u22a4) : (s.map (f : A \u2192\u2090[R] B)).topologicalClosure = \u22a4 := by\n  rw [SetLike.ext'_iff] at hs \u22a2\n  simp only [Subalgebra.topologicalClosure_coe] at hs \u22a2\n  simp only [coe_top] at hs \u22a2\n  simp only [\u2190 dense_iff_closure_eq] at hs \u22a2\n  simp only [Subalgebra.coe_map] at hs \u22a2\n  simp only [AlgHom.coe_coe] at hs \u22a2\n  exact hf'.dense_image f.continuous hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Algebra.lean", "context": {"open": ["Algebra Set TopologicalSpace Topology"], "variables": ["(R : Type*) (A : Type u)", "[CommSemiring R] [Semiring A] [Algebra R A]", "[TopologicalSpace R] [TopologicalSpace A]", "[ContinuousSMul R A]", "(R : Type*) [CommSemiring R]", "{R} {A}", "[TopologicalSpace A]", "{B : Type*} [Semiring B] [TopologicalSpace B] [Algebra R A] [Algebra R B]", "[IsTopologicalSemiring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : s.topologicalClosure = \u22a4\n\u22a2 (Subalgebra.map (\u2191f) s).topologicalClosure = \u22a4"}, {"line": "rw [SetLike.ext'_iff] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : \u2191s.topologicalClosure = \u2191\u22a4\n\u22a2 \u2191(Subalgebra.map (\u2191f) s).topologicalClosure = \u2191\u22a4"}, {"line": "simp only [Subalgebra.topologicalClosure_coe] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : closure \u2191s = \u2191\u22a4\n\u22a2 closure \u2191(Subalgebra.map (\u2191f) s) = \u2191\u22a4"}, {"line": "simp only [coe_top] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : closure \u2191s = univ\n\u22a2 closure \u2191(Subalgebra.map (\u2191f) s) = univ"}, {"line": "simp only [\u2190 dense_iff_closure_eq] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : Dense \u2191s\n\u22a2 Dense \u2191(Subalgebra.map (\u2191f) s)"}, {"line": "simp only [Subalgebra.coe_map] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : Dense \u2191s\n\u22a2 Dense (\u21d1\u2191f '' \u2191s)"}, {"line": "simp only [AlgHom.coe_coe] at hs \u22a2", "tactic_state": "A : Type u\ninst\u271d\u2079 : Semiring A\ninst\u271d\u2078 : TopologicalSpace A\nR : Type u_2\ninst\u271d\u2077 : CommSemiring R\ninst\u271d\u2076 : TopologicalSpace A\nB : Type u_3\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace B\ninst\u271d\u00b3 : Algebra R A\ninst\u271d\u00b2 : Algebra R B\ninst\u271d\u00b9 : IsTopologicalSemiring A\ninst\u271d : IsTopologicalSemiring B\nf : A \u2192A[R] B\nhf' : DenseRange \u21d1f\ns : Subalgebra R A\nhs : Dense \u2191s\n\u22a2 Dense ((fun a => f a) '' \u2191s)"}, {"line": "exact hf'.dense_image f.continuous hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedEmbedding_coe (x : A) : IsClosedEmbedding ((\u2191) : elemental R x \u2192 A) where\n  eq_induced := rfl\n  injective := Subtype.coe_injective\n  isClosed_range := by simpa using isClosed R x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Algebra.lean", "context": {"open": ["Algebra Set TopologicalSpace Topology", "Subalgebra"], "variables": ["(R : Type*) (A : Type u)", "[CommSemiring R] [Semiring A] [Algebra R A]", "[TopologicalSpace R] [TopologicalSpace A]", "[ContinuousSMul R A]", "(R : Type*) [CommSemiring R]", "{R} {A}", "[TopologicalSpace A]", "{B : Type*} [Semiring B] [TopologicalSpace B] [Algebra R A] [Algebra R B]", "[IsTopologicalSemiring A]", "[TopologicalSpace A]", "[Algebra R A]", "{R} {A}", "[TopologicalSpace A]", "{B : Type*} [Semiring B] [TopologicalSpace B] [Algebra R A] [Algebra R B]", "{R} {A}", "[TopologicalSpace A]", "{B : Type*} [Semiring B] [TopologicalSpace B] [Algebra R A] [Algebra R B]", "{F : Type*}", "(R A B)", "{R A B}", "{R A}", "[TopologicalSpace A]", "{B : Type*} [Semiring B] [TopologicalSpace B] [Algebra R A] [Algebra R B]", "{S : Type*} [Ring S] [TopologicalSpace S] [Algebra R S] {B : Type*} [Ring B]", "{S : Type*} [CommSemiring S] [Algebra R S] {B : Type*} [Ring B] [TopologicalSpace B]", "{R}", "{R : Type*} [CommSemiring R]", "{A : Type u} [TopologicalSpace A]", "[Semiring A] [Algebra R A]", "[IsTopologicalSemiring A]", "(R)", "{R} in", "{R} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\ninst\u271d\u2074 : CommSemiring R\nA : Type u\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : Semiring A\ninst\u271d\u00b9 : Algebra R A\ninst\u271d : IsTopologicalSemiring A\nx : A\n\u22a2 IsClosed (range Subtype.val)"}, {"line": "simpa using isClosed R x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Topology.IsInducing.continuousConstSMul {N \u03b2 : Type*} [SMul N \u03b2] [TopologicalSpace \u03b2]\n    {g : \u03b2 \u2192 \u03b1} (hg : IsInducing g) (f : N \u2192 M) (hf : \u2200 {c : N} {x : \u03b2}, g (c \u2022 x) = f c \u2022 g x) :\n    ContinuousConstSMul N \u03b2 where\n  continuous_const_smul c := by\n    simpa only [Function.comp_def,hf,hg.continuous_iff] using hg.continuous.const_smul (f c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/ConstMulAction.lean", "context": {"open": ["Topology Pointwise Filter Set TopologicalSpace"], "variables": ["{M \u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [SMul M \u03b1] [ContinuousConstSMul M \u03b1]", "[TopologicalSpace \u03b2] {g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : SMul M \u03b1\ninst\u271d\u00b2 : ContinuousConstSMul M \u03b1\nN : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : SMul N \u03b2\ninst\u271d : TopologicalSpace \u03b2\ng : \u03b2 \u2192 \u03b1\nhg : IsInducing g\nf : N \u2192 M\nhf : \u2200 {c : N} {x : \u03b2}, g (c \u2022 x) = f c \u2022 g x\nc : N\n\u22a2 Continuous fun x => c \u2022 x"}, {"line": "simpa only [Function.comp_def,hf,hg.continuous_iff] using hg.continuous.const_smul (f c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.smul_left {s : Set G} {t : Set \u03b1} (ht : IsOpen t) : IsOpen (s \u2022 t) := by\n  rw [\u2190 iUnion_smul_set]\n  exact isOpen_biUnion fun a _ => ht.smul _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/ConstMulAction.lean", "context": {"open": ["Topology Pointwise Filter Set TopologicalSpace"], "variables": ["{M \u03b1 \u03b2 : Type*}", "[TopologicalSpace \u03b1] [SMul M \u03b1] [ContinuousConstSMul M \u03b1]", "[TopologicalSpace \u03b2] {g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2}", "[TopologicalSpace \u03b1]", "[Monoid M] [MulAction M \u03b1] [ContinuousConstSMul M \u03b1]", "{G : Type*} [TopologicalSpace \u03b1] [Group G] [MulAction G \u03b1] [ContinuousConstSMul G \u03b1]", "[TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace \u03b1\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : ContinuousConstSMul G \u03b1\ns : Set G\nt : Set \u03b1\nht : IsOpen t\n\u22a2 IsOpen (s \u2022 t)"}, {"line": "rw [\u2190 iUnion_smul_set]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u2075 inst\u271d\u2074 : TopologicalSpace \u03b1\nG : Type u_4\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : MulAction G \u03b1\ninst\u271d : ContinuousConstSMul G \u03b1\ns : Set G\nt : Set \u03b1\nht : IsOpen t\n\u22a2 IsOpen (\u22c3 a \u2208 s, a \u2022 t)"}, {"line": "exact isOpen_biUnion fun a _ => ht.smul _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toAffineMap_injective {f g : P \u2192\u1d2c[R] Q} (h : (f : P \u2192\u1d43[R] Q) = (g : P \u2192\u1d43[R] Q)) :\n    f = g := by\n  cases f\n  cases g\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/ContinuousAffineMap.lean", "context": {"open": [], "variables": ["{R V W P Q : Type*} [Ring R]", "[AddCommGroup V] [Module R V] [TopologicalSpace P] [AddTorsor V P]", "[AddCommGroup W] [Module R W] [TopologicalSpace Q] [AddTorsor W Q]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nV : Type u_2\nW : Type u_3\nP : Type u_4\nQ : Type u_5\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : TopologicalSpace P\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup W\ninst\u271d\u00b2 : Module R W\ninst\u271d\u00b9 : TopologicalSpace Q\ninst\u271d : AddTorsor W Q\nf g : P \u2192\u1d2c[R] Q\nh : \u2191f = \u2191g\n\u22a2 f = g"}, {"line": "cases f", "tactic_state": "case mk\nR : Type u_1\nV : Type u_2\nW : Type u_3\nP : Type u_4\nQ : Type u_5\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : TopologicalSpace P\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup W\ninst\u271d\u00b2 : Module R W\ninst\u271d\u00b9 : TopologicalSpace Q\ninst\u271d : AddTorsor W Q\ng : P \u2192\u1d2c[R] Q\ntoAffineMap\u271d : P \u2192\u1d43[R] Q\ncont\u271d : Continuous toAffineMap\u271d.toFun\nh : \u2191{ toAffineMap := toAffineMap\u271d, cont := cont\u271d } = \u2191g\n\u22a2 { toAffineMap := toAffineMap\u271d, cont := cont\u271d } = g"}, {"line": "cases g", "tactic_state": "case mk.mk\nR : Type u_1\nV : Type u_2\nW : Type u_3\nP : Type u_4\nQ : Type u_5\ninst\u271d\u2078 : Ring R\ninst\u271d\u2077 : AddCommGroup V\ninst\u271d\u2076 : Module R V\ninst\u271d\u2075 : TopologicalSpace P\ninst\u271d\u2074 : AddTorsor V P\ninst\u271d\u00b3 : AddCommGroup W\ninst\u271d\u00b2 : Module R W\ninst\u271d\u00b9 : TopologicalSpace Q\ninst\u271d : AddTorsor W Q\ntoAffineMap\u271d\u00b9 : P \u2192\u1d43[R] Q\ncont\u271d\u00b9 : Continuous toAffineMap\u271d\u00b9.toFun\ntoAffineMap\u271d : P \u2192\u1d43[R] Q\ncont\u271d : Continuous toAffineMap\u271d.toFun\nh : \u2191{ toAffineMap := toAffineMap\u271d\u00b9, cont := cont\u271d\u00b9 } = \u2191{ toAffineMap := toAffineMap\u271d, cont := cont\u271d }\n\u22a2 { toAffineMap := toAffineMap\u271d\u00b9, cont := cont\u271d\u00b9 } = { toAffineMap := toAffineMap\u271d, cont := cont\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.div_const {x : G\u2080} (hf : Tendsto f l (\ud835\udcdd x)) (y : G\u2080) :\n    Tendsto (fun a => f a / y) l (\ud835\udcdd (x / y)) := by\n  simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b2 : DivInvMonoid G\u2080\ninst\u271d\u00b9 : TopologicalSpace G\u2080\ninst\u271d : ContinuousMul G\u2080\nf : \u03b1 \u2192 G\u2080\nl : Filter \u03b1\nx : G\u2080\nhf : Tendsto f l (nhds x)\ny : G\u2080\n\u22a2 Tendsto (fun a => f a / y) l (nhds (x / y))"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul tendsto_const_nhds", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousOn.div_const (hf : ContinuousOn f s) (y : G\u2080) :\n    ContinuousOn (fun x => f x / y) s := by\n  simpa only [div_eq_mul_inv] using hf.mul continuousOn_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b3 : DivInvMonoid G\u2080\ninst\u271d\u00b2 : TopologicalSpace G\u2080\ninst\u271d\u00b9 : ContinuousMul G\u2080\nf : \u03b1 \u2192 G\u2080\ns : Set \u03b1\ninst\u271d : TopologicalSpace \u03b1\nhf : ContinuousOn f s\ny : G\u2080\n\u22a2 ContinuousOn (fun x => f x / y) s"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul continuousOn_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.div_const (hf : Continuous f) (y : G\u2080) : Continuous fun x => f x / y := by\n  simpa only [div_eq_mul_inv] using hf.mul continuous_const\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}", "[TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b3 : DivInvMonoid G\u2080\ninst\u271d\u00b2 : TopologicalSpace G\u2080\ninst\u271d\u00b9 : ContinuousMul G\u2080\nf : \u03b1 \u2192 G\u2080\ninst\u271d : TopologicalSpace \u03b1\nhf : Continuous f\ny : G\u2080\n\u22a2 Continuous fun x => f x / y"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul continuous_const", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.div {l : Filter \u03b1} {a b : G\u2080} (hf : Tendsto f l (\ud835\udcdd a))\n    (hg : Tendsto g l (\ud835\udcdd b)) (hy : b \u2260 0) : Tendsto (f / g) l (\ud835\udcdd (a / b)) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[Zero G\u2080] [Inv G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {l : Filter \u03b1} {f : \u03b1 \u2192 G\u2080}", "[TopologicalSpace \u03b1]", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {x : G\u2080}", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] [ContinuousMul G\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b9\u2075 : DivInvMonoid G\u2080\ninst\u271d\u00b9\u2074 : TopologicalSpace G\u2080\ninst\u271d\u00b9\u00b3 : ContinuousMul G\u2080\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : Zero G\u2080\ninst\u271d\u00b9\u2070 : Inv G\u2080\ninst\u271d\u2079 : TopologicalSpace G\u2080\ninst\u271d\u2078 : HasContinuousInv\u2080 G\u2080\nf : \u03b1 \u2192 G\u2080\ninst\u271d\u2077 : TopologicalSpace \u03b1\ninst\u271d\u2076 : GroupWithZero G\u2080\ninst\u271d\u2075 : TopologicalSpace G\u2080\ninst\u271d\u2074 : HasContinuousInv\u2080 G\u2080\ninst\u271d\u00b3 : GroupWithZero G\u2080\ninst\u271d\u00b2 : TopologicalSpace G\u2080\ninst\u271d\u00b9 : HasContinuousInv\u2080 G\u2080\ninst\u271d : ContinuousMul G\u2080\ng : \u03b1 \u2192 G\u2080\nl : Filter \u03b1\na b : G\u2080\nhf : Tendsto f l (nhds a)\nhg : Tendsto g l (nhds b)\nhy : b \u2260 0\n\u22a2 Tendsto (f / g) l (nhds (a / b))"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.div (hf : Continuous f) (hg : Continuous g) (h\u2080 : \u2200 x, g x \u2260 0) :\n    Continuous (f / g) := by simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[Zero G\u2080] [Inv G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {l : Filter \u03b1} {f : \u03b1 \u2192 G\u2080}", "[TopologicalSpace \u03b1]", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {x : G\u2080}", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] [ContinuousMul G\u2080]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b9\u2076 : DivInvMonoid G\u2080\ninst\u271d\u00b9\u2075 : TopologicalSpace G\u2080\ninst\u271d\u00b9\u2074 : ContinuousMul G\u2080\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Zero G\u2080\ninst\u271d\u00b9\u00b9 : Inv G\u2080\ninst\u271d\u00b9\u2070 : TopologicalSpace G\u2080\ninst\u271d\u2079 : HasContinuousInv\u2080 G\u2080\nf : \u03b1 \u2192 G\u2080\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : GroupWithZero G\u2080\ninst\u271d\u2076 : TopologicalSpace G\u2080\ninst\u271d\u2075 : HasContinuousInv\u2080 G\u2080\ninst\u271d\u2074 : GroupWithZero G\u2080\ninst\u271d\u00b3 : TopologicalSpace G\u2080\ninst\u271d\u00b2 : HasContinuousInv\u2080 G\u2080\ninst\u271d\u00b9 : ContinuousMul G\u2080\ninst\u271d : TopologicalSpace \u03b1\ng : \u03b1 \u2192 G\u2080\nhf : Continuous f\nhg : Continuous g\nh\u2080 : \u2200 (x : \u03b1), g x \u2260 0\n\u22a2 Continuous (f / g)"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.div\u2080 (hf : Continuous f) (hg : Continuous g) (h\u2080 : \u2200 x, g x \u2260 0) :\n    Continuous (fun x => f x / g x) := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/GroupWithZero.lean", "context": {"open": ["Topology Filter Function"], "variables": ["{\u03b1 \u03b2 G\u2080 : Type*}", "[DivInvMonoid G\u2080] [TopologicalSpace G\u2080] [ContinuousMul G\u2080] {f : \u03b1 \u2192 G\u2080} {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[Zero G\u2080] [Inv G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {l : Filter \u03b1} {f : \u03b1 \u2192 G\u2080}", "[TopologicalSpace \u03b1]", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] {x : G\u2080}", "[GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] [ContinuousMul G\u2080]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nG\u2080 : Type u_3\ninst\u271d\u00b9\u2076 : DivInvMonoid G\u2080\ninst\u271d\u00b9\u2075 : TopologicalSpace G\u2080\ninst\u271d\u00b9\u2074 : ContinuousMul G\u2080\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : Zero G\u2080\ninst\u271d\u00b9\u00b9 : Inv G\u2080\ninst\u271d\u00b9\u2070 : TopologicalSpace G\u2080\ninst\u271d\u2079 : HasContinuousInv\u2080 G\u2080\nf : \u03b1 \u2192 G\u2080\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : GroupWithZero G\u2080\ninst\u271d\u2076 : TopologicalSpace G\u2080\ninst\u271d\u2075 : HasContinuousInv\u2080 G\u2080\ninst\u271d\u2074 : GroupWithZero G\u2080\ninst\u271d\u00b3 : TopologicalSpace G\u2080\ninst\u271d\u00b2 : HasContinuousInv\u2080 G\u2080\ninst\u271d\u00b9 : ContinuousMul G\u2080\ninst\u271d : TopologicalSpace \u03b1\ng : \u03b1 \u2192 G\u2080\nhf : Continuous f\nhg : Continuous g\nh\u2080 : \u2200 (x : \u03b1), g x \u2260 0\n\u22a2 Continuous fun x => f x / g x"}, {"line": "simpa only [div_eq_mul_inv] using hf.mul (hg.inv\u2080 h\u2080)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_forall_imp_mem_of_principal {S : Set \u03b9} (hS : cofinite \u2264 \ud835\udcdf S) {p : \u03b9 \u2192 Prop} :\n    IsOpen {f : \u03a0\u02b3 i, [R i, A i]_[\ud835\udcdf S] | \u2200 i, p i \u2192 f.1 i \u2208 A i} := by\n  rw [le_principal_iff] at hS\n  convert isOpen_set_pi (hS.inter_of_left {i | p i}) (fun i _ \u21a6 hAopen i) |>.preimage continuous_coe\n  ext f\n  refine \u27e8fun H i hi \u21a6 H i hi.2, fun H i hiT \u21a6 ?_\u27e9\n  by_cases hiS : i \u2208 S\n  \u00b7 exact f.2 hiS\n  \u00b7 exact H i \u27e8hiS, hiT\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/RestrictedProduct.lean", "context": {"open": ["Set Topology Filter", "Batteries.ExtendedBinder", "scoped RestrictedProduct"], "variables": ["{\u03b9 : Type*}", "(R : \u03b9 \u2192 Type*) (A : (i : \u03b9) \u2192 Set (R i))", "{\ud835\udcd5 \ud835\udcd6 : Filter \u03b9}", "(\ud835\udcd5) in", "(\ud835\udcd5) in", "{S : \u03b9 \u2192 Type*} -- subobject type", "[\u03a0 i, SetLike (S i) (R i)]", "{B : \u03a0 i, S i}", "{S : \u03b9 \u2192 Type*}", "[\u03a0 i, SetLike (S i) (R i)]", "{B : \u03a0 i, S i}", "{\u03b9\u2081 \u03b9\u2082 : Type*}", "(R\u2081 : \u03b9\u2081 \u2192 Type*) (R\u2082 : \u03b9\u2082 \u2192 Type*)", "{\ud835\udcd5\u2081 : Filter \u03b9\u2081} {\ud835\udcd5\u2082 : Filter \u03b9\u2082}", "{A\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)} {A\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)}", "{S\u2081 : \u03b9\u2081 \u2192 Type*} {S\u2082 : \u03b9\u2082 \u2192 Type*}", "[\u03a0 i, SetLike (S\u2081 i) (R\u2081 i)] [\u03a0 j, SetLike (S\u2082 j) (R\u2082 j)]", "{B\u2081 : \u03a0 i, S\u2081 i} {B\u2082 : \u03a0 j, S\u2082 j}", "(f : \u03b9\u2082 \u2192 \u03b9\u2081) (hf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081)", "(\u03c6 : \u2200 j, R\u2081 (f j) \u2192 R\u2082 j) (h\u03c6 : \u2200\u1da0 j in \ud835\udcd5\u2082, Set.MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j))", "[\u03a0 i, Monoid (R\u2081 i)] [\u03a0 i, Monoid (R\u2082 i)] [\u2200 i, SubmonoidClass (S\u2081 i) (R\u2081 i)]", "[\u03a0 i, Ring (R\u2081 i)] [\u03a0 i, Ring (R\u2082 i)] [\u2200 i, SubringClass (S\u2081 i) (R\u2081 i)]", "{R A R' A'}", "{\ud835\udcd5 : Filter \u03b9}", "[\u2200 i, TopologicalSpace (R i)]", "(R A \ud835\udcd5) in", "{S : Set \u03b9}", "(\ud835\udcd5) in", "(hAopen : \u2200 i, IsOpen (A i))"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : cofinite \u2264 principal S\np : \u03b9 \u2192 Prop\n\u22a2 IsOpen {f | \u2200 (i : \u03b9), p i \u2192 \u2191f i \u2208 A i}"}, {"line": "rw [le_principal_iff] at hS", "tactic_state": "S\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 IsOpen {f | \u2200 (i : \u03b9), p i \u2192 \u2191f i \u2208 A i}"}, {"line": "convert isOpen_set_pi (hS.inter_of_left {i | p i}) (fun i _ \u21a6 hAopen i) |>.preimage continuous_coe", "tactic_state": "case h.e'_3\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 {f | \u2200 (i : \u03b9), p i \u2192 \u2191f i \u2208 A i} = ?convert_6 \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi ?convert_3\n---\ncase convert_1\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 \u03b9 \u2192 Type ?u.28393\n---\ncase convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (?convert_1 i)\n---\ncase convert_3\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (a : \u03b9) \u2192 Set (?convert_1 a)\n---\ncase convert_6\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 RestrictedProduct (fun i => R i) (fun i => A i) (principal S) \u2192 (i : \u03b9) \u2192 ?convert_1 i"}, {"line": "ext f", "tactic_state": "case h.e'_3.h\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf\u271d : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f\u271d \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f\u271d j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f\u271d j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\nf : RestrictedProduct (fun i => R i) (fun i => A i) (principal S)\n\u22a2 f \u2208 {f | \u2200 (i : \u03b9), p i \u2192 \u2191f i \u2208 A i} \u2194 f \u2208 ?convert_6 \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi ?convert_3\n---\ncase convert_1\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 \u03b9 \u2192 Type ?u.28393\n---\ncase convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (?convert_1 i)\n---\ncase convert_3\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (a : \u03b9) \u2192 Set (?convert_1 a)\n---\ncase convert_6\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 RestrictedProduct (fun i => R i) (fun i => A i) (principal S) \u2192 (i : \u03b9) \u2192 ?convert_1 i"}, {"line": "refine \u27e8fun H i hi \u21a6 H i hi.2, fun H i hiT \u21a6 ?_\u27e9", "tactic_state": "case h.e'_3.h\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf\u271d : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f\u271d \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f\u271d j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f\u271d j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\nf : RestrictedProduct (fun i => R i) (fun i => A i) (principal S)\nH : f \u2208 Subtype.val \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi A\ni : \u03b9\nhiT : p i\n\u22a2 \u2191f i \u2208 A i\n---\ncase convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (R i)"}, {"line": "by_cases hiS : i \u2208 S", "tactic_state": "case pos\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf\u271d : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f\u271d \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f\u271d j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f\u271d j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\nf : RestrictedProduct (fun i => R i) (fun i => A i) (principal S)\nH : f \u2208 Subtype.val \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi A\ni : \u03b9\nhiT : p i\nhiS : i \u2208 S\n\u22a2 \u2191f i \u2208 A i\n---\ncase neg\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf\u271d : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f\u271d \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f\u271d j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f\u271d j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\nf : RestrictedProduct (fun i => R i) (fun i => A i) (principal S)\nH : f \u2208 Subtype.val \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi A\ni : \u03b9\nhiT : p i\nhiS : i \u2209 S\n\u22a2 \u2191f i \u2208 A i\n---\ncase convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (R i)"}, {"line": "\u00b7 exact f.2 hiS", "tactic_state": "case neg\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf\u271d : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f\u271d \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f\u271d j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f\u271d j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f\u271d hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\nf : RestrictedProduct (fun i => R i) (fun i => A i) (principal S)\nH : f \u2208 Subtype.val \u207b\u00b9' (S\u1d9c \u2229 {i | p i}).pi A\ni : \u03b9\nhiT : p i\nhiS : i \u2209 S\n\u22a2 \u2191f i \u2208 A i\n---\ncase convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (R i)"}, {"line": "\u00b7 exact H i \u27e8hiS, hiT\u27e9", "tactic_state": "case convert_2\nS\u271d\u00b9 : ?m.26364\n\u03b9\u271d : Type u_1\nR\u271d : \u03b9\u271d \u2192 Type u_2\nA\u271d : (i : \u03b9\u271d) \u2192 Set (R\u271d i)\n\ud835\udcd5\u271d \ud835\udcd6 : Filter \u03b9\u271d\ninst\u271d\u00b9\u00b2 : (i : \u03b9\u271d) \u2192 SetLike sorry (R\u271d i)\nB\u271d : ?m.27795 \u2192 sorry\nS\u271d : \u03b9\u271d \u2192 Type u_3\ninst\u271d\u00b9\u00b9 : (i : \u03b9\u271d) \u2192 SetLike (S\u271d i) (R\u271d i)\nB : (i : \u03b9\u271d) \u2192 S\u271d i\n\u03b9\u2081 : Type u_4\n\u03b9\u2082 : Type u_5\nR\u2081 : \u03b9\u2081 \u2192 Type u_6\nR\u2082 : \u03b9\u2082 \u2192 Type u_7\n\ud835\udcd5\u2081 : Filter \u03b9\u2081\n\ud835\udcd5\u2082 : Filter \u03b9\u2082\nA\u2081 : (i : \u03b9\u2081) \u2192 Set (R\u2081 i)\nA\u2082 : (i : \u03b9\u2082) \u2192 Set (R\u2082 i)\nS\u2081 : \u03b9\u2081 \u2192 Type u_8\nS\u2082 : \u03b9\u2082 \u2192 Type u_9\ninst\u271d\u00b9\u2070 : (i : \u03b9\u2081) \u2192 SetLike (S\u2081 i) (R\u2081 i)\ninst\u271d\u2079 : (j : \u03b9\u2082) \u2192 SetLike (S\u2082 j) (R\u2082 j)\nB\u2081 : (i : \u03b9\u2081) \u2192 S\u2081 i\nB\u2082 : (j : \u03b9\u2082) \u2192 S\u2082 j\nf : \u03b9\u2082 \u2192 \u03b9\u2081\nhf : Tendsto f \ud835\udcd5\u2082 \ud835\udcd5\u2081\n\u03c6 : (j : \u03b9\u2082) \u2192 R\u2081 (f j) \u2192 R\u2082 j\nh\u03c6 : \u2200\u1da0 (j : \u03b9\u2082) in \ud835\udcd5\u2082, MapsTo (\u03c6 j) (A\u2081 (f j)) (A\u2082 j)\ninst\u271d\u2078 : (i : \u03b9\u2081) \u2192 Monoid (R\u2081 i)\ninst\u271d\u2077 : (i : \u03b9\u2082) \u2192 Monoid (R\u2082 i)\ninst\u271d\u2076 : \u2200 (i : \u03b9\u2081), SubmonoidClass (S\u2081 i) (R\u2081 i)\ninst\u271d\u2075 : (i : \u03b9\u2081) \u2192 Ring (R\u2081 i)\ninst\u271d\u2074 : (i : \u03b9\u2082) \u2192 Ring (R\u2082 i)\ninst\u271d\u00b3 : \u2200 (i : \u03b9\u2081), SubringClass (S\u2081 i) (R\u2081 i)\nR' : ?m.27799 R\u2081 R\u2082 f hf \u03c6 h\u03c6\nA' : ?m.27803 R\u2081 R\u2082 f hf \u03c6 h\u03c6\n\ud835\udcd5 : Filter \u03b9\u271d\ninst\u271d\u00b2 : (i : \u03b9\u271d) \u2192 TopologicalSpace (R\u271d i)\n\u03b9 : Type u_1\nR : \u03b9 \u2192 Type u_2\nA : (i : \u03b9) \u2192 Set (R i)\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SetLike sorry (R i)\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (R i)\nS : Set \u03b9\nhS : S \u2208 cofinite\np : \u03b9 \u2192 Prop\n\u22a2 (i : \u03b9) \u2192 TopologicalSpace (R i)"}]}
{"declaration": "theorem mulTSupport_eq_empty_iff {f : X \u2192 \u03b1} : mulTSupport f = \u2205 \u2194 f = 1 := by\n  rw [mulTSupport]\n  rw [closure_empty_iff]\n  rw [mulSupport_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : TopologicalSpace X\nf : X \u2192 \u03b1\n\u22a2 mulTSupport f = \u2205 \u2194 f = 1"}, {"line": "rw [mulTSupport]", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : TopologicalSpace X\nf : X \u2192 \u03b1\n\u22a2 closure (mulSupport f) = \u2205 \u2194 f = 1"}, {"line": "rw [closure_empty_iff]", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : One \u03b1\ninst\u271d : TopologicalSpace X\nf : X \u2192 \u03b1\n\u22a2 mulSupport f = \u2205 \u2194 f = 1"}, {"line": "rw [mulSupport_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_mem_mulTSupport_iff_eventuallyEq : x \u2209 mulTSupport f \u2194 f =\u1da0[\ud835\udcdd x] 1 := by\n  simp_rw [mulTSupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, exists_prop,\n    \u2190 disjoint_iff_inter_eq_empty, disjoint_mulSupport_iff, eventuallyEq_iff_exists_mem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u00b2 : One \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : One \u03b2\nf : \u03b1 \u2192 \u03b2\nx : \u03b1\n\u22a2 x \u2209 mulTSupport f \u2194 f =\u1da0[nhds x] 1"}, {"line": "simp_rw [mulTSupport, mem_closure_iff_nhds, not_forall, not_nonempty_iff_eq_empty, exists_prop,\n    \u2190 disjoint_iff_inter_eq_empty, disjoint_mulSupport_iff, eventuallyEq_iff_exists_mem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasCompactMulSupport_def : HasCompactMulSupport f \u2194 IsCompact (closure (mulSupport f)) := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u2074 : One \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : One \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 HasCompactMulSupport f \u2194 IsCompact (closure (mulSupport f))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp\u2082_left (hf : HasCompactMulSupport f)\n    (hf\u2082 : HasCompactMulSupport f\u2082) (hm : m 1 1 = 1) :\n    HasCompactMulSupport fun x => m (f x) (f\u2082 x) := by\n  rw [hasCompactMulSupport_iff_eventuallyEq] at hf hf\u2082 \u22a2\n  filter_upwards [hf, hf\u2082] with x hx hx\u2082\n  simp_rw [hx, hx\u2082, Pi.one_apply, hm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : One \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : One \u03b3\ninst\u271d : One \u03b4\nf : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nm : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nhf : HasCompactMulSupport f\nhf\u2082 : HasCompactMulSupport f\u2082\nhm : m 1 1 = 1\n\u22a2 HasCompactMulSupport fun x => m (f x) (f\u2082 x)"}, {"line": "rw [hasCompactMulSupport_iff_eventuallyEq] at hf hf\u2082 \u22a2", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : One \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : One \u03b3\ninst\u271d : One \u03b4\nf : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nm : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nhf : f =\u1da0[coclosedCompact \u03b1] 1\nhf\u2082 : f\u2082 =\u1da0[coclosedCompact \u03b1] 1\nhm : m 1 1 = 1\n\u22a2 (fun x => m (f x) (f\u2082 x)) =\u1da0[coclosedCompact \u03b1] 1"}, {"line": "filter_upwards [hf, hf\u2082] with x hx hx\u2082", "tactic_state": "case h\n\u03b1 : Type u_2\n\u03b2 : Type u_4\n\u03b3 : Type u_5\n\u03b4 : Type u_6\ninst\u271d\u2076 : One \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : One \u03b2\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : One \u03b2\ninst\u271d\u00b9 : One \u03b3\ninst\u271d : One \u03b4\nf : \u03b1 \u2192 \u03b2\nf\u2082 : \u03b1 \u2192 \u03b3\nm : \u03b2 \u2192 \u03b3 \u2192 \u03b4\nhf : f =\u1da0[coclosedCompact \u03b1] 1\nhf\u2082 : f\u2082 =\u1da0[coclosedCompact \u03b1] 1\nhm : m 1 1 = 1\nx : \u03b1\nhx : f x = 1 x\nhx\u2082 : f\u2082 x = 1 x\n\u22a2 m (f x) (f\u2082 x) = 1 x"}, {"line": "simp_rw [hx, hx\u2082, Pi.one_apply, hm]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma HasCompactMulSupport.one {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [One \u03b2] :\n    HasCompactMulSupport (1 : \u03b1 \u2192 \u03b2) := by\n  simp [HasCompactMulSupport, mulTSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : One \u03b2\n\u22a2 HasCompactMulSupport 1"}, {"line": "simp [HasCompactMulSupport, mulTSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma HasCompactMulSupport.inv' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [DivisionMonoid \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (hf : HasCompactMulSupport f) :\n    HasCompactMulSupport (f\u207b\u00b9) := by\n  simpa only [HasCompactMulSupport,mulTSupport,mulSupport_inv'] using hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_9\n\u03b2 : Type u_10\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DivisionMonoid \u03b2\nf : \u03b1 \u2192 \u03b2\nhf : HasCompactMulSupport f\n\u22a2 HasCompactMulSupport f\u207b\u00b9"}, {"line": "simpa only [HasCompactMulSupport,mulTSupport,mulSupport_inv'] using hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasCompactSupport.smul_left (hf : HasCompactSupport f') : HasCompactSupport (f \u2022 f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2\n  exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, smul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [Zero M] [SMulZeroClass R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Type u_7\nR : Type u_8\ninst\u271d\u2077 : One \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : CompactSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\nf : \u03b1 \u2192 R\nf' : \u03b1 \u2192 M\nhf : HasCompactSupport f'\n\u22a2 HasCompactSupport (f \u2022 f')"}, {"line": "rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2", "tactic_state": "\u03b1 : Type u_2\nM : Type u_7\nR : Type u_8\ninst\u271d\u2077 : One \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : CompactSpace \u03b1\ninst\u271d\u00b3 inst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulZeroClass R M\nf : \u03b1 \u2192 R\nf' : \u03b1 \u2192 M\nhf : f' =\u1da0[coclosedCompact \u03b1] 0\n\u22a2 f \u2022 f' =\u1da0[coclosedCompact \u03b1] 0"}, {"line": "exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, smul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasCompactSupport.smul_right (hf : HasCompactSupport f) : HasCompactSupport (f \u2022 f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2\n  exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, zero_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [Zero M] [SMulZeroClass R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [Zero R] [Zero M] [SMulWithZero R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nM : Type u_7\nR : Type u_8\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : CompactSpace \u03b1\ninst\u271d\u2077 inst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Zero M\ninst\u271d\u2074 : SMulZeroClass R M\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\nf : \u03b1 \u2192 R\nf' : \u03b1 \u2192 M\nhf : HasCompactSupport f\n\u22a2 HasCompactSupport (f \u2022 f')"}, {"line": "rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2", "tactic_state": "\u03b1 : Type u_2\nM : Type u_7\nR : Type u_8\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 inst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : CompactSpace \u03b1\ninst\u271d\u2077 inst\u271d\u2076 : TopologicalSpace \u03b1\ninst\u271d\u2075 : Zero M\ninst\u271d\u2074 : SMulZeroClass R M\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : Zero R\ninst\u271d\u00b9 : Zero M\ninst\u271d : SMulWithZero R M\nf : \u03b1 \u2192 R\nf' : \u03b1 \u2192 M\nhf : f =\u1da0[coclosedCompact \u03b1] 0\n\u22a2 f \u2022 f' =\u1da0[coclosedCompact \u03b1] 0"}, {"line": "exact hf.mono fun x hx => by simp_rw [Pi.smul_apply', hx, Pi.zero_apply, zero_smul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasCompactSupport.mul_right (hf : HasCompactSupport f) : HasCompactSupport (f * f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2\n  exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [Zero M] [SMulZeroClass R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [Zero R] [Zero M] [SMulWithZero R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [MulZeroClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : One \u03b2\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : One \u03b2\ninst\u271d\u2076 : CompactSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : MulOneClass \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MulZeroClass \u03b2\nf f' : \u03b1 \u2192 \u03b2\nhf : HasCompactSupport f\n\u22a2 HasCompactSupport (f * f')"}, {"line": "rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : One \u03b2\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : One \u03b2\ninst\u271d\u2076 : CompactSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : MulOneClass \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MulZeroClass \u03b2\nf f' : \u03b1 \u2192 \u03b2\nhf : f =\u1da0[coclosedCompact \u03b1] 0\n\u22a2 f * f' =\u1da0[coclosedCompact \u03b1] 0"}, {"line": "exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasCompactSupport.mul_left (hf : HasCompactSupport f') : HasCompactSupport (f * f') := by\n  rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2\n  exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, mul_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [Zero M] [SMulZeroClass R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [Zero R] [Zero M] [SMulWithZero R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [MulZeroClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : One \u03b2\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : One \u03b2\ninst\u271d\u2076 : CompactSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : MulOneClass \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MulZeroClass \u03b2\nf f' : \u03b1 \u2192 \u03b2\nhf : HasCompactSupport f'\n\u22a2 HasCompactSupport (f * f')"}, {"line": "rw [hasCompactSupport_iff_eventuallyEq] at hf \u22a2", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_4\ninst\u271d\u00b9\u00b9 : One \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : One \u03b2\ninst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : One \u03b2\ninst\u271d\u2076 : CompactSpace \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : MulOneClass \u03b2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : MulZeroClass \u03b2\nf f' : \u03b1 \u2192 \u03b2\nhf : f' =\u1da0[coclosedCompact \u03b1] 0\n\u22a2 f * f' =\u1da0[coclosedCompact \u03b1] 0"}, {"line": "exact hf.mono fun x hx => by simp_rw [Pi.mul_apply, hx, Pi.zero_apply, mul_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyFinite.exists_finset_nhd_mulSupport_subset {U : \u03b9 \u2192 Set X} [One R] {f : \u03b9 \u2192 X \u2192 R}\n    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : \u2200 i, mulTSupport (f i) \u2286 U i)\n    (ho : \u2200 i, IsOpen (U i)) (x : X) :\n    \u2203 (is : Finset \u03b9), \u2203 n, n \u2208 \ud835\udcdd x \u2227 (n \u2286 \u22c2 i \u2208 is, U i) \u2227\n      \u2200 z \u2208 n, (mulSupport fun i => f i z) \u2286 is := by\n  obtain \u27e8n, hn, hnf\u27e9 := hlf x\n  classical\n    let is := {i \u2208 hnf.toFinset | x \u2208 U i}\n    let js := {j \u2208 hnf.toFinset | x \u2209 U j}\n    refine\n      \u27e8is, (n \u2229 \u22c2 j \u2208 js, (mulTSupport (f j))\u1d9c) \u2229 \u22c2 i \u2208 is, U i, inter_mem (inter_mem hn ?_) ?_,\n        inter_subset_right, fun z hz => ?_\u27e9\n    \u00b7 exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)\n        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)\n    \u00b7 exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2\n    \u00b7 have hzn : z \u2208 n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [js] at hz\n      simp only [Finset.mem_filter] at hz\n      simp only [Finite.mem_toFinset] at hz\n      simp only [mem_setOf_eq] at hz\n      simp only [mem_iInter] at hz\n      simp only [and_imp] at hz\n      suffices (mulSupport fun i => f i z) \u2286 hnf.toFinset by\n        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_\n        specialize hz i \u27e8z, \u27e8hi, hzn\u27e9\u27e9\n        contrapose hz\n        simp [hz, subset_mulTSupport (f i) hi]\n      intro i hi\n      simp only [Finite.coe_toFinset]\n      simp only [mem_setOf_eq]\n      exact \u27e8z, \u27e8hi, hzn\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Support.lean", "context": {"open": ["Function Set Filter Topology", "sets, then for any point we can find a neighbourhood on which only finitely-many members of `f`"], "variables": ["{X \u03b1 \u03b1' \u03b2 \u03b3 \u03b4 M R : Type*}", "[One \u03b1] [TopologicalSpace X]", "[TopologicalSpace \u03b1]", "[One \u03b2]", "{f : \u03b1 \u2192 \u03b2} {x : \u03b1}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b1']", "[One \u03b2] [One \u03b3] [One \u03b4]", "{g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} {m : \u03b2 \u2192 \u03b3 \u2192 \u03b4}", "[T2Space \u03b1']", "(hf : HasCompactMulSupport f) {g : \u03b1 \u2192 \u03b1'} (cont : Continuous g)", "[CompactSpace \u03b1]", "[TopologicalSpace \u03b1] [MulOneClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [Zero M] [SMulZeroClass R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [Zero R] [Zero M] [SMulWithZero R M]", "{f : \u03b1 \u2192 R} {f' : \u03b1 \u2192 M}", "[TopologicalSpace \u03b1] [MulZeroClass \u03b2]", "{f f' : \u03b1 \u2192 \u03b2}", "[TopologicalSpace \u03b1] [AddGroup \u03b2] [Lattice \u03b2] [AddLeftMono \u03b2]", "{\u03b9 : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nR : Type u_8\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Zero R\n\u03b9 : Type u_9\ninst\u271d\u00b9 : TopologicalSpace X\nU : \u03b9 \u2192 Set X\ninst\u271d : One R\nf : \u03b9 \u2192 X \u2192 R\nhlf : LocallyFinite fun i => mulSupport (f i)\nhso : \u2200 (i : \u03b9), mulTSupport (f i) \u2286 U i\nho : \u2200 (i : \u03b9), IsOpen (U i)\nx : X\n\u22a2 \u2203 is, \u2203 n \u2208 nhds x, n \u2286 \u22c2 i \u2208 is, U i \u2227 \u2200 z \u2208 n, (mulSupport fun i => f i z) \u2286 \u2191is"}, {"line": "obtain \u27e8n, hn, hnf\u27e9 := hlf x", "tactic_state": "case intro.intro\nX : Type u_1\nR : Type u_8\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Zero R\n\u03b9 : Type u_9\ninst\u271d\u00b9 : TopologicalSpace X\nU : \u03b9 \u2192 Set X\ninst\u271d : One R\nf : \u03b9 \u2192 X \u2192 R\nhlf : LocallyFinite fun i => mulSupport (f i)\nhso : \u2200 (i : \u03b9), mulTSupport (f i) \u2286 U i\nho : \u2200 (i : \u03b9), IsOpen (U i)\nx : X\nn : Set X\nhn : n \u2208 nhds x\nhnf : {i | ((fun i => mulSupport (f i)) i \u2229 n).Nonempty}.Finite\n\u22a2 \u2203 is, \u2203 n \u2208 nhds x, n \u2286 \u22c2 i \u2208 is, U i \u2227 \u2200 z \u2208 n, (mulSupport fun i => f i z) \u2286 \u2191is"}, {"line": "classical\n    let is := {i \u2208 hnf.toFinset | x \u2208 U i}\n    let js := {j \u2208 hnf.toFinset | x \u2209 U j}\n    refine\n      \u27e8is, (n \u2229 \u22c2 j \u2208 js, (mulTSupport (f j))\u1d9c) \u2229 \u22c2 i \u2208 is, U i, inter_mem (inter_mem hn ?_) ?_,\n        inter_subset_right, fun z hz => ?_\u27e9\n    \u00b7 exact (biInter_finset_mem js).mpr fun j hj => IsClosed.compl_mem_nhds (isClosed_mulTSupport _)\n        (Set.not_mem_subset (hso j) (Finset.mem_filter.mp hj).2)\n    \u00b7 exact (biInter_finset_mem is).mpr fun i hi => (ho i).mem_nhds (Finset.mem_filter.mp hi).2\n    \u00b7 have hzn : z \u2208 n := by\n        rw [inter_assoc] at hz\n        exact mem_of_mem_inter_left hz\n      replace hz := mem_of_mem_inter_right (mem_of_mem_inter_left hz)\n      simp only [js] at hz\n      simp only [Finset.mem_filter] at hz\n      simp only [Finite.mem_toFinset] at hz\n      simp only [mem_setOf_eq] at hz\n      simp only [mem_iInter] at hz\n      simp only [and_imp] at hz\n      suffices (mulSupport fun i => f i z) \u2286 hnf.toFinset by\n        refine hnf.toFinset.subset_coe_filter_of_subset_forall _ this fun i hi => ?_\n        specialize hz i \u27e8z, \u27e8hi, hzn\u27e9\u27e9\n        contrapose hz\n        simp [hz, subset_mulTSupport (f i) hi]\n      intro i hi\n      simp only [Finite.coe_toFinset]\n      simp only [mem_setOf_eq]\n      exact \u27e8z, \u27e8hi, hzn\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsNilpotent.isTopologicallyNilpotent {a : R} (ha : IsNilpotent a) :\n    IsTopologicallyNilpotent a := by\n  obtain \u27e8n, hn\u27e9 := ha\n  apply tendsto_atTop_of_eventually_const (i\u2080 := n)\n  intro i hi\n  rw [\u2190 Nat.add_sub_of_le hi]\n  rw [pow_add]\n  rw [hn]\n  rw [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/TopologicallyNilpotent.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{R S : Type*} [TopologicalSpace R] [MonoidWithZero R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nha : IsNilpotent a\n\u22a2 IsTopologicallyNilpotent a"}, {"line": "obtain \u27e8n, hn\u27e9 := ha", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\n\u22a2 IsTopologicallyNilpotent a"}, {"line": "apply tendsto_atTop_of_eventually_const (i\u2080 := n)", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\n\u22a2 \u2200 i \u2265 n, a ^ i = 0"}, {"line": "intro i hi", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\ni : \u2115\nhi : i \u2265 n\n\u22a2 a ^ i = 0"}, {"line": "rw [\u2190 Nat.add_sub_of_le hi]", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\ni : \u2115\nhi : i \u2265 n\n\u22a2 a ^ (n + (i - n)) = 0"}, {"line": "rw [pow_add]", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\ni : \u2115\nhi : i \u2265 n\n\u22a2 a ^ n * a ^ (i - n) = 0"}, {"line": "rw [hn]", "tactic_state": "case intro\nR : Type u_1\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : MonoidWithZero R\na : R\nn : \u2115\nhn : a ^ n = 0\ni : \u2115\nhi : i \u2265 n\n\u22a2 0 * a ^ (i - n) = 0"}, {"line": "rw [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_topologicalNilradical_iff {a : R} :\n    a \u2208 topologicalNilradical R \u2194 IsTopologicallyNilpotent a := by\n  simp [topologicalNilradical]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/TopologicallyNilpotent.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{R S : Type*} [TopologicalSpace R] [MonoidWithZero R]", "{R : Type*} [TopologicalSpace R] [Ring R]", "{R : Type*} [TopologicalSpace R] [CommRing R] [IsLinearTopology R R]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : CommRing R\ninst\u271d : IsLinearTopology R R\na : R\n\u22a2 a \u2208 topologicalNilradical R \u2194 IsTopologicallyNilpotent a"}, {"line": "simp [topologicalNilradical]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem UniformFun.hasBasis_nhds_one_of_basis {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set G}\n    (h : (\ud835\udcdd 1 : Filter G).HasBasis p b) :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64 G)).HasBasis p fun i => { f : \u03b1 \u2192\u1d64 G | \u2200 x, toFun f x \u2208 b i } := by\n  convert UniformFun.hasBasis_nhds_of_basis \u03b1 _ (1 : \u03b1 \u2192\u1d64 G) h.uniformity_of_nhds_one\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/UniformConvergence.lean", "context": {"open": ["Filter", "scoped Topology Pointwise UniformConvergence Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b9 R : Type*} {\ud835\udd16 : Set <| Set \u03b1} {x : \u03b1}", "{\u03b1 G \u03b9 : Type*} [Group G] {\ud835\udd16 : Set <| Set \u03b1} [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 (nhds 1).HasBasis p fun i => {f | \u2200 (x : \u03b1), toFun f x \u2208 b i}"}, {"line": "convert UniformFun.hasBasis_nhds_of_basis \u03b1 _ (1 : \u03b1 \u2192\u1d64 G) h.uniformity_of_nhds_one", "tactic_state": "case a\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ((nhds 1).HasBasis p fun i => {f | \u2200 (x : \u03b1), toFun f x \u2208 b i}) \u2194\n    (nhds sorry).HasBasis ?convert_3 fun i => {g | (sorry, g) \u2208 UniformFun.gen \u03b1 sorry (?convert_4 i)}\n---\ncase convert_1\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 Type ?u.1551\n---\ncase convert_2\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 UniformSpace sorry\n---\ncase convert_3\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ?convert_1 \u2192 Prop\n---\ncase convert_4\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ?convert_1 \u2192 Set (sorry \u00d7 sorry)"}, {"line": "simp", "tactic_state": "case a\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ((nhds 1).HasBasis p fun i => {f | \u2200 (x : \u03b1), toFun f x \u2208 b i}) \u2194\n    (nhds (sorry ())).HasBasis ?convert_3 fun i => {g | \u2200 (x : \u03b1), (toFun (sorry ()) x, toFun g x) \u2208 ?convert_4 i}\n---\ncase convert_1\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 Type ?u.1551\n---\ncase convert_2\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 UniformSpace sorry\n---\ncase convert_3\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ?convert_1 \u2192 Prop\n---\ncase convert_4\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 ?convert_1 \u2192 Set (sorry \u00d7 sorry)"}]}
{"declaration": "protected theorem UniformOnFun.hasBasis_nhds_one_of_basis (\ud835\udd16 : Set <| Set \u03b1) (h\ud835\udd16\u2081 : \ud835\udd16.Nonempty)\n    (h\ud835\udd16\u2082 : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set G}\n    (h : (\ud835\udcdd 1 : Filter G).HasBasis p b) :\n    (\ud835\udcdd 1 : Filter (\u03b1 \u2192\u1d64[\ud835\udd16] G)).HasBasis (fun Si : Set \u03b1 \u00d7 \u03b9 => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2) fun Si =>\n      { f : \u03b1 \u2192\u1d64[\ud835\udd16] G | \u2200 x \u2208 Si.1, toFun \ud835\udd16 f x \u2208 b Si.2 } := by\n  convert UniformOnFun.hasBasis_nhds_of_basis \u03b1 _ \ud835\udd16 (1 : \u03b1 \u2192\u1d64[\ud835\udd16] G) h\ud835\udd16\u2081 h\ud835\udd16\u2082 <|\n    h.uniformity_of_nhds_one_swapped\n  simp [UniformOnFun.gen]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/UniformConvergence.lean", "context": {"open": ["Filter", "scoped Topology Pointwise UniformConvergence Uniformity"], "variables": ["{\u03b1 \u03b2 \u03b9 R : Type*} {\ud835\udd16 : Set <| Set \u03b1} {x : \u03b1}", "{\u03b1 G \u03b9 : Type*} [Group G] {\ud835\udd16 : Set <| Set \u03b1} [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 (nhds 1).HasBasis (fun Si => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2) fun Si => {f | \u2200 x \u2208 Si.1, (toFun \ud835\udd16) f x \u2208 b Si.2}"}, {"line": "convert UniformOnFun.hasBasis_nhds_of_basis \u03b1 _ \ud835\udd16 (1 : \u03b1 \u2192\u1d64[\ud835\udd16] G) h\ud835\udd16\u2081 h\ud835\udd16\u2082 <|\n    h.uniformity_of_nhds_one_swapped", "tactic_state": "case h.e'_3.h.e'_3\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 1 = sorry\n---\ncase h.e'_5.h.h.e'_2.h.a\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\nx\u271d\u00b9 : Set \u03b1 \u00d7 \u03b9\nx\u271d : UniformOnFun \u03b1 G \ud835\udd16\n\u22a2 (\u2200 x \u2208 x\u271d\u00b9.1, (toFun \ud835\udd16) x\u271d x \u2208 b x\u271d\u00b9.2) \u2194 (x\u271d, sorry) \u2208 UniformOnFun.gen \ud835\udd16 x\u271d\u00b9.1 {x | x.1 / x.2 \u2208 b x\u271d\u00b9.2}\n---\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 IsUniformGroup G"}, {"line": "simp [UniformOnFun.gen]", "tactic_state": "case h.e'_3.h.e'_3\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 1 = sorry ()\n---\ncase h.e'_5.h.h.e'_2.h.a\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\nx\u271d\u00b9 : Set \u03b1 \u00d7 \u03b9\nx\u271d : UniformOnFun \u03b1 G \ud835\udd16\n\u22a2 (\u2200 x \u2208 x\u271d\u00b9.1, (toFun \ud835\udd16) x\u271d x \u2208 b x\u271d\u00b9.2) \u2194 (x\u271d, sorry) \u2208 UniformOnFun.gen \ud835\udd16 x\u271d\u00b9.1 {x | x.1 / x.2 \u2208 b x\u271d\u00b9.2}\n---\n\u03b1 : Type u_5\nG : Type u_6\n\u03b9 : Type u_7\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udd16 : Set (Set \u03b1)\nh\ud835\udd16\u2081 : \ud835\udd16.Nonempty\nh\ud835\udd16\u2082 : DirectedOn (fun x1 x2 => x1 \u2286 x2) \ud835\udd16\np : \u03b9 \u2192 Prop\nb : \u03b9 \u2192 Set G\nh : (nhds 1).HasBasis p b\n\u22a2 IsUniformGroup G"}]}
{"declaration": "theorem comp_coe (e\u2081 : A \u2243A[R] B) (e\u2082 : B \u2243A[R] C) :\n    e\u2082.toAlgHom.comp e\u2081.toAlgHom = e\u2081.trans e\u2082 := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Algebra/Equiv.lean", "context": {"open": ["scoped Topology"], "variables": ["{R A B C : Type*}", "(R A)", "{R A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "e\u2081 : sorry\ne\u2082 : sorry\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (A : ProfiniteGrp.{u}) (a : A) :\n    (\ud835\udfd9 A : A \u27f6 A) a = a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Category/ProfiniteGrp/Basic.lean", "context": {"open": ["CategoryTheory Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : ProfiniteGrp.{u}\na : \u2191A.toProfinite.toTop\n\u22a2 (ProfiniteGrp.Hom.hom (CategoryStruct.id A)) a = a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {A B : ProfiniteGrp.{u}} (e : A \u2245 B) (x : A) : e.inv (e.hom x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Category/ProfiniteGrp/Basic.lean", "context": {"open": ["CategoryTheory Topology"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : ProfiniteGrp.{u}\ne : A \u2245 B\nx : \u2191A.toProfinite.toTop\n\u22a2 (ProfiniteGrp.Hom.hom e.inv) ((ProfiniteGrp.Hom.hom e.hom) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {A B : ProfiniteGrp.{u}} (e : A \u2245 B) (x : B) : e.hom (e.inv x) = x := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Category/ProfiniteGrp/Basic.lean", "context": {"open": ["CategoryTheory Topology"], "variables": ["{X Y Z : Type u} [Group X] [TopologicalSpace X] [IsTopologicalGroup X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A B : ProfiniteGrp.{u}\ne : A \u2245 B\nx : \u2191B.toProfinite.toTop\n\u22a2 (ProfiniteGrp.Hom.hom e.hom) ((ProfiniteGrp.Hom.hom e.inv) x) = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousInv_iInf {ts' : \u03b9' \u2192 TopologicalSpace G}\n    (h' : \u2200 i, @ContinuousInv G (ts' i) _) : @ContinuousInv G (\u2a05 i, ts' i) _ := by\n  rw [\u2190 sInf_range]\n  exact continuousInv_sInf (Set.forall_mem_range.mpr h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u2079 : TopologicalSpace G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : ContinuousMul G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : ContinuousInv G\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : ContinuousInv G\n\u03b9' : Sort u_4\ninst\u271d : Inv G\nts' : \u03b9' \u2192 TopologicalSpace G\nh' : \u2200 (i : \u03b9'), ContinuousInv G\n\u22a2 ContinuousInv G"}, {"line": "rw [\u2190 sInf_range]", "tactic_state": "G : Type w\ninst\u271d\u2079 : TopologicalSpace G\ninst\u271d\u2078 : Group G\ninst\u271d\u2077 : ContinuousMul G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : ContinuousInv G\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : InvolutiveInv G\ninst\u271d\u00b9 : ContinuousInv G\n\u03b9' : Sort u_4\ninst\u271d : Inv G\nts' : \u03b9' \u2192 TopologicalSpace G\nh' : \u2200 (i : \u03b9'), ContinuousInv G\n\u22a2 ContinuousInv G"}, {"line": "exact continuousInv_sInf (Set.forall_mem_range.mpr h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_inv_nhdsGT_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[>] a\u207b\u00b9) (\ud835\udcdd[<] a) := by\n  simpa only [inv_inv] using tendsto_inv_nhdsGT (a := a\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type x\ninst\u271d\u2074 : TopologicalSpace H\ninst\u271d\u00b3 : CommGroup H\ninst\u271d\u00b2 : PartialOrder H\ninst\u271d\u00b9 : IsOrderedMonoid H\ninst\u271d : ContinuousInv H\na : H\n\u22a2 Tendsto Inv.inv (nhdsWithin a\u207b\u00b9 (Ioi a\u207b\u00b9)) (nhdsWithin a (Iio a))"}, {"line": "simpa only [inv_inv] using tendsto_inv_nhdsGT (a := a\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_inv_nhdsLT_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[<] a\u207b\u00b9) (\ud835\udcdd[>] a) := by\n  simpa only [inv_inv] using tendsto_inv_nhdsLT (a := a\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type x\ninst\u271d\u2074 : TopologicalSpace H\ninst\u271d\u00b3 : CommGroup H\ninst\u271d\u00b2 : PartialOrder H\ninst\u271d\u00b9 : IsOrderedMonoid H\ninst\u271d : ContinuousInv H\na : H\n\u22a2 Tendsto Inv.inv (nhdsWithin a\u207b\u00b9 (Iio a\u207b\u00b9)) (nhdsWithin a (Ioi a))"}, {"line": "simpa only [inv_inv] using tendsto_inv_nhdsLT (a := a\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_inv_nhdsGE_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2265] a\u207b\u00b9) (\ud835\udcdd[\u2264] a) := by\n  simpa only [inv_inv] using tendsto_inv_nhdsGE (a := a\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type x\ninst\u271d\u2074 : TopologicalSpace H\ninst\u271d\u00b3 : CommGroup H\ninst\u271d\u00b2 : PartialOrder H\ninst\u271d\u00b9 : IsOrderedMonoid H\ninst\u271d : ContinuousInv H\na : H\n\u22a2 Tendsto Inv.inv (nhdsWithin a\u207b\u00b9 (Ici a\u207b\u00b9)) (nhdsWithin a (Iic a))"}, {"line": "simpa only [inv_inv] using tendsto_inv_nhdsGE (a := a\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_inv_nhdsLE_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2264] a\u207b\u00b9) (\ud835\udcdd[\u2265] a) := by\n  simpa only [inv_inv] using tendsto_inv_nhdsLE (a := a\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "H : Type x\ninst\u271d\u2074 : TopologicalSpace H\ninst\u271d\u00b3 : CommGroup H\ninst\u271d\u00b2 : PartialOrder H\ninst\u271d\u00b9 : IsOrderedMonoid H\ninst\u271d : ContinuousInv H\na : H\n\u22a2 Tendsto Inv.inv (nhdsWithin a\u207b\u00b9 (Iic a\u207b\u00b9)) (nhdsWithin a (Ici a))"}, {"line": "simpa only [inv_inv] using tendsto_inv_nhdsLE (a := a\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.topologicalClosure_map_subgroup [Group H] [TopologicalSpace H]\n    [IsTopologicalGroup H] {f : G \u2192* H} (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G}\n    (hs : s.topologicalClosure = \u22a4) : (s.map f).topologicalClosure = \u22a4 := by\n  rw [SetLike.ext'_iff] at hs \u22a2\n  simp only [Subgroup.topologicalClosure_coe] at hs \u22a2\n  simp only [Subgroup.coe_top] at hs \u22a2\n  simp only [\u2190 dense_iff_closure_eq] at hs \u22a2\n  exact hf'.dense_image hf hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\nH : Type x\ninst\u271d\u00b2\u2074 : TopologicalSpace G\ninst\u271d\u00b2\u00b3 : Group G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Inv G\ninst\u271d\u00b9\u2079 : ContinuousInv G\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : InvolutiveInv G\ninst\u271d\u00b9\u2076 : ContinuousInv G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : TopologicalSpace G\ninst\u271d\u00b9\u00b3 : Inv G\ninst\u271d\u00b9\u00b2 : Mul G\ninst\u271d\u00b9\u00b9 : ContinuousMul G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : IsTopologicalGroup G\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : CommGroup H\ninst\u271d\u2075 : PartialOrder H\ninst\u271d\u2074 : IsOrderedMonoid H\ninst\u271d\u00b3 : ContinuousInv H\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : TopologicalSpace H\ninst\u271d : IsTopologicalGroup H\nf : G \u2192* H\nhf : Continuous \u21d1f\nhf' : DenseRange \u21d1f\ns : Subgroup G\nhs : s.topologicalClosure = \u22a4\n\u22a2 (Subgroup.map f s).topologicalClosure = \u22a4"}, {"line": "rw [SetLike.ext'_iff] at hs \u22a2", "tactic_state": "G : Type w\nH : Type x\ninst\u271d\u00b2\u2074 : TopologicalSpace G\ninst\u271d\u00b2\u00b3 : Group G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Inv G\ninst\u271d\u00b9\u2079 : ContinuousInv G\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : InvolutiveInv G\ninst\u271d\u00b9\u2076 : ContinuousInv G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : TopologicalSpace G\ninst\u271d\u00b9\u00b3 : Inv G\ninst\u271d\u00b9\u00b2 : Mul G\ninst\u271d\u00b9\u00b9 : ContinuousMul G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : IsTopologicalGroup G\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : CommGroup H\ninst\u271d\u2075 : PartialOrder H\ninst\u271d\u2074 : IsOrderedMonoid H\ninst\u271d\u00b3 : ContinuousInv H\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : TopologicalSpace H\ninst\u271d : IsTopologicalGroup H\nf : G \u2192* H\nhf : Continuous \u21d1f\nhf' : DenseRange \u21d1f\ns : Subgroup G\nhs : \u2191s.topologicalClosure = \u2191\u22a4\n\u22a2 \u2191(Subgroup.map f s).topologicalClosure = \u2191\u22a4"}, {"line": "simp only [Subgroup.topologicalClosure_coe] at hs \u22a2", "tactic_state": "G : Type w\nH : Type x\ninst\u271d\u00b2\u2074 : TopologicalSpace G\ninst\u271d\u00b2\u00b3 : Group G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Inv G\ninst\u271d\u00b9\u2079 : ContinuousInv G\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : InvolutiveInv G\ninst\u271d\u00b9\u2076 : ContinuousInv G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : TopologicalSpace G\ninst\u271d\u00b9\u00b3 : Inv G\ninst\u271d\u00b9\u00b2 : Mul G\ninst\u271d\u00b9\u00b9 : ContinuousMul G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : IsTopologicalGroup G\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : CommGroup H\ninst\u271d\u2075 : PartialOrder H\ninst\u271d\u2074 : IsOrderedMonoid H\ninst\u271d\u00b3 : ContinuousInv H\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : TopologicalSpace H\ninst\u271d : IsTopologicalGroup H\nf : G \u2192* H\nhf : Continuous \u21d1f\nhf' : DenseRange \u21d1f\ns : Subgroup G\nhs : closure \u2191s = \u2191\u22a4\n\u22a2 closure \u2191(Subgroup.map f s) = \u2191\u22a4"}, {"line": "simp only [Subgroup.coe_top] at hs \u22a2", "tactic_state": "G : Type w\nH : Type x\ninst\u271d\u00b2\u2074 : TopologicalSpace G\ninst\u271d\u00b2\u00b3 : Group G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Inv G\ninst\u271d\u00b9\u2079 : ContinuousInv G\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : InvolutiveInv G\ninst\u271d\u00b9\u2076 : ContinuousInv G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : TopologicalSpace G\ninst\u271d\u00b9\u00b3 : Inv G\ninst\u271d\u00b9\u00b2 : Mul G\ninst\u271d\u00b9\u00b9 : ContinuousMul G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : IsTopologicalGroup G\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : CommGroup H\ninst\u271d\u2075 : PartialOrder H\ninst\u271d\u2074 : IsOrderedMonoid H\ninst\u271d\u00b3 : ContinuousInv H\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : TopologicalSpace H\ninst\u271d : IsTopologicalGroup H\nf : G \u2192* H\nhf : Continuous \u21d1f\nhf' : DenseRange \u21d1f\ns : Subgroup G\nhs : closure \u2191s = univ\n\u22a2 closure \u2191(Subgroup.map f s) = univ"}, {"line": "simp only [\u2190 dense_iff_closure_eq] at hs \u22a2", "tactic_state": "G : Type w\nH : Type x\ninst\u271d\u00b2\u2074 : TopologicalSpace G\ninst\u271d\u00b2\u00b3 : Group G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Inv G\ninst\u271d\u00b9\u2079 : ContinuousInv G\ninst\u271d\u00b9\u2078 : TopologicalSpace G\ninst\u271d\u00b9\u2077 : InvolutiveInv G\ninst\u271d\u00b9\u2076 : ContinuousInv G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : TopologicalSpace G\ninst\u271d\u00b9\u00b3 : Inv G\ninst\u271d\u00b9\u00b2 : Mul G\ninst\u271d\u00b9\u00b9 : ContinuousMul G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : Group G\ninst\u271d\u2078 : IsTopologicalGroup G\ninst\u271d\u2077 : TopologicalSpace H\ninst\u271d\u2076 : CommGroup H\ninst\u271d\u2075 : PartialOrder H\ninst\u271d\u2074 : IsOrderedMonoid H\ninst\u271d\u00b3 : ContinuousInv H\ninst\u271d\u00b2 : Group H\ninst\u271d\u00b9 : TopologicalSpace H\ninst\u271d : IsTopologicalGroup H\nf : G \u2192* H\nhf : Continuous \u21d1f\nhf' : DenseRange \u21d1f\ns : Subgroup G\nhs : Dense \u2191s\n\u22a2 Dense \u2191(Subgroup.map f s)"}, {"line": "exact hf'.dense_image hf hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [DivisionMonoid G]\n    [ContinuousInv G] {g : G} (hg : g \u2208 connectedComponent (1 : G)) :\n    g\u207b\u00b9 \u2208 connectedComponent (1 : G) := by\n  rw [\u2190 inv_one]\n  exact\n    Continuous.image_connectedComponent_subset continuous_inv _\n      ((Set.mem_image _ _ _).mp \u27e8g, hg, rfl\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_5\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : DivisionMonoid G\ninst\u271d : ContinuousInv G\ng : G\nhg : g \u2208 connectedComponent 1\n\u22a2 g\u207b\u00b9 \u2208 connectedComponent 1"}, {"line": "rw [\u2190 inv_one]", "tactic_state": "G : Type u_5\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : DivisionMonoid G\ninst\u271d : ContinuousInv G\ng : G\nhg : g \u2208 connectedComponent 1\n\u22a2 g\u207b\u00b9 \u2208 connectedComponent 1\u207b\u00b9"}, {"line": "exact\n    Continuous.image_connectedComponent_subset continuous_inv _\n      ((Set.mem_image _ _ _).mp \u27e8g, hg, rfl\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Subgroup.coe_topologicalClosure_bot :\n    ((\u22a5 : Subgroup G).topologicalClosure : Set G) = _root_.closure ({1} : Set G) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u22a2 \u2191\u22a5.topologicalClosure = _root_.closure {1}"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.HasBasis.nhds_of_one {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set G}\n    (hb : HasBasis (\ud835\udcdd 1 : Filter G) p s) (x : G) :\n    HasBasis (\ud835\udcdd x) p fun i => { y | y / x \u2208 s i } := by\n  rw [\u2190 nhds_translation_mul_inv]\n  simp_rw [div_eq_mul_inv]\n  exact hb.comap _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}", "(G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 (nhds x).HasBasis p fun i => {y | y / x \u2208 s i}"}, {"line": "rw [\u2190 nhds_translation_mul_inv]", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 (Filter.comap (fun x_1 => x_1 * x\u207b\u00b9) (nhds 1)).HasBasis p fun i => {y | y / x \u2208 s i}\n---\nG : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 Group G\n---\nG : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 IsTopologicalGroup G"}, {"line": "simp_rw [div_eq_mul_inv]", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 (Filter.comap (fun x_1 => x_1 * x\u207b\u00b9) (nhds 1)).HasBasis p fun i => {y | y * x\u207b\u00b9 \u2208 s i}\n---\nG : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 Group G\n---\nG : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 IsTopologicalGroup G"}, {"line": "exact hb.comap _", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Group G\ninst\u271d\u00b9\u2074 : ContinuousMul G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : Inv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : TopologicalSpace G\ninst\u271d\u2079 : InvolutiveInv G\ninst\u271d\u2078 : ContinuousInv G\ninst\u271d\u2077 : Inv G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Inv G\ninst\u271d\u2074 : Mul G\ninst\u271d\u00b3 : ContinuousMul G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\n\u03b9 : Sort u_5\np : \u03b9 \u2192 Prop\ns : \u03b9 \u2192 Set G\nhb : (nhds 1).HasBasis p s\nx : G\n\u22a2 IsTopologicalGroup G"}]}
{"declaration": "theorem nhds_translation_div (x : G) : comap (\u00b7 / x) (\ud835\udcdd 1) = \ud835\udcdd x := by\n  simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}", "(G) in", "(G) in", "[TopologicalSpace G] [Div G] [ContinuousDiv G]", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "[Group G] [TopologicalSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b9\u2079 : TopologicalSpace G\ninst\u271d\u00b9\u2078 : Group G\ninst\u271d\u00b9\u2077 : ContinuousMul G\ninst\u271d\u00b9\u2076 : TopologicalSpace G\ninst\u271d\u00b9\u2075 : Inv G\ninst\u271d\u00b9\u2074 : ContinuousInv G\ninst\u271d\u00b9\u00b3 : TopologicalSpace G\ninst\u271d\u00b9\u00b2 : InvolutiveInv G\ninst\u271d\u00b9\u00b9 : ContinuousInv G\ninst\u271d\u00b9\u2070 : Inv G\ninst\u271d\u2079 : TopologicalSpace G\ninst\u271d\u2078 : Inv G\ninst\u271d\u2077 : Mul G\ninst\u271d\u2076 : ContinuousMul G\ninst\u271d\u2075 : TopologicalSpace G\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : IsTopologicalGroup G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nx : G\n\u22a2 comap (fun x_1 => x_1 / x) (nhds 1) = nhds x"}, {"line": "simpa only [div_eq_mul_inv] using nhds_translation_mul_inv x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem topologicalGroup_iInf {ts' : \u03b9 \u2192 TopologicalSpace G}\n    (h' : \u2200 i, @IsTopologicalGroup G (ts' i) _) : @IsTopologicalGroup G (\u2a05 i, ts' i) _ := by\n  rw [\u2190 sInf_range]\n  exact topologicalGroup_sInf (Set.forall_mem_range.mpr h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology MulOpposite Pointwise", "MulOpposite", "MulOpposite", "MulOpposite (continuous_op continuous_unop)"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Inv G] [ContinuousInv G]", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9 : Type*}", "(G\u2081 G\u2082 : Type*) [TopologicalSpace G\u2082] [T2Space G\u2082]", "[TopologicalSpace G] [InvolutiveInv G] [ContinuousInv G] {s : Set G}", "(G)", "{G}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "{\u03b9' : Sort*} [Inv G]", "[TopologicalSpace G] [Inv G] [Mul G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] [TopologicalSpace \u03b1] {f : \u03b1 \u2192 G}", "[TopologicalSpace H] [CommGroup H] [PartialOrder H] [IsOrderedMonoid H] [ContinuousInv H]", "(G)", "{G}", "(G) in", "(G) in", "[TopologicalSpace G] [Div G] [ContinuousDiv G]", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 G} {s : Set \u03b1} {x : \u03b1}", "[Group G] [TopologicalSpace G] [IsTopologicalGroup G]", "(G) [TopologicalSpace G] [Group G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G]", "(S : Subgroup G) [Subgroup.Normal S] [IsClosed (S : Set G)]", "[TopologicalSpace G] [MulOneClass G] [ContinuousMul G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G]", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G]", "[Monoid \u03b1] [TopologicalSpace \u03b1] [Monoid \u03b2] [TopologicalSpace \u03b2]", "{\u03b9 : Sort*} [Group G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b3\u2075 : TopologicalSpace G\ninst\u271d\u00b3\u2074 : Group G\ninst\u271d\u00b3\u00b3 : ContinuousMul G\ninst\u271d\u00b3\u00b2 : TopologicalSpace G\ninst\u271d\u00b3\u00b9 : Inv G\ninst\u271d\u00b3\u2070 : ContinuousInv G\ninst\u271d\u00b2\u2079 : TopologicalSpace G\ninst\u271d\u00b2\u2078 : InvolutiveInv G\ninst\u271d\u00b2\u2077 : ContinuousInv G\ninst\u271d\u00b2\u2076 : Inv G\ninst\u271d\u00b2\u2075 : TopologicalSpace G\ninst\u271d\u00b2\u2074 : Inv G\ninst\u271d\u00b2\u00b3 : Mul G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Group G\ninst\u271d\u00b9\u2079 : IsTopologicalGroup G\ninst\u271d\u00b9\u2078 : Group G\ninst\u271d\u00b9\u2077 : TopologicalSpace G\ninst\u271d\u00b9\u2076 : IsTopologicalGroup G\ninst\u271d\u00b9\u2075 : TopologicalSpace G\ninst\u271d\u00b9\u2074 : Group G\ninst\u271d\u00b9\u00b3 : ContinuousMul G\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\ninst\u271d\u00b9\u2070 : IsTopologicalGroup G\ninst\u271d\u2079 : TopologicalSpace G\ninst\u271d\u2078 : MulOneClass G\ninst\u271d\u2077 : ContinuousMul G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : IsTopologicalGroup G\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : IsTopologicalGroup G\n\u03b9 : Sort u_5\ninst\u271d : Group G\nts' : \u03b9 \u2192 TopologicalSpace G\nh' : \u2200 (i : \u03b9), IsTopologicalGroup G\n\u22a2 IsTopologicalGroup G"}, {"line": "rw [\u2190 sInf_range]", "tactic_state": "G : Type w\ninst\u271d\u00b3\u2075 : TopologicalSpace G\ninst\u271d\u00b3\u2074 : Group G\ninst\u271d\u00b3\u00b3 : ContinuousMul G\ninst\u271d\u00b3\u00b2 : TopologicalSpace G\ninst\u271d\u00b3\u00b9 : Inv G\ninst\u271d\u00b3\u2070 : ContinuousInv G\ninst\u271d\u00b2\u2079 : TopologicalSpace G\ninst\u271d\u00b2\u2078 : InvolutiveInv G\ninst\u271d\u00b2\u2077 : ContinuousInv G\ninst\u271d\u00b2\u2076 : Inv G\ninst\u271d\u00b2\u2075 : TopologicalSpace G\ninst\u271d\u00b2\u2074 : Inv G\ninst\u271d\u00b2\u00b3 : Mul G\ninst\u271d\u00b2\u00b2 : ContinuousMul G\ninst\u271d\u00b2\u00b9 : TopologicalSpace G\ninst\u271d\u00b2\u2070 : Group G\ninst\u271d\u00b9\u2079 : IsTopologicalGroup G\ninst\u271d\u00b9\u2078 : Group G\ninst\u271d\u00b9\u2077 : TopologicalSpace G\ninst\u271d\u00b9\u2076 : IsTopologicalGroup G\ninst\u271d\u00b9\u2075 : TopologicalSpace G\ninst\u271d\u00b9\u2074 : Group G\ninst\u271d\u00b9\u00b3 : ContinuousMul G\ninst\u271d\u00b9\u00b2 : TopologicalSpace G\ninst\u271d\u00b9\u00b9 : Group G\ninst\u271d\u00b9\u2070 : IsTopologicalGroup G\ninst\u271d\u2079 : TopologicalSpace G\ninst\u271d\u2078 : MulOneClass G\ninst\u271d\u2077 : ContinuousMul G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : Group G\ninst\u271d\u2074 : IsTopologicalGroup G\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : IsTopologicalGroup G\n\u03b9 : Sort u_5\ninst\u271d : Group G\nts' : \u03b9 \u2192 TopologicalSpace G\nh' : \u2200 (i : \u03b9), IsTopologicalGroup G\n\u22a2 IsTopologicalGroup G"}, {"line": "exact topologicalGroup_sInf (Set.forall_mem_range.mpr h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_mul' (g : GroupTopology \u03b1) :\n    haveI := g.toTopologicalSpace\n    Continuous fun p : \u03b1 \u00d7 \u03b1 => p.1 * p.2 := by\n  letI := g.toTopologicalSpace\n  haveI := g.toIsTopologicalGroup\n  exact continuous_mul\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/GroupTopology.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[Group \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\n\u22a2 Continuous fun p => p.1 * p.2"}, {"line": "letI := g.toTopologicalSpace", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\nthis : TopologicalSpace \u03b1 := sorry\n\u22a2 Continuous fun p => p.1 * p.2"}, {"line": "haveI := g.toIsTopologicalGroup", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\nthis\u271d : TopologicalSpace \u03b1 := sorry\nthis : IsTopologicalGroup \u03b1\n\u22a2 Continuous fun p => p.1 * p.2"}, {"line": "exact continuous_mul", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_inv' (g : GroupTopology \u03b1) :\n    haveI := g.toTopologicalSpace\n    Continuous (Inv.inv : \u03b1 \u2192 \u03b1) := by\n  letI := g.toTopologicalSpace\n  haveI := g.toIsTopologicalGroup\n  exact continuous_inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/GroupTopology.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[Group \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\n\u22a2 Continuous Inv.inv"}, {"line": "letI := g.toTopologicalSpace", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\nthis : TopologicalSpace \u03b1 := sorry\n\u22a2 Continuous Inv.inv"}, {"line": "haveI := g.toIsTopologicalGroup", "tactic_state": "\u03b1 : Type u\ninst\u271d : Group \u03b1\ng : GroupTopology \u03b1\nthis\u271d : TopologicalSpace \u03b1 := sorry\nthis : IsTopologicalGroup \u03b1\n\u22a2 Continuous Inv.inv"}, {"line": "exact continuous_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MulAction.isClosedMap_quotient [CompactSpace \u03b1] :\n    letI := orbitRel \u03b1 \u03b2\n    IsClosedMap (Quotient.mk' : \u03b2 \u2192 Quotient (orbitRel \u03b1 \u03b2)) := by\n  intro t ht\n  rw [\u2190 isQuotientMap_quotient_mk'.isClosed_preimage]\n  rw [MulAction.quotient_preimage_image_eq_union_mul]\n  convert ht.smul_left_of_isCompact (isCompact_univ (X := \u03b1))\n  rw [\u2190 biUnion_univ]\n  rw [\u2190 iUnion_smul_left_image]\n  simp only [image_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\n\u22a2 IsClosedMap Quotient.mk'"}, {"line": "intro t ht", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 IsClosed (Quotient.mk' '' t)"}, {"line": "rw [\u2190 isQuotientMap_quotient_mk'.isClosed_preimage]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 IsClosed (Quotient.mk' \u207b\u00b9' (Quotient.mk' '' t))"}, {"line": "rw [MulAction.quotient_preimage_image_eq_union_mul]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 IsClosed (\u22c3 g, (fun x => g \u2022 x) '' t)"}, {"line": "convert ht.smul_left_of_isCompact (isCompact_univ (X := \u03b1))", "tactic_state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 \u22c3 g, (fun x => g \u2022 x) '' t = univ \u2022 t\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousInv \u03b1\n---\ncase convert_4\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousSMul \u03b1 \u03b2\n---\ncase convert_5\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 TopologicalSpace \u03b1\n---\ncase convert_6\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 CompactSpace \u03b1"}, {"line": "rw [\u2190 biUnion_univ]", "tactic_state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 \u22c3 x \u2208 univ, (fun x_1 => x \u2022 x_1) '' t = univ \u2022 t\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousInv \u03b1\n---\ncase convert_4\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousSMul \u03b1 \u03b2\n---\ncase convert_5\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 TopologicalSpace \u03b1\n---\ncase convert_6\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 CompactSpace \u03b1"}, {"line": "rw [\u2190 iUnion_smul_left_image]", "tactic_state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 \u22c3 x \u2208 univ, (fun x_1 => x \u2022 x_1) '' t = \u22c3 a \u2208 univ, a \u2022 t\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousInv \u03b1\n---\ncase convert_4\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousSMul \u03b1 \u03b2\n---\ncase convert_5\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 TopologicalSpace \u03b1\n---\ncase convert_6\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 CompactSpace \u03b1"}, {"line": "simp only [image_smul]", "tactic_state": "case h.e'_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 \u22c3 x \u2208 univ, x \u2022 t = \u22c3 a \u2208 univ, a \u2022 t\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_1\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 Group \u03b1\n---\ncase convert_2\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 MulAction \u03b1 \u03b2\n---\ncase convert_3\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousInv \u03b1\n---\ncase convert_4\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 ContinuousSMul \u03b1 \u03b2\n---\ncase convert_5\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 TopologicalSpace \u03b1\n---\ncase convert_6\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b2\ninst\u271d\u2079 : Group \u03b1\ninst\u271d\u2078 : MulAction \u03b1 \u03b2\ninst\u271d\u2077 : ContinuousConstSMul \u03b1 \u03b2\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Group \u03b1\ninst\u271d\u00b2 : MulAction \u03b1 \u03b2\ninst\u271d\u00b9 : ContinuousInv \u03b1\ninst\u271d : CompactSpace \u03b1\nt : Set \u03b2\nht : IsClosed t\n\u22a2 CompactSpace \u03b1"}]}
{"declaration": "theorem singleton_mul_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : {a} * s \u2208 \ud835\udcdd a := by\n  simpa only [mul_one] using singleton_mul_mem_nhds a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 inst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousInv \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1 \u03b1\ns : Set \u03b1\na : \u03b1\nh : s \u2208 nhds 1\n\u22a2 {a} * s \u2208 nhds a"}, {"line": "simpa only [mul_one] using singleton_mul_mem_nhds a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.mul_right (hs : IsOpen s) : IsOpen (s * t) := by\n  rw [\u2190 image_op_smul]\n  exact hs.smul_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : ContinuousInv \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousConstSMul \u03b1 \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1\ns t : Set \u03b1\nhs : IsOpen s\n\u22a2 IsOpen (s * t)"}, {"line": "rw [\u2190 image_op_smul]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : ContinuousInv \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousConstSMul \u03b1 \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1\ns t : Set \u03b1\nhs : IsOpen s\n\u22a2 IsOpen (op '' t \u2022 s)"}, {"line": "exact hs.smul_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_singleton_mem_nhds (a : \u03b1) {b : \u03b1} (h : s \u2208 \ud835\udcdd b) : s * {a} \u2208 \ud835\udcdd (b * a) := by\n  rw [mul_singleton]\n  exact smul_mem_nhds_smul (op a) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : ContinuousInv \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousConstSMul \u03b1 \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1\ns : Set \u03b1\na b : \u03b1\nh : s \u2208 nhds b\n\u22a2 s * {a} \u2208 nhds (b * a)"}, {"line": "rw [mul_singleton]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : ContinuousInv \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousConstSMul \u03b1 \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1\ns : Set \u03b1\na b : \u03b1\nh : s \u2208 nhds b\n\u22a2 (fun x => x * a) '' s \u2208 nhds (b * a)"}, {"line": "exact smul_mem_nhds_smul (op a) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_singleton_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : s * {a} \u2208 \ud835\udcdd a := by\n  simpa only [one_mul] using mul_singleton_mem_nhds a h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9\u2070 : Group \u03b1\ninst\u271d\u2079 inst\u271d\u2078 : TopologicalSpace \u03b1\ninst\u271d\u2077 : Group \u03b1\ninst\u271d\u2076 : ContinuousInv \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : Group \u03b1\ninst\u271d\u00b3 : ContinuousConstSMul \u03b1 \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1\ns : Set \u03b1\na : \u03b1\nh : s \u2208 nhds 1\n\u22a2 s * {a} \u2208 nhds a"}, {"line": "simpa only [one_mul] using mul_singleton_mem_nhds a h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) := by\n  rw [\u2190 iUnion_div_left_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_left a t ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] {s t : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nht : IsOpen t\n\u22a2 IsOpen (s / t)"}, {"line": "rw [\u2190 iUnion_div_left_image]", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nht : IsOpen t\n\u22a2 IsOpen (\u22c3 a \u2208 s, (fun x => a / x) '' t)"}, {"line": "exact isOpen_biUnion fun a _ => isOpenMap_div_left a t ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.div_right (hs : IsOpen s) : IsOpen (s / t) := by\n  rw [\u2190 iUnion_div_right_image]\n  exact isOpen_biUnion fun a _ => isOpenMap_div_right a s hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] {s t : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nhs : IsOpen s\n\u22a2 IsOpen (s / t)"}, {"line": "rw [\u2190 iUnion_div_right_image]", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nhs : IsOpen s\n\u22a2 IsOpen (\u22c3 a \u2208 t, (fun x => x / a) '' s)"}, {"line": "exact isOpen_biUnion fun a _ => isOpenMap_div_right a s hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.mul_right_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (t * s) := by\n  rw [\u2190 image_op_smul]\n  exact IsClosed.smul_left_of_isCompact ht (hs.image continuous_op)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/Pointwise.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Pointwise MulOpposite"], "variables": ["{G : Type w} {H : Type x} {\u03b1 : Type u} {\u03b2 : Type v}", "[TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousConstSMul \u03b1 \u03b2] {s : Set \u03b1}", "[TopologicalSpace \u03b1]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [Group \u03b1] [MulAction \u03b1 \u03b2] [ContinuousInv \u03b1]", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace \u03b1] [Group \u03b1] [ContinuousConstSMul \u03b1\u1d50\u1d52\u1d56 \u03b1] {s t : Set \u03b1}", "[TopologicalSpace G] [Group G] [IsTopologicalGroup G] {s t : Set G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\n\u22a2 IsClosed (t * s)"}, {"line": "rw [\u2190 image_op_smul]", "tactic_state": "G : Type w\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : Group G\ninst\u271d : IsTopologicalGroup G\ns t : Set G\nht : IsClosed t\nhs : IsCompact s\n\u22a2 IsClosed (op '' s \u2022 t)"}, {"line": "exact IsClosed.smul_left_of_isCompact ht (hs.image continuous_op)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mapClusterPt_atTop_zpow_iff_pow [DivInvMonoid G] [TopologicalSpace G] {x y : G} :\n    MapClusterPt x atTop (y ^ \u00b7 : \u2124 \u2192 G) \u2194 MapClusterPt x atTop (y ^ \u00b7 : \u2115 \u2192 G) := by\n  simp_rw [MapClusterPt, \u2190 Nat.map_cast_int_atTop, map_map, comp_def, zpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/SubmonoidClosure.lean", "context": {"open": ["Filter Function Set", "scoped Topology"], "variables": ["{G : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : DivInvMonoid G\ninst\u271d : TopologicalSpace G\nx y : G\n\u22a2 (MapClusterPt x atTop fun x => y ^ x) \u2194 MapClusterPt x atTop fun x => y ^ x"}, {"line": "simp_rw [MapClusterPt, \u2190 Nat.map_cast_int_atTop, map_map, comp_def, zpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mapClusterPt_one_atTop_pow (x : G) : MapClusterPt 1 atTop (x ^ \u00b7 : \u2115 \u2192 G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/SubmonoidClosure.lean", "context": {"open": ["Filter Function Set", "scoped Topology"], "variables": ["{G : Type*}", "[Group G] [TopologicalSpace G] [CompactSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx : G\n\u22a2 MapClusterPt 1 atTop fun x_1 => x ^ x_1"}, {"line": "simpa using mapClusterPt_self_zpow_atTop_pow x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mapClusterPt_self_atTop_pow (x : G) : MapClusterPt x atTop (x ^ \u00b7 : \u2115 \u2192 G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/SubmonoidClosure.lean", "context": {"open": ["Filter Function Set", "scoped Topology"], "variables": ["{G : Type*}", "[Group G] [TopologicalSpace G] [CompactSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx : G\n\u22a2 MapClusterPt x atTop fun x_1 => x ^ x_1"}, {"line": "simpa using mapClusterPt_self_zpow_atTop_pow x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mapClusterPt_atTop_pow_tfae (x y : G) :\n    List.TFAE [\n      MapClusterPt x atTop (y ^ \u00b7 : \u2115 \u2192 G),\n      MapClusterPt x atTop (y ^ \u00b7 : \u2124 \u2192 G),\n      x \u2208 closure (range (y ^ \u00b7 : \u2115 \u2192 G)),\n      x \u2208 closure (range (y ^ \u00b7 : \u2124 \u2192 G)),\n    ] := by\n  tfae_have 2 \u2194 1 := mapClusterPt_atTop_zpow_iff_pow\n  tfae_have 3 \u2192 4 := by\n    refine fun h \u21a6 closure_mono (range_subset_iff.2 fun n \u21a6 ?_) h\n    exact \u27e8n, zpow_natCast _ _\u27e9\n  tfae_have 4 \u2192 1 := by\n    refine fun h \u21a6 closure_minimal ?_ isClosed_setOf_clusterPt h\n    exact range_subset_iff.2 (mapClusterPt_self_zpow_atTop_pow _)\n  tfae_have 1 \u2192 3 := by\n    rw [mem_closure_iff_clusterPt]\n    exact (ClusterPt.mono \u00b7 (le_principal_iff.2 range_mem_map))\n  tfae_finish\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/SubmonoidClosure.lean", "context": {"open": ["Filter Function Set", "scoped Topology"], "variables": ["{G : Type*}", "[Group G] [TopologicalSpace G] [CompactSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\n\u22a2 [MapClusterPt x atTop fun x => y ^ x, MapClusterPt x atTop fun x => y ^ x, x \u2208 closure (range fun x => y ^ x),\n      x \u2208 closure (range fun x => y ^ x)].TFAE"}, {"line": "tfae_have 2 \u2194 1 := mapClusterPt_atTop_zpow_iff_pow", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\ntfae_2_iff_1 : (MapClusterPt x atTop fun x => y ^ x) \u2194 MapClusterPt x atTop fun x => y ^ x\n\u22a2 [MapClusterPt x atTop fun x => y ^ x, MapClusterPt x atTop fun x => y ^ x, x \u2208 closure (range fun x => y ^ x),\n      x \u2208 closure (range fun x => y ^ x)].TFAE"}, {"line": "tfae_have 3 \u2192 4 := by\n    refine fun h \u21a6 closure_mono (range_subset_iff.2 fun n \u21a6 ?_) h\n    exact \u27e8n, zpow_natCast _ _\u27e9", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\ntfae_2_iff_1 : (MapClusterPt x atTop fun x => y ^ x) \u2194 MapClusterPt x atTop fun x => y ^ x\ntfae_3_to_4 : x \u2208 closure (range fun x => y ^ x) \u2192 x \u2208 closure (range fun x => y ^ x)\n\u22a2 [MapClusterPt x atTop fun x => y ^ x, MapClusterPt x atTop fun x => y ^ x, x \u2208 closure (range fun x => y ^ x),\n      x \u2208 closure (range fun x => y ^ x)].TFAE"}, {"line": "tfae_have 4 \u2192 1 := by\n    refine fun h \u21a6 closure_minimal ?_ isClosed_setOf_clusterPt h\n    exact range_subset_iff.2 (mapClusterPt_self_zpow_atTop_pow _)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\ntfae_2_iff_1 : (MapClusterPt x atTop fun x => y ^ x) \u2194 MapClusterPt x atTop fun x => y ^ x\ntfae_3_to_4 : x \u2208 closure (range fun x => y ^ x) \u2192 x \u2208 closure (range fun x => y ^ x)\ntfae_4_to_1 : x \u2208 closure (range fun x => y ^ x) \u2192 MapClusterPt x atTop fun x => y ^ x\n\u22a2 [MapClusterPt x atTop fun x => y ^ x, MapClusterPt x atTop fun x => y ^ x, x \u2208 closure (range fun x => y ^ x),\n      x \u2208 closure (range fun x => y ^ x)].TFAE"}, {"line": "tfae_have 1 \u2192 3 := by\n    rw [mem_closure_iff_clusterPt]\n    exact (ClusterPt.mono \u00b7 (le_principal_iff.2 range_mem_map))", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\ntfae_2_iff_1 : (MapClusterPt x atTop fun x => y ^ x) \u2194 MapClusterPt x atTop fun x => y ^ x\ntfae_3_to_4 : x \u2208 closure (range fun x => y ^ x) \u2192 x \u2208 closure (range fun x => y ^ x)\ntfae_4_to_1 : x \u2208 closure (range fun x => y ^ x) \u2192 MapClusterPt x atTop fun x => y ^ x\ntfae_1_to_3 : (MapClusterPt x atTop fun x => y ^ x) \u2192 x \u2208 closure (range fun x => y ^ x)\n\u22a2 [MapClusterPt x atTop fun x => y ^ x, MapClusterPt x atTop fun x => y ^ x, x \u2208 closure (range fun x => y ^ x),\n      x \u2208 closure (range fun x => y ^ x)].TFAE"}, {"line": "tfae_finish", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closure_range_zpow_eq_pow (x : G) :\n    closure (range (x ^ \u00b7 : \u2124 \u2192 G)) = closure (range (x ^ \u00b7 : \u2115 \u2192 G)) := by\n  ext y\n  exact (mapClusterPt_atTop_pow_tfae y x).out 3 2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Group/SubmonoidClosure.lean", "context": {"open": ["Filter Function Set", "scoped Topology"], "variables": ["{G : Type*}", "[Group G] [TopologicalSpace G] [CompactSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx : G\n\u22a2 closure (range fun x_1 => x ^ x_1) = closure (range fun x_1 => x ^ x_1)"}, {"line": "ext y", "tactic_state": "case h\nG : Type u_1\ninst\u271d\u00b3 : Group G\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : CompactSpace G\ninst\u271d : IsTopologicalGroup G\nx y : G\n\u22a2 y \u2208 closure (range fun x_1 => x ^ x_1) \u2194 y \u2208 closure (range fun x_1 => x ^ x_1)"}, {"line": "exact (mapClusterPt_atTop_pow_tfae y x).out 3 2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_one : HasProd (fun _ \u21a6 1 : \u03b2 \u2192 \u03b1) 1 := by simp [HasProd, tendsto_const_nhds]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 HasProd (fun x => 1) 1"}, {"line": "simp [HasProd, tendsto_const_nhds]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_empty [IsEmpty \u03b2] : HasProd f 1 := by\n  convert @hasProd_one \u03b1 \u03b2 _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : IsEmpty \u03b2\n\u22a2 HasProd f 1"}, {"line": "convert @hasProd_one \u03b1 \u03b2 _ _", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : IsEmpty \u03b2\nx\u271d : \u03b2\n\u22a2 f x\u271d = 1"}]}
{"declaration": "theorem hasProd_subtype_iff_mulIndicator {s : Set \u03b2} :\n    HasProd (f \u2218 (\u2191) : s \u2192 \u03b1) a \u2194 HasProd (s.mulIndicator f) a := by\n  rw [\u2190 Set.mulIndicator_range_comp]\n  rw [Subtype.range_coe]\n  rw [hasProd_subtype_iff_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b2\n\u22a2 HasProd (f \u2218 Subtype.val) a \u2194 HasProd (s.mulIndicator f) a"}, {"line": "rw [\u2190 Set.mulIndicator_range_comp]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b2\n\u22a2 HasProd ((Set.range Subtype.val).mulIndicator f \u2218 Subtype.val) a \u2194 HasProd (s.mulIndicator f) a\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b2\n\u22a2 One \u03b1"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b2\n\u22a2 HasProd (s.mulIndicator f \u2218 Subtype.val) a \u2194 HasProd (s.mulIndicator f) a\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ns : Set \u03b2\n\u22a2 One \u03b1"}, {"line": "rw [hasProd_subtype_iff_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Set.Finite.multipliable {s : Set \u03b2} (hs : s.Finite) (f : \u03b2 \u2192 \u03b1) :\n    Multipliable (f \u2218 (\u2191) : s \u2192 \u03b1) := by\n  have := hs.toFinset.multipliable f\n  rwa [hs.coe_toFinset] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nhs : s.Finite\nf : \u03b2 \u2192 \u03b1\n\u22a2 Multipliable (f \u2218 Subtype.val)"}, {"line": "have := hs.toFinset.multipliable f", "tactic_state": "case refine_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nhs : s.Finite\nf : \u03b2 \u2192 \u03b1\nthis : Multipliable (f \u2218 Subtype.val)\n\u22a2 Multipliable (f \u2218 Subtype.val)\n---\ncase refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nhs : s.Finite\nf : \u03b2 \u2192 \u03b1\n\u22a2 CommMonoid \u03b1\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nhs : s.Finite\nf : \u03b2 \u2192 \u03b1\n\u22a2 TopologicalSpace \u03b1"}, {"line": "rwa [hs.coe_toFinset] at this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_ite_eq (b : \u03b2) [DecidablePred (\u00b7 = b)] (a : \u03b1) :\n    HasProd (fun b' \u21a6 if b' = b then a else 1) a := by\n  convert @hasProd_single _ _ _ _ (fun b' \u21a6 if b' = b then a else 1) b (fun b' hb' \u21a6 if_neg hb')\n  exact (if_pos rfl).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 HasProd (fun b' => if b' = b then a else 1) a"}, {"line": "convert @hasProd_single _ _ _ _ (fun b' \u21a6 if b' = b then a else 1) b (fun b' hb' \u21a6 if_neg hb')", "tactic_state": "case h.e'_6\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 a = if b = b then a else 1"}, {"line": "exact (if_pos rfl).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Equiv.hasProd_iff_of_mulSupport {g : \u03b3 \u2192 \u03b1} (e : mulSupport f \u2243 mulSupport g)\n    (he : \u2200 x : mulSupport f, g (e x) = f x) : HasProd f a \u2194 HasProd g a := by\n  have : (g \u2218 (\u2191)) \u2218 e = f \u2218 (\u2191) := funext he\n  rw [\u2190 hasProd_subtype_mulSupport]\n  rw [\u2190 this]\n  rw [e.hasProd_iff]\n  rw [hasProd_subtype_mulSupport]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ng : \u03b3 \u2192 \u03b1\ne : \u2191(mulSupport f) \u2243 \u2191(mulSupport g)\nhe : \u2200 (x : \u2191(mulSupport f)), g \u2191(e x) = f \u2191x\n\u22a2 HasProd f a \u2194 HasProd g a"}, {"line": "have : (g \u2218 (\u2191)) \u2218 e = f \u2218 (\u2191) := funext he", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ng : \u03b3 \u2192 \u03b1\ne : \u2191(mulSupport f) \u2243 \u2191(mulSupport g)\nhe : \u2200 (x : \u2191(mulSupport f)), g \u2191(e x) = f \u2191x\nthis : (g \u2218 Subtype.val) \u2218 \u21d1e = f \u2218 Subtype.val\n\u22a2 HasProd f a \u2194 HasProd g a"}, {"line": "rw [\u2190 hasProd_subtype_mulSupport]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ng : \u03b3 \u2192 \u03b1\ne : \u2191(mulSupport f) \u2243 \u2191(mulSupport g)\nhe : \u2200 (x : \u2191(mulSupport f)), g \u2191(e x) = f \u2191x\nthis : (g \u2218 Subtype.val) \u2218 \u21d1e = f \u2218 Subtype.val\n\u22a2 HasProd (f \u2218 Subtype.val) a \u2194 HasProd g a"}, {"line": "rw [\u2190 this]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ng : \u03b3 \u2192 \u03b1\ne : \u2191(mulSupport f) \u2243 \u2191(mulSupport g)\nhe : \u2200 (x : \u2191(mulSupport f)), g \u2191(e x) = f \u2191x\nthis : (g \u2218 Subtype.val) \u2218 \u21d1e = f \u2218 Subtype.val\n\u22a2 HasProd ((g \u2218 Subtype.val) \u2218 \u21d1e) a \u2194 HasProd g a"}, {"line": "rw [e.hasProd_iff]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na : \u03b1\ng : \u03b3 \u2192 \u03b1\ne : \u2191(mulSupport f) \u2243 \u2191(mulSupport g)\nhe : \u2200 (x : \u2191(mulSupport f)), g \u2191(e x) = f \u2191x\nthis : (g \u2218 Subtype.val) \u2218 \u21d1e = f \u2218 Subtype.val\n\u22a2 HasProd (g \u2218 Subtype.val) a \u2194 HasProd g a"}, {"line": "rw [hasProd_subtype_mulSupport]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.mul (hf : HasProd f a) (hg : HasProd g b) :\n    HasProd (fun b \u21a6 f b * g b) (a * b) := by\n  dsimp only [HasProd] at hf hg \u22a2\n  simp_rw [prod_mul_distrib]\n  exact hf.mul hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\nhf : HasProd f a\nhg : HasProd g b\n\u22a2 HasProd (fun b => f b * g b) (a * b)"}, {"line": "dsimp only [HasProd] at hf hg \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\nhf : Tendsto (fun s => \u220f b \u2208 s, f b) atTop (nhds a)\nhg : Tendsto (fun s => \u220f b \u2208 s, g b) atTop (nhds b)\n\u22a2 Tendsto (fun s => \u220f b \u2208 s, f b * g b) atTop (nhds (a * b))"}, {"line": "simp_rw [prod_mul_distrib]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf g : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\nhf : Tendsto (fun s => \u220f b \u2208 s, f b) atTop (nhds a)\nhg : Tendsto (fun s => \u220f b \u2208 s, g b) atTop (nhds b)\n\u22a2 Tendsto (fun s => (\u220f x \u2208 s, f x) * \u220f x \u2208 s, g x) atTop (nhds (a * b))"}, {"line": "exact hf.mul hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.mul_disjoint {s t : Set \u03b2} (hs : Disjoint s t) (ha : HasProd (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasProd (f \u2218 (\u2191) : t \u2192 \u03b1) b) : HasProd (f \u2218 (\u2191) : (s \u222a t : Set \u03b2) \u2192 \u03b1) (a * b) := by\n  rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Set.mulIndicator_union_of_disjoint hs]\n  exact ha.mul hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\ns t : Set \u03b2\nhs : Disjoint s t\nha : HasProd (f \u2218 Subtype.val) a\nhb : HasProd (f \u2218 Subtype.val) b\n\u22a2 HasProd (f \u2218 Subtype.val) (a * b)"}, {"line": "rw [hasProd_subtype_iff_mulIndicator] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\ns t : Set \u03b2\nhs : Disjoint s t\nha : HasProd (s.mulIndicator f) a\nhb : HasProd (t.mulIndicator f) b\n\u22a2 HasProd ((s \u222a t).mulIndicator f) (a * b)"}, {"line": "rw [Set.mulIndicator_union_of_disjoint hs]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\ns t : Set \u03b2\nhs : Disjoint s t\nha : HasProd (s.mulIndicator f) a\nhb : HasProd (t.mulIndicator f) b\n\u22a2 HasProd (fun a => s.mulIndicator f a * t.mulIndicator f a) (a * b)"}, {"line": "exact ha.mul hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_prod_disjoint {\u03b9} (s : Finset \u03b9) {t : \u03b9 \u2192 Set \u03b2} {a : \u03b9 \u2192 \u03b1}\n    (hs : (s : Set \u03b9).Pairwise (Disjoint on t)) (hf : \u2200 i \u2208 s, HasProd (f \u2218 (\u2191) : t i \u2192 \u03b1) (a i)) :\n    HasProd (f \u2218 (\u2191) : (\u22c3 i \u2208 s, t i) \u2192 \u03b1) (\u220f i \u2208 s, a i) := by\n  simp_rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Finset.mulIndicator_biUnion _ _ hs]\n  exact hasProd_prod hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : ContinuousMul \u03b1\n\u03b9 : Type u_4\ns : Finset \u03b9\nt : \u03b9 \u2192 Set \u03b2\na : \u03b9 \u2192 \u03b1\nhs : (\u2191s).Pairwise (onFun Disjoint t)\nhf : \u2200 i \u2208 s, HasProd (f \u2218 Subtype.val) (a i)\n\u22a2 HasProd (f \u2218 Subtype.val) (\u220f i \u2208 s, a i)"}, {"line": "simp_rw [hasProd_subtype_iff_mulIndicator] at *", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : ContinuousMul \u03b1\n\u03b9 : Type u_4\ns : Finset \u03b9\nt : \u03b9 \u2192 Set \u03b2\na : \u03b9 \u2192 \u03b1\nhs : (\u2191s).Pairwise (onFun Disjoint t)\nhf : \u2200 i \u2208 s, HasProd ((t i).mulIndicator f) (a i)\n\u22a2 HasProd ((\u22c3 i \u2208 s, t i).mulIndicator f) (\u220f i \u2208 s, a i)"}, {"line": "rw [Finset.mulIndicator_biUnion _ _ hs]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : ContinuousMul \u03b1\n\u03b9 : Type u_4\ns : Finset \u03b9\nt : \u03b9 \u2192 Set \u03b2\na : \u03b9 \u2192 \u03b1\nhs : (\u2191s).Pairwise (onFun Disjoint t)\nhf : \u2200 i \u2208 s, HasProd ((t i).mulIndicator f) (a i)\n\u22a2 HasProd (fun a => \u220f i \u2208 s, (t i).mulIndicator f a) (\u220f i \u2208 s, a i)"}, {"line": "exact hasProd_prod hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.mul_isCompl {s t : Set \u03b2} (hs : IsCompl s t) (ha : HasProd (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasProd (f \u2218 (\u2191) : t \u2192 \u03b1) b) : HasProd f (a * b) := by\n  simpa [\u2190 hs.compl_eq] using\n    (hasProd_subtype_iff_mulIndicator.1 ha).mul (hasProd_subtype_iff_mulIndicator.1 hb)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na b : \u03b1\ninst\u271d : ContinuousMul \u03b1\ns t : Set \u03b2\nhs : IsCompl s t\nha : HasProd (f \u2218 Subtype.val) a\nhb : HasProd (f \u2218 Subtype.val) b\n\u22a2 HasProd f (a * b)"}, {"line": "simpa [\u2190 hs.compl_eq] using\n    (hasProd_subtype_iff_mulIndicator.1 ha).mul (hasProd_subtype_iff_mulIndicator.1 hb)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_congr_set_coe (f : \u03b2 \u2192 \u03b1) {s t : Set \u03b2} (h : s = t) :\n    \u220f' x : s, f x = \u220f' x : t, f x := by rw [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ns t : Set \u03b2\nh : s = t\n\u22a2 \u220f' (x : \u2191s), f \u2191x = \u220f' (x : \u2191t), f \u2191x"}, {"line": "rw [h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_eq_finprod (hf : (mulSupport f).Finite) :\n    \u220f' b, f b = \u220f\u1da0 b, f b := by simp [tprod_def, multipliable_of_finite_mulSupport hf, hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : (mulSupport f).Finite\n\u22a2 \u220f' (b : \u03b2), f b = \u220f\u1da0 (b : \u03b2), f b"}, {"line": "simp [tprod_def, multipliable_of_finite_mulSupport hf, hf]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : (mulSupport f).Finite\n\u22a2 (\u00acMultipliable fun b => f b) \u2192 1 = \u220f\u1da0 (b : \u03b2), f b"}]}
{"declaration": "theorem tprod_one : \u220f' _ : \u03b2, (1 : \u03b1) = 1 := by rw [tprod_eq_finprod] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 \u220f' (x : \u03b2), 1 = 1"}, {"line": "rw [tprod_eq_finprod] <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_empty [IsEmpty \u03b2] : \u220f' b, f b = 1 := by\n  rw [tprod_eq_prod (s := (\u2205 : Finset \u03b2))] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : IsEmpty \u03b2\n\u22a2 \u220f' (b : \u03b2), f b = 1"}, {"line": "rw [tprod_eq_prod (s := (\u2205 : Finset \u03b2))] <;> simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : IsEmpty \u03b2\n\u22a2 \u2200 (b : \u03b2), f b = 1"}]}
{"declaration": "theorem prod_eq_tprod_mulIndicator (f : \u03b2 \u2192 \u03b1) (s : Finset \u03b2) :\n    \u220f x \u2208 s, f x = \u220f' x, Set.mulIndicator (\u2191s) f x := by\n  rw [tprod_eq_prod' (Set.mulSupport_mulIndicator_subset)]\n  rw [Finset.prod_mulIndicator_subset _ Finset.Subset.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Finset \u03b2\n\u22a2 \u220f x \u2208 s, f x = \u220f' (x : \u03b2), (\u2191s).mulIndicator f x"}, {"line": "rw [tprod_eq_prod' (Set.mulSupport_mulIndicator_subset)]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ns : Finset \u03b2\n\u22a2 \u220f x \u2208 s, f x = \u220f b \u2208 s, (\u2191s).mulIndicator f b"}, {"line": "rw [Finset.prod_mulIndicator_subset _ Finset.Subset.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_eq_mulSingle {f : \u03b2 \u2192 \u03b1} (b : \u03b2) (hf : \u2200 b' \u2260 b, f b' = 1) :\n    \u220f' b, f b = f b := by\n  rw [tprod_eq_prod (s := {b})]\n  rw [prod_singleton]\n  exact fun b' hb' \u21a6 hf b' (by simpa using hb')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhf : \u2200 (b' : \u03b2), b' \u2260 b \u2192 f b' = 1\n\u22a2 \u220f' (b : \u03b2), f b = f b"}, {"line": "rw [tprod_eq_prod (s := {b})]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhf : \u2200 (b' : \u03b2), b' \u2260 b \u2192 f b' = 1\n\u22a2 \u220f b \u2208 {b}, f b = f b\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhf : \u2200 (b' : \u03b2), b' \u2260 b \u2192 f b' = 1\n\u22a2 \u2200 b_1 \u2209 {b}, f b_1 = 1"}, {"line": "rw [prod_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nb : \u03b2\nhf : \u2200 (b' : \u03b2), b' \u2260 b \u2192 f b' = 1\n\u22a2 \u2200 b_1 \u2209 {b}, f b_1 = 1"}, {"line": "exact fun b' hb' \u21a6 hf b' (by simpa using hb')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_ite_eq (b : \u03b2) [DecidablePred (\u00b7 = b)] (a : \u03b1) :\n    \u220f' b', (if b' = b then a else 1) = a := by\n  rw [tprod_eq_mulSingle b]\n  \u00b7 simp\n  \u00b7 intro b' hb'; simp [hb']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 (\u220f' (b' : \u03b2), if b' = b then a else 1) = a"}, {"line": "rw [tprod_eq_mulSingle b]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 (if b = b then a else 1) = a\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 \u2200 (b' : \u03b2), b' \u2260 b \u2192 (if b' = b then a else 1) = 1"}, {"line": "\u00b7 simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nb : \u03b2\ninst\u271d : DecidablePred fun x => x = b\na : \u03b1\n\u22a2 \u2200 (b' : \u03b2), b' \u2260 b \u2192 (if b' = b then a else 1) = 1"}, {"line": "\u00b7 intro b' hb'; simp [hb']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.tprod_subtype' (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    \u220f' x : (s : Set \u03b2), f x = \u220f x \u2208 s, f x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191\u2191s), f \u2191x = \u220f x \u2208 s, f x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_singleton (b : \u03b2) (f : \u03b2 \u2192 \u03b1) : \u220f' x : ({b} : Set \u03b2), f x = f b := by\n  rw [\u2190 coe_singleton]\n  rw [Finset.tprod_subtype']\n  rw [prod_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nb : \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191{b}), f \u2191x = f b"}, {"line": "rw [\u2190 coe_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nb : \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191\u2191{b}), f \u2191x = f b"}, {"line": "rw [Finset.tprod_subtype']", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nb : \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f x \u2208 {b}, f x = f b"}, {"line": "rw [prod_singleton]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_subtype (s : Set \u03b2) (f : \u03b2 \u2192 \u03b1) : \u220f' x : s, f x = \u220f' x, s.mulIndicator f x := by\n  rw [\u2190 tprod_subtype_eq_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]\n  rw [tprod_congr]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191s), f \u2191x = \u220f' (x : \u03b2), s.mulIndicator f x"}, {"line": "rw [\u2190 tprod_subtype_eq_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191s), f \u2191x = \u220f' (x : \u2191s), s.mulIndicator f \u2191x"}, {"line": "rw [tprod_congr]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 \u2200 (b : \u2191s), f \u2191b = s.mulIndicator f \u2191b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_dite_right (P : Prop) [Decidable P] (x : \u03b2 \u2192 \u00acP \u2192 \u03b1) :\n    \u220f' b : \u03b2, (if h : P then (1 : \u03b1) else x b h) = if h : P then (1 : \u03b1) else \u220f' b : \u03b2, x b h := by\n  by_cases hP : P <;> simp [hP]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nP : Prop\ninst\u271d : Decidable P\nx : \u03b2 \u2192 \u00acP \u2192 \u03b1\n\u22a2 (\u220f' (b : \u03b2), if h : P then 1 else x b h) = if h : P then 1 else \u220f' (b : \u03b2), x b h"}, {"line": "by_cases hP : P <;> simp [hP]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_dite_left (P : Prop) [Decidable P] (x : \u03b2 \u2192 P \u2192 \u03b1) :\n    \u220f' b : \u03b2, (if h : P then x b h else 1) = if h : P then \u220f' b : \u03b2, x b h else 1 := by\n  by_cases hP : P <;> simp [hP]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "context": {"open": ["Filter Finset Function Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a b : \u03b1}", "[ContinuousMul \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] {f g : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nP : Prop\ninst\u271d : Decidable P\nx : \u03b2 \u2192 P \u2192 \u03b1\n\u22a2 (\u220f' (b : \u03b2), if h : P then x b h else 1) = if h : P then \u220f' (b : \u03b2), x b h else 1"}, {"line": "by_cases hP : P <;> simp [hP]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_pi_single [DecidableEq \u03b2] (b : \u03b2) (a : \u03b1) : HasProd (Pi.mulSingle b a) a := by\n  convert hasProd_ite_eq b a\n  simp [Pi.mulSingle_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 HasProd (Pi.mulSingle b a) a"}, {"line": "convert hasProd_ite_eq b a", "tactic_state": "case h.e'_5.h\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\nx\u271d : \u03b2\n\u22a2 Pi.mulSingle b a x\u271d = if x\u271d = b then a else 1\n---\ncase convert_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 DecidablePred fun x => x = b"}, {"line": "simp [Pi.mulSingle_apply]", "tactic_state": "case convert_3\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 DecidablePred fun x => x = b"}]}
{"declaration": "theorem tprod_pi_single [DecidableEq \u03b2] (b : \u03b2) (a : \u03b1) : \u220f' b', Pi.mulSingle b a b' = a := by\n  rw [tprod_eq_mulSingle b]\n  \u00b7 simp\n  \u00b7 intro b' hb'; simp [hb']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 \u220f' (b' : \u03b2), Pi.mulSingle b a b' = a"}, {"line": "rw [tprod_eq_mulSingle b]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 Pi.mulSingle b a b = a\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 \u2200 (b' : \u03b2), b' \u2260 b \u2192 Pi.mulSingle b a b' = 1"}, {"line": "\u00b7 simp", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : DecidableEq \u03b2\nb : \u03b2\na : \u03b1\n\u22a2 \u2200 (b' : \u03b2), b' \u2260 b \u2192 Pi.mulSingle b a b' = 1"}, {"line": "\u00b7 intro b' hb'; simp [hb']", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tprod_setProd_singleton_left (b : \u03b2) (t : Set \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (\u220f' x : {b} \u00d7\u02e2 t, f x) = \u220f' c : t, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.singleton_prod]\n  rw [tprod_image _ (Prod.mk_right_injective b).injOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nb : \u03b2\nt : Set \u03b3\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191({b} \u00d7\u02e2 t)), f \u2191x = \u220f' (c : \u2191t), f (b, \u2191c)"}, {"line": "rw [tprod_congr_set_coe _ Set.singleton_prod]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nb : \u03b2\nt : Set \u03b3\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191(Prod.mk b '' t)), f \u2191x = \u220f' (c : \u2191t), f (b, \u2191c)"}, {"line": "rw [tprod_image _ (Prod.mk_right_injective b).injOn]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tprod_setProd_singleton_right (s : Set \u03b2) (c : \u03b3) (f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1) :\n    (\u220f' x : s \u00d7\u02e2 {c}, f x) = \u220f' b : s, f (b, c) := by\n  rw [tprod_congr_set_coe _ Set.prod_singleton]\n  rw [tprod_image _ (Prod.mk_left_injective c).injOn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nc : \u03b3\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191(s \u00d7\u02e2 {c})), f \u2191x = \u220f' (b : \u2191s), f (\u2191b, c)"}, {"line": "rw [tprod_congr_set_coe _ Set.prod_singleton]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b2\nc : \u03b3\nf : \u03b2 \u00d7 \u03b3 \u2192 \u03b1\n\u22a2 \u220f' (x : \u2191((fun a => (a, c)) '' s)), f \u2191x = \u220f' (b : \u2191s), f (\u2191b, c)"}, {"line": "rw [tprod_image _ (Prod.mk_left_injective c).injOn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.prodMk {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b3} {a : \u03b1} {b : \u03b3} (hf : HasProd f a)\n    (hg : HasProd g b) : HasProd (fun x \u21a6 (\u27e8f x, g x\u27e9 : \u03b1 \u00d7 \u03b3)) \u27e8a, b\u27e9 := by\n  simp [HasProd, \u2190 prod_mk_prod, Filter.Tendsto.prodMk_nhds hf hg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b3\ninst\u271d : TopologicalSpace \u03b3\nf : \u03b2 \u2192 \u03b1\ng : \u03b2 \u2192 \u03b3\na : \u03b1\nb : \u03b3\nhf : HasProd f a\nhg : HasProd g b\n\u22a2 HasProd (fun x => (f x, g x)) (a, b)"}, {"line": "simp [HasProd, \u2190 prod_mk_prod, Filter.Tendsto.prodMk_nhds hf hg]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\n\u03b3 : Type u_3\ninst\u271d\u2075 : CommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CommMonoid \u03b3\ninst\u271d : TopologicalSpace \u03b3\nf : \u03b2 \u2192 \u03b1\ng : \u03b2 \u2192 \u03b3\na : \u03b1\nb : \u03b3\nhf : HasProd f a\nhg : HasProd g b\n\u22a2 Tendsto (fun s => (\u220f x \u2208 s, f x, \u220f x \u2208 s, g x)) atTop (nhds (a, b))"}]}
{"declaration": "theorem HasProd.sigma_of_hasProd {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3 b : \u03b2, \u03b3 b) \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1}\n    {a : \u03b1} (ha : HasProd g a) (hf : \u2200 b, HasProd (fun c \u21a6 f \u27e8b, c\u27e9) (g b)) (hf' : Multipliable f) :\n    HasProd f a := by simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2078 : CommMonoid \u03b1\ninst\u271d\u2077 : TopologicalSpace \u03b1\ninst\u271d\u2076 : CommMonoid \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : ContinuousMul \u03b1\ninst\u271d\u00b9 : RegularSpace \u03b1\ninst\u271d : T3Space \u03b1\n\u03b3 : \u03b2 \u2192 Type u_4\nf : (b : \u03b2) \u00d7 \u03b3 b \u2192 \u03b1\ng : \u03b2 \u2192 \u03b1\na : \u03b1\nha : HasProd g a\nhf : \u2200 (b : \u03b2), HasProd (fun c => f \u27e8b, c\u27e9) (g b)\nhf' : Multipliable f\n\u22a2 HasProd f a"}, {"line": "simpa [(hf'.hasProd.sigma hf).unique ha] using hf'.hasProd", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pi.hasProd {f : \u03b9 \u2192 \u2200 x, \u03c0 x} {g : \u2200 x, \u03c0 x} :\n    HasProd f g \u2194 \u2200 x, HasProd (fun i \u21a6 f i x) (g x) := by\n  simp only [HasProd]\n  simp only [tendsto_pi_nhds]\n  simp only [prod_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1] [IsUniformGroup \u03b1]", "[CompleteSpace \u03b1]", "[T0Space \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b1 \u2192 Type*} [\u2200 x, CommMonoid (\u03c0 x)] [\u2200 x, TopologicalSpace (\u03c0 x)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\ng : (x : \u03b1) \u2192 \u03c0 x\n\u22a2 HasProd f g \u2194 \u2200 (x : \u03b1), HasProd (fun i => f i x) (g x)"}, {"line": "simp only [HasProd]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\ng : (x : \u03b1) \u2192 \u03c0 x\n\u22a2 Tendsto (fun s => \u220f b \u2208 s, f b) atTop (nhds g) \u2194 \u2200 (x : \u03b1), Tendsto (fun s => \u220f x_1 \u2208 s, f x_1 x) atTop (nhds (g x))"}, {"line": "simp only [tendsto_pi_nhds]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\ng : (x : \u03b1) \u2192 \u03c0 x\n\u22a2 (\u2200 (x : \u03b1), Tendsto (fun i => (\u220f b \u2208 i, f b) x) atTop (nhds (g x))) \u2194\n    \u2200 (x : \u03b1), Tendsto (fun s => \u220f x_1 \u2208 s, f x_1 x) atTop (nhds (g x))"}, {"line": "simp only [prod_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pi.multipliable {f : \u03b9 \u2192 \u2200 x, \u03c0 x} : Multipliable f \u2194 \u2200 x, Multipliable fun i \u21a6 f i x := by\n  simp only [Multipliable]\n  simp only [Pi.hasProd]\n  simp only [Classical.skolem]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1] [IsUniformGroup \u03b1]", "[CompleteSpace \u03b1]", "[T0Space \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b1 \u2192 Type*} [\u2200 x, CommMonoid (\u03c0 x)] [\u2200 x, TopologicalSpace (\u03c0 x)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\n\u22a2 Multipliable f \u2194 \u2200 (x : \u03b1), Multipliable fun i => f i x"}, {"line": "simp only [Multipliable]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\n\u22a2 (\u2203 a, HasProd f a) \u2194 \u2200 (x : \u03b1), \u2203 a, HasProd (fun i => f i x) a"}, {"line": "simp only [Pi.hasProd]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b9 : CommMonoid \u03b1\ninst\u271d\u00b9\u2070 : TopologicalSpace \u03b1\ninst\u271d\u2079 : ContinuousMul \u03b1\ninst\u271d\u2078 : RegularSpace \u03b1\ninst\u271d\u2077 : T3Space \u03b1\ninst\u271d\u2076 : CommGroup \u03b1\ninst\u271d\u2075 : UniformSpace \u03b1\ninst\u271d\u2074 : IsUniformGroup \u03b1\ninst\u271d\u00b3 : CompleteSpace \u03b1\ninst\u271d\u00b2 : T0Space \u03b1\n\u03b9 : Type u_4\n\u03c0 : \u03b1 \u2192 Type u_5\ninst\u271d\u00b9 : (x : \u03b1) \u2192 CommMonoid (\u03c0 x)\ninst\u271d : (x : \u03b1) \u2192 TopologicalSpace (\u03c0 x)\nf : \u03b9 \u2192 (x : \u03b1) \u2192 \u03c0 x\n\u22a2 (\u2203 a, \u2200 (x : \u03b1), HasProd (fun i => f i x) (a x)) \u2194 \u2200 (x : \u03b1), \u2203 a, HasProd (fun i => f i x) a"}, {"line": "simp only [Classical.skolem]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_op [T2Space \u03b1] :\n    \u2211' x, op (f x) = op (\u2211' x, f x) := by\n  by_cases h : Summable f\n  \u00b7 exact h.hasSum.op.tsum_eq\n  \u00b7 have ho := summable_op.not.mpr h\n    rw [tsum_eq_zero_of_not_summable h]\n    rw [tsum_eq_zero_of_not_summable ho]\n    rw [op_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology", "MulOpposite"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1] [IsUniformGroup \u03b1]", "[CompleteSpace \u03b1]", "[T0Space \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b1 \u2192 Type*} [\u2200 x, CommMonoid (\u03c0 x)] [\u2200 x, TopologicalSpace (\u03c0 x)]", "[AddCommMonoid \u03b1] [TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : ContinuousMul \u03b1\ninst\u271d\u2079 : RegularSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : CommGroup \u03b1\ninst\u271d\u2076 : UniformSpace \u03b1\ninst\u271d\u2075 : IsUniformGroup \u03b1\ninst\u271d\u2074 : CompleteSpace \u03b1\ninst\u271d\u00b3 : T0Space \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\n\u22a2 \u2211' (x : \u03b2), op (f x) = op (\u2211' (x : \u03b2), f x)"}, {"line": "by_cases h : Summable f", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : ContinuousMul \u03b1\ninst\u271d\u2079 : RegularSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : CommGroup \u03b1\ninst\u271d\u2076 : UniformSpace \u03b1\ninst\u271d\u2075 : IsUniformGroup \u03b1\ninst\u271d\u2074 : CompleteSpace \u03b1\ninst\u271d\u00b3 : T0Space \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nh : sorry\n\u22a2 \u2211' (x : \u03b2), op (f x) = op (\u2211' (x : \u03b2), f x)\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : ContinuousMul \u03b1\ninst\u271d\u2079 : RegularSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : CommGroup \u03b1\ninst\u271d\u2076 : UniformSpace \u03b1\ninst\u271d\u2075 : IsUniformGroup \u03b1\ninst\u271d\u2074 : CompleteSpace \u03b1\ninst\u271d\u00b3 : T0Space \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nh : \u00acsorry\n\u22a2 \u2211' (x : \u03b2), op (f x) = op (\u2211' (x : \u03b2), f x)"}, {"line": "\u00b7 exact h.hasSum.op.tsum_eq", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : ContinuousMul \u03b1\ninst\u271d\u2079 : RegularSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : CommGroup \u03b1\ninst\u271d\u2076 : UniformSpace \u03b1\ninst\u271d\u2075 : IsUniformGroup \u03b1\ninst\u271d\u2074 : CompleteSpace \u03b1\ninst\u271d\u00b3 : T0Space \u03b1\ninst\u271d\u00b2 : AddCommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nh : \u00acsorry\n\u22a2 \u2211' (x : \u03b2), op (f x) = op (\u2211' (x : \u03b2), f x)"}, {"line": "\u00b7 have ho := summable_op.not.mpr h\n    rw [tsum_eq_zero_of_not_summable h]\n    rw [tsum_eq_zero_of_not_summable ho]\n    rw [op_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Summable.ofStar (hf : Summable fun b \u21a6 Star.star (f b)) : Summable f := by\n  simpa only [star_star] using hf.star\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology", "MulOpposite"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1] [IsUniformGroup \u03b1]", "[CompleteSpace \u03b1]", "[T0Space \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b1 \u2192 Type*} [\u2200 x, CommMonoid (\u03c0 x)] [\u2200 x, TopologicalSpace (\u03c0 x)]", "[AddCommMonoid \u03b1] [TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[AddCommMonoid \u03b1] [TopologicalSpace \u03b1] [StarAddMonoid \u03b1] [ContinuousStar \u03b1] {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u2079 : CommMonoid \u03b1\ninst\u271d\u00b9\u2078 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2077 : CommMonoid \u03b1\ninst\u271d\u00b9\u2076 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2075 : CommMonoid \u03b1\ninst\u271d\u00b9\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u00b3 : ContinuousMul \u03b1\ninst\u271d\u00b9\u00b2 : RegularSpace \u03b1\ninst\u271d\u00b9\u00b9 : T3Space \u03b1\ninst\u271d\u00b9\u2070 : CommGroup \u03b1\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : IsUniformGroup \u03b1\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : T0Space \u03b1\ninst\u271d\u2075 : AddCommMonoid \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : AddCommMonoid \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : StarAddMonoid \u03b1\ninst\u271d : ContinuousStar \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : Summable fun b => Star.star (f b)\n\u22a2 Summable f"}, {"line": "simpa only [star_star] using hf.star", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tsum_star [T2Space \u03b1] : star (\u2211' b, f b) = \u2211' b, star (f b) := by\n  by_cases hf : Summable f\n  \u00b7 exact hf.hasSum.star.tsum_eq.symm\n  \u00b7 rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt Summable.ofStar hf),\n      star_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Constructions.lean", "context": {"open": ["Filter Finset Function", "scoped Topology", "MulOpposite"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [CommMonoid \u03b3] [TopologicalSpace \u03b3]", "[CommMonoid \u03b1] [TopologicalSpace \u03b1] [ContinuousMul \u03b1]", "[RegularSpace \u03b1]", "[T3Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1] [IsUniformGroup \u03b1]", "[CompleteSpace \u03b1]", "[T0Space \u03b1]", "{\u03b9 : Type*} {\u03c0 : \u03b1 \u2192 Type*} [\u2200 x, CommMonoid (\u03c0 x)] [\u2200 x, TopologicalSpace (\u03c0 x)]", "[AddCommMonoid \u03b1] [TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}", "[AddCommMonoid \u03b1] [TopologicalSpace \u03b1] [StarAddMonoid \u03b1] [ContinuousStar \u03b1] {f : \u03b2 \u2192 \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u2070 : CommMonoid \u03b1\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2078 : CommMonoid \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : ContinuousMul \u03b1\ninst\u271d\u00b9\u00b3 : RegularSpace \u03b1\ninst\u271d\u00b9\u00b2 : T3Space \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : UniformSpace \u03b1\ninst\u271d\u2079 : IsUniformGroup \u03b1\ninst\u271d\u2078 : CompleteSpace \u03b1\ninst\u271d\u2077 : T0Space \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : StarAddMonoid \u03b1\ninst\u271d\u00b9 : ContinuousStar \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\n\u22a2 star (\u2211' (b : \u03b2), f b) = \u2211' (b : \u03b2), star (f b)"}, {"line": "by_cases hf : Summable f", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u2070 : CommMonoid \u03b1\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2078 : CommMonoid \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : ContinuousMul \u03b1\ninst\u271d\u00b9\u00b3 : RegularSpace \u03b1\ninst\u271d\u00b9\u00b2 : T3Space \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : UniformSpace \u03b1\ninst\u271d\u2079 : IsUniformGroup \u03b1\ninst\u271d\u2078 : CompleteSpace \u03b1\ninst\u271d\u2077 : T0Space \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : StarAddMonoid \u03b1\ninst\u271d\u00b9 : ContinuousStar \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : sorry\n\u22a2 star (\u2211' (b : \u03b2), f b) = \u2211' (b : \u03b2), star (f b)\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u2070 : CommMonoid \u03b1\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2078 : CommMonoid \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : ContinuousMul \u03b1\ninst\u271d\u00b9\u00b3 : RegularSpace \u03b1\ninst\u271d\u00b9\u00b2 : T3Space \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : UniformSpace \u03b1\ninst\u271d\u2079 : IsUniformGroup \u03b1\ninst\u271d\u2078 : CompleteSpace \u03b1\ninst\u271d\u2077 : T0Space \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : StarAddMonoid \u03b1\ninst\u271d\u00b9 : ContinuousStar \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : \u00acsorry\n\u22a2 star (\u2211' (b : \u03b2), f b) = \u2211' (b : \u03b2), star (f b)"}, {"line": "\u00b7 exact hf.hasSum.star.tsum_eq.symm", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u2070 : CommMonoid \u03b1\ninst\u271d\u00b9\u2079 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2078 : CommMonoid \u03b1\ninst\u271d\u00b9\u2077 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2076 : CommMonoid \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : ContinuousMul \u03b1\ninst\u271d\u00b9\u00b3 : RegularSpace \u03b1\ninst\u271d\u00b9\u00b2 : T3Space \u03b1\ninst\u271d\u00b9\u00b9 : CommGroup \u03b1\ninst\u271d\u00b9\u2070 : UniformSpace \u03b1\ninst\u271d\u2079 : IsUniformGroup \u03b1\ninst\u271d\u2078 : CompleteSpace \u03b1\ninst\u271d\u2077 : T0Space \u03b1\ninst\u271d\u2076 : AddCommMonoid \u03b1\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : AddCommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : StarAddMonoid \u03b1\ninst\u271d\u00b9 : ContinuousStar \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : \u00acsorry\n\u22a2 star (\u2211' (b : \u03b2), f b) = \u2211' (b : \u03b2), star (f b)"}, {"line": "\u00b7 rw [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (mt Summable.ofStar hf),\n      star_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_eq_one_of_not_multipliable (h : \u00acMultipliable f) : \u220f' b, f b = 1 := by\n  simp [tprod_def, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "context": {"open": ["Filter Function", "scoped Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nh : \u00acMultipliable f\n\u22a2 \u220f' (b : \u03b2), f b = 1"}, {"line": "simp [tprod_def, h]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Finset.hasProd (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    HasProd (f \u2218 (\u2191) : (\u2191s : Set \u03b2) \u2192 \u03b1) (\u220f b \u2208 s, f b) := by\n  rw [\u2190 prod_attach]\n  exact hasProd_fintype _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "context": {"open": ["Filter Function", "scoped Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 HasProd (f \u2218 Subtype.val) (\u220f b \u2208 s, f b)"}, {"line": "rw [\u2190 prod_attach]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\ns : Finset \u03b2\nf : \u03b2 \u2192 \u03b1\n\u22a2 HasProd (f \u2218 Subtype.val) (\u220f x \u2208 s.attach, f \u2191x)"}, {"line": "exact hasProd_fintype _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multipliable.hasProd (ha : Multipliable f) : HasProd f (\u220f' b, f b) := by\n  simp only [tprod_def]\n  simp only [ha]\n  simp only [dite_true]\n  by_cases H : (mulSupport f).Finite\n  \u00b7 simp [H, hasProd_prod_of_ne_finset_one, finprod_eq_prod]\n  \u00b7 simpa [H] using ha.choose_spec\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "context": {"open": ["Filter Function", "scoped Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\n\u22a2 HasProd f (\u220f' (b : \u03b2), f b)"}, {"line": "simp only [tprod_def]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\n\u22a2 HasProd f\n    (if h : Multipliable fun b => f b then if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose h\n    else 1)"}, {"line": "simp only [ha]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\n\u22a2 HasProd f (if h : True then if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose \u22ef else 1)"}, {"line": "simp only [dite_true]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\n\u22a2 HasProd f (if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose \u22ef)"}, {"line": "by_cases H : (mulSupport f).Finite", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\nH : sorry\n\u22a2 HasProd f (if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose \u22ef)\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\nH : \u00acsorry\n\u22a2 HasProd f (if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose \u22ef)"}, {"line": "\u00b7 simp [H, hasProd_prod_of_ne_finset_one, finprod_eq_prod]", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : CommMonoid \u03b1\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\nha : Multipliable f\nH : \u00acsorry\n\u22a2 HasProd f (if (mulSupport fun b => f b).Finite then \u220f\u1da0 (b : \u03b2), f b else Exists.choose \u22ef)"}, {"line": "\u00b7 simpa [H] using ha.choose_spec", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.unique {a\u2081 a\u2082 : \u03b1} [T2Space \u03b1] : HasProd f a\u2081 \u2192 HasProd f a\u2082 \u2192 a\u2081 = a\u2082 := by\n  classical exact tendsto_nhds_unique\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Defs.lean", "context": {"open": ["Filter Function", "scoped Topology", "scoped Classical in"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommMonoid \u03b1] [TopologicalSpace \u03b1]", "{f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Finset \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nf : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\ninst\u271d : T2Space \u03b1\n\u22a2 HasProd f a\u2081 \u2192 HasProd f a\u2082 \u2192 a\u2081 = a\u2082"}, {"line": "classical exact tendsto_nhds_unique", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_tsum_of_dist_le_of_tendsto (d : \u2115 \u2192 \u211d) (hf : \u2200 n, dist (f n) (f n.succ) \u2264 d n)\n    (hd : Summable d) {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) (n : \u2115) :\n    dist (f n) a \u2264 \u2211' m, d (n + m) := by\n  refine le_of_tendsto (tendsto_const_nhds.dist ha) (eventually_atTop.2 \u27e8n, fun m hnm \u21a6 ?_\u27e9)\n  refine le_trans (dist_le_Ico_sum_of_dist_le hnm fun _ _ \u21a6 hf _) ?_\n  rw [sum_Ico_eq_sum_range]\n  refine Summable.sum_le_tsum (range _) (fun _ _ \u21a6 le_trans dist_nonneg (hf _)) ?_\n  exact hd.comp_injective (add_right_injective n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn : \u2115\n\u22a2 dist (f n) a \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "refine le_of_tendsto (tendsto_const_nhds.dist ha) (eventually_atTop.2 \u27e8n, fun m hnm \u21a6 ?_\u27e9)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 dist (f n) (f m) \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "refine le_trans (dist_le_Ico_sum_of_dist_le hnm fun _ _ \u21a6 hf _) ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 \u2211 i \u2208 Ico n m, d i \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "rw [sum_Ico_eq_sum_range]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 \u2211 k \u2208 range (m - n), d (n + k) \u2264 \u2211' (m : \u2115), d (n + m)"}, {"line": "refine Summable.sum_le_tsum (range _) (fun _ _ \u21a6 le_trans dist_nonneg (hf _)) ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\na : \u03b1\nha : Tendsto f atTop (nhds a)\nn m : \u2115\nhnm : m \u2265 n\n\u22a2 Summable fun k => d (n + k)"}, {"line": "exact hd.comp_injective (add_right_injective n)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_tsum_of_dist_le_of_tendsto\u2080 (d : \u2115 \u2192 \u211d) (hf : \u2200 n, dist (f n) (f n.succ) \u2264 d n)\n    (hd : Summable d) (ha : Tendsto f atTop (\ud835\udcdd a)) : dist (f 0) a \u2264 tsum d := by\n  simpa only [zero_add] using dist_le_tsum_of_dist_le_of_tendsto d hf hd ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\na : \u03b1\nd : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), dist (f n) (f n.succ) \u2264 d n\nhd : Summable d\nha : Tendsto f atTop (nhds a)\n\u22a2 dist (f 0) a \u2264 tsum d"}, {"line": "simpa only [zero_add] using dist_le_tsum_of_dist_le_of_tendsto d hf hd ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le_tsum_dist_of_tendsto\u2080 (h : Summable fun n \u21a6 dist (f n) (f n.succ))\n    (ha : Tendsto f atTop (\ud835\udcdd a)) : dist (f 0) a \u2264 \u2211' n, dist (f n) (f n.succ) := by\n  simpa only [zero_add] using dist_le_tsum_dist_of_tendsto h ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : PseudoMetricSpace \u03b1\nf : \u2115 \u2192 \u03b1\na : \u03b1\nh : Summable fun n => dist (f n) (f n.succ)\nha : Tendsto f atTop (nhds a)\n\u22a2 dist (f 0) a \u2264 \u2211' (n : \u2115), dist (f n) (f n.succ)"}, {"line": "simpa only [zero_add] using dist_le_tsum_dist_of_tendsto h ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_iff_not_tendsto_nat_atTop_of_nonneg {f : \u2115 \u2192 \u211d} (hf : \u2200 n, 0 \u2264 f n) :\n    Summable f \u2194 \u00acTendsto (fun n : \u2115 => \u2211 i \u2208 Finset.range n, f i) atTop atTop := by\n  rw [\u2190 not_iff_not]\n  rw [Classical.not_not]\n  rw [not_summable_iff_tendsto_nat_atTop_of_nonneg hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\n\u22a2 Summable f \u2194 \u00acTendsto (fun n => \u2211 i \u2208 range n, f i) atTop atTop"}, {"line": "rw [\u2190 not_iff_not]", "tactic_state": "f : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\n\u22a2 \u00acSummable f \u2194 \u00ac\u00acTendsto (fun n => \u2211 i \u2208 range n, f i) atTop atTop"}, {"line": "rw [Classical.not_not]", "tactic_state": "f : \u2115 \u2192 \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\n\u22a2 \u00acSummable f \u2194 Tendsto (fun n => \u2211 i \u2208 range n, f i) atTop atTop"}, {"line": "rw [not_summable_iff_tendsto_nat_atTop_of_nonneg hf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma summable_partition {\u03b1 \u03b2 : Type*} {f : \u03b2 \u2192 \u211d} (hf : 0 \u2264 f) {s : \u03b1  \u2192 Set \u03b2}\n    (hs : \u2200 i, \u2203! j, i \u2208 s j) : Summable f \u2194\n      (\u2200 j, Summable fun i : s j \u21a6 f i) \u2227 Summable fun j \u21a6 \u2211' i : s j, f i := by\n  simpa only [\u2190 (Set.sigmaEquiv s hs).summable_iff] using summable_sigma_of_nonneg (fun _ \u21a6 hf _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\n\u03b2 : Type u_4\nf : \u03b2 \u2192 \u211d\nhf : 0 \u2264 f\ns : \u03b1 \u2192 Set \u03b2\nhs : \u2200 (i : \u03b2), \u2203! j, i \u2208 s j\n\u22a2 Summable f \u2194 (\u2200 (j : \u03b1), Summable fun i => f \u2191i) \u2227 Summable fun j => \u2211' (i : \u2191(s j)), f \u2191i"}, {"line": "simpa only [\u2190 (Set.sigmaEquiv s hs).summable_iff] using summable_sigma_of_nonneg (fun _ \u21a6 hf _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_of_sum_range_le {f : \u2115 \u2192 \u211d} {c : \u211d} (hf : \u2200 n, 0 \u2264 f n)\n    (h : \u2200 n, \u2211 i \u2208 Finset.range n, f i \u2264 c) : Summable f := by\n  refine (summable_iff_not_tendsto_nat_atTop_of_nonneg hf).2 fun H => ?_\n  rcases exists_lt_of_tendsto_atTop H 0 c with \u27e8n, -, hn\u27e9\n  exact lt_irrefl _ (hn.trans_le (h n))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Real.lean", "context": {"open": ["Filter Finset NNReal Topology"], "variables": ["{\u03b1 \u03b2 : Type*} [PseudoMetricSpace \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2115 \u2192 \u211d\nc : \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\nh : \u2200 (n : \u2115), \u2211 i \u2208 range n, f i \u2264 c\n\u22a2 Summable f"}, {"line": "refine (summable_iff_not_tendsto_nat_atTop_of_nonneg hf).2 fun H => ?_", "tactic_state": "f : \u2115 \u2192 \u211d\nc : \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\nh : \u2200 (n : \u2115), \u2211 i \u2208 range n, f i \u2264 c\nH : Tendsto (fun n => \u2211 i \u2208 range n, f i) atTop atTop\n\u22a2 False"}, {"line": "rcases exists_lt_of_tendsto_atTop H 0 c with \u27e8n, -, hn\u27e9", "tactic_state": "case intro.intro\nf : \u2115 \u2192 \u211d\nc : \u211d\nhf : \u2200 (n : \u2115), 0 \u2264 f n\nh : \u2200 (n : \u2115), \u2211 i \u2208 range n, f i \u2264 c\nH : Tendsto (fun n => \u2211 i \u2208 range n, f i) atTop atTop\nn : \u2115\nhn : c < \u2211 i \u2208 range n, f i\n\u22a2 False"}, {"line": "exact lt_irrefl _ (hn.trans_le (h n))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_sum_mul_antidiagonal_of_summable_mul\n    (h : Summable fun x : A \u00d7 A \u21a6 f x.1 * g x.2) :\n    Summable fun n \u21a6 \u2211 kl \u2208 antidiagonal n, f kl.1 * g kl.2 := by\n  rw [summable_mul_prod_iff_summable_mul_sigma_antidiagonal] at h\n  conv => congr; ext; rw [\u2190 Finset.sum_finset_coe, \u2190 tsum_fintype]\n  exact h.sigma' fun n \u21a6 (hasSum_fintype _).summable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Ring.lean", "context": {"open": ["Filter Finset Function"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[NonUnitalNonAssocSemiring \u03b1] [TopologicalSpace \u03b1] [IsTopologicalSemiring \u03b1] {f : \u03b9 \u2192 \u03b1}", "[T2Space \u03b1]", "[DivisionSemiring \u03b1] [TopologicalSpace \u03b1] [IsTopologicalSemiring \u03b1]", "[TopologicalSpace \u03b1] [T3Space \u03b1] [NonUnitalNonAssocSemiring \u03b1] [IsTopologicalSemiring \u03b1]", "{A : Type*} [AddCommMonoid A] [HasAntidiagonal A]", "[TopologicalSpace \u03b1] [NonUnitalNonAssocSemiring \u03b1] {f g : A \u2192 \u03b1}", "[T3Space \u03b1] [IsTopologicalSemiring \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh : Summable fun x => f x.1 * g x.2\n\u22a2 Summable fun n => \u2211 kl \u2208 antidiagonal n, f kl.1 * g kl.2"}, {"line": "rw [summable_mul_prod_iff_summable_mul_sigma_antidiagonal] at h", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh\u271d : Summable fun x => f x.1 * g x.2\nh : Summable fun x => f (\u2191x.snd).1 * g (\u2191x.snd).2\n\u22a2 Summable fun n => \u2211 kl \u2208 antidiagonal n, f kl.1 * g kl.2\n---\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh : Summable fun x => f x.1 * g x.2\n\u22a2 AddCommMonoid A\n---\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh : Summable fun x => f x.1 * g x.2\n\u22a2 HasAntidiagonal A"}, {"line": "conv => congr; ext; rw [\u2190 Finset.sum_finset_coe, \u2190 tsum_fintype]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh\u271d : Summable fun x => f x.1 * g x.2\nh : Summable fun x => f (\u2191x.snd).1 * g (\u2191x.snd).2\n\u22a2 Summable fun x => \u2211' (b : \u2191\u2191(antidiagonal x)), f (\u2191b).1 * g (\u2191b).2\n---\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh : Summable fun x => f x.1 * g x.2\n\u22a2 AddCommMonoid A\n---\n\u03b1 : Type u_3\ninst\u271d\u00b9\u2076 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u00b9\u2075 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2074 : IsTopologicalSemiring \u03b1\ninst\u271d\u00b9\u00b3 : T2Space \u03b1\ninst\u271d\u00b9\u00b2 : DivisionSemiring \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalSemiring \u03b1\ninst\u271d\u2079 : TopologicalSpace \u03b1\ninst\u271d\u2078 : T3Space \u03b1\ninst\u271d\u2077 : NonUnitalNonAssocSemiring \u03b1\ninst\u271d\u2076 : IsTopologicalSemiring \u03b1\nA : Type u_4\ninst\u271d\u2075 : AddCommMonoid A\ninst\u271d\u2074 : HasAntidiagonal A\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : NonUnitalNonAssocSemiring \u03b1\nf g : A \u2192 \u03b1\ninst\u271d\u00b9 : T3Space \u03b1\ninst\u271d : IsTopologicalSemiring \u03b1\nh : Summable fun x => f x.1 * g x.2\n\u22a2 HasAntidiagonal A"}, {"line": "exact h.sigma' fun n \u21a6 (hasSum_fintype _).summable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multipliable.of_inv (hf : Multipliable fun b \u21a6 (f b)\u207b\u00b9) : Multipliable f := by\n  simpa only [inv_inv] using hf.inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\nhf : Multipliable fun b => (f b)\u207b\u00b9\n\u22a2 Multipliable f"}, {"line": "simpa only [inv_inv] using hf.inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.div (hf : HasProd f a\u2081) (hg : HasProd g a\u2082) :\n    HasProd (fun b \u21a6 f b / g b) (a\u2081 / a\u2082) := by\n  simp only [div_eq_mul_inv]\n  exact hf.mul hg.inv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf g : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\nhf : HasProd f a\u2081\nhg : HasProd g a\u2082\n\u22a2 HasProd (fun b => f b / g b) (a\u2081 / a\u2082)"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf g : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\nhf : HasProd f a\u2081\nhg : HasProd g a\u2082\n\u22a2 HasProd (fun b => f b * (g b)\u207b\u00b9) (a\u2081 * a\u2082\u207b\u00b9)"}, {"line": "exact hf.mul hg.inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multipliable.trans_div (hg : Multipliable g) (hfg : Multipliable fun b \u21a6 f b / g b) :\n    Multipliable f := by\n  simpa only [div_mul_cancel] using hfg.mul hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf g : \u03b2 \u2192 \u03b1\nhg : Multipliable g\nhfg : Multipliable fun b => f b / g b\n\u22a2 Multipliable f"}, {"line": "simpa only [div_mul_cancel] using hfg.mul hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasProd.hasProd_compl_iff {s : Set \u03b2} (hf : HasProd (f \u2218 (\u2191) : s \u2192 \u03b1) a\u2081) :\n    HasProd (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1) a\u2082 \u2194 HasProd f (a\u2081 * a\u2082) := by\n  refine \u27e8fun h \u21a6 hf.mul_compl h, fun h \u21a6 ?_\u27e9\n  rw [hasProd_subtype_iff_mulIndicator] at hf \u22a2\n  rw [Set.mulIndicator_compl]\n  simpa only [div_eq_mul_inv,mul_inv_cancel_comm] using h.div hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\ns : Set \u03b2\nhf : HasProd (f \u2218 Subtype.val) a\u2081\n\u22a2 HasProd (f \u2218 Subtype.val) a\u2082 \u2194 HasProd f (a\u2081 * a\u2082)"}, {"line": "refine \u27e8fun h \u21a6 hf.mul_compl h, fun h \u21a6 ?_\u27e9", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\ns : Set \u03b2\nhf : HasProd (f \u2218 Subtype.val) a\u2081\nh : HasProd f (a\u2081 * a\u2082)\n\u22a2 HasProd (f \u2218 Subtype.val) a\u2082"}, {"line": "rw [hasProd_subtype_iff_mulIndicator] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\ns : Set \u03b2\nhf : HasProd (s.mulIndicator f) a\u2081\nh : HasProd f (a\u2081 * a\u2082)\n\u22a2 HasProd (s\u1d9c.mulIndicator f) a\u2082"}, {"line": "rw [Set.mulIndicator_compl]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\na\u2081 a\u2082 : \u03b1\ns : Set \u03b2\nhf : HasProd (s.mulIndicator f) a\u2081\nh : HasProd f (a\u2081 * a\u2082)\n\u22a2 HasProd (f * (s.mulIndicator f)\u207b\u00b9) a\u2082"}, {"line": "simpa only [div_eq_mul_inv,mul_inv_cancel_comm] using h.div hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_inv : \u220f' b, (f b)\u207b\u00b9 = (\u220f' b, f b)\u207b\u00b9 := by\n  by_cases hf : Multipliable f\n  \u00b7 exact hf.hasProd.inv.tprod_eq\n  \u00b7 simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}", "[T2Space \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CommGroup \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\n\u22a2 \u220f' (b : \u03b2), (f b)\u207b\u00b9 = (\u220f' (b : \u03b2), f b)\u207b\u00b9"}, {"line": "by_cases hf : Multipliable f", "tactic_state": "case pos\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CommGroup \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : sorry\n\u22a2 \u220f' (b : \u03b2), (f b)\u207b\u00b9 = (\u220f' (b : \u03b2), f b)\u207b\u00b9\n---\ncase neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CommGroup \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : \u00acsorry\n\u22a2 \u220f' (b : \u03b2), (f b)\u207b\u00b9 = (\u220f' (b : \u03b2), f b)\u207b\u00b9"}, {"line": "\u00b7 exact hf.hasProd.inv.tprod_eq", "tactic_state": "case neg\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : CommGroup \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : IsTopologicalGroup \u03b1\nf : \u03b2 \u2192 \u03b1\ninst\u271d : T2Space \u03b1\nhf : \u00acsorry\n\u22a2 \u220f' (b : \u03b2), (f b)\u207b\u00b9 = (\u220f' (b : \u03b2), f b)\u207b\u00b9"}, {"line": "\u00b7 simp [tprod_eq_one_of_not_multipliable hf,\n      tprod_eq_one_of_not_multipliable (mt Multipliable.of_inv hf)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multipliable.countable_mulSupport [FirstCountableTopology G] [T1Space G]\n    (hf : Multipliable f) : f.mulSupport.Countable := by\n  simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Group.lean", "context": {"open": ["Filter Finset Function", "scoped Topology"], "variables": ["{\u03b1 \u03b2 \u03b3 : Type*}", "[CommGroup \u03b1] [TopologicalSpace \u03b1] [IsTopologicalGroup \u03b1]", "{f g : \u03b2 \u2192 \u03b1} {a a\u2081 a\u2082 : \u03b1}", "[T2Space \u03b1]", "[CommGroup \u03b1] [UniformSpace \u03b1]", "[IsUniformGroup \u03b1] {f g : \u03b2 \u2192 \u03b1}", "[CompleteSpace \u03b1]", "{G : Type*} [TopologicalSpace G] [CommGroup G] [IsTopologicalGroup G] {f : \u03b1 \u2192 G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9\u00b2 : CommGroup \u03b1\ninst\u271d\u00b9\u00b9 : TopologicalSpace \u03b1\ninst\u271d\u00b9\u2070 : IsTopologicalGroup \u03b1\ninst\u271d\u2079 : T2Space \u03b1\ninst\u271d\u2078 : CommGroup \u03b1\ninst\u271d\u2077 : UniformSpace \u03b1\ninst\u271d\u2076 : IsUniformGroup \u03b1\ninst\u271d\u2075 : CompleteSpace \u03b1\nG : Type u_4\ninst\u271d\u2074 : TopologicalSpace G\ninst\u271d\u00b3 : CommGroup G\ninst\u271d\u00b2 : IsTopologicalGroup G\nf : \u03b1 \u2192 G\ninst\u271d\u00b9 : FirstCountableTopology G\ninst\u271d : T1Space G\nhf : Multipliable f\n\u22a2 (mulSupport f).Countable"}, {"line": "simpa only [ker_nhds] using hf.tendsto_cofinite_one.countable_compl_preimage_ker", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rel_iSup_prod [CompleteLattice \u03b1] (m : \u03b1 \u2192 M) (m0 : m \u22a5 = 1) (R : M \u2192 M \u2192 Prop)\n    (m_iSup : \u2200 s : \u2115 \u2192 \u03b1, R (m (\u2a06 i, s i)) (\u220f' i, m (s i))) (s : \u03b3 \u2192 \u03b1) (t : Finset \u03b3) :\n    R (m (\u2a06 d \u2208 t, s d)) (\u220f d \u2208 t, m (s d)) := by\n  rw [iSup_subtype']\n  rw [\u2190 Finset.tprod_subtype]\n  exact rel_iSup_tprod m m0 R m_iSup _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "context": {"open": ["Filter Finset Function Encodable", "scoped Topology"], "variables": ["{M : Type*} [CommMonoid M] [TopologicalSpace M] {m m' : M}", "{G : Type*} [CommGroup G] {g g' : G}", "[ContinuousMul M]", "[ContinuousMul M]", "{\u03b1 \u03b2 \u03b3 : Type*}", "[Encodable \u03b2]", "[Countable \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\n\u03b3 : Type u_5\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns : \u03b3 \u2192 \u03b1\nt : Finset \u03b3\n\u22a2 R (m (\u2a06 d \u2208 t, s d)) (\u220f d \u2208 t, m (s d))"}, {"line": "rw [iSup_subtype']", "tactic_state": "M : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\n\u03b3 : Type u_5\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns : \u03b3 \u2192 \u03b1\nt : Finset \u03b3\n\u22a2 R (m (\u2a06 x, s \u2191x)) (\u220f d \u2208 t, m (s d))"}, {"line": "rw [\u2190 Finset.tprod_subtype]", "tactic_state": "M : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\n\u03b3 : Type u_5\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns : \u03b3 \u2192 \u03b1\nt : Finset \u03b3\n\u22a2 R (m (\u2a06 x, s \u2191x)) (\u220f' (x : { x // x \u2208 t }), m (s \u2191x))\n---\nM : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\n\u03b3 : Type u_5\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns : \u03b3 \u2192 \u03b1\nt : Finset \u03b3\n\u22a2 TopologicalSpace M"}, {"line": "exact rel_iSup_tprod m m0 R m_iSup _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rel_sup_mul [CompleteLattice \u03b1] (m : \u03b1 \u2192 M) (m0 : m \u22a5 = 1) (R : M \u2192 M \u2192 Prop)\n    (m_iSup : \u2200 s : \u2115 \u2192 \u03b1, R (m (\u2a06 i, s i)) (\u220f' i, m (s i))) (s\u2081 s\u2082 : \u03b1) :\n    R (m (s\u2081 \u2294 s\u2082)) (m s\u2081 * m s\u2082) := by\n  convert rel_iSup_tprod m m0 R m_iSup fun b \u21a6 cond b s\u2081 s\u2082\n  \u00b7 simp only [iSup_bool_eq, cond]\n  \u00b7 rw [tprod_fintype, Fintype.prod_bool, cond, cond]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "context": {"open": ["Filter Finset Function Encodable", "scoped Topology"], "variables": ["{M : Type*} [CommMonoid M] [TopologicalSpace M] {m m' : M}", "{G : Type*} [CommGroup G] {g g' : G}", "[ContinuousMul M]", "[ContinuousMul M]", "{\u03b1 \u03b2 \u03b3 : Type*}", "[Encodable \u03b2]", "[Countable \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns\u2081 s\u2082 : \u03b1\n\u22a2 R (m (s\u2081 \u2294 s\u2082)) (m s\u2081 * m s\u2082)"}, {"line": "convert rel_iSup_tprod m m0 R m_iSup fun b \u21a6 cond b s\u2081 s\u2082", "tactic_state": "case h.e'_1.h.e'_1\nM : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns\u2081 s\u2082 : \u03b1\n\u22a2 s\u2081 \u2294 s\u2082 = \u2a06 b, bif b then s\u2081 else s\u2082\n---\ncase h.e'_2\nM : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns\u2081 s\u2082 : \u03b1\n\u22a2 m s\u2081 * m s\u2082 = \u220f' (b : Bool), m (bif b then s\u2081 else s\u2082)"}, {"line": "\u00b7 simp only [iSup_bool_eq, cond]", "tactic_state": "case h.e'_2\nM : Type u_1\ninst\u271d\u2074 : CommMonoid M\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 inst\u271d\u00b9 : ContinuousMul M\n\u03b1 : Type u_3\ninst\u271d : CompleteLattice \u03b1\nm : \u03b1 \u2192 M\nm0 : m \u22a5 = 1\nR : M \u2192 M \u2192 Prop\nm_iSup : \u2200 (s : \u2115 \u2192 \u03b1), R (m (\u2a06 i, s i)) (\u220f' (i : \u2115), m (s i))\ns\u2081 s\u2082 : \u03b1\n\u22a2 m s\u2081 * m s\u2082 = \u220f' (b : Bool), m (bif b then s\u2081 else s\u2082)"}, {"line": "\u00b7 rw [tprod_fintype, Fintype.prod_bool, cond, cond]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tprod_eq_zero_mul'\n    {f : \u2115 \u2192 M} (hf : Multipliable (fun n \u21a6 f (n + 1))) :\n    \u220f' b, f b = f 0 * \u220f' b, f (b + 1) := by\n  simpa only [prod_range_one] using hf.prod_mul_tprod_nat_mul'.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "context": {"open": ["Filter Finset Function Encodable", "scoped Topology"], "variables": ["{M : Type*} [CommMonoid M] [TopologicalSpace M] {m m' : M}", "{G : Type*} [CommGroup G] {g g' : G}", "[ContinuousMul M]", "[ContinuousMul M]", "{\u03b1 \u03b2 \u03b3 : Type*}", "[Encodable \u03b2]", "[Countable \u03b2]", "[T2Space M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_1\ninst\u271d\u2075 : CommMonoid M\ninst\u271d\u2074 : TopologicalSpace M\ninst\u271d\u00b3 inst\u271d\u00b2 : ContinuousMul M\ninst\u271d\u00b9 : T2Space M\ninst\u271d : ContinuousMul M\nf : \u2115 \u2192 M\nhf : Multipliable fun n => f (n + 1)\n\u22a2 \u220f' (b : \u2115), f b = f 0 * \u220f' (b : \u2115), f (b + 1)"}, {"line": "simpa only [prod_range_one] using hf.prod_mul_tprod_nat_mul'.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasProd_nat_add_iff {f : \u2115 \u2192 G} (k : \u2115) :\n    HasProd (fun n \u21a6 f (n + k)) g \u2194 HasProd f (g * \u220f i \u2208 range k, f i) := by\n  refine Iff.trans ?_ (range k).hasProd_compl_iff\n  rw [\u2190 (notMemRangeEquiv k).symm.hasProd_iff]\n  rw [Function.comp_def]\n  rw [coe_notMemRangeEquiv_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "context": {"open": ["Filter Finset Function Encodable", "scoped Topology"], "variables": ["{M : Type*} [CommMonoid M] [TopologicalSpace M] {m m' : M}", "{G : Type*} [CommGroup G] {g g' : G}", "[ContinuousMul M]", "[ContinuousMul M]", "{\u03b1 \u03b2 \u03b3 : Type*}", "[Encodable \u03b2]", "[Countable \u03b2]", "[T2Space M] [ContinuousMul M]", "[TopologicalSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 : CommGroup G\ng : G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nk : \u2115\n\u22a2 HasProd (fun n => f (n + k)) g \u2194 HasProd f (g * \u220f i \u2208 range k, f i)"}, {"line": "refine Iff.trans ?_ (range k).hasProd_compl_iff", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 : CommGroup G\ng : G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nk : \u2115\n\u22a2 HasProd (fun n => f (n + k)) g \u2194 HasProd (fun x => f \u2191x) g"}, {"line": "rw [\u2190 (notMemRangeEquiv k).symm.hasProd_iff]", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 : CommGroup G\ng : G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nk : \u2115\n\u22a2 HasProd (fun n => f (n + k)) g \u2194 HasProd ((fun x => f \u2191x) \u2218 \u21d1(notMemRangeEquiv k).symm) g"}, {"line": "rw [Function.comp_def]", "tactic_state": "G : Type u_2\ninst\u271d\u00b2 : CommGroup G\ng : G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nk : \u2115\n\u22a2 HasProd (fun n => f (n + k)) g \u2194 HasProd (fun x => f \u2191((notMemRangeEquiv k).symm x)) g"}, {"line": "rw [coe_notMemRangeEquiv_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Multipliable.tendsto_atTop_one {f : \u2115 \u2192 G} (hf : Multipliable f) :\n    Tendsto f atTop (\ud835\udcdd 1) := by\n  rw [\u2190 Nat.cofinite_eq_atTop]\n  exact hf.tendsto_cofinite_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/NatInt.lean", "context": {"open": ["Filter Finset Function Encodable", "scoped Topology"], "variables": ["{M : Type*} [CommMonoid M] [TopologicalSpace M] {m m' : M}", "{G : Type*} [CommGroup G] {g g' : G}", "[ContinuousMul M]", "[ContinuousMul M]", "{\u03b1 \u03b2 \u03b3 : Type*}", "[Encodable \u03b2]", "[Countable \u03b2]", "[T2Space M] [ContinuousMul M]", "[TopologicalSpace G] [IsTopologicalGroup G]", "[UniformSpace G] [IsUniformGroup G]", "[CompleteSpace G]", "[TopologicalSpace G] [IsTopologicalGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_2\ninst\u271d\u2077 : CommGroup G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : IsTopologicalGroup G\ninst\u271d\u2074 : UniformSpace G\ninst\u271d\u00b3 : IsUniformGroup G\ninst\u271d\u00b2 : CompleteSpace G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nhf : Multipliable f\n\u22a2 Tendsto f atTop (nhds 1)"}, {"line": "rw [\u2190 Nat.cofinite_eq_atTop]", "tactic_state": "G : Type u_2\ninst\u271d\u2077 : CommGroup G\ninst\u271d\u2076 : TopologicalSpace G\ninst\u271d\u2075 : IsTopologicalGroup G\ninst\u271d\u2074 : UniformSpace G\ninst\u271d\u00b3 : IsUniformGroup G\ninst\u271d\u00b2 : CompleteSpace G\ninst\u271d\u00b9 : TopologicalSpace G\ninst\u271d : IsTopologicalGroup G\nf : \u2115 \u2192 G\nhf : Multipliable f\n\u22a2 Tendsto f cofinite (nhds 1)"}, {"line": "exact hf.tendsto_cofinite_one", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma Multipliable.tprod_subtype_le {\u03ba \u03b3 : Type*} [CommGroup \u03b3] [PartialOrder \u03b3]\n    [IsOrderedMonoid \u03b3] [UniformSpace \u03b3] [IsUniformGroup \u03b3] [OrderClosedTopology \u03b3]\n    [CompleteSpace \u03b3] (f : \u03ba \u2192 \u03b3) (\u03b2 : Set \u03ba) (h : \u2200 a : \u03ba, 1 \u2264 f a) (hf : Multipliable f) :\n    (\u220f' (b : \u03b2), f b) \u2264 (\u220f' (a : \u03ba), f a) := by\n  apply Multipliable.tprod_le_tprod_of_inj _\n    (Subtype.coe_injective)\n    (by simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq, h, implies_true])\n    (by simp only [le_refl, Subtype.forall, implies_true])\n    (by apply hf.subtype)\n  apply hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "context": {"open": ["Finset Filter Function"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[Preorder \u03b1] [CommMonoid \u03b1] [TopologicalSpace \u03b1] {a c : \u03b1} {f : \u03b9 \u2192 \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 \u220f' (b : \u2191\u03b2), f \u2191b \u2264 \u220f' (a : \u03ba), f a"}, {"line": "apply Multipliable.tprod_le_tprod_of_inj _\n    (Subtype.coe_injective)\n    (by simp only [Subtype.range_coe_subtype, Set.setOf_mem_eq, h, implies_true])\n    (by simp only [le_refl, Subtype.forall, implies_true])\n    (by apply hf.subtype)", "tactic_state": "\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 Multipliable fun a => f a\n---\n\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 IsOrderedMonoid \u03b3\n---\n\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 OrderClosedTopology \u03b3"}, {"line": "apply hf", "tactic_state": "\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 IsOrderedMonoid \u03b3\n---\n\u03ba : Type u_4\n\u03b3 : Type u_5\ninst\u271d\u2076 : CommGroup \u03b3\ninst\u271d\u2075 : PartialOrder \u03b3\ninst\u271d\u2074 : IsOrderedMonoid \u03b3\ninst\u271d\u00b3 : UniformSpace \u03b3\ninst\u271d\u00b2 : IsUniformGroup \u03b3\ninst\u271d\u00b9 : OrderClosedTopology \u03b3\ninst\u271d : CompleteSpace \u03b3\nf : \u03ba \u2192 \u03b3\n\u03b2 : Set \u03ba\nh : \u2200 (a : \u03ba), 1 \u2264 f a\nhf : Multipliable f\n\u22a2 OrderClosedTopology \u03b3"}]}
{"declaration": "theorem tprod_le_one (h : \u2200 i, f i \u2264 1) : \u220f' i, f i \u2264 1 := by\n  by_cases hf : Multipliable f\n  \u00b7 exact hf.hasProd.le_one h\n  \u00b7 rw [tprod_eq_one_of_not_multipliable hf]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/InfiniteSum/Order.lean", "context": {"open": ["Finset Filter Function"], "variables": ["{\u03b9 \u03ba \u03b1 : Type*}", "[Preorder \u03b1] [CommMonoid \u03b1] [TopologicalSpace \u03b1] {a c : \u03b1} {f : \u03b9 \u2192 \u03b1}", "[CommMonoid \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nh : \u2200 (i : \u03b9), f i \u2264 1\n\u22a2 \u220f' (i : \u03b9), f i \u2264 1"}, {"line": "by_cases hf : Multipliable f", "tactic_state": "case pos\n\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nh : \u2200 (i : \u03b9), f i \u2264 1\nhf : sorry\n\u22a2 \u220f' (i : \u03b9), f i \u2264 1\n---\ncase neg\n\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nh : \u2200 (i : \u03b9), f i \u2264 1\nhf : \u00acsorry\n\u22a2 \u220f' (i : \u03b9), f i \u2264 1"}, {"line": "\u00b7 exact hf.hasProd.le_one h", "tactic_state": "case neg\n\u03b9 : Type u_1\n\u03b1 : Type u_3\ninst\u271d\u2075 : Preorder \u03b1\ninst\u271d\u2074 : CommMonoid \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\nf : \u03b9 \u2192 \u03b1\ninst\u271d\u00b2 : CommMonoid \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\nh : \u2200 (i : \u03b9), f i \u2264 1\nhf : \u00acsorry\n\u22a2 \u220f' (i : \u03b9), f i \u2264 1"}, {"line": "\u00b7 rw [tprod_eq_one_of_not_multipliable hf]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cauchy_iff_tendsto (\ud835\udcd5 : Filter G) :\n    Cauchy \ud835\udcd5 \u2194 NeBot \ud835\udcd5 \u2227 Tendsto (fun p \u21a6 p.1 / p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (\ud835\udcdd 1) := by\n  simp [Cauchy, uniformity_eq_comap_nhds_one_swapped, \u2190 tendsto_iff_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "{\u03b9 G : Type*} [Group G] [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter G\n\u22a2 Cauchy \ud835\udcd5 \u2194 \ud835\udcd5.NeBot \u2227 Tendsto (fun p => p.1 / p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1)"}, {"line": "simp [Cauchy, uniformity_eq_comap_nhds_one_swapped, \u2190 tendsto_iff_comap]", "tactic_state": "G : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter G\n\u22a2 \ud835\udcd5.NeBot \u2192 (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5 \u2264 uniformity G \u2194 Tendsto (fun p => p.1 / p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1))"}]}
{"declaration": "lemma cauchy_iff_tendsto_swapped (\ud835\udcd5 : Filter G) :\n    Cauchy \ud835\udcd5 \u2194 NeBot \ud835\udcd5 \u2227 Tendsto (fun p \u21a6 p.2 / p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (\ud835\udcdd 1) := by\n  simp [Cauchy, uniformity_eq_comap_nhds_one, \u2190 tendsto_iff_comap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "{\u03b9 G : Type*} [Group G] [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter G\n\u22a2 Cauchy \ud835\udcd5 \u2194 \ud835\udcd5.NeBot \u2227 Tendsto (fun p => p.2 / p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1)"}, {"line": "simp [Cauchy, uniformity_eq_comap_nhds_one, \u2190 tendsto_iff_comap]", "tactic_state": "G : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter G\n\u22a2 \ud835\udcd5.NeBot \u2192 (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5 \u2264 uniformity G \u2194 Tendsto (fun p => p.2 / p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1))"}]}
{"declaration": "lemma cauchy_map_iff_tendsto (\ud835\udcd5 : Filter \u03b9) (f : \u03b9 \u2192 G) :\n    Cauchy (map f \ud835\udcd5) \u2194 NeBot \ud835\udcd5 \u2227 Tendsto (fun p \u21a6 f p.1 / f p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (\ud835\udcdd 1) := by\n  simp [cauchy_map_iff, uniformity_eq_comap_nhds_one_swapped, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "{\u03b9 G : Type*} [Group G] [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter \u03b9\nf : \u03b9 \u2192 G\n\u22a2 Cauchy (map f \ud835\udcd5) \u2194 \ud835\udcd5.NeBot \u2227 Tendsto (fun p => f p.1 / f p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1)"}, {"line": "simp [cauchy_map_iff, uniformity_eq_comap_nhds_one_swapped, Function.comp_def]", "tactic_state": "\u03b9 : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter \u03b9\nf : \u03b9 \u2192 G\n\u22a2 \ud835\udcd5.NeBot \u2192\n    (Tendsto (fun p => (f p.1, f p.2)) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (uniformity G) \u2194 Tendsto (fun p => f p.1 / f p.2) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1))"}]}
{"declaration": "lemma cauchy_map_iff_tendsto_swapped (\ud835\udcd5 : Filter \u03b9) (f : \u03b9 \u2192 G) :\n    Cauchy (map f \ud835\udcd5) \u2194 NeBot \ud835\udcd5 \u2227 Tendsto (fun p \u21a6 f p.2 / f p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (\ud835\udcdd 1) := by\n  simp [cauchy_map_iff, uniformity_eq_comap_nhds_one, Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Basic.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "{\u03b9 G : Type*} [Group G] [UniformSpace G] [IsUniformGroup G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter \u03b9\nf : \u03b9 \u2192 G\n\u22a2 Cauchy (map f \ud835\udcd5) \u2194 \ud835\udcd5.NeBot \u2227 Tendsto (fun p => f p.2 / f p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1)"}, {"line": "simp [cauchy_map_iff, uniformity_eq_comap_nhds_one, Function.comp_def]", "tactic_state": "\u03b9 : Type u_3\nG : Type u_4\ninst\u271d\u00b2 : Group G\ninst\u271d\u00b9 : UniformSpace G\ninst\u271d : IsUniformGroup G\n\ud835\udcd5 : Filter \u03b9\nf : \u03b9 \u2192 G\n\u22a2 \ud835\udcd5.NeBot \u2192\n    (Tendsto (fun p => (f p.1, f p.2)) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (uniformity G) \u2194 Tendsto (fun p => f p.2 / f p.1) (\ud835\udcd5 \u00d7\u02e2 \ud835\udcd5) (nhds 1))"}]}
{"declaration": "theorem UniformContinuous.inv [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n    UniformContinuous fun x => (f x)\u207b\u00b9 := by\n  have : UniformContinuous fun x => 1 / f x := uniformContinuous_const.div hf\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\n\u22a2 UniformContinuous fun x => (f x)\u207b\u00b9"}, {"line": "have : UniformContinuous fun x => 1 / f x := uniformContinuous_const.div hf", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\nthis : sorry\n\u22a2 UniformContinuous fun x => (f x)\u207b\u00b9"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\nthis : sorry ()\n\u22a2 UniformContinuous fun x => (f x)\u207b\u00b9"}]}
{"declaration": "theorem UniformContinuous.mul [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x * g x := by\n  have : UniformContinuous fun x => f x / (g x)\u207b\u00b9 := hf.div hg.inv\n  simp_all\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\nhg : UniformContinuous g\n\u22a2 UniformContinuous fun x => f x * g x"}, {"line": "have : UniformContinuous fun x => f x / (g x)\u207b\u00b9 := hf.div hg.inv", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\nhg : UniformContinuous g\nthis : sorry\n\u22a2 UniformContinuous fun x => f x * g x"}, {"line": "simp_all", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b3 : UniformSpace \u03b1\ninst\u271d\u00b2 : Group \u03b1\ninst\u271d\u00b9 : IsUniformGroup \u03b1\ninst\u271d : UniformSpace \u03b2\nf g : \u03b2 \u2192 \u03b1\nhf : UniformContinuous f\nhg : UniformContinuous g\nthis : sorry ()\n\u22a2 UniformContinuous fun x => f x * g x"}]}
{"declaration": "theorem isUniformGroup_iInf {\u03b9 : Sort*} {us' : \u03b9 \u2192 UniformSpace \u03b2}\n    (h' : \u2200 i, @IsUniformGroup \u03b2 (us' i) _) : @IsUniformGroup \u03b2 (\u2a05 i, us' i) _ := by\n  rw [\u2190 sInf_range]\n  exact isUniformGroup_sInf (Set.forall_mem_range.mpr h')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "[Group \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : Group \u03b2\n\u03b9 : Sort u_3\nus' : \u03b9 \u2192 UniformSpace \u03b2\nh' : \u2200 (i : \u03b9), IsUniformGroup \u03b2\n\u22a2 IsUniformGroup \u03b2"}, {"line": "rw [\u2190 sInf_range]", "tactic_state": "\u03b2 : Type u_2\ninst\u271d : Group \u03b2\n\u03b9 : Sort u_3\nus' : \u03b9 \u2192 UniformSpace \u03b2\nh' : \u2200 (i : \u03b9), IsUniformGroup \u03b2\n\u22a2 IsUniformGroup \u03b2"}, {"line": "exact isUniformGroup_sInf (Set.forall_mem_range.mpr h')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    \ud835\udce4 \u03b1 = comap (fun x : \u03b1 \u00d7 \u03b1 => x.2\u207b\u00b9 * x.1) (\ud835\udcdd (1 : \u03b1)) := by\n  rw [\u2190 comap_swap_uniformity]\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  rw [comap_comap]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set", "MulOpposite"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "[Group \u03b2]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 uniformity \u03b1 = comap (fun x => x.2\u207b\u00b9 * x.1) (nhds 1)"}, {"line": "rw [\u2190 comap_swap_uniformity]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 comap Prod.swap (uniformity \u03b1) = comap (fun x => x.2\u207b\u00b9 * x.1) (nhds 1)"}, {"line": "rw [uniformity_eq_comap_inv_mul_nhds_one]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 comap Prod.swap (comap (fun x => x.1\u207b\u00b9 * x.2) (nhds 1)) = comap (fun x => x.2\u207b\u00b9 * x.1) (nhds 1)\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 Group \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 IsUniformGroup \u03b1"}, {"line": "rw [comap_comap]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 comap ((fun x => x.1\u207b\u00b9 * x.2) \u2218 Prod.swap) (nhds 1) = comap (fun x => x.2\u207b\u00b9 * x.1) (nhds 1)\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 Group \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 Group \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 IsUniformGroup \u03b1"}, {"line": "rfl", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u22a2 IsUniformGroup \u03b1"}]}
{"declaration": "theorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.1\u207b\u00b9 * x.2 \u2208 U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one]\n  exact h.comap _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set", "MulOpposite"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "[Group \u03b2]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 (uniformity \u03b1).HasBasis p fun i => {x | x.1\u207b\u00b9 * x.2 \u2208 U i}"}, {"line": "rw [uniformity_eq_comap_inv_mul_nhds_one]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 (Filter.comap (fun x => x.1\u207b\u00b9 * x.2) (nhds 1)).HasBasis p fun i => {x | x.1\u207b\u00b9 * x.2 \u2208 U i}\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 Group \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 IsUniformGroup \u03b1"}, {"line": "exact h.comap _", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 IsUniformGroup \u03b1"}]}
{"declaration": "theorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.2\u207b\u00b9 * x.1 \u2208 U i } := by\n  rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]\n  exact h.comap _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set", "MulOpposite"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "[Group \u03b2]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 (uniformity \u03b1).HasBasis p fun i => {x | x.2\u207b\u00b9 * x.1 \u2208 U i}"}, {"line": "rw [uniformity_eq_comap_inv_mul_nhds_one_swapped]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 (Filter.comap (fun x => x.2\u207b\u00b9 * x.1) (nhds 1)).HasBasis p fun i => {x | x.2\u207b\u00b9 * x.1 \u2208 U i}\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 Group \u03b1\n---\n\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 IsUniformGroup \u03b1"}, {"line": "exact h.comap _", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : UniformSpace \u03b1\ninst\u271d\u00b9 : Group \u03b1\ninst\u271d : IsUniformGroup \u03b1\n\u03b9 : Sort u_3\np : \u03b9 \u2192 Prop\nU : \u03b9 \u2192 Set \u03b1\nh : (nhds 1).HasBasis p U\n\u22a2 IsUniformGroup \u03b1"}]}
{"declaration": "theorem IsUniformGroup.uniformContinuous_iff_isOpen_ker {hom : Type*} [UniformSpace \u03b2]\n    [DiscreteTopology \u03b2] [Group \u03b2] [IsUniformGroup \u03b2] [FunLike hom \u03b1 \u03b2] [MonoidHomClass hom \u03b1 \u03b2]\n    {f : hom} :\n    UniformContinuous f \u2194 IsOpen ((f : \u03b1 \u2192* \u03b2).ker : Set \u03b1) := by\n  refine \u27e8fun hf => ?_, fun hf => ?_\u27e9\n  \u00b7 apply (isOpen_discrete ({1} : Set \u03b2)).preimage hf.continuous\n  \u00b7 apply uniformContinuous_of_continuousAt_one\n    rw [ContinuousAt]\n    rw [nhds_discrete \u03b2]\n    rw [map_one]\n    rw [tendsto_pure]\n    exact hf.mem_nhds (map_one f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/IsUniformGroup/Defs.lean", "context": {"open": ["Uniformity Topology Filter Pointwise", "Filter Set", "MulOpposite"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*}", "[UniformSpace \u03b1] [Group \u03b1] [IsUniformGroup \u03b1]", "[Group \u03b2]", "(\u03b1)", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : IsUniformGroup \u03b1\ninst\u271d\u2076 : Group \u03b2\nhom : Type u_3\ninst\u271d\u2075 : UniformSpace \u03b2\ninst\u271d\u2074 : DiscreteTopology \u03b2\ninst\u271d\u00b3 : Group \u03b2\ninst\u271d\u00b2 : IsUniformGroup \u03b2\ninst\u271d\u00b9 : FunLike hom \u03b1 \u03b2\ninst\u271d : MonoidHomClass hom \u03b1 \u03b2\nf : hom\n\u22a2 UniformContinuous \u21d1f \u2194 IsOpen \u2191(\u2191f).ker"}, {"line": "refine \u27e8fun hf => ?_, fun hf => ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : IsUniformGroup \u03b1\ninst\u271d\u2076 : Group \u03b2\nhom : Type u_3\ninst\u271d\u2075 : UniformSpace \u03b2\ninst\u271d\u2074 : DiscreteTopology \u03b2\ninst\u271d\u00b3 : Group \u03b2\ninst\u271d\u00b2 : IsUniformGroup \u03b2\ninst\u271d\u00b9 : FunLike hom \u03b1 \u03b2\ninst\u271d : MonoidHomClass hom \u03b1 \u03b2\nf : hom\nhf : UniformContinuous \u21d1f\n\u22a2 IsOpen \u2191(\u2191f).ker\n---\ncase refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : IsUniformGroup \u03b1\ninst\u271d\u2076 : Group \u03b2\nhom : Type u_3\ninst\u271d\u2075 : UniformSpace \u03b2\ninst\u271d\u2074 : DiscreteTopology \u03b2\ninst\u271d\u00b3 : Group \u03b2\ninst\u271d\u00b2 : IsUniformGroup \u03b2\ninst\u271d\u00b9 : FunLike hom \u03b1 \u03b2\ninst\u271d : MonoidHomClass hom \u03b1 \u03b2\nf : hom\nhf : IsOpen \u2191(\u2191f).ker\n\u22a2 UniformContinuous \u21d1f"}, {"line": "\u00b7 apply (isOpen_discrete ({1} : Set \u03b2)).preimage hf.continuous", "tactic_state": "case refine_2\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : Group \u03b1\ninst\u271d\u2077 : IsUniformGroup \u03b1\ninst\u271d\u2076 : Group \u03b2\nhom : Type u_3\ninst\u271d\u2075 : UniformSpace \u03b2\ninst\u271d\u2074 : DiscreteTopology \u03b2\ninst\u271d\u00b3 : Group \u03b2\ninst\u271d\u00b2 : IsUniformGroup \u03b2\ninst\u271d\u00b9 : FunLike hom \u03b1 \u03b2\ninst\u271d : MonoidHomClass hom \u03b1 \u03b2\nf : hom\nhf : IsOpen \u2191(\u2191f).ker\n\u22a2 UniformContinuous \u21d1f"}, {"line": "\u00b7 apply uniformContinuous_of_continuousAt_one\n    rw [ContinuousAt]\n    rw [nhds_discrete \u03b2]\n    rw [map_one]\n    rw [tendsto_pure]\n    exact hf.mem_nhds (map_one f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Submodule.isClosed_or_dense_of_isCoatom (s : Submodule R M) (hs : IsCoatom s) :\n    IsClosed (s : Set M) \u2228 Dense (s : Set M) := by\n  refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr\n  exact fun h \u21a6 h \u25b8 isClosed_closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Basic.lean", "context": {"open": ["LinearMap (ker range)", "Topology Filter Pointwise"], "variables": ["{R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]", "(R M) in", "{R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]", "(R M)", "{R M\u2081 M\u2082 : Type*} [SMul R M\u2081] [SMul R M\u2082] [u : TopologicalSpace R]", "{R : Type u} {M : Type v} [Semiring R] [TopologicalSpace M] [AddCommMonoid M] [Module R M]", "[ContinuousAdd M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 IsClosed \u2191s \u2228 Dense \u2191s"}, {"line": "refine (hs.le_iff.mp s.le_topologicalClosure).symm.imp ?_ dense_iff_topologicalClosure_eq_top.mpr", "tactic_state": "case refine_1\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 s.topologicalClosure = s \u2192 IsClosed \u2191s\n---\ncase refine_2\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 ContinuousConstSMul R M\n---\ncase refine_3\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 ContinuousAdd M"}, {"line": "exact fun h \u21a6 h \u25b8 isClosed_closure", "tactic_state": "case refine_2\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 ContinuousConstSMul R M\n---\ncase refine_3\nR : Type u\nM : Type v\ninst\u271d\u2074 : Semiring R\ninst\u271d\u00b3 : TopologicalSpace M\ninst\u271d\u00b2 : AddCommMonoid M\ninst\u271d\u00b9 : Module R M\ninst\u271d : ContinuousAdd M\ns : Submodule R M\nhs : IsCoatom s\n\u22a2 ContinuousAdd M"}]}
{"declaration": "theorem cardinal_eq_of_isOpen\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [AddGroup E] [MulActionWithZero \ud835\udd5c E]\n    [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E] {s : Set E}\n    (hs : IsOpen s) (h's : s.Nonempty) : #s = #E := by\n  rcases h's with \u27e8x, hx\u27e9\n  exact cardinal_eq_of_mem_nhds \ud835\udd5c (hs.mem_nhds hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Cardinality.lean", "context": {"open": ["Filter Pointwise Set Function Cardinal", "scoped Cardinal Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddGroup E\ninst\u271d\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : IsOpen s\nh's : s.Nonempty\n\u22a2 Cardinal.mk \u2191s = Cardinal.mk E"}, {"line": "rcases h's with \u27e8x, hx\u27e9", "tactic_state": "case intro\nE : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2075 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2074 : AddGroup E\ninst\u271d\u00b3 : MulActionWithZero \ud835\udd5c E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : IsOpen s\nx : E\nhx : x \u2208 s\n\u22a2 Cardinal.mk \u2191s = Cardinal.mk E"}, {"line": "exact cardinal_eq_of_mem_nhds \ud835\udd5c (hs.mem_nhds hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuum_le_cardinal_of_isOpen\n    {E : Type*} (\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c] [AddCommGroup E]\n    [Module \ud835\udd5c E] [Nontrivial E] [TopologicalSpace E] [ContinuousAdd E] [ContinuousSMul \ud835\udd5c E]\n    {s : Set E} (hs : IsOpen s) (h's : s.Nonempty) : \ud835\udd20 \u2264 #s := by\n  simpa [cardinal_eq_of_isOpen \ud835\udd5c hs h's] using continuum_le_cardinal_of_module \ud835\udd5c E\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Cardinality.lean", "context": {"open": ["Filter Pointwise Set Function Cardinal", "scoped Cardinal Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\n\ud835\udd5c : Type u_2\ninst\u271d\u2077 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2076 : CompleteSpace \ud835\udd5c\ninst\u271d\u2075 : AddCommGroup E\ninst\u271d\u2074 : Module \ud835\udd5c E\ninst\u271d\u00b3 : Nontrivial E\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousAdd E\ninst\u271d : ContinuousSMul \ud835\udd5c E\ns : Set E\nhs : IsOpen s\nh's : s.Nonempty\n\u22a2 continuum \u2264 Cardinal.mk \u2191s"}, {"line": "simpa [cardinal_eq_of_isOpen \ud835\udd5c hs h's] using continuum_le_cardinal_of_module \ud835\udd5c E", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_comp_symm (e : M\u2081 \u2243SL[\u03c3\u2081\u2082] M\u2082) : (e : M\u2081 \u2192 M\u2082) \u2218 (e.symm : M\u2082 \u2192 M\u2081) = id := by\n  ext x\n  exact apply_symm_apply e x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Equiv.lean", "context": {"open": ["LinearMap (ker range)", "Topology Filter Pointwise"], "variables": ["{R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]", "(R M)", "(F : Type*) {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)", "{R : Type*} [Semiring R] {M : Type*} [TopologicalSpace M] [AddCommMonoid M] [Module R M]", "(R \u03c6)", "{R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*} [Semiring R\u2081] [Semiring R\u2082] [Semiring R\u2083]", "(R\u2081 M\u2081)", "(R\u2081 M\u2081 M\u2082)", "{R\u2081 M\u2081 M\u2082}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M\u2081 : Type u_14\nM\u2082 : Type u_13\n\u03b1\u271d\u00b9 : Type u_11\n\u03b1\u271d : Type u_12\nself\u271d\u00b9 : Semiring \u03b1\u271d\u00b9\nself\u271d : Semiring \u03b1\u271d\n\u03c3\u2081\u2082 : \u03b1\u271d\u00b9 \u2192+* \u03b1\u271d\ne : sorry\n\u22a2 sorry \u2218 sorry = id"}, {"line": "ext x", "tactic_state": "case h\nM\u2081 : Type u_14\nM\u2082 : Type u_13\n\u03b1\u271d\u00b9 : Type u_11\n\u03b1\u271d : Type u_12\nself\u271d\u00b9 : Semiring \u03b1\u271d\u00b9\nself\u271d : Semiring \u03b1\u271d\n\u03c3\u2081\u2082 : \u03b1\u271d\u00b9 \u2192+* \u03b1\u271d\ne : sorry\nx : M\u2082\n\u22a2 (sorry \u2218 sorry) x = id x"}, {"line": "exact apply_symm_apply e x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_apply [ContinuousNeg M] (x : M) :\n    neg R x = -x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Equiv.lean", "context": {"open": ["LinearMap (ker range)", "Topology Filter Pointwise"], "variables": ["{R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]", "(R M)", "(F : Type*) {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)", "{R : Type*} [Semiring R] {M : Type*} [TopologicalSpace M] [AddCommMonoid M] [Module R M]", "(R \u03c6)", "{R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*} [Semiring R\u2081] [Semiring R\u2082] [Semiring R\u2083]", "(R\u2081 M\u2081)", "(R\u2081 M\u2081 M\u2082)", "{R\u2081 M\u2081 M\u2082}", "(M\u2081)", "{M\u2081} {R\u2084 : Type*} [Semiring R\u2084] [Module R\u2084 M\u2084] {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084} {\u03c3\u2084\u2083 : R\u2084 \u2192+* R\u2083}", "{\u03b9 : Type*} {M : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (M i)] [\u2200 i, AddCommMonoid (M i)]", "{R : Type*} [Semiring R] {M : Type*} [TopologicalSpace M] [AddCommGroup M] {M\u2082 : Type*}", "[IsTopologicalAddGroup M\u2084]", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_14\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : AddCommGroup M\nx\u271d : Sort u_16\nneg : x\u271d\ninst\u271d : ContinuousNeg M\nx : M\n\u22a2 sorry = -x"}, {"line": "simp", "tactic_state": "M : Type u_14\ninst\u271d\u00b2 : TopologicalSpace M\ninst\u271d\u00b9 : AddCommGroup M\nx\u271d : Sort u_16\nneg : x\u271d\ninst\u271d : ContinuousNeg M\nx : M\n\u22a2 sorry () = -x"}]}
{"declaration": "theorem inverse_equiv (e : M \u2243L[R] M\u2082) : inverse (e : M \u2192L[R] M\u2082) = e.symm := by\n  simp [inverse]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/Equiv.lean", "context": {"open": ["LinearMap (ker range)", "Topology Filter Pointwise", "Classical in"], "variables": ["{R : Type*} {M : Type*} [Ring R] [TopologicalSpace R] [TopologicalSpace M]", "(R M)", "(F : Type*) {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)", "{R : Type*} [Semiring R] {M : Type*} [TopologicalSpace M] [AddCommMonoid M] [Module R M]", "(R \u03c6)", "{R\u2081 : Type*} {R\u2082 : Type*} {R\u2083 : Type*} [Semiring R\u2081] [Semiring R\u2082] [Semiring R\u2083]", "(R\u2081 M\u2081)", "(R\u2081 M\u2081 M\u2082)", "{R\u2081 M\u2081 M\u2082}", "(M\u2081)", "{M\u2081} {R\u2084 : Type*} [Semiring R\u2084] [Module R\u2084 M\u2084] {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084} {\u03c3\u2084\u2083 : R\u2084 \u2192+* R\u2083}", "{\u03b9 : Type*} {M : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (M i)] [\u2200 i, AddCommMonoid (M i)]", "{R : Type*} [Semiring R] {M : Type*} [TopologicalSpace M] [AddCommGroup M] {M\u2082 : Type*}", "[IsTopologicalAddGroup M\u2084]", "(R) in", "{R : Type*} [Ring R] {R\u2082 : Type*} [Ring R\u2082] {M : Type*} [TopologicalSpace M]", "{\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]", "(R M)", "(R) [TopologicalSpace R]", "[ContinuousMul R]", "{R}", "[Module R M\u2082] [IsTopologicalAddGroup M]", "(\u03b9 R M : Type*) [Unique \u03b9] [Semiring R] [AddCommMonoid M] [Module R M]", "{\u03b9 R M}", "(R M)", "{n : \u2115} {R : Type*} {M : Fin n.succ \u2192 Type*} {N : Type*}", "[Semiring R]", "[\u2200 i, AddCommMonoid (M i)] [\u2200 i, Module R (M i)] [\u2200 i, TopologicalSpace (M i)]", "(R M) in", "{R : Type*} {M M\u2082 M\u2083 : Type*}", "[Semiring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_20\ninverse : x\u271d\ne : sorry\n\u22a2 sorry = sorry"}, {"line": "simp [inverse]", "tactic_state": "x\u271d : Sort u_20\ninverse : x\u271d\ne : sorry\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem continuous_of_ringHom {R A B} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B]\n    [TopologicalSpace R] [TopologicalSpace A] [IsModuleTopology R A] [TopologicalSpace B]\n    [IsTopologicalSemiring B]\n    (\u03c6 : A \u2192+* B) (h\u03c6 : Continuous (\u03c6.comp (algebraMap R A))) : Continuous \u03c6 := by\n  let inst := Module.compHom B (\u03c6.comp (algebraMap R A))\n  let \u03c6' : A \u2192\u2097[R] B := \u27e8\u03c6, fun r m \u21a6 by simp [Algebra.smul_def]; rfl\u27e9\n  have : ContinuousSMul R B := \u27e8(h\u03c6.comp continuous_fst).mul continuous_snd\u27e9\n  exact continuous_of_linearMap \u03c6'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/ModuleTopology.lean", "context": {"open": [], "variables": ["(R : Type*) [TopologicalSpace R] (A : Type*) [Add A] [SMul R A]", "{R : Type*} [TopologicalSpace R]", "{R : Type*} [\u03c4R : TopologicalSpace R] [Semiring R]", "{A : Type*} [AddCommMonoid A] [Module R A] [\u03c4A : TopologicalSpace A] [IsModuleTopology R A]", "{B : Type*} [AddCommMonoid B] [Module R B] [\u03c4B : TopologicalSpace B]", "(R : Type*) [Semiring R] [\u03c4R : TopologicalSpace R] [IsTopologicalSemiring R]", "(R : Type*) [Semiring R] [\u03c4R : TopologicalSpace R] [IsTopologicalSemiring R]", "{R : Type*} [\u03c4R : TopologicalSpace R] [Semiring R]", "{A : Type*} [AddCommMonoid A] [Module R A] [aA : TopologicalSpace A] [IsModuleTopology R A]", "{B : Type*} [AddCommMonoid B] [Module R B] [aB : TopologicalSpace B]", "(R) in", "(R) in", "(R) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 Continuous \u21d1\u03c6"}, {"line": "let inst := Module.compHom B (\u03c6.comp (algebraMap R A))", "tactic_state": "case refine_3\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\ninst : Module R B := sorry\n\u22a2 Continuous \u21d1\u03c6\n---\ncase refine_1\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 AddCommMonoid B\n---\ncase refine_2\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 CommSemiring R"}, {"line": "let \u03c6' : A \u2192\u2097[R] B := \u27e8\u03c6, fun r m \u21a6 by simp [Algebra.smul_def]; rfl\u27e9", "tactic_state": "case refine_3\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\ninst : Module R B := sorry\n\u03c6' : sorry := sorry\n\u22a2 Continuous \u21d1\u03c6\n---\ncase refine_1\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 AddCommMonoid B\n---\ncase refine_2\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 CommSemiring R"}, {"line": "have : ContinuousSMul R B := \u27e8(h\u03c6.comp continuous_fst).mul continuous_snd\u27e9", "tactic_state": "case refine_3\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\ninst : Module R B := sorry\n\u03c6' : sorry := sorry\nthis : sorry\n\u22a2 Continuous \u21d1\u03c6\n---\ncase refine_1\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 AddCommMonoid B\n---\ncase refine_2\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 CommSemiring R"}, {"line": "exact continuous_of_linearMap \u03c6'", "tactic_state": "case refine_1\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 AddCommMonoid B\n---\ncase refine_2\nR : Type u_12\nA : Type u_13\nB : Type u_14\ninst\u271d\u2078 : CommSemiring R\ninst\u271d\u2077 : Semiring A\ninst\u271d\u2076 : Algebra R A\ninst\u271d\u2075 : Semiring B\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : IsTopologicalSemiring B\n\u03c6 : A \u2192+* B\nh\u03c6 : Continuous \u21d1(\u03c6.comp (algebraMap R A))\n\u22a2 CommSemiring R"}]}
{"declaration": "lemma _root_.ModuleTopology.eq_coinduced_of_surjective\n    {\u03c6 : A \u2192\u2097[R] B} (h\u03c6 : Function.Surjective \u03c6) :\n    moduleTopology R B = TopologicalSpace.coinduced \u03c6 inferInstance := by\n  letI : TopologicalSpace B := moduleTopology R B\n  haveI : IsModuleTopology R B := \u27e8rfl\u27e9\n  exact (isQuotientMap_of_surjective h\u03c6).eq_coinduced\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Module/ModuleTopology.lean", "context": {"open": ["Topology in"], "variables": ["(R : Type*) [TopologicalSpace R] (A : Type*) [Add A] [SMul R A]", "{R : Type*} [TopologicalSpace R]", "{R : Type*} [\u03c4R : TopologicalSpace R] [Semiring R]", "{A : Type*} [AddCommMonoid A] [Module R A] [\u03c4A : TopologicalSpace A] [IsModuleTopology R A]", "{B : Type*} [AddCommMonoid B] [Module R B] [\u03c4B : TopologicalSpace B]", "(R : Type*) [Semiring R] [\u03c4R : TopologicalSpace R] [IsTopologicalSemiring R]", "(R : Type*) [Semiring R] [\u03c4R : TopologicalSpace R] [IsTopologicalSemiring R]", "{R : Type*} [\u03c4R : TopologicalSpace R] [Semiring R]", "{A : Type*} [AddCommMonoid A] [Module R A] [aA : TopologicalSpace A] [IsModuleTopology R A]", "{B : Type*} [AddCommMonoid B] [Module R B] [aB : TopologicalSpace B]", "(R) in", "(R) in", "(R) in", "{R : Type*} [\u03c4R : TopologicalSpace R] [Ring R]", "{A : Type*} [AddCommGroup A] [Module R A] [TopologicalSpace A] [IsModuleTopology R A]", "{B : Type*} [AddCommGroup B] [Module R B]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_7\n\u03c4R : TopologicalSpace R\ninst\u271d\u2076 : Semiring R\nA : Type u_10\ninst\u271d\u2075 : AddCommGroup A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\nB : Type u_11\ninst\u271d\u00b9 : AddCommGroup B\ninst\u271d : Module R B\n\u03c6 : A \u2192\u2097[R] B\nh\u03c6 : Function.Surjective \u21d1\u03c6\n\u22a2 moduleTopology R B = TopologicalSpace.coinduced (\u21d1\u03c6) inferInstance"}, {"line": "letI : TopologicalSpace B := moduleTopology R B", "tactic_state": "R : Type u_7\n\u03c4R : TopologicalSpace R\ninst\u271d\u2076 : Semiring R\nA : Type u_10\ninst\u271d\u2075 : AddCommGroup A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\nB : Type u_11\ninst\u271d\u00b9 : AddCommGroup B\ninst\u271d : Module R B\n\u03c6 : A \u2192\u2097[R] B\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis : TopologicalSpace B := sorry\n\u22a2 moduleTopology R B = TopologicalSpace.coinduced (\u21d1\u03c6) inferInstance"}, {"line": "haveI : IsModuleTopology R B := \u27e8rfl\u27e9", "tactic_state": "R : Type u_7\n\u03c4R : TopologicalSpace R\ninst\u271d\u2076 : Semiring R\nA : Type u_10\ninst\u271d\u2075 : AddCommGroup A\ninst\u271d\u2074 : Module R A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : IsModuleTopology R A\nB : Type u_11\ninst\u271d\u00b9 : AddCommGroup B\ninst\u271d : Module R B\n\u03c6 : A \u2192\u2097[R] B\nh\u03c6 : Function.Surjective \u21d1\u03c6\nthis\u271d : TopologicalSpace B := sorry\nthis : sorry\n\u22a2 moduleTopology R B = TopologicalSpace.coinduced (\u21d1\u03c6) inferInstance"}, {"line": "exact (isQuotientMap_of_surjective h\u03c6).eq_coinduced", "tactic_state": "No Goals!"}]}
{"declaration": "example : NonarchimedeanRing R := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "context": {"open": ["Set IsTopologicalAddGroup Submodule Filter", "Topology Pointwise"], "variables": ["{R : Type*} [CommRing R]", "(I : Ideal R) (M : Type*) [AddCommGroup M] [Module R M]", "[TopologicalSpace R] [IsTopologicalRing R]", "(R)", "[WithIdeal R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nI : Ideal R\nM : Type u_2\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : IsTopologicalRing R\ninst\u271d : WithIdeal R\n\u22a2 NonarchimedeanRing R"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example : IsTopologicalRing (UniformSpace.Completion R) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "context": {"open": ["Set IsTopologicalAddGroup Submodule Filter", "Topology Pointwise"], "variables": ["{R : Type*} [CommRing R]", "(I : Ideal R) (M : Type*) [AddCommGroup M] [Module R M]", "[TopologicalSpace R] [IsTopologicalRing R]", "(R)", "[WithIdeal R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2075 : CommRing R\nI : Ideal R\nM : Type u_2\ninst\u271d\u2074 : AddCommGroup M\ninst\u271d\u00b3 : Module R M\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : IsTopologicalRing R\ninst\u271d : WithIdeal R\n\u22a2 IsTopologicalRing (UniformSpace.Completion R)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (M : Type*) [AddCommGroup M] [Module R M] :\n    @IsTopologicalAddGroup M (WithIdeal.topologicalSpaceModule R M) _ := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "context": {"open": ["Set IsTopologicalAddGroup Submodule Filter", "Topology Pointwise"], "variables": ["{R : Type*} [CommRing R]", "(I : Ideal R) (M : Type*) [AddCommGroup M] [Module R M]", "[TopologicalSpace R] [IsTopologicalRing R]", "(R)", "[WithIdeal R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : CommRing R\nI : Ideal R\nM\u271d : Type u_2\ninst\u271d\u2076 : AddCommGroup M\u271d\ninst\u271d\u2075 : Module R M\u271d\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : IsTopologicalRing R\ninst\u271d\u00b2 : WithIdeal R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 IsTopologicalAddGroup M"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "example (M : Type*) [AddCommGroup M] [Module R M] :\n    @ContinuousSMul R M _ _ (WithIdeal.topologicalSpaceModule R M) := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Nonarchimedean/AdicTopology.lean", "context": {"open": ["Set IsTopologicalAddGroup Submodule Filter", "Topology Pointwise"], "variables": ["{R : Type*} [CommRing R]", "(I : Ideal R) (M : Type*) [AddCommGroup M] [Module R M]", "[TopologicalSpace R] [IsTopologicalRing R]", "(R)", "[WithIdeal R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u2077 : CommRing R\nI : Ideal R\nM\u271d : Type u_2\ninst\u271d\u2076 : AddCommGroup M\u271d\ninst\u271d\u2075 : Module R M\u271d\ninst\u271d\u2074 : TopologicalSpace R\ninst\u271d\u00b3 : IsTopologicalRing R\ninst\u271d\u00b2 : WithIdeal R\nM : Type u_3\ninst\u271d\u00b9 : AddCommGroup M\ninst\u271d : Module R M\n\u22a2 ContinuousSMul R M"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma limsup_mul_le (h\u2081 : \u2203\u1da0 x in f, 0 \u2264 u x) (h\u2082 : IsBoundedUnder (fun x1 x2 \u21a6 x1 \u2264 x2) f u)\n    (h\u2083 : 0 \u2264\u1da0[f] v) (h\u2084 : IsBoundedUnder (fun x1 x2 \u21a6 x1 \u2264 x2) f v) :\n    limsup (u * v) f \u2264 (limsup u f) * limsup v f := by\n  have h := IsCoboundedUnder.of_frequently_ge (a := 0)\n    <| (h\u2081.and_eventually h\u2083).mono fun x \u27e8ux_0, vx_0\u27e9 \u21a6 mul_nonneg ux_0 vx_0\n  have h' := isBoundedUnder_le_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084\n  refine le_mul_of_forall_lt\u2080 fun a a_u b b_v \u21a6 (limsup_le_iff h h').2 fun c c_ab \u21a6 ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v, h\u2083]\n    with x x_a x_b v_0\n  apply lt_of_le_of_lt _ c_ab\n  rcases lt_or_ge (u x) 0 with u_0 | u_0\n  \u00b7 apply (mul_nonpos_of_nonpos_of_nonneg u_0.le v_0).trans\n    exact mul_nonneg ((le_limsup_of_frequently_le h\u2081 h\u2082).trans a_u.le) (v_0.trans x_b.le)\n  \u00b7 exact mul_le_mul x_a.le x_b.le v_0 (u_0.trans x_a.le)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "context": {"open": ["Filter TopologicalSpace", "scoped Topology", "Filter Real"], "variables": ["{\u03b9 \u03b1 \u03b2 R S : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[BoundedLENhdsClass \u03b1] [BoundedLENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[BoundedGENhdsClass \u03b1] [BoundedGENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "[FirstCountableTopology \u03b1] {f : Filter \u03b2} [CountableInterFilter f] {u : \u03b2 \u2192 \u03b1}", "[CompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [FirstCountableTopology \u03b1] [OrderTopology \u03b1]", "{F : Filter \u03b9} [NeBot F]", "[AddCommGroup \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [DenselyOrdered \u03b1]", "{f : Filter \u03b9} {u v : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\n\u22a2 limsup (u * v) f \u2264 limsup u f * limsup v f"}, {"line": "have h := IsCoboundedUnder.of_frequently_ge (a := 0)\n    <| (h\u2081.and_eventually h\u2083).mono fun x \u27e8ux_0, vx_0\u27e9 \u21a6 mul_nonneg ux_0 vx_0", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\n\u22a2 limsup (u * v) f \u2264 limsup u f * limsup v f"}, {"line": "have h' := isBoundedUnder_le_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\n\u22a2 limsup (u * v) f \u2264 limsup u f * limsup v f"}, {"line": "refine le_mul_of_forall_lt\u2080 fun a a_u b b_v \u21a6 (limsup_le_iff h h').2 fun c c_ab \u21a6 ?_", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\n\u22a2 \u2200\u1da0 (a : \u03b9) in f, u a * v a < c"}, {"line": "filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v, h\u2083]\n    with x x_a x_b v_0", "tactic_state": "case h\n\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx_a : u x < a\nx_b : v x < b\nv_0 : 0 x \u2264 v x\n\u22a2 u x * v x < c"}, {"line": "apply lt_of_le_of_lt _ c_ab", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx_a : u x < a\nx_b : v x < b\nv_0 : 0 x \u2264 v x\n\u22a2 u x * v x \u2264 a * b"}, {"line": "rcases lt_or_ge (u x) 0 with u_0 | u_0", "tactic_state": "case inl\n\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx_a : u x < a\nx_b : v x < b\nv_0 : 0 x \u2264 v x\nu_0 : u x < 0\n\u22a2 u x * v x \u2264 a * b\n---\ncase inr\n\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx_a : u x < a\nx_b : v x < b\nv_0 : 0 x \u2264 v x\nu_0 : u x \u2265 0\n\u22a2 u x * v x \u2264 a * b"}, {"line": "\u00b7 apply (mul_nonpos_of_nonpos_of_nonneg u_0.le v_0).trans\n    exact mul_nonneg ((le_limsup_of_frequently_le h\u2081 h\u2082).trans a_u.le) (v_0.trans x_b.le)", "tactic_state": "case inr\n\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\nh\u2081 : \u2203\u1da0 (x : \u03b9) in f, 0 \u2264 u x\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2264 x2) f fun x => u x * v x\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f (u * v)\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > limsup v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx_a : u x < a\nx_b : v x < b\nv_0 : 0 x \u2264 v x\nu_0 : u x \u2265 0\n\u22a2 u x * v x \u2264 a * b"}, {"line": "\u00b7 exact mul_le_mul x_a.le x_b.le v_0 (u_0.trans x_a.le)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_liminf_mul [f.NeBot] (h\u2081 : 0 \u2264\u1da0[f] u) (h\u2082 : IsBoundedUnder (fun x1 x2 \u21a6 x1 \u2264 x2) f u)\n    (h\u2083 : 0 \u2264\u1da0[f] v) (h\u2084 : IsCoboundedUnder (fun x1 x2 \u21a6 x1 \u2265 x2) f v) :\n    (liminf u f) * liminf v f \u2264 liminf (u * v) f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h\u2081.and h\u2083).mono fun x \u27e8u0, v0\u27e9 \u21a6 mul_nonneg u0 v0\n  apply mul_le_of_forall_lt_of_nonneg (le_liminf_of_le h\u2082.isCoboundedUnder_ge h\u2081)\n    (le_liminf_of_le h ((h\u2081.and h\u2083).mono fun x \u27e8u0, v0\u27e9 \u21a6 mul_nonneg u0 v0))\n  intro a a0 au b b0 bv\n  refine (le_liminf_iff h h').2 fun c c_ab \u21a6 ?_\n  filter_upwards [eventually_lt_of_lt_liminf au (isBoundedUnder_of_eventually_ge h\u2081),\n    eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge h\u2083)] with x xa xb\n  exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 (a0.trans xa.le))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "context": {"open": ["Filter TopologicalSpace", "scoped Topology", "Filter Real"], "variables": ["{\u03b9 \u03b1 \u03b2 R S : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[BoundedLENhdsClass \u03b1] [BoundedLENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[BoundedGENhdsClass \u03b1] [BoundedGENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "[FirstCountableTopology \u03b1] {f : Filter \u03b2} [CountableInterFilter f] {u : \u03b2 \u2192 \u03b1}", "[CompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [FirstCountableTopology \u03b1] [OrderTopology \u03b1]", "{F : Filter \u03b9} [NeBot F]", "[AddCommGroup \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [DenselyOrdered \u03b1]", "{f : Filter \u03b9} {u v : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\n\u22a2 liminf u f * liminf v f \u2264 liminf (u * v) f"}, {"line": "have h := isCoboundedUnder_ge_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\n\u22a2 liminf u f * liminf v f \u2264 liminf (u * v) f"}, {"line": "have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h\u2081.and h\u2083).mono fun x \u27e8u0, v0\u27e9 \u21a6 mul_nonneg u0 v0", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\n\u22a2 liminf u f * liminf v f \u2264 liminf (u * v) f"}, {"line": "apply mul_le_of_forall_lt_of_nonneg (le_liminf_of_le h\u2082.isCoboundedUnder_ge h\u2081)\n    (le_liminf_of_le h ((h\u2081.and h\u2083).mono fun x \u27e8u0, v0\u27e9 \u21a6 mul_nonneg u0 v0))", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\n\u22a2 \u2200 a' \u2265 0, a' < liminf u f \u2192 \u2200 b' \u2265 0, b' < liminf v f \u2192 a' * b' \u2264 liminf (u * v) f"}, {"line": "intro a a0 au b b0 bv", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\na : \u211d\na0 : a \u2265 0\nau : a < liminf u f\nb : \u211d\nb0 : b \u2265 0\nbv : b < liminf v f\n\u22a2 a * b \u2264 liminf (u * v) f"}, {"line": "refine (le_liminf_iff h h').2 fun c c_ab \u21a6 ?_", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\na : \u211d\na0 : a \u2265 0\nau : a < liminf u f\nb : \u211d\nb0 : b \u2265 0\nbv : b < liminf v f\nc : \u211d\nc_ab : c < a * b\n\u22a2 \u2200\u1da0 (a : \u03b9) in f, c < (u * v) a"}, {"line": "filter_upwards [eventually_lt_of_lt_liminf au (isBoundedUnder_of_eventually_ge h\u2081),\n    eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge h\u2083)] with x xa xb", "tactic_state": "case h\n\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\na : \u211d\na0 : a \u2265 0\nau : a < liminf u f\nb : \u211d\nb0 : b \u2265 0\nbv : b < liminf v f\nc : \u211d\nc_ab : c < a * b\nx : \u03b9\nxa : a < u x\nxb : b < v x\n\u22a2 c < (u * v) x"}, {"line": "exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 (a0.trans xa.le))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma liminf_mul_le [f.NeBot] (h\u2081 : 0 \u2264\u1da0[f] u) (h\u2082 : IsBoundedUnder (fun x1 x2 \u21a6 x1 \u2264 x2) f u)\n    (h\u2083 : 0 \u2264\u1da0[f] v) (h\u2084 : IsCoboundedUnder (fun x1 x2 \u21a6 x1 \u2265 x2) f v) :\n    liminf (u * v) f \u2264 (limsup u f) * liminf v f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h\u2081.and h\u2083).mono fun x \u27e8u_0, v_0\u27e9 \u21a6 mul_nonneg u_0 v_0\n  refine le_mul_of_forall_lt\u2080 fun a a_u b b_v \u21a6 (liminf_le_iff h h').2 fun c c_ab \u21a6 ?_\n  refine ((frequently_lt_of_liminf_lt h\u2084 b_v).and_eventually ((eventually_lt_of_limsup_lt a_u).and\n    (h\u2081.and h\u2083))).mono fun x \u27e8x_v, x_u, u_0, v_0\u27e9 \u21a6 ?_\n  exact (mul_le_mul x_u.le x_v.le v_0 (u_0.trans x_u.le)).trans_lt c_ab\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/LiminfLimsup.lean", "context": {"open": ["Filter TopologicalSpace", "scoped Topology", "Filter Real"], "variables": ["{\u03b9 \u03b1 \u03b2 R S : Type*} {\u03c0 : \u03b9 \u2192 Type*}", "[Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[BoundedLENhdsClass \u03b1] [BoundedLENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[BoundedGENhdsClass \u03b1] [BoundedGENhdsClass \u03b2] {f : Filter \u03b9} {u : \u03b9 \u2192 \u03b1} {a : \u03b1}", "[ConditionallyCompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "[FirstCountableTopology \u03b1] {f : Filter \u03b2} [CountableInterFilter f] {u : \u03b2 \u2192 \u03b1}", "[CompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [FirstCountableTopology \u03b1] [OrderTopology \u03b1]", "{F : Filter \u03b9} [NeBot F]", "[AddCommGroup \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [DenselyOrdered \u03b1]", "{f : Filter \u03b9} {u v : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\n\u22a2 liminf (u * v) f \u2264 limsup u f * liminf v f"}, {"line": "have h := isCoboundedUnder_ge_mul_of_nonneg h\u2081 h\u2082 h\u2083 h\u2084", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\n\u22a2 liminf (u * v) f \u2264 limsup u f * liminf v f"}, {"line": "have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h\u2081.and h\u2083).mono fun x \u27e8u_0, v_0\u27e9 \u21a6 mul_nonneg u_0 v_0", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\n\u22a2 liminf (u * v) f \u2264 limsup u f * liminf v f"}, {"line": "refine le_mul_of_forall_lt\u2080 fun a a_u b b_v \u21a6 (liminf_le_iff h h').2 fun c c_ab \u21a6 ?_", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > liminf v f\nc : \u211d\nc_ab : c > a * b\n\u22a2 \u2203\u1da0 (a : \u03b9) in f, (u * v) a < c"}, {"line": "refine ((frequently_lt_of_liminf_lt h\u2084 b_v).and_eventually ((eventually_lt_of_limsup_lt a_u).and\n    (h\u2081.and h\u2083))).mono fun x \u27e8x_v, x_u, u_0, v_0\u27e9 \u21a6 ?_", "tactic_state": "\u03b9 : Type u_1\nf : Filter \u03b9\nu v : \u03b9 \u2192 \u211d\ninst\u271d : f.NeBot\nh\u2081 : 0 \u2264\u1da0[f] u\nh\u2082 : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) f u\nh\u2083 : 0 \u2264\u1da0[f] v\nh\u2084 : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f v\nh : IsCoboundedUnder (fun x1 x2 => x1 \u2265 x2) f (u * v)\nh' : IsBoundedUnder (fun x1 x2 => x1 \u2265 x2) f fun x => u x * v x\na : \u211d\na_u : a > limsup u f\nb : \u211d\nb_v : b > liminf v f\nc : \u211d\nc_ab : c > a * b\nx : \u03b9\nx\u271d : v x < b \u2227 u x < a \u2227 0 x \u2264 u x \u2227 0 x \u2264 v x\nx_v : v x < b\nx_u : u x < a\nu_0 : 0 x \u2264 u x\nv_0 : 0 x \u2264 v x\n\u22a2 (u * v) x < c"}, {"line": "exact (mul_le_mul x_u.le x_v.le v_0 (u_0.trans x_u.le)).trans_lt c_ab", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsUpperSet.interior (h : IsUpperSet s) : IsUpperSet (interior s) := by\n  rw [\u2190 isLowerSet_compl]\n  rw [\u2190 closure_compl]\n  exact h.compl.closure\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/UpperLower.lean", "context": {"open": ["Function Set", "Pointwise"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1]", "[Preorder \u03b1] [HasUpperLowerClosure \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsUpperSet (interior s)"}, {"line": "rw [\u2190 isLowerSet_compl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsLowerSet (interior s)\u1d9c"}, {"line": "rw [\u2190 closure_compl]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : Preorder \u03b1\ninst\u271d : HasUpperLowerClosure \u03b1\ns : Set \u03b1\nh : IsUpperSet s\n\u22a2 IsLowerSet (closure s\u1d9c)"}, {"line": "exact h.compl.closure", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dense_iff_ne_zpowers {s : Subgroup G} :\n    Dense (s : Set G) \u2194 \u2200 a, s \u2260 .zpowers a := by\n  simp [xor_iff_iff_not.1 s.dense_xor'_cyclic]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Archimedean.lean", "context": {"open": ["Set"], "variables": ["{G : Type*} [CommGroup G] [LinearOrder G] [IsOrderedMonoid G]", "[Nontrivial G] [DenselyOrdered G]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u2074 : CommGroup G\ninst\u271d\u00b3 : LinearOrder G\ninst\u271d\u00b2 : IsOrderedMonoid G\ninst\u271d\u00b9 : Nontrivial G\ninst\u271d : DenselyOrdered G\ns : Subgroup G\n\u22a2 sorry \u2194 \u2200 (a : G), s \u2260 Subgroup.zpowers a"}, {"line": "simp [xor_iff_iff_not.1 s.dense_xor'_cyclic]", "tactic_state": "G : Type u_1\ninst\u271d\u2074 : CommGroup G\ninst\u271d\u00b3 : LinearOrder G\ninst\u271d\u00b2 : IsOrderedMonoid G\ninst\u271d\u00b9 : Nontrivial G\ninst\u271d : DenselyOrdered G\ns : Subgroup G\n\u22a2 sorry () \u2194 \u2200 (a : G), \u00acs = Subgroup.zpowers a"}]}
{"declaration": "theorem Filter.Tendsto.pos_mul_atTop {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atTop := by\n  simpa only [mul_comm] using hg.atTop_mul_pos hC hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Field.lean", "context": {"open": ["Set Filter TopologicalSpace Function", "scoped Pointwise Topology", "OrderDual (toDual ofDual)"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\n\u03b1\u271d : Type u_3\nf : \u03b1\u271d \u2192 \ud835\udd5c\nl : Filter \u03b1\u271d\ng : \u03b1\u271d \u2192 \ud835\udd5c\nC : \ud835\udd5c\nhC : 0 < C\nhf : Tendsto f l (nhds C)\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => f x * g x) l atTop"}, {"line": "simpa only [mul_comm] using hg.atTop_mul_pos hC hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.neg_mul_atTop {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atBot := by\n  simpa only [mul_comm] using hg.atTop_mul_neg hC hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Field.lean", "context": {"open": ["Set Filter TopologicalSpace Function", "scoped Pointwise Topology", "OrderDual (toDual ofDual)"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\n\u03b1\u271d : Type u_3\nf : \u03b1\u271d \u2192 \ud835\udd5c\nl : Filter \u03b1\u271d\ng : \u03b1\u271d \u2192 \ud835\udd5c\nC : \ud835\udd5c\nhC : C < 0\nhf : Tendsto f l (nhds C)\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => f x * g x) l atBot"}, {"line": "simpa only [mul_comm] using hg.atTop_mul_neg hC hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.pos_mul_atBot {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atBot := by\n  simpa only [mul_comm] using hg.atBot_mul_pos hC hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Field.lean", "context": {"open": ["Set Filter TopologicalSpace Function", "scoped Pointwise Topology", "OrderDual (toDual ofDual)"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\n\u03b1\u271d : Type u_3\nf : \u03b1\u271d \u2192 \ud835\udd5c\nl : Filter \u03b1\u271d\ng : \u03b1\u271d \u2192 \ud835\udd5c\nC : \ud835\udd5c\nhC : 0 < C\nhf : Tendsto f l (nhds C)\nhg : Tendsto g l atBot\n\u22a2 Tendsto (fun x => f x * g x) l atBot"}, {"line": "simpa only [mul_comm] using hg.atBot_mul_pos hC hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.neg_mul_atBot {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atTop := by\n  simpa only [mul_comm] using hg.atBot_mul_neg hC hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Field.lean", "context": {"open": ["Set Filter TopologicalSpace Function", "scoped Pointwise Topology", "OrderDual (toDual ofDual)"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\n\u03b1\u271d : Type u_3\nf : \u03b1\u271d \u2192 \ud835\udd5c\nl : Filter \u03b1\u271d\ng : \u03b1\u271d \u2192 \ud835\udd5c\nC : \ud835\udd5c\nhC : C < 0\nhf : Tendsto f l (nhds C)\nhg : Tendsto g l atBot\n\u22a2 Tendsto (fun x => f x * g x) l atTop"}, {"line": "simpa only [mul_comm] using hg.atBot_mul_neg hC hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_bdd_div_atTop_nhds_zero {f g : \u03b1 \u2192 \ud835\udd5c} {b B : \ud835\udd5c}\n    (hb : \u2200\u1da0 x in l, b \u2264 f x) (hB : \u2200\u1da0 x in l, f x \u2264 B) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x / g x) l (\ud835\udcdd 0) := by\n  simp only [div_eq_mul_inv]\n  exact bdd_le_mul_tendsto_zero hb hB hg.inv_tendsto_atTop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Field.lean", "context": {"open": ["Set Filter TopologicalSpace Function", "scoped Pointwise Topology", "OrderDual (toDual ofDual)"], "variables": ["{\ud835\udd5c \u03b1 : Type*} [Field \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\nl : Filter \u03b1\nf g : \u03b1 \u2192 \ud835\udd5c\nb B : \ud835\udd5c\nhb : \u2200\u1da0 (x : \u03b1) in l, b \u2264 f x\nhB : \u2200\u1da0 (x : \u03b1) in l, f x \u2264 B\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => f x / g x) l (nhds 0)"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "\ud835\udd5c : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b2 : Field \ud835\udd5c\ninst\u271d\u00b9 : LinearOrder \ud835\udd5c\ninst\u271d : IsStrictOrderedRing \ud835\udd5c\nl : Filter \u03b1\nf g : \u03b1 \u2192 \ud835\udd5c\nb B : \ud835\udd5c\nhb : \u2200\u1da0 (x : \u03b1) in l, b \u2264 f x\nhB : \u2200\u1da0 (x : \u03b1) in l, f x \u2264 B\nhg : Tendsto g l atTop\n\u22a2 Tendsto (fun x => f x * (g x)\u207b\u00b9) l (nhds 0)"}, {"line": "exact bdd_le_mul_tendsto_zero hb hB hg.inv_tendsto_atTop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_one_iff_mabs_tendsto_one (f : \u03b1 \u2192 G) :\n    Tendsto f l (\ud835\udcdd 1) \u2194 Tendsto (mabs \u2218 f) l (\ud835\udcdd 1) := by\n  rw [\u2190 tendsto_comap_iff]\n  rw [comap_mabs_nhds_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Order/Group.lean", "context": {"open": ["Set Filter Function", "scoped Topology"], "variables": ["{G : Type*} [TopologicalSpace G] [CommGroup G] [LinearOrder G] [IsOrderedMonoid G]", "{\u03b1 : Type*} {l : Filter \u03b1} {f : \u03b1 \u2192 G}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\n\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 G\n\u22a2 Tendsto f l (nhds 1) \u2194 Tendsto (mabs \u2218 f) l (nhds 1)"}, {"line": "rw [\u2190 tendsto_comap_iff]", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\n\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 G\n\u22a2 Tendsto f l (nhds 1) \u2194 Tendsto f l (comap mabs (nhds 1))"}, {"line": "rw [comap_mabs_nhds_one]", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\n\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 G\n\u22a2 IsOrderedMonoid G\n---\nG : Type u_1\ninst\u271d\u00b3 : TopologicalSpace G\ninst\u271d\u00b2 : CommGroup G\ninst\u271d\u00b9 : LinearOrder G\ninst\u271d : IsOrderedMonoid G\n\u03b1 : Type u_2\nl : Filter \u03b1\nf : \u03b1 \u2192 G\n\u22a2 OrderTopology G"}]}
{"declaration": "theorem properSMul_iff_continuousSMul_ultrafilter_tendsto_t2 [T2Space X] :\n    ProperSMul G X \u2194 ContinuousSMul G X \u2227\n      (\u2200 \ud835\udcb0 : Ultrafilter (G \u00d7 X), \u2200 x\u2081 x\u2082 : X,\n        Tendsto (fun gx : G \u00d7 X \u21a6 (gx.1 \u2022 gx.2, gx.2)) \ud835\udcb0 (\ud835\udcdd (x\u2081, x\u2082)) \u2192\n     \u2203 g : G, Tendsto (Prod.fst : G \u00d7 X \u2192 G) \ud835\udcb0 (\ud835\udcdd g)) := by\n  rw [properSMul_iff_continuousSMul_ultrafilter_tendsto]\n  refine and_congr_right fun hc \u21a6 ?_\n  congrm \u2200 \ud835\udcb0 x\u2081 x\u2082 hxx, \u2203 g, ?_\n  exact and_iff_right_of_imp fun hg \u21a6 tendsto_nhds_unique\n    (hg.smul ((continuous_snd.tendsto _).comp hxx)) ((continuous_fst.tendsto _).comp hxx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/ProperAction/Basic.lean", "context": {"open": ["Filter Topology Set Prod"], "variables": ["{G X : Type*} [Group G] [MulAction G X]", "[TopologicalSpace G] [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\nX : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G X\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\n\u22a2 ProperSMul G X \u2194\n    ContinuousSMul G X \u2227\n      \u2200 (\ud835\udcb0 : Ultrafilter (G \u00d7 X)) (x\u2081 x\u2082 : X),\n        Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082)) \u2192 \u2203 g, Tendsto fst (\u2191\ud835\udcb0) (nhds g)"}, {"line": "rw [properSMul_iff_continuousSMul_ultrafilter_tendsto]", "tactic_state": "G : Type u_1\nX : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G X\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\n\u22a2 (ContinuousSMul G X \u2227\n      \u2200 (\ud835\udcb0 : Ultrafilter (G \u00d7 X)) (x\u2081 x\u2082 : X),\n        Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082)) \u2192 \u2203 g, g \u2022 x\u2082 = x\u2081 \u2227 Tendsto fst (\u2191\ud835\udcb0) (nhds g)) \u2194\n    ContinuousSMul G X \u2227\n      \u2200 (\ud835\udcb0 : Ultrafilter (G \u00d7 X)) (x\u2081 x\u2082 : X),\n        Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082)) \u2192 \u2203 g, Tendsto fst (\u2191\ud835\udcb0) (nhds g)"}, {"line": "refine and_congr_right fun hc \u21a6 ?_", "tactic_state": "G : Type u_1\nX : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G X\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\nhc : ContinuousSMul G X\n\u22a2 (\u2200 (\ud835\udcb0 : Ultrafilter (G \u00d7 X)) (x\u2081 x\u2082 : X),\n      Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082)) \u2192 \u2203 g, g \u2022 x\u2082 = x\u2081 \u2227 Tendsto fst (\u2191\ud835\udcb0) (nhds g)) \u2194\n    \u2200 (\ud835\udcb0 : Ultrafilter (G \u00d7 X)) (x\u2081 x\u2082 : X),\n      Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082)) \u2192 \u2203 g, Tendsto fst (\u2191\ud835\udcb0) (nhds g)"}, {"line": "congrm \u2200 \ud835\udcb0 x\u2081 x\u2082 hxx, \u2203 g, ?_", "tactic_state": "case a\nG : Type u_1\nX : Type u_2\ninst\u271d\u2074 : Group G\ninst\u271d\u00b3 : MulAction G X\ninst\u271d\u00b2 : TopologicalSpace G\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : T2Space X\nhc : ContinuousSMul G X\n\ud835\udcb0 : Ultrafilter (G \u00d7 X)\nx\u2081 x\u2082 : X\nhxx : Tendsto (fun gx => (gx.1 \u2022 gx.2, gx.2)) (\u2191\ud835\udcb0) (nhds (x\u2081, x\u2082))\ng : G\n\u22a2 g \u2022 x\u2082 = x\u2081 \u2227 Tendsto fst (\u2191\ud835\udcb0) (nhds g) \u2194 Tendsto fst (\u2191\ud835\udcb0) (nhds g)"}, {"line": "exact and_iff_right_of_imp fun hg \u21a6 tendsto_nhds_unique\n    (hg.smul ((continuous_snd.tendsto _).comp hxx)) ((continuous_fst.tendsto _).comp hxx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsTopologicalSemiring.continuousNeg_of_mul [TopologicalSpace R] [NonAssocRing R]\n    [ContinuousMul R] : ContinuousNeg R where\n  continuous_neg := by\n    simpa using (continuous_const.mul continuous_id : Continuous fun x : R => -1 * x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Ring/Basic.lean", "context": {"open": ["Set Filter TopologicalSpace Function Topology Filter"], "variables": ["(R : Type*)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : TopologicalSpace R\ninst\u271d\u00b9 : NonAssocRing R\ninst\u271d : ContinuousMul R\n\u22a2 Continuous fun a => -a"}, {"line": "simpa using (continuous_const.mul continuous_id : Continuous fun x : R => -1 * x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_le_one_iff : \u2016x\u2016 \u2264 1 \u2194 val.v x \u2264 1 := by\n  simpa only [map_one] using (Valuation.RankOne.strictMono val.v).le_iff_le (b := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Valued/NormedValued.lean", "context": {"open": ["Filter Set Valuation", "scoped NNReal", "scoped Valued"], "variables": ["{K : Type*} [hK : NormedField K] [IsUltrametricDist K]", "{L : Type*} [Field L] {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]", "(L) (\u0393\u2080)", "{L} {\u0393\u2080}", "{x x' : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry \u2264 1 \u2194 sorry \u2264 1"}, {"line": "simpa only [map_one] using (Valuation.RankOne.strictMono val.v).le_iff_le (b := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_lt_one_iff : \u2016x\u2016 < 1 \u2194 val.v x < 1 := by\n  simpa only [map_one] using (Valuation.RankOne.strictMono val.v).lt_iff_lt (b := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Valued/NormedValued.lean", "context": {"open": ["Filter Set Valuation", "scoped NNReal", "scoped Valued"], "variables": ["{K : Type*} [hK : NormedField K] [IsUltrametricDist K]", "{L : Type*} [Field L] {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]", "(L) (\u0393\u2080)", "{L} {\u0393\u2080}", "{x x' : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sorry < 1 \u2194 sorry < 1"}, {"line": "simpa only [map_one] using (Valuation.RankOne.strictMono val.v).lt_iff_lt (b := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_norm_iff : 1 \u2264 \u2016x\u2016 \u2194 1 \u2264 val.v x := by\n  simpa only [map_one] using (Valuation.RankOne.strictMono val.v).le_iff_le (a := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Valued/NormedValued.lean", "context": {"open": ["Filter Set Valuation", "scoped NNReal", "scoped Valued"], "variables": ["{K : Type*} [hK : NormedField K] [IsUltrametricDist K]", "{L : Type*} [Field L] {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]", "(L) (\u0393\u2080)", "{L} {\u0393\u2080}", "{x x' : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 \u2264 sorry \u2194 1 \u2264 sorry"}, {"line": "simpa only [map_one] using (Valuation.RankOne.strictMono val.v).le_iff_le (a := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_norm_iff : 1 < \u2016x\u2016 \u2194 1 < val.v x := by\n  simpa only [map_one] using (Valuation.RankOne.strictMono val.v).lt_iff_lt (a := 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Valued/NormedValued.lean", "context": {"open": ["Filter Set Valuation", "scoped NNReal", "scoped Valued"], "variables": ["{K : Type*} [hK : NormedField K] [IsUltrametricDist K]", "{L : Type*} [Field L] {\u0393\u2080 : Type*} [LinearOrderedCommGroupWithZero \u0393\u2080]", "(L) (\u0393\u2080)", "{L} {\u0393\u2080}", "{x x' : L}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 1 < sorry \u2194 1 < sorry"}, {"line": "simpa only [map_one] using (Valuation.RankOne.strictMono val.v).lt_iff_lt (a := 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_nhds_zero :\n    (\ud835\udcdd (0 : R)).HasBasis (fun _ => True) fun \u03b3 : \u0393\u2080\u02e3 => { x | v x < (\u03b3 : \u0393\u2080) } := by\n  simp [Filter.hasBasis_iff, is_topological_valuation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Algebra/Valued/ValuationTopology.lean", "context": {"open": ["scoped Topology uniformity", "Set Valuation"], "variables": ["{R : Type u} [Ring R] {\u0393\u2080 : Type v} [LinearOrderedCommGroupWithZero \u0393\u2080]", "(v : Valuation R \u0393\u2080)", "(R \u0393\u2080)", "[_i : Valued R \u0393\u2080]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\n\u0393\u2080 : Type v\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\n_i : Valued R \u0393\u2080\n\u22a2 (nhds 0).HasBasis (fun x => True) fun \u03b3 => {x | v x < \u2191\u03b3}"}, {"line": "simp [Filter.hasBasis_iff, is_topological_valuation]", "tactic_state": "R : Type u\ninst\u271d\u00b9 : Ring R\n\u0393\u2080 : Type v\ninst\u271d : LinearOrderedCommGroupWithZero \u0393\u2080\nv : Valuation R \u0393\u2080\n_i : Valued R \u0393\u2080\n\u22a2 \u2200 (t : Set R), t \u2208 nhds 0 \u2194 \u2203 i, {x | v x < \u2191i} \u2286 t"}]}
{"declaration": "theorem dense_biInter_of_isOpen {S : Set \u03b1} {f : \u03b1 \u2192 Set X} (ho : \u2200 s \u2208 S, IsOpen (f s))\n    (hS : S.Countable) (hd : \u2200 s \u2208 S, Dense (f s)) : Dense (\u22c2 s \u2208 S, f s) := by\n  rw [\u2190 sInter_image]\n  refine dense_sInter_of_isOpen ?_ (hS.image _) ?_ <;> rwa [forall_mem_image]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/Lemmas.lean", "context": {"open": ["scoped Topology", "Filter Set TopologicalSpace"], "variables": ["{X \u03b1 : Type*} {\u03b9 : Sort*}", "[TopologicalSpace X] [BaireSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nS : Set \u03b1\nf : \u03b1 \u2192 Set X\nho : \u2200 s \u2208 S, IsOpen (f s)\nhS : S.Countable\nhd : \u2200 s \u2208 S, Dense (f s)\n\u22a2 Dense (\u22c2 s \u2208 S, f s)"}, {"line": "rw [\u2190 sInter_image]", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nS : Set \u03b1\nf : \u03b1 \u2192 Set X\nho : \u2200 s \u2208 S, IsOpen (f s)\nhS : S.Countable\nhd : \u2200 s \u2208 S, Dense (f s)\n\u22a2 Dense (\u22c2\u2080 (f '' S))"}, {"line": "refine dense_sInter_of_isOpen ?_ (hS.image _) ?_ <;> rwa [forall_mem_image]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dense_biInter_of_G\u03b4 {S : Set \u03b1} {f : \u2200 x \u2208 S, Set X} (ho : \u2200 s (H : s \u2208 S), IsG\u03b4 (f s H))\n    (hS : S.Countable) (hd : \u2200 s (H : s \u2208 S), Dense (f s H)) : Dense (\u22c2 s \u2208 S, f s \u2039_\u203a) := by\n  rw [biInter_eq_iInter]\n  haveI := hS.to_subtype\n  exact dense_iInter_of_G\u03b4 (fun s => ho s s.2) fun s => hd s s.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/Lemmas.lean", "context": {"open": ["scoped Topology", "Filter Set TopologicalSpace"], "variables": ["{X \u03b1 : Type*} {\u03b9 : Sort*}", "[TopologicalSpace X] [BaireSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nS : Set \u03b1\nf : (x : \u03b1) \u2192 x \u2208 S \u2192 Set X\nho : \u2200 (s : \u03b1) (H : s \u2208 S), IsG\u03b4 (f s H)\nhS : S.Countable\nhd : \u2200 (s : \u03b1) (H : s \u2208 S), Dense (f s H)\n\u22a2 Dense (\u22c2 s, \u22c2 (h : s \u2208 S), f s h)"}, {"line": "rw [biInter_eq_iInter]", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nS : Set \u03b1\nf : (x : \u03b1) \u2192 x \u2208 S \u2192 Set X\nho : \u2200 (s : \u03b1) (H : s \u2208 S), IsG\u03b4 (f s H)\nhS : S.Countable\nhd : \u2200 (s : \u03b1) (H : s \u2208 S), Dense (f s H)\n\u22a2 Dense (\u22c2 x, f \u2191x \u22ef)"}, {"line": "haveI := hS.to_subtype", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nS : Set \u03b1\nf : (x : \u03b1) \u2192 x \u2208 S \u2192 Set X\nho : \u2200 (s : \u03b1) (H : s \u2208 S), IsG\u03b4 (f s H)\nhS : S.Countable\nhd : \u2200 (s : \u03b1) (H : s \u2208 S), Dense (f s H)\nthis : Countable \u2191S\n\u22a2 Dense (\u22c2 x, f \u2191x \u22ef)"}, {"line": "exact dense_iInter_of_G\u03b4 (fun s => ho s s.2) fun s => hd s s.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.dense_biUnion_interior_of_closed {t : Set \u03b1} {s : Set X} (hs : IsG\u03b4 s) (hd : Dense s)\n    (ht : t.Countable) {f : \u03b1 \u2192 Set X} (hc : \u2200 i \u2208 t, IsClosed (f i)) (hU : s \u2286 \u22c3 i \u2208 t, f i) :\n    Dense (\u22c3 i \u2208 t, interior (f i)) := by\n  haveI := ht.to_subtype\n  simp only [biUnion_eq_iUnion] at *\n  simp only [SetCoe.forall'] at *\n  exact hs.dense_iUnion_interior_of_closed hd hc hU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/Lemmas.lean", "context": {"open": ["scoped Topology", "Filter Set TopologicalSpace"], "variables": ["{X \u03b1 : Type*} {\u03b9 : Sort*}", "[TopologicalSpace X] [BaireSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nt : Set \u03b1\ns : Set X\nhs : IsG\u03b4 s\nhd : Dense s\nht : t.Countable\nf : \u03b1 \u2192 Set X\nhc : \u2200 i \u2208 t, IsClosed (f i)\nhU : s \u2286 \u22c3 i \u2208 t, f i\n\u22a2 Dense (\u22c3 i \u2208 t, interior (f i))"}, {"line": "haveI := ht.to_subtype", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nt : Set \u03b1\ns : Set X\nhs : IsG\u03b4 s\nhd : Dense s\nht : t.Countable\nf : \u03b1 \u2192 Set X\nhc : \u2200 i \u2208 t, IsClosed (f i)\nhU : s \u2286 \u22c3 i \u2208 t, f i\nthis : Countable \u2191t\n\u22a2 Dense (\u22c3 i \u2208 t, interior (f i))"}, {"line": "simp only [biUnion_eq_iUnion] at *", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nt : Set \u03b1\ns : Set X\nhs : IsG\u03b4 s\nhd : Dense s\nht : t.Countable\nf : \u03b1 \u2192 Set X\nhc : \u2200 i \u2208 t, IsClosed (f i)\nthis : Countable \u2191t\nhU : s \u2286 \u22c3 x, f \u2191x\n\u22a2 Dense (\u22c3 x, interior (f \u2191x))"}, {"line": "simp only [SetCoe.forall'] at *", "tactic_state": "X : Type u_1\n\u03b1 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : BaireSpace X\nt : Set \u03b1\ns : Set X\nhs : IsG\u03b4 s\nhd : Dense s\nht : t.Countable\nf : \u03b1 \u2192 Set X\nthis : Countable \u2191t\nhU : s \u2286 \u22c3 x, f \u2191x\nhc : \u2200 (x : \u2191t), IsClosed (f \u2191x)\n\u22a2 Dense (\u22c3 x, interior (f \u2191x))"}, {"line": "exact hs.dense_iUnion_interior_of_closed hd hc hU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_interior_of_iUnion_of_closed [Nonempty X] [Countable \u03b9] {f : \u03b9 \u2192 Set X}\n    (hc : \u2200 i, IsClosed (f i)) (hU : \u22c3 i, f i = univ) : \u2203 i, (interior <| f i).Nonempty := by\n  simpa using (dense_iUnion_interior_of_closed hc hU).nonempty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/Lemmas.lean", "context": {"open": ["scoped Topology", "Filter Set TopologicalSpace"], "variables": ["{X \u03b1 : Type*} {\u03b9 : Sort*}", "[TopologicalSpace X] [BaireSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Sort u_3\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : BaireSpace X\ninst\u271d\u00b9 : Nonempty X\ninst\u271d : Countable \u03b9\nf : \u03b9 \u2192 Set X\nhc : \u2200 (i : \u03b9), IsClosed (f i)\nhU : \u22c3 i, f i = univ\n\u22a2 \u2203 i, (interior (f i)).Nonempty"}, {"line": "simpa using (dense_iUnion_interior_of_closed hc hU).nonempty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.IsOpen.baireMeasurableSet (h : IsOpen s) : BaireMeasurableSet s := by\n  borelize \u03b1\n  exact h.measurableSet.baireMeasurableSet\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/BaireMeasurable.lean", "context": {"open": ["Topology"], "variables": ["(\u03b1 : Type*) {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{\u03b1}", "{s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nh : IsOpen s\n\u22a2 BaireMeasurableSet s"}, {"line": "borelize \u03b1", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nh : IsOpen s\nthis\u271d\u00b9 : MeasurableSpace \u03b1 := sorry\nthis\u271d : sorry\n\u22a2 BaireMeasurableSet s"}, {"line": "exact h.measurableSet.baireMeasurableSet", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Homeomorph.residual_map_eq (h : \u03b1 \u2243\u209c \u03b2) : (residual \u03b1).map h = residual \u03b2 := by\n  refine le_antisymm (tendsto_residual_of_isOpenMap h.continuous h.isOpenMap) (le_map ?_)\n  simp_rw [\u2190 preimage_symm]\n  exact tendsto_residual_of_isOpenMap h.symm.continuous h.symm.isOpenMap\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Baire/BaireMeasurable.lean", "context": {"open": ["Topology", "Filter", "Set"], "variables": ["(\u03b1 : Type*) {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{\u03b1}", "{s t : Set \u03b1}", "{f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nh : \u03b1 \u2243\u209c \u03b2\n\u22a2 map (\u21d1h) (residual \u03b1) = residual \u03b2"}, {"line": "refine le_antisymm (tendsto_residual_of_isOpenMap h.continuous h.isOpenMap) (le_map ?_)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nh : \u03b1 \u2243\u209c \u03b2\n\u22a2 \u2200 s \u2208 residual \u03b1, \u21d1h '' s \u2208 residual \u03b2"}, {"line": "simp_rw [\u2190 preimage_symm]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nh : \u03b1 \u2243\u209c \u03b2\n\u22a2 \u2200 s \u2208 residual \u03b1, \u21d1h.symm \u207b\u00b9' s \u2208 residual \u03b2"}, {"line": "exact tendsto_residual_of_isOpenMap h.symm.continuous h.symm.isOpenMap", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.absorbs_union : Absorbs M s (t\u2081 \u222a t\u2082) \u2194 Absorbs M s t\u2081 \u2227 Absorbs M s t\u2082 := by\n  simp [Absorbs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Absorbs.lean", "context": {"open": ["Set Bornology Filter", "scoped Pointwise"], "variables": ["(M : Type*) {\u03b1 : Type*} [Bornology M] [SMul M \u03b1]", "{M \u03b1 : Type*} [Bornology M] [SMul M \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {S T : Set (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Bornology M\ninst\u271d : SMul M \u03b1\ns t\u2081 t\u2082 : Set \u03b1\n\u22a2 Absorbs M s (t\u2081 \u222a t\u2082) \u2194 Absorbs M s t\u2081 \u2227 Absorbs M s t\u2082"}, {"line": "simp [Absorbs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.Finite.absorbs_sUnion {T : Set (Set \u03b1)} (hT : T.Finite) :\n    Absorbs M s (\u22c3\u2080 T) \u2194 \u2200 t \u2208 T, Absorbs M s t := by\n  simp [Absorbs, hT]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Absorbs.lean", "context": {"open": ["Set Bornology Filter", "scoped Pointwise"], "variables": ["(M : Type*) {\u03b1 : Type*} [Bornology M] [SMul M \u03b1]", "{M \u03b1 : Type*} [Bornology M] [SMul M \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {S T : Set (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Bornology M\ninst\u271d : SMul M \u03b1\ns : Set \u03b1\nT : Set (Set \u03b1)\nhT : T.Finite\n\u22a2 Absorbs M s (\u22c3\u2080 T) \u2194 \u2200 t \u2208 T, Absorbs M s t"}, {"line": "simp [Absorbs, hT]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Set.Finite.absorbs_biUnion {\u03b9 : Type*} {t : \u03b9 \u2192 Set \u03b1} {I : Set \u03b9} (hI : I.Finite) :\n    Absorbs M s (\u22c3 i \u2208 I, t i) \u2194 \u2200 i \u2208 I, Absorbs M s (t i) := by\n  simp [Absorbs, hI]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Absorbs.lean", "context": {"open": ["Set Bornology Filter", "scoped Pointwise"], "variables": ["(M : Type*) {\u03b1 : Type*} [Bornology M] [SMul M \u03b1]", "{M \u03b1 : Type*} [Bornology M] [SMul M \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {S T : Set (Set \u03b1)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_3\n\u03b1 : Type u_4\ninst\u271d\u00b9 : Bornology M\ninst\u271d : SMul M \u03b1\ns : Set \u03b1\n\u03b9 : Type u_5\nt : \u03b9 \u2192 Set \u03b1\nI : Set \u03b9\nhI : I.Finite\n\u22a2 Absorbs M s (\u22c3 i \u2208 I, t i) \u2194 \u2200 i \u2208 I, Absorbs M s (t i)"}, {"line": "simp [Absorbs, hI]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem absorbs_finite (hs : Absorbent M s) (ht : t.Finite) : Absorbs M s t := by\n  rw [\u2190 Set.biUnion_of_singleton t]\n  exact .biUnion ht fun _ _ => hs.absorbs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Absorbs.lean", "context": {"open": ["Set Bornology Filter", "scoped Pointwise"], "variables": ["(M : Type*) {\u03b1 : Type*} [Bornology M] [SMul M \u03b1]", "{M \u03b1 : Type*} [Bornology M] [SMul M \u03b1] {s s\u2081 s\u2082 t t\u2081 t\u2082 : Set \u03b1} {S T : Set (Set \u03b1)}", "{M E : Type*} [Bornology M] {s\u2081 s\u2082 t\u2081 t\u2082 : Set E}", "{G\u2080 \u03b1 : Type*} [GroupWithZero G\u2080] [Bornology G\u2080] [MulAction G\u2080 \u03b1]", "(G\u2080 u) in", "{M E : Type*} [Monoid M] [AddGroup E] [DistribMulAction M E] [Bornology M]", "{M \u03b1 : Type*} [Bornology M] [SMul M \u03b1] {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_9\n\u03b1 : Type u_10\ninst\u271d\u00b9 : Bornology M\ninst\u271d : SMul M \u03b1\ns t : Set \u03b1\nhs : Absorbent M s\nht : t.Finite\n\u22a2 Absorbs M s t"}, {"line": "rw [\u2190 Set.biUnion_of_singleton t]", "tactic_state": "M : Type u_9\n\u03b1 : Type u_10\ninst\u271d\u00b9 : Bornology M\ninst\u271d : SMul M \u03b1\ns t : Set \u03b1\nhs : Absorbent M s\nht : t.Finite\n\u22a2 Absorbs M s (\u22c3 x \u2208 t, {x})"}, {"line": "exact .biUnion ht fun _ _ => hs.absorbs", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Bornology.ext (t t' : Bornology \u03b1)\n    (h_cobounded : @Bornology.cobounded \u03b1 t = @Bornology.cobounded \u03b1 t') :\n    t = t' := by\n  cases t\n  cases t'\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Basic.lean", "context": {"open": ["Set Filter"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nt t' : Bornology \u03b1\nh_cobounded : cobounded \u03b1 = cobounded \u03b1\n\u22a2 t = t'"}, {"line": "cases t", "tactic_state": "case mk\n\u03b1 : Type u_2\nt' : Bornology \u03b1\ncobounded'\u271d : Filter \u03b1\nle_cofinite'\u271d : cobounded'\u271d \u2264 Filter.cofinite\nh_cobounded : cobounded \u03b1 = cobounded \u03b1\n\u22a2 { cobounded' := cobounded'\u271d, le_cofinite' := le_cofinite'\u271d } = t'"}, {"line": "cases t'", "tactic_state": "case mk.mk\n\u03b1 : Type u_2\ncobounded'\u271d\u00b9 : Filter \u03b1\nle_cofinite'\u271d\u00b9 : cobounded'\u271d\u00b9 \u2264 Filter.cofinite\ncobounded'\u271d : Filter \u03b1\nle_cofinite'\u271d : cobounded'\u271d \u2264 Filter.cofinite\nh_cobounded : cobounded \u03b1 = cobounded \u03b1\n\u22a2 { cobounded' := cobounded'\u271d\u00b9, le_cofinite' := le_cofinite'\u271d\u00b9 } =\n    { cobounded' := cobounded'\u271d, le_cofinite' := le_cofinite'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cobounded_eq_bot_iff : cobounded \u03b1 = \u22a5 \u2194 BoundedSpace \u03b1 := by\n  rw [\u2190 isBounded_univ]\n  rw [isBounded_def]\n  rw [compl_univ]\n  rw [empty_mem_iff_bot]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Basic.lean", "context": {"open": ["Set Filter", "Bornology"], "variables": ["{\u03b9 \u03b1 \u03b2 : Type*}", "{_ : Bornology \u03b1} {s t : Set \u03b1} {x : \u03b1}", "{s : Set \u03b1}", "[Bornology \u03b1]", "[Bornology \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 inst\u271d : Bornology \u03b1\n\u22a2 cobounded \u03b1 = \u22a5 \u2194 BoundedSpace \u03b1"}, {"line": "rw [\u2190 isBounded_univ]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 inst\u271d : Bornology \u03b1\n\u22a2 cobounded \u03b1 = \u22a5 \u2194 Bornology.IsBounded univ"}, {"line": "rw [isBounded_def]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 inst\u271d : Bornology \u03b1\n\u22a2 cobounded \u03b1 = \u22a5 \u2194 univ\u1d9c \u2208 cobounded \u03b1"}, {"line": "rw [compl_univ]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 inst\u271d : Bornology \u03b1\n\u22a2 cobounded \u03b1 = \u22a5 \u2194 \u2205 \u2208 cobounded \u03b1"}, {"line": "rw [empty_mem_iff_bot]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sub_bounded_of_bounded_of_bounded {X : Type*} [PseudoMetricSpace R] [Sub R] [BoundedSub R]\n    {f g : X \u2192 R} (f_bdd : \u2203 C, \u2200 x y, dist (f x) (f y) \u2264 C)\n    (g_bdd : \u2203 C, \u2200 x y, dist (g x) (g y) \u2264 C) :\n    \u2203 C, \u2200 x y, dist ((f - g) x) ((f - g) y) \u2264 C := by\n  obtain \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp <|\n    isBounded_sub (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)\n  use C\n  intro x y\n  exact hC (Set.sub_mem_sub (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.sub_mem_sub (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/BoundedOperation.lean", "context": {"open": ["scoped NNReal", "Pointwise"], "variables": ["{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Sub R\ninst\u271d : BoundedSub R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\n\u22a2 \u2203 C, \u2200 (x y : X), dist ((f - g) x) ((f - g) y) \u2264 C"}, {"line": "obtain \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp <|\n    isBounded_sub (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)", "tactic_state": "case intro\nR : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Sub R\ninst\u271d : BoundedSub R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 Set.range f - Set.range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 Set.range f - Set.range g \u2192 dist x y \u2264 C\n\u22a2 \u2203 C, \u2200 (x y : X), dist ((f - g) x) ((f - g) y) \u2264 C"}, {"line": "use C", "tactic_state": "case h\nR : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Sub R\ninst\u271d : BoundedSub R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 Set.range f - Set.range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 Set.range f - Set.range g \u2192 dist x y \u2264 C\n\u22a2 \u2200 (x y : X), dist ((f - g) x) ((f - g) y) \u2264 C"}, {"line": "intro x y", "tactic_state": "case h\nR : Type u_1\nX : Type u_2\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Sub R\ninst\u271d : BoundedSub R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 Set.range f - Set.range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 Set.range f - Set.range g \u2192 dist x y \u2264 C\nx y : X\n\u22a2 dist ((f - g) x) ((f - g) y) \u2264 C"}, {"line": "exact hC (Set.sub_mem_sub (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.sub_mem_sub (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_bounded_of_bounded_of_bounded {X : Type*} [PseudoMetricSpace R] [Mul R] [BoundedMul R]\n    {f g : X \u2192 R} (f_bdd : \u2203 C, \u2200 x y, dist (f x) (f y) \u2264 C)\n    (g_bdd : \u2203 C, \u2200 x y, dist (g x) (g y) \u2264 C) :\n    \u2203 C, \u2200 x y, dist ((f * g) x) ((f * g) y) \u2264 C := by\n  obtain \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp <|\n    isBounded_mul (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)\n  use C\n  intro x y\n  exact hC (Set.mul_mem_mul (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.mul_mem_mul (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/BoundedOperation.lean", "context": {"open": ["scoped NNReal", "Pointwise", "Pointwise Set"], "variables": ["{R : Type*}", "{R : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_2\nX : Type u_3\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Mul R\ninst\u271d : BoundedMul R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\n\u22a2 \u2203 C, \u2200 (x y : X), dist ((f * g) x) ((f * g) y) \u2264 C"}, {"line": "obtain \u27e8C, hC\u27e9 := Metric.isBounded_iff.mp <|\n    isBounded_mul (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)", "tactic_state": "case intro\nR : Type u_2\nX : Type u_3\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Mul R\ninst\u271d : BoundedMul R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 range f * range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 range f * range g \u2192 dist x y \u2264 C\n\u22a2 \u2203 C, \u2200 (x y : X), dist ((f * g) x) ((f * g) y) \u2264 C"}, {"line": "use C", "tactic_state": "case h\nR : Type u_2\nX : Type u_3\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Mul R\ninst\u271d : BoundedMul R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 range f * range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 range f * range g \u2192 dist x y \u2264 C\n\u22a2 \u2200 (x y : X), dist ((f * g) x) ((f * g) y) \u2264 C"}, {"line": "intro x y", "tactic_state": "case h\nR : Type u_2\nX : Type u_3\ninst\u271d\u00b2 : PseudoMetricSpace R\ninst\u271d\u00b9 : Mul R\ninst\u271d : BoundedMul R\nf g : X \u2192 R\nf_bdd : \u2203 C, \u2200 (x y : X), dist (f x) (f y) \u2264 C\ng_bdd : \u2203 C, \u2200 (x y : X), dist (g x) (g y) \u2264 C\nC : \u211d\nhC : \u2200 \u2983x : R\u2984, x \u2208 range f * range g \u2192 \u2200 \u2983y : R\u2984, y \u2208 range f * range g \u2192 dist x y \u2264 C\nx y : X\n\u22a2 dist ((f * g) x) ((f * g) y) \u2264 C"}, {"line": "exact hC (Set.mul_mem_mul (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.mul_mem_mul (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SeminormedAddCommGroup.lipschitzWith_sub :\n    LipschitzWith 2 (fun (p : R \u00d7 R) \u21a6 p.1 - p.2) := by\n  convert LipschitzWith.prod_fst.sub LipschitzWith.prod_snd\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/BoundedOperation.lean", "context": {"open": ["scoped NNReal", "Pointwise", "Pointwise Set"], "variables": ["{R : Type*}", "{R : Type*}", "{R : Type*} [SeminormedAddCommGroup R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : SeminormedAddCommGroup R\n\u22a2 LipschitzWith 2 fun p => p.1 - p.2"}, {"line": "convert LipschitzWith.prod_fst.sub LipschitzWith.prod_snd", "tactic_state": "case h.e'_5\nR : Type u_3\ninst\u271d : SeminormedAddCommGroup R\n\u22a2 2 = 1 + 1"}, {"line": "norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boundedSpace_induced_iff {\u03b1 \u03b2 : Type*} [Bornology \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    @BoundedSpace \u03b1 (Bornology.induced f) \u2194 IsBounded (range f) := by\n  rw [\u2190 @isBounded_univ]\n  rw [isBounded_induced]\n  rw [image_univ]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Constructions.lean", "context": {"open": ["Set Filter Bornology Function", "Filter", "Bornology"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Bornology \u03b1] [Bornology \u03b2]", "{s : Set \u03b1} {t : Set \u03b2} {S : \u2200 i, Set (\u03c0 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d : Bornology \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 BoundedSpace \u03b1 \u2194 Bornology.IsBounded (range f)"}, {"line": "rw [\u2190 @isBounded_univ]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d : Bornology \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Bornology.IsBounded univ \u2194 Bornology.IsBounded (range f)"}, {"line": "rw [isBounded_induced]", "tactic_state": "\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d : Bornology \u03b2\nf : \u03b1 \u2192 \u03b2\n\u22a2 Bornology.IsBounded (f '' univ) \u2194 Bornology.IsBounded (range f)"}, {"line": "rw [image_univ]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem boundedSpace_subtype_iff {p : \u03b1 \u2192 Prop} :\n    BoundedSpace (Subtype p) \u2194 IsBounded { x | p x } := by\n  rw [boundedSpace_induced_iff]\n  rw [Subtype.range_coe_subtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Bornology/Constructions.lean", "context": {"open": ["Set Filter Bornology Function", "Filter", "Bornology"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [Bornology \u03b1] [Bornology \u03b2]", "{s : Set \u03b1} {t : Set \u03b2} {S : \u2200 i, Set (\u03c0 i)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Bornology \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 BoundedSpace (Subtype p) \u2194 Bornology.IsBounded {x | p x}"}, {"line": "rw [boundedSpace_induced_iff]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : Bornology \u03b1\np : \u03b1 \u2192 Prop\n\u22a2 Bornology.IsBounded (range Subtype.val) \u2194 Bornology.IsBounded {x | p x}"}, {"line": "rw [Subtype.range_coe_subtype]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lim_eq_str {X : Compactum} (F : Ultrafilter X) : F.lim = X.str F := by\n  rw [Ultrafilter.lim_eq_iff_le_nhds]\n  rw [le_nhds_iff]\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Compactum.lean", "context": {"open": ["CategoryTheory Filter Ultrafilter TopologicalSpace CategoryTheory.Limits FiniteInter", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Compactum\nF : Ultrafilter X.A\n\u22a2 F.lim = X.str F"}, {"line": "rw [Ultrafilter.lim_eq_iff_le_nhds]", "tactic_state": "X : Compactum\nF : Ultrafilter X.A\n\u22a2 \u2191F \u2264 nhds (X.str F)"}, {"line": "rw [le_nhds_iff]", "tactic_state": "X : Compactum\nF : Ultrafilter X.A\n\u22a2 \u2200 (s : Set X.A), X.str F \u2208 s \u2192 IsOpen s \u2192 s \u2208 \u2191F"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem epi_of_surjective {X Y : CompHausLike.{u} P} (f : X \u27f6 Y) (hf : Function.Surjective f) :\n    Epi f := by\n  rw [\u2190 CategoryTheory.epi_iff_surjective] at hf\n  exact (forget (CompHausLike P)).epi_of_epi_map hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/CompHausLike/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["(P : TopCat.{u} \u2192 Prop)", "(X : Type u) [TopologicalSpace X] [CompactSpace X] [T2Space X]", "[HasProp P X]", "{X} {Y : Type u} [TopologicalSpace Y] [CompactSpace Y] [T2Space Y] [HasProp P Y]", "{Z : Type u} [TopologicalSpace Z] [CompactSpace Z] [T2Space Z] [HasProp P Z]", "{P}", "{P P' : TopCat \u2192 Prop} (h : \u2200 (X : CompHausLike P), P X.toTop \u2192 P' X.toTop)", "(P)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nhf : Function.Surjective \u21d1(ConcreteCategory.hom f)\n\u22a2 Epi f"}, {"line": "rw [\u2190 CategoryTheory.epi_iff_surjective] at hf", "tactic_state": "P : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nhf : Epi \u21d1(ConcreteCategory.hom f)\n\u22a2 Epi f"}, {"line": "exact (forget (CompHausLike P)).epi_of_epi_map hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isIso_of_bijective {X Y : CompHausLike.{u} P} (f : X \u27f6 Y) (bij : Function.Bijective f) :\n    IsIso f := by\n  let E := Equiv.ofBijective _ bij\n  have hE : Continuous E.symm := by\n    rw [continuous_iff_isClosed]\n    intro S hS\n    rw [\u2190 E.image_eq_preimage]\n    exact isClosedMap f S hS\n  refine \u27e8\u27e8ofHom _ \u27e8E.symm, hE\u27e9, ?_, ?_\u27e9\u27e9\n  \u00b7 ext x\n    apply E.symm_apply_apply\n  \u00b7 ext x\n    apply E.apply_symm_apply\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/CompHausLike/Basic.lean", "context": {"open": ["CategoryTheory"], "variables": ["(P : TopCat.{u} \u2192 Prop)", "(X : Type u) [TopologicalSpace X] [CompactSpace X] [T2Space X]", "[HasProp P X]", "{X} {Y : Type u} [TopologicalSpace Y] [CompactSpace Y] [T2Space Y] [HasProp P Y]", "{Z : Type u} [TopologicalSpace Z] [CompactSpace Z] [T2Space Z] [HasProp P Z]", "{P}", "{P P' : TopCat \u2192 Prop} (h : \u2200 (X : CompHausLike P), P X.toTop \u2192 P' X.toTop)", "(P)", "{P}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\n\u22a2 IsIso f"}, {"line": "let E := Equiv.ofBijective _ bij", "tactic_state": "P : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\nE : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij\n\u22a2 IsIso f"}, {"line": "have hE : Continuous E.symm := sorry", "tactic_state": "P : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\nE : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij\nhE : Continuous \u21d1E.symm\n\u22a2 IsIso f"}, {"line": "refine \u27e8\u27e8ofHom _ \u27e8E.symm, hE\u27e9, ?_, ?_\u27e9\u27e9", "tactic_state": "case refine_1\nP : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\nE : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij\nhE : Continuous \u21d1E.symm\n\u22a2 CategoryStruct.comp f sorry = CategoryStruct.id X\n---\ncase refine_2\nP : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\nE : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij\nhE : Continuous \u21d1E.symm\n\u22a2 CategoryStruct.comp sorry f = CategoryStruct.id Y"}, {"line": "\u00b7 ext x\n    apply E.symm_apply_apply", "tactic_state": "case refine_2\nP : TopCat \u2192 Prop\nX Y : CompHausLike P\nf : X \u27f6 Y\nbij : Function.Bijective \u21d1(ConcreteCategory.hom f)\nE : (fun X => \u2191X.toTop) X \u2243 (fun X => \u2191X.toTop) Y := Equiv.ofBijective (\u21d1(ConcreteCategory.hom f)) bij\nhE : Continuous \u21d1E.symm\n\u22a2 CategoryStruct.comp sorry f = CategoryStruct.id Y"}, {"line": "\u00b7 ext x\n    apply E.apply_symm_apply", "tactic_state": "No Goals!"}]}
{"declaration": "lemma proj_comp_transitionMap' (n : \u2115) : S.transitionMap n \u2218 S.proj (n + 1) = S.proj n := by\n  rw [\u2190 S.proj_comp_transitionMap n]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/LightProfinite/AsLimit.lean", "context": {"open": ["CategoryTheory Limits CompHausLike"], "variables": ["(S : LightProfinite.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : LightProfinite\nn : \u2115\n\u22a2 \u21d1(ConcreteCategory.hom (S.transitionMap n)) \u2218 \u21d1(ConcreteCategory.hom (S.proj (n + 1))) =\n    \u21d1(ConcreteCategory.hom (S.proj n))"}, {"line": "rw [\u2190 S.proj_comp_transitionMap n]", "tactic_state": "S : LightProfinite\nn : \u2115\n\u22a2 \u21d1(ConcreteCategory.hom (S.transitionMap n)) \u2218 \u21d1(ConcreteCategory.hom (S.proj (n + 1))) =\n    \u21d1(ConcreteCategory.hom (CategoryStruct.comp (S.proj (n + 1)) (S.diagram.map (Opposite.op (homOfLE \u22ef)))))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma proj_comp_transitionMapLE' {n m : \u2115} (h : n \u2264 m) :\n    S.transitionMapLE h \u2218 S.proj m  = S.proj n := by\n  rw [\u2190 S.proj_comp_transitionMapLE h]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/LightProfinite/AsLimit.lean", "context": {"open": ["CategoryTheory Limits CompHausLike"], "variables": ["(S : LightProfinite.{u})"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : LightProfinite\nn m : \u2115\nh : n \u2264 m\n\u22a2 \u21d1(ConcreteCategory.hom (S.transitionMapLE h)) \u2218 \u21d1(ConcreteCategory.hom (S.proj m)) =\n    \u21d1(ConcreteCategory.hom (S.proj n))"}, {"line": "rw [\u2190 S.proj_comp_transitionMapLE h]", "tactic_state": "S : LightProfinite\nn m : \u2115\nh : n \u2264 m\n\u22a2 \u21d1(ConcreteCategory.hom (S.transitionMapLE h)) \u2218 \u21d1(ConcreteCategory.hom (S.proj m)) =\n    \u21d1(ConcreteCategory.hom (CategoryStruct.comp (S.proj m) (S.diagram.map (Opposite.op (homOfLE h)))))"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem effectiveEpi_iff_surjective {X Y : LightProfinite.{u}} (f : X \u27f6 Y) :\n    EffectiveEpi f \u2194 Function.Surjective f := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 \u27e8\u27e8effectiveEpiStruct f h\u27e9\u27e9\u27e9\n  rw [\u2190 epi_iff_surjective]\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/LightProfinite/EffectiveEpi.lean", "context": {"open": ["CategoryTheory Limits CompHausLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : LightProfinite\nf : X \u27f6 Y\n\u22a2 EffectiveEpi f \u2194 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 \u27e8\u27e8effectiveEpiStruct f h\u27e9\u27e9\u27e9", "tactic_state": "X Y : LightProfinite\nf : X \u27f6 Y\nh : EffectiveEpi f\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "rw [\u2190 epi_iff_surjective]", "tactic_state": "X Y : LightProfinite\nf : X \u27f6 Y\nh : EffectiveEpi f\n\u22a2 Epi \u21d1(ConcreteCategory.hom f)"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ord_term {o : Ordinal} (ho : o < Ordinal.type ((\u00b7 < \u00b7) : I \u2192 I \u2192 Prop)) (i : I) :\n    ord I i = o \u2194 term I ho = i := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 subst h\n    exact term_ord_aux ho\n  \u00b7 subst h\n    exact ord_term_aux ho\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Profinite/Nobeling/Basic.lean", "context": {"open": ["CategoryTheory ContinuousMap Limits Opposite Submodule"], "variables": ["{I : Type u} (C : Set (I \u2192 Bool))", "(J K L : I \u2192 Prop) [\u2200 i, Decidable (J i)] [\u2200 i, Decidable (K i)] [\u2200 i, Decidable (L i)]", "{J K L}", "(J) in", "(J)", "{C}", "[LinearOrder I]", "[LinearOrder I] [WellFoundedLT I]", "(I)", "{I}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nx\u271d\u00b9 : Sort u_1\nord : x\u271d\u00b9\nx\u271d : Sort u_2\nterm : x\u271d\no : Ordinal.{u}\nho : o < Ordinal.type fun x1 x2 => x1 < x2\ni : I\n\u22a2 sorry = o \u2194 sorry = i"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nI : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nx\u271d\u00b9 : Sort u_1\nord : x\u271d\u00b9\nx\u271d : Sort u_2\nterm : x\u271d\no : Ordinal.{u}\nho : o < Ordinal.type fun x1 x2 => x1 < x2\ni : I\nh : sorry = o\n\u22a2 sorry = i\n---\ncase refine_2\nI : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nx\u271d\u00b9 : Sort u_1\nord : x\u271d\u00b9\nx\u271d : Sort u_2\nterm : x\u271d\no : Ordinal.{u}\nho : o < Ordinal.type fun x1 x2 => x1 < x2\ni : I\nh : sorry = i\n\u22a2 sorry = o"}, {"line": "\u00b7 subst h\n    exact term_ord_aux ho", "tactic_state": "case refine_2\nI : Type u\ninst\u271d\u00b2 inst\u271d\u00b9 : LinearOrder I\ninst\u271d : WellFoundedLT I\nx\u271d\u00b9 : Sort u_1\nord : x\u271d\u00b9\nx\u271d : Sort u_2\nterm : x\u271d\no : Ordinal.{u}\nho : o < Ordinal.type fun x1 x2 => x1 < x2\ni : I\nh : sorry = i\n\u22a2 sorry = o"}, {"line": "\u00b7 subst h\n    exact ord_term_aux ho", "tactic_state": "No Goals!"}]}
{"declaration": "theorem list_prod_apply {I} (C : Set (I \u2192 Bool)) (x : C) (l : List (LocallyConstant C \u2124)) :\n    l.prod x = (l.map (LocallyConstant.evalMonoidHom x)).prod := by\n  rw [\u2190 map_list_prod (LocallyConstant.evalMonoidHom x) l]\n  rw [LocallyConstant.evalMonoidHom_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Profinite/Nobeling/Span.lean", "context": {"open": ["scoped Classical in", "scoped Classical in"], "variables": ["{I : Type u} (C : Set (I \u2192 Bool)) [LinearOrder I]", "(s : Finset I)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : Type u_1\nC : Set (I \u2192 Bool)\nx : \u2191C\nl : List (LocallyConstant \u2191C \u2124)\n\u22a2 l.prod x = (List.map (\u21d1(LocallyConstant.evalMonoidHom x)) l).prod"}, {"line": "rw [\u2190 map_list_prod (LocallyConstant.evalMonoidHom x) l]", "tactic_state": "I : Type u_1\nC : Set (I \u2192 Bool)\nx : \u2191C\nl : List (LocallyConstant \u2191C \u2124)\n\u22a2 l.prod x = (LocallyConstant.evalMonoidHom x) l.prod"}, {"line": "rw [LocallyConstant.evalMonoidHom_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem succ_exact :\n    (ShortComplex.mk (ModuleCat.ofHom (\u03c0s C o)) (ModuleCat.ofHom (Linear_CC' C hsC ho))\n    (by ext : 2; apply CC_comp_zero)).Exact := by\n  rw [ShortComplex.moduleCat_exact_iff]\n  intro f\n  exact CC_exact C hC hsC ho\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Profinite/Nobeling/Successor.lean", "context": {"open": ["CategoryTheory", "scoped Classical in"], "variables": ["{I : Type u} (C : Set (I \u2192 Bool)) [LinearOrder I] [WellFoundedLT I]", "(o)", "{o}", "(o) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\n\u03c0s : x\u271d\u00b9\nx\u271d : Sort u_2\nLinear_CC' : x\u271d\n\u22a2 { X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n      f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.Exact"}, {"line": "rw [ShortComplex.moduleCat_exact_iff]", "tactic_state": "x\u271d\u00b9 : Sort u_1\n\u03c0s : x\u271d\u00b9\nx\u271d : Sort u_2\nLinear_CC' : x\u271d\n\u22a2 \u2200\n    (x\u2082 :\n      \u2191{ X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n            f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.X\u2082),\n    (ConcreteCategory.hom\n            { X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n                f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.g)\n          x\u2082 =\n        0 \u2192\n      \u2203 x\u2081,\n        (ConcreteCategory.hom\n              { X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n                  f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.f)\n            x\u2081 =\n          x\u2082"}, {"line": "intro f", "tactic_state": "x\u271d\u00b9 : Sort u_1\n\u03c0s : x\u271d\u00b9\nx\u271d : Sort u_2\nLinear_CC' : x\u271d\nf :\n  \u2191{ X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n        f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.X\u2082\n\u22a2 (ConcreteCategory.hom\n          { X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n              f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.g)\n        f =\n      0 \u2192\n    \u2203 x\u2081,\n      (ConcreteCategory.hom\n            { X\u2081 := ModuleCat.of sorry sorry, X\u2082 := ModuleCat.of sorry sorry, X\u2083 := ModuleCat.of sorry sorry,\n                f := ModuleCat.ofHom sorry, g := ModuleCat.ofHom sorry, zero := \u22ef }.f)\n          x\u2081 =\n        f"}, {"line": "exact CC_exact C hC hsC ho", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lift_lifts {X Y : CompHaus} {Z : Stonean} (e : Z.compHaus \u27f6 Y) (f : X \u27f6 Y) [Epi f] :\n    lift e f \u226b f = e := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Stonean/Basic.lean", "context": {"open": ["CategoryTheory", "scoped Topology", "CompHausLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nX Y : CompHaus\nZ : Stonean\ne : Z.compHaus \u27f6 Y\nf : X \u27f6 Y\ninst\u271d : Epi f\n\u22a2 CategoryStruct.comp sorry f = e"}, {"line": "simp [lift]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nX Y : CompHaus\nZ : Stonean\ne : Z.compHaus \u27f6 Y\nf : X \u27f6 Y\ninst\u271d : Epi f\n\u22a2 CategoryStruct.comp (sorry ()) f = e"}]}
{"declaration": "lemma lift_lifts {X Y : Profinite} {Z : Stonean} (e : Stonean.toProfinite.obj Z \u27f6 Y) (f : X \u27f6 Y)\n    [Epi f] : lift e f \u226b f = e := by simp [lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Stonean/Basic.lean", "context": {"open": ["CategoryTheory", "scoped Topology", "CompHausLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nX Y : Profinite\nZ : Stonean\ne : Stonean.toProfinite.obj Z \u27f6 Y\nf : X \u27f6 Y\ninst\u271d : Epi f\n\u22a2 CategoryStruct.comp sorry f = e"}, {"line": "simp [lift]", "tactic_state": "x\u271d : Sort u_1\nlift : x\u271d\nX Y : Profinite\nZ : Stonean\ne : Stonean.toProfinite.obj Z \u27f6 Y\nf : X \u27f6 Y\ninst\u271d : Epi f\n\u22a2 CategoryStruct.comp (sorry ()) f = e"}]}
{"declaration": "lemma projective_of_extrDisc {X : Profinite.{u}} (hX : ExtremallyDisconnected X) :\n    Projective X := by\n  show Projective (Stonean.toProfinite.obj \u27e8X.toTop, inferInstance\u27e9)\n  exact inferInstance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Stonean/Basic.lean", "context": {"open": ["CategoryTheory", "scoped Topology", "CompHausLike"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Profinite\nhX : ExtremallyDisconnected \u2191X.toTop\n\u22a2 Projective X"}, {"line": "show Projective (Stonean.toProfinite.obj \u27e8X.toTop, inferInstance\u27e9)", "tactic_state": "X : Profinite\nhX : ExtremallyDisconnected \u2191X.toTop\n\u22a2 Projective (Stonean.toProfinite.obj { toTop := X.toTop, is_compact := \u22ef, is_hausdorff := \u22ef, prop := \u22ef })"}, {"line": "exact inferInstance", "tactic_state": "No Goals!"}]}
{"declaration": "lemma extremallyDisconnected_preimage : ExtremallyDisconnected (i \u207b\u00b9' (Set.range f)) where\n  open_closure U hU := by\n    have h : IsClopen (i \u207b\u00b9' (Set.range f)) :=\n      \u27e8IsClosed.preimage i.hom.continuous (isCompact_range f.hom.continuous).isClosed,\n        IsOpen.preimage i.hom.continuous hi.isOpen_range\u27e9\n    rw [\u2190 (closure U).preimage_image_eq Subtype.coe_injective]\n    rw [\u2190 h.1.isClosedEmbedding_subtypeVal.closure_image_eq U]\n    exact isOpen_induced (ExtremallyDisconnected.open_closure _\n      (h.2.isOpenEmbedding_subtypeVal.isOpenMap U hU))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/Stonean/Limits.lean", "context": {"open": ["CategoryTheory Limits CompHausLike Topology"], "variables": ["{X Y Z : Stonean} {f : X \u27f6 Z} (i : Y \u27f6 Z) (hi : IsOpenEmbedding f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : Stonean\nf : X \u27f6 Z\ni : Y \u27f6 Z\nU : Set \u2191(\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\nhU : IsOpen U\n\u22a2 IsOpen (closure U)"}, {"line": "have h : IsClopen (i \u207b\u00b9' (Set.range f)) :=\n      \u27e8IsClosed.preimage i.hom.continuous (isCompact_range f.hom.continuous).isClosed,\n        IsOpen.preimage i.hom.continuous hi.isOpen_range\u27e9", "tactic_state": "X Y Z : Stonean\nf : X \u27f6 Z\ni : Y \u27f6 Z\nU : Set \u2191(\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\nhU : IsOpen U\nh : IsClopen (\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\n\u22a2 IsOpen (closure U)"}, {"line": "rw [\u2190 (closure U).preimage_image_eq Subtype.coe_injective]", "tactic_state": "X Y Z : Stonean\nf : X \u27f6 Z\ni : Y \u27f6 Z\nU : Set \u2191(\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\nhU : IsOpen U\nh : IsClopen (\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\n\u22a2 IsOpen ((fun a => \u2191a) \u207b\u00b9' ((fun a => \u2191a) '' closure U))"}, {"line": "rw [\u2190 h.1.isClosedEmbedding_subtypeVal.closure_image_eq U]", "tactic_state": "X Y Z : Stonean\nf : X \u27f6 Z\ni : Y \u27f6 Z\nU : Set \u2191(\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\nhU : IsOpen U\nh : IsClopen (\u21d1(ConcreteCategory.hom i) \u207b\u00b9' Set.range \u21d1(ConcreteCategory.hom f))\n\u22a2 IsOpen ((fun a => \u2191a) \u207b\u00b9' closure (Subtype.val '' U))"}, {"line": "exact isOpen_induced (ExtremallyDisconnected.open_closure _\n      (h.2.isOpenEmbedding_subtypeVal.isOpenMap U hU))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem epi_iff_surjective {X Y : TopCat.{u}} (f : X \u27f6 Y) : Epi f \u2194 Function.Surjective f := by\n  suffices Epi f \u2194 Epi ((forget TopCat).map f) by\n    rw [this]\n    rw [CategoryTheory.epi_iff_surjective]\n    rfl\n  constructor\n  \u00b7 intro\n    infer_instance\n  \u00b7 apply Functor.epi_of_epi_map\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/EpiMono.lean", "context": {"open": ["CategoryTheory", "TopCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\n\u22a2 Epi f \u2194 Function.Surjective \u21d1(ConcreteCategory.hom f)"}, {"line": "suffices Epi f \u2194 Epi ((forget TopCat).map f) by\n    rw [this]\n    rw [CategoryTheory.epi_iff_surjective]\n    rfl", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\n\u22a2 Epi f \u2194 Epi ((forget TopCat).map f)"}, {"line": "constructor", "tactic_state": "case mp\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Epi f \u2192 Epi ((forget TopCat).map f)\n---\ncase mpr\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Epi ((forget TopCat).map f) \u2192 Epi f"}, {"line": "\u00b7 intro\n    infer_instance", "tactic_state": "case mpr\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Epi ((forget TopCat).map f) \u2192 Epi f"}, {"line": "\u00b7 apply Functor.epi_of_epi_map", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mono_iff_injective {X Y : TopCat.{u}} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f := by\n  suffices Mono f \u2194 Mono ((forget TopCat).map f) by\n    rw [this]\n    rw [CategoryTheory.mono_iff_injective]\n    rfl\n  constructor\n  \u00b7 intro\n    infer_instance\n  \u00b7 apply Functor.mono_of_mono_map\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/EpiMono.lean", "context": {"open": ["CategoryTheory", "TopCat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\n\u22a2 Mono f \u2194 Function.Injective \u21d1(ConcreteCategory.hom f)"}, {"line": "suffices Mono f \u2194 Mono ((forget TopCat).map f) by\n    rw [this]\n    rw [CategoryTheory.mono_iff_injective]\n    rfl", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\n\u22a2 Mono f \u2194 Mono ((forget TopCat).map f)"}, {"line": "constructor", "tactic_state": "case mp\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Mono f \u2192 Mono ((forget TopCat).map f)\n---\ncase mpr\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Mono ((forget TopCat).map f) \u2192 Mono f"}, {"line": "\u00b7 intro\n    infer_instance", "tactic_state": "case mpr\nX Y : TopCat\nf : X \u27f6 Y\n\u22a2 Mono ((forget TopCat).map f) \u2192 Mono f"}, {"line": "\u00b7 apply Functor.mono_of_mono_map", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_id_obj_unop (U : (Opens X)\u1d52\u1d56) : (map (\ud835\udfd9 X)).obj (unop U) = unop U := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 sorry = unop U"}, {"line": "simp", "tactic_state": "X : TopCat\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 sorry () = unop U"}]}
{"declaration": "theorem op_map_id_obj (U : (Opens X)\u1d52\u1d56) : (map (\ud835\udfd9 X)).op.obj U = U := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 sorry = U"}, {"line": "simp", "tactic_state": "X : TopCat\nU : (Opens \u2191X)\u1d52\u1d56\n\u22a2 sorry () = U"}]}
{"declaration": "theorem map_eq (f g : X \u27f6 Y) (h : f = g) : map f = map g := by\n  subst h\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf g : X \u27f6 Y\nh : f = g\n\u22a2 sorry = sorry"}, {"line": "subst h", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\n\u22a2 sorry = sorry"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mem_functorObj_iff {X Y : TopCat} {f : X \u27f6 Y} (hf : IsInducing f) (U : Opens X)\n    {x : X} : f x \u2208 hf.functorObj U \u2194 x \u2208 U := by\n  conv_rhs => rw [\u2190 hf.map_functorObj U]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nhf : IsInducing \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191X\nx : \u2191X\n\u22a2 (ConcreteCategory.hom f) x \u2208 hf.functorObj U \u2194 x \u2208 U"}, {"line": "conv_rhs => rw [\u2190 hf.map_functorObj U]", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nhf : IsInducing \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191X\nx : \u2191X\n\u22a2 (ConcreteCategory.hom f) x \u2208 hf.functorObj U \u2194 x \u2208 (Opens.map f).obj (hf.functorObj U)"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenEmbedding_obj_top {X : TopCat} (U : Opens X) :\n    U.isOpenEmbedding.isOpenMap.functor.obj \u22a4 = U := by\n  ext1\n  exact Set.image_univ.trans Subtype.range_coe\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology", "TopologicalSpace"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nU : Opens \u2191X\n\u22a2 \u22ef.functor.obj \u22a4 = U"}, {"line": "ext1", "tactic_state": "case h\nX : TopCat\nU : Opens \u2191X\n\u22a2 \u2191(\u22ef.functor.obj \u22a4) = \u2191U"}, {"line": "exact Set.image_univ.trans Subtype.range_coe", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inclusion'_map_eq_top {X : TopCat} (U : Opens X) : (Opens.map U.inclusion').obj U = \u22a4 := by\n  ext1\n  exact Subtype.coe_preimage_self _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology", "TopologicalSpace"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nU : Opens \u2191X\n\u22a2 (Opens.map U.inclusion').obj U = \u22a4"}, {"line": "ext1", "tactic_state": "case h\nX : TopCat\nU : Opens \u2191X\n\u22a2 \u2191((Opens.map U.inclusion').obj U) = \u2191\u22a4"}, {"line": "exact Subtype.coe_preimage_self _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem functor_obj_map_obj {X Y : TopCat} {f : X \u27f6 Y} (hf : IsOpenMap f) (U : Opens Y) :\n    hf.functor.obj ((Opens.map f).obj U) = hf.functor.obj \u22a4 \u2293 U := by\n  ext\n  constructor\n  \u00b7 rintro \u27e8x, hx, rfl\u27e9\n    exact \u27e8\u27e8x, trivial, rfl\u27e9, hx\u27e9\n  \u00b7 rintro \u27e8\u27e8x, -, rfl\u27e9, hx\u27e9\n    exact \u27e8x, hx, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology", "TopologicalSpace"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenMap \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191Y\n\u22a2 hf.functor.obj ((Opens.map f).obj U) = hf.functor.obj \u22a4 \u2293 U"}, {"line": "ext", "tactic_state": "case h.h\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenMap \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191Y\nx\u271d : \u2191Y\n\u22a2 x\u271d \u2208 \u2191(hf.functor.obj ((Opens.map f).obj U)) \u2194 x\u271d \u2208 \u2191(hf.functor.obj \u22a4 \u2293 U)"}, {"line": "constructor", "tactic_state": "case h.h.mp\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenMap \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191Y\nx\u271d : \u2191Y\n\u22a2 x\u271d \u2208 \u2191(hf.functor.obj ((Opens.map f).obj U)) \u2192 x\u271d \u2208 \u2191(hf.functor.obj \u22a4 \u2293 U)\n---\ncase h.h.mpr\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenMap \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191Y\nx\u271d : \u2191Y\n\u22a2 x\u271d \u2208 \u2191(hf.functor.obj \u22a4 \u2293 U) \u2192 x\u271d \u2208 \u2191(hf.functor.obj ((Opens.map f).obj U))"}, {"line": "\u00b7 rintro \u27e8x, hx, rfl\u27e9\n    exact \u27e8\u27e8x, trivial, rfl\u27e9, hx\u27e9", "tactic_state": "case h.h.mpr\nX Y : TopCat\nf : X \u27f6 Y\nhf : IsOpenMap \u21d1(ConcreteCategory.hom f)\nU : Opens \u2191Y\nx\u271d : \u2191Y\n\u22a2 x\u271d \u2208 \u2191(hf.functor.obj \u22a4 \u2293 U) \u2192 x\u271d \u2208 \u2191(hf.functor.obj ((Opens.map f).obj U))"}, {"line": "\u00b7 rintro \u27e8\u27e8x, -, rfl\u27e9, hx\u27e9\n    exact \u27e8x, hx, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem adjunction_counit_map_functor {X : TopCat} {U : Opens X} (V : Opens U) :\n    U.isOpenEmbedding.isOpenMap.adjunction.counit.app (U.isOpenEmbedding.isOpenMap.functor.obj V) =\n      eqToHom (by dsimp; rw [map_functor_eq V]) := by\n  subsingleton\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Opens.lean", "context": {"open": ["CategoryTheory TopologicalSpace Opposite Topology", "TopologicalSpace"], "variables": ["{X Y Z : TopCat.{u}} {U V W : Opens X}", "(X)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : TopCat\nU : Opens \u2191X\nV : Opens \u21a5U\n\u22a2 \u22ef.adjunction.counit.app (\u22ef.functor.obj V) = eqToHom \u22ef"}, {"line": "subsingleton", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_id_apply {X Y : TopCat} (f : X \u2245 Y) (y : Y) : f.hom (f.inv y) = y := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Basic.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology"], "variables": ["{X} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf : X \u2245 Y\ny : \u2191Y\n\u22a2 (ConcreteCategory.hom f.hom) ((ConcreteCategory.hom f.inv) y) = y"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenEmbedding_iff_comp_isIso' {X Y Z : TopCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso g] :\n    IsOpenEmbedding (g \u2218 f) \u2194 IsOpenEmbedding f := by\n  simp only [\u2190 Functor.map_comp]\n  exact isOpenEmbedding_iff_comp_isIso f g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Basic.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology"], "variables": ["{X} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso g\n\u22a2 IsOpenEmbedding (\u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)) \u2194 IsOpenEmbedding \u21d1(ConcreteCategory.hom f)"}, {"line": "simp only [\u2190 Functor.map_comp]", "tactic_state": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso g\n\u22a2 IsOpenEmbedding (\u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)) \u2194 IsOpenEmbedding \u21d1(ConcreteCategory.hom f)"}, {"line": "exact isOpenEmbedding_iff_comp_isIso f g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenEmbedding_iff_isIso_comp {X Y Z : TopCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] :\n    IsOpenEmbedding (f \u226b g) \u2194 IsOpenEmbedding g := by\n  constructor\n  \u00b7 intro h\n    convert h.comp (TopCat.homeoOfIso (asIso f).symm).isOpenEmbedding\n    exact congr_arg (DFunLike.coe \u2218 ConcreteCategory.hom) (IsIso.inv_hom_id_assoc f g).symm\n  \u00b7 exact fun h => h.comp (TopCat.homeoOfIso (asIso f)).isOpenEmbedding\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Basic.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology"], "variables": ["{X} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding \u21d1(ConcreteCategory.hom (CategoryStruct.comp f g)) \u2194 IsOpenEmbedding \u21d1(ConcreteCategory.hom g)"}, {"line": "constructor", "tactic_state": "case mp\nX Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding \u21d1(ConcreteCategory.hom (CategoryStruct.comp f g)) \u2192 IsOpenEmbedding \u21d1(ConcreteCategory.hom g)\n---\ncase mpr\nX Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding \u21d1(ConcreteCategory.hom g) \u2192 IsOpenEmbedding \u21d1(ConcreteCategory.hom (CategoryStruct.comp f g))"}, {"line": "\u00b7 intro h\n    convert h.comp (TopCat.homeoOfIso (asIso f).symm).isOpenEmbedding\n    exact congr_arg (DFunLike.coe \u2218 ConcreteCategory.hom) (IsIso.inv_hom_id_assoc f g).symm", "tactic_state": "case mpr\nX Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding \u21d1(ConcreteCategory.hom g) \u2192 IsOpenEmbedding \u21d1(ConcreteCategory.hom (CategoryStruct.comp f g))"}, {"line": "\u00b7 exact fun h => h.comp (TopCat.homeoOfIso (asIso f)).isOpenEmbedding", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenEmbedding_iff_isIso_comp' {X Y Z : TopCat} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] :\n    IsOpenEmbedding (g \u2218 f) \u2194 IsOpenEmbedding g := by\n  simp only [\u2190 Functor.map_comp]\n  exact isOpenEmbedding_iff_isIso_comp f g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Basic.lean", "context": {"open": ["CategoryTheory TopologicalSpace Topology"], "variables": ["{X} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding (\u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)) \u2194 IsOpenEmbedding \u21d1(ConcreteCategory.hom g)"}, {"line": "simp only [\u2190 Functor.map_comp]", "tactic_state": "X Y Z : TopCat\nf : X \u27f6 Y\ng : Y \u27f6 Z\ninst\u271d : IsIso f\n\u22a2 IsOpenEmbedding (\u21d1(ConcreteCategory.hom g) \u2218 \u21d1(ConcreteCategory.hom f)) \u2194 IsOpenEmbedding \u21d1(ConcreteCategory.hom g)"}, {"line": "exact isOpenEmbedding_iff_isIso_comp f g", "tactic_state": "No Goals!"}]}
{"declaration": "theorem colimit_isOpen_iff (F : J \u2964 TopCat.{u}) [HasColimit F]\n    (U : Set ((colimit F : _) : Type u)) :\n    IsOpen U \u2194 \u2200 j, IsOpen (colimit.\u03b9 F j \u207b\u00b9' U) := by\n  apply isOpen_iff_of_isColimit _ (colimit.isColimit _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Basic.lean", "context": {"open": ["TopologicalSpace CategoryTheory CategoryTheory.Limits Opposite"], "variables": ["{J : Type v} [Category.{w} J]", "{F : J \u2964 TopCat.{u}} (c : Cone (F \u22d9 forget))", "{F : J \u2964 TopCat.{u}} (c : Cone F) (hc : IsLimit c)", "(F : J \u2964 TopCat.{u})", "{J : Type v} [Category.{w} J] {F : J \u2964 TopCat.{u}}", "(c : Cocone (F \u22d9 forget))", "(c : Cocone F) (hc : IsColimit c)", "(F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "J : Type v\ninst\u271d\u00b9 : Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\ninst\u271d : HasColimit F\nU : Set \u2191(colimit F)\n\u22a2 IsOpen U \u2194 \u2200 (j : J), IsOpen (\u21d1(ConcreteCategory.hom (colimit.\u03b9 F j)) \u207b\u00b9' U)"}, {"line": "apply isOpen_iff_of_isColimit _ (colimit.isColimit _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem piIsoPi_inv_\u03c0 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCat.{max v u}) (i : \u03b9) :\n    (piIsoPi \u03b1).inv \u226b Pi.\u03c0 \u03b1 i = pi\u03c0 \u03b1 i := by simp [piIsoPi]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\npiIsoPi : x\u271d\u00b9\nx\u271d : Sort u_2\npi\u03c0 : x\u271d\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\n\u22a2 CategoryStruct.comp sorry (Pi.\u03c0 \u03b1 i) = sorry"}, {"line": "simp [piIsoPi]", "tactic_state": "x\u271d\u00b9 : Sort u_1\npiIsoPi : x\u271d\u00b9\nx\u271d : Sort u_2\npi\u03c0 : x\u271d\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\n\u22a2 CategoryStruct.comp (sorry ()) (Pi.\u03c0 \u03b1 i) = sorry ()"}]}
{"declaration": "theorem sigmaIsoSigma_hom_\u03b9 {\u03b9 : Type v} (\u03b1 : \u03b9 \u2192 TopCat.{max v u}) (i : \u03b9) :\n    Sigma.\u03b9 \u03b1 i \u226b (sigmaIsoSigma \u03b1).hom = sigma\u03b9 \u03b1 i := by simp [sigmaIsoSigma]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nsigmaIsoSigma : x\u271d\u00b9\nx\u271d : Sort u_2\nsigma\u03b9 : x\u271d\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\n\u22a2 CategoryStruct.comp (Sigma.\u03b9 \u03b1 i) sorry = sorry"}, {"line": "simp [sigmaIsoSigma]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nsigmaIsoSigma : x\u271d\u00b9\nx\u271d : Sort u_2\nsigma\u03b9 : x\u271d\n\u03b9 : Type v\n\u03b1 : \u03b9 \u2192 TopCat\ni : \u03b9\n\u22a2 CategoryStruct.comp (Sigma.\u03b9 \u03b1 i) (sorry ()) = sorry ()"}]}
{"declaration": "theorem prodIsoProd_hom_apply {X Y : TopCat.{u}} (x : \u2191(X \u2a2f Y)) :\n    (prodIsoProd X Y).hom x = ((Limits.prod.fst : X \u2a2f Y \u27f6 _) x,\n    (Limits.prod.snd : X \u2a2f Y \u27f6 _) x) := by\n  ext\n  \u00b7 exact ConcreteCategory.congr_hom (prodIsoProd_hom_fst X Y) x\n  \u00b7 exact ConcreteCategory.congr_hom (prodIsoProd_hom_snd X Y) x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nprodIsoProd : x\u271d\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 sorry = ((ConcreteCategory.hom prod.fst) x, (ConcreteCategory.hom prod.snd) x)"}, {"line": "ext", "tactic_state": "case fst\nx\u271d : Sort u_1\nprodIsoProd : x\u271d\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 sorry.1 = ((ConcreteCategory.hom prod.fst) x, (ConcreteCategory.hom prod.snd) x).1\n---\ncase snd\nx\u271d : Sort u_1\nprodIsoProd : x\u271d\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 sorry.2 = ((ConcreteCategory.hom prod.fst) x, (ConcreteCategory.hom prod.snd) x).2"}, {"line": "\u00b7 exact ConcreteCategory.congr_hom (prodIsoProd_hom_fst X Y) x", "tactic_state": "case snd\nx\u271d : Sort u_1\nprodIsoProd : x\u271d\nX Y : TopCat\nx : \u2191(X \u2a2f Y)\n\u22a2 sorry.2 = ((ConcreteCategory.hom prod.fst) x, (ConcreteCategory.hom prod.snd) x).2"}, {"line": "\u00b7 exact ConcreteCategory.congr_hom (prodIsoProd_hom_snd X Y) x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv \u226b Limits.prod.fst = prodFst := by simp [Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nprodIsoProd : x\u271d\nobj\u271d : Type u_2\nself\u271d : Category.{u_3, u_2} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nprodFst : a\u271d\u00b9 \u27f6 a\u271d\nX Y : TopCat\n\u22a2 CategoryStruct.comp sorry prod.fst = prodFst"}, {"line": "simp [Iso.inv_comp_eq]", "tactic_state": "x\u271d : Sort u_1\nprodIsoProd : x\u271d\nobj\u271d : Type u_2\nself\u271d : Category.{u_3, u_2} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nprodFst : a\u271d\u00b9 \u27f6 a\u271d\nX Y : TopCat\n\u22a2 CategoryStruct.comp (sorry ()) prod.fst = prodFst"}]}
{"declaration": "theorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv \u226b Limits.prod.snd = prodSnd := by simp [Iso.inv_comp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nprodIsoProd : x\u271d\nobj\u271d : Type u_2\nself\u271d : Category.{u_3, u_2} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nprodSnd : a\u271d\u00b9 \u27f6 a\u271d\nX Y : TopCat\n\u22a2 CategoryStruct.comp sorry prod.snd = prodSnd"}, {"line": "simp [Iso.inv_comp_eq]", "tactic_state": "x\u271d : Sort u_1\nprodIsoProd : x\u271d\nobj\u271d : Type u_2\nself\u271d : Category.{u_3, u_2} obj\u271d\na\u271d\u00b9 a\u271d : obj\u271d\nprodSnd : a\u271d\u00b9 \u27f6 a\u271d\nX Y : TopCat\n\u22a2 CategoryStruct.comp (sorry ()) prod.snd = prodSnd"}]}
{"declaration": "theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) \u2194\n      IsOpenEmbedding c.inl \u2227 IsOpenEmbedding c.inr \u2227 IsCompl (range c.inl) (range c.inr) := by\n  classical\n    constructor\n    \u00b7 rintro \u27e8h\u27e9\n      rw [\u2190 show _ = c.inl from           h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) \u27e8WalkingPair.left\u27e9]\n      rw [\u2190 show _ = c.inr from           h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) \u27e8WalkingPair.right\u27e9]\n      dsimp\n      refine \u27e8(homeoOfIso <| h.coconePointUniqueUpToIso\n        (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inl,\n          (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inr, ?_\u27e9\n      rw [Set.range_comp]\n      rw [\u2190 eq_compl_iff_isCompl]\n      conv_rhs => rw [Set.range_comp]\n      erw [\u2190 Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]\n    \u00b7 rintro \u27e8h\u2081, h\u2082, h\u2083\u27e9\n      have : \u2200 x, x \u2208 Set.range c.inl \u2228 x \u2208 Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h\u2083.symm]\n        exact fun _ => or_not\n      refine \u27e8BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_\u27e9\n      \u00b7 intro T f g\n        refine ofHom (ContinuousMap.mk ?_ ?_)\n        \u00b7 exact fun x =>\n            if h : x \u2208 Set.range c.inl then f ((Equiv.ofInjective _ h\u2081.injective).symm \u27e8x, h\u27e9)\n            else g ((Equiv.ofInjective _ h\u2082.injective).symm \u27e8x, (this x).resolve_left h\u27e9)\n        rw [continuous_iff_continuousAt]\n        intro x\n        by_cases h : x \u2208 Set.range c.inl\n        \u00b7 revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          \u00b7 rw [continuousOn_iff_continuous_restrict]\n            convert_to Continuous (f \u2218 h\u2081.isEmbedding.toHomeomorph.symm)\n            \u00b7 ext \u27e8x, hx\u27e9\n              exact dif_pos hx\n            continuity\n          \u00b7 exact h\u2081.isOpen_range\n        \u00b7 revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          \u00b7 rw [continuousOn_iff_continuous_restrict]\n            have : \u2200 a, a \u2209 Set.range c.inl \u2192 a \u2208 Set.range c.inr := by\n              rintro a (h : a \u2208 (Set.range c.inl)\u1d9c)\n              rwa [eq_compl_iff_isCompl.mpr h\u2083.symm]\n            convert_to Continuous\n                (g \u2218 h\u2082.isEmbedding.toHomeomorph.symm \u2218 Subtype.map _ this)\n            \u00b7 ext \u27e8x, hx\u27e9\n              exact dif_neg hx\n            apply Continuous.comp\n            \u00b7 exact g.hom.continuous_toFun\n            \u00b7 apply Continuous.comp\n              \u00b7 continuity\n              \u00b7 rw [IsEmbedding.subtypeVal.isInducing.continuous_iff]\n                exact continuous_subtype_val\n          \u00b7 change IsOpen (Set.range c.inl)\u1d9c\n            rw [\u2190 eq_compl_iff_isCompl.mpr h\u2083.symm]\n            exact h\u2082.isOpen_range\n      \u00b7 intro T f g\n        ext x\n        dsimp\n        rw [dif_pos]\n        conv_lhs => rw [Equiv.ofInjective_symm_apply]\n      \u00b7 intro T f g\n        ext x\n        dsimp\n        rw [dif_neg]\n        \u00b7 exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n        \u00b7 rintro \u27e8y, e\u27e9\n          have : c.inr x \u2208 Set.range c.inl \u2293 Set.range c.inr := \u27e8\u27e8_, e\u27e9, \u27e8_, rfl\u27e9\u27e9\n          rwa [disjoint_iff.mp h\u2083.1] at this\n      \u00b7 rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ \u27e8_, _\u27e9).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Products.lean", "context": {"open": ["CategoryTheory Limits Set TopologicalSpace Topology"], "variables": ["{J : Type v} [Category.{w} J]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nc : BinaryCofan X Y\n\u22a2 Nonempty (IsColimit c) \u2194\n    IsOpenEmbedding \u21d1(ConcreteCategory.hom c.inl) \u2227\n      IsOpenEmbedding \u21d1(ConcreteCategory.hom c.inr) \u2227\n        IsCompl (range \u21d1(ConcreteCategory.hom c.inl)) (range \u21d1(ConcreteCategory.hom c.inr))"}, {"line": "classical\n    constructor\n    \u00b7 rintro \u27e8h\u27e9\n      rw [\u2190 show _ = c.inl from           h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) \u27e8WalkingPair.left\u27e9]\n      rw [\u2190 show _ = c.inr from           h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) \u27e8WalkingPair.right\u27e9]\n      dsimp\n      refine \u27e8(homeoOfIso <| h.coconePointUniqueUpToIso\n        (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inl,\n          (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inr, ?_\u27e9\n      rw [Set.range_comp]\n      rw [\u2190 eq_compl_iff_isCompl]\n      conv_rhs => rw [Set.range_comp]\n      erw [\u2190 Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]\n    \u00b7 rintro \u27e8h\u2081, h\u2082, h\u2083\u27e9\n      have : \u2200 x, x \u2208 Set.range c.inl \u2228 x \u2208 Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h\u2083.symm]\n        exact fun _ => or_not\n      refine \u27e8BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_\u27e9\n      \u00b7 intro T f g\n        refine ofHom (ContinuousMap.mk ?_ ?_)\n        \u00b7 exact fun x =>\n            if h : x \u2208 Set.range c.inl then f ((Equiv.ofInjective _ h\u2081.injective).symm \u27e8x, h\u27e9)\n            else g ((Equiv.ofInjective _ h\u2082.injective).symm \u27e8x, (this x).resolve_left h\u27e9)\n        rw [continuous_iff_continuousAt]\n        intro x\n        by_cases h : x \u2208 Set.range c.inl\n        \u00b7 revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          \u00b7 rw [continuousOn_iff_continuous_restrict]\n            convert_to Continuous (f \u2218 h\u2081.isEmbedding.toHomeomorph.symm)\n            \u00b7 ext \u27e8x, hx\u27e9\n              exact dif_pos hx\n            continuity\n          \u00b7 exact h\u2081.isOpen_range\n        \u00b7 revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          \u00b7 rw [continuousOn_iff_continuous_restrict]\n            have : \u2200 a, a \u2209 Set.range c.inl \u2192 a \u2208 Set.range c.inr := by\n              rintro a (h : a \u2208 (Set.range c.inl)\u1d9c)\n              rwa [eq_compl_iff_isCompl.mpr h\u2083.symm]\n            convert_to Continuous\n                (g \u2218 h\u2082.isEmbedding.toHomeomorph.symm \u2218 Subtype.map _ this)\n            \u00b7 ext \u27e8x, hx\u27e9\n              exact dif_neg hx\n            apply Continuous.comp\n            \u00b7 exact g.hom.continuous_toFun\n            \u00b7 apply Continuous.comp\n              \u00b7 continuity\n              \u00b7 rw [IsEmbedding.subtypeVal.isInducing.continuous_iff]\n                exact continuous_subtype_val\n          \u00b7 change IsOpen (Set.range c.inl)\u1d9c\n            rw [\u2190 eq_compl_iff_isCompl.mpr h\u2083.symm]\n            exact h\u2082.isOpen_range\n      \u00b7 intro T f g\n        ext x\n        dsimp\n        rw [dif_pos]\n        conv_lhs => rw [Equiv.ofInjective_symm_apply]\n      \u00b7 intro T f g\n        ext x\n        dsimp\n        rw [dif_neg]\n        \u00b7 exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n        \u00b7 rintro \u27e8y, e\u27e9\n          have : c.inr x \u2208 Set.range c.inl \u2293 Set.range c.inr := \u27e8\u27e8_, e\u27e9, \u27e8_, rfl\u27e9\u27e9\n          rwa [disjoint_iff.mp h\u2083.1] at this\n      \u00b7 rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ \u27e8_, _\u27e9).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pullbackIsoProdSubtype_inv_fst (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (pullbackIsoProdSubtype f g).inv \u226b pullback.fst _ _ = pullbackFst f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "context": {"open": ["TopologicalSpace Topology", "CategoryTheory", "CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "{X Y Z : TopCat.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : TopCat\nx\u271d\u00b9 : Sort u_1\npullbackIsoProdSubtype : x\u271d\u00b9\nx\u271d : Sort u_2\npullbackFst : x\u271d\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 CategoryStruct.comp sorry (pullback.fst (?m.16083 f g) (?m.16084 f g)) = sorry"}, {"line": "simp [pullbackCone, pullbackIsoProdSubtype]", "tactic_state": "X Y Z : TopCat\nx\u271d\u00b9 : Sort u_1\npullbackIsoProdSubtype : x\u271d\u00b9\nx\u271d : Sort u_2\npullbackFst : x\u271d\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 CategoryStruct.comp (sorry ()) (pullback.fst (?m.16083 f g) (?m.16084 f g)) = sorry ()"}]}
{"declaration": "theorem pullbackIsoProdSubtype_inv_snd (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (pullbackIsoProdSubtype f g).inv \u226b pullback.snd _ _ = pullbackSnd f g := by\n  simp [pullbackCone, pullbackIsoProdSubtype]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "context": {"open": ["TopologicalSpace Topology", "CategoryTheory", "CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "{X Y Z : TopCat.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y Z : TopCat\nx\u271d\u00b9 : Sort u_1\npullbackIsoProdSubtype : x\u271d\u00b9\nx\u271d : Sort u_2\npullbackSnd : x\u271d\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 CategoryStruct.comp sorry (pullback.snd (?m.16083 f g) (?m.16084 f g)) = sorry"}, {"line": "simp [pullbackCone, pullbackIsoProdSubtype]", "tactic_state": "X Y Z : TopCat\nx\u271d\u00b9 : Sort u_1\npullbackIsoProdSubtype : x\u271d\u00b9\nx\u271d : Sort u_2\npullbackSnd : x\u271d\nf : X \u27f6 Z\ng : Y \u27f6 Z\n\u22a2 CategoryStruct.comp (sorry ()) (pullback.snd (?m.16083 f g) (?m.16084 f g)) = sorry ()"}]}
{"declaration": "theorem fst_iso_of_right_embedding_range_subset {X Y S : TopCat} (f : X \u27f6 S) {g : Y \u27f6 S}\n    (hg : IsEmbedding g) (H : Set.range f \u2286 Set.range g) :\n    IsIso (pullback.fst f g) := by\n  let esto : (pullback f g : TopCat) \u2243\u209c X :=\n    (fst_isEmbedding_of_right f hg).toHomeomorph.trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          \u27e8x, by\n            rw [pullback_fst_range]\n            exact \u27e8_, (H (Set.mem_range_self x)).choose_spec.symm\u27e9\u27e9\n        left_inv := fun \u27e8_, _\u27e9 => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "context": {"open": ["TopologicalSpace Topology", "CategoryTheory", "CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "{X Y Z : TopCat.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y S : TopCat\nf : X \u27f6 S\ng : Y \u27f6 S\nhg : IsEmbedding \u21d1(ConcreteCategory.hom g)\nH : Set.range \u21d1(ConcreteCategory.hom f) \u2286 Set.range \u21d1(ConcreteCategory.hom g)\n\u22a2 IsIso (pullback.fst f g)"}, {"line": "let esto : (pullback f g : TopCat) \u2243\u209c X :=\n    (fst_isEmbedding_of_right f hg).toHomeomorph.trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          \u27e8x, by\n            rw [pullback_fst_range]\n            exact \u27e8_, (H (Set.mem_range_self x)).choose_spec.symm\u27e9\u27e9\n        left_inv := fun \u27e8_, _\u27e9 => rfl\n        right_inv := fun x => rfl }", "tactic_state": "X Y S : TopCat\nf : X \u27f6 S\ng : Y \u27f6 S\nhg : IsEmbedding \u21d1(ConcreteCategory.hom g)\nH : Set.range \u21d1(ConcreteCategory.hom f) \u2286 Set.range \u21d1(ConcreteCategory.hom g)\nesto : \u2191(pullback f g) \u2243\u209c \u2191X := sorry\n\u22a2 IsIso (pullback.fst f g)"}, {"line": "convert (isoOfHomeo esto).isIso_hom", "tactic_state": "No Goals!"}]}
{"declaration": "theorem snd_iso_of_left_embedding_range_subset {X Y S : TopCat} {f : X \u27f6 S} (hf : IsEmbedding f)\n    (g : Y \u27f6 S) (H : Set.range g \u2286 Set.range f) : IsIso (pullback.snd f g) := by\n  let esto : (pullback f g : TopCat) \u2243\u209c Y :=\n    (snd_isEmbedding_of_left hf g).toHomeomorph.trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          \u27e8x, by\n            rw [pullback_snd_range]\n            exact \u27e8_, (H (Set.mem_range_self x)).choose_spec\u27e9\u27e9\n        left_inv := fun \u27e8_, _\u27e9 => rfl\n        right_inv := fun x => rfl }\n  convert (isoOfHomeo esto).isIso_hom\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "context": {"open": ["TopologicalSpace Topology", "CategoryTheory", "CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "{X Y Z : TopCat.{u}}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y S : TopCat\nf : X \u27f6 S\nhf : IsEmbedding \u21d1(ConcreteCategory.hom f)\ng : Y \u27f6 S\nH : Set.range \u21d1(ConcreteCategory.hom g) \u2286 Set.range \u21d1(ConcreteCategory.hom f)\n\u22a2 IsIso (pullback.snd f g)"}, {"line": "let esto : (pullback f g : TopCat) \u2243\u209c Y :=\n    (snd_isEmbedding_of_left hf g).toHomeomorph.trans\n      { toFun := Subtype.val\n        invFun := fun x =>\n          \u27e8x, by\n            rw [pullback_snd_range]\n            exact \u27e8_, (H (Set.mem_range_self x)).choose_spec\u27e9\u27e9\n        left_inv := fun \u27e8_, _\u27e9 => rfl\n        right_inv := fun x => rfl }", "tactic_state": "X Y S : TopCat\nf : X \u27f6 S\nhf : IsEmbedding \u21d1(ConcreteCategory.hom f)\ng : Y \u27f6 S\nH : Set.range \u21d1(ConcreteCategory.hom g) \u2286 Set.range \u21d1(ConcreteCategory.hom f)\nesto : \u2191(pullback f g) \u2243\u209c \u2191Y := sorry\n\u22a2 IsIso (pullback.snd f g)"}, {"line": "convert (isoOfHomeo esto).isIso_hom", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isQuotientMap_of_isColimit_cofork (c : Cofork f g) (hc : IsColimit c) :\n    IsQuotientMap c.\u03c0 := by\n  rw [isQuotientMap_iff]\n  constructor\n  \u00b7 simpa only [\u2190 epi_iff_surjective] using epi_of_isColimit_cofork hc\n  \u00b7 exact isOpen_iff_of_isColimit_cofork c hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Category/TopCat/Limits/Pullbacks.lean", "context": {"open": ["TopologicalSpace Topology", "CategoryTheory", "CategoryTheory.Limits"], "variables": ["{J : Type v} [Category.{w} J]", "{X Y Z : TopCat.{u}}", "{X Y : TopCat.{u}} {f g : X \u27f6 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X Y : TopCat\nf g : X \u27f6 Y\nc : Cofork f g\nhc : IsColimit c\n\u22a2 IsQuotientMap \u21d1(ConcreteCategory.hom c.\u03c0)"}, {"line": "rw [isQuotientMap_iff]", "tactic_state": "X Y : TopCat\nf g : X \u27f6 Y\nc : Cofork f g\nhc : IsColimit c\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom c.\u03c0) \u2227\n    \u2200 (s : Set \u2191(((Functor.const WalkingParallelPair).obj c.pt).obj WalkingParallelPair.one)),\n      IsOpen s \u2194 IsOpen (\u21d1(ConcreteCategory.hom c.\u03c0) \u207b\u00b9' s)"}, {"line": "constructor", "tactic_state": "case left\nX Y : TopCat\nf g : X \u27f6 Y\nc : Cofork f g\nhc : IsColimit c\n\u22a2 Function.Surjective \u21d1(ConcreteCategory.hom c.\u03c0)\n---\ncase right\nX Y : TopCat\nf g : X \u27f6 Y\nc : Cofork f g\nhc : IsColimit c\n\u22a2 \u2200 (s : Set \u2191(((Functor.const WalkingParallelPair).obj c.pt).obj WalkingParallelPair.one)),\n    IsOpen s \u2194 IsOpen (\u21d1(ConcreteCategory.hom c.\u03c0) \u207b\u00b9' s)"}, {"line": "\u00b7 simpa only [\u2190 epi_iff_surjective] using epi_of_isColimit_cofork hc", "tactic_state": "case right\nX Y : TopCat\nf g : X \u27f6 Y\nc : Cofork f g\nhc : IsColimit c\n\u22a2 \u2200 (s : Set \u2191(((Functor.const WalkingParallelPair).obj c.pt).obj WalkingParallelPair.one)),\n    IsOpen s \u2194 IsOpen (\u21d1(ConcreteCategory.hom c.\u03c0) \u207b\u00b9' s)"}, {"line": "\u00b7 exact isOpen_iff_of_isColimit_cofork c hc", "tactic_state": "No Goals!"}]}
{"declaration": "lemma some_eq_iff (x\u2081 x\u2082 : X) : (some x\u2081 = some x\u2082) \u2194 (x\u2081 = x\u2082) := by\n  rw [iff_eq_eq]\n  exact Option.some.injEq x\u2081 x\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactification/OnePoint.lean", "context": {"open": ["Set Filter Topology"], "variables": ["{X Y : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nx\u2081 x\u2082 : X\n\u22a2 some x\u2081 = some x\u2082 \u2194 x\u2081 = x\u2082"}, {"line": "rw [iff_eq_eq]", "tactic_state": "X : Type u_1\nx\u2081 x\u2082 : X\n\u22a2 (some x\u2081 = some x\u2082) = (x\u2081 = x\u2082)"}, {"line": "exact Option.some.injEq x\u2081 x\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_nonempty_of_compact [CompactSpace X] {f : \u03b9 \u2192 Set X}\n    (hf : LocallyFinite f) : { i | (f i).Nonempty }.Finite := by\n  simpa only [inter_univ] using hf.finite_nonempty_inter_compact isCompact_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/LocallyFinite.lean", "context": {"open": ["Set"], "variables": ["{X \u03b9 : Type*} [TopologicalSpace X] {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\n\u22a2 {i | (f i).Nonempty}.Finite"}, {"line": "simpa only [inter_univ] using hf.finite_nonempty_inter_compact isCompact_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finite_of_compact [CompactSpace X] {f : \u03b9 \u2192 Set X}\n    (hf : LocallyFinite f) (hne : \u2200 i, (f i).Nonempty) : (univ : Set \u03b9).Finite := by\n  simpa only [hne] using hf.finite_nonempty_of_compact\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/LocallyFinite.lean", "context": {"open": ["Set"], "variables": ["{X \u03b9 : Type*} [TopologicalSpace X] {s : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nf : \u03b9 \u2192 Set X\nhf : LocallyFinite f\nhne : \u2200 (i : \u03b9), (f i).Nonempty\n\u22a2 univ.Finite"}, {"line": "simpa only [hne] using hf.finite_nonempty_of_compact", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.compl_mem_sets (hs : IsCompact s) {f : Filter X} (hf : \u2200 x \u2208 s, s\u1d9c \u2208 \ud835\udcdd x \u2293 f) :\n    s\u1d9c \u2208 f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl] at hf \u22a2\n  simp only [compl_compl] at hf \u22a2\n  simp only [inf_assoc] at hf \u22a2\n  exact @hs _ hf inf_le_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : \u2200 x \u2208 s, s\u1d9c \u2208 nhds x \u2293 f\n\u22a2 s\u1d9c \u2208 f"}, {"line": "contrapose! hf", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : s\u1d9c \u2209 f\n\u22a2 \u2203 x \u2208 s, s\u1d9c \u2209 nhds x \u2293 f"}, {"line": "simp only [not_mem_iff_inf_principal_compl] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : (f \u2293 principal s\u1d9c\u1d9c).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 f \u2293 principal s\u1d9c\u1d9c).NeBot"}, {"line": "simp only [compl_compl] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : (f \u2293 principal s).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 f \u2293 principal s).NeBot"}, {"line": "simp only [inf_assoc] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\nf : Filter X\nhf : (f \u2293 principal s).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 (f \u2293 principal s)).NeBot"}, {"line": "exact @hs _ hf inf_le_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.induction_on (hs : IsCompact s) {p : Set X \u2192 Prop} (he : p \u2205)\n    (hmono : \u2200 \u2983s t\u2984, s \u2286 t \u2192 p t \u2192 p s) (hunion : \u2200 \u2983s t\u2984, p s \u2192 p t \u2192 p (s \u222a t))\n    (hnhds : \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, p t) : p s := by\n  let f : Filter X := comk p he (fun _t ht _s hsub \u21a6 hmono hsub ht) (fun _s hs _t ht \u21a6 hunion hs ht)\n  have : s\u1d9c \u2208 f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)\n  rwa [\u2190 compl_compl s]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\np : Set X \u2192 Prop\nhe : p \u2205\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhunion : \u2200 \u2983s t : Set X\u2984, p s \u2192 p t \u2192 p (s \u222a t)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\n\u22a2 p s"}, {"line": "let f : Filter X := comk p he (fun _t ht _s hsub \u21a6 hmono hsub ht) (fun _s hs _t ht \u21a6 hunion hs ht)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\np : Set X \u2192 Prop\nhe : p \u2205\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhunion : \u2200 \u2983s t : Set X\u2984, p s \u2192 p t \u2192 p (s \u222a t)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\nf : Filter X := comk p he \u22ef \u22ef\n\u22a2 p s"}, {"line": "have : s\u1d9c \u2208 f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\np : Set X \u2192 Prop\nhe : p \u2205\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhunion : \u2200 \u2983s t : Set X\u2984, p s \u2192 p t \u2192 p (s \u222a t)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\nf : Filter X := comk p he \u22ef \u22ef\nthis : s\u1d9c \u2208 f\n\u22a2 p s"}, {"line": "rwa [\u2190 compl_compl s]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCompact_iff_ultrafilter_le_nhds' :\n    IsCompact s \u2194 \u2200 f : Ultrafilter X, s \u2208 f \u2192 \u2203 x \u2208 s, \u2191f \u2264 \ud835\udcdd x := by\n  simp only [isCompact_iff_ultrafilter_le_nhds]\n  simp only [le_principal_iff]\n  simp only [Ultrafilter.mem_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsCompact s \u2194 \u2200 (f : Ultrafilter X), s \u2208 f \u2192 \u2203 x \u2208 s, \u2191f \u2264 nhds x"}, {"line": "simp only [isCompact_iff_ultrafilter_le_nhds]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2200 (f : Ultrafilter X), \u2191f \u2264 principal s \u2192 \u2203 x \u2208 s, \u2191f \u2264 nhds x) \u2194 \u2200 (f : Ultrafilter X), s \u2208 f \u2192 \u2203 x \u2208 s, \u2191f \u2264 nhds x"}, {"line": "simp only [le_principal_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2200 (f : Ultrafilter X), s \u2208 \u2191f \u2192 \u2203 x \u2208 s, \u2191f \u2264 nhds x) \u2194 \u2200 (f : Ultrafilter X), s \u2208 f \u2192 \u2203 x \u2208 s, \u2191f \u2264 nhds x"}, {"line": "simp only [Ultrafilter.mem_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.disjoint_nhdsSet_right {l : Filter X} (hs : IsCompact s) :\n    Disjoint l (\ud835\udcdd\u02e2 s) \u2194 \u2200 x \u2208 s, Disjoint l (\ud835\udcdd x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nl : Filter X\nhs : IsCompact s\n\u22a2 Disjoint l (nhdsSet s) \u2194 \u2200 x \u2208 s, Disjoint l (nhds x)"}, {"line": "simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.inter_iInter_nonempty {\u03b9 : Type v} (hs : IsCompact s) (t : \u03b9 \u2192 Set X)\n    (htc : \u2200 i, IsClosed (t i)) (hst : \u2200 u : Finset \u03b9, (s \u2229 \u22c2 i \u2208 u, t i).Nonempty) :\n    (s \u2229 \u22c2 i, t i).Nonempty := by\n  contrapose! hst\n  exact hs.elim_finite_subfamily_closed t htc hst\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u03b9 : Type v\nhs : IsCompact s\nt : \u03b9 \u2192 Set X\nhtc : \u2200 (i : \u03b9), IsClosed (t i)\nhst : \u2200 (u : Finset \u03b9), (s \u2229 \u22c2 i \u2208 u, t i).Nonempty\n\u22a2 (s \u2229 \u22c2 i, t i).Nonempty"}, {"line": "contrapose! hst", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u03b9 : Type v\nhs : IsCompact s\nt : \u03b9 \u2192 Set X\nhtc : \u2200 (i : \u03b9), IsClosed (t i)\nhst : s \u2229 \u22c2 i, t i = \u2205\n\u22a2 \u2203 u, s \u2229 \u22c2 i \u2208 u, t i = \u2205"}, {"line": "exact hs.elim_finite_subfamily_closed t htc hst", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n    {\u03b9 : Type v} [h\u03b9 : Nonempty \u03b9] (t : \u03b9 \u2192 Set X) (htd : Directed (\u00b7 \u2287 \u00b7) t)\n    (htn : \u2200 i, (t i).Nonempty) (htc : \u2200 i, IsCompact (t i)) (htcl : \u2200 i, IsClosed (t i)) :\n    (\u22c2 i, t i).Nonempty := by\n  let i\u2080 := h\u03b9.some\n  suffices (t i\u2080 \u2229 \u22c2 i, t i).Nonempty by\n    rwa [inter_eq_right.mpr (iInter_subset _ i\u2080)] at this\n  simp only [nonempty_iff_ne_empty] at htn \u22a2\n  apply mt ((htc i\u2080).elim_directed_family_closed t htcl)\n  push_neg\n  simp only [\u2190 nonempty_iff_ne_empty] at htn \u22a2\n  refine \u27e8htd, fun i => ?_\u27e9\n  rcases htd i\u2080 i with \u27e8j, hji\u2080, hji\u27e9\n  exact (htn j).mono (subset_inter hji\u2080 hji)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\n\u22a2 (\u22c2 i, t i).Nonempty"}, {"line": "let i\u2080 := h\u03b9.some", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\n\u22a2 (\u22c2 i, t i).Nonempty"}, {"line": "suffices (t i\u2080 \u2229 \u22c2 i, t i).Nonempty by\n    rwa [inter_eq_right.mpr (iInter_subset _ i\u2080)] at this", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\n\u22a2 (t i\u2080 \u2229 \u22c2 i, t i).Nonempty"}, {"line": "simp only [nonempty_iff_ne_empty] at htn \u22a2", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), t i \u2260 \u2205\n\u22a2 t i\u2080 \u2229 \u22c2 i, t i \u2260 \u2205"}, {"line": "apply mt ((htc i\u2080).elim_directed_family_closed t htcl)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), t i \u2260 \u2205\n\u22a2 \u00ac(Directed (fun x1 x2 => x1 \u2287 x2) t \u2192 \u2203 i, t i\u2080 \u2229 t i = \u2205)"}, {"line": "push_neg", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), t i \u2260 \u2205\n\u22a2 Directed (fun x1 x2 => x1 \u2287 x2) t \u2227 \u2200 (i : \u03b9), (t i\u2080 \u2229 t i).Nonempty"}, {"line": "simp only [\u2190 nonempty_iff_ne_empty] at htn \u22a2", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\n\u22a2 Directed (fun x1 x2 => x1 \u2287 x2) t \u2227 \u2200 (i : \u03b9), (t i\u2080 \u2229 t i).Nonempty"}, {"line": "refine \u27e8htd, fun i => ?_\u27e9", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\ni : \u03b9\n\u22a2 (t i\u2080 \u2229 t i).Nonempty"}, {"line": "rcases htd i\u2080 i with \u27e8j, hji\u2080, hji\u27e9", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\n\u03b9 : Type v\nh\u03b9 : Nonempty \u03b9\nt : \u03b9 \u2192 Set X\nhtd : Directed (fun x1 x2 => x1 \u2287 x2) t\nhtc : \u2200 (i : \u03b9), IsCompact (t i)\nhtcl : \u2200 (i : \u03b9), IsClosed (t i)\ni\u2080 : \u03b9 := h\u03b9.some\nhtn : \u2200 (i : \u03b9), (t i).Nonempty\ni j : \u03b9\nhji\u2080 : t i\u2080 \u2287 t j\nhji : t i \u2287 t j\n\u22a2 (t i\u2080 \u2229 t i).Nonempty"}, {"line": "exact (htn j).mono (subset_inter hji\u2080 hji)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.nonempty_sInter_of_directed_nonempty_isCompact_isClosed\n    {S : Set (Set X)} [hS : Nonempty S] (hSd : DirectedOn (\u00b7 \u2287 \u00b7) S) (hSn : \u2200 U \u2208 S, U.Nonempty)\n    (hSc : \u2200 U \u2208 S, IsCompact U) (hScl : \u2200 U \u2208 S, IsClosed U) : (\u22c2\u2080 S).Nonempty := by\n  rw [sInter_eq_iInter]\n  exact IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _\n    (DirectedOn.directed_val hSd) (fun i \u21a6 hSn i i.2) (fun i \u21a6 hSc i i.2) (fun i \u21a6 hScl i i.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : Nonempty \u2191S\nhSd : DirectedOn (fun x1 x2 => x1 \u2287 x2) S\nhSn : \u2200 U \u2208 S, U.Nonempty\nhSc : \u2200 U \u2208 S, IsCompact U\nhScl : \u2200 U \u2208 S, IsClosed U\n\u22a2 (\u22c2\u2080 S).Nonempty"}, {"line": "rw [sInter_eq_iInter]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhS : Nonempty \u2191S\nhSd : DirectedOn (fun x1 x2 => x1 \u2287 x2) S\nhSn : \u2200 U \u2208 S, U.Nonempty\nhSc : \u2200 U \u2208 S, IsCompact U\nhScl : \u2200 U \u2208 S, IsClosed U\n\u22a2 (\u22c2 i, \u2191i).Nonempty"}, {"line": "exact IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _\n    (DirectedOn.directed_val hSd) (fun i \u21a6 hSn i i.2) (fun i \u21a6 hSc i i.2) (fun i \u21a6 hScl i i.2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_cocompact_left (f : Filter X) :\n    Disjoint (Filter.cocompact X) f \u2194 \u2203 K \u2208 f, IsCompact K := by\n  simp_rw [hasBasis_cocompact.disjoint_iff_left, compl_compl]\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 Disjoint (cocompact X) f \u2194 \u2203 K \u2208 f, IsCompact K"}, {"line": "simp_rw [hasBasis_cocompact.disjoint_iff_left, compl_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 (\u2203 i, IsCompact i \u2227 i \u2208 f) \u2194 \u2203 K \u2208 f, IsCompact K"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_cocompact_right (f : Filter X) :\n    Disjoint f (Filter.cocompact X) \u2194 \u2203 K \u2208 f, IsCompact K := by\n  simp_rw [hasBasis_cocompact.disjoint_iff_right, compl_compl]\n  tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 Disjoint f (cocompact X) \u2194 \u2203 K \u2208 f, IsCompact K"}, {"line": "simp_rw [hasBasis_cocompact.disjoint_iff_right, compl_compl]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\nf : Filter X\n\u22a2 (\u2203 i, IsCompact i \u2227 i \u2208 f) \u2194 \u2203 K \u2208 f, IsCompact K"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_coclosedCompact :\n    (Filter.coclosedCompact X).HasBasis (fun s => IsClosed s \u2227 IsCompact s) compl := by\n  simp only [Filter.coclosedCompact]\n  simp only [iInf_and']\n  refine hasBasis_biInf_principal' ?_ \u27e8\u2205, isClosed_empty, isCompact_empty\u27e9\n  rintro s \u27e8hs\u2081, hs\u2082\u27e9 t \u27e8ht\u2081, ht\u2082\u27e9\n  exact \u27e8s \u222a t, \u27e8\u27e8hs\u2081.union ht\u2081, hs\u2082.union ht\u2082\u27e9, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (coclosedCompact X).HasBasis (fun s => IsClosed s \u2227 IsCompact s) compl"}, {"line": "simp only [Filter.coclosedCompact]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2a05 s, \u2a05 (_ : IsClosed s), \u2a05 (_ : IsCompact s), principal s\u1d9c).HasBasis (fun s => IsClosed s \u2227 IsCompact s) compl"}, {"line": "simp only [iInf_and']", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2a05 s, \u2a05 (_ : IsClosed s \u2227 IsCompact s), principal s\u1d9c).HasBasis (fun s => IsClosed s \u2227 IsCompact s) compl"}, {"line": "refine hasBasis_biInf_principal' ?_ \u27e8\u2205, isClosed_empty, isCompact_empty\u27e9", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 \u2200 (i : Set X),\n    IsClosed i \u2227 IsCompact i \u2192\n      \u2200 (j : Set X), IsClosed j \u2227 IsCompact j \u2192 \u2203 k, (IsClosed k \u2227 IsCompact k) \u2227 k\u1d9c \u2286 i\u1d9c \u2227 k\u1d9c \u2286 j\u1d9c"}, {"line": "rintro s \u27e8hs\u2081, hs\u2082\u27e9 t \u27e8ht\u2081, ht\u2082\u27e9", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs\u2081 : IsClosed s\nhs\u2082 : IsCompact s\nt : Set X\nht\u2081 : IsClosed t\nht\u2082 : IsCompact t\n\u22a2 \u2203 k, (IsClosed k \u2227 IsCompact k) \u2227 k\u1d9c \u2286 s\u1d9c \u2227 k\u1d9c \u2286 t\u1d9c"}, {"line": "exact \u27e8s \u222a t, \u27e8\u27e8hs\u2081.union ht\u2081, hs\u2082.union ht\u2082\u27e9, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem compl_mem_coclosedCompact : s\u1d9c \u2208 coclosedCompact X \u2194 IsCompact (closure s) := by\n  rw [mem_coclosedCompact_iff]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s\u1d9c \u2208 coclosedCompact X \u2194 IsCompact (closure s)"}, {"line": "rw [mem_coclosedCompact_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsCompact (closure s\u1d9c\u1d9c) \u2194 IsCompact (closure s)"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_prod_le_of_disjoint_cocompact {f : Filter Y} (x : X)\n    (hf : Disjoint f (Filter.cocompact Y)) :\n    \ud835\udcdd x \u00d7\u02e2 f \u2264 \ud835\udcdd\u02e2 ({x} \u00d7\u02e2 Set.univ) := by\n  simpa using nhdsSet_prod_le_of_disjoint_cocompact isCompact_singleton hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : Filter Y\nx : X\nhf : Disjoint f (cocompact Y)\n\u22a2 nhds x \u00d7\u02e2 f \u2264 nhdsSet ({x} \u00d7\u02e2 univ)"}, {"line": "simpa using nhdsSet_prod_le_of_disjoint_cocompact isCompact_singleton hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_nhds_le_of_disjoint_cocompact {f : Filter X} (y : Y)\n    (hf : Disjoint f (Filter.cocompact X)) :\n    f \u00d7\u02e2 \ud835\udcdd y \u2264 \ud835\udcdd\u02e2 (Set.univ \u00d7\u02e2 {y}) := by\n  simpa using prod_nhdsSet_le_of_disjoint_cocompact isCompact_singleton hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : Filter X\ny : Y\nhf : Disjoint f (cocompact X)\n\u22a2 f \u00d7\u02e2 nhds y \u2264 nhdsSet (univ \u00d7\u02e2 {y})"}, {"line": "simpa using prod_nhdsSet_le_of_disjoint_cocompact isCompact_singleton hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Set.Infinite.exists_accPt_cofinite_inf_principal [CompactSpace X] (hs : s.Infinite) :\n    \u2203 x, AccPt x (cofinite \u2293 \ud835\udcdf s) := by\n  simpa only [mem_univ,true_and]\n    using hs.exists_accPt_cofinite_inf_principal_of_subset_isCompact isCompact_univ s.subset_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\ninst\u271d : CompactSpace X\nhs : s.Infinite\n\u22a2 \u2203 x, AccPt x (cofinite \u2293 principal s)"}, {"line": "simpa only [mem_univ,true_and]\n    using hs.exists_accPt_cofinite_inf_principal_of_subset_isCompact isCompact_univ s.subset_univ", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_nhds_ne_neBot (X : Type*) [TopologicalSpace X] [CompactSpace X] [Infinite X] :\n    \u2203 z : X, (\ud835\udcdd[\u2260] z).NeBot := by\n  simpa [AccPt] using (@infinite_univ X _).exists_accPt_principal\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : Infinite X\n\u22a2 \u2203 z, (nhdsWithin z {z}\u1d9c).NeBot"}, {"line": "simpa [AccPt] using (@infinite_univ X _).exists_accPt_principal", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCompact_iff_isCompact_univ : IsCompact s \u2194 IsCompact (univ : Set s) := by\n  rw [Subtype.isCompact_iff]\n  rw [image_univ]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsCompact s \u2194 IsCompact univ"}, {"line": "rw [Subtype.isCompact_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsCompact s \u2194 IsCompact (Subtype.val '' univ)"}, {"line": "rw [image_univ]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsCompact s \u2194 IsCompact (range Subtype.val)"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.coprod_cocompact :\n    (Filter.cocompact X).coprod (Filter.cocompact Y) = Filter.cocompact (X \u00d7 Y) := by\n  apply le_antisymm\n  \u00b7 exact sup_le (comap_cocompact_le continuous_fst) (comap_cocompact_le continuous_snd)\n  \u00b7 refine (hasBasis_cocompact.coprod hasBasis_cocompact).ge_iff.2 fun K hK \u21a6 ?_\n    rw [\u2190 univ_prod]\n    rw [\u2190 prod_univ]\n    rw [\u2190 compl_prod_eq_union]\n    exact (hK.1.prod hK.2).compl_mem_cocompact\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 (cocompact X).coprod (cocompact Y) = cocompact (X \u00d7 Y)"}, {"line": "apply le_antisymm", "tactic_state": "case a\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 (cocompact X).coprod (cocompact Y) \u2264 cocompact (X \u00d7 Y)\n---\ncase a\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 cocompact (X \u00d7 Y) \u2264 (cocompact X).coprod (cocompact Y)"}, {"line": "\u00b7 exact sup_le (comap_cocompact_le continuous_fst) (comap_cocompact_le continuous_snd)", "tactic_state": "case a\nX : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 cocompact (X \u00d7 Y) \u2264 (cocompact X).coprod (cocompact Y)"}, {"line": "\u00b7 refine (hasBasis_cocompact.coprod hasBasis_cocompact).ge_iff.2 fun K hK \u21a6 ?_\n    rw [\u2190 univ_prod]\n    rw [\u2190 prod_univ]\n    rw [\u2190 compl_prod_eq_union]\n    exact (hK.1.prod hK.2).compl_mem_cocompact", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prod.noncompactSpace_iff :\n    NoncompactSpace (X \u00d7 Y) \u2194 NoncompactSpace X \u2227 Nonempty Y \u2228 Nonempty X \u2227 NoncompactSpace Y := by\n  simp [\u2190 Filter.cocompact_neBot_iff, \u2190 Filter.coprod_cocompact, Filter.coprod_neBot_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 NoncompactSpace (X \u00d7 Y) \u2194 NoncompactSpace X \u2227 Nonempty Y \u2228 Nonempty X \u2227 NoncompactSpace Y"}, {"line": "simp [\u2190 Filter.cocompact_neBot_iff, \u2190 Filter.coprod_cocompact, Filter.coprod_neBot_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.coprod\u1d62_cocompact {X : \u03b9 \u2192 Type*} [\u2200 d, TopologicalSpace (X d)] :\n    (Filter.coprod\u1d62 fun d => Filter.cocompact (X d)) = Filter.cocompact (\u2200 d, X d) := by\n  refine le_antisymm (iSup_le fun i => Filter.comap_cocompact_le (continuous_apply i)) ?_\n  refine compl_surjective.forall.2 fun s H => ?_\n  simp only [compl_mem_coprod\u1d62] at H \u22a2\n  simp only [Filter.mem_cocompact] at H \u22a2\n  simp only [compl_subset_compl] at H \u22a2\n  simp only [image_subset_iff] at H \u22a2\n  choose K hKc htK using H\n  exact \u27e8Set.pi univ K, isCompact_univ_pi hKc, fun f hf i _ => htK i hf\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in", "{X : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\n\u22a2 (Filter.coprod\u1d62 fun d => cocompact (X d)) = cocompact ((d : \u03b9) \u2192 X d)"}, {"line": "refine le_antisymm (iSup_le fun i => Filter.comap_cocompact_le (continuous_apply i)) ?_", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\n\u22a2 cocompact ((d : \u03b9) \u2192 X d) \u2264 Filter.coprod\u1d62 fun d => cocompact (X d)"}, {"line": "refine compl_surjective.forall.2 fun s H => ?_", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nH : s\u1d9c \u2208 Filter.coprod\u1d62 fun d => cocompact (X d)\n\u22a2 s\u1d9c \u2208 cocompact ((d : \u03b9) \u2192 X d)"}, {"line": "simp only [compl_mem_coprod\u1d62] at H \u22a2", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nH : \u2200 (i : \u03b9), (eval i '' s)\u1d9c \u2208 cocompact (X i)\n\u22a2 s\u1d9c \u2208 cocompact ((d : \u03b9) \u2192 X d)"}, {"line": "simp only [Filter.mem_cocompact] at H \u22a2", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nH : \u2200 (i : \u03b9), \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 (eval i '' s)\u1d9c\n\u22a2 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 s\u1d9c"}, {"line": "simp only [compl_subset_compl] at H \u22a2", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nH : \u2200 (i : \u03b9), \u2203 t, IsCompact t \u2227 eval i '' s \u2286 t\n\u22a2 \u2203 t, IsCompact t \u2227 s \u2286 t"}, {"line": "simp only [image_subset_iff] at H \u22a2", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nH : \u2200 (i : \u03b9), \u2203 t, IsCompact t \u2227 s \u2286 eval i \u207b\u00b9' t\n\u22a2 \u2203 t, IsCompact t \u2227 s \u2286 t"}, {"line": "choose K hKc htK using H", "tactic_state": "\u03b9 : Type u_1\nX : \u03b9 \u2192 Type u_2\ninst\u271d : (d : \u03b9) \u2192 TopologicalSpace (X d)\ns : Set ((i : \u03b9) \u2192 X i)\nK : (i : \u03b9) \u2192 Set (X i)\nhKc : \u2200 (i : \u03b9), IsCompact (K i)\nhtK : \u2200 (i : \u03b9), s \u2286 eval i \u207b\u00b9' K i\n\u22a2 \u2203 t, IsCompact t \u2227 s \u2286 t"}, {"line": "exact \u27e8Set.pi univ K, isCompact_univ_pi hKc, fun f hf i _ => htK i hf\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace X] {S : Set X}\n    (hS : IsClosed S) (hne : S.Nonempty) :\n    \u2203 V : Set X, V \u2286 S \u2227 V.Nonempty \u2227 IsClosed V \u2227\n      \u2200 V' : Set X, V' \u2286 V \u2192 V'.Nonempty \u2192 IsClosed V' \u2192 V' = V := by\n  let opens := { U : Set X | S\u1d9c \u2286 U \u2227 IsOpen U \u2227 U\u1d9c.Nonempty }\n  obtain \u27e8U, h\u27e9 :=\n    zorn_subset opens fun c hc hz => by\n      by_cases hcne : c.Nonempty\n      \u00b7 obtain \u27e8U\u2080, hU\u2080\u27e9 := hcne\n        haveI : Nonempty { U // U \u2208 c } := \u27e8\u27e8U\u2080, hU\u2080\u27e9\u27e9\n        obtain \u27e8U\u2080compl, -, -\u27e9 := hc hU\u2080\n        use \u22c3\u2080 c\n        refine \u27e8\u27e8?_, ?_, ?_\u27e9, fun U hU _ hx => \u27e8U, hU, hx\u27e9\u27e9\n        \u00b7 exact fun _ hx => \u27e8U\u2080, hU\u2080, U\u2080compl hx\u27e9\n        \u00b7 exact isOpen_sUnion fun _ h => (hc h).2.1\n        \u00b7 convert_to (\u22c2 U : { U // U \u2208 c }, U.1\u1d9c).Nonempty\n          \u00b7 ext\n            simp only [not_exists]\n            simp only [exists_prop]\n            simp only [not_and]\n            simp only [Set.mem_iInter]\n            simp only [Subtype.forall]\n            simp only [mem_setOf_eq]\n            simp only [mem_compl_iff]\n            simp only [mem_sUnion]\n          apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n          \u00b7 rintro \u27e8U, hU\u27e9 \u27e8U', hU'\u27e9\n            obtain \u27e8V, hVc, hVU, hVU'\u27e9 := hz.directedOn U hU U' hU'\n            exact \u27e8\u27e8V, hVc\u27e9, Set.compl_subset_compl.mpr hVU, Set.compl_subset_compl.mpr hVU'\u27e9\n          \u00b7 exact fun U => (hc U.2).2.2\n          \u00b7 exact fun U => (hc U.2).2.1.isClosed_compl.isCompact\n          \u00b7 exact fun U => (hc U.2).2.1.isClosed_compl\n      \u00b7 use S\u1d9c\n        refine \u27e8\u27e8Set.Subset.refl _, isOpen_compl_iff.mpr hS, ?_\u27e9, fun U Uc => (hcne \u27e8U, Uc\u27e9).elim\u27e9\n        rw [compl_compl]\n        exact hne\n  obtain \u27e8Uc, Uo, Ucne\u27e9 := h.prop\n  refine \u27e8U\u1d9c, Set.compl_subset_comm.mp Uc, Ucne, Uo.isClosed_compl, ?_\u27e9\n  intro V' V'sub V'ne V'cls\n  have : V'\u1d9c = U := by\n    refine h.eq_of_ge \u27e8?_, isOpen_compl_iff.mpr V'cls, ?_\u27e9 (subset_compl_comm.2 V'sub)\n    \u00b7 exact Set.Subset.trans Uc (Set.subset_compl_comm.mp V'sub)\n    \u00b7 simp only [compl_compl, V'ne]\n  rw [\u2190 this]\n  rw [compl_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Compact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace Function"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X} {f : X \u2192 Y}", "(X) in", "{X : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\n\u22a2 \u2203 V \u2286 S, V.Nonempty \u2227 IsClosed V \u2227 \u2200 V' \u2286 V, V'.Nonempty \u2192 IsClosed V' \u2192 V' = V"}, {"line": "let opens := { U : Set X | S\u1d9c \u2286 U \u2227 IsOpen U \u2227 U\u1d9c.Nonempty }", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\n\u22a2 \u2203 V \u2286 S, V.Nonempty \u2227 IsClosed V \u2227 \u2200 V' \u2286 V, V'.Nonempty \u2192 IsClosed V' \u2192 V' = V"}, {"line": "obtain \u27e8U, h\u27e9 :=\n    zorn_subset opens fun c hc hz => by\n      by_cases hcne : c.Nonempty\n      \u00b7 obtain \u27e8U\u2080, hU\u2080\u27e9 := hcne\n        haveI : Nonempty { U // U \u2208 c } := \u27e8\u27e8U\u2080, hU\u2080\u27e9\u27e9\n        obtain \u27e8U\u2080compl, -, -\u27e9 := hc hU\u2080\n        use \u22c3\u2080 c\n        refine \u27e8\u27e8?_, ?_, ?_\u27e9, fun U hU _ hx => \u27e8U, hU, hx\u27e9\u27e9\n        \u00b7 exact fun _ hx => \u27e8U\u2080, hU\u2080, U\u2080compl hx\u27e9\n        \u00b7 exact isOpen_sUnion fun _ h => (hc h).2.1\n        \u00b7 convert_to (\u22c2 U : { U // U \u2208 c }, U.1\u1d9c).Nonempty\n          \u00b7 ext\n            simp only [not_exists]\n            simp only [exists_prop]\n            simp only [not_and]\n            simp only [Set.mem_iInter]\n            simp only [Subtype.forall]\n            simp only [mem_setOf_eq]\n            simp only [mem_compl_iff]\n            simp only [mem_sUnion]\n          apply IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n          \u00b7 rintro \u27e8U, hU\u27e9 \u27e8U', hU'\u27e9\n            obtain \u27e8V, hVc, hVU, hVU'\u27e9 := hz.directedOn U hU U' hU'\n            exact \u27e8\u27e8V, hVc\u27e9, Set.compl_subset_compl.mpr hVU, Set.compl_subset_compl.mpr hVU'\u27e9\n          \u00b7 exact fun U => (hc U.2).2.2\n          \u00b7 exact fun U => (hc U.2).2.1.isClosed_compl.isCompact\n          \u00b7 exact fun U => (hc U.2).2.1.isClosed_compl\n      \u00b7 use S\u1d9c\n        refine \u27e8\u27e8Set.Subset.refl _, isOpen_compl_iff.mpr hS, ?_\u27e9, fun U Uc => (hcne \u27e8U, Uc\u27e9).elim\u27e9\n        rw [compl_compl]\n        exact hne", "tactic_state": "case intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\n\u22a2 \u2203 V \u2286 S, V.Nonempty \u2227 IsClosed V \u2227 \u2200 V' \u2286 V, V'.Nonempty \u2192 IsClosed V' \u2192 V' = V"}, {"line": "obtain \u27e8Uc, Uo, Ucne\u27e9 := h.prop", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\nUc : S\u1d9c \u2286 U\nUo : sorry\nUcne : U\u1d9c.Nonempty\n\u22a2 \u2203 V \u2286 S, V.Nonempty \u2227 IsClosed V \u2227 \u2200 V' \u2286 V, V'.Nonempty \u2192 IsClosed V' \u2192 V' = V"}, {"line": "refine \u27e8U\u1d9c, Set.compl_subset_comm.mp Uc, Ucne, Uo.isClosed_compl, ?_\u27e9", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\nUc : S\u1d9c \u2286 U\nUo : sorry\nUcne : U\u1d9c.Nonempty\n\u22a2 \u2200 V' \u2286 U\u1d9c, V'.Nonempty \u2192 IsClosed V' \u2192 V' = U\u1d9c"}, {"line": "intro V' V'sub V'ne V'cls", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\nUc : S\u1d9c \u2286 U\nUo : sorry\nUcne : U\u1d9c.Nonempty\nV' : Set X\nV'sub : V' \u2286 U\u1d9c\nV'ne : V'.Nonempty\nV'cls : IsClosed V'\n\u22a2 V' = U\u1d9c"}, {"line": "have : V'\u1d9c = U := by\n    refine h.eq_of_ge \u27e8?_, isOpen_compl_iff.mpr V'cls, ?_\u27e9 (subset_compl_comm.2 V'sub)\n    \u00b7 exact Set.Subset.trans Uc (Set.subset_compl_comm.mp V'sub)\n    \u00b7 simp only [compl_compl, V'ne]", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\nUc : S\u1d9c \u2286 U\nUo : sorry\nUcne : U\u1d9c.Nonempty\nV' : Set X\nV'sub : V' \u2286 U\u1d9c\nV'ne : V'.Nonempty\nV'cls : IsClosed V'\nthis : V'\u1d9c = U\n\u22a2 V' = U\u1d9c"}, {"line": "rw [\u2190 this]", "tactic_state": "case intro.intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : CompactSpace X\nS : Set X\nhS : IsClosed S\nhne : S.Nonempty\nopens : Set (Set X) := {U | S\u1d9c \u2286 U \u2227 sorry \u2227 U\u1d9c.Nonempty}\nU : Set X\nh : Maximal (fun x => x \u2208 opens) U\nUc : S\u1d9c \u2286 U\nUo : sorry\nUcne : U\u1d9c.Nonempty\nV' : Set X\nV'sub : V' \u2286 U\u1d9c\nV'ne : V'.Nonempty\nV'cls : IsClosed V'\nthis : V'\u1d9c = U\n\u22a2 V' = V'\u1d9c\u1d9c"}, {"line": "rw [compl_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_from_compactlyGenerated [TopologicalSpace X] [t : TopologicalSpace Y] (f : X \u2192 Y)\n    (h : \u2200 (S : CompHaus.{u}) (g : C(S, X)), Continuous (f \u2218 g)) :\n        Continuous[compactlyGenerated.{u} X, t] f := by\n  rw [continuous_coinduced_dom]\n  continuity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/CompactlyGeneratedSpace.lean", "context": {"open": ["TopologicalSpace Filter Topology Set"], "variables": ["{X : Type w} {Y : Type x}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type w\nY : Type x\ninst\u271d : TopologicalSpace X\nt : TopologicalSpace Y\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 Continuous f"}, {"line": "rw [continuous_coinduced_dom]", "tactic_state": "X : Type w\nY : Type x\ninst\u271d : TopologicalSpace X\nt : TopologicalSpace Y\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 Continuous\n    (f \u2218 fun x =>\n      match x with\n      | \u27e8\u27e8fst, i\u27e9, s\u27e9 => i s)"}, {"line": "continuity", "tactic_state": "No Goals!"}]}
{"declaration": "lemma continuous_from_uCompactlyGeneratedSpace [UCompactlyGeneratedSpace.{u} X] (f : X \u2192 Y)\n    (h : \u2200 (S : CompHaus.{u}) (g : C(S, X)), Continuous (f \u2218 g)) : Continuous f := by\n  apply continuous_le_dom UCompactlyGeneratedSpace.le_compactlyGenerated\n  exact continuous_from_compactlyGenerated f h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/CompactlyGeneratedSpace.lean", "context": {"open": ["TopologicalSpace Filter Topology Set"], "variables": ["{X : Type w} {Y : Type x}", "[tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type w\nY : Type x\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ninst\u271d : UCompactlyGeneratedSpace X\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 Continuous f"}, {"line": "apply continuous_le_dom UCompactlyGeneratedSpace.le_compactlyGenerated", "tactic_state": "X : Type w\nY : Type x\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ninst\u271d : UCompactlyGeneratedSpace X\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 Continuous f\n---\nX : Type w\nY : Type x\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ninst\u271d : UCompactlyGeneratedSpace X\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 UCompactlyGeneratedSpace X"}, {"line": "exact continuous_from_compactlyGenerated f h", "tactic_state": "X : Type w\nY : Type x\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ninst\u271d : UCompactlyGeneratedSpace X\nf : X \u2192 Y\nh : \u2200 (S : CompHaus) (g : C(\u2191S.toTop, X)), Continuous (f \u2218 \u21d1g)\n\u22a2 UCompactlyGeneratedSpace X"}]}
{"declaration": "lemma isOpen_deltaGenerated_iff {u : Set X} :\n    IsOpen[deltaGenerated X] u \u2194 \u2200 n (p : C(Fin n \u2192 \u211d, X)), IsOpen (p \u207b\u00b9' u) := by\n  simp_rw [deltaGenerated, isOpen_iSup_iff, isOpen_coinduced, Sigma.forall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/DeltaGeneratedSpace.lean", "context": {"open": ["TopologicalSpace Topology"], "variables": ["{X Y : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ntX : TopologicalSpace X\nu : Set X\n\u22a2 IsOpen u \u2194 \u2200 (n : \u2115) (p : C(Fin n \u2192 \u211d, X)), IsOpen (\u21d1p \u207b\u00b9' u)"}, {"line": "simp_rw [deltaGenerated, isOpen_iSup_iff, isOpen_coinduced, Sigma.forall]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma deltaGenerated_mono {X : Type*} {t\u2081 t\u2082 : TopologicalSpace X} (h : t\u2081 \u2264 t\u2082) :\n    @deltaGenerated X t\u2081 \u2264 @deltaGenerated X t\u2082 := by\n  rw [\u2190 continuous_id_iff_le]\n  rw [@continuous_to_deltaGenerated _ _     (@deltaGenerated X t\u2081) t\u2082 deltaGeneratedSpace_deltaGenerated id]\n  exact continuous_id_iff_le.2 <| (@deltaGenerated_le X t\u2081).trans h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/DeltaGeneratedSpace.lean", "context": {"open": ["TopologicalSpace Topology"], "variables": ["{X Y : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh : t\u2081 \u2264 t\u2082\n\u22a2 deltaGenerated X \u2264 deltaGenerated X"}, {"line": "rw [\u2190 continuous_id_iff_le]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh : t\u2081 \u2264 t\u2082\n\u22a2 Continuous id"}, {"line": "rw [@continuous_to_deltaGenerated _ _     (@deltaGenerated X t\u2081) t\u2082 deltaGeneratedSpace_deltaGenerated id]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh : t\u2081 \u2264 t\u2082\n\u22a2 Continuous id"}, {"line": "exact continuous_id_iff_le.2 <| (@deltaGenerated_le X t\u2081).trans h", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma DeltaGeneratedSpace.sup {X : Type*} {t\u2081 t\u2082 : TopologicalSpace X}\n    (h\u2081 : @DeltaGeneratedSpace X t\u2081) (h\u2082 : @DeltaGeneratedSpace X t\u2082) :\n    @DeltaGeneratedSpace X (t\u2081 \u2294 t\u2082) := by\n  rw [sup_eq_iSup]\n  exact .iSup <| Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/DeltaGeneratedSpace.lean", "context": {"open": ["TopologicalSpace Topology"], "variables": ["{X Y : Type*} [tX : TopologicalSpace X] [tY : TopologicalSpace Y]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : DeltaGeneratedSpace X\nh\u2082 : DeltaGeneratedSpace X\n\u22a2 DeltaGeneratedSpace X"}, {"line": "rw [sup_eq_iSup]", "tactic_state": "X : Type u_3\nt\u2081 t\u2082 : TopologicalSpace X\nh\u2081 : DeltaGeneratedSpace X\nh\u2082 : DeltaGeneratedSpace X\n\u22a2 DeltaGeneratedSpace X"}, {"line": "exact .iSup <| Bool.forall_bool.2 \u27e8h\u2082, h\u2081\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLindelof.compl_mem_sets (hs : IsLindelof s) {f : Filter X} [CountableInterFilter f]\n    (hf : \u2200 x \u2208 s, s\u1d9c \u2208 \ud835\udcdd x \u2293 f) : s\u1d9c \u2208 f := by\n  contrapose! hf\n  simp only [not_mem_iff_inf_principal_compl] at hf \u22a2\n  simp only [compl_compl] at hf \u22a2\n  simp only [inf_assoc] at hf \u22a2\n  exact hs inf_le_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst\u271d : CountableInterFilter f\nhf : \u2200 x \u2208 s, s\u1d9c \u2208 nhds x \u2293 f\n\u22a2 s\u1d9c \u2208 f"}, {"line": "contrapose! hf", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst\u271d : CountableInterFilter f\nhf : s\u1d9c \u2209 f\n\u22a2 \u2203 x \u2208 s, s\u1d9c \u2209 nhds x \u2293 f"}, {"line": "simp only [not_mem_iff_inf_principal_compl] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst\u271d : CountableInterFilter f\nhf : (f \u2293 principal s\u1d9c\u1d9c).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 f \u2293 principal s\u1d9c\u1d9c).NeBot"}, {"line": "simp only [compl_compl] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst\u271d : CountableInterFilter f\nhf : (f \u2293 principal s).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 f \u2293 principal s).NeBot"}, {"line": "simp only [inf_assoc] at hf \u22a2", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\nf : Filter X\ninst\u271d : CountableInterFilter f\nhf : (f \u2293 principal s).NeBot\n\u22a2 \u2203 x \u2208 s, (nhds x \u2293 (f \u2293 principal s)).NeBot"}, {"line": "exact hs inf_le_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLindelof.induction_on (hs : IsLindelof s) {p : Set X \u2192 Prop}\n    (hmono : \u2200 \u2983s t\u2984, s \u2286 t \u2192 p t \u2192 p s)\n    (hcountable_union : \u2200 (S : Set (Set X)), S.Countable \u2192 (\u2200 s \u2208 S, p s) \u2192 p (\u22c3\u2080 S))\n    (hnhds : \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, p t) : p s := by\n  let f : Filter X := ofCountableUnion p hcountable_union (fun t ht _ hsub \u21a6 hmono hsub ht)\n  have : s\u1d9c \u2208 f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)\n  rwa [\u2190 compl_compl s]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\np : Set X \u2192 Prop\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhcountable_union : \u2200 (S : Set (Set X)), S.Countable \u2192 (\u2200 s \u2208 S, p s) \u2192 p (\u22c3\u2080 S)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\n\u22a2 p s"}, {"line": "let f : Filter X := ofCountableUnion p hcountable_union (fun t ht _ hsub \u21a6 hmono hsub ht)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\np : Set X \u2192 Prop\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhcountable_union : \u2200 (S : Set (Set X)), S.Countable \u2192 (\u2200 s \u2208 S, p s) \u2192 p (\u22c3\u2080 S)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\nf : Filter X := ofCountableUnion p hcountable_union \u22ef\n\u22a2 p s"}, {"line": "have : s\u1d9c \u2208 f := hs.compl_mem_sets_of_nhdsWithin (by simpa [f] using hnhds)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsLindelof s\np : Set X \u2192 Prop\nhmono : \u2200 \u2983s t : Set X\u2984, s \u2286 t \u2192 p t \u2192 p s\nhcountable_union : \u2200 (S : Set (Set X)), S.Countable \u2192 (\u2200 s \u2208 S, p s) \u2192 p (\u22c3\u2080 S)\nhnhds : \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, p t\nf : Filter X := ofCountableUnion p hcountable_union \u22ef\nthis : s\u1d9c \u2208 f\n\u22a2 p s"}, {"line": "rwa [\u2190 compl_compl s]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLindelof.disjoint_nhdsSet_right {l : Filter X} [CountableInterFilter l]\n    (hs : IsLindelof s) : Disjoint l (\ud835\udcdd\u02e2 s) \u2194 \u2200 x \u2208 s, Disjoint l (\ud835\udcdd x) := by\n  simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ns : Set X\nl : Filter X\ninst\u271d : CountableInterFilter l\nhs : IsLindelof s\n\u22a2 Disjoint l (nhdsSet s) \u2194 \u2200 x \u2208 s, Disjoint l (nhds x)"}, {"line": "simpa only [disjoint_comm] using hs.disjoint_nhdsSet_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasBasis_coclosedLindelof :\n    (Filter.coclosedLindelof X).HasBasis (fun s => IsClosed s \u2227 IsLindelof s) compl := by\n  simp only [Filter.coclosedLindelof]\n  simp only [iInf_and']\n  refine hasBasis_biInf_principal' ?_ \u27e8\u2205, isClosed_empty, isLindelof_empty\u27e9\n  rintro s \u27e8hs\u2081, hs\u2082\u27e9 t \u27e8ht\u2081, ht\u2082\u27e9\n  exact \u27e8s \u222a t, \u27e8\u27e8hs\u2081.union ht\u2081, hs\u2082.union ht\u2082\u27e9, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (coclosedLindelof X).HasBasis (fun s => IsClosed s \u2227 IsLindelof s) compl"}, {"line": "simp only [Filter.coclosedLindelof]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2a05 s, \u2a05 (_ : IsClosed s), \u2a05 (_ : IsLindelof s), principal s\u1d9c).HasBasis (fun s => IsClosed s \u2227 IsLindelof s) compl"}, {"line": "simp only [iInf_and']", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2a05 s, \u2a05 (_ : IsClosed s \u2227 IsLindelof s), principal s\u1d9c).HasBasis (fun s => IsClosed s \u2227 IsLindelof s) compl"}, {"line": "refine hasBasis_biInf_principal' ?_ \u27e8\u2205, isClosed_empty, isLindelof_empty\u27e9", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\n\u22a2 \u2200 (i : Set X),\n    IsClosed i \u2227 IsLindelof i \u2192\n      \u2200 (j : Set X), IsClosed j \u2227 IsLindelof j \u2192 \u2203 k, (IsClosed k \u2227 IsLindelof k) \u2227 k\u1d9c \u2286 i\u1d9c \u2227 k\u1d9c \u2286 j\u1d9c"}, {"line": "rintro s \u27e8hs\u2081, hs\u2082\u27e9 t \u27e8ht\u2081, ht\u2082\u27e9", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs\u2081 : IsClosed s\nhs\u2082 : IsLindelof s\nt : Set X\nht\u2081 : IsClosed t\nht\u2082 : IsLindelof t\n\u22a2 \u2203 k, (IsClosed k \u2227 IsLindelof k) \u2227 k\u1d9c \u2286 s\u1d9c \u2227 k\u1d9c \u2286 t\u1d9c"}, {"line": "exact \u27e8s \u222a t, \u27e8\u27e8hs\u2081.union ht\u2081, hs\u2082.union ht\u2082\u27e9, compl_subset_compl.2 subset_union_left,\n    compl_subset_compl.2 subset_union_right\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_coclosedLindelof : s \u2208 coclosedLindelof X \u2194\n    \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 t\u1d9c \u2286 s := by\n  simp only [hasBasis_coclosedLindelof.mem_iff]\n  simp only [and_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2208 coclosedLindelof X \u2194 \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 t\u1d9c \u2286 s"}, {"line": "simp only [hasBasis_coclosedLindelof.mem_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2203 i, (IsClosed i \u2227 IsLindelof i) \u2227 i\u1d9c \u2286 s) \u2194 \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 t\u1d9c \u2286 s"}, {"line": "simp only [and_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_coclosed_Lindelof' : s \u2208 coclosedLindelof X \u2194\n    \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 s\u1d9c \u2286 t := by\n  simp only [mem_coclosedLindelof]\n  simp only [compl_subset_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 s \u2208 coclosedLindelof X \u2194 \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 s\u1d9c \u2286 t"}, {"line": "simp only [mem_coclosedLindelof]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 (\u2203 t, IsClosed t \u2227 IsLindelof t \u2227 t\u1d9c \u2286 s) \u2194 \u2203 t, IsClosed t \u2227 IsLindelof t \u2227 s\u1d9c \u2286 t"}, {"line": "simp only [compl_subset_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsCompact.isLindelof (hs : IsCompact s) :\n    IsLindelof s := by tauto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsCompact s\n\u22a2 IsLindelof s"}, {"line": "tauto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsSigmaCompact.isLindelof (hs : IsSigmaCompact s) :\n    IsLindelof s := by\n  rw [IsSigmaCompact] at hs\n  rcases hs with \u27e8K, \u27e8hc, huniv\u27e9\u27e9\n  rw [\u2190 huniv]\n  have hl : \u2200 n, IsLindelof (K n) := fun n \u21a6 IsCompact.isLindelof (hc n)\n  exact isLindelof_iUnion hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsSigmaCompact s\n\u22a2 IsLindelof s"}, {"line": "rw [IsSigmaCompact] at hs", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : \u2203 K, (\u2200 (n : \u2115), IsCompact (K n)) \u2227 \u22c3 n, K n = s\n\u22a2 IsLindelof s"}, {"line": "rcases hs with \u27e8K, \u27e8hc, huniv\u27e9\u27e9", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nK : \u2115 \u2192 Set X\nhc : \u2200 (n : \u2115), IsCompact (K n)\nhuniv : \u22c3 n, K n = s\n\u22a2 IsLindelof s"}, {"line": "rw [\u2190 huniv]", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nK : \u2115 \u2192 Set X\nhc : \u2200 (n : \u2115), IsCompact (K n)\nhuniv : \u22c3 n, K n = s\n\u22a2 IsLindelof (\u22c3 n, K n)"}, {"line": "have hl : \u2200 n, IsLindelof (K n) := fun n \u21a6 IsCompact.isLindelof (hc n)", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\nK : \u2115 \u2192 Set X\nhc : \u2200 (n : \u2115), IsCompact (K n)\nhuniv : \u22c3 n, K n = s\nhl : \u2115 \u2192 sorry\n\u22a2 IsLindelof (\u22c3 n, K n)"}, {"line": "exact isLindelof_iUnion hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLindelof_iff_isLindelof_univ : IsLindelof s \u2194 IsLindelof (univ : Set s) := by\n  rw [Subtype.isLindelof_iff]\n  rw [image_univ]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsLindelof s \u2194 IsLindelof univ"}, {"line": "rw [Subtype.isLindelof_iff]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsLindelof s \u2194 IsLindelof (Subtype.val '' univ)"}, {"line": "rw [image_univ]", "tactic_state": "X : Type u\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsLindelof s \u2194 IsLindelof (range Subtype.val)"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LindelofSpace.of_continuous_surjective {f : X \u2192 Y} [LindelofSpace X] (hf : Continuous f)\n    (hsur : Function.Surjective f) : LindelofSpace Y where\n  isLindelof_univ := by\n    rw [\u2190 Set.image_univ_of_surjective hsur]\n    exact IsLindelof.image (isLindelof_univ_iff.mpr \u2039_\u203a) hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : LindelofSpace X\nhf : Continuous f\nhsur : Function.Surjective f\n\u22a2 IsLindelof univ"}, {"line": "rw [\u2190 Set.image_univ_of_surjective hsur]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\nf : X \u2192 Y\ninst\u271d : LindelofSpace X\nhf : Continuous f\nhsur : Function.Surjective f\n\u22a2 IsLindelof (f '' univ)"}, {"line": "exact IsLindelof.image (isLindelof_univ_iff.mpr \u2039_\u203a) hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma eq_open_union_countable [HereditarilyLindelofSpace X] {\u03b9 : Type u} (U : \u03b9 \u2192 Set X)\n    (h : \u2200 i, IsOpen (U i)) : \u2203 t : Set \u03b9, t.Countable \u2227 \u22c3 i\u2208t, U i = \u22c3 i, U i := by\n  have : IsLindelof (\u22c3 i, U i) := HereditarilyLindelof_LindelofSets (\u22c3 i, U i)\n  rcases isLindelof_iff_countable_subcover.mp this U h (Eq.subset rfl) with \u27e8t, \u27e8htc, htu\u27e9\u27e9\n  use t, htc\n  apply eq_of_subset_of_subset (iUnion\u2082_subset_iUnion (fun i \u21a6 i \u2208 t) fun i \u21a6 U i) htu\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/Lindelof.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type u} {Y : Type v} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : HereditarilyLindelofSpace X\n\u03b9 : Type u\nU : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (U i)\n\u22a2 \u2203 t, t.Countable \u2227 \u22c3 i \u2208 t, U i = \u22c3 i, U i"}, {"line": "have : IsLindelof (\u22c3 i, U i) := HereditarilyLindelof_LindelofSets (\u22c3 i, U i)", "tactic_state": "X : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : HereditarilyLindelofSpace X\n\u03b9 : Type u\nU : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (U i)\nthis : sorry\n\u22a2 \u2203 t, t.Countable \u2227 \u22c3 i \u2208 t, U i = \u22c3 i, U i"}, {"line": "rcases isLindelof_iff_countable_subcover.mp this U h (Eq.subset rfl) with \u27e8t, \u27e8htc, htu\u27e9\u27e9", "tactic_state": "case intro.intro\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : HereditarilyLindelofSpace X\n\u03b9 : Type u\nU : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (U i)\nthis : sorry\nt : Set \u03b9\nhtc : t.Countable\nhtu : \u22c3 i, U i \u2286 \u22c3 i \u2208 t, U i\n\u22a2 \u2203 t, t.Countable \u2227 \u22c3 i \u2208 t, U i = \u22c3 i, U i"}, {"line": "use t, htc", "tactic_state": "case right\nX : Type u\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : HereditarilyLindelofSpace X\n\u03b9 : Type u\nU : \u03b9 \u2192 Set X\nh : \u2200 (i : \u03b9), IsOpen (U i)\nthis : sorry\nt : Set \u03b9\nhtc : t.Countable\nhtu : \u22c3 i, U i \u2286 \u22c3 i \u2208 t, U i\n\u22a2 \u22c3 i \u2208 t, U i = \u22c3 i, U i"}, {"line": "apply eq_of_subset_of_subset (iUnion\u2082_subset_iUnion (fun i \u21a6 i \u2208 t) fun i \u21a6 U i) htu", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_iUnion_of_isCompact [h\u03b9 : Countable \u03b9] (s : \u03b9 \u2192 Set X)\n    (hcomp : \u2200 i, IsCompact (s i)) : IsSigmaCompact (\u22c3 i, s i) := by\n  rcases isEmpty_or_nonempty \u03b9\n  \u00b7 simp only [iUnion_of_empty, isSigmaCompact_empty]\n  \u00b7 -- If \u03b9 is non-empty, choose a surjection f : \u2115 \u2192 \u03b9, this yields a map \u2115 \u2192 Set X.\n    obtain \u27e8f, hf\u27e9 := countable_iff_exists_surjective.mp h\u03b9\n    exact \u27e8s \u2218 f, fun n \u21a6 hcomp (f n), Function.Surjective.iUnion_comp hf _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "rcases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\nX : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : IsEmpty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)\n---\ncase inr\nX : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "\u00b7 simp only [iUnion_of_empty, isSigmaCompact_empty]", "tactic_state": "case inr\nX : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\nh\u03b9 : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsCompact (s i)\nh\u271d : Nonempty \u03b9\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "\u00b7 -- If \u03b9 is non-empty, choose a surjection f : \u2115 \u2192 \u03b9, this yields a map \u2115 \u2192 Set X.\n    obtain \u27e8f, hf\u27e9 := countable_iff_exists_surjective.mp h\u03b9\n    exact \u27e8s \u2218 f, fun n \u21a6 hcomp (f n), Function.Surjective.iUnion_comp hf _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_sUnion_of_isCompact {S : Set (Set X)} (hc : Set.Countable S)\n    (hcomp : \u2200 (s : Set X), s \u2208 S \u2192 IsCompact s) : IsSigmaCompact (\u22c3\u2080 S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  rw [sUnion_eq_iUnion]\n  apply isSigmaCompact_iUnion_of_isCompact _ (fun \u27e8s, hs\u27e9 \u21a6 hcomp s hs)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : \u2200 s \u2208 S, IsCompact s\n\u22a2 IsSigmaCompact (\u22c3\u2080 S)"}, {"line": "have : Countable S := countable_coe_iff.mpr hc", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : \u2200 s \u2208 S, IsCompact s\nthis : Countable \u2191S\n\u22a2 IsSigmaCompact (\u22c3\u2080 S)"}, {"line": "rw [sUnion_eq_iUnion]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : \u2200 s \u2208 S, IsCompact s\nthis : Countable \u2191S\n\u22a2 IsSigmaCompact (\u22c3 i, \u2191i)"}, {"line": "apply isSigmaCompact_iUnion_of_isCompact _ (fun \u27e8s, hs\u27e9 \u21a6 hcomp s hs)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_iUnion [Countable \u03b9] (s : \u03b9 \u2192 Set X)\n    (hcomp : \u2200 i, IsSigmaCompact (s i)) : IsSigmaCompact (\u22c3 i, s i) := by\n  -- Choose a decomposition s_i = \u22c3 K_i,j for each i.\n  choose K hcomp hcov using fun i \u21a6 hcomp i\n  -- Then, we have a countable union of countable unions of compact sets, i.e. countably many.\n  have := calc\n    \u22c3 i, s i\n    _ = \u22c3 i, \u22c3 n, (K i n) := by simp_rw [hcov]\n    _ = \u22c3 (i) (n : \u2115), (K.uncurry \u27e8i, n\u27e9) := by rw [Function.uncurry_def]\n    _ = \u22c3 x, K.uncurry x := by rw [\u2190 iUnion_prod']\n  rw [this]\n  exact isSigmaCompact_iUnion_of_isCompact K.uncurry fun x \u21a6 (hcomp x.1 x.2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp : \u2200 (i : \u03b9), IsSigmaCompact (s i)\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "choose K hcomp hcov using fun i \u21a6 hcomp i", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp\u271d : \u2200 (i : \u03b9), IsSigmaCompact (s i)\nK : \u03b9 \u2192 \u2115 \u2192 Set X\nhcomp : \u2200 (i : \u03b9) (n : \u2115), IsCompact (K i n)\nhcov : \u2200 (i : \u03b9), \u22c3 n, K i n = s i\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "have := calc\n    \u22c3 i, s i\n    _ = \u22c3 i, \u22c3 n, (K i n) := by simp_rw [hcov]\n    _ = \u22c3 (i) (n : \u2115), (K.uncurry \u27e8i, n\u27e9) := by rw [Function.uncurry_def]\n    _ = \u22c3 x, K.uncurry x := by rw [\u2190 iUnion_prod']", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp\u271d : \u2200 (i : \u03b9), IsSigmaCompact (s i)\nK : \u03b9 \u2192 \u2115 \u2192 Set X\nhcomp : \u2200 (i : \u03b9) (n : \u2115), IsCompact (K i n)\nhcov : \u2200 (i : \u03b9), \u22c3 n, K i n = s i\nthis : \u22c3 i, s i = \u22c3 x, Function.uncurry K x\n\u22a2 IsSigmaCompact (\u22c3 i, s i)"}, {"line": "rw [this]", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9\ns : \u03b9 \u2192 Set X\nhcomp\u271d : \u2200 (i : \u03b9), IsSigmaCompact (s i)\nK : \u03b9 \u2192 \u2115 \u2192 Set X\nhcomp : \u2200 (i : \u03b9) (n : \u2115), IsCompact (K i n)\nhcov : \u2200 (i : \u03b9), \u22c3 n, K i n = s i\nthis : \u22c3 i, s i = \u22c3 x, Function.uncurry K x\n\u22a2 IsSigmaCompact (\u22c3 x, Function.uncurry K x)"}, {"line": "exact isSigmaCompact_iUnion_of_isCompact K.uncurry fun x \u21a6 (hcomp x.1 x.2)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_sUnion (S : Set (Set X)) (hc : Set.Countable S)\n    (hcomp : \u2200 s : S, IsSigmaCompact s (X := X)) : IsSigmaCompact (\u22c3\u2080 S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  apply sUnion_eq_iUnion.symm \u25b8 isSigmaCompact_iUnion _ hcomp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : \u2200 (s : \u2191S), IsSigmaCompact \u2191s\n\u22a2 IsSigmaCompact (\u22c3\u2080 S)"}, {"line": "have : Countable S := countable_coe_iff.mpr hc", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : \u2200 (s : \u2191S), IsSigmaCompact \u2191s\nthis : Countable \u2191S\n\u22a2 IsSigmaCompact (\u22c3\u2080 S)"}, {"line": "apply sUnion_eq_iUnion.symm \u25b8 isSigmaCompact_iUnion _ hcomp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_biUnion {s : Set \u03b9} {S : \u03b9 \u2192 Set X} (hc : Set.Countable s)\n    (hcomp : \u2200 (i : \u03b9), i \u2208 s \u2192 IsSigmaCompact (S i)) :\n    IsSigmaCompact (\u22c3 (i : \u03b9) (_ : i \u2208 s), S i) := by\n  have : Countable \u2191s := countable_coe_iff.mpr hc\n  rw [biUnion_eq_iUnion]\n  exact isSigmaCompact_iUnion _ (fun \u27e8i', hi'\u27e9 \u21a6 hcomp i' hi')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nS : \u03b9 \u2192 Set X\nhc : s.Countable\nhcomp : \u2200 i \u2208 s, IsSigmaCompact (S i)\n\u22a2 IsSigmaCompact (\u22c3 i \u2208 s, S i)"}, {"line": "have : Countable \u2191s := countable_coe_iff.mpr hc", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nS : \u03b9 \u2192 Set X\nhc : s.Countable\nhcomp : \u2200 i \u2208 s, IsSigmaCompact (S i)\nthis : Countable \u2191s\n\u22a2 IsSigmaCompact (\u22c3 i \u2208 s, S i)"}, {"line": "rw [biUnion_eq_iUnion]", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nS : \u03b9 \u2192 Set X\nhc : s.Countable\nhcomp : \u2200 i \u2208 s, IsSigmaCompact (S i)\nthis : Countable \u2191s\n\u22a2 IsSigmaCompact (\u22c3 x, S \u2191x)"}, {"line": "exact isSigmaCompact_iUnion _ (fun \u27e8i', hi'\u27e9 \u21a6 hcomp i' hi')", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsSigmaCompact.of_isClosed_subset {s t : Set X} (ht : IsSigmaCompact t)\n    (hs : IsClosed s) (h : s \u2286 t) : IsSigmaCompact s := by\n  rcases ht with \u27e8K, hcompact, hcov\u27e9\n  refine \u27e8(fun n \u21a6 s \u2229 (K n)), fun n \u21a6 (hcompact n).inter_left hs, ?_\u27e9\n  rw [\u2190 inter_iUnion]\n  rw [hcov]\n  exact inter_eq_left.mpr h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nht : IsSigmaCompact t\nhs : IsClosed s\nh : s \u2286 t\n\u22a2 IsSigmaCompact s"}, {"line": "rcases ht with \u27e8K, hcompact, hcov\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsClosed s\nh : s \u2286 t\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = t\n\u22a2 IsSigmaCompact s"}, {"line": "refine \u27e8(fun n \u21a6 s \u2229 (K n)), fun n \u21a6 (hcompact n).inter_left hs, ?_\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsClosed s\nh : s \u2286 t\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = t\n\u22a2 \u22c3 n, (fun n => s \u2229 K n) n = s"}, {"line": "rw [\u2190 inter_iUnion]", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsClosed s\nh : s \u2286 t\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = t\n\u22a2 s \u2229 \u22c3 i, K i = s"}, {"line": "rw [hcov]", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsClosed s\nh : s \u2286 t\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = t\n\u22a2 s \u2229 t = s"}, {"line": "exact inter_eq_left.mpr h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsSigmaCompact.image_of_continuousOn {f : X \u2192 Y} {s : Set X} (hs : IsSigmaCompact s)\n    (hf : ContinuousOn f s) : IsSigmaCompact (f '' s) := by\n  rcases hs with \u27e8K, hcompact, hcov\u27e9\n  refine \u27e8fun n \u21a6 f '' K n, ?_, hcov.symm \u25b8 image_iUnion.symm\u27e9\n  exact fun n \u21a6 (hcompact n).image_of_continuousOn (hf.mono (hcov.symm \u25b8 subset_iUnion K n))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nhs : IsSigmaCompact s\nhf : ContinuousOn f s\n\u22a2 IsSigmaCompact (f '' s)"}, {"line": "rcases hs with \u27e8K, hcompact, hcov\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nhf : ContinuousOn f s\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = s\n\u22a2 IsSigmaCompact (f '' s)"}, {"line": "refine \u27e8fun n \u21a6 f '' K n, ?_, hcov.symm \u25b8 image_iUnion.symm\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nf : X \u2192 Y\ns : Set X\nhf : ContinuousOn f s\nK : \u2115 \u2192 Set X\nhcompact : \u2200 (n : \u2115), IsCompact (K n)\nhcov : \u22c3 n, K n = s\n\u22a2 \u2200 (n : \u2115), IsCompact ((fun n => f '' K n) n)"}, {"line": "exact fun n \u21a6 (hcompact n).image_of_continuousOn (hf.mono (hcov.symm \u25b8 subset_iUnion K n))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma SigmaCompactSpace_iff_exists_compact_covering :\n    SigmaCompactSpace X \u2194 \u2203 K : \u2115 \u2192 Set X, (\u2200 n, IsCompact (K n)) \u2227 \u22c3 n, K n = univ := by\n  rw [\u2190 isSigmaCompact_univ_iff]\n  rw [IsSigmaCompact]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 SigmaCompactSpace X \u2194 \u2203 K, (\u2200 (n : \u2115), IsCompact (K n)) \u2227 \u22c3 n, K n = univ"}, {"line": "rw [\u2190 isSigmaCompact_univ_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u22a2 IsSigmaCompact univ \u2194 \u2203 K, (\u2200 (n : \u2115), IsCompact (K n)) \u2227 \u22c3 n, K n = univ"}, {"line": "rw [IsSigmaCompact]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isSigmaCompact_iff_isSigmaCompact_univ {s : Set X} :\n    IsSigmaCompact s \u2194 IsSigmaCompact (univ : Set s) := by\n  rw [Subtype.isSigmaCompact_iff]\n  rw [image_univ]\n  rw [Subtype.range_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Compactness/SigmaCompact.lean", "context": {"open": ["Set Filter Topology TopologicalSpace"], "variables": ["{X : Type*} {Y : Type*} {\u03b9 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsSigmaCompact s \u2194 IsSigmaCompact univ"}, {"line": "rw [Subtype.isSigmaCompact_iff]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsSigmaCompact s \u2194 IsSigmaCompact (Subtype.val '' univ)"}, {"line": "rw [image_univ]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsSigmaCompact s \u2194 IsSigmaCompact (range Subtype.val)"}, {"line": "rw [Subtype.range_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPreconnected_of_forall_pair {s : Set \u03b1}\n    (H : \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 t, t \u2286 s \u2227 x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t) :\n    IsPreconnected s := by\n  rcases eq_empty_or_nonempty s with (rfl | \u27e8x, hx\u27e9)\n  exacts [isPreconnected_empty, isPreconnected_of_forall x fun y => H x hx y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nH : \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 t \u2286 s, x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t\n\u22a2 IsPreconnected s"}, {"line": "rcases eq_empty_or_nonempty s with (rfl | \u27e8x, hx\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nH : \u2200 x \u2208 \u2205, \u2200 y \u2208 \u2205, \u2203 t \u2286 \u2205, x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t\n\u22a2 IsPreconnected \u2205\n---\ncase inr.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\nH : \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 t \u2286 s, x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t\nx : \u03b1\nhx : x \u2208 s\n\u22a2 IsPreconnected s"}, {"line": "exacts [isPreconnected_empty, isPreconnected_of_forall x fun y => H x hx y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreconnected.union' {s t : Set \u03b1} (H : (s \u2229 t).Nonempty) (hs : IsPreconnected s)\n    (ht : IsPreconnected t) : IsPreconnected (s \u222a t) := by\n  rcases H with \u27e8x, hxs, hxt\u27e9\n  exact hs.union x hxs hxt ht\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nH : (s \u2229 t).Nonempty\nhs : IsPreconnected s\nht : IsPreconnected t\n\u22a2 IsPreconnected (s \u222a t)"}, {"line": "rcases H with \u27e8x, hxs, hxt\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nhs : IsPreconnected s\nht : IsPreconnected t\nx : \u03b1\nhxs : x \u2208 s\nhxt : x \u2208 t\n\u22a2 IsPreconnected (s \u222a t)"}, {"line": "exact hs.union x hxs hxt ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsConnected.union {s t : Set \u03b1} (H : (s \u2229 t).Nonempty) (Hs : IsConnected s)\n    (Ht : IsConnected t) : IsConnected (s \u222a t) := by\n  rcases H with \u27e8x, hx\u27e9\n  refine \u27e8\u27e8x, mem_union_left t (mem_of_mem_inter_left hx)\u27e9, ?_\u27e9\n  exact Hs.isPreconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx)\n    Ht.isPreconnected\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nH : (s \u2229 t).Nonempty\nHs : IsConnected s\nHt : IsConnected t\n\u22a2 IsConnected (s \u222a t)"}, {"line": "rcases H with \u27e8x, hx\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nHs : IsConnected s\nHt : IsConnected t\nx : \u03b1\nhx : x \u2208 s \u2229 t\n\u22a2 IsConnected (s \u222a t)"}, {"line": "refine \u27e8\u27e8x, mem_union_left t (mem_of_mem_inter_left hx)\u27e9, ?_\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns t : Set \u03b1\nHs : IsConnected s\nHt : IsConnected t\nx : \u03b1\nhx : x \u2208 s \u2229 t\n\u22a2 IsPreconnected (s \u222a t)"}, {"line": "exact Hs.isPreconnected.union x (mem_of_mem_inter_left hx) (mem_of_mem_inter_right hx)\n    Ht.isPreconnected", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreconnected.sUnion_directed {S : Set (Set \u03b1)} (K : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (H : \u2200 s \u2208 S, IsPreconnected s) : IsPreconnected (\u22c3\u2080 S) := by\n  rintro u v hu hv Huv \u27e8a, \u27e8s, hsS, has\u27e9, hau\u27e9 \u27e8b, \u27e8t, htS, hbt\u27e9, hbv\u27e9\n  obtain \u27e8r, hrS, hsr, htr\u27e9 : \u2203 r \u2208 S, s \u2286 r \u2227 t \u2286 r := K s hsS t htS\n  have Hnuv : (r \u2229 (u \u2229 v)).Nonempty :=\n    H _ hrS u v hu hv ((subset_sUnion_of_mem hrS).trans Huv) \u27e8a, hsr has, hau\u27e9 \u27e8b, htr hbt, hbv\u27e9\n  have Kruv : r \u2229 (u \u2229 v) \u2286 \u22c3\u2080 S \u2229 (u \u2229 v) := inter_subset_inter_left _ (subset_sUnion_of_mem hrS)\n  exact Hnuv.mono Kruv\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nK : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nH : \u2200 s \u2208 S, IsPreconnected s\n\u22a2 IsPreconnected (\u22c3\u2080 S)"}, {"line": "rintro u v hu hv Huv \u27e8a, \u27e8s, hsS, has\u27e9, hau\u27e9 \u27e8b, \u27e8t, htS, hbt\u27e9, hbv\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nK : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nH : \u2200 s \u2208 S, IsPreconnected s\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nHuv : \u22c3\u2080 S \u2286 u \u222a v\na : \u03b1\nhau : a \u2208 u\ns : Set \u03b1\nhsS : s \u2208 S\nhas : a \u2208 s\nb : \u03b1\nhbv : b \u2208 v\nt : Set \u03b1\nhtS : t \u2208 S\nhbt : b \u2208 t\n\u22a2 (\u22c3\u2080 S \u2229 (u \u2229 v)).Nonempty"}, {"line": "obtain \u27e8r, hrS, hsr, htr\u27e9 : \u2203 r \u2208 S, s \u2286 r \u2227 t \u2286 r := K s hsS t htS", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nK : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nH : \u2200 s \u2208 S, IsPreconnected s\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nHuv : \u22c3\u2080 S \u2286 u \u222a v\na : \u03b1\nhau : a \u2208 u\ns : Set \u03b1\nhsS : s \u2208 S\nhas : a \u2208 s\nb : \u03b1\nhbv : b \u2208 v\nt : Set \u03b1\nhtS : t \u2208 S\nhbt : b \u2208 t\nr : Set \u03b1\nhrS : r \u2208 S\nhsr : s \u2286 r\nhtr : t \u2286 r\n\u22a2 (\u22c3\u2080 S \u2229 (u \u2229 v)).Nonempty"}, {"line": "have Hnuv : (r \u2229 (u \u2229 v)).Nonempty :=\n    H _ hrS u v hu hv ((subset_sUnion_of_mem hrS).trans Huv) \u27e8a, hsr has, hau\u27e9 \u27e8b, htr hbt, hbv\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nK : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nH : \u2200 s \u2208 S, IsPreconnected s\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nHuv : \u22c3\u2080 S \u2286 u \u222a v\na : \u03b1\nhau : a \u2208 u\ns : Set \u03b1\nhsS : s \u2208 S\nhas : a \u2208 s\nb : \u03b1\nhbv : b \u2208 v\nt : Set \u03b1\nhtS : t \u2208 S\nhbt : b \u2208 t\nr : Set \u03b1\nhrS : r \u2208 S\nhsr : s \u2286 r\nhtr : t \u2286 r\nHnuv : (r \u2229 (u \u2229 v)).Nonempty\n\u22a2 (\u22c3\u2080 S \u2229 (u \u2229 v)).Nonempty"}, {"line": "have Kruv : r \u2229 (u \u2229 v) \u2286 \u22c3\u2080 S \u2229 (u \u2229 v) := inter_subset_inter_left _ (subset_sUnion_of_mem hrS)", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nS : Set (Set \u03b1)\nK : DirectedOn (fun x1 x2 => x1 \u2286 x2) S\nH : \u2200 s \u2208 S, IsPreconnected s\nu v : Set \u03b1\nhu : IsOpen u\nhv : IsOpen v\nHuv : \u22c3\u2080 S \u2286 u \u222a v\na : \u03b1\nhau : a \u2208 u\ns : Set \u03b1\nhsS : s \u2208 S\nhas : a \u2208 s\nb : \u03b1\nhbv : b \u2208 v\nt : Set \u03b1\nhtS : t \u2208 S\nhbt : b \u2208 t\nr : Set \u03b1\nhrS : r \u2208 S\nhsr : s \u2286 r\nhtr : t \u2286 r\nHnuv : (r \u2229 (u \u2229 v)).Nonempty\nKruv : r \u2229 (u \u2229 v) \u2286 \u22c3\u2080 S \u2229 (u \u2229 v)\n\u22a2 (\u22c3\u2080 S \u2229 (u \u2229 v)).Nonempty"}, {"line": "exact Hnuv.mono Kruv", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsPreconnected.image [TopologicalSpace \u03b2] {s : Set \u03b1} (H : IsPreconnected s)\n    (f : \u03b1 \u2192 \u03b2) (hf : ContinuousOn f s) : IsPreconnected (f '' s) := by\n  -- Unfold/destruct definitions in hypotheses\n  rintro u v hu hv huv \u27e8_, \u27e8x, xs, rfl\u27e9, xu\u27e9 \u27e8_, \u27e8y, ys, rfl\u27e9, yv\u27e9\n  rcases continuousOn_iff'.1 hf u hu with \u27e8u', hu', u'_eq\u27e9\n  rcases continuousOn_iff'.1 hf v hv with \u27e8v', hv', v'_eq\u27e9\n  -- Reformulate `huv : f '' s \u2286 u \u222a v` in terms of `u'` and `v'`\n  replace huv : s \u2286 u' \u222a v' := by\n    rw [image_subset_iff] at huv\n    rw [preimage_union] at huv\n    replace huv := subset_inter huv Subset.rfl\n    rw [union_inter_distrib_right] at huv\n    rw [u'_eq] at huv\n    rw [v'_eq] at huv\n    rw [\u2190 union_inter_distrib_right] at huv\n    exact (subset_inter_iff.1 huv).1\n  -- Now `s \u2286 u' \u222a v'`, so we can apply `\u2039IsPreconnected s\u203a`\n  obtain \u27e8z, hz\u27e9 : (s \u2229 (u' \u2229 v')).Nonempty := by\n    refine H u' v' hu' hv' huv \u27e8x, ?_\u27e9 \u27e8y, ?_\u27e9 <;> rw [inter_comm]\n    exacts [u'_eq \u25b8 \u27e8xu, xs\u27e9, v'_eq \u25b8 \u27e8yv, ys\u27e9]\n  rw [\u2190 inter_self s] at hz\n  rw [inter_assoc] at hz\n  rw [inter_left_comm s u'] at hz\n  rw [\u2190 inter_assoc] at hz\n  rw [inter_comm s] at hz\n  rw [inter_comm s] at hz\n  rw [\u2190 u'_eq] at hz\n  rw [\u2190 v'_eq] at hz\n  exact \u27e8f z, \u27e8z, hz.1.2, rfl\u27e9, hz.1.1, hz.2.1\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation", "Order"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]", "[LinearOrder \u03b2] [SuccOrder \u03b2] [IsSuccArchimedean \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\n\u22a2 IsPreconnected (f '' s)"}, {"line": "rintro u v hu hv huv \u27e8_, \u27e8x, xs, rfl\u27e9, xu\u27e9 \u27e8_, \u27e8y, ys, rfl\u27e9, yv\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nhuv : f '' s \u2286 u \u222a v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rcases continuousOn_iff'.1 hf u hu with \u27e8u', hu', u'_eq\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nhuv : f '' s \u2286 u \u222a v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rcases continuousOn_iff'.1 hf v hv with \u27e8v', hv', v'_eq\u27e9", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nhuv : f '' s \u2286 u \u222a v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "replace huv : s \u2286 u' \u222a v' := by\n    rw [image_subset_iff] at huv\n    rw [preimage_union] at huv\n    replace huv := subset_inter huv Subset.rfl\n    rw [union_inter_distrib_right] at huv\n    rw [u'_eq] at huv\n    rw [v'_eq] at huv\n    rw [\u2190 union_inter_distrib_right] at huv\n    exact (subset_inter_iff.1 huv).1", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "obtain \u27e8z, hz\u27e9 : (s \u2229 (u' \u2229 v')).Nonempty := by\n    refine H u' v' hu' hv' huv \u27e8x, ?_\u27e9 \u27e8y, ?_\u27e9 <;> rw [inter_comm]\n    exacts [u'_eq \u25b8 \u27e8xu, xs\u27e9, v'_eq \u25b8 \u27e8yv, ys\u27e9]", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 s \u2229 (u' \u2229 v')\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 inter_self s] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 s \u2229 s \u2229 (u' \u2229 v')\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_assoc] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 s \u2229 (s \u2229 (u' \u2229 v'))\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_left_comm s u'] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 s \u2229 (u' \u2229 (s \u2229 v'))\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 inter_assoc] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 s \u2229 u' \u2229 (s \u2229 v')\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_comm s] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 u' \u2229 s \u2229 (s \u2229 v')\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [inter_comm s] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 u' \u2229 s \u2229 (v' \u2229 s)\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 u'_eq] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 f \u207b\u00b9' u \u2229 s \u2229 (v' \u2229 s)\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "rw [\u2190 v'_eq] at hz", "tactic_state": "case intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : LinearOrder \u03b2\ninst\u271d\u00b2 : SuccOrder \u03b2\ninst\u271d\u00b9 : IsSuccArchimedean \u03b2\ninst\u271d : TopologicalSpace \u03b2\ns : Set \u03b1\nH : IsPreconnected s\nf : \u03b1 \u2192 \u03b2\nhf : ContinuousOn f s\nu v : Set \u03b2\nhu : IsOpen u\nhv : IsOpen v\nx : \u03b1\nxs : x \u2208 s\nxu : f x \u2208 u\ny : \u03b1\nys : y \u2208 s\nyv : f y \u2208 v\nu' : Set \u03b1\nhu' : IsOpen u'\nu'_eq : f \u207b\u00b9' u \u2229 s = u' \u2229 s\nv' : Set \u03b1\nhv' : IsOpen v'\nv'_eq : f \u207b\u00b9' v \u2229 s = v' \u2229 s\nhuv : s \u2286 u' \u222a v'\nz : \u03b1\nhz : z \u2208 f \u207b\u00b9' u \u2229 s \u2229 (f \u207b\u00b9' v \u2229 s)\n\u22a2 (f '' s \u2229 (u \u2229 v)).Nonempty"}, {"line": "exact \u27e8f z, \u27e8z, hz.1.2, rfl\u27e9, hz.1.1, hz.2.1\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_connectedComponentIn {x : \u03b1} {F : Set \u03b1} (hx : x \u2208 F) :\n    x \u2208 connectedComponentIn F x := by\n  simp [connectedComponentIn_eq_image hx, mem_connectedComponent, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Basic.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation", "Order", "Classical in"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]", "[LinearOrder \u03b2] [SuccOrder \u03b2] [IsSuccArchimedean \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\n\u22a2 x \u2208 sorry"}, {"line": "simp [connectedComponentIn_eq_image hx, mem_connectedComponent, hx]", "tactic_state": "\u03b1 : Type u_1\nx : \u03b1\nF : Set \u03b1\nhx : x \u2208 F\n\u22a2 x \u2208 sorry ()"}]}
{"declaration": "theorem LocPathConnectedSpace.of_bases {p : X \u2192 \u03b9 \u2192 Prop} {s : X \u2192 \u03b9 \u2192 Set X}\n    (h : \u2200 x, (\ud835\udcdd x).HasBasis (p x) (s x)) (h' : \u2200 x i, p x i \u2192 IsPathConnected (s x i)) :\n    LocPathConnectedSpace X where\n  path_connected_basis x := by\n    rw [hasBasis_self]\n    intro t ht\n    rcases (h x).mem_iff.mp ht with \u27e8i, hpi, hi\u27e9\n    exact \u27e8s x i, (h x).mem_of_mem hpi, h' x i hpi, hi\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Type u_3\np : X \u2192 \u03b9 \u2192 Prop\ns : X \u2192 \u03b9 \u2192 Set X\nh : \u2200 (x : X), (nhds x).HasBasis (p x) (s x)\nh' : \u2200 (x : X) (i : \u03b9), p x i \u2192 IsPathConnected (s x i)\nx : X\n\u22a2 (nhds x).HasBasis (fun s => s \u2208 nhds x \u2227 IsPathConnected s) id"}, {"line": "rw [hasBasis_self]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Type u_3\np : X \u2192 \u03b9 \u2192 Prop\ns : X \u2192 \u03b9 \u2192 Set X\nh : \u2200 (x : X), (nhds x).HasBasis (p x) (s x)\nh' : \u2200 (x : X) (i : \u03b9), p x i \u2192 IsPathConnected (s x i)\nx : X\n\u22a2 \u2200 t \u2208 nhds x, \u2203 r \u2208 nhds x, IsPathConnected r \u2227 r \u2286 t"}, {"line": "intro t ht", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Type u_3\np : X \u2192 \u03b9 \u2192 Prop\ns : X \u2192 \u03b9 \u2192 Set X\nh : \u2200 (x : X), (nhds x).HasBasis (p x) (s x)\nh' : \u2200 (x : X) (i : \u03b9), p x i \u2192 IsPathConnected (s x i)\nx : X\nt : Set X\nht : t \u2208 nhds x\n\u22a2 \u2203 r \u2208 nhds x, IsPathConnected r \u2227 r \u2286 t"}, {"line": "rcases (h x).mem_iff.mp ht with \u27e8i, hpi, hi\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\n\u03b9 : Type u_3\np : X \u2192 \u03b9 \u2192 Prop\ns : X \u2192 \u03b9 \u2192 Set X\nh : \u2200 (x : X), (nhds x).HasBasis (p x) (s x)\nh' : \u2200 (x : X) (i : \u03b9), p x i \u2192 IsPathConnected (s x i)\nx : X\nt : Set X\nht : t \u2208 nhds x\ni : \u03b9\nhpi : p x i\nhi : s x i \u2286 t\n\u22a2 \u2203 r \u2208 nhds x, IsPathConnected r \u2227 r \u2286 t"}, {"line": "exact \u27e8s x i, (h x).mem_of_mem hpi, h' x i hpi, hi\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsOpen.pathComponent (x : X) : IsOpen (pathComponent x) := by\n  rw [\u2190 pathComponentIn_univ]\n  exact isOpen_univ.pathComponentIn _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}", "[LocPathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nx : X\n\u22a2 IsOpen (pathComponent x)"}, {"line": "rw [\u2190 pathComponentIn_univ]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nx : X\n\u22a2 IsOpen (pathComponentIn x univ)"}, {"line": "exact isOpen_univ.pathComponentIn _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pathComponentIn_mem_nhds (hF : F \u2208 \ud835\udcdd x) : pathComponentIn x F \u2208 \ud835\udcdd x := by\n  let \u27e8u, huF, hu, hxu\u27e9 := mem_nhds_iff.mp hF\n  exact mem_nhds_iff.mpr \u27e8pathComponentIn x u, pathComponentIn_mono huF,\n    hu.pathComponentIn x, mem_pathComponentIn_self hxu\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}", "[LocPathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\nF : Set X\ninst\u271d : LocPathConnectedSpace X\nhF : F \u2208 nhds x\n\u22a2 pathComponentIn x F \u2208 nhds x"}, {"line": "let \u27e8u, huF, hu, hxu\u27e9 := mem_nhds_iff.mp hF", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nx : X\nF : Set X\ninst\u271d : LocPathConnectedSpace X\nhF : F \u2208 nhds x\nu : Set X\nhuF : u \u2286 F\nhu : IsOpen u\nhxu : x \u2208 u\n\u22a2 pathComponentIn x F \u2208 nhds x"}, {"line": "exact mem_nhds_iff.mpr \u27e8pathComponentIn x u, pathComponentIn_mono huF,\n    hu.pathComponentIn x, mem_pathComponentIn_self hxu\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_isPathConnected_basis (x : X) :\n    (\ud835\udcdd x).HasBasis (fun s : Set X \u21a6 IsOpen s \u2227 x \u2208 s \u2227 IsPathConnected s) id := by\n  refine \u27e8fun s \u21a6 \u27e8fun hs \u21a6 ?_, fun \u27e8u, hu\u27e9 \u21a6 mem_nhds_iff.mpr \u27e8u, hu.2, hu.1.1, hu.1.2.1\u27e9\u27e9\u27e9\n  have \u27e8u, hus, hu, hxu\u27e9 := mem_nhds_iff.mp hs\n  exact \u27e8pathComponentIn x u, \u27e8hu.pathComponentIn _, \u27e8mem_pathComponentIn_self hxu,\n    isPathConnected_pathComponentIn hxu\u27e9\u27e9, pathComponentIn_subset.trans hus\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}", "[LocPathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nx : X\n\u22a2 (nhds x).HasBasis (fun s => IsOpen s \u2227 x \u2208 s \u2227 IsPathConnected s) id"}, {"line": "refine \u27e8fun s \u21a6 \u27e8fun hs \u21a6 ?_, fun \u27e8u, hu\u27e9 \u21a6 mem_nhds_iff.mpr \u27e8u, hu.2, hu.1.1, hu.1.2.1\u27e9\u27e9\u27e9", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nx : X\ns : Set X\nhs : s \u2208 nhds x\n\u22a2 \u2203 i, (IsOpen i \u2227 x \u2208 i \u2227 IsPathConnected i) \u2227 id i \u2286 s"}, {"line": "have \u27e8u, hus, hu, hxu\u27e9 := mem_nhds_iff.mp hs", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nx : X\ns : Set X\nhs : s \u2208 nhds x\nu : Set X\nhus : u \u2286 s\nhu : IsOpen u\nhxu : x \u2208 u\n\u22a2 \u2203 i, (IsOpen i \u2227 x \u2208 i \u2227 IsPathConnected i) \u2227 id i \u2286 s"}, {"line": "exact \u27e8pathComponentIn x u, \u27e8hu.pathComponentIn _, \u27e8mem_pathComponentIn_self hxu,\n    isPathConnected_pathComponentIn hxu\u27e9\u27e9, pathComponentIn_subset.trans hus\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsOpen.isConnected_iff_isPathConnected {U : Set X} (U_op : IsOpen U) :\n    IsConnected U \u2194 IsPathConnected U := by\n  rw [isConnected_iff_connectedSpace]\n  rw [isPathConnected_iff_pathConnectedSpace]\n  haveI := U_op.locPathConnectedSpace\n  exact pathConnectedSpace_iff_connectedSpace.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}", "[LocPathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\n\u22a2 IsConnected U \u2194 IsPathConnected U"}, {"line": "rw [isConnected_iff_connectedSpace]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\n\u22a2 ConnectedSpace \u2191U \u2194 IsPathConnected U"}, {"line": "rw [isPathConnected_iff_pathConnectedSpace]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\n\u22a2 ConnectedSpace \u2191U \u2194 PathConnectedSpace \u2191U"}, {"line": "haveI := U_op.locPathConnectedSpace", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : LocPathConnectedSpace X\nU : Set X\nU_op : IsOpen U\nthis : LocPathConnectedSpace \u2191U\n\u22a2 ConnectedSpace \u2191U \u2194 PathConnectedSpace \u2191U"}, {"line": "exact pathConnectedSpace_iff_connectedSpace.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma locPathConnectedSpace_iff_pathComponentIn_mem_nhds {X : Type*} [TopologicalSpace X] :\n    LocPathConnectedSpace X \u2194\n    \u2200 x : X, \u2200 u : Set X, IsOpen u \u2192 x \u2208 u \u2192 pathComponentIn x u \u2208 nhds x := by\n  rw [locPathConnectedSpace_iff_isOpen_pathComponentIn]\n  simp_rw [forall_comm (\u03b2 := Set X), \u2190 imp_forall_iff]\n  refine forall_congr' fun u \u21a6 imp_congr_right fun _ \u21a6 ?_\n  exact \u27e8fun h x hxu \u21a6 (h x).mem_nhds (mem_pathComponentIn_self hxu),\n    fun h x \u21a6 isOpen_iff_mem_nhds.mpr fun y hy \u21a6\n      pathComponentIn_congr hy \u25b8 h y <| pathComponentIn_subset hy\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocPathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*} {F : Set X}", "[LocPathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u22a2 LocPathConnectedSpace X \u2194 \u2200 (x : X) (u : Set X), IsOpen u \u2192 x \u2208 u \u2192 pathComponentIn x u \u2208 nhds x"}, {"line": "rw [locPathConnectedSpace_iff_isOpen_pathComponentIn]", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (x : X) (u : Set X), IsOpen u \u2192 IsOpen (pathComponentIn x u)) \u2194\n    \u2200 (x : X) (u : Set X), IsOpen u \u2192 x \u2208 u \u2192 pathComponentIn x u \u2208 nhds x"}, {"line": "simp_rw [forall_comm (\u03b2 := Set X), \u2190 imp_forall_iff]", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\n\u22a2 (\u2200 (b : Set X), IsOpen b \u2192 \u2200 (x : X), IsOpen (pathComponentIn x b)) \u2194\n    \u2200 (b : Set X), IsOpen b \u2192 \u2200 x \u2208 b, pathComponentIn x b \u2208 nhds x"}, {"line": "refine forall_congr' fun u \u21a6 imp_congr_right fun _ \u21a6 ?_", "tactic_state": "X : Type u_4\ninst\u271d : TopologicalSpace X\nu : Set X\nx\u271d : IsOpen u\n\u22a2 (\u2200 (x : X), IsOpen (pathComponentIn x u)) \u2194 \u2200 x \u2208 u, pathComponentIn x u \u2208 nhds x"}, {"line": "exact \u27e8fun h x hxu \u21a6 (h x).mem_nhds (mem_pathComponentIn_self hxu),\n    fun h x \u21a6 isOpen_iff_mem_nhds.mpr fun y hy \u21a6\n      pathComponentIn_congr hy \u25b8 h y <| pathComponentIn_subset hy\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem connectedComponentIn_mem_nhds [LocallyConnectedSpace \u03b1] {F : Set \u03b1} {x : \u03b1} (h : F \u2208 \ud835\udcdd x) :\n    connectedComponentIn F x \u2208 \ud835\udcdd x := by\n  rw [(LocallyConnectedSpace.open_connected_basis x).mem_iff] at h\n  rcases h with \u27e8s, \u27e8h1s, hxs, h2s\u27e9, hsF\u27e9\n  exact mem_nhds_iff.mpr \u27e8s, h2s.isPreconnected.subset_connectedComponentIn hxs hsF, h1s, hxs\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocallyConnected.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\nh : F \u2208 nhds x\n\u22a2 connectedComponentIn F x \u2208 nhds x"}, {"line": "rw [(LocallyConnectedSpace.open_connected_basis x).mem_iff] at h", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\nh : \u2203 i, (IsOpen i \u2227 x \u2208 i \u2227 IsConnected i) \u2227 id i \u2286 F\n\u22a2 connectedComponentIn F x \u2208 nhds x\n---\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\nh : F \u2208 nhds x\n\u22a2 LocallyConnectedSpace \u03b1"}, {"line": "rcases h with \u27e8s, \u27e8h1s, hxs, h2s\u27e9, hsF\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\ns : Set \u03b1\nhsF : id s \u2286 F\nh1s : IsOpen s\nhxs : x \u2208 s\nh2s : IsConnected s\n\u22a2 connectedComponentIn F x \u2208 nhds x\n---\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\nh : F \u2208 nhds x\n\u22a2 LocallyConnectedSpace \u03b1"}, {"line": "exact mem_nhds_iff.mpr \u27e8s, h2s.isPreconnected.subset_connectedComponentIn hxs hsF, h1s, hxs\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nF : Set \u03b1\nx : \u03b1\nh : F \u2208 nhds x\n\u22a2 LocallyConnectedSpace \u03b1"}]}
{"declaration": "theorem isOpen_connectedComponent [LocallyConnectedSpace \u03b1] {x : \u03b1} :\n    IsOpen (connectedComponent x) := by\n  rw [\u2190 connectedComponentIn_univ]\n  exact isOpen_univ.connectedComponentIn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocallyConnected.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nx : \u03b1\n\u22a2 IsOpen (connectedComponent x)"}, {"line": "rw [\u2190 connectedComponentIn_univ]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : LocallyConnectedSpace \u03b1\nx : \u03b1\n\u22a2 IsOpen (connectedComponentIn univ x)"}, {"line": "exact isOpen_univ.connectedComponentIn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyConnectedSpace_iff_connectedComponentIn_open :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 F : Set \u03b1, IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x) := by\n  constructor\n  \u00b7 intro h\n    exact fun F hF x _ => hF.connectedComponentIn\n  \u00b7 intro h\n    rw [locallyConnectedSpace_iff_subsets_isOpen_isConnected]\n    refine fun x U hU =>\n        \u27e8connectedComponentIn (interior U) x,\n          (connectedComponentIn_subset _ _).trans interior_subset, h _ isOpen_interior x ?_,\n          mem_connectedComponentIn ?_, isConnected_connectedComponentIn_iff.mpr ?_\u27e9 <;>\n      exact mem_interior_iff_mem_nhds.mpr hU\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocallyConnected.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 LocallyConnectedSpace \u03b1 \u2194 \u2200 (F : Set \u03b1), IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x)"}, {"line": "constructor", "tactic_state": "case mp\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 LocallyConnectedSpace \u03b1 \u2192 \u2200 (F : Set \u03b1), IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x)\n---\ncase mpr\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (F : Set \u03b1), IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x)) \u2192 LocallyConnectedSpace \u03b1"}, {"line": "\u00b7 intro h\n    exact fun F hF x _ => hF.connectedComponentIn", "tactic_state": "case mpr\n\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (F : Set \u03b1), IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x)) \u2192 LocallyConnectedSpace \u03b1"}, {"line": "\u00b7 intro h\n    rw [locallyConnectedSpace_iff_subsets_isOpen_isConnected]\n    refine fun x U hU =>\n        \u27e8connectedComponentIn (interior U) x,\n          (connectedComponentIn_subset _ _).trans interior_subset, h _ isOpen_interior x ?_,\n          mem_connectedComponentIn ?_, isConnected_connectedComponentIn_iff.mpr ?_\u27e9 <;>\n      exact mem_interior_iff_mem_nhds.mpr hU", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyConnectedSpace_iff_connected_basis :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 x, (\ud835\udcdd x).HasBasis (fun s : Set \u03b1 => s \u2208 \ud835\udcdd x \u2227 IsPreconnected s) id := by\n  rw [locallyConnectedSpace_iff_connected_subsets]\n  exact forall_congr' fun x => Filter.hasBasis_self.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocallyConnected.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 LocallyConnectedSpace \u03b1 \u2194 \u2200 (x : \u03b1), (nhds x).HasBasis (fun s => s \u2208 nhds x \u2227 IsPreconnected s) id"}, {"line": "rw [locallyConnectedSpace_iff_connected_subsets]", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 (x : \u03b1), \u2200 U \u2208 nhds x, \u2203 V \u2208 nhds x, IsPreconnected V \u2227 V \u2286 U) \u2194\n    \u2200 (x : \u03b1), (nhds x).HasBasis (fun s => s \u2208 nhds x \u2227 IsPreconnected s) id"}, {"line": "exact forall_congr' fun x => Filter.hasBasis_self.symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem locallyConnectedSpace_of_connected_bases {\u03b9 : Type*} (b : \u03b1 \u2192 \u03b9 \u2192 Set \u03b1) (p : \u03b1 \u2192 \u03b9 \u2192 Prop)\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (p x) (b x))\n    (hconnected : \u2200 x i, p x i \u2192 IsPreconnected (b x i)) : LocallyConnectedSpace \u03b1 := by\n  rw [locallyConnectedSpace_iff_connected_basis]\n  exact fun x =>\n    (hbasis x).to_hasBasis\n      (fun i hi => \u27e8b x i, \u27e8(hbasis x).mem_of_mem hi, hconnected x i hi\u27e9, subset_rfl\u27e9) fun s hs =>\n      \u27e8(hbasis x).index s hs.1, \u27e8(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/LocallyConnected.lean", "context": {"open": ["Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b1 \u2192 \u03b9 \u2192 Set \u03b1\np : \u03b1 \u2192 \u03b9 \u2192 Prop\nhbasis : \u2200 (x : \u03b1), (nhds x).HasBasis (p x) (b x)\nhconnected : \u2200 (x : \u03b1) (i : \u03b9), p x i \u2192 IsPreconnected (b x i)\n\u22a2 LocallyConnectedSpace \u03b1"}, {"line": "rw [locallyConnectedSpace_iff_connected_basis]", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\n\u03b9 : Type u_3\nb : \u03b1 \u2192 \u03b9 \u2192 Set \u03b1\np : \u03b1 \u2192 \u03b9 \u2192 Prop\nhbasis : \u2200 (x : \u03b1), (nhds x).HasBasis (p x) (b x)\nhconnected : \u2200 (x : \u03b1) (i : \u03b9), p x i \u2192 IsPreconnected (b x i)\n\u22a2 \u2200 (x : \u03b1), (nhds x).HasBasis (fun s => s \u2208 nhds x \u2227 IsPreconnected s) id"}, {"line": "exact fun x =>\n    (hbasis x).to_hasBasis\n      (fun i hi => \u27e8b x i, \u27e8(hbasis x).mem_of_mem hi, hconnected x i hi\u27e9, subset_rfl\u27e9) fun s hs =>\n      \u27e8(hbasis x).index s hs.1, \u27e8(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma totallyDisconnectedSpace_subtype_iff {s : Set \u03b1} :\n    TotallyDisconnectedSpace s \u2194 IsTotallyDisconnected s := by\n  rw [\u2190 IsEmbedding.subtypeVal.isTotallyDisconnected_range]\n  rw [Subtype.range_val]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/TotallyDisconnected.lean", "context": {"open": ["Function Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\n\u22a2 TotallyDisconnectedSpace \u2191s \u2194 IsTotallyDisconnected s"}, {"line": "rw [\u2190 IsEmbedding.subtypeVal.isTotallyDisconnected_range]", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\ns : Set \u03b1\n\u22a2 IsTotallyDisconnected (range Subtype.val) \u2194 IsTotallyDisconnected s"}, {"line": "rw [Subtype.range_val]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem totallySeparatedSpace_iff_exists_isClopen {\u03b1 : Type*} [TopologicalSpace \u03b1] :\n    TotallySeparatedSpace \u03b1 \u2194 Pairwise (\u2203 U : Set \u03b1, IsClopen U \u2227 \u00b7 \u2208 U \u2227 \u00b7 \u2208 U\u1d9c) := by\n  simp only [totallySeparatedSpace_iff]\n  simp only [IsTotallySeparated]\n  simp only [Set.Pairwise]\n  simp only [mem_univ]\n  simp only [true_implies]\n  refine forall\u2083_congr fun x y _ \u21a6\n    \u27e8fun \u27e8U, V, hU, hV, Ux, Vy, f, disj\u27e9 \u21a6 ?_, fun \u27e8U, hU, Ux, Ucy\u27e9 \u21a6 ?_\u27e9\n  \u00b7 exact \u27e8U, isClopen_of_disjoint_cover_open f hU hV disj,\n      Ux, fun Uy \u21a6 Set.disjoint_iff.mp disj \u27e8Uy, Vy\u27e9\u27e9\n  \u00b7 exact \u27e8U, U\u1d9c, hU.2, hU.compl.2, Ux, Ucy, (Set.union_compl_self U).ge, disjoint_compl_right\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/TotallyDisconnected.lean", "context": {"open": ["Function Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 TotallySeparatedSpace \u03b1 \u2194 Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "simp only [totallySeparatedSpace_iff]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 IsTotallySeparated univ \u2194 Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "simp only [IsTotallySeparated]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (univ.Pairwise fun x y => \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v) \u2194\n    Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "simp only [Set.Pairwise]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984,\n      x \u2208 univ \u2192\n        \u2200 \u2983y : \u03b1\u2984, y \u2208 univ \u2192 x \u2260 y \u2192 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v) \u2194\n    Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "simp only [mem_univ]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 \u2983x : \u03b1\u2984,\n      True \u2192 \u2200 \u2983y : \u03b1\u2984, True \u2192 x \u2260 y \u2192 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v) \u2194\n    Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "simp only [true_implies]", "tactic_state": "\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\n\u22a2 (\u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v) \u2194\n    Pairwise fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c"}, {"line": "refine forall\u2083_congr fun x y _ \u21a6\n    \u27e8fun \u27e8U, V, hU, hV, Ux, Vy, f, disj\u27e9 \u21a6 ?_, fun \u27e8U, hU, Ux, Ucy\u27e9 \u21a6 ?_\u27e9", "tactic_state": "case refine_1\n\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\nx y : \u03b1\nx\u271d\u00b9 : x \u2260 y\nx\u271d : \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v\nU V : Set \u03b1\nhU : IsOpen U\nhV : IsOpen V\nUx : x \u2208 U\nVy : y \u2208 V\nf : univ \u2286 U \u222a V\ndisj : Disjoint U V\n\u22a2 (fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c) x y\n---\ncase refine_2\n\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\nx y : \u03b1\nx\u271d\u00b9 : x \u2260 y\nx\u271d : (fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c) x y\nU : Set \u03b1\nhU : IsClopen U\nUx : x \u2208 U\nUcy : y \u2208 U\u1d9c\n\u22a2 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v"}, {"line": "\u00b7 exact \u27e8U, isClopen_of_disjoint_cover_open f hU hV disj,\n      Ux, fun Uy \u21a6 Set.disjoint_iff.mp disj \u27e8Uy, Vy\u27e9\u27e9", "tactic_state": "case refine_2\n\u03b1 : Type u_3\ninst\u271d : TopologicalSpace \u03b1\nx y : \u03b1\nx\u271d\u00b9 : x \u2260 y\nx\u271d : (fun x1 x2 => \u2203 U, IsClopen U \u2227 x1 \u2208 U \u2227 x2 \u2208 U\u1d9c) x y\nU : Set \u03b1\nhU : IsClopen U\nUx : x \u2208 U\nUcy : y \u2208 U\u1d9c\n\u22a2 \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 univ \u2286 u \u222a v \u2227 Disjoint u v"}, {"line": "\u00b7 exact \u27e8U, U\u1d9c, hU.2, hU.compl.2, Ux, Ucy, (Set.union_compl_self U).ge, disjoint_compl_right\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreconnected.constant_of_mapsTo {S : Set \u03b1} (hS : IsPreconnected S)\n    {\u03b2} [TopologicalSpace \u03b2] {T : Set \u03b2} [DiscreteTopology T] {f : \u03b1 \u2192 \u03b2} (hc : ContinuousOn f S)\n    (hTm : MapsTo f S T) {x y : \u03b1} (hx : x \u2208 S) (hy : y \u2208 S) : f x = f y := by\n  let F : S \u2192 T := hTm.restrict f S T\n  suffices F \u27e8x, hx\u27e9 = F \u27e8y, hy\u27e9 by rwa [\u2190 Subtype.coe_inj] at this\n  exact (isPreconnected_iff_preconnectedSpace.mp hS).constant (hc.restrict_mapsTo _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/TotallyDisconnected.lean", "context": {"open": ["Function Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]", "[TopologicalSpace \u03b2] [TotallyDisconnectedSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nx y : \u03b1\nhx : x \u2208 S\nhy : y \u2208 S\n\u22a2 f x = f y"}, {"line": "let F : S \u2192 T := hTm.restrict f S T", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nx y : \u03b1\nhx : x \u2208 S\nhy : y \u2208 S\nF : \u2191S \u2192 \u2191T := MapsTo.restrict f S T hTm\n\u22a2 f x = f y"}, {"line": "suffices F \u27e8x, hx\u27e9 = F \u27e8y, hy\u27e9 by rwa [\u2190 Subtype.coe_inj] at this", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nx y : \u03b1\nhx : x \u2208 S\nhy : y \u2208 S\nF : \u2191S \u2192 \u2191T := MapsTo.restrict f S T hTm\n\u22a2 F \u27e8x, hx\u27e9 = F \u27e8y, hy\u27e9"}, {"line": "exact (isPreconnected_iff_preconnectedSpace.mp hS).constant (hc.restrict_mapsTo _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPreconnected.eqOn_const_of_mapsTo {S : Set \u03b1} (hS : IsPreconnected S)\n    {\u03b2} [TopologicalSpace \u03b2] {T : Set \u03b2} [DiscreteTopology T] {f : \u03b1 \u2192 \u03b2} (hc : ContinuousOn f S)\n    (hTm : MapsTo f S T) (hne : T.Nonempty) : \u2203 y \u2208 T, EqOn f (const \u03b1 y) S := by\n  rcases S.eq_empty_or_nonempty with (rfl | \u27e8x, hx\u27e9)\n  \u00b7 exact hne.imp fun _ hy => \u27e8hy, eqOn_empty _ _\u27e9\n  \u00b7 exact \u27e8f x, hTm hx, fun x' hx' => hS.constant_of_mapsTo hc hTm hx' hx\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/TotallyDisconnected.lean", "context": {"open": ["Function Set Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]", "[TopologicalSpace \u03b2] [TotallyDisconnectedSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nhne : T.Nonempty\n\u22a2 \u2203 y \u2208 T, EqOn f (const \u03b1 y) S"}, {"line": "rcases S.eq_empty_or_nonempty with (rfl | \u27e8x, hx\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhne : T.Nonempty\nhS : IsPreconnected \u2205\nhc : ContinuousOn f \u2205\nhTm : MapsTo f \u2205 T\n\u22a2 \u2203 y \u2208 T, EqOn f (const \u03b1 y) \u2205\n---\ncase inr.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nhne : T.Nonempty\nx : \u03b1\nhx : x \u2208 S\n\u22a2 \u2203 y \u2208 T, EqOn f (const \u03b1 y) S"}, {"line": "\u00b7 exact hne.imp fun _ hy => \u27e8hy, eqOn_empty _ _\u27e9", "tactic_state": "case inr.intro\n\u03b1 : Type u\ninst\u271d\u00b2 : TopologicalSpace \u03b1\nS : Set \u03b1\nhS : IsPreconnected S\n\u03b2 : Type u_3\ninst\u271d\u00b9 : TopologicalSpace \u03b2\nT : Set \u03b2\ninst\u271d : DiscreteTopology \u2191T\nf : \u03b1 \u2192 \u03b2\nhc : ContinuousOn f S\nhTm : MapsTo f S T\nhne : T.Nonempty\nx : \u03b1\nhx : x \u2208 S\n\u22a2 \u2203 y \u2208 T, EqOn f (const \u03b1 y) S"}, {"line": "\u00b7 exact \u27e8f x, hTm hx, fun x' hx' => hS.constant_of_mapsTo hc hTm hx' hx\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.exists_lift_sigma [ConnectedSpace \u03b1] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    {f : \u03b1 \u2192 \u03a3 i, \u03c0 i} (hf : Continuous f) :\n    \u2203 (i : \u03b9) (g : \u03b1 \u2192 \u03c0 i), Continuous g \u2227 f = Sigma.mk i \u2218 g := by\n  obtain \u27e8i, hi\u27e9 : \u2203 i, range f \u2286 range (.mk i) := by\n    rcases Sigma.isConnected_iff.1 (isConnected_range hf) with \u27e8i, s, -, hs\u27e9\n    exact \u27e8i, hs.trans_subset (image_subset_range _ _)\u27e9\n  rcases range_subset_range_iff_exists_comp.1 hi with \u27e8g, rfl\u27e9\n  refine \u27e8i, g, ?_, rfl\u27e9\n  rwa [\u2190 IsEmbedding.sigmaMk.continuous_iff] at hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/Clopen.lean", "context": {"open": ["Set Function Topology TopologicalSpace Relation"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [TopologicalSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ConnectedSpace \u03b1\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : \u03b1 \u2192 (i : \u03b9) \u00d7 \u03c0 i\nhf : Continuous f\n\u22a2 \u2203 i g, Continuous g \u2227 f = Sigma.mk i \u2218 g"}, {"line": "obtain \u27e8i, hi\u27e9 : \u2203 i, range f \u2286 range (.mk i) := by\n    rcases Sigma.isConnected_iff.1 (isConnected_range hf) with \u27e8i, s, -, hs\u27e9\n    exact \u27e8i, hs.trans_subset (image_subset_range _ _)\u27e9", "tactic_state": "case intro\n\u03b1 : Type u\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ConnectedSpace \u03b1\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\nf : \u03b1 \u2192 (i : \u03b9) \u00d7 \u03c0 i\nhf : Continuous f\ni : \u03b9\nhi : range f \u2286 range (Sigma.mk i)\n\u22a2 \u2203 i g, Continuous g \u2227 f = Sigma.mk i \u2218 g"}, {"line": "rcases range_subset_range_iff_exists_comp.1 hi with \u27e8g, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ConnectedSpace \u03b1\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ni : \u03b9\ng : \u03b1 \u2192 \u03c0 i\nhf : Continuous (Sigma.mk i \u2218 g)\nhi : range (Sigma.mk i \u2218 g) \u2286 range (Sigma.mk i)\n\u22a2 \u2203 i_1 g_1, Continuous g_1 \u2227 Sigma.mk i \u2218 g = Sigma.mk i_1 \u2218 g_1"}, {"line": "refine \u27e8i, g, ?_, rfl\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b9 : Type u_1\n\u03c0 : \u03b9 \u2192 Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : ConnectedSpace \u03b1\ninst\u271d : (i : \u03b9) \u2192 TopologicalSpace (\u03c0 i)\ni : \u03b9\ng : \u03b1 \u2192 \u03c0 i\nhf : Continuous (Sigma.mk i \u2218 g)\nhi : range (Sigma.mk i \u2218 g) \u2286 range (Sigma.mk i)\n\u22a2 Continuous g"}, {"line": "rwa [\u2190 IsEmbedding.sigmaMk.continuous_iff] at hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem joinedIn_univ : JoinedIn univ x y \u2194 Joined x y := by\n  simp [JoinedIn, Joined, exists_true_iff_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx y : X\n\u22a2 JoinedIn univ x y \u2194 Joined x y"}, {"line": "simp [JoinedIn, Joined, exists_true_iff_nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Topology.IsInducing.joinedIn_image {f : X \u2192 Y} (hf : IsInducing f) (hx : x \u2208 F)\n    (hy : y \u2208 F) : JoinedIn (f '' F) (f x) (f y) \u2194 JoinedIn F x y := by\n  refine \u27e8?_, (.map \u00b7 hf.continuous)\u27e9\n  rintro \u27e8\u03b3, h\u03b3\u27e9\n  choose \u03b3' h\u03b3'F h\u03b3' using h\u03b3\n  have h\u2080 : x \u2933 \u03b3' 0 := by rw [\u2190 hf.specializes_iff, h\u03b3', \u03b3.source]\n  have h\u2081 : \u03b3' 1 \u2933 y := by rw [\u2190 hf.specializes_iff, h\u03b3', \u03b3.target]\n  have h : JoinedIn F (\u03b3' 0) (\u03b3' 1) := by\n    refine \u27e8\u27e8\u27e8\u03b3', ?_\u27e9, rfl, rfl\u27e9, h\u03b3'F\u27e9\n    simpa only [hf.continuous_iff,comp_def,h\u03b3'] using map_continuous \u03b3\n  exact (h\u2080.joinedIn hx (h\u03b3'F _)).trans <| h.trans <| h\u2081.joinedIn (h\u03b3'F _) hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 JoinedIn (f '' F) (f x) (f y) \u2194 JoinedIn F x y"}, {"line": "refine \u27e8?_, (.map \u00b7 hf.continuous)\u27e9", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u22a2 JoinedIn (f '' F) (f x) (f y) \u2192 JoinedIn F x y"}, {"line": "rintro \u27e8\u03b3, h\u03b3\u27e9", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u03b3 : Path (f x) (f y)\nh\u03b3 : \u2200 (t : \u2191unitInterval), \u03b3 t \u2208 f '' F\n\u22a2 JoinedIn F x y"}, {"line": "choose \u03b3' h\u03b3'F h\u03b3' using h\u03b3", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u03b3 : Path (f x) (f y)\n\u03b3' : \u2191unitInterval \u2192 X\nh\u03b3'F : \u2200 (t : \u2191unitInterval), \u03b3' t \u2208 F\nh\u03b3' : \u2200 (t : \u2191unitInterval), f (\u03b3' t) = \u03b3 t\n\u22a2 JoinedIn F x y"}, {"line": "have h\u2080 : x \u2933 \u03b3' 0 := sorry", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u03b3 : Path (f x) (f y)\n\u03b3' : \u2191unitInterval \u2192 X\nh\u03b3'F : \u2200 (t : \u2191unitInterval), \u03b3' t \u2208 F\nh\u03b3' : \u2200 (t : \u2191unitInterval), f (\u03b3' t) = \u03b3 t\nh\u2080 : sorry\n\u22a2 JoinedIn F x y"}, {"line": "have h\u2081 : \u03b3' 1 \u2933 y := sorry", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u03b3 : Path (f x) (f y)\n\u03b3' : \u2191unitInterval \u2192 X\nh\u03b3'F : \u2200 (t : \u2191unitInterval), \u03b3' t \u2208 F\nh\u03b3' : \u2200 (t : \u2191unitInterval), f (\u03b3' t) = \u03b3 t\nh\u2080 : sorry\nh\u2081 : sorry\n\u22a2 JoinedIn F x y"}, {"line": "have h : JoinedIn F (\u03b3' 0) (\u03b3' 1) := sorry", "tactic_state": "case intro\nX : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx y : X\nF : Set X\nf : X \u2192 Y\nhf : IsInducing f\nhx : x \u2208 F\nhy : y \u2208 F\n\u03b3 : Path (f x) (f y)\n\u03b3' : \u2191unitInterval \u2192 X\nh\u03b3'F : \u2200 (t : \u2191unitInterval), \u03b3' t \u2208 F\nh\u03b3' : \u2200 (t : \u2191unitInterval), f (\u03b3' t) = \u03b3 t\nh\u2080 : sorry\nh\u2081 : sorry\nh : sorry\n\u22a2 JoinedIn F x y"}, {"line": "exact (h\u2080.joinedIn hx (h\u03b3'F _)).trans <| h.trans <| h\u2081.joinedIn (h\u03b3'F _) hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pathComponentIn_univ (x : X) : pathComponentIn x univ = pathComponent x := by\n  simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 pathComponentIn x univ = pathComponent x"}, {"line": "simp [pathComponentIn, pathComponent, JoinedIn, Joined, exists_true_iff_nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_singleton (x : X) : IsPathConnected ({x} : Set X) := by\n  refine \u27e8x, rfl, ?_\u27e9\n  rintro y rfl\n  exact JoinedIn.refl rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 IsPathConnected {x}"}, {"line": "refine \u27e8x, rfl, ?_\u27e9", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 \u2200 {y : X}, y \u2208 {x} \u2192 JoinedIn {x} x y"}, {"line": "rintro y rfl", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ny : X\n\u22a2 JoinedIn {y} y y"}, {"line": "exact JoinedIn.refl rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_pathComponent : IsPathConnected (pathComponent x) := by\n  rw [\u2190 pathComponentIn_univ]\n  exact isPathConnected_pathComponentIn (mem_univ x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 IsPathConnected (pathComponent x)"}, {"line": "rw [\u2190 pathComponentIn_univ]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nx : X\n\u22a2 IsPathConnected (pathComponentIn x univ)"}, {"line": "exact isPathConnected_pathComponentIn (mem_univ x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V)\n    (hUV : (U \u2229 V).Nonempty) : IsPathConnected (U \u222a V) := by\n  rcases hUV with \u27e8x, xU, xV\u27e9\n  use x, Or.inl xU\n  rintro y (yU | yV)\n  \u00b7 exact (hU.joinedIn x xU y yU).mono subset_union_left\n  \u00b7 exact (hV.joinedIn x xV y yV).mono subset_union_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nhUV : (U \u2229 V).Nonempty\n\u22a2 IsPathConnected (U \u222a V)"}, {"line": "rcases hUV with \u27e8x, xU, xV\u27e9", "tactic_state": "case intro.intro\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nx : X\nxU : x \u2208 U\nxV : x \u2208 V\n\u22a2 IsPathConnected (U \u222a V)"}, {"line": "use x, Or.inl xU", "tactic_state": "case right\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nx : X\nxU : x \u2208 U\nxV : x \u2208 V\n\u22a2 \u2200 {y : X}, y \u2208 U \u222a V \u2192 JoinedIn (U \u222a V) x y"}, {"line": "rintro y (yU | yV)", "tactic_state": "case right.inl\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nx : X\nxU : x \u2208 U\nxV : x \u2208 V\ny : X\nyU : y \u2208 U\n\u22a2 JoinedIn (U \u222a V) x y\n---\ncase right.inr\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nx : X\nxU : x \u2208 U\nxV : x \u2208 V\ny : X\nyV : y \u2208 V\n\u22a2 JoinedIn (U \u222a V) x y"}, {"line": "\u00b7 exact (hU.joinedIn x xU y yU).mono subset_union_left", "tactic_state": "case right.inr\nX : Type u_1\ninst\u271d : TopologicalSpace X\nU V : Set X\nhU : IsPathConnected U\nhV : IsPathConnected V\nx : X\nxU : x \u2208 U\nxV : x \u2208 V\ny : X\nyV : y \u2208 V\n\u22a2 JoinedIn (U \u222a V) x y"}, {"line": "\u00b7 exact (hV.joinedIn x xV y yV).mono subset_union_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W \u2286 U) :\n    IsPathConnected (((\u2191) : U \u2192 X) \u207b\u00b9' W) := by\n  rwa [IsInducing.subtypeVal.isPathConnected_iff, Subtype.image_preimage_val, inter_eq_right.2 hWU]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nU W : Set X\nhW : IsPathConnected W\nhWU : W \u2286 U\n\u22a2 IsPathConnected (Subtype.val \u207b\u00b9' W)"}, {"line": "rwa [IsInducing.subtypeVal.isPathConnected_iff, Subtype.image_preimage_val, inter_eq_right.2 hWU]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pathConnectedSpace_iff_univ : PathConnectedSpace X \u2194 IsPathConnected (univ : Set X) := by\n  simp [pathConnectedSpace_iff, isPathConnected_iff, nonempty_iff_univ_nonempty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : PathConnectedSpace X\n\u22a2 PathConnectedSpace X \u2194 IsPathConnected univ"}, {"line": "simp [pathConnectedSpace_iff, isPathConnected_iff, nonempty_iff_univ_nonempty]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_iff_pathConnectedSpace : IsPathConnected F \u2194 PathConnectedSpace F := by\n  rw [pathConnectedSpace_iff_univ]\n  rw [IsInducing.subtypeVal.isPathConnected_iff]\n  rw [image_univ]\n  rw [Subtype.range_val_subtype]\n  rw [setOf_mem_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\n\u22a2 IsPathConnected F \u2194 PathConnectedSpace \u2191F"}, {"line": "rw [pathConnectedSpace_iff_univ]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\n\u22a2 IsPathConnected F \u2194 IsPathConnected univ"}, {"line": "rw [IsInducing.subtypeVal.isPathConnected_iff]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\n\u22a2 IsPathConnected F \u2194 IsPathConnected (Subtype.val '' univ)"}, {"line": "rw [image_univ]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\n\u22a2 IsPathConnected F \u2194 IsPathConnected (range Subtype.val)"}, {"line": "rw [Subtype.range_val_subtype]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\n\u22a2 IsPathConnected F \u2194 IsPathConnected {x | x \u2208 F}"}, {"line": "rw [setOf_mem_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_range [PathConnectedSpace X] {f : X \u2192 Y} (hf : Continuous f) :\n    IsPathConnected (range f) := by\n  rw [\u2190 image_univ]\n  exact isPathConnected_univ.image hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 inst\u271d : PathConnectedSpace X\nf : X \u2192 Y\nhf : Continuous f\n\u22a2 IsPathConnected (range f)"}, {"line": "rw [\u2190 image_univ]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 inst\u271d : PathConnectedSpace X\nf : X \u2192 Y\nhf : Continuous f\n\u22a2 IsPathConnected (f '' univ)"}, {"line": "exact isPathConnected_univ.image hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Function.Surjective.pathConnectedSpace [PathConnectedSpace X]\n    {f : X \u2192 Y} (hf : Surjective f) (hf' : Continuous f) : PathConnectedSpace Y := by\n  rw [pathConnectedSpace_iff_univ]\n  rw [\u2190 hf.range_eq]\n  exact isPathConnected_range hf'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 inst\u271d : PathConnectedSpace X\nf : X \u2192 Y\nhf : Surjective f\nhf' : Continuous f\n\u22a2 PathConnectedSpace Y"}, {"line": "rw [pathConnectedSpace_iff_univ]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 inst\u271d : PathConnectedSpace X\nf : X \u2192 Y\nhf : Surjective f\nhf' : Continuous f\n\u22a2 IsPathConnected univ"}, {"line": "rw [\u2190 hf.range_eq]", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 inst\u271d : PathConnectedSpace X\nf : X \u2192 Y\nhf : Surjective f\nhf' : Continuous f\n\u22a2 IsPathConnected (range f)"}, {"line": "exact isPathConnected_range hf'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pathConnectedSpace_iff_eq : PathConnectedSpace X \u2194 \u2203 x : X, pathComponent x = univ := by\n  simp [pathConnectedSpace_iff_univ, isPathConnected_iff_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : PathConnectedSpace X\n\u22a2 PathConnectedSpace X \u2194 \u2203 x, pathComponent x = univ"}, {"line": "simp [pathConnectedSpace_iff_univ, isPathConnected_iff_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsPathConnected.isConnected (hF : IsPathConnected F) : IsConnected F := by\n  rw [isConnected_iff_connectedSpace]\n  rw [isPathConnected_iff_pathConnectedSpace] at hF\n  exact @PathConnectedSpace.connectedSpace _ _ hF\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Connected/PathConnected.lean", "context": {"open": ["Topology Filter unitInterval Set Function"], "variables": ["{X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {\u03b9 : Type*}", "(X)", "{X}", "{F : Set X}", "[PathConnectedSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\nhF : IsPathConnected F\n\u22a2 IsConnected F"}, {"line": "rw [isConnected_iff_connectedSpace]", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\nhF : IsPathConnected F\n\u22a2 ConnectedSpace \u2191F"}, {"line": "rw [isPathConnected_iff_pathConnectedSpace] at hF", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 : TopologicalSpace X\nF : Set X\ninst\u271d : PathConnectedSpace X\nhF : PathConnectedSpace \u2191F\n\u22a2 ConnectedSpace \u2191F"}, {"line": "exact @PathConnectedSpace.connectedSpace _ _ hF", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.prodMk_right (x : X) : Continuous fun y : Y => (x, y) := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\n\u22a2 Continuous fun y => (x, y)"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Continuous.prodMk_left (y : Y) : Continuous fun x : X => (x, y) := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ny : Y\n\u22a2 Continuous fun x => (x, y)"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsClosed.setOf_mapsTo {\u03b1 : Type*} {f : X \u2192 \u03b1 \u2192 Z} {s : Set \u03b1} {t : Set Z} (ht : IsClosed t)\n    (hf : \u2200 a \u2208 s, Continuous (f \u00b7 a)) : IsClosed {x | MapsTo (f x) s t} := by\n  simpa only [MapsTo,setOf_forall] using isClosed_biInter fun y hy \u21a6 ht.preimage (hf y hy)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nZ : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Z\n\u03b1 : Type u_5\nf : X \u2192 \u03b1 \u2192 Z\ns : Set \u03b1\nt : Set Z\nht : IsClosed t\nhf : \u2200 a \u2208 s, Continuous fun x => f x a\n\u22a2 IsClosed {x | MapsTo (f x) s t}"}, {"line": "simpa only [MapsTo,setOf_forall] using isClosed_biInter fun y hy \u21a6 ht.preimage (hf y hy)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_inf_dom_left\u2082 {X Y Z} {f : X \u2192 Y \u2192 Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta1; haveI := tb1; exact Continuous fun p : X \u00d7 Y => f p.1 p.2) : by\n    haveI := ta1 \u2293 ta2; haveI := tb1 \u2293 tb2; exact Continuous fun p : X \u00d7 Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta1 tb1 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have h_continuous_id := @Continuous.prodMap _ _ _ _ ta1 tb1 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\nh_continuous_id : Continuous (Prod.map id id)\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_inf_dom_right\u2082 {X Y Z} {f : X \u2192 Y \u2192 Z} {ta1 ta2 : TopologicalSpace X}\n    {tb1 tb2 : TopologicalSpace Y} {tc1 : TopologicalSpace Z}\n    (h : by haveI := ta2; haveI := tb2; exact Continuous fun p : X \u00d7 Y => f p.1 p.2) : by\n    haveI := ta1 \u2293 ta2; haveI := tb1 \u2293 tb2; exact Continuous fun p : X \u00d7 Y => f p.1 p.2 := by\n  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))\n  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ ta2 tb2 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have h_continuous_id := @Continuous.prodMap _ _ _ _ ta2 tb2 (ta1 \u2293 ta2) (tb1 \u2293 tb2) _ _ ha hb", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\nta1 ta2 : TopologicalSpace X\ntb1 tb2 : TopologicalSpace Y\ntc1 : TopologicalSpace Z\nh : Continuous fun p => f p.1 p.2\nha : Continuous id\nhb : Continuous id\nh_continuous_id : Continuous (Prod.map id id)\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_sInf_dom\u2082 {X Y Z} {f : X \u2192 Y \u2192 Z} {tas : Set (TopologicalSpace X)}\n    {tbs : Set (TopologicalSpace Y)} {tX : TopologicalSpace X} {tY : TopologicalSpace Y}\n    {tc : TopologicalSpace Z} (hX : tX \u2208 tas) (hY : tY \u2208 tbs)\n    (hf : Continuous fun p : X \u00d7 Y => f p.1 p.2) : by\n    haveI := sInf tas; haveI := sInf tbs\n    exact @Continuous _ _ _ tc fun p : X \u00d7 Y => f p.1 p.2 := by\n  have hX := continuous_sInf_dom hX continuous_id\n  have hY := continuous_sInf_dom hY continuous_id\n  have h_continuous_id := @Continuous.prodMap _ _ _ _ tX tY (sInf tas) (sInf tbs) _ _ hX hY\n  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX : tX \u2208 tas\nhY : tY \u2208 tbs\nhf : Continuous fun p => f p.1 p.2\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have hX := continuous_sInf_dom hX continuous_id", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX\u271d : tX \u2208 tas\nhY : tY \u2208 tbs\nhf : Continuous fun p => f p.1 p.2\nhX : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have hY := continuous_sInf_dom hY continuous_id", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX\u271d : tX \u2208 tas\nhY\u271d : tY \u2208 tbs\nhf : Continuous fun p => f p.1 p.2\nhX : Continuous id\nhY : Continuous id\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "have h_continuous_id := @Continuous.prodMap _ _ _ _ tX tY (sInf tas) (sInf tbs) _ _ hX hY", "tactic_state": "X : Type u_5\nY : Type u_6\nZ : Type u_7\nf : X \u2192 Y \u2192 Z\ntas : Set (TopologicalSpace X)\ntbs : Set (TopologicalSpace Y)\ntX : TopologicalSpace X\ntY : TopologicalSpace Y\ntc : TopologicalSpace Z\nhX\u271d : tX \u2208 tas\nhY\u271d : tY \u2208 tbs\nhf : Continuous fun p => f p.1 p.2\nhX : Continuous id\nhY : Continuous id\nh_continuous_id : Continuous (Prod.map id id)\n\u22a2 Continuous fun p => f p.1 p.2"}, {"line": "exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhds_prod_eq {x : X} {y : Y} : \ud835\udcdd (x, y) = \ud835\udcdd x \u00d7\u02e2 \ud835\udcdd y := by\n  rw [prod_eq_inf]\n  rw [instTopologicalSpaceProd]\n  rw [nhds_inf (t\u2081 := TopologicalSpace.induced Prod.fst _)     (t\u2082 := TopologicalSpace.induced Prod.snd _)]\n  rw [nhds_induced]\n  rw [nhds_induced]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\n\u22a2 nhds (x, y) = nhds x \u00d7\u02e2 nhds y"}, {"line": "rw [prod_eq_inf]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\n\u22a2 nhds (x, y) = comap Prod.fst (nhds x) \u2293 comap Prod.snd (nhds y)"}, {"line": "rw [instTopologicalSpaceProd]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\n\u22a2 nhds (x, y) = comap Prod.fst (nhds x) \u2293 comap Prod.snd (nhds y)"}, {"line": "rw [nhds_inf (t\u2081 := TopologicalSpace.induced Prod.fst _)     (t\u2082 := TopologicalSpace.induced Prod.snd _)]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\n\u22a2 nhds (x, y) \u2293 nhds (x, y) = comap Prod.fst (nhds x) \u2293 comap Prod.snd (nhds y)"}, {"line": "rw [nhds_induced]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\n\u22a2 comap Prod.fst (nhds (x, y).1) \u2293 nhds (x, y) = comap Prod.fst (nhds x) \u2293 comap Prod.snd (nhds y)"}, {"line": "rw [nhds_induced]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nhdsWithin_prod_eq (x : X) (y : Y) (s : Set X) (t : Set Y) :\n    \ud835\udcdd[s \u00d7\u02e2 t] (x, y) = \ud835\udcdd[s] x \u00d7\u02e2 \ud835\udcdd[t] y := by\n  simp only [nhdsWithin]\n  simp only [nhds_prod_eq]\n  simp only [\u2190 prod_inf_prod]\n  simp only [prod_principal_principal]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\n\u22a2 nhdsWithin (x, y) (s \u00d7\u02e2 t) = nhdsWithin x s \u00d7\u02e2 nhdsWithin y t"}, {"line": "simp only [nhdsWithin]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\n\u22a2 nhds (x, y) \u2293 principal (s \u00d7\u02e2 t) = (nhds x \u2293 principal s) \u00d7\u02e2 (nhds y \u2293 principal t)"}, {"line": "simp only [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\n\u22a2 nhds x \u00d7\u02e2 nhds y \u2293 principal (s \u00d7\u02e2 t) = (nhds x \u2293 principal s) \u00d7\u02e2 (nhds y \u2293 principal t)"}, {"line": "simp only [\u2190 prod_inf_prod]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set X\nt : Set Y\n\u22a2 nhds x \u00d7\u02e2 nhds y \u2293 principal (s \u00d7\u02e2 t) = nhds x \u00d7\u02e2 nhds y \u2293 principal s \u00d7\u02e2 principal t"}, {"line": "simp only [prod_principal_principal]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhds_prod_iff {x : X} {y : Y} {s : Set (X \u00d7 Y)} :\n    s \u2208 \ud835\udcdd (x, y) \u2194 \u2203 u \u2208 \ud835\udcdd x, \u2203 v \u2208 \ud835\udcdd y, u \u00d7\u02e2 v \u2286 s := by rw [nhds_prod_eq, mem_prod_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set (X \u00d7 Y)\n\u22a2 s \u2208 nhds (x, y) \u2194 \u2203 u \u2208 nhds x, \u2203 v \u2208 nhds y, u \u00d7\u02e2 v \u2286 s"}, {"line": "rw [nhds_prod_eq, mem_prod_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_nhdsWithin_prod_iff {x : X} {y : Y} {s : Set (X \u00d7 Y)} {tx : Set X} {ty : Set Y} :\n    s \u2208 \ud835\udcdd[tx \u00d7\u02e2 ty] (x, y) \u2194 \u2203 u \u2208 \ud835\udcdd[tx] x, \u2203 v \u2208 \ud835\udcdd[ty] y, u \u00d7\u02e2 v \u2286 s := by\n  rw [nhdsWithin_prod_eq]\n  rw [mem_prod_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set (X \u00d7 Y)\ntx : Set X\nty : Set Y\n\u22a2 s \u2208 nhdsWithin (x, y) (tx \u00d7\u02e2 ty) \u2194 \u2203 u \u2208 nhdsWithin x tx, \u2203 v \u2208 nhdsWithin y ty, u \u00d7\u02e2 v \u2286 s"}, {"line": "rw [nhdsWithin_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nx : X\ny : Y\ns : Set (X \u00d7 Y)\ntx : Set X\nty : Set Y\n\u22a2 s \u2208 nhdsWithin x tx \u00d7\u02e2 nhdsWithin y ty \u2194 \u2203 u \u2208 nhdsWithin x tx, \u2203 v \u2208 nhdsWithin y ty, u \u00d7\u02e2 v \u2286 s"}, {"line": "rw [mem_prod_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.HasBasis.prod_nhds {\u03b9X \u03b9Y : Type*} {px : \u03b9X \u2192 Prop} {py : \u03b9Y \u2192 Prop}\n    {sx : \u03b9X \u2192 Set X} {sy : \u03b9Y \u2192 Set Y} {x : X} {y : Y} (hx : (\ud835\udcdd x).HasBasis px sx)\n    (hy : (\ud835\udcdd y).HasBasis py sy) :\n    (\ud835\udcdd (x, y)).HasBasis (fun i : \u03b9X \u00d7 \u03b9Y => px i.1 \u2227 py i.2) fun i => sx i.1 \u00d7\u02e2 sy i.2 := by\n  rw [nhds_prod_eq]\n  exact hx.prod hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b9X : Type u_5\n\u03b9Y : Type u_6\npx : \u03b9X \u2192 Prop\npy : \u03b9Y \u2192 Prop\nsx : \u03b9X \u2192 Set X\nsy : \u03b9Y \u2192 Set Y\nx : X\ny : Y\nhx : (nhds x).HasBasis px sx\nhy : (nhds y).HasBasis py sy\n\u22a2 (nhds (x, y)).HasBasis (fun i => px i.1 \u2227 py i.2) fun i => sx i.1 \u00d7\u02e2 sy i.2"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b9X : Type u_5\n\u03b9Y : Type u_6\npx : \u03b9X \u2192 Prop\npy : \u03b9Y \u2192 Prop\nsx : \u03b9X \u2192 Set X\nsy : \u03b9Y \u2192 Set Y\nx : X\ny : Y\nhx : (nhds x).HasBasis px sx\nhy : (nhds y).HasBasis py sy\n\u22a2 (nhds x \u00d7\u02e2 nhds y).HasBasis (fun i => px i.1 \u2227 py i.2) fun i => sx i.1 \u00d7\u02e2 sy i.2"}, {"line": "exact hx.prod hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Prod.tendsto_iff {X} (seq : X \u2192 Y \u00d7 Z) {f : Filter X} (p : Y \u00d7 Z) :\n    Tendsto seq f (\ud835\udcdd p) \u2194\n      Tendsto (fun n => (seq n).fst) f (\ud835\udcdd p.fst) \u2227 Tendsto (fun n => (seq n).snd) f (\ud835\udcdd p.snd) := by\n  rw [nhds_prod_eq]\n  rw [Filter.tendsto_prod_iff']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y : Type v\nZ : Type u_2\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nX : Type u_5\nseq : X \u2192 Y \u00d7 Z\nf : Filter X\np : Y \u00d7 Z\n\u22a2 Tendsto seq f (nhds p) \u2194 Tendsto (fun n => (seq n).1) f (nhds p.1) \u2227 Tendsto (fun n => (seq n).2) f (nhds p.2)"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "Y : Type v\nZ : Type u_2\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nX : Type u_5\nseq : X \u2192 Y \u00d7 Z\nf : Filter X\np : Y \u00d7 Z\n\u22a2 Tendsto seq f (nhds p.1 \u00d7\u02e2 nhds p.2) \u2194\n    Tendsto (fun n => (seq n).1) f (nhds p.1) \u2227 Tendsto (fun n => (seq n).2) f (nhds p.2)"}, {"line": "rw [Filter.tendsto_prod_iff']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_mem_nhds_iff {s : Set X} {t : Set Y} {x : X} {y : Y} :\n    s \u00d7\u02e2 t \u2208 \ud835\udcdd (x, y) \u2194 s \u2208 \ud835\udcdd x \u2227 t \u2208 \ud835\udcdd y := by rw [nhds_prod_eq, prod_mem_prod_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : X\ny : Y\n\u22a2 s \u00d7\u02e2 t \u2208 nhds (x, y) \u2194 s \u2208 nhds x \u2227 t \u2208 nhds y"}, {"line": "rw [nhds_prod_eq, prod_mem_prod_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyEq.prodMap_nhds {\u03b1 \u03b2 : Type*} {f\u2081 f\u2082 : X \u2192 \u03b1} {g\u2081 g\u2082 : Y \u2192 \u03b2}\n    {x : X} {y : Y} (hf : f\u2081 =\u1da0[\ud835\udcdd x] f\u2082) (hg : g\u2081 =\u1da0[\ud835\udcdd y] g\u2082) :\n    Prod.map f\u2081 g\u2081 =\u1da0[\ud835\udcdd (x, y)] Prod.map f\u2082 g\u2082 := by\n  rw [nhds_prod_eq]\n  exact hf.prodMap hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b1 : Type u_5\n\u03b2 : Type u_6\nf\u2081 f\u2082 : X \u2192 \u03b1\ng\u2081 g\u2082 : Y \u2192 \u03b2\nx : X\ny : Y\nhf : f\u2081 =\u1da0[nhds x] f\u2082\nhg : g\u2081 =\u1da0[nhds y] g\u2082\n\u22a2 Prod.map f\u2081 g\u2081 =\u1da0[nhds (x, y)] Prod.map f\u2082 g\u2082"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b1 : Type u_5\n\u03b2 : Type u_6\nf\u2081 f\u2082 : X \u2192 \u03b1\ng\u2081 g\u2082 : Y \u2192 \u03b2\nx : X\ny : Y\nhf : f\u2081 =\u1da0[nhds x] f\u2082\nhg : g\u2081 =\u1da0[nhds y] g\u2082\n\u22a2 Prod.map f\u2081 g\u2081 =\u1da0[nhds x \u00d7\u02e2 nhds y] Prod.map f\u2082 g\u2082"}, {"line": "exact hf.prodMap hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.EventuallyLE.prodMap_nhds {\u03b1 \u03b2 : Type*} [LE \u03b1] [LE \u03b2] {f\u2081 f\u2082 : X \u2192 \u03b1} {g\u2081 g\u2082 : Y \u2192 \u03b2}\n    {x : X} {y : Y} (hf : f\u2081 \u2264\u1da0[\ud835\udcdd x] f\u2082) (hg : g\u2081 \u2264\u1da0[\ud835\udcdd y] g\u2082) :\n    Prod.map f\u2081 g\u2081 \u2264\u1da0[\ud835\udcdd (x, y)] Prod.map f\u2082 g\u2082 := by\n  rw [nhds_prod_eq]\n  exact hf.prodMap hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LE \u03b2\nf\u2081 f\u2082 : X \u2192 \u03b1\ng\u2081 g\u2082 : Y \u2192 \u03b2\nx : X\ny : Y\nhf : f\u2081 \u2264\u1da0[nhds x] f\u2082\nhg : g\u2081 \u2264\u1da0[nhds y] g\u2082\n\u22a2 Prod.map f\u2081 g\u2081 \u2264\u1da0[nhds (x, y)] Prod.map f\u2082 g\u2082"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\n\u03b1 : Type u_5\n\u03b2 : Type u_6\ninst\u271d\u00b9 : LE \u03b1\ninst\u271d : LE \u03b2\nf\u2081 f\u2082 : X \u2192 \u03b1\ng\u2081 g\u2082 : Y \u2192 \u03b2\nx : X\ny : Y\nhf : f\u2081 \u2264\u1da0[nhds x] f\u2082\nhg : g\u2081 \u2264\u1da0[nhds y] g\u2082\n\u22a2 Prod.map f\u2081 g\u2081 \u2264\u1da0[nhds x \u00d7\u02e2 nhds y] Prod.map f\u2082 g\u2082"}, {"line": "exact hf.prodMap hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.prodMk_nhds {\u03b3} {x : X} {y : Y} {f : Filter \u03b3} {mx : \u03b3 \u2192 X} {my : \u03b3 \u2192 Y}\n    (hx : Tendsto mx f (\ud835\udcdd x)) (hy : Tendsto my f (\ud835\udcdd y)) :\n    Tendsto (fun c => (mx c, my c)) f (\ud835\udcdd (x, y)) := by\n  rw [nhds_prod_eq]\n  exact hx.prodMk hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b3 : Type u_5\nx : X\ny : Y\nf : Filter \u03b3\nmx : \u03b3 \u2192 X\nmy : \u03b3 \u2192 Y\nhx : Tendsto mx f (nhds x)\nhy : Tendsto my f (nhds y)\n\u22a2 Tendsto (fun c => (mx c, my c)) f (nhds (x, y))"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u03b3 : Type u_5\nx : X\ny : Y\nf : Filter \u03b3\nmx : \u03b3 \u2192 X\nmy : \u03b3 \u2192 Y\nhx : Tendsto mx f (nhds x)\nhy : Tendsto my f (nhds y)\n\u22a2 Tendsto (fun c => (mx c, my c)) f (nhds x \u00d7\u02e2 nhds y)"}, {"line": "exact hx.prodMk hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Tendsto.prodMap_nhds {x : X} {y : Y} {z : Z} {w : W} {f : X \u2192 Y} {g : Z \u2192 W}\n    (hf : Tendsto f (\ud835\udcdd x) (\ud835\udcdd y)) (hg : Tendsto g (\ud835\udcdd z) (\ud835\udcdd w)) :\n    Tendsto (Prod.map f g) (\ud835\udcdd (x, z)) (\ud835\udcdd (y, w)) := by\n  rw [nhds_prod_eq]\n  rw [nhds_prod_eq]\n  exact hf.prodMap hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nx : X\ny : Y\nz : Z\nw : W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : Tendsto f (nhds x) (nhds y)\nhg : Tendsto g (nhds z) (nhds w)\n\u22a2 Tendsto (Prod.map f g) (nhds (x, z)) (nhds (y, w))"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nx : X\ny : Y\nz : Z\nw : W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : Tendsto f (nhds x) (nhds y)\nhg : Tendsto g (nhds z) (nhds w)\n\u22a2 Tendsto (Prod.map f g) (nhds x \u00d7\u02e2 nhds z) (nhds (y, w))"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nx : X\ny : Y\nz : Z\nw : W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : Tendsto f (nhds x) (nhds y)\nhg : Tendsto g (nhds z) (nhds w)\n\u22a2 Tendsto (Prod.map f g) (nhds x \u00d7\u02e2 nhds z) (nhds y \u00d7\u02e2 nhds w)"}, {"line": "exact hf.prodMap hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Filter.Eventually.curry_nhds {p : X \u00d7 Y \u2192 Prop} {x : X} {y : Y}\n    (h : \u2200\u1da0 x in \ud835\udcdd (x, y), p x) : \u2200\u1da0 x' in \ud835\udcdd x, \u2200\u1da0 y' in \ud835\udcdd y, p (x', y') := by\n  rw [nhds_prod_eq] at h\n  exact h.curry\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\np : X \u00d7 Y \u2192 Prop\nx : X\ny : Y\nh : \u2200\u1da0 (x : X \u00d7 Y) in nhds (x, y), p x\n\u22a2 \u2200\u1da0 (x' : X) in nhds x, \u2200\u1da0 (y' : Y) in nhds y, p (x', y')"}, {"line": "rw [nhds_prod_eq] at h", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\np : X \u00d7 Y \u2192 Prop\nx : X\ny : Y\nh : \u2200\u1da0 (x : X \u00d7 Y) in nhds x \u00d7\u02e2 nhds y, p x\n\u22a2 \u2200\u1da0 (x' : X) in nhds x, \u2200\u1da0 (y' : Y) in nhds y, p (x', y')"}, {"line": "exact h.curry", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousAt.comp\u2082_of_eq {f : Y \u00d7 Z \u2192 W} {g : X \u2192 Y} {h : X \u2192 Z} {x : X} {y : Y \u00d7 Z}\n    (hf : ContinuousAt f y) (hg : ContinuousAt g x) (hh : ContinuousAt h x) (e : (g x, h x) = y) :\n    ContinuousAt (fun x \u21a6 f (g x, h x)) x := by\n  rw [\u2190 e] at hf\n  exact hf.comp\u2082 hg hh\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : Y \u00d7 Z \u2192 W\ng : X \u2192 Y\nh : X \u2192 Z\nx : X\ny : Y \u00d7 Z\nhf : ContinuousAt f y\nhg : ContinuousAt g x\nhh : ContinuousAt h x\ne : (g x, h x) = y\n\u22a2 ContinuousAt (fun x => f (g x, h x)) x"}, {"line": "rw [\u2190 e] at hf", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : Y \u00d7 Z \u2192 W\ng : X \u2192 Y\nh : X \u2192 Z\nx : X\ny : Y \u00d7 Z\nhf : ContinuousAt f (g x, h x)\nhg : ContinuousAt g x\nhh : ContinuousAt h x\ne : (g x, h x) = y\n\u22a2 ContinuousAt (fun x => f (g x, h x)) x"}, {"line": "exact hf.comp\u2082 hg hh", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_induced_induced {X Z} (f : X \u2192 Y) (g : Z \u2192 W) :\n    @instTopologicalSpaceProd X Z (induced f \u2039_\u203a) (induced g \u2039_\u203a) =\n      induced (fun p => (f p.1, g p.2)) instTopologicalSpaceProd := by\n  delta instTopologicalSpaceProd\n  simp_rw [induced_inf, induced_compose]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y : Type v\nW : Type u_1\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace W\nX : Type u_5\nZ : Type u_6\nf : X \u2192 Y\ng : Z \u2192 W\n\u22a2 instTopologicalSpaceProd = induced (fun p => (f p.1, g p.2)) instTopologicalSpaceProd"}, {"line": "delta instTopologicalSpaceProd", "tactic_state": "Y : Type v\nW : Type u_1\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace W\nX : Type u_5\nZ : Type u_6\nf : X \u2192 Y\ng : Z \u2192 W\n\u22a2 induced Prod.fst (induced f inst\u271d\u00b9) \u2293 induced Prod.snd (induced g inst\u271d) =\n    induced (fun p => (f p.1, g p.2)) (induced Prod.fst inst\u271d\u00b9 \u2293 induced Prod.snd inst\u271d)"}, {"line": "simp_rw [induced_inf, induced_compose]", "tactic_state": "Y : Type v\nW : Type u_1\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace W\nX : Type u_5\nZ : Type u_6\nf : X \u2192 Y\ng : Z \u2192 W\n\u22a2 induced (f \u2218 Prod.fst) inst\u271d\u00b9 \u2293 induced (g \u2218 Prod.snd) inst\u271d =\n    induced (Prod.fst \u2218 fun p => (f p.1, g p.2)) inst\u271d\u00b9 \u2293 induced (Prod.snd \u2218 fun p => (f p.1, g p.2)) inst\u271d"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_prod_eq (s : Set X) (t : Set Y) :\n    frontier (s \u00d7\u02e2 t) = closure s \u00d7\u02e2 frontier t \u222a frontier s \u00d7\u02e2 closure t := by\n  simp only [frontier]\n  simp only [closure_prod_eq]\n  simp only [interior_prod_eq]\n  simp only [prod_diff_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nt : Set Y\n\u22a2 frontier (s \u00d7\u02e2 t) = closure s \u00d7\u02e2 frontier t \u222a frontier s \u00d7\u02e2 closure t"}, {"line": "simp only [frontier]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nt : Set Y\n\u22a2 closure (s \u00d7\u02e2 t) \\ interior (s \u00d7\u02e2 t) = closure s \u00d7\u02e2 (closure t \\ interior t) \u222a (closure s \\ interior s) \u00d7\u02e2 closure t"}, {"line": "simp only [closure_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nt : Set Y\n\u22a2 closure s \u00d7\u02e2 closure t \\ interior (s \u00d7\u02e2 t) =\n    closure s \u00d7\u02e2 (closure t \\ interior t) \u222a (closure s \\ interior s) \u00d7\u02e2 closure t"}, {"line": "simp only [interior_prod_eq]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\nt : Set Y\n\u22a2 closure s \u00d7\u02e2 closure t \\ interior s \u00d7\u02e2 interior t =\n    closure s \u00d7\u02e2 (closure t \\ interior t) \u222a (closure s \\ interior s) \u00d7\u02e2 closure t"}, {"line": "simp only [prod_diff_prod]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_prod_univ_eq (s : Set X) :\n    frontier (s \u00d7\u02e2 (univ : Set Y)) = frontier s \u00d7\u02e2 univ := by\n  simp [frontier_prod_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set X\n\u22a2 frontier (s \u00d7\u02e2 univ) = frontier s \u00d7\u02e2 univ"}, {"line": "simp [frontier_prod_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem frontier_univ_prod_eq (s : Set Y) :\n    frontier ((univ : Set X) \u00d7\u02e2 s) = univ \u00d7\u02e2 frontier s := by\n  simp [frontier_prod_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set Y\n\u22a2 frontier (univ \u00d7\u02e2 s) = univ \u00d7\u02e2 frontier s"}, {"line": "simp [frontier_prod_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DenseRange.prodMap {\u03b9 : Type*} {\u03ba : Type*} {f : \u03b9 \u2192 Y} {g : \u03ba \u2192 Z} (hf : DenseRange f)\n    (hg : DenseRange g) : DenseRange (Prod.map f g) := by\n  simpa only [DenseRange,prod_range_range_eq] using hf.prod hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "Y : Type v\nZ : Type u_2\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\n\u03b9 : Type u_5\n\u03ba : Type u_6\nf : \u03b9 \u2192 Y\ng : \u03ba \u2192 Z\nhf : DenseRange f\nhg : DenseRange g\n\u22a2 DenseRange (Prod.map f g)"}, {"line": "simpa only [DenseRange,prod_range_range_eq] using hf.prod hg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Topology.isInducing_const_prod {x : X} {f : Y \u2192 Z} :\n    IsInducing (fun x' => (x, f x')) \u2194 IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, top_inf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nx : X\nf : Y \u2192 Z\n\u22a2 (IsInducing fun x' => (x, f x')) \u2194 IsInducing f"}, {"line": "simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, top_inf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Topology.isInducing_prod_const {y : Y} {f : X \u2192 Z} :\n    IsInducing (fun x => (f x, y)) \u2194 IsInducing f := by\n  simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, inf_top_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\ny : Y\nf : X \u2192 Z\n\u22a2 (IsInducing fun x => (f x, y)) \u2194 IsInducing f"}, {"line": "simp_rw [isInducing_iff, instTopologicalSpaceProd, induced_inf, induced_compose,\n    Function.comp_def, induced_const, inf_top_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsOpenMap.prodMap {f : X \u2192 Y} {g : Z \u2192 W} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Prod.map f g) := by\n  rw [isOpenMap_iff_nhds_le]\n  rintro \u27e8a, b\u27e9\n  rw [nhds_prod_eq]\n  rw [nhds_prod_eq]\n  rw [\u2190 Filter.prod_map_map_eq']\n  exact Filter.prod_mono (hf.nhds_le a) (hg.nhds_le b)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\n\u22a2 IsOpenMap (Prod.map f g)"}, {"line": "rw [isOpenMap_iff_nhds_le]", "tactic_state": "X : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\n\u22a2 \u2200 (x : X \u00d7 Z), nhds (Prod.map f g x) \u2264 map (Prod.map f g) (nhds x)"}, {"line": "rintro \u27e8a, b\u27e9", "tactic_state": "case mk\nX : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\na : X\nb : Z\n\u22a2 nhds (Prod.map f g (a, b)) \u2264 map (Prod.map f g) (nhds (a, b))"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "case mk\nX : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\na : X\nb : Z\n\u22a2 nhds (Prod.map f g (a, b)).1 \u00d7\u02e2 nhds (Prod.map f g (a, b)).2 \u2264 map (Prod.map f g) (nhds (a, b))"}, {"line": "rw [nhds_prod_eq]", "tactic_state": "case mk\nX : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\na : X\nb : Z\n\u22a2 nhds (Prod.map f g (a, b)).1 \u00d7\u02e2 nhds (Prod.map f g (a, b)).2 \u2264 map (Prod.map f g) (nhds a \u00d7\u02e2 nhds b)"}, {"line": "rw [\u2190 Filter.prod_map_map_eq']", "tactic_state": "case mk\nX : Type u\nY : Type v\nW : Type u_1\nZ : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace Z\ninst\u271d : TopologicalSpace W\nf : X \u2192 Y\ng : Z \u2192 W\nhf : IsOpenMap f\nhg : IsOpenMap g\na : X\nb : Z\n\u22a2 nhds (Prod.map f g (a, b)).1 \u00d7\u02e2 nhds (Prod.map f g (a, b)).2 \u2264 map f (nhds a) \u00d7\u02e2 map g (nhds b)"}, {"line": "exact Filter.prod_mono (hf.nhds_le a) (hg.nhds_le b)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_sum_iff {s : Set (X \u2295 Y)} :\n    IsClosed s \u2194 IsClosed (inl \u207b\u00b9' s) \u2227 IsClosed (inr \u207b\u00b9' s) := by\n  simp only [\u2190 isOpen_compl_iff]\n  simp only [isOpen_sum_iff]\n  simp only [preimage_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set (X \u2295 Y)\n\u22a2 IsClosed s \u2194 IsClosed (inl \u207b\u00b9' s) \u2227 IsClosed (inr \u207b\u00b9' s)"}, {"line": "simp only [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set (X \u2295 Y)\n\u22a2 IsOpen s\u1d9c \u2194 IsOpen (inl \u207b\u00b9' s)\u1d9c \u2227 IsOpen (inr \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [isOpen_sum_iff]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\ns : Set (X \u2295 Y)\n\u22a2 IsOpen (inl \u207b\u00b9' s\u1d9c) \u2227 IsOpen (inr \u207b\u00b9' s\u1d9c) \u2194 IsOpen (inl \u207b\u00b9' s)\u1d9c \u2227 IsOpen (inr \u207b\u00b9' s)\u1d9c"}, {"line": "simp only [preimage_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_range_inl : IsClosed (range (inl : X \u2192 X \u2295 Y)) := by\n  rw [\u2190 isOpen_compl_iff]\n  rw [compl_range_inl]\n  exact isOpen_range_inr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsClosed (range inl)"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsOpen (range inl)\u1d9c"}, {"line": "rw [compl_range_inl]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsOpen (range inr)"}, {"line": "exact isOpen_range_inr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosed_range_inr : IsClosed (range (inr : Y \u2192 X \u2295 Y)) := by\n  rw [\u2190 isOpen_compl_iff]\n  rw [compl_range_inr]\n  exact isOpen_range_inl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsClosed (range inr)"}, {"line": "rw [\u2190 isOpen_compl_iff]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsOpen (range inr)\u1d9c"}, {"line": "rw [compl_range_inr]", "tactic_state": "X : Type u\nY : Type v\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : TopologicalSpace Y\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\n\u22a2 IsOpen (range inl)"}, {"line": "exact isOpen_range_inl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenMap_sum {f : X \u2295 Y \u2192 Z} :\n    IsOpenMap f \u2194 (IsOpenMap fun a => f (inl a)) \u2227 IsOpenMap fun b => f (inr b) := by\n  simp only [isOpenMap_iff_nhds_le]\n  simp only [Sum.forall]\n  simp only [nhds_inl]\n  simp only [nhds_inr]\n  simp only [Filter.map_map]\n  simp only [comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 IsOpenMap f \u2194 (IsOpenMap fun a => f (inl a)) \u2227 IsOpenMap fun b => f (inr b)"}, {"line": "simp only [isOpenMap_iff_nhds_le]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 (\u2200 (x : X \u2295 Y), nhds (f x) \u2264 map f (nhds x)) \u2194\n    (\u2200 (x : X), nhds (f (inl x)) \u2264 map (fun a => f (inl a)) (nhds x)) \u2227\n      \u2200 (x : Y), nhds (f (inr x)) \u2264 map (fun b => f (inr b)) (nhds x)"}, {"line": "simp only [Sum.forall]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 ((\u2200 (a : X), nhds (f (inl a)) \u2264 map f (nhds (inl a))) \u2227 \u2200 (b : Y), nhds (f (inr b)) \u2264 map f (nhds (inr b))) \u2194\n    (\u2200 (x : X), nhds (f (inl x)) \u2264 map (fun a => f (inl a)) (nhds x)) \u2227\n      \u2200 (x : Y), nhds (f (inr x)) \u2264 map (fun b => f (inr b)) (nhds x)"}, {"line": "simp only [nhds_inl]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 ((\u2200 (a : X), nhds (f (inl a)) \u2264 map f (map inl (nhds a))) \u2227 \u2200 (b : Y), nhds (f (inr b)) \u2264 map f (nhds (inr b))) \u2194\n    (\u2200 (x : X), nhds (f (inl x)) \u2264 map (fun a => f (inl a)) (nhds x)) \u2227\n      \u2200 (x : Y), nhds (f (inr x)) \u2264 map (fun b => f (inr b)) (nhds x)"}, {"line": "simp only [nhds_inr]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 ((\u2200 (a : X), nhds (f (inl a)) \u2264 map f (map inl (nhds a))) \u2227 \u2200 (b : Y), nhds (f (inr b)) \u2264 map f (map inr (nhds b))) \u2194\n    (\u2200 (x : X), nhds (f (inl x)) \u2264 map (fun a => f (inl a)) (nhds x)) \u2227\n      \u2200 (x : Y), nhds (f (inr x)) \u2264 map (fun b => f (inr b)) (nhds x)"}, {"line": "simp only [Filter.map_map]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2295 Y \u2192 Z\n\u22a2 ((\u2200 (a : X), nhds (f (inl a)) \u2264 map (f \u2218 inl) (nhds a)) \u2227 \u2200 (b : Y), nhds (f (inr b)) \u2264 map (f \u2218 inr) (nhds b)) \u2194\n    (\u2200 (x : X), nhds (f (inl x)) \u2264 map (fun a => f (inl a)) (nhds x)) \u2227\n      \u2200 (x : Y), nhds (f (inr x)) \u2264 map (fun b => f (inr b)) (nhds x)"}, {"line": "simp only [comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpenMap_sumElim {f : X \u2192 Z} {g : Y \u2192 Z} :\n    IsOpenMap (Sum.elim f g) \u2194 IsOpenMap f \u2227 IsOpenMap g := by\n  simp only [isOpenMap_sum]\n  simp only [elim_inl]\n  simp only [elim_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 IsOpenMap (Sum.elim f g) \u2194 IsOpenMap f \u2227 IsOpenMap g"}, {"line": "simp only [isOpenMap_sum]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 ((IsOpenMap fun a => Sum.elim f g (inl a)) \u2227 IsOpenMap fun b => Sum.elim f g (inr b)) \u2194 IsOpenMap f \u2227 IsOpenMap g"}, {"line": "simp only [elim_inl]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 ((IsOpenMap fun a => f a) \u2227 IsOpenMap fun b => Sum.elim f g (inr b)) \u2194 IsOpenMap f \u2227 IsOpenMap g"}, {"line": "simp only [elim_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsOpenEmbedding.sumElim {f : X \u2192 Z} {g : Y \u2192 Z}\n    (hf : IsOpenEmbedding f) (hg : IsOpenEmbedding g) (h : Injective (Sum.elim f g)) :\n    IsOpenEmbedding (Sum.elim f g) := by\n  rw [isOpenEmbedding_iff_continuous_injective_isOpenMap] at hf hg \u22a2\n  exact \u27e8hf.1.sumElim hg.1, h, hf.2.2.sumElim hg.2.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\nhf : IsOpenEmbedding f\nhg : IsOpenEmbedding g\nh : Injective (Sum.elim f g)\n\u22a2 IsOpenEmbedding (Sum.elim f g)"}, {"line": "rw [isOpenEmbedding_iff_continuous_injective_isOpenMap] at hf hg \u22a2", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\nhf : Continuous f \u2227 Injective f \u2227 IsOpenMap f\nhg : Continuous g \u2227 Injective g \u2227 IsOpenMap g\nh : Injective (Sum.elim f g)\n\u22a2 Continuous (Sum.elim f g) \u2227 Injective (Sum.elim f g) \u2227 IsOpenMap (Sum.elim f g)"}, {"line": "exact \u27e8hf.1.sumElim hg.1, h, hf.2.2.sumElim hg.2.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isClosedMap_sumElim {f : X \u2192 Z} {g : Y \u2192 Z} :\n    IsClosedMap (Sum.elim f g) \u2194 IsClosedMap f \u2227 IsClosedMap g := by\n  simp only [isClosedMap_sum]\n  simp only [Sum.elim_inl]\n  simp only [Sum.elim_inr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 IsClosedMap (Sum.elim f g) \u2194 IsClosedMap f \u2227 IsClosedMap g"}, {"line": "simp only [isClosedMap_sum]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 ((IsClosedMap fun a => Sum.elim f g (inl a)) \u2227 IsClosedMap fun b => Sum.elim f g (inr b)) \u2194\n    IsClosedMap f \u2227 IsClosedMap g"}, {"line": "simp only [Sum.elim_inl]", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\n\u22a2 ((IsClosedMap fun a => f a) \u2227 IsClosedMap fun b => Sum.elim f g (inr b)) \u2194 IsClosedMap f \u2227 IsClosedMap g"}, {"line": "simp only [Sum.elim_inr]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma IsClosedEmbedding.sumElim {f : X \u2192 Z} {g : Y \u2192 Z}\n    (hf : IsClosedEmbedding f) (hg : IsClosedEmbedding g) (h : Injective (Sum.elim f g)) :\n    IsClosedEmbedding (Sum.elim f g) := by\n  rw [IsClosedEmbedding.isClosedEmbedding_iff_continuous_injective_isClosedMap] at hf hg \u22a2\n  exact \u27e8hf.1.sumElim hg.1, h, hf.2.2.sumElim hg.2.2\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Constructions/SumProd.lean", "context": {"open": ["Topology TopologicalSpace Set Filter Function", "Sum"], "variables": ["{X : Type u} {Y : Type v} {W Z \u03b5 \u03b6 : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z] [TopologicalSpace W]", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\nhf : IsClosedEmbedding f\nhg : IsClosedEmbedding g\nh : Injective (Sum.elim f g)\n\u22a2 IsClosedEmbedding (Sum.elim f g)"}, {"line": "rw [IsClosedEmbedding.isClosedEmbedding_iff_continuous_injective_isClosedMap] at hf hg \u22a2", "tactic_state": "X : Type u\nY : Type v\nZ : Type u_2\ninst\u271d\u2075 : TopologicalSpace X\ninst\u271d\u2074 : TopologicalSpace Y\ninst\u271d\u00b3 : TopologicalSpace Z\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : TopologicalSpace Y\ninst\u271d : TopologicalSpace Z\nf : X \u2192 Z\ng : Y \u2192 Z\nhf : Continuous f \u2227 Injective f \u2227 IsClosedMap f\nhg : Continuous g \u2227 Injective g \u2227 IsClosedMap g\nh : Injective (Sum.elim f g)\n\u22a2 Continuous (Sum.elim f g) \u2227 Injective (Sum.elim f g) \u2227 IsClosedMap (Sum.elim f g)"}, {"line": "exact \u27e8hf.1.sumElim hg.1, h, hf.2.2.sumElim hg.2.2\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isCompact_preimage_of_isClosed (f : CocompactMap \u03b1 \u03b2)\n    \u2983s : Set \u03b2\u2984 (hs : IsCompact s) (h's : IsClosed s) :\n    IsCompact (f \u207b\u00b9' s) := by\n  obtain \u27e8t, ht, hts\u27e9 :=\n    mem_cocompact'.mp\n      (by\n        simpa only [preimage_image_preimage,preimage_compl] using\n          mem_map.mp\n            (cocompact_tendsto f <|\n              mem_cocompact.mpr \u27e8s, hs, compl_subset_compl.mpr (image_preimage_subset f _)\u27e9))\n  exact\n    ht.of_isClosed_subset (h's.preimage <| map_continuous f) (by simpa using hts)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/CocompactMap.lean", "context": {"open": ["Filter Set"], "variables": ["{F \u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[FunLike F \u03b1 \u03b2] [CocompactMapClass F \u03b1 \u03b2]", "{\u03b1 \u03b2 \u03b3 \u03b4 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [TopologicalSpace \u03b3]", "(\u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : CocompactMap \u03b1 \u03b2\ns : Set \u03b2\nhs : IsCompact s\nh's : IsClosed s\n\u22a2 IsCompact (\u21d1f \u207b\u00b9' s)"}, {"line": "obtain \u27e8t, ht, hts\u27e9 :=\n    mem_cocompact'.mp\n      (by\n        simpa only [preimage_image_preimage,preimage_compl] using\n          mem_map.mp\n            (cocompact_tendsto f <|\n              mem_cocompact.mpr \u27e8s, hs, compl_subset_compl.mpr (image_preimage_subset f _)\u27e9))", "tactic_state": "case intro.intro\n\u03b1 : Type u_4\n\u03b2 : Type u_5\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\nf : CocompactMap \u03b1 \u03b2\ns : Set \u03b2\nhs : IsCompact s\nh's : IsClosed s\nt : Set \u03b1\nht : IsCompact t\nhts : (\u21d1f \u207b\u00b9' s)\u1d9c\u1d9c \u2286 t\n\u22a2 IsCompact (\u21d1f \u207b\u00b9' s)"}, {"line": "exact\n    ht.of_isClosed_subset (h's.preimage <| map_continuous f) (by simpa using hts)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_apply [CommMonoid \u03b2] [ContinuousMul \u03b2] {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 C(\u03b1, \u03b2))\n    (a : \u03b1) : (\u220f i \u2208 s, f i) a = \u220f i \u2208 s, f i a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Algebra.lean", "context": {"open": [], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "{f g : { f : \u03b1 \u2192 \u03b2 | Continuous f }}", "{\u03b1 : Type*} {\u03b2 : Type*} {\u03b3 : Type*}", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [TopologicalSpace \u03b3]", "{\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "(\u03b1) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_6\n\u03b2 : Type u_7\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : CommMonoid \u03b2\ninst\u271d : ContinuousMul \u03b2\n\u03b9 : Type u_8\ns : Finset \u03b9\nf : \u03b9 \u2192 C(\u03b1, \u03b2)\na : \u03b1\n\u22a2 (\u220f i \u2208 s, f i) a = \u220f i \u2208 s, (f i) a"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_lt_iff_of_nonempty_compactlySupported [c : Nonempty \u03b1] {f : \u03b1 \u2192\u1d47 \u03b3}\n    (h : f \u2208 C_cb(\u03b1, \u03b3)) {M : \u211d} : \u2016f\u2016 < M \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 < M := by\n  obtain (hM | hM) := lt_or_le 0 M\n  \u00b7 exact norm_lt_iff_of_compactlySupported h hM\n  \u00b7 exact \u27e8fun h \u21a6 False.elim <| (h.trans_le hM).not_le (by positivity),\n      fun h \u21a6 False.elim <| (h (Classical.arbitrary \u03b1) |>.trans_le hM).not_le (by positivity)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/BoundedCompactlySupported.lean", "context": {"open": ["Set BoundedContinuousFunction"], "variables": ["{\u03b1 \u03b3 : Type*} [TopologicalSpace \u03b1] [NonUnitalNormedRing \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b3 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : NonUnitalNormedRing \u03b3\nc : Nonempty \u03b1\nf : BoundedContinuousFunction \u03b1 \u03b3\nh : f \u2208 compactlySupported \u03b1 \u03b3\nM : \u211d\n\u22a2 \u2016f\u2016 < M \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 < M"}, {"line": "obtain (hM | hM) := lt_or_le 0 M", "tactic_state": "case inl\n\u03b1 : Type u_1\n\u03b3 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : NonUnitalNormedRing \u03b3\nc : Nonempty \u03b1\nf : BoundedContinuousFunction \u03b1 \u03b3\nh : f \u2208 compactlySupported \u03b1 \u03b3\nM : \u211d\nhM : 0 < M\n\u22a2 \u2016f\u2016 < M \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 < M\n---\ncase inr\n\u03b1 : Type u_1\n\u03b3 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : NonUnitalNormedRing \u03b3\nc : Nonempty \u03b1\nf : BoundedContinuousFunction \u03b1 \u03b3\nh : f \u2208 compactlySupported \u03b1 \u03b3\nM : \u211d\nhM : M \u2264 0\n\u22a2 \u2016f\u2016 < M \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 < M"}, {"line": "\u00b7 exact norm_lt_iff_of_compactlySupported h hM", "tactic_state": "case inr\n\u03b1 : Type u_1\n\u03b3 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : NonUnitalNormedRing \u03b3\nc : Nonempty \u03b1\nf : BoundedContinuousFunction \u03b1 \u03b3\nh : f \u2208 compactlySupported \u03b1 \u03b3\nM : \u211d\nhM : M \u2264 0\n\u22a2 \u2016f\u2016 < M \u2194 \u2200 (x : \u03b1), \u2016f x\u2016 < M"}, {"line": "\u00b7 exact \u27e8fun h \u21a6 False.elim <| (h.trans_le hM).not_le (by positivity),\n      fun h \u21a6 False.elim <| (h (Classical.arbitrary \u03b1) |>.trans_le hM).not_le (by positivity)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_le (C0 : (0 : \u211d) \u2264 C) : dist f g \u2264 C \u2194 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C := by\n  simp only [\u2190 dist_mkOfCompact]\n  simp only [BoundedContinuousFunction.dist_le C0]\n  simp only [mkOfCompact_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Compact.lean", "context": {"open": ["NNReal BoundedContinuousFunction Set Metric", "BoundedContinuousFunction"], "variables": ["{\u03b1 \u03b2 E : Type*}", "[TopologicalSpace \u03b1] [CompactSpace \u03b1] [PseudoMetricSpace \u03b2] [SeminormedAddCommGroup E]", "(\u03b1 \u03b2)", "{f g : C(\u03b1, \u03b2)} {C : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 \u2264 C\n\u22a2 dist f g \u2264 C \u2194 \u2200 (x : \u03b1), dist (f x) (g x) \u2264 C"}, {"line": "simp only [\u2190 dist_mkOfCompact]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 \u2264 C\n\u22a2 dist (mkOfCompact f) (mkOfCompact g) \u2264 C \u2194 \u2200 (x : \u03b1), dist (f x) (g x) \u2264 C"}, {"line": "simp only [BoundedContinuousFunction.dist_le C0]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 \u2264 C\n\u22a2 (\u2200 (x : \u03b1), dist ((mkOfCompact f) x) ((mkOfCompact g) x) \u2264 C) \u2194 \u2200 (x : \u03b1), dist (f x) (g x) \u2264 C"}, {"line": "simp only [mkOfCompact_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_lt_iff (C0 : (0 : \u211d) < C) : dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C := by\n  rw [\u2190 dist_mkOfCompact]\n  rw [dist_lt_iff_of_compact C0]\n  simp only [mkOfCompact_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Compact.lean", "context": {"open": ["NNReal BoundedContinuousFunction Set Metric", "BoundedContinuousFunction"], "variables": ["{\u03b1 \u03b2 E : Type*}", "[TopologicalSpace \u03b1] [CompactSpace \u03b1] [PseudoMetricSpace \u03b2] [SeminormedAddCommGroup E]", "(\u03b1 \u03b2)", "{f g : C(\u03b1, \u03b2)} {C : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 < C\n\u22a2 dist f g < C \u2194 \u2200 (x : \u03b1), dist (f x) (g x) < C"}, {"line": "rw [\u2190 dist_mkOfCompact]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 < C\n\u22a2 dist (mkOfCompact f) (mkOfCompact g) < C \u2194 \u2200 (x : \u03b1), dist (f x) (g x) < C"}, {"line": "rw [dist_lt_iff_of_compact C0]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 < C\n\u22a2 (\u2200 (x : \u03b1), dist ((mkOfCompact f) x) ((mkOfCompact g) x) < C) \u2194 \u2200 (x : \u03b1), dist (f x) (g x) < C\n---\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 < C\n\u22a2 CompactSpace \u03b1"}, {"line": "simp only [mkOfCompact_apply]", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2 : TopologicalSpace \u03b1\ninst\u271d\u00b9 : CompactSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nf g : C(\u03b1, \u03b2)\nC : \u211d\nC0 : 0 < C\n\u22a2 CompactSpace \u03b1"}]}
{"declaration": "theorem sum_apply [AddCommMonoid \u03b2] [ContinuousAdd \u03b2] {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 C_c(\u03b1, \u03b2))\n    (a : \u03b1) : (\u2211 i \u2208 s, f i) a = \u2211 i \u2208 s, f i a := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/CompactlySupported.lean", "context": {"open": ["CompactlySupported"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*} [TopologicalSpace \u03b1]", "[TopologicalSpace \u03b2] [Zero \u03b2]", "{\u03b3 : Type*} [TopologicalSpace \u03b3] [Zero \u03b3]", "[TopologicalSpace \u03b2] (x : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : ContinuousAdd \u03b2\n\u03b9 : Type u_6\ns : Finset \u03b9\nf : \u03b9 \u2192 CompactlySupportedContinuousMap \u03b1 \u03b2\na : \u03b1\n\u22a2 sorry = \u2211 i \u2208 s, (f i) a"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_3\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : Zero \u03b2\ninst\u271d\u00b2 : TopologicalSpace \u03b2\ninst\u271d\u00b9 : AddCommMonoid \u03b2\ninst\u271d : ContinuousAdd \u03b2\n\u03b9 : Type u_6\ns : Finset \u03b9\nf : \u03b9 \u2192 CompactlySupportedContinuousMap \u03b1 \u03b2\na : \u03b1\n\u22a2 sorry () = \u2211 i \u2208 s, (f i) a"}]}
{"declaration": "lemma toRealLinearMap_apply_apply (f : C_c(\u03b1, \u211d\u22650)) (x : \u03b1) :\n    toRealLinearMap f x = (f x).toReal := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/CompactlySupported.lean", "context": {"open": ["CompactlySupported", "NNReal"], "variables": ["{F \u03b1 \u03b2 \u03b3 : Type*} [TopologicalSpace \u03b1]", "[TopologicalSpace \u03b2] [Zero \u03b2]", "{\u03b3 : Type*} [TopologicalSpace \u03b3] [Zero \u03b3]", "[TopologicalSpace \u03b2] (x : \u03b1)", "[AddGroup \u03b2] [IsTopologicalAddGroup \u03b2] (f g : C_c(\u03b1, \u03b2))", "[TopologicalSpace \u03b2] [AddMonoid \u03b2] [StarAddMonoid \u03b2] [ContinuousStar \u03b2]", "{\ud835\udd5c : Type*} [Zero \ud835\udd5c] [Star \ud835\udd5c] [AddMonoid \u03b2] [StarAddMonoid \u03b2] [TopologicalSpace \u03b2]", "[NonUnitalSemiring \u03b2] [StarRing \u03b2] [TopologicalSpace \u03b2] [ContinuousStar \u03b2]", "{\u03b2 : Type*} [TopologicalSpace \u03b2] [Zero \u03b2] [PartialOrder \u03b2]", "[SemilatticeSup \u03b2] [Zero \u03b2] [TopologicalSpace \u03b2] [ContinuousSup \u03b2]", "[SemilatticeInf \u03b2] [Zero \u03b2] [TopologicalSpace \u03b2] [ContinuousInf \u03b2]", "{\u03b4 : Type*} [TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [TopologicalSpace \u03b4]", "[Zero \u03b4]", "[Zero \u03b2] [TopologicalSpace \u03b2] [FunLike F \u03b1 \u03b2] [CompactlySupportedContinuousMapClass F \u03b1 \u03b2]", "[UniformSpace \u03b2] [UniformSpace \u03b3] [Zero \u03b3] [FunLike F \u03b2 \u03b3]", "[TopologicalSpace \u03b2] [TopologicalSpace \u03b3] [Zero \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nx\u271d : Sort u_9\ntoRealLinearMap : x\u271d\nf : CompactlySupportedContinuousMap \u03b1 NNReal\nx : \u03b1\n\u22a2 sorry = \u2191(f x)"}, {"line": "simp", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : TopologicalSpace \u03b1\nx\u271d : Sort u_9\ntoRealLinearMap : x\u271d\nf : CompactlySupportedContinuousMap \u03b1 NNReal\nx : \u03b1\n\u22a2 sorry () = \u2191(f x)"}]}
{"declaration": "theorem mem_idealOfSet {s : Set X} {f : C(X, R)} :\n    f \u2208 idealOfSet R s \u2194 \u2200 \u2983x : X\u2984, x \u2208 s\u1d9c \u2192 f x = 0 := by\n  convert Iff.rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Ideals.lean", "context": {"open": ["scoped NNReal", "TopologicalSpace"], "variables": ["{X R : Type*} [TopologicalSpace X] [Semiring R]", "[TopologicalSpace R] [IsTopologicalSemiring R]", "(R)", "{R}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : IsTopologicalSemiring R\nx\u271d : Sort u_3\nidealOfSet : x\u271d\ns : Set X\nf : C(X, R)\n\u22a2 f \u2208 sorry \u2194 \u2200 \u2983x : X\u2984, x \u2208 s\u1d9c \u2192 f x = 0"}, {"line": "convert Iff.rfl", "tactic_state": "case h.e'_2.a\nX : Type u_1\nR : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Semiring R\ninst\u271d\u00b9 : TopologicalSpace R\ninst\u271d : IsTopologicalSemiring R\nx\u271d : Sort u_3\nidealOfSet : x\u271d\ns : Set X\nf : C(X, R)\n\u22a2 (\u2200 \u2983x : X\u2984, x \u2208 s\u1d9c \u2192 f x = 0) \u2194 f \u2208 sorry"}]}
{"declaration": "theorem ideal_isMaximal_iff (I : Ideal C(X, \ud835\udd5c)) [hI : IsClosed (I : Set C(X, \ud835\udd5c))] :\n    I.IsMaximal \u2194 \u2203 x : X, idealOfSet \ud835\udd5c {x}\u1d9c = I := by\n  refine\n    \u27e8?_, fun h =>\n      let \u27e8x, hx\u27e9 := h\n      hx \u25b8 idealOf_compl_singleton_isMaximal \ud835\udd5c x\u27e9\n  intro hI'\n  obtain \u27e8x, hx\u27e9 := setOfIdeal_eq_compl_singleton I\n  exact\n    \u27e8x, by\n      simpa only [idealOfSet_ofIdeal_eq_closure,I.closure_eq_of_isClosed hI] using\n        congr_arg (idealOfSet \ud835\udd5c) hx.symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Ideals.lean", "context": {"open": ["scoped NNReal", "TopologicalSpace", "RCLike"], "variables": ["{X R : Type*} [TopologicalSpace X] [Semiring R]", "[TopologicalSpace R] [IsTopologicalSemiring R]", "(R)", "{R}", "(X R)", "{X \ud835\udd5c : Type*} [RCLike \ud835\udd5c] [TopologicalSpace X]", "[CompactSpace X] [T2Space X]", "(\ud835\udd5c)", "(X) in", "{\ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : T2Space X\nx\u271d : Sort u_5\nidealOfSet : x\u271d\nI : Ideal C(X, \ud835\udd5c)\nhI : IsClosed \u2191I\n\u22a2 I.IsMaximal \u2194 \u2203 x, sorry = I"}, {"line": "refine\n    \u27e8?_, fun h =>\n      let \u27e8x, hx\u27e9 := h\n      hx \u25b8 idealOf_compl_singleton_isMaximal \ud835\udd5c x\u27e9", "tactic_state": "X : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : T2Space X\nx\u271d : Sort u_5\nidealOfSet : x\u271d\nI : Ideal C(X, \ud835\udd5c)\nhI : IsClosed \u2191I\n\u22a2 I.IsMaximal \u2192 \u2203 x, sorry = I"}, {"line": "intro hI'", "tactic_state": "X : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : T2Space X\nx\u271d : Sort u_5\nidealOfSet : x\u271d\nI : Ideal C(X, \ud835\udd5c)\nhI : IsClosed \u2191I\nhI' : I.IsMaximal\n\u22a2 \u2203 x, sorry = I"}, {"line": "obtain \u27e8x, hx\u27e9 := setOfIdeal_eq_compl_singleton I", "tactic_state": "case mk\nX : Type u_3\n\ud835\udd5c : Type u_4\ninst\u271d\u00b3 : RCLike \ud835\udd5c\ninst\u271d\u00b2 : TopologicalSpace X\ninst\u271d\u00b9 : CompactSpace X\ninst\u271d : T2Space X\nx\u271d : Sort u_5\nidealOfSet : x\u271d\nI : Ideal C(X, \ud835\udd5c)\nhI : IsClosed \u2191I\nhI' : I.IsMaximal\nx : AddSubmonoid C(X, \ud835\udd5c)\nhx : \u2200 (c : C(X, \ud835\udd5c)) {x_1 : C(X, \ud835\udd5c)}, x_1 \u2208 x.carrier \u2192 c \u2022 x_1 \u2208 x.carrier\n\u22a2 \u2203 x_1, { toAddSubmonoid := x, smul_mem' := hx } = I"}, {"line": "exact\n    \u27e8x, by\n      simpa only [idealOfSet_ofIdeal_eq_closure,I.closure_eq_of_isClosed hI] using\n        congr_arg (idealOfSet \ud835\udd5c) hx.symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IccExtendCM_of_mem {f : C(Icc a b, E)} {x : \u03b1} (hx : x \u2208 Icc a b) :\n    IccExtendCM f x = f \u27e8x, hx\u27e9 := by\n  simp [IccExtendCM, projIccCM, projIcc, hx.1, hx.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Interval.lean", "context": {"open": ["Set ContinuousMap Filter Topology"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "{a b c : \u03b1} [Fact (a \u2264 b)] [Fact (b \u2264 c)]", "{E : Type*} [TopologicalSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2074 : LinearOrder \u03b1\ninst\u271d\u00b3 : TopologicalSpace \u03b1\ninst\u271d\u00b2 : OrderTopology \u03b1\na b : \u03b1\ninst\u271d\u00b9 : Fact (a \u2264 b)\nE : Type u_2\ninst\u271d : TopologicalSpace E\nf : C(\u2191(Icc a b), E)\nx : \u03b1\nhx : x \u2208 Icc a b\n\u22a2 (IccExtendCM f) x = f \u27e8x, hx\u27e9"}, {"line": "simp [IccExtendCM, projIccCM, projIcc, hx.1, hx.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem concatCM_left {x : Icc a c} (hx : x \u2264 b)\n    {fg : {fg : C(Icc a b, E) \u00d7 C(Icc b c, E) // fg.1 \u22a4 = fg.2 \u22a5}} :\n    concatCM fg x = fg.1.1 \u27e8x.1, x.2.1, hx\u27e9 := by\n  exact concat_left fg.2 hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Interval.lean", "context": {"open": ["Set ContinuousMap Filter Topology"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1]", "{a b c : \u03b1} [Fact (a \u2264 b)] [Fact (b \u2264 c)]", "{E : Type*} [TopologicalSpace E]", "{f : C(Icc a b, E)} {g : C(Icc b c, E)}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u2075 : LinearOrder \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b1\ninst\u271d\u00b3 : OrderTopology \u03b1\na b c : \u03b1\ninst\u271d\u00b2 : Fact (a \u2264 b)\ninst\u271d\u00b9 : Fact (b \u2264 c)\nE : Type u_2\ninst\u271d : TopologicalSpace E\nx : \u2191(Icc a c)\nhx : \u2191x \u2264 b\nfg : { fg // fg.1 \u22a4 = fg.2 \u22a5 }\n\u22a2 (concatCM fg) x = (\u2191fg).1 \u27e8\u2191x, \u22ef\u27e9"}, {"line": "exact concat_left fg.2 hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unitsLift_symm_apply_apply_inv' (f : C(X, M)\u02e3) (x : X) :\n    (ContinuousMap.unitsLift.symm f x)\u207b\u00b9 = (\u2191f\u207b\u00b9 : C(X, M)) x := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Units.lean", "context": {"open": [], "variables": ["{X M R \ud835\udd5c : Type*} [TopologicalSpace X]", "[Monoid M] [TopologicalSpace M] [ContinuousMul M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nM : Type u_2\ninst\u271d\u00b3 : TopologicalSpace X\ninst\u271d\u00b2 : Monoid M\ninst\u271d\u00b9 : TopologicalSpace M\ninst\u271d : ContinuousMul M\nf : C(X, M)\u02e3\nx : X\n\u22a2 \u2191((ContinuousMap.unitsLift.symm f) x)\u207b\u00b9 = \u2191f\u207b\u00b9 x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polynomialFunctions_closure_eq_top' : (polynomialFunctions I).topologicalClosure = \u22a4 := by\n  rw [eq_top_iff]\n  rintro f -\n  refine Filter.Frequently.mem_closure ?_\n  refine Filter.Tendsto.frequently (bernsteinApproximation_uniform f) ?_\n  apply Frequently.of_forall\n  intro n\n  simp only [SetLike.mem_coe]\n  apply Subalgebra.sum_mem\n  rintro n -\n  apply Subalgebra.smul_mem\n  dsimp [bernstein, polynomialFunctions]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Weierstrass.lean", "context": {"open": ["ContinuousMap Filter", "scoped unitInterval"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (polynomialFunctions unitInterval).topologicalClosure = \u22a4"}, {"line": "rw [eq_top_iff]", "tactic_state": "\u22a2 \u22a4 \u2264 (polynomialFunctions unitInterval).topologicalClosure"}, {"line": "rintro f -", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 f \u2208 (polynomialFunctions unitInterval).topologicalClosure"}, {"line": "refine Filter.Frequently.mem_closure ?_", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 \u2203\u1da0 (x : C(\u2191unitInterval, \u211d)) in nhds f, x \u2208 \u2191(polynomialFunctions unitInterval).toSubsemiring"}, {"line": "refine Filter.Tendsto.frequently (bernsteinApproximation_uniform f) ?_", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 \u2203\u1da0 (x : \u2115) in atTop, bernsteinApproximation x f \u2208 \u2191(polynomialFunctions unitInterval).toSubsemiring"}, {"line": "apply Frequently.of_forall", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u22a2 \u2200 (x : \u2115), bernsteinApproximation x f \u2208 \u2191(polynomialFunctions unitInterval).toSubsemiring"}, {"line": "intro n", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\nn : \u2115\n\u22a2 bernsteinApproximation n f \u2208 \u2191(polynomialFunctions unitInterval).toSubsemiring"}, {"line": "simp only [SetLike.mem_coe]", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\nn : \u2115\n\u22a2 bernsteinApproximation n f \u2208 (polynomialFunctions unitInterval).toSubsemiring"}, {"line": "apply Subalgebra.sum_mem", "tactic_state": "case h.h\nf : C(\u2191unitInterval, \u211d)\nn : \u2115\n\u22a2 \u2200 x \u2208 Finset.univ, f (bernstein.z x) \u2022 bernstein n \u2191x \u2208 polynomialFunctions unitInterval"}, {"line": "rintro n -", "tactic_state": "case h.h\nf : C(\u2191unitInterval, \u211d)\nn\u271d : \u2115\nn : Fin (n\u271d + 1)\n\u22a2 f (bernstein.z n) \u2022 bernstein n\u271d \u2191n \u2208 polynomialFunctions unitInterval"}, {"line": "apply Subalgebra.smul_mem", "tactic_state": "case h.h.hx\nf : C(\u2191unitInterval, \u211d)\nn\u271d : \u2115\nn : Fin (n\u271d + 1)\n\u22a2 bernstein n\u271d \u2191n \u2208 polynomialFunctions unitInterval"}, {"line": "dsimp [bernstein, polynomialFunctions]", "tactic_state": "case h.h.hx\nf : C(\u2191unitInterval, \u211d)\nn\u271d : \u2115\nn : Fin (n\u271d + 1)\n\u22a2 (bernsteinPolynomial \u211d n\u271d \u2191n).toContinuousMapOn unitInterval \u2208\n    Subalgebra.map (Polynomial.toContinuousMapOnAlgHom unitInterval) \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polynomialFunctions_closure_eq_top (a b : \u211d) :\n    (polynomialFunctions (Set.Icc a b)).topologicalClosure = \u22a4 := by\n  rcases lt_or_le a b with h | h\n  -- (Otherwise it's easy; we'll deal with that later.)\n  \u00b7 -- We can pullback continuous functions on `[a,b]` to continuous functions on `[0,1]`,\n    -- by precomposing with an affine map.\n    let W : C(Set.Icc a b, \u211d) \u2192\u2090[\u211d] C(I, \u211d) :=\n      compRightAlgHom \u211d \u211d (iccHomeoI a b h).symm\n    -- This operation is itself a homeomorphism\n    -- (with respect to the norm topologies on continuous functions).\n    let W' : C(Set.Icc a b, \u211d) \u2243\u209c C(I, \u211d) := (iccHomeoI a b h).arrowCongr (.refl _)\n    have w : (W : C(Set.Icc a b, \u211d) \u2192 C(I, \u211d)) = W' := rfl\n    -- Thus we take the statement of the Weierstrass approximation theorem for `[0,1]`,\n    have p := polynomialFunctions_closure_eq_top'\n    -- and pullback both sides, obtaining an equation between subalgebras of `C([a,b], \u211d)`.\n    apply_fun fun s => s.comap W at p\n    simp only [Algebra.comap_top] at p\n    -- Since the pullback operation is continuous, it commutes with taking `topologicalClosure`,\n    rw [Subalgebra.topologicalClosure_comap_homeomorph _ W W' w] at p\n    -- and precomposing with an affine map takes polynomial functions to polynomial functions.\n    rw [polynomialFunctions.comap_compRightAlgHom_iccHomeoI] at p\n    -- \ud83c\udf89\n    exact p\n  \u00b7 -- Otherwise, `b \u2264 a`, and the interval is a subsingleton,\n    subsingleton [(Set.subsingleton_Icc_of_ge h).coe_sort]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Weierstrass.lean", "context": {"open": ["ContinuousMap Filter", "scoped unitInterval"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 (polynomialFunctions (Set.Icc a b)).topologicalClosure = \u22a4"}, {"line": "rcases lt_or_le a b with h | h", "tactic_state": "case inl\na b : \u211d\nh : a < b\n\u22a2 (polynomialFunctions (Set.Icc a b)).topologicalClosure = \u22a4\n---\ncase inr\na b : \u211d\nh : b \u2264 a\n\u22a2 (polynomialFunctions (Set.Icc a b)).topologicalClosure = \u22a4"}, {"line": "\u00b7 -- We can pullback continuous functions on `[a,b]` to continuous functions on `[0,1]`,\n    let W : C(Set.Icc a b, \u211d) \u2192\u2090[\u211d] C(I, \u211d) :=\n      compRightAlgHom \u211d \u211d (iccHomeoI a b h).symm\n    let W' : C(Set.Icc a b, \u211d) \u2243\u209c C(I, \u211d) := (iccHomeoI a b h).arrowCongr (.refl _)\n    have w : (W : C(Set.Icc a b, \u211d) \u2192 C(I, \u211d)) = W' := rfl\n    have p := polynomialFunctions_closure_eq_top'\n    apply_fun fun s => s.comap W at p\n    simp only [Algebra.comap_top] at p\n    rw [Subalgebra.topologicalClosure_comap_homeomorph _ W W' w] at p\n    rw [polynomialFunctions.comap_compRightAlgHom_iccHomeoI] at p\n    exact p", "tactic_state": "case inr\na b : \u211d\nh : b \u2264 a\n\u22a2 (polynomialFunctions (Set.Icc a b)).topologicalClosure = \u22a4"}, {"line": "\u00b7 -- Otherwise, `b \u2264 a`, and the interval is a subsingleton,\n    subsingleton [(Set.subsingleton_Icc_of_ge h).coe_sort]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousMap_mem_polynomialFunctions_closure (a b : \u211d) (f : C(Set.Icc a b, \u211d)) :\n    f \u2208 (polynomialFunctions (Set.Icc a b)).topologicalClosure := by\n  rw [polynomialFunctions_closure_eq_top _ _]\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Weierstrass.lean", "context": {"open": ["ContinuousMap Filter", "scoped unitInterval"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u22a2 f \u2208 (polynomialFunctions (Set.Icc a b)).topologicalClosure"}, {"line": "rw [polynomialFunctions_closure_eq_top _ _]", "tactic_state": "a b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u22a2 f \u2208 \u22a4"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_polynomial_near_continuousMap (a b : \u211d) (f : C(Set.Icc a b, \u211d)) (\u03b5 : \u211d)\n    (pos : 0 < \u03b5) : \u2203 p : \u211d[X], \u2016p.toContinuousMapOn _ - f\u2016 < \u03b5 := by\n  have w := mem_closure_iff_frequently.mp (continuousMap_mem_polynomialFunctions_closure _ _ f)\n  rw [Metric.nhds_basis_ball.frequently_iff] at w\n  obtain \u27e8-, H, \u27e8m, \u27e8-, rfl\u27e9\u27e9\u27e9 := w \u03b5 pos\n  rw [Metric.mem_ball] at H\n  rw [dist_eq_norm] at H\n  exact \u27e8m, H\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Weierstrass.lean", "context": {"open": ["ContinuousMap Filter", "scoped unitInterval", "scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "have w := mem_closure_iff_frequently.mp (continuousMap_mem_polynomialFunctions_closure _ _ f)", "tactic_state": "a b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nw : \u2203\u1da0 (x : C(\u2191(Set.Icc a b), \u211d)) in nhds f, x \u2208 \u2191(polynomialFunctions (Set.Icc a b)).toSubsemiring\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "rw [Metric.nhds_basis_ball.frequently_iff] at w", "tactic_state": "a b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nw : \u2200 (i : \u211d), 0 < i \u2192 \u2203 x \u2208 Metric.ball f i, x \u2208 \u2191(polynomialFunctions (Set.Icc a b)).toSubsemiring\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "obtain \u27e8-, H, \u27e8m, \u27e8-, rfl\u27e9\u27e9\u27e9 := w \u03b5 pos", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nw : \u2200 (i : \u211d), 0 < i \u2192 \u2203 x \u2208 Metric.ball f i, x \u2208 \u2191(polynomialFunctions (Set.Icc a b)).toSubsemiring\nm : Polynomial \u211d\nH : \u2191(Polynomial.toContinuousMapOnAlgHom (Set.Icc a b)) m \u2208 Metric.ball f \u03b5\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "rw [Metric.mem_ball] at H", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nw : \u2200 (i : \u211d), 0 < i \u2192 \u2203 x \u2208 Metric.ball f i, x \u2208 \u2191(polynomialFunctions (Set.Icc a b)).toSubsemiring\nm : Polynomial \u211d\nH : dist (\u2191(Polynomial.toContinuousMapOnAlgHom (Set.Icc a b)) m) f < \u03b5\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "rw [dist_eq_norm] at H", "tactic_state": "case intro.intro.intro.intro\na b : \u211d\nf : C(\u2191(Set.Icc a b), \u211d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nw : \u2200 (i : \u211d), 0 < i \u2192 \u2203 x \u2208 Metric.ball f i, x \u2208 \u2191(polynomialFunctions (Set.Icc a b)).toSubsemiring\nm : Polynomial \u211d\nH : \u2016\u2191(Polynomial.toContinuousMapOnAlgHom (Set.Icc a b)) m - f\u2016 < \u03b5\n\u22a2 \u2203 p, \u2016p.toContinuousMapOn (Set.Icc a b) - f\u2016 < \u03b5"}, {"line": "exact \u27e8m, H\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exists_polynomial_near_of_continuousOn (a b : \u211d) (f : \u211d \u2192 \u211d)\n    (c : ContinuousOn f (Set.Icc a b)) (\u03b5 : \u211d) (pos : 0 < \u03b5) :\n    \u2203 p : \u211d[X], \u2200 x \u2208 Set.Icc a b, |p.eval x - f x| < \u03b5 := by\n  let f' : C(Set.Icc a b, \u211d) := \u27e8fun x => f x, continuousOn_iff_continuous_restrict.mp c\u27e9\n  obtain \u27e8p, b\u27e9 := exists_polynomial_near_continuousMap a b f' \u03b5 pos\n  use p\n  rw [norm_lt_iff _ pos] at b\n  intro x m\n  exact b \u27e8x, m\u27e9", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Weierstrass.lean", "context": {"open": ["ContinuousMap Filter", "scoped unitInterval", "scoped Polynomial"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b)\n\u03b5 : \u211d\npos : 0 < \u03b5\n\u22a2 \u2203 p, \u2200 x \u2208 Set.Icc a b, |Polynomial.eval x p - f x| < \u03b5"}, {"line": "let f' : C(Set.Icc a b, \u211d) := \u27e8fun x => f x, continuousOn_iff_continuous_restrict.mp c\u27e9", "tactic_state": "a b : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b)\n\u03b5 : \u211d\npos : 0 < \u03b5\nf' : C(\u2191(Set.Icc a b), \u211d) := { toFun := fun x => f \u2191x, continuous_toFun := \u22ef }\n\u22a2 \u2203 p, \u2200 x \u2208 Set.Icc a b, |Polynomial.eval x p - f x| < \u03b5"}, {"line": "obtain \u27e8p, b\u27e9 := exists_polynomial_near_continuousMap a b f' \u03b5 pos", "tactic_state": "case intro\na b\u271d : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b\u271d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nf' : C(\u2191(Set.Icc a b\u271d), \u211d) := { toFun := fun x => f \u2191x, continuous_toFun := \u22ef }\np : Polynomial \u211d\nb : \u2016p.toContinuousMapOn (Set.Icc a b\u271d) - f'\u2016 < \u03b5\n\u22a2 \u2203 p, \u2200 x \u2208 Set.Icc a b\u271d, |Polynomial.eval x p - f x| < \u03b5"}, {"line": "use p", "tactic_state": "case h\na b\u271d : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b\u271d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nf' : C(\u2191(Set.Icc a b\u271d), \u211d) := { toFun := fun x => f \u2191x, continuous_toFun := \u22ef }\np : Polynomial \u211d\nb : \u2016p.toContinuousMapOn (Set.Icc a b\u271d) - f'\u2016 < \u03b5\n\u22a2 \u2200 x \u2208 Set.Icc a b\u271d, |Polynomial.eval x p - f x| < \u03b5"}, {"line": "rw [norm_lt_iff _ pos] at b", "tactic_state": "case h\na b\u271d : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b\u271d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nf' : C(\u2191(Set.Icc a b\u271d), \u211d) := { toFun := fun x => f \u2191x, continuous_toFun := \u22ef }\np : Polynomial \u211d\nb : \u2200 (x : \u2191(Set.Icc a b\u271d)), \u2016(p.toContinuousMapOn (Set.Icc a b\u271d) - f') x\u2016 < \u03b5\n\u22a2 \u2200 x \u2208 Set.Icc a b\u271d, |Polynomial.eval x p - f x| < \u03b5"}, {"line": "intro x m", "tactic_state": "case h\na b\u271d : \u211d\nf : \u211d \u2192 \u211d\nc : ContinuousOn f (Set.Icc a b\u271d)\n\u03b5 : \u211d\npos : 0 < \u03b5\nf' : C(\u2191(Set.Icc a b\u271d), \u211d) := { toFun := fun x => f \u2191x, continuous_toFun := \u22ef }\np : Polynomial \u211d\nb : \u2200 (x : \u2191(Set.Icc a b\u271d)), \u2016(p.toContinuousMapOn (Set.Icc a b\u271d) - f') x\u2016 < \u03b5\nx : \u211d\nm : x \u2208 Set.Icc a b\u271d\n\u22a2 |Polynomial.eval x p - f x| < \u03b5"}, {"line": "exact b \u27e8x, m\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_lt_iff_of_compact [CompactSpace \u03b1] (C0 : (0 : \u211d) < C) :\n    dist f g < C \u2194 \u2200 x : \u03b1, dist (f x) (g x) < C := by\n  fconstructor\n  \u00b7 intro w x\n    exact lt_of_le_of_lt (dist_coe_le_dist x) w\n  \u00b7 by_cases h : Nonempty \u03b1\n    \u00b7 exact dist_lt_of_nonempty_compact\n    \u00b7 rintro -\n      convert C0\n      apply le_antisymm _ dist_nonneg'\n      rw [dist_eq]\n      exact csInf_le \u27e80, fun C => And.left\u27e9 \u27e8le_rfl, fun x => False.elim (h (Nonempty.intro x))\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Bounded/Basic.lean", "context": {"open": ["Topology Bornology NNReal UniformConvergence", "Set Filter Metric Function"], "variables": ["{F : Type*} {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [PseudoMetricSpace \u03b2] [PseudoMetricSpace \u03b3]", "{f g : \u03b1 \u2192\u1d47 \u03b2} {x : \u03b1} {C : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nC : \u211d\ninst\u271d : CompactSpace \u03b1\nC0 : 0 < C\n\u22a2 sorry < C \u2194 \u03b1 \u2192 sorry < C"}, {"line": "fconstructor", "tactic_state": "case mp\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nC : \u211d\ninst\u271d : CompactSpace \u03b1\nC0 : 0 < C\n\u22a2 sorry < C \u2192 \u03b1 \u2192 sorry < C\n---\ncase mpr\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nC : \u211d\ninst\u271d : CompactSpace \u03b1\nC0 : 0 < C\n\u22a2 (\u03b1 \u2192 sorry < C) \u2192 sorry < C"}, {"line": "\u00b7 intro w x\n    exact lt_of_le_of_lt (dist_coe_le_dist x) w", "tactic_state": "case mpr\n\u03b1 : Type u\ninst\u271d\u00b9 : TopologicalSpace \u03b1\nC : \u211d\ninst\u271d : CompactSpace \u03b1\nC0 : 0 < C\n\u22a2 (\u03b1 \u2192 sorry < C) \u2192 sorry < C"}, {"line": "\u00b7 by_cases h : Nonempty \u03b1\n    \u00b7 exact dist_lt_of_nonempty_compact\n    \u00b7 rintro -\n      convert C0\n      apply le_antisymm _ dist_nonneg'\n      rw [dist_eq]\n      exact csInf_le \u27e80, fun C => And.left\u27e9 \u27e8le_rfl, fun x => False.elim (h (Nonempty.intro x))\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq (f : \u03b1 \u2192\u1d47 \u03b2) : \u2016f\u2016 = sInf { C : \u211d | 0 \u2264 C \u2227 \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C } := by\n  simp [norm_def, BoundedContinuousFunction.dist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Bounded/Normed.lean", "context": {"open": ["NNReal Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [SeminormedAddCommGroup \u03b2]", "(f g : \u03b1 \u2192\u1d47 \u03b2) {x : \u03b1} {C : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 sorry\n\u22a2 sorry = sInf {C | 0 \u2264 C \u2227 (\u03b1 \u2192 sorry \u2264 C)}"}, {"line": "simp [norm_def, BoundedContinuousFunction.dist_eq]", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 sorry\n\u22a2 sorry () = sInf {C | 0 \u2264 C \u2227 (\u03b1 \u2192 sorry () \u2264 C)}"}]}
{"declaration": "theorem norm_le (C0 : (0 : \u211d) \u2264 C) : \u2016f\u2016 \u2264 C \u2194 \u2200 x : \u03b1, \u2016f x\u2016 \u2264 C := by\n  simpa using @dist_le _ _ _ _ f 0 _ C0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/ContinuousMap/Bounded/Normed.lean", "context": {"open": ["NNReal Set Function"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w}", "[TopologicalSpace \u03b1] [SeminormedAddCommGroup \u03b2]", "(f g : \u03b1 \u2192\u1d47 \u03b2) {x : \u03b1} {C : \u211d}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : TopologicalSpace \u03b1\nC : \u211d\nC0 : 0 \u2264 C\n\u22a2 sorry \u2264 C \u2194 \u03b1 \u2192 sorry \u2264 C"}, {"line": "simpa using @dist_le _ _ _ _ f 0 _ C0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoLocallyUniformlyOn_iff {\u03b9 : Type*} [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1}\n    {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 n in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5 := by\n  refine \u27e8fun H \u03b5 h\u03b5 => H _ (edist_mem_uniformity h\u03b5), fun H u hu x hx => ?_\u27e9\n  rcases mem_uniformity_edist.1 hu with \u27e8\u03b5, \u03b5pos, h\u03b5\u27e9\n  rcases H \u03b5 \u03b5pos x hx with \u27e8t, ht, Ht\u27e9\n  exact \u27e8t, ht, Ht.mono fun n hs x hx => h\u03b5 (hs x hx)\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\n\u22a2 TendstoLocallyUniformlyOn F f p s \u2194\n    \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5"}, {"line": "refine \u27e8fun H \u03b5 h\u03b5 => H _ (edist_mem_uniformity h\u03b5), fun H u hu x hx => ?_\u27e9", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\nH : \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\nx : \u03b2\nhx : x \u2208 s\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u"}, {"line": "rcases mem_uniformity_edist.1 hu with \u27e8\u03b5, \u03b5pos, h\u03b5\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\nH : \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\nx : \u03b2\nhx : x \u2208 s\n\u03b5 : ENNReal\n\u03b5pos : \u03b5 > 0\nh\u03b5 : \u2200 {a b : \u03b1}, edist a b < \u03b5 \u2192 (a, b) \u2208 u\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u"}, {"line": "rcases H \u03b5 \u03b5pos x hx with \u27e8t, ht, Ht\u27e9", "tactic_state": "case intro.intro.intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\ninst\u271d : TopologicalSpace \u03b2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\nH : \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\nx : \u03b2\nhx : x \u2208 s\n\u03b5 : ENNReal\n\u03b5pos : \u03b5 > 0\nh\u03b5 : \u2200 {a b : \u03b1}, edist a b < \u03b5 \u2192 (a, b) \u2208 u\nt : Set \u03b2\nht : t \u2208 nhdsWithin x s\nHt : \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5\n\u22a2 \u2203 t \u2208 nhdsWithin x s, \u2200\u1da0 (n : \u03b9) in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u"}, {"line": "exact \u27e8t, ht, Ht.mono fun n hs x hx => h\u03b5 (hs x hx)\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformlyOn_iff {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoUniformlyOn F f p s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 n in p, \u2200 x \u2208 s, edist (f x) (F n x) < \u03b5 := by\n  refine \u27e8fun H \u03b5 h\u03b5 => H _ (edist_mem_uniformity h\u03b5), fun H u hu => ?_\u27e9\n  rcases mem_uniformity_edist.1 hu with \u27e8\u03b5, \u03b5pos, h\u03b5\u27e9\n  exact (H \u03b5 \u03b5pos).mono fun n hs x hx => h\u03b5 (hs x hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\n\u22a2 TendstoUniformlyOn F f p s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, edist (f x) (F n x) < \u03b5"}, {"line": "refine \u27e8fun H \u03b5 h\u03b5 => H _ (edist_mem_uniformity h\u03b5), fun H u hu => ?_\u27e9", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\nH : \u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, edist (f x) (F n x) < \u03b5\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, (f x, F n x) \u2208 u"}, {"line": "rcases mem_uniformity_edist.1 hu with \u27e8\u03b5, \u03b5pos, h\u03b5\u27e9", "tactic_state": "case intro.intro\n\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d : PseudoEMetricSpace \u03b1\n\u03b9 : Type u_2\nF : \u03b9 \u2192 \u03b2 \u2192 \u03b1\nf : \u03b2 \u2192 \u03b1\np : Filter \u03b9\ns : Set \u03b2\nH : \u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, edist (f x) (F n x) < \u03b5\nu : Set (\u03b1 \u00d7 \u03b1)\nhu : u \u2208 uniformity \u03b1\n\u03b5 : ENNReal\n\u03b5pos : \u03b5 > 0\nh\u03b5 : \u2200 {a b : \u03b1}, edist a b < \u03b5 \u2192 (a, b) \u2208 u\n\u22a2 \u2200\u1da0 (n : \u03b9) in p, \u2200 x \u2208 s, (f x, F n x) \u2208 u"}, {"line": "exact (H \u03b5 \u03b5pos).mono fun n hs x hx => h\u03b5 (hs x hx)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inseparable_iff : Inseparable x y \u2194 edist x y = 0 := by\n  simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u22a2 Inseparable x y \u2194 edist x y = 0"}, {"line": "simp [inseparable_iff_mem_closure, mem_closure_iff, edist_comm, forall_lt_iff_le']", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u22a2 x \u2208 closure {y} \u2227 y \u2208 closure {x} \u2194 edist x y = 0"}]}
{"declaration": "theorem IsSeparable.exists_countable_dense_subset\n    {s : Set \u03b1} (hs : IsSeparable s) : \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s \u2286 closure t := by\n  have : \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, closedBall x \u03b5 := fun \u03b5 \u03b50 => by\n    rcases hs with \u27e8t, htc, hst\u27e9\n    refine \u27e8t, htc, hst.trans fun x hx => ?_\u27e9\n    rcases mem_closure_iff.1 hx \u03b5 \u03b50 with \u27e8y, hyt, hxy\u27e9\n    exact mem_iUnion\u2082.2 \u27e8y, hyt, mem_closedBall.2 hxy.le\u27e9\n  exact subset_countable_closure_of_almost_dense_set _ this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nhs : TopologicalSpace.IsSeparable s\n\u22a2 \u2203 t \u2286 s, t.Countable \u2227 s \u2286 closure t"}, {"line": "have : \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, closedBall x \u03b5 := fun \u03b5 \u03b50 => by\n    rcases hs with \u27e8t, htc, hst\u27e9\n    refine \u27e8t, htc, hst.trans fun x hx => ?_\u27e9\n    rcases mem_closure_iff.1 hx \u03b5 \u03b50 with \u27e8y, hyt, hxy\u27e9\n    exact mem_iUnion\u2082.2 \u27e8y, hyt, mem_closedBall.2 hxy.le\u27e9", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nhs : TopologicalSpace.IsSeparable s\nthis : \u2200 \u03b5 > 0, \u2203 t, t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, sorry\n\u22a2 \u2203 t \u2286 s, t.Countable \u2227 s \u2286 closure t"}, {"line": "exact subset_countable_closure_of_almost_dense_set _ this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_emetric {\u03b9 : Sort*} {c : \u03b9 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i, c i) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 i, ball x \u03b4 \u2286 c i := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma hs hc\u2081 hc\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\n\u03b9 : Sort u_2\nc : \u03b9 \u2192 Set \u03b1\nhs : IsCompact s\nhc\u2081 : \u2200 (i : \u03b9), IsOpen (c i)\nhc\u2082 : s \u2286 \u22c3 i, c i\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 i, ball x \u03b4 \u2286 c i"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma hs hc\u2081 hc\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_emetric_nhds' {c : (x : \u03b1) \u2192 x \u2208 s \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc : \u2200 x hx, c x hx \u2208 \ud835\udcdd x) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y : s, ball x \u03b4 \u2286 c y y.2 := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhds' hs hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nc : (x : \u03b1) \u2192 x \u2208 s \u2192 Set \u03b1\nhs : IsCompact s\nhc : \u2200 (x : \u03b1) (hx : x \u2208 s), c x hx \u2208 nhds x\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2286 c \u2191y \u22ef"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhds' hs hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_emetric_nhds {c : \u03b1 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc : \u2200 x \u2208 s, c x \u2208 \ud835\udcdd x) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2286 c y := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhds hs hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nc : \u03b1 \u2192 Set \u03b1\nhs : IsCompact s\nhc : \u2200 x \u2208 s, c x \u2208 nhds x\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2286 c y"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhds hs hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_emetric_nhdsWithin' {c : (x : \u03b1) \u2192 x \u2208 s \u2192 Set \u03b1}\n    (hs : IsCompact s) (hc : \u2200 x hx, c x hx \u2208 \ud835\udcdd[s] x) :\n    \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y : s, ball x \u03b4 \u2229 s \u2286 c y y.2 := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhdsWithin' hs hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nc : (x : \u03b1) \u2192 x \u2208 s \u2192 Set \u03b1\nhs : IsCompact s\nhc : \u2200 (x : \u03b1) (hx : x \u2208 s), c x hx \u2208 nhdsWithin x s\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2229 s \u2286 c \u2191y \u22ef"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhdsWithin' hs hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lebesgue_number_lemma_of_emetric_nhdsWithin {c : \u03b1 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc : \u2200 x \u2208 s, c x \u2208 \ud835\udcdd[s] x) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2229 s \u2286 c y := by\n  simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhdsWithin hs hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Basic.lean", "context": {"open": ["Set Filter", "scoped Uniformity Topology NNReal ENNReal Pointwise", "EMetric", "TopologicalSpace", "SeparationQuotient in", "Topology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "(\u03b1) in", "{\u03b3 : Type w} [EMetricSpace \u03b3]", "{s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\nc : \u03b1 \u2192 Set \u03b1\nhs : IsCompact s\nhc : \u2200 x \u2208 s, c x \u2208 nhdsWithin x s\n\u22a2 \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 y, ball x \u03b4 \u2229 s \u2286 c y"}, {"line": "simpa only [ball,UniformSpace.ball,preimage_setOf_eq,edist_comm]\n    using uniformity_basis_edist.lebesgue_number_lemma_nhdsWithin hs hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonempty_monotone_mem {s : Set \u03b1} (hs : s.Nonempty) :\n    Nonempty { u // Monotone u \u2227 \u2200 i : \u2115, u i \u2208 s } := by\n  obtain \u27e8x, hx\u27e9 := hs\n  exact \u27e8\u27e8fun _ => x, fun i j _ => le_rfl, fun _ => hx\u27e9\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\nhs : s.Nonempty\n\u22a2 Nonempty { u // Monotone u \u2227 \u2200 (i : \u2115), u i \u2208 s }"}, {"line": "obtain \u27e8x, hx\u27e9 := hs", "tactic_state": "case intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\ns : Set \u03b1\nx : \u03b1\nhx : x \u2208 s\n\u22a2 Nonempty { u // Monotone u \u2227 \u2200 (i : \u2115), u i \u2208 s }"}, {"line": "exact \u27e8\u27e8fun _ => x, fun i j _ => le_rfl, fun _ => hx\u27e9\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sum_le_of_monotoneOn_Iic (f : \u03b1 \u2192 E) {s : Set \u03b1} {n : \u2115} {u : \u2115 \u2192 \u03b1}\n    (hu : MonotoneOn u (Iic n)) (us : \u2200 i \u2264 n, u i \u2208 s) :\n    (\u2211 i \u2208 Finset.range n, edist (f (u (i + 1))) (f (u i))) \u2264 eVariationOn f s := by\n  simpa using sum_le_of_monotoneOn_Icc f (m := 0) (hu.mono Icc_subset_Iic_self) fun i hi \u21a6 us i hi.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u03b1 \u2192 E\ns : Set \u03b1\nn : \u2115\nu : \u2115 \u2192 \u03b1\nhu : MonotoneOn u (Iic n)\nus : \u2200 i \u2264 n, u i \u2208 s\n\u22a2 \u2211 i \u2208 Finset.range n, edist (f (u (i + 1))) (f (u i)) \u2264 eVariationOn f s"}, {"line": "simpa using sum_le_of_monotoneOn_Icc f (m := 0) (hu.mono Icc_subset_Iic_self) fun i hi \u21a6 us i hi.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mono (f : \u03b1 \u2192 E) {s t : Set \u03b1} (hst : t \u2286 s) : eVariationOn f t \u2264 eVariationOn f s := by\n  apply iSup_le _\n  rintro \u27e8n, \u27e8u, hu, ut\u27e9\u27e9\n  exact sum_le f n hu fun i => hst (ut i)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhst : t \u2286 s\n\u22a2 eVariationOn f t \u2264 eVariationOn f s"}, {"line": "apply iSup_le _", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhst : t \u2286 s\n\u22a2 \u2200 (i : \u2115 \u00d7 { u // Monotone u \u2227 \u2200 (i : \u2115), u i \u2208 t }),\n    \u2211 i_1 \u2208 Finset.range i.1, edist (f (\u2191i.2 (i_1 + 1))) (f (\u2191i.2 i_1)) \u2264 eVariationOn f s"}, {"line": "rintro \u27e8n, \u27e8u, hu, ut\u27e9\u27e9", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d : PseudoEMetricSpace E\nf : \u03b1 \u2192 E\ns t : Set \u03b1\nhst : t \u2286 s\nn : \u2115\nu : \u2115 \u2192 \u03b1\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\n\u22a2 \u2211 i \u2208 Finset.range (n, \u27e8u, \u22ef\u27e9).1, edist (f (\u2191(n, \u27e8u, \u22ef\u27e9).2 (i + 1))) (f (\u2191(n, \u27e8u, \u22ef\u27e9).2 i)) \u2264 eVariationOn f s"}, {"line": "exact sum_le f n hu fun i => hst (ut i)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.BoundedVariationOn.dist_le {E : Type*} [PseudoMetricSpace E] {f : \u03b1 \u2192 E}\n    {s : Set \u03b1} (h : BoundedVariationOn f s) {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) :\n    dist (f x) (f y) \u2264 (eVariationOn f s).toReal := by\n  rw [\u2190 ENNReal.ofReal_le_ofReal_iff ENNReal.toReal_nonneg]\n  rw [ENNReal.ofReal_toReal h]\n  rw [\u2190 edist_dist]\n  exact edist_le f hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_3\ninst\u271d : PseudoMetricSpace E\nf : \u03b1 \u2192 E\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 dist (f x) (f y) \u2264 (eVariationOn f s).toReal"}, {"line": "rw [\u2190 ENNReal.ofReal_le_ofReal_iff ENNReal.toReal_nonneg]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_3\ninst\u271d : PseudoMetricSpace E\nf : \u03b1 \u2192 E\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 ENNReal.ofReal (dist (f x) (f y)) \u2264 ENNReal.ofReal (eVariationOn f s).toReal"}, {"line": "rw [ENNReal.ofReal_toReal h]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_3\ninst\u271d : PseudoMetricSpace E\nf : \u03b1 \u2192 E\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 ENNReal.ofReal (dist (f x) (f y)) \u2264 eVariationOn f s"}, {"line": "rw [\u2190 edist_dist]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b9 : LinearOrder \u03b1\nE : Type u_3\ninst\u271d : PseudoMetricSpace E\nf : \u03b1 \u2192 E\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 edist (f x) (f y) \u2264 eVariationOn f s"}, {"line": "exact edist_le f hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.BoundedVariationOn.sub_le {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (h : BoundedVariationOn f s)\n    {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) : f x - f y \u2264 (eVariationOn f s).toReal := by\n  apply (le_abs_self _).trans\n  rw [\u2190 Real.dist_eq]\n  exact h.dist_le hx hy\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 f x - f y \u2264 (eVariationOn f s).toReal"}, {"line": "apply (le_abs_self _).trans", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 |f x - f y| \u2264 (eVariationOn f s).toReal"}, {"line": "rw [\u2190 Real.dist_eq]", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : BoundedVariationOn f s\nx y : \u03b1\nhx : x \u2208 s\nhy : y \u2208 s\n\u22a2 dist (f x) (f y) \u2264 (eVariationOn f s).toReal"}, {"line": "exact h.dist_le hx hy", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comp_le_of_antitoneOn (f : \u03b1 \u2192 E) {s : Set \u03b1} {t : Set \u03b2} (\u03c6 : \u03b2 \u2192 \u03b1) (h\u03c6 : AntitoneOn \u03c6 t)\n    (\u03c6st : MapsTo \u03c6 t s) : eVariationOn (f \u2218 \u03c6) t \u2264 eVariationOn f s := by\n  refine iSup_le ?_\n  rintro \u27e8n, u, hu, ut\u27e9\n  rw [\u2190 Finset.sum_range_reflect]\n  refine (Finset.sum_congr rfl fun x hx => ?_).trans_le <| le_iSup_of_le\n    \u27e8n, fun i => \u03c6 (u <| n - i), fun x y xy => h\u03c6 (ut _) (ut _) (hu <| Nat.sub_le_sub_left xy n),\n      fun i => \u03c6st (ut _)\u27e9\n    le_rfl\n  rw [Finset.mem_range] at hx\n  dsimp only [Subtype.coe_mk, Function.comp_apply]\n  rw [edist_comm]\n  congr 4 <;> omega\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{\u03b2 : Type*} [LinearOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\n\u22a2 eVariationOn (f \u2218 \u03c6) t \u2264 eVariationOn f s"}, {"line": "refine iSup_le ?_", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\n\u22a2 \u2200 (i : \u2115 \u00d7 { u // Monotone u \u2227 \u2200 (i : \u2115), u i \u2208 t }),\n    \u2211 i_1 \u2208 Finset.range i.1, edist ((f \u2218 \u03c6) (\u2191i.2 (i_1 + 1))) ((f \u2218 \u03c6) (\u2191i.2 i_1)) \u2264 eVariationOn f s"}, {"line": "rintro \u27e8n, u, hu, ut\u27e9", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\n\u22a2 \u2211 i \u2208 Finset.range (n, \u27e8u, \u22ef\u27e9).1, edist ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 (i + 1))) ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 i)) \u2264\n    eVariationOn f s"}, {"line": "rw [\u2190 Finset.sum_range_reflect]", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\n\u22a2 \u2211 j \u2208 Finset.range (n, \u27e8u, \u22ef\u27e9).1,\n      edist ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - j + 1))) ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - j))) \u2264\n    eVariationOn f s"}, {"line": "refine (Finset.sum_congr rfl fun x hx => ?_).trans_le <| le_iSup_of_le\n    \u27e8n, fun i => \u03c6 (u <| n - i), fun x y xy => h\u03c6 (ut _) (ut _) (hu <| Nat.sub_le_sub_left xy n),\n      fun i => \u03c6st (ut _)\u27e9\n    le_rfl", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\nx : \u2115\nhx : x \u2208 Finset.range (n, \u27e8u, \u22ef\u27e9).1\n\u22a2 edist ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - x + 1))) ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - x))) =\n    edist (f (\u2191(n, \u27e8fun i => \u03c6 (u (n - i)), \u22ef\u27e9).2 (x + 1))) (f (\u2191(n, \u27e8fun i => \u03c6 (u (n - i)), \u22ef\u27e9).2 x))"}, {"line": "rw [Finset.mem_range] at hx", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\nx : \u2115\nhx : x < (n, \u27e8u, \u22ef\u27e9).1\n\u22a2 edist ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - x + 1))) ((f \u2218 \u03c6) (\u2191(n, \u27e8u, \u22ef\u27e9).2 ((n, \u27e8u, \u22ef\u27e9).1 - 1 - x))) =\n    edist (f (\u2191(n, \u27e8fun i => \u03c6 (u (n - i)), \u22ef\u27e9).2 (x + 1))) (f (\u2191(n, \u27e8fun i => \u03c6 (u (n - i)), \u22ef\u27e9).2 x))"}, {"line": "dsimp only [Subtype.coe_mk, Function.comp_apply]", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\nx : \u2115\nhx : x < (n, \u27e8u, \u22ef\u27e9).1\n\u22a2 edist (f (\u03c6 (u (n - 1 - x + 1)))) (f (\u03c6 (u (n - 1 - x)))) = edist (f (\u03c6 (u (n - (x + 1))))) (f (\u03c6 (u (n - x))))"}, {"line": "rw [edist_comm]", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d\u00b2 : LinearOrder \u03b1\nE : Type u_2\ninst\u271d\u00b9 : PseudoEMetricSpace E\n\u03b2 : Type u_3\ninst\u271d : LinearOrder \u03b2\nf : \u03b1 \u2192 E\ns : Set \u03b1\nt : Set \u03b2\n\u03c6 : \u03b2 \u2192 \u03b1\nh\u03c6 : AntitoneOn \u03c6 t\n\u03c6st : MapsTo \u03c6 t s\nn : \u2115\nu : \u2115 \u2192 \u03b2\nhu : Monotone u\nut : \u2200 (i : \u2115), u i \u2208 t\nx : \u2115\nhx : x < (n, \u27e8u, \u22ef\u27e9).1\n\u22a2 edist (f (\u03c6 (u (n - 1 - x)))) (f (\u03c6 (u (n - 1 - x + 1)))) = edist (f (\u03c6 (u (n - (x + 1))))) (f (\u03c6 (u (n - x))))"}, {"line": "congr 4 <;> omega", "tactic_state": "No Goals!"}]}
{"declaration": "theorem MonotoneOn.eVariationOn_le {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} (hf : MonotoneOn f s) {a b : \u03b1}\n    (as : a \u2208 s) (bs : b \u2208 s) : eVariationOn f (s \u2229 Icc a b) \u2264 ENNReal.ofReal (f b - f a) := by\n  apply iSup_le _\n  rintro \u27e8n, \u27e8u, hu, us\u27e9\u27e9\n  calc\n    (\u2211 i \u2208 Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n        \u2211 i \u2208 Finset.range n, ENNReal.ofReal (f (u (i + 1)) - f (u i)) := by\n      refine Finset.sum_congr rfl fun i hi => ?_\n      simp only [Finset.mem_range] at hi\n      rw [edist_dist]\n      rw [Real.dist_eq]\n      rw [abs_of_nonneg]\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (\u2211 i \u2208 Finset.range n, (f (u (i + 1)) - f (u i))) := by\n      rw [ENNReal.ofReal_sum_of_nonneg]\n      intro i _\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (f (u n) - f (u 0)) := by rw [Finset.sum_range_sub fun i => f (u i)]\n    _ \u2264 ENNReal.ofReal (f b - f a) := by\n      apply ENNReal.ofReal_le_ofReal\n      exact sub_le_sub (hf (us n).1 bs (us n).2.2) (hf as (us 0).1 (us 0).2.1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter", "OrderDual"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{\u03b2 : Type*} [LinearOrder \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nhf : MonotoneOn f s\na b : \u03b1\nas : a \u2208 s\nbs : b \u2208 s\n\u22a2 eVariationOn f (s \u2229 Icc a b) \u2264 ENNReal.ofReal (f b - f a)"}, {"line": "apply iSup_le _", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nhf : MonotoneOn f s\na b : \u03b1\nas : a \u2208 s\nbs : b \u2208 s\n\u22a2 \u2200 (i : \u2115 \u00d7 { u // Monotone u \u2227 \u2200 (i : \u2115), u i \u2208 s \u2229 Icc a b }),\n    \u2211 i_1 \u2208 Finset.range i.1, edist (f (\u2191i.2 (i_1 + 1))) (f (\u2191i.2 i_1)) \u2264 ENNReal.ofReal (f b - f a)"}, {"line": "rintro \u27e8n, \u27e8u, hu, us\u27e9\u27e9", "tactic_state": "case mk.mk.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nhf : MonotoneOn f s\na b : \u03b1\nas : a \u2208 s\nbs : b \u2208 s\nn : \u2115\nu : \u2115 \u2192 \u03b1\nhu : Monotone u\nus : \u2200 (i : \u2115), u i \u2208 s \u2229 Icc a b\n\u22a2 \u2211 i \u2208 Finset.range (n, \u27e8u, \u22ef\u27e9).1, edist (f (\u2191(n, \u27e8u, \u22ef\u27e9).2 (i + 1))) (f (\u2191(n, \u27e8u, \u22ef\u27e9).2 i)) \u2264\n    ENNReal.ofReal (f b - f a)"}, {"line": "calc\n    (\u2211 i \u2208 Finset.range n, edist (f (u (i + 1))) (f (u i))) =\n        \u2211 i \u2208 Finset.range n, ENNReal.ofReal (f (u (i + 1)) - f (u i)) := by\n      refine Finset.sum_congr rfl fun i hi => ?_\n      simp only [Finset.mem_range] at hi\n      rw [edist_dist]\n      rw [Real.dist_eq]\n      rw [abs_of_nonneg]\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (\u2211 i \u2208 Finset.range n, (f (u (i + 1)) - f (u i))) := by\n      rw [ENNReal.ofReal_sum_of_nonneg]\n      intro i _\n      exact sub_nonneg_of_le (hf (us i).1 (us (i + 1)).1 (hu (Nat.le_succ _)))\n    _ = ENNReal.ofReal (f (u n) - f (u 0)) := by rw [Finset.sum_range_sub fun i => f (u i)]\n    _ \u2264 ENNReal.ofReal (f b - f a) := by\n      apply ENNReal.ofReal_le_ofReal\n      exact sub_le_sub (hf (us n).1 bs (us n).2.2) (hf as (us 0).1 (us 0).2.1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LocallyBoundedVariationOn.exists_monotoneOn_sub_monotoneOn {f : \u03b1 \u2192 \u211d} {s : Set \u03b1}\n    (h : LocallyBoundedVariationOn f s) :\n    \u2203 p q : \u03b1 \u2192 \u211d, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q := by\n  rcases eq_empty_or_nonempty s with (rfl | \u27e8c, cs\u27e9)\n  \u00b7 exact \u27e8f, 0, subsingleton_empty.monotoneOn _, subsingleton_empty.monotoneOn _,\n      (sub_zero f).symm\u27e9\n  \u00b7 exact \u27e8_, _, variationOnFromTo.monotoneOn h cs, variationOnFromTo.sub_self_monotoneOn h cs,\n      (sub_sub_cancel _ _).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/BoundedVariation.lean", "context": {"open": ["scoped NNReal ENNReal Topology UniformConvergence", "Set Filter", "OrderDual"], "variables": ["{\u03b1 : Type*} [LinearOrder \u03b1] {E : Type*} [PseudoEMetricSpace E]", "{\u03b2 : Type*} [LinearOrder \u03b2]", "(f : \u03b1 \u2192 E) (s : Set \u03b1)", "{f s} in", "{f} {s}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : LocallyBoundedVariationOn f s\n\u22a2 \u2203 p q, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q"}, {"line": "rcases eq_empty_or_nonempty s with (rfl | \u27e8c, cs\u27e9)", "tactic_state": "case inl\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\nh : LocallyBoundedVariationOn f \u2205\n\u22a2 \u2203 p q, MonotoneOn p \u2205 \u2227 MonotoneOn q \u2205 \u2227 f = p - q\n---\ncase inr.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : LocallyBoundedVariationOn f s\nc : \u03b1\ncs : c \u2208 s\n\u22a2 \u2203 p q, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q"}, {"line": "\u00b7 exact \u27e8f, 0, subsingleton_empty.monotoneOn _, subsingleton_empty.monotoneOn _,\n      (sub_zero f).symm\u27e9", "tactic_state": "case inr.intro\n\u03b1 : Type u_1\ninst\u271d : LinearOrder \u03b1\nf : \u03b1 \u2192 \u211d\ns : Set \u03b1\nh : LocallyBoundedVariationOn f s\nc : \u03b1\ncs : c \u2208 s\n\u22a2 \u2203 p q, MonotoneOn p s \u2227 MonotoneOn q s \u2227 f = p - q"}, {"line": "\u00b7 exact \u27e8_, _, variationOnFromTo.monotoneOn h cs, variationOnFromTo.sub_self_monotoneOn h cs,\n      (sub_sub_cancel _ _).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_ball' : y \u2208 ball x \u03b5 \u2194 edist x y < \u03b5 := by rw [edist_comm, mem_ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u03b5 : ENNReal\n\u22a2 y \u2208 ball x \u03b5 \u2194 edist x y < \u03b5"}, {"line": "rw [edist_comm, mem_ball]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closedBall' : y \u2208 closedBall x \u03b5 \u2194 edist x y \u2264 \u03b5 := by rw [edist_comm, mem_closedBall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u03b5 : ENNReal\n\u22a2 y \u2208 closedBall x \u03b5 \u2194 edist x y \u2264 \u03b5"}, {"line": "rw [edist_comm, mem_closedBall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_ball_comm : x \u2208 ball y \u03b5 \u2194 y \u2208 ball x \u03b5 := by rw [mem_ball', mem_ball]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u03b5 : ENNReal\n\u22a2 x \u2208 ball y \u03b5 \u2194 y \u2208 ball x \u03b5"}, {"line": "rw [mem_ball', mem_ball]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closedBall_comm : x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5 := by\n  rw [mem_closedBall']\n  rw [mem_closedBall]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u03b5 : ENNReal\n\u22a2 x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5"}, {"line": "rw [mem_closedBall']", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx y : \u03b1\n\u03b5 : ENNReal\n\u22a2 edist y x \u2264 \u03b5 \u2194 y \u2208 closedBall x \u03b5"}, {"line": "rw [mem_closedBall]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ball_zero : ball x 0 = \u2205 := by rw [EMetric.ball_eq_empty_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\nx : \u03b1\n\u22a2 ball x 0 = \u2205"}, {"line": "rw [EMetric.ball_eq_empty_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isOpen_iff : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s := by\n  simp [isOpen_iff_nhds, mem_nhds_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s"}, {"line": "simp [isOpen_iff_nhds, mem_nhds_iff]", "tactic_state": "\u03b1 : Type u\ninst\u271d : PseudoEMetricSpace \u03b1\ns : Set \u03b1\n\u22a2 (\u2200 x \u2208 s, s \u2208 nhds x) \u2194 \u2200 x \u2208 s, \u2203 \u03b5, 0 < \u03b5 \u2227 ball x \u03b5 \u2286 s"}]}
{"declaration": "protected theorem EMetricSpace.ext\n    {\u03b1 : Type*} {m m' : EMetricSpace \u03b1} (h : m.toEDist = m'.toEDist) : m = m' := by\n  cases m\n  cases m'\n  congr\n  ext1\n  assumption\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nm m' : EMetricSpace \u03b1\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 m = m'"}, {"line": "cases m", "tactic_state": "case mk\n\u03b1 : Type u_2\nm' : EMetricSpace \u03b1\ntoPseudoEMetricSpace\u271d : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 { toPseudoEMetricSpace := toPseudoEMetricSpace\u271d, eq_of_edist_eq_zero := eq_of_edist_eq_zero\u271d } = m'"}, {"line": "cases m'", "tactic_state": "case mk.mk\n\u03b1 : Type u_2\ntoPseudoEMetricSpace\u271d\u00b9 : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d\u00b9 : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\ntoPseudoEMetricSpace\u271d : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 { toPseudoEMetricSpace := toPseudoEMetricSpace\u271d\u00b9, eq_of_edist_eq_zero := eq_of_edist_eq_zero\u271d\u00b9 } =\n    { toPseudoEMetricSpace := toPseudoEMetricSpace\u271d, eq_of_edist_eq_zero := eq_of_edist_eq_zero\u271d }"}, {"line": "congr", "tactic_state": "case mk.mk.e_toPseudoEMetricSpace\n\u03b1 : Type u_2\ntoPseudoEMetricSpace\u271d\u00b9 : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d\u00b9 : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\ntoPseudoEMetricSpace\u271d : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 toPseudoEMetricSpace\u271d\u00b9 = toPseudoEMetricSpace\u271d"}, {"line": "ext1", "tactic_state": "case mk.mk.e_toPseudoEMetricSpace.h\n\u03b1 : Type u_2\ntoPseudoEMetricSpace\u271d\u00b9 : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d\u00b9 : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\ntoPseudoEMetricSpace\u271d : PseudoEMetricSpace \u03b1\neq_of_edist_eq_zero\u271d : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y\nh : PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist\n\u22a2 PseudoEMetricSpace.toEDist = PseudoEMetricSpace.toEDist"}, {"line": "assumption", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_pos {x y : \u03b3} : 0 < edist x y \u2194 x \u2260 y := by simp [\u2190 not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Defs.lean", "context": {"open": ["Filter Set Topology", "scoped Uniformity Topology Filter NNReal ENNReal Pointwise", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {X : Type*}", "[PseudoEMetricSpace \u03b1]", "{x y z : \u03b1} {\u03b5 \u03b5\u2081 \u03b5\u2082 : \u211d\u22650\u221e} {s t : Set \u03b1}", "[PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}", "{\u03b3 : Type w} [EMetricSpace \u03b3]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b3 : Type w\ninst\u271d : EMetricSpace \u03b3\nx y : \u03b3\n\u22a2 0 < edist x y \u2194 x \u2260 y"}, {"line": "simp [\u2190 not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzOnWith_iff_restrict : LipschitzOnWith K f s \u2194 LipschitzWith K (s.restrict f) := by\n  simp [LipschitzOnWith, LipschitzWith]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\n\u22a2 LipschitzOnWith K f s \u2194 LipschitzWith K (s.restrict f)"}, {"line": "simp [LipschitzOnWith, LipschitzWith]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lipschitzOnWith_restrict {t : Set s} :\n    LipschitzOnWith K (s.restrict f) t \u2194 LipschitzOnWith K f (s \u2229 Subtype.val '' t) := by\n  simp [LipschitzOnWith, LipschitzWith]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1} {f : \u03b1 \u2192 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\ns : Set \u03b1\nf : \u03b1 \u2192 \u03b2\nt : Set \u2191s\n\u22a2 LipschitzOnWith K (s.restrict f) t \u2194 LipschitzOnWith K f (s \u2229 Subtype.val '' t)"}, {"line": "simp [LipschitzOnWith, LipschitzWith]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_edist_le (h : LipschitzWith K f) (x y : \u03b1) :\n    (K\u207b\u00b9 : \u211d\u22650\u221e) * edist (f x) (f y) \u2264 edist x y := by\n  rw [mul_comm]\n  rw [\u2190 div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (h x y)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} {r : \u211d\u22650\u221e} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nh : LipschitzWith K f\nx y : \u03b1\n\u22a2 (\u2191K)\u207b\u00b9 * edist (f x) (f y) \u2264 edist x y"}, {"line": "rw [mul_comm]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nh : LipschitzWith K f\nx y : \u03b1\n\u22a2 edist (f x) (f y) * (\u2191K)\u207b\u00b9 \u2264 edist x y"}, {"line": "rw [\u2190 div_eq_mul_inv]", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nK : NNReal\nf : \u03b1 \u2192 \u03b2\nh : LipschitzWith K f\nx y : \u03b1\n\u22a2 edist (f x) (f y) / \u2191K \u2264 edist x y"}, {"line": "exact ENNReal.div_le_of_le_mul' (h x y)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_iterate_succ_le_geometric {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) (x n) :\n    edist (f^[n] x) (f^[n + 1] x) \u2264 edist x (f x) * (K : \u211d\u22650\u221e) ^ n := by\n  rw [iterate_succ]\n  rw [mul_comm]\n  simpa only [ENNReal.coe_pow] using (hf.iterate n) x (f x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} {r : \u211d\u22650\u221e} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 edist (f^[n] x) (f^[n + 1] x) \u2264 edist x (f x) * \u2191K ^ n"}, {"line": "rw [iterate_succ]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 edist (f^[n] x) ((f^[n] \u2218 f) x) \u2264 edist x (f x) * \u2191K ^ n"}, {"line": "rw [mul_comm]", "tactic_state": "\u03b1 : Type u\ninst\u271d\u00b9 inst\u271d : PseudoEMetricSpace \u03b1\nK : NNReal\nf : \u03b1 \u2192 \u03b1\nhf : LipschitzWith K f\nx : \u03b1\nn : \u2115\n\u22a2 edist (f^[n] x) ((f^[n] \u2218 f) x) \u2264 \u2191K ^ n * edist x (f x)"}, {"line": "simpa only [ENNReal.coe_pow] using (hf.iterate n) x (f x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuous_prod_of_dense_continuous_lipschitzWith [PseudoEMetricSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoEMetricSpace \u03b3] (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (K : \u211d\u22650) {s : Set \u03b1}\n    (hs : Dense s) (ha : \u2200 a \u2208 s, Continuous fun y => f (a, y))\n    (hb : \u2200 b, LipschitzWith K fun x => f (x, b)) : Continuous f := by\n  simp only [continuous_iff_continuousOn_univ] at *\n  simp only [\u2190 univ_prod_univ] at *\n  simp only [\u2190 lipschitzOnWith_univ] at *\n  exact continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith f (subset_univ _)\n    hs.closure_eq.ge K ha fun b _ => hb b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/EMetricSpace/Lipschitz.lean", "context": {"open": ["Filter Function Set Topology NNReal ENNReal Bornology", "EMetric"], "variables": ["{\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {\u03b9 : Type x}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} {r : \u211d\u22650\u221e} {s : Set \u03b1}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3]", "{K : \u211d\u22650} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] [PseudoEMetricSpace \u03b3] {f : \u03b1 \u2192 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b3\ninst\u271d\u00b9\u2070 : PseudoEMetricSpace \u03b1\ninst\u271d\u2079 : PseudoEMetricSpace \u03b2\ninst\u271d\u2078 : PseudoEMetricSpace \u03b3\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : PseudoEMetricSpace \u03b3\ninst\u271d\u2074 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nK : NNReal\ns : Set \u03b1\nhs : Dense s\nha : \u2200 a \u2208 s, Continuous fun y => f (a, y)\nhb : \u2200 (b : \u03b2), LipschitzWith K fun x => f (x, b)\n\u22a2 Continuous f"}, {"line": "simp only [continuous_iff_continuousOn_univ] at *", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b3\ninst\u271d\u00b9\u2070 : PseudoEMetricSpace \u03b1\ninst\u271d\u2079 : PseudoEMetricSpace \u03b2\ninst\u271d\u2078 : PseudoEMetricSpace \u03b3\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : PseudoEMetricSpace \u03b3\ninst\u271d\u2074 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nK : NNReal\ns : Set \u03b1\nhs : Dense s\nhb : \u2200 (b : \u03b2), LipschitzWith K fun x => f (x, b)\nha : \u2200 a \u2208 s, ContinuousOn (fun y => f (a, y)) univ\n\u22a2 ContinuousOn f univ"}, {"line": "simp only [\u2190 univ_prod_univ] at *", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b3\ninst\u271d\u00b9\u2070 : PseudoEMetricSpace \u03b1\ninst\u271d\u2079 : PseudoEMetricSpace \u03b2\ninst\u271d\u2078 : PseudoEMetricSpace \u03b3\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : PseudoEMetricSpace \u03b3\ninst\u271d\u2074 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nK : NNReal\ns : Set \u03b1\nhs : Dense s\nhb : \u2200 (b : \u03b2), LipschitzWith K fun x => f (x, b)\nha : \u2200 a \u2208 s, ContinuousOn (fun y => f (a, y)) univ\n\u22a2 ContinuousOn f (univ \u00d7\u02e2 univ)"}, {"line": "simp only [\u2190 lipschitzOnWith_univ] at *", "tactic_state": "\u03b1 : Type u\n\u03b2 : Type v\n\u03b3 : Type w\ninst\u271d\u00b9\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u00b9 : PseudoEMetricSpace \u03b3\ninst\u271d\u00b9\u2070 : PseudoEMetricSpace \u03b1\ninst\u271d\u2079 : PseudoEMetricSpace \u03b2\ninst\u271d\u2078 : PseudoEMetricSpace \u03b3\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : PseudoEMetricSpace \u03b3\ninst\u271d\u2074 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9 : TopologicalSpace \u03b2\ninst\u271d : PseudoEMetricSpace \u03b3\nf : \u03b1 \u00d7 \u03b2 \u2192 \u03b3\nK : NNReal\ns : Set \u03b1\nhs : Dense s\nha : \u2200 a \u2208 s, ContinuousOn (fun y => f (a, y)) univ\nhb : \u2200 (b : \u03b2), LipschitzOnWith K (fun x => f (x, b)) univ\n\u22a2 ContinuousOn f (univ \u00d7\u02e2 univ)"}, {"line": "exact continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith f (subset_univ _)\n    hs.closure_eq.ge K ha fun b _ => hb b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mk_mem_localTrivAt_source : (\u27e8b, a\u27e9 : Z.TotalSpace) \u2208 (Z.localTrivAt b).source := by\n  simp only [mfld_simps]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/FiberBundle/Basic.lean", "context": {"open": ["TopologicalSpace Filter Set Bundle Topology", "Trivialization"], "variables": ["{\u03b9 B F X : Type*} [TopologicalSpace X]", "(F)", "[TopologicalSpace B] [TopologicalSpace F] (E : B \u2192 Type*)", "[FiberBundle F E] (b : B)", "{F}", "{E}", "(F)", "[FiberBundle F E]", "(E)", "{E F}", "(F)", "(F)", "(E)", "[TopologicalSpace B] [TopologicalSpace F] (Z : FiberBundleCore \u03b9 B F)", "(i : \u03b9)", "(b : B) (a : F)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nB : Type u_2\nF : Type u_3\ninst\u271d\u00b3 : TopologicalSpace B\ninst\u271d\u00b2 : TopologicalSpace F\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : TopologicalSpace F\nZ : FiberBundleCore \u03b9 B F\nb : B\na : F\n\u22a2 { proj := b, snd := a } \u2208 (Z.localTrivAt b).source"}, {"line": "simp only [mfld_simps]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pullback.continuous_proj (f : B' \u2192 B) : Continuous (\u03c0 F (f *\u1d56 E)) := by\n  rw [continuous_iff_le_induced]\n  rw [Pullback.TotalSpace.topologicalSpace]\n  rw [pullbackTopology_def]\n  exact inf_le_left\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/FiberBundle/Constructions.lean", "context": {"open": ["Bundle Filter Set TopologicalSpace Topology", "FiberBundle", "Trivialization"], "variables": ["(B : Type*) (F : Type*)", "[TopologicalSpace B] [TopologicalSpace F]", "{B : Type*}", "(F\u2081 : Type*) (E\u2081 : B \u2192 Type*) (F\u2082 : Type*) (E\u2082 : B \u2192 Type*)", "[TopologicalSpace (TotalSpace F\u2081 E\u2081)] [TopologicalSpace (TotalSpace F\u2082 E\u2082)]", "[TopologicalSpace B] (F\u2081 : Type*) [TopologicalSpace F\u2081] (E\u2081 : B \u2192 Type*)", "{F\u2081 E\u2081 F\u2082 E\u2082}", "(e\u2081 : Trivialization F\u2081 (\u03c0 F\u2081 E\u2081)) (e\u2082 : Trivialization F\u2082 (\u03c0 F\u2082 E\u2082))", "{e\u2081 e\u2082}", "(e\u2081 e\u2082) [\u2200 x, Zero (E\u2081 x)] [\u2200 x, Zero (E\u2082 x)]", "{e\u2081 e\u2082}", "(e\u2081 e\u2082)", "[\u2200 x, Zero (E\u2081 x)] [\u2200 x, Zero (E\u2082 x)] [\u2200 x : B, TopologicalSpace (E\u2081 x)]", "{B : Type u} (F : Type v) (E : B \u2192 Type w\u2081) {B' : Type w\u2082} (f : B' \u2192 B)", "[TopologicalSpace B'] [TopologicalSpace (TotalSpace F E)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 Continuous TotalSpace.proj"}, {"line": "rw [continuous_iff_le_induced]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 TotalSpace.topologicalSpace F E f \u2264 induced TotalSpace.proj inst\u271d\u00b9"}, {"line": "rw [Pullback.TotalSpace.topologicalSpace]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 pullbackTopology F E f \u2264 induced TotalSpace.proj inst\u271d\u00b9"}, {"line": "rw [pullbackTopology_def]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 induced TotalSpace.proj inst\u271d\u00b9 \u2293 induced (Pullback.lift f) inst\u271d \u2264 induced TotalSpace.proj inst\u271d\u00b9"}, {"line": "exact inf_le_left", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Pullback.continuous_lift (f : B' \u2192 B) : Continuous (@Pullback.lift B F E B' f) := by\n  rw [continuous_iff_le_induced]\n  rw [Pullback.TotalSpace.topologicalSpace]\n  rw [pullbackTopology_def]\n  exact inf_le_right\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/FiberBundle/Constructions.lean", "context": {"open": ["Bundle Filter Set TopologicalSpace Topology", "FiberBundle", "Trivialization"], "variables": ["(B : Type*) (F : Type*)", "[TopologicalSpace B] [TopologicalSpace F]", "{B : Type*}", "(F\u2081 : Type*) (E\u2081 : B \u2192 Type*) (F\u2082 : Type*) (E\u2082 : B \u2192 Type*)", "[TopologicalSpace (TotalSpace F\u2081 E\u2081)] [TopologicalSpace (TotalSpace F\u2082 E\u2082)]", "[TopologicalSpace B] (F\u2081 : Type*) [TopologicalSpace F\u2081] (E\u2081 : B \u2192 Type*)", "{F\u2081 E\u2081 F\u2082 E\u2082}", "(e\u2081 : Trivialization F\u2081 (\u03c0 F\u2081 E\u2081)) (e\u2082 : Trivialization F\u2082 (\u03c0 F\u2082 E\u2082))", "{e\u2081 e\u2082}", "(e\u2081 e\u2082) [\u2200 x, Zero (E\u2081 x)] [\u2200 x, Zero (E\u2082 x)]", "{e\u2081 e\u2082}", "(e\u2081 e\u2082)", "[\u2200 x, Zero (E\u2081 x)] [\u2200 x, Zero (E\u2082 x)] [\u2200 x : B, TopologicalSpace (E\u2081 x)]", "{B : Type u} (F : Type v) (E : B \u2192 Type w\u2081) {B' : Type w\u2082} (f : B' \u2192 B)", "[TopologicalSpace B'] [TopologicalSpace (TotalSpace F E)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 Continuous (Pullback.lift f)"}, {"line": "rw [continuous_iff_le_induced]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 TotalSpace.topologicalSpace F E f \u2264 induced (Pullback.lift f) inst\u271d"}, {"line": "rw [Pullback.TotalSpace.topologicalSpace]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 pullbackTopology F E f \u2264 induced (Pullback.lift f) inst\u271d"}, {"line": "rw [pullbackTopology_def]", "tactic_state": "B : Type u\nF : Type v\nE : B \u2192 Type w\u2081\nB' : Type w\u2082\ninst\u271d\u00b9 : TopologicalSpace B'\ninst\u271d : TopologicalSpace (TotalSpace F E)\nf : B' \u2192 B\n\u22a2 induced TotalSpace.proj inst\u271d\u00b9 \u2293 induced (Pullback.lift f) inst\u271d \u2264 induced (Pullback.lift f) inst\u271d"}, {"line": "exact inf_le_right", "tactic_state": "No Goals!"}]}
{"declaration": "theorem symm_trans_symm (e e' : Pretrivialization F proj) :\n    (e.toPartialEquiv.symm.trans e'.toPartialEquiv).symm\n      = e'.toPartialEquiv.symm.trans e.toPartialEquiv := by\n  rw [PartialEquiv.trans_symm_eq_symm_trans_symm]\n  rw [PartialEquiv.symm_symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/FiberBundle/Trivialization.lean", "context": {"open": ["TopologicalSpace Filter Set Bundle Function", "scoped Topology"], "variables": ["{B : Type*} (F : Type*) {E : B \u2192 Type*}", "{Z : Type*} [TopologicalSpace B] [TopologicalSpace F] {proj : Z \u2192 B}", "{F}", "(e : Pretrivialization F proj) {x : Z}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_1\nF : Type u_2\nZ : Type u_4\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : TopologicalSpace F\nproj : Z \u2192 B\ne e' : Pretrivialization F proj\n\u22a2 (e.symm.trans e'.toPartialEquiv).symm = e'.symm.trans e.toPartialEquiv"}, {"line": "rw [PartialEquiv.trans_symm_eq_symm_trans_symm]", "tactic_state": "B : Type u_1\nF : Type u_2\nZ : Type u_4\ninst\u271d\u00b9 : TopologicalSpace B\ninst\u271d : TopologicalSpace F\nproj : Z \u2192 B\ne e' : Pretrivialization F proj\n\u22a2 e'.symm.trans e.symm.symm = e'.symm.trans e.toPartialEquiv"}, {"line": "rw [PartialEquiv.symm_symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem proj_clift : proj (T.clift (e, \u03b3) i) = \u03b3 i := by\n  simp [clift, liftCM, proj_lift]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/FiberBundle/Trivialization.lean", "context": {"open": ["TopologicalSpace Filter Set Bundle Function", "scoped Topology", "Classical in", "Classical in", "Classical in"], "variables": ["{B : Type*} (F : Type*) {E : B \u2192 Type*}", "{Z : Type*} [TopologicalSpace B] [TopologicalSpace F] {proj : Z \u2192 B}", "{F}", "(e : Pretrivialization F proj) {x : Z}", "(e' : Pretrivialization F (\u03c0 F E)) {b : B} {y : E b}", "[\u2200 x, Zero (E x)]", "[TopologicalSpace Z] [TopologicalSpace (TotalSpace F E)]", "{F}", "(e : Trivialization F proj) {x : Z}", "(e' : Trivialization F (\u03c0 F E)) {b : B} {y : E b}", "[\u2200 x, Zero (E x)]", "{T : Trivialization F proj} {z : Z} {b : B}", "{\u03b9 : Type*} [TopologicalSpace \u03b9] [LocallyCompactPair \u03b9 T.baseSet]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "B : Type u_3\nZ : Type u_1\ninst\u271d\u00b9 : TopologicalSpace B\nproj : Z \u2192 B\ninst\u271d : TopologicalSpace Z\nx\u271d : Sort u_2\n\u03b3 : x\u271d\n\u22a2 proj sorry = sorry"}, {"line": "simp [clift, liftCM, proj_lift]", "tactic_state": "B : Type u_3\nZ : Type u_1\ninst\u271d\u00b9 : TopologicalSpace B\nproj : Z \u2192 B\ninst\u271d : TopologicalSpace Z\nx\u271d : Sort u_2\n\u03b3 : x\u271d\n\u22a2 proj (sorry ()) = sorry ()"}]}
{"declaration": "protected theorem IsG\u03b4.iInter [Countable \u03b9'] {s : \u03b9' \u2192 Set X} (hs : \u2200 i, IsG\u03b4 (s i)) :\n    IsG\u03b4 (\u22c2 i, s i) := by\n  choose T hTo hTc hTs using hs\n  obtain rfl : s = fun i => \u22c2\u2080 T i := funext hTs\n  refine \u27e8\u22c3 i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm\u27e9\n  simpa [@forall_swap \u03b9'] using hTo\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9' : Sort u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9'\ns : \u03b9' \u2192 Set X\nhs : \u2200 (i : \u03b9'), IsG\u03b4 (s i)\n\u22a2 IsG\u03b4 (\u22c2 i, s i)"}, {"line": "choose T hTo hTc hTs using hs", "tactic_state": "X : Type u_1\n\u03b9' : Sort u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9'\ns : \u03b9' \u2192 Set X\nT : \u03b9' \u2192 Set (Set X)\nhTo : \u2200 (i : \u03b9'), \u2200 t \u2208 T i, IsOpen t\nhTc : \u2200 (i : \u03b9'), (T i).Countable\nhTs : \u2200 (i : \u03b9'), s i = \u22c2\u2080 T i\n\u22a2 IsG\u03b4 (\u22c2 i, s i)"}, {"line": "obtain rfl : s = fun i => \u22c2\u2080 T i := funext hTs", "tactic_state": "X : Type u_1\n\u03b9' : Sort u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9'\nT : \u03b9' \u2192 Set (Set X)\nhTo : \u2200 (i : \u03b9'), \u2200 t \u2208 T i, IsOpen t\nhTc : \u2200 (i : \u03b9'), (T i).Countable\nhTs : \u2200 (i : \u03b9'), (fun i => \u22c2\u2080 T i) i = \u22c2\u2080 T i\n\u22a2 IsG\u03b4 (\u22c2 i, (fun i => \u22c2\u2080 T i) i)"}, {"line": "refine \u27e8\u22c3 i, T i, ?_, countable_iUnion hTc, (sInter_iUnion _).symm\u27e9", "tactic_state": "X : Type u_1\n\u03b9' : Sort u_4\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : Countable \u03b9'\nT : \u03b9' \u2192 Set (Set X)\nhTo : \u2200 (i : \u03b9'), \u2200 t \u2208 T i, IsOpen t\nhTc : \u2200 (i : \u03b9'), (T i).Countable\nhTs : \u2200 (i : \u03b9'), (fun i => \u22c2\u2080 T i) i = \u22c2\u2080 T i\n\u22a2 \u2200 t \u2208 \u22c3 i, T i, IsOpen t"}, {"line": "simpa [@forall_swap \u03b9'] using hTo", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.biInter {s : Set \u03b9} (hs : s.Countable) {t : \u2200 i \u2208 s, Set X}\n    (ht : \u2200 (i) (hi : i \u2208 s), IsG\u03b4 (t i hi)) : IsG\u03b4 (\u22c2 i \u2208 s, t i \u2039_\u203a) := by\n  rw [biInter_eq_iInter]\n  haveI := hs.to_subtype\n  exact .iInter fun x => ht x x.2\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nhs : s.Countable\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set X\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), IsG\u03b4 (t i hi)\n\u22a2 IsG\u03b4 (\u22c2 i, \u22c2 (h : i \u2208 s), t i h)"}, {"line": "rw [biInter_eq_iInter]", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nhs : s.Countable\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set X\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), IsG\u03b4 (t i hi)\n\u22a2 IsG\u03b4 (\u22c2 x, t \u2191x \u22ef)"}, {"line": "haveI := hs.to_subtype", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nhs : s.Countable\nt : (i : \u03b9) \u2192 i \u2208 s \u2192 Set X\nht : \u2200 (i : \u03b9) (hi : i \u2208 s), IsG\u03b4 (t i hi)\nthis : Countable \u2191s\n\u22a2 IsG\u03b4 (\u22c2 x, t \u2191x \u22ef)"}, {"line": "exact .iInter fun x => ht x x.2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.sInter {S : Set (Set X)} (h : \u2200 s \u2208 S, IsG\u03b4 s) (hS : S.Countable) : IsG\u03b4 (\u22c2\u2080 S) := by\n  simpa only [sInter_eq_biInter] using IsG\u03b4.biInter hS h\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\nS : Set (Set X)\nh : \u2200 s \u2208 S, IsG\u03b4 s\nhS : S.Countable\n\u22a2 IsG\u03b4 (\u22c2\u2080 S)"}, {"line": "simpa only [sInter_eq_biInter] using IsG\u03b4.biInter hS h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.inter {s t : Set X} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u2229 t) := by\n  rw [inter_eq_iInter]\n  exact .iInter (Bool.forall_bool.2 \u27e8ht, hs\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsG\u03b4 s\nht : IsG\u03b4 t\n\u22a2 IsG\u03b4 (s \u2229 t)"}, {"line": "rw [inter_eq_iInter]", "tactic_state": "X : Type u_1\ninst\u271d : TopologicalSpace X\ns t : Set X\nhs : IsG\u03b4 s\nht : IsG\u03b4 t\n\u22a2 IsG\u03b4 (\u22c2 b, bif b then s else t)"}, {"line": "exact .iInter (Bool.forall_bool.2 \u27e8ht, hs\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsG\u03b4.biUnion {s : Set \u03b9} (hs : s.Finite) {f : \u03b9 \u2192 Set X} (h : \u2200 i \u2208 s, IsG\u03b4 (f i)) :\n    IsG\u03b4 (\u22c3 i \u2208 s, f i) := by\n  rw [\u2190 sUnion_image]\n  exact .sUnion (hs.image _) (forall_mem_image.2 h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nhs : s.Finite\nf : \u03b9 \u2192 Set X\nh : \u2200 i \u2208 s, IsG\u03b4 (f i)\n\u22a2 IsG\u03b4 (\u22c3 i \u2208 s, f i)"}, {"line": "rw [\u2190 sUnion_image]", "tactic_state": "X : Type u_1\n\u03b9 : Type u_3\ninst\u271d : TopologicalSpace X\ns : Set \u03b9\nhs : s.Finite\nf : \u03b9 \u2192 Set X\nh : \u2200 i \u2208 s, IsG\u03b4 (f i)\n\u22a2 IsG\u03b4 (\u22c3\u2080 (f '' s))"}, {"line": "exact .sUnion (hs.image _) (forall_mem_image.2 h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem residual_of_dense_G\u03b4 {s : Set X} (ho : IsG\u03b4 s) (hd : Dense s) : s \u2208 residual X := by\n  rcases ho with \u27e8T, To, Tct, rfl\u27e9\n  exact\n    (countable_sInter_mem Tct).mpr fun t tT =>\n      residual_of_dense_open (To t tT) (hd.mono (sInter_subset_of_mem tT))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\ns : Set X\nho : IsG\u03b4 s\nhd : Dense s\n\u22a2 s \u2208 residual X"}, {"line": "rcases ho with \u27e8T, To, Tct, rfl\u27e9", "tactic_state": "case intro.intro.intro\nX : Type u_1\ninst\u271d\u00b9 inst\u271d : TopologicalSpace X\nT : Set (Set X)\nTo : \u2200 t \u2208 T, IsOpen t\nTct : T.Countable\nhd : Dense (\u22c2\u2080 T)\n\u22a2 \u22c2\u2080 T \u2208 residual X"}, {"line": "exact\n    (countable_sInter_mem Tct).mpr fun t tT =>\n      residual_of_dense_open (To t tT) (hd.mono (sInter_subset_of_mem tT))", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNowhereDense_empty : IsNowhereDense (\u2205 : Set X) := by\n  rw [IsNowhereDense]\n  rw [closure_empty]\n  rw [interior_empty]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set", "Function TopologicalSpace Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 IsNowhereDense \u2205"}, {"line": "rw [IsNowhereDense]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 interior (closure \u2205) = \u2205"}, {"line": "rw [closure_empty]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 interior \u2205 = \u2205"}, {"line": "rw [interior_empty]", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma IsNowhereDense.closure {s : Set X} (hs : IsNowhereDense s) :\n    IsNowhereDense (closure s) := by\n  rwa [IsNowhereDense, closure_closure]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set", "Function TopologicalSpace Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : Set X\nhs : IsNowhereDense s\n\u22a2 IsNowhereDense (closure s)"}, {"line": "rwa [IsNowhereDense, closure_closure]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isClosed_isNowhereDense_iff_compl {s : Set X} :\n    IsClosed s \u2227 IsNowhereDense s \u2194 IsOpen s\u1d9c \u2227 Dense s\u1d9c := by\n  rw [and_congr_right IsClosed.isNowhereDense_iff]\n  rw [isOpen_compl_iff]\n  rw [interior_eq_empty_iff_dense_compl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set", "Function TopologicalSpace Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed s \u2227 IsNowhereDense s \u2194 IsOpen s\u1d9c \u2227 Dense s\u1d9c"}, {"line": "rw [and_congr_right IsClosed.isNowhereDense_iff]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed s \u2227 interior s = \u2205 \u2194 IsOpen s\u1d9c \u2227 Dense s\u1d9c"}, {"line": "rw [isOpen_compl_iff]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : Set X\n\u22a2 IsClosed s \u2227 interior s = \u2205 \u2194 IsClosed s \u2227 Dense s\u1d9c"}, {"line": "rw [interior_eq_empty_iff_dense_compl]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma meagre_empty : IsMeagre (\u2205 : Set X) := by\n  rw [IsMeagre]\n  rw [compl_empty]\n  exact Filter.univ_mem\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set", "Function TopologicalSpace Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 IsMeagre \u2205"}, {"line": "rw [IsMeagre]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 \u2205\u1d9c \u2208 residual X"}, {"line": "rw [compl_empty]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\n\u22a2 univ \u2208 residual X"}, {"line": "exact Filter.univ_mem", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isMeagre_iUnion {s : \u2115 \u2192 Set X} (hs : \u2200 n, IsMeagre (s n)) : IsMeagre (\u22c3 n, s n) := by\n  rw [IsMeagre]\n  rw [compl_iUnion]\n  exact countable_iInter_mem.mpr hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/GDelta/Basic.lean", "context": {"open": ["Topology TopologicalSpace Filter Encodable Set", "Function TopologicalSpace Set"], "variables": ["{X Y \u03b9 : Type*} {\u03b9' : Sort*}", "[TopologicalSpace X]", "[TopologicalSpace X]", "{X : Type*} [TopologicalSpace X]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : \u2115 \u2192 Set X\nhs : \u2200 (n : \u2115), IsMeagre (s n)\n\u22a2 IsMeagre (\u22c3 n, s n)"}, {"line": "rw [IsMeagre]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : \u2115 \u2192 Set X\nhs : \u2200 (n : \u2115), IsMeagre (s n)\n\u22a2 (\u22c3 n, s n)\u1d9c \u2208 residual X"}, {"line": "rw [compl_iUnion]", "tactic_state": "X : Type u_5\ninst\u271d : TopologicalSpace X\ns : \u2115 \u2192 Set X\nhs : \u2200 (n : \u2115), IsMeagre (s n)\n\u22a2 \u22c2 i, (s i)\u1d9c \u2208 residual X"}, {"line": "exact countable_iInter_mem.mpr hs", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_coe (h : X \u2243\u209c Y) : range h = univ := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Topology/Homeomorph/Defs.lean", "context": {"open": ["Set Topology Filter"], "variables": ["{X Y W Z : Type*}", "[TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace W] [TopologicalSpace Z]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "X : Type u_1\nY : Type u_2\ninst\u271d\u00b9 : TopologicalSpace X\ninst\u271d : TopologicalSpace Y\nh : X \u2243\u209c Y\n\u22a2 range \u21d1h = univ"}, {"line": "simp", "tactic_state": "No Goals!"}]}
