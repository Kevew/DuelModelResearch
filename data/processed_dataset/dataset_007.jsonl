{"declaration": "theorem dist_center_homothety (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\n    dist p\u2081 (homothety p\u2081 c p\u2082) = \u2016c\u2016 * dist p\u2081 p\u2082 := by\n  simp [homothety_def, norm_smul, \u2190 dist_eq_norm_vsub, dist_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter", "AffineMap"], "variables": ["{V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c V] [NormedSpace \ud835\udd5c W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : PseudoMetricSpace P\n\ud835\udd5c : Type u_5\np\u2081 p\u2082 : P\nc : \ud835\udd5c\n\u22a2 dist p\u2081 sorry = sorry * dist p\u2081 p\u2082"}, {"line": "simp [homothety_def, norm_smul, \u2190 dist_eq_norm_vsub, dist_comm]", "tactic_state": "P : Type u_2\ninst\u271d : PseudoMetricSpace P\n\ud835\udd5c : Type u_5\np\u2081 p\u2082 : P\nc : \ud835\udd5c\n\u22a2 dist p\u2081 (sorry ()) = sorry () * dist p\u2081 p\u2082"}]}
{"declaration": "theorem dist_lineMap_left (p\u2081 p\u2082 : P) (c : \ud835\udd5c) : dist (lineMap p\u2081 p\u2082 c) p\u2081 = \u2016c\u2016 * dist p\u2081 p\u2082 := by\n  simpa only [lineMap_apply_zero,dist_zero_right] using dist_lineMap_lineMap p\u2081 p\u2082 c 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter", "AffineMap"], "variables": ["{V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c V] [NormedSpace \ud835\udd5c W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_2\ninst\u271d : PseudoMetricSpace P\n\ud835\udd5c : Type u_5\np\u2081 p\u2082 : P\nc : \ud835\udd5c\n\u22a2 dist sorry p\u2081 = sorry * dist p\u2081 p\u2082"}, {"line": "simpa only [lineMap_apply_zero,dist_zero_right] using dist_lineMap_lineMap p\u2081 p\u2082 c 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_pointReflection_right (p q : P) :\n    dist (Equiv.pointReflection p q) q = \u2016(2 : \ud835\udd5c)\u2016 * dist p q := by\n  simp [dist_eq_norm_vsub V, Equiv.pointReflection_vsub_right (G := V), \u2190 Nat.cast_smul_eq_nsmul \ud835\udd5c,\n    norm_smul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter", "AffineMap"], "variables": ["{V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c V] [NormedSpace \ud835\udd5c W]", "[Invertible (2 : \ud835\udd5c)]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np q : P\n\u22a2 dist ((Equiv.pointReflection p) q) q = sorry * dist p q"}, {"line": "simp [dist_eq_norm_vsub V, Equiv.pointReflection_vsub_right (G := V), \u2190 Nat.cast_smul_eq_nsmul \ud835\udd5c,\n    norm_smul]", "tactic_state": "V : Type u_1\nP : Type u_2\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np q : P\n\u22a2 dist ((Equiv.pointReflection p) q) q = sorry () * dist p q"}]}
{"declaration": "theorem dist_midpoint_midpoint_le (p\u2081 p\u2082 p\u2083 p\u2084 : V) :\n    dist (midpoint \u211d p\u2081 p\u2082) (midpoint \u211d p\u2083 p\u2084) \u2264 (dist p\u2081 p\u2083 + dist p\u2082 p\u2084) / 2 := by\n  simpa using dist_midpoint_midpoint_le' (\ud835\udd5c := \u211d) p\u2081 p\u2082 p\u2083 p\u2084\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter", "AffineMap"], "variables": ["{V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c V] [NormedSpace \ud835\udd5c W]", "[Invertible (2 : \ud835\udd5c)]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c)", "[NormedSpace \u211d V] [NormedSpace \u211d W]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_1\ninst\u271d : SeminormedAddCommGroup V\np\u2081 p\u2082 p\u2083 p\u2084 : V\n\u22a2 dist sorry sorry \u2264 (dist p\u2081 p\u2083 + dist p\u2082 p\u2084) / 2"}, {"line": "simpa using dist_midpoint_midpoint_le' (\ud835\udd5c := \u211d) p\u2081 p\u2082 p\u2083 p\u2084", "tactic_state": "No Goals!"}]}
{"declaration": "lemma DilationEquiv.smulTorsor_preimage_ball {c : P} {k : \ud835\udd5c} (hk : k \u2260 0) :\n    smulTorsor c hk \u207b\u00b9' (Metric.ball c \u2016k\u2016) = Metric.ball (0 : E) 1 := by\n  aesop (add simp norm_smul)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter", "AffineMap", "Dilation"], "variables": ["{V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [NormedSpace \ud835\udd5c V] [NormedSpace \ud835\udd5c W]", "[Invertible (2 : \ud835\udd5c)]", "(\ud835\udd5c) in", "(\ud835\udd5c) in", "(\ud835\udd5c)", "[NormedSpace \u211d V] [NormedSpace \u211d W]", "{\ud835\udd5c E : Type*} [NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E] {P : Type*} [PseudoMetricSpace P] [NormedAddTorsor E P]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_5\nE : Type u_6\ninst\u271d\u2075 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : Module \ud835\udd5c E\ninst\u271d\u00b2 : IsBoundedSMul \ud835\udd5c E\nP : Type u_7\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor E P\nc : P\nk : \ud835\udd5c\nhk : k \u2260 0\n\u22a2 \u21d1(smulTorsor c hk) \u207b\u00b9' Metric.ball c \u2016k\u2016 = Metric.ball 0 1"}, {"line": "aesop (add simp norm_smul)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AffineBasis.interior_convexHull {\u03b9 E : Type*} [Finite \u03b9] [NormedAddCommGroup E]\n    [NormedSpace \u211d E] (b : AffineBasis \u03b9 \u211d E) :\n    interior (convexHull \u211d (range b)) = {x | \u2200 i, 0 < b.coord i x} := by\n  cases subsingleton_or_nontrivial \u03b9\n  \u00b7 -- The zero-dimensional case.\n    have : range b = univ :=\n      AffineSubspace.eq_univ_of_subsingleton_span_eq_top (subsingleton_range _) b.tot\n    simp [this]\n  \u00b7 -- The positive-dimensional case.\n    haveI : FiniteDimensional \u211d E := b.finiteDimensional\n    have : convexHull \u211d (range b) = \u22c2 i, b.coord i \u207b\u00b9' Ici 0 := by\n      rw [b.convexHull_eq_nonneg_coord]; rfl\n      rw [setOf_forall]; rfl\n    ext\n    simp only [this]\n    simp only [interior_iInter_of_finite]\n    simp only [\u2190       IsOpenMap.preimage_interior_eq_interior_preimage (isOpenMap_barycentric_coord b _)         (continuous_barycentric_coord b _)]\n    simp only [interior_Ici]\n    simp only [mem_iInter]\n    simp only [mem_setOf_eq]\n    simp only [mem_Ioi]\n    simp only [mem_preimage]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/AddTorsorBases.lean", "context": {"open": ["Set"], "variables": ["{\u03b9 \ud835\udd5c E P : Type*} [NontriviallyNormedField \ud835\udd5c] [CompleteSpace \ud835\udd5c]", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[MetricSpace P] [NormedAddTorsor E P]", "[FiniteDimensional \ud835\udd5c E] (b : AffineBasis \u03b9 \ud835\udd5c P)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_5\nE : Type u_6\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nb : AffineBasis \u03b9 \u211d E\n\u22a2 interior ((convexHull \u211d) (range \u21d1b)) = {x | \u2200 (i : \u03b9), 0 < (b.coord i) x}"}, {"line": "cases subsingleton_or_nontrivial \u03b9", "tactic_state": "case inl\n\u03b9 : Type u_5\nE : Type u_6\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nb : AffineBasis \u03b9 \u211d E\nh\u271d : Subsingleton \u03b9\n\u22a2 interior ((convexHull \u211d) (range \u21d1b)) = {x | \u2200 (i : \u03b9), 0 < (b.coord i) x}\n---\ncase inr\n\u03b9 : Type u_5\nE : Type u_6\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nb : AffineBasis \u03b9 \u211d E\nh\u271d : Nontrivial \u03b9\n\u22a2 interior ((convexHull \u211d) (range \u21d1b)) = {x | \u2200 (i : \u03b9), 0 < (b.coord i) x}"}, {"line": "\u00b7 -- The zero-dimensional case.\n    have : range b = univ :=\n      AffineSubspace.eq_univ_of_subsingleton_span_eq_top (subsingleton_range _) b.tot\n    simp [this]", "tactic_state": "case inr\n\u03b9 : Type u_5\nE : Type u_6\ninst\u271d\u00b2 : Finite \u03b9\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nb : AffineBasis \u03b9 \u211d E\nh\u271d : Nontrivial \u03b9\n\u22a2 interior ((convexHull \u211d) (range \u21d1b)) = {x | \u2200 (i : \u03b9), 0 < (b.coord i) x}"}, {"line": "\u00b7 -- The positive-dimensional case.\n    haveI : FiniteDimensional \u211d E := b.finiteDimensional\n    have : convexHull \u211d (range b) = \u22c2 i, b.coord i \u207b\u00b9' Ici 0 := by\n      rw [b.convexHull_eq_nonneg_coord]; rfl\n      rw [setOf_forall]; rfl\n    ext\n    simp only [this]\n    simp only [interior_iInter_of_finite]\n    simp only [\u2190       IsOpenMap.preimage_interior_eq_interior_preimage (isOpenMap_barycentric_coord b _)         (continuous_barycentric_coord b _)]\n    simp only [interior_Ici]\n    simp only [mem_iInter]\n    simp only [mem_setOf_eq]\n    simp only [mem_Ioi]\n    simp only [mem_preimage]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_map (x y : P) : nndist (f x) (f y) = nndist x y := by simp [nndist_dist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/Isometry.lean", "context": {"open": ["Function Set"], "variables": ["(\ud835\udd5c : Type*) {V V\u2081 V\u2081' V\u2082 V\u2083 V\u2084 : Type*} {P\u2081 P\u2081' : Type*} (P P\u2082 : Type*) {P\u2083 P\u2084 : Type*}", "{\ud835\udd5c P P\u2082}", "(f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)", "(f : V \u2192\u2097\u1d62[\ud835\udd5c] V\u2082)", "(f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (f\u2081 : P\u2081' \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_10\nx y : P\n\u22a2 nndist sorry sorry = sorry"}, {"line": "simp [nndist_dist]", "tactic_state": "P : Type u_10\nx y : P\n\u22a2 nndist (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem edist_map (x y : P) : edist (f x) (f y) = edist x y := by simp [edist_dist]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Affine/Isometry.lean", "context": {"open": ["Function Set"], "variables": ["(\ud835\udd5c : Type*) {V V\u2081 V\u2081' V\u2082 V\u2083 V\u2084 : Type*} {P\u2081 P\u2081' : Type*} (P P\u2082 : Type*) {P\u2083 P\u2084 : Type*}", "{\ud835\udd5c P P\u2082}", "(f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)", "(f : V \u2192\u2097\u1d62[\ud835\udd5c] V\u2082)", "(f : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082) (f\u2081 : P\u2081' \u2192\u1d43\u2071[\ud835\udd5c] P\u2082)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "P : Type u_10\nx y : P\n\u22a2 edist sorry sorry = sorry"}, {"line": "simp [edist_dist]", "tactic_state": "P : Type u_10\nx y : P\n\u22a2 edist (sorry ()) (sorry ()) = sorry ()"}]}
{"declaration": "theorem exp_of_re_eq_zero (q : Quaternion \u211d) (hq : q.re = 0) :\n    exp \u211d q = \u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q := by\n  rw [exp_eq_tsum]\n  refine HasSum.tsum_eq ?_\n  simp_rw [\u2190 expSeries_apply_eq]\n  exact hasSum_expSeries_of_imaginary hq (Real.hasSum_cos _) (Real.hasSum_sin _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/QuaternionExponential.lean", "context": {"open": ["scoped Quaternion Nat", "NormedSpace"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : Quaternion \u211d\nhq : q.re = 0\n\u22a2 exp \u211d q = \u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q"}, {"line": "rw [exp_eq_tsum]", "tactic_state": "q : Quaternion \u211d\nhq : q.re = 0\n\u22a2 (fun x => \u2211' (n : \u2115), (\u2191n.factorial)\u207b\u00b9 \u2022 x ^ n) q = \u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q"}, {"line": "refine HasSum.tsum_eq ?_", "tactic_state": "q : Quaternion \u211d\nhq : q.re = 0\n\u22a2 HasSum (fun n => (\u2191n.factorial)\u207b\u00b9 \u2022 q ^ n) (\u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q)"}, {"line": "simp_rw [\u2190 expSeries_apply_eq]", "tactic_state": "q : Quaternion \u211d\nhq : q.re = 0\n\u22a2 HasSum (fun n => (expSeries \u211d (Quaternion \u211d) n) fun x => q) (\u2191(Real.cos \u2016q\u2016) + (Real.sin \u2016q\u2016 / \u2016q\u2016) \u2022 q)"}, {"line": "exact hasSum_expSeries_of_imaginary hq (Real.hasSum_cos _) (Real.hasSum_sin _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem re_exp (q : \u210d[\u211d]) : (exp \u211d q).re = exp \u211d q.re * Real.cos \u2016q - q.re\u2016 := by simp [exp_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/QuaternionExponential.lean", "context": {"open": ["scoped Quaternion Nat", "NormedSpace"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : Quaternion \u211d\n\u22a2 (exp \u211d q).re = exp \u211d q.re * Real.cos \u2016q - \u2191q.re\u2016"}, {"line": "simp [exp_eq]", "tactic_state": "q : Quaternion \u211d\n\u22a2 (exp \u211d q).re = exp \u211d q.re * Real.cos \u2016q.im\u2016"}]}
{"declaration": "lemma unitization_norm_inr (x : A) : \u2016(WithLp.equiv 1 (Unitization \ud835\udd5c A)).symm x\u2016 = \u2016x\u2016 := by\n  simp [unitization_norm_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/UnitizationL1.lean", "context": {"open": ["Unitization", "ENNReal in"], "variables": ["(\ud835\udd5c A : Type*) [NormedField \ud835\udd5c] [NonUnitalNormedRing A]", "[NormedSpace \ud835\udd5c A]", "{\ud835\udd5c A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\nx : A\n\u22a2 sorry = sorry"}, {"line": "simp [unitization_norm_def]", "tactic_state": "A : Type u_2\nx : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "lemma unitization_nnnorm_inr (x : A) : \u2016(WithLp.equiv 1 (Unitization \ud835\udd5c A)).symm x\u2016\u208a = \u2016x\u2016\u208a := by\n  simp [unitization_nnnorm_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/UnitizationL1.lean", "context": {"open": ["Unitization", "ENNReal in"], "variables": ["(\ud835\udd5c A : Type*) [NormedField \ud835\udd5c] [NonUnitalNormedRing A]", "[NormedSpace \ud835\udd5c A]", "{\ud835\udd5c A}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_2\nx : A\n\u22a2 sorry = sorry"}, {"line": "simp [unitization_nnnorm_def]", "tactic_state": "A : Type u_2\nx : A\n\u22a2 sorry () = sorry ()"}]}
{"declaration": "theorem expSeries_apply_eq (x : \ud835\udd38) (n : \u2115) :\n    (expSeries \ud835\udd42 \ud835\udd38 n fun _ => x) = (n !\u207b\u00b9 : \ud835\udd42) \u2022 x ^ n := by simp [expSeries]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/Exponential.lean", "context": {"open": ["Filter RCLike ContinuousMultilinearMap NormedField Asymptotics FormalMultilinearSeries", "scoped Nat Topology ENNReal"], "variables": ["(\ud835\udd42 \ud835\udd38 : Type*) [Field \ud835\udd42] [Ring \ud835\udd38] [Algebra \ud835\udd42 \ud835\udd38] [TopologicalSpace \ud835\udd38] [IsTopologicalRing \ud835\udd38]", "{\ud835\udd38}", "{\ud835\udd42}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd42 : Type u_1\n\ud835\udd38 : Type u_2\ninst\u271d\u2074 : Field \ud835\udd42\ninst\u271d\u00b3 : Ring \ud835\udd38\ninst\u271d\u00b2 : Algebra \ud835\udd42 \ud835\udd38\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd38\ninst\u271d : IsTopologicalRing \ud835\udd38\nx\u271d : Sort u_3\nexpSeries : x\u271d\nx : \ud835\udd38\nn : \u2115\n\u22a2 sorry = (\u2191n.factorial)\u207b\u00b9 \u2022 x ^ n"}, {"line": "simp [expSeries]", "tactic_state": "\ud835\udd42 : Type u_1\n\ud835\udd38 : Type u_2\ninst\u271d\u2074 : Field \ud835\udd42\ninst\u271d\u00b3 : Ring \ud835\udd38\ninst\u271d\u00b2 : Algebra \ud835\udd42 \ud835\udd38\ninst\u271d\u00b9 : TopologicalSpace \ud835\udd38\ninst\u271d : IsTopologicalRing \ud835\udd38\nx\u271d : Sort u_3\nexpSeries : x\u271d\nx : \ud835\udd38\nn : \u2115\n\u22a2 sorry () = (\u2191n.factorial)\u207b\u00b9 \u2022 x ^ n"}]}
{"declaration": "theorem SpectralRadius.of_subsingleton [Subsingleton A] (a : A) : spectralRadius \ud835\udd5c a = 0 := by\n  simp [spectralRadius]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/Spectrum.lean", "context": {"open": ["NormedSpace Topology -- For `NormedSpace.exp`.", "scoped ENNReal NNReal", "Filter"], "variables": ["{\ud835\udd5c : Type*} {A : Type*}", "[NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : Subsingleton A\na : A\n\u22a2 spectralRadius \ud835\udd5c a = 0"}, {"line": "simp [spectralRadius]", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c A\ninst\u271d : Subsingleton A\na : A\n\u22a2 \u2200 i \u2208 spectrum \ud835\udd5c a, \u2016i\u2016\u208a = 0"}]}
{"declaration": "theorem spectralRadius_zero : spectralRadius \ud835\udd5c (0 : A) = 0 := by\n  nontriviality A\n  simp [spectralRadius]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/Spectrum.lean", "context": {"open": ["NormedSpace Topology -- For `NormedSpace.exp`.", "scoped ENNReal NNReal", "Filter"], "variables": ["{\ud835\udd5c : Type*} {A : Type*}", "[NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\n\u22a2 spectralRadius \ud835\udd5c 0 = 0"}, {"line": "nontriviality A", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\na\u271d : Nontrivial A\n\u22a2 spectralRadius \ud835\udd5c 0 = 0"}, {"line": "simp [spectralRadius]", "tactic_state": "\ud835\udd5c : Type u_1\nA : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : NormedRing A\ninst\u271d : NormedAlgebra \ud835\udd5c A\na\u271d : Nontrivial A\n\u22a2 \u20160\u2016\u208a = 0"}]}
{"declaration": "lemma nnreal_iff [Algebra \u211d A] {a : A} :\n    SpectrumRestricts a ContinuousMap.realToNNReal \u2194 \u2200 x \u2208 spectrum \u211d a, 0 \u2264 x := by\n  refine \u27e8fun h x hx \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8x, -, rfl\u27e9 := h.algebraMap_image.symm \u25b8 hx\n    exact coe_nonneg x\n  \u00b7 exact .of_subset_range_algebraMap (fun _ \u21a6 Real.toNNReal_coe) fun x hx \u21a6 \u27e8\u27e8x, h x hx\u27e9, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/Spectrum.lean", "context": {"open": ["NormedSpace Topology -- For `NormedSpace.exp`.", "scoped ENNReal NNReal", "Filter", "NNReal", "ENNReal Polynomial", "Filter Asymptotics Bornology Topology", "ContinuousMultilinearMap ENNReal FormalMultilinearSeries", "scoped NNReal ENNReal", "Filter ENNReal ContinuousMultilinearMap", "scoped Topology", "scoped Polynomial", "Polynomial", "Topology Filter Set", "SubalgebraClass in", "Set Notation", "NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} {A : Type*}", "[NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "[CompleteSpace A]", "{B : Type*} [NonUnitalNormedRing B] [NormedSpace \ud835\udd5c B] [CompleteSpace B]", "[IsScalarTower \ud835\udd5c B B] [SMulCommClass \ud835\udd5c B B] [ProperSpace \ud835\udd5c]", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] [NormOneClass A]", "(\ud835\udd5c)", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "(\ud835\udd5c) in", "[NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A]", "[NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] [Nontrivial A] (a : A)", "[NormedRing A] [NormedAlgebra \u2102 A] (hA : \u2200 {a : A}, IsUnit a \u2194 a \u2260 0)", "{F : Type*} [NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [CompleteSpace A]", "[NormedAlgebra \ud835\udd5c A]", "{\ud835\udd5c A SA : Type*} [NormedRing A] [CompleteSpace A] [SetLike SA A] [SubringClass SA A]", "[NormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c A] [instSMulMem : SMulMemClass SA \ud835\udd5c A]", "(S : SA) [hS : IsClosed (S : Set A)] (x : S)", "[NontriviallyNormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c A] [SMulMemClass SA \ud835\udd5c A]", "(S : SA) [hS : IsClosed (S : Set A)] (x : S)", "{A : Type*} [Ring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\na : A\n\u22a2 SpectrumRestricts a \u21d1ContinuousMap.realToNNReal \u2194 \u2200 x \u2208 spectrum \u211d a, 0 \u2264 x"}, {"line": "refine \u27e8fun h x hx \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\na : A\nh : SpectrumRestricts a \u21d1ContinuousMap.realToNNReal\nx : \u211d\nhx : x \u2208 spectrum \u211d a\n\u22a2 0 \u2264 x\n---\ncase refine_2\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\na : A\nh : \u2200 x \u2208 spectrum \u211d a, 0 \u2264 x\n\u22a2 SpectrumRestricts a \u21d1ContinuousMap.realToNNReal"}, {"line": "\u00b7 obtain \u27e8x, -, rfl\u27e9 := h.algebraMap_image.symm \u25b8 hx\n    exact coe_nonneg x", "tactic_state": "case refine_2\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u211d A\na : A\nh : \u2200 x \u2208 spectrum \u211d a, 0 \u2264 x\n\u22a2 SpectrumRestricts a \u21d1ContinuousMap.realToNNReal"}, {"line": "\u00b7 exact .of_subset_range_algebraMap (fun _ \u21a6 Real.toNNReal_coe) fun x hx \u21a6 \u27e8\u27e8x, h x hx\u27e9, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma real_iff [Algebra \u2102 A] {a : A} :\n    SpectrumRestricts a Complex.reCLM \u2194 \u2200 x \u2208 spectrum \u2102 a, x = x.re := by\n  refine \u27e8fun h x hx \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 obtain \u27e8x, -, rfl\u27e9 := h.algebraMap_image.symm \u25b8 hx\n    simp\n  \u00b7 exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx \u21a6 \u27e8x.re, (h x hx).symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Algebra/Spectrum.lean", "context": {"open": ["NormedSpace Topology -- For `NormedSpace.exp`.", "scoped ENNReal NNReal", "Filter", "NNReal", "ENNReal Polynomial", "Filter Asymptotics Bornology Topology", "ContinuousMultilinearMap ENNReal FormalMultilinearSeries", "scoped NNReal ENNReal", "Filter ENNReal ContinuousMultilinearMap", "scoped Topology", "scoped Polynomial", "Polynomial", "Topology Filter Set", "SubalgebraClass in", "Set Notation", "NNReal ENNReal"], "variables": ["{\ud835\udd5c : Type*} {A : Type*}", "[NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "[CompleteSpace A]", "{B : Type*} [NonUnitalNormedRing B] [NormedSpace \ud835\udd5c B] [CompleteSpace B]", "[IsScalarTower \ud835\udd5c B B] [SMulCommClass \ud835\udd5c B B] [ProperSpace \ud835\udd5c]", "{A : Type*} [NormedRing A] [NormedAlgebra \u211d A] [CompleteSpace A] [NormOneClass A]", "(\ud835\udd5c)", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A]", "(\ud835\udd5c) in", "[NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A]", "[NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] [Nontrivial A] (a : A)", "[NormedRing A] [NormedAlgebra \u2102 A] (hA : \u2200 {a : A}, IsUnit a \u2194 a \u2260 0)", "{F : Type*} [NormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [NormedAlgebra \ud835\udd5c A] [CompleteSpace A]", "[NontriviallyNormedField \ud835\udd5c] [NormedRing A] [CompleteSpace A]", "[NormedAlgebra \ud835\udd5c A]", "{\ud835\udd5c A SA : Type*} [NormedRing A] [CompleteSpace A] [SetLike SA A] [SubringClass SA A]", "[NormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c A] [instSMulMem : SMulMemClass SA \ud835\udd5c A]", "(S : SA) [hS : IsClosed (S : Set A)] (x : S)", "[NontriviallyNormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c A] [SMulMemClass SA \ud835\udd5c A]", "(S : SA) [hS : IsClosed (S : Set A)] (x : S)", "{A : Type*} [Ring A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u2102 A\na : A\n\u22a2 SpectrumRestricts a \u21d1Complex.reCLM \u2194 \u2200 x \u2208 spectrum \u2102 a, x = \u2191x.re"}, {"line": "refine \u27e8fun h x hx \u21a6 ?_, fun h \u21a6 ?_\u27e9", "tactic_state": "case refine_1\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u2102 A\na : A\nh : SpectrumRestricts a \u21d1Complex.reCLM\nx : \u2102\nhx : x \u2208 spectrum \u2102 a\n\u22a2 x = \u2191x.re\n---\ncase refine_2\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u2102 A\na : A\nh : \u2200 x \u2208 spectrum \u2102 a, x = \u2191x.re\n\u22a2 SpectrumRestricts a \u21d1Complex.reCLM"}, {"line": "\u00b7 obtain \u27e8x, -, rfl\u27e9 := h.algebraMap_image.symm \u25b8 hx\n    simp", "tactic_state": "case refine_2\nA : Type u_9\ninst\u271d\u00b9 : Ring A\ninst\u271d : Algebra \u2102 A\na : A\nh : \u2200 x \u2208 spectrum \u2102 a, x = \u2191x.re\n\u22a2 SpectrumRestricts a \u21d1Complex.reCLM"}, {"line": "\u00b7 exact .of_subset_range_algebraMap Complex.ofReal_re fun x hx \u21a6 \u27e8x.re, (h x hx).symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_inv {a : \u03b1} (ha : a \u2260 0) : \u2016a\u207b\u00b9\u2016\u2091 = \u2016a\u2016\u2091\u207b\u00b9 := by simp [enorm, ENNReal.coe_inv, ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Field/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal ENNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[NormedDivisionRing \u03b1] {a b : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : NormedDivisionRing \u03b1\na : \u03b1\nha : a \u2260 0\n\u22a2 \u2016a\u207b\u00b9\u2016\u2091 = \u2016a\u2016\u2091\u207b\u00b9"}, {"line": "simp [enorm, ENNReal.coe_inv, ha]", "tactic_state": "\u03b1 : Type u_2\ninst\u271d : NormedDivisionRing \u03b1\na : \u03b1\nha : a \u2260 0\n\u22a2 \u2191\u2016a\u2016\u208a\u207b\u00b9 = (\u2191\u2016a\u2016\u208a)\u207b\u00b9"}]}
{"declaration": "lemma norm_le_one_of_discrete\n    (x : \ud835\udd5c) : \u2016x\u2016 \u2264 1 := by\n  rcases eq_or_ne x 0 with rfl|hx\n  \u00b7 simp\n  \u00b7 simp [norm_eq_one_iff_ne_zero_of_discrete.mpr hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Field/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal ENNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[NormedDivisionRing \u03b1] {a b : \u03b1}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] [DiscreteTopology \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\nx : \ud835\udd5c\n\u22a2 \u2016x\u2016 \u2264 1"}, {"line": "rcases eq_or_ne x 0 with rfl|hx", "tactic_state": "case inl\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\n\u22a2 \u2016sorry\u2016 \u2264 1\n---\ncase inr\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\nx : \ud835\udd5c\nhx : x \u2260 sorry\n\u22a2 \u2016x\u2016 \u2264 1"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\nx : \ud835\udd5c\nhx : x \u2260 sorry\n\u22a2 \u2016x\u2016 \u2264 1"}, {"line": "\u00b7 simp [norm_eq_one_iff_ne_zero_of_discrete.mpr hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma unitClosedBall_eq_univ_of_discrete : (Metric.closedBall 0 1 : Set \ud835\udd5c) = Set.univ := by\n  ext\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Field/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal ENNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[NormedDivisionRing \u03b1] {a b : \u03b1}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] [DiscreteTopology \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\n\u22a2 Metric.closedBall 0 1 = Set.univ"}, {"line": "ext", "tactic_state": "case h\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\nx\u271d : \ud835\udd5c\n\u22a2 x\u271d \u2208 Metric.closedBall 0 1 \u2194 x\u271d \u2208 Set.univ"}, {"line": "simp", "tactic_state": "case h\n\ud835\udd5c : Type u_5\ninst\u271d\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d : DiscreteTopology \ud835\udd5c\nx\u271d : \ud835\udd5c\n\u22a2 dist x\u271d 0 \u2264 1"}]}
{"declaration": "theorem nhdsWithin_isUnit_neBot : NeBot (\ud835\udcdd[{ x : \u03b1 | IsUnit x }] 0) := by\n  simpa only [isUnit_iff_ne_zero] using nhdsNE_neBot (0 : \u03b1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Field/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal ENNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[NormedDivisionRing \u03b1] {a b : \u03b1}", "{\ud835\udd5c : Type*} [NormedDivisionRing \ud835\udd5c] [DiscreteTopology \ud835\udd5c]", "[NormedField \u03b1]", "(\u03b1) [NontriviallyNormedField \u03b1]", "{\u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b2 : NormedDivisionRing \u03b1\ninst\u271d\u00b9 : NormedField \u03b1\ninst\u271d : NontriviallyNormedField \u03b1\n\u22a2 (nhdsWithin 0 {x | IsUnit x}).NeBot"}, {"line": "simpa only [isUnit_iff_ne_zero] using nhdsNE_neBot (0 : \u03b1)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma discreteTopology_of_bddAbove_range_norm {\ud835\udd5c : Type*} [NormedField \ud835\udd5c]\n    (h : BddAbove (Set.range fun k : \ud835\udd5c \u21a6 \u2016k\u2016)) :\n    DiscreteTopology \ud835\udd5c := by\n  refine (NormedField.discreteTopology_or_nontriviallyNormedField _).resolve_right ?_\n  rintro \u27e8_, rfl\u27e9\n  obtain \u27e8x, h\u27e9 := h\n  obtain \u27e8k, hk\u27e9 := NormedField.exists_lt_norm \ud835\udd5c x\n  exact hk.not_le (h (Set.mem_range_self k))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Field/Lemmas.lean", "context": {"open": ["Filter Bornology", "scoped Topology NNReal Pointwise"], "variables": ["{\u03b1 \u03b2 \u03b9 : Type*}", "[NormedDivisionRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d : NormedField \ud835\udd5c\nh : BddAbove (Set.range fun k => \u2016k\u2016)\n\u22a2 DiscreteTopology \ud835\udd5c"}, {"line": "refine (NormedField.discreteTopology_or_nontriviallyNormedField _).resolve_right ?_", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d : NormedField \ud835\udd5c\nh : BddAbove (Set.range fun k => \u2016k\u2016)\n\u22a2 \u00acNonempty { h' // NontriviallyNormedField.toNormedField = inst\u271d }"}, {"line": "rintro \u27e8_, rfl\u27e9", "tactic_state": "case intro.mk\n\ud835\udd5c : Type u_4\nval\u271d : NontriviallyNormedField \ud835\udd5c\nh : BddAbove (Set.range fun k => \u2016k\u2016)\n\u22a2 False"}, {"line": "obtain \u27e8x, h\u27e9 := h", "tactic_state": "case intro.mk.intro\n\ud835\udd5c : Type u_4\nval\u271d : NontriviallyNormedField \ud835\udd5c\nx : \u211d\nh : x \u2208 upperBounds (Set.range fun k => \u2016k\u2016)\n\u22a2 False"}, {"line": "obtain \u27e8k, hk\u27e9 := NormedField.exists_lt_norm \ud835\udd5c x", "tactic_state": "case intro.mk.intro.intro\n\ud835\udd5c : Type u_4\nval\u271d : NontriviallyNormedField \ud835\udd5c\nx : \u211d\nh : x \u2208 upperBounds (Set.range fun k => \u2016k\u2016)\nk : \ud835\udd5c\nhk : x < \u2016k\u2016\n\u22a2 False"}, {"line": "exact hk.not_le (h (Set.mem_range_self k))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_vadd_left (v : V) (x : P) : dist (v +\u1d65 x) x = \u2016v\u2016 := by\n  simp [dist_eq_norm_vsub V _ x]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter"], "variables": ["{\u03b1 V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "(V W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\nv : V\nx : P\n\u22a2 dist (v +\u1d65 x) x = \u2016v\u2016"}, {"line": "simp [dist_eq_norm_vsub V _ x]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_vadd_right (v : V) (x : P) : dist x (v +\u1d65 x) = \u2016v\u2016 := by rw [dist_comm, dist_vadd_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter"], "variables": ["{\u03b1 V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "(V W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\nv : V\nx : P\n\u22a2 dist x (v +\u1d65 x) = \u2016v\u2016"}, {"line": "rw [dist_comm, dist_vadd_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_vsub_vsub_le (p\u2081 p\u2082 p\u2083 p\u2084 : P) :\n    nndist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084 := by\n  simp only [\u2190 NNReal.coe_le_coe]\n  simp only [NNReal.coe_add]\n  simp only [\u2190 dist_nndist]\n  simp only [dist_vsub_vsub_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddTorsor.lean", "context": {"open": ["NNReal Topology", "Filter"], "variables": ["{\u03b1 V P W Q : Type*} [SeminormedAddCommGroup V] [PseudoMetricSpace P] [NormedAddTorsor V P]", "(V W)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 nndist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084"}, {"line": "simp only [\u2190 NNReal.coe_le_coe]", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 \u2191(nndist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084)) \u2264 \u2191(nndist p\u2081 p\u2083 + nndist p\u2082 p\u2084)"}, {"line": "simp only [NNReal.coe_add]", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 \u2191(nndist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084)) \u2264 \u2191(nndist p\u2081 p\u2083) + \u2191(nndist p\u2082 p\u2084)"}, {"line": "simp only [\u2190 dist_nndist]", "tactic_state": "V : Type u_2\nP : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup V\ninst\u271d\u00b9 : PseudoMetricSpace P\ninst\u271d : NormedAddTorsor V P\np\u2081 p\u2082 p\u2083 p\u2084 : P\n\u22a2 dist (p\u2081 -\u1d65 p\u2082) (p\u2083 -\u1d65 p\u2084) \u2264 dist p\u2081 p\u2083 + dist p\u2082 p\u2084"}, {"line": "simp only [dist_vsub_vsub_le]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comap_norm_atTop' : comap norm atTop = cobounded E := by\n  simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Bounded.lean", "context": {"open": ["Filter Metric Bornology", "scoped Pointwise Topology"], "variables": ["{\u03b1 E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : SeminormedGroup E\n\u22a2 comap norm atTop = cobounded E"}, {"line": "simpa only [dist_one_right] using comap_dist_right_atTop (1 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBounded_iff_forall_norm_le' : Bornology.IsBounded s \u2194 \u2203 C, \u2200 x \u2208 s, \u2016x\u2016 \u2264 C := by\n  simpa only [Set.subset_def,mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Bounded.lean", "context": {"open": ["Filter Metric Bornology", "scoped Pointwise Topology"], "variables": ["{\u03b1 E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : SeminormedGroup E\ns : Set E\n\u22a2 Bornology.IsBounded s \u2194 \u2203 C, \u2200 x \u2208 s, \u2016x\u2016 \u2264 C"}, {"line": "simpa only [Set.subset_def,mem_closedBall_one_iff] using isBounded_iff_subset_closedBall (1 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma NormedCommGroup.cauchySeq_iff [Nonempty \u03b1] [SemilatticeSup \u03b1] {u : \u03b1 \u2192 E} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m, N \u2264 m \u2192 \u2200 n, N \u2264 n \u2192 \u2016u m / u n\u2016 < \u03b5 := by\n  simp [Metric.cauchySeq_iff, dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Bounded.lean", "context": {"open": ["Filter Metric Bornology", "scoped Pointwise Topology"], "variables": ["{\u03b1 E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : SemilatticeSup \u03b1\nu : \u03b1 \u2192 E\n\u22a2 CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 (m : \u03b1), N \u2264 m \u2192 \u2200 (n : \u03b1), N \u2264 n \u2192 \u2016u m / u n\u2016 < \u03b5"}, {"line": "simp [Metric.cauchySeq_iff, dist_eq_norm_div]", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : Nonempty \u03b1\ninst\u271d : SemilatticeSup \u03b1\nu : \u03b1 \u2192 E\n\u22a2 CauchySeq u \u2194 \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 N, \u2200 (m : \u03b1), N \u2264 m \u2192 \u2200 (n : \u03b1), N \u2264 n \u2192 \u2016u m / u n\u2016 < \u03b5"}]}
{"declaration": "lemma HasCompactMulSupport.exists_bound_of_continuous [TopologicalSpace \u03b1]\n    {f : \u03b1 \u2192 E} (hf : HasCompactMulSupport f) (h'f : Continuous f) : \u2203 C, \u2200 x, \u2016f x\u2016 \u2264 C := by\n  simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Bounded.lean", "context": {"open": ["Filter Metric Bornology", "scoped Pointwise Topology"], "variables": ["{\u03b1 E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : Type u_2\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : TopologicalSpace \u03b1\nf : \u03b1 \u2192 E\nhf : HasCompactMulSupport f\nh'f : Continuous f\n\u22a2 \u2203 C, \u2200 (x : \u03b1), \u2016f x\u2016 \u2264 C"}, {"line": "simpa using (hf.isCompact_range h'f).isBounded.exists_norm_le'", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedAddGroupHom.completion_id :\n    (NormedAddGroupHom.id G).completion = NormedAddGroupHom.id (Completion G) := by\n  ext x\n  rw [NormedAddGroupHom.completion_def]\n  rw [NormedAddGroupHom.coe_id]\n  rw [Completion.map_id]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/HomCompletion.lean", "context": {"open": ["Set NormedAddGroupHom UniformSpace"], "variables": ["{G : Type*} [SeminormedAddCommGroup G] {H : Type*} [SeminormedAddCommGroup H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d : SeminormedAddCommGroup G\n\u22a2 (id G).completion = id (Completion G)"}, {"line": "ext x", "tactic_state": "case H\nG : Type u_1\ninst\u271d : SeminormedAddCommGroup G\nx : Completion G\n\u22a2 (id G).completion x = (id (Completion G)) x"}, {"line": "rw [NormedAddGroupHom.completion_def]", "tactic_state": "case H\nG : Type u_1\ninst\u271d : SeminormedAddCommGroup G\nx : Completion G\n\u22a2 Completion.map (\u21d1(id G)) x = (id (Completion G)) x"}, {"line": "rw [NormedAddGroupHom.coe_id]", "tactic_state": "case H\nG : Type u_1\ninst\u271d : SeminormedAddCommGroup G\nx : Completion G\n\u22a2 Completion.map _root_.id x = (id (Completion G)) x"}, {"line": "rw [Completion.map_id]", "tactic_state": "case H\nG : Type u_1\ninst\u271d : SeminormedAddCommGroup G\nx : Completion G\n\u22a2 _root_.id x = (id (Completion G)) x"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedAddGroupHom.ker_le_ker_completion (f : NormedAddGroupHom G H) :\n    (toCompl.comp <| incl f.ker).range \u2264 f.completion.ker := by\n  rintro _ \u27e8\u27e8g, h\u2080 : f g = 0\u27e9, rfl\u27e9\n  simp [h\u2080, mem_ker, Completion.coe_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/HomCompletion.lean", "context": {"open": ["Set NormedAddGroupHom UniformSpace", "NormedAddCommGroup"], "variables": ["{G : Type*} [SeminormedAddCommGroup G] {H : Type*} [SeminormedAddCommGroup H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup G\nH : Type u_2\ninst\u271d : SeminormedAddCommGroup H\nf : NormedAddGroupHom G H\n\u22a2 (toCompl.comp (incl f.ker)).range \u2264 f.completion.ker"}, {"line": "rintro _ \u27e8\u27e8g, h\u2080 : f g = 0\u27e9, rfl\u27e9", "tactic_state": "case intro.mk\nG : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup G\nH : Type u_2\ninst\u271d : SeminormedAddCommGroup H\nf : NormedAddGroupHom G H\ng : G\nh\u2080 : f g = 0\n\u22a2 (toCompl.comp (incl f.ker)).toAddMonoidHom \u27e8g, h\u2080\u27e9 \u2208 f.completion.ker"}, {"line": "simp [h\u2080, mem_ker, Completion.coe_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_natCast (n : \u2115) : \u2016(n : \u2124)\u2016 = n := by simp [Int.norm_eq_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Int.lean", "context": {"open": ["NNReal"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 \u2016\u2191n\u2016 = \u2191n"}, {"line": "simp [Int.norm_eq_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_le_floor_nnreal_iff (z : \u2124) (c : \u211d\u22650) : |z| \u2264 \u230ac\u230b\u208a \u2194 \u2016z\u2016\u208a \u2264 c := by\n  rw [Int.abs_eq_natAbs]\n  rw [Int.ofNat_le]\n  rw [Nat.le_floor_iff (zero_le c)]\n  rw [NNReal.natCast_natAbs z]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Int.lean", "context": {"open": ["NNReal"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2124\nc : NNReal\n\u22a2 |z| \u2264 \u2191\u230ac\u230b\u208a \u2194 \u2016z\u2016\u208a \u2264 c"}, {"line": "rw [Int.abs_eq_natAbs]", "tactic_state": "z : \u2124\nc : NNReal\n\u22a2 \u2191z.natAbs \u2264 \u2191\u230ac\u230b\u208a \u2194 \u2016z\u2016\u208a \u2264 c"}, {"line": "rw [Int.ofNat_le]", "tactic_state": "z : \u2124\nc : NNReal\n\u22a2 z.natAbs \u2264 \u230ac\u230b\u208a \u2194 \u2016z\u2016\u208a \u2264 c"}, {"line": "rw [Nat.le_floor_iff (zero_le c)]", "tactic_state": "z : \u2124\nc : NNReal\n\u22a2 \u2191z.natAbs \u2264 c \u2194 \u2016z\u2016\u208a \u2264 c"}, {"line": "rw [NNReal.natCast_natAbs z]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnnorm_zpow_le_mul_norm (n : \u2124) (a : \u03b1) : \u2016a ^ n\u2016\u208a \u2264 \u2016n\u2016\u208a * \u2016a\u2016\u208a := by\n  simpa only [\u2190 NNReal.coe_le_coe,NNReal.coe_mul] using norm_zpow_le_mul_norm n a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Int.lean", "context": {"open": ["NNReal"], "variables": ["{\u03b1 : Type*}", "[SeminormedCommGroup \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d : SeminormedCommGroup \u03b1\nn : \u2124\na : \u03b1\n\u22a2 \u2016a ^ n\u2016\u208a \u2264 \u2016n\u2016\u208a * \u2016a\u2016\u208a"}, {"line": "simpa only [\u2190 NNReal.coe_le_coe,NNReal.coe_mul] using norm_zpow_le_mul_norm n a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_thickening : (thickening \u03b4 s)\u207b\u00b9 = thickening \u03b4 s\u207b\u00b9 := by\n  simp_rw [thickening, \u2190 infEdist_inv]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\ns : Set E\n\u22a2 (thickening \u03b4 s)\u207b\u00b9 = thickening \u03b4 s\u207b\u00b9"}, {"line": "simp_rw [thickening, \u2190 infEdist_inv]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\ns : Set E\n\u22a2 {x | infEdist x s < ENNReal.ofReal \u03b4}\u207b\u00b9 = {x | infEdist x\u207b\u00b9 s < ENNReal.ofReal \u03b4}"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_cthickening : (cthickening \u03b4 s)\u207b\u00b9 = cthickening \u03b4 s\u207b\u00b9 := by\n  simp_rw [cthickening, \u2190 infEdist_inv]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\ns : Set E\n\u22a2 (cthickening \u03b4 s)\u207b\u00b9 = cthickening \u03b4 s\u207b\u00b9"}, {"line": "simp_rw [cthickening, \u2190 infEdist_inv]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\ns : Set E\n\u22a2 {x | infEdist x s \u2264 ENNReal.ofReal \u03b4}\u207b\u00b9 = {x | infEdist x\u207b\u00b9 s \u2264 ENNReal.ofReal \u03b4}"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem singleton_mul_ball_one : {x} * ball 1 \u03b4 = ball x \u03b4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 {x} * Metric.ball 1 \u03b4 = Metric.ball x \u03b4"}, {"line": "simp", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 (fun x_1 => x\u207b\u00b9 * x_1) \u207b\u00b9' Metric.ball 1 \u03b4 = Metric.ball x \u03b4"}]}
{"declaration": "theorem ball_one_mul_singleton : ball 1 \u03b4 * {x} = ball x \u03b4 := by simp [ball_mul_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 Metric.ball 1 \u03b4 * {x} = Metric.ball x \u03b4"}, {"line": "simp [ball_mul_singleton]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 (fun x_1 => x_1 * x\u207b\u00b9) \u207b\u00b9' Metric.ball 1 \u03b4 = Metric.ball x \u03b4"}]}
{"declaration": "theorem closedBall_mul_singleton : closedBall x \u03b4 * {y} = closedBall (x * y) \u03b4 := by\n  simp [mul_comm _ {y}, mul_comm y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx y : E\n\u22a2 Metric.closedBall x \u03b4 * {y} = Metric.closedBall (x * y) \u03b4"}, {"line": "simp [mul_comm _ {y}, mul_comm y]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx y : E\n\u22a2 (fun x => x * y\u207b\u00b9) \u207b\u00b9' Metric.closedBall x \u03b4 = Metric.closedBall (x * y) \u03b4"}]}
{"declaration": "theorem closedBall_div_singleton : closedBall x \u03b4 / {y} = closedBall (x / y) \u03b4 := by\n  simp [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx y : E\n\u22a2 Metric.closedBall x \u03b4 / {y} = Metric.closedBall (x / y) \u03b4"}, {"line": "simp [div_eq_mul_inv]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx y : E\n\u22a2 (fun x => x * y\u207b\u00b9\u207b\u00b9) \u207b\u00b9' Metric.closedBall x \u03b4 = Metric.closedBall (x * y\u207b\u00b9) \u03b4"}]}
{"declaration": "theorem singleton_mul_closedBall_one : {x} * closedBall 1 \u03b4 = closedBall x \u03b4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 {x} * Metric.closedBall 1 \u03b4 = Metric.closedBall x \u03b4"}, {"line": "simp", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 (fun x_1 => x\u207b\u00b9 * x_1) \u207b\u00b9' Metric.closedBall 1 \u03b4 = Metric.closedBall x \u03b4"}]}
{"declaration": "theorem closedBall_one_mul_singleton : closedBall 1 \u03b4 * {x} = closedBall x \u03b4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 Metric.closedBall 1 \u03b4 * {x} = Metric.closedBall x \u03b4"}, {"line": "simp", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 (fun x_1 => x_1 * x\u207b\u00b9) \u207b\u00b9' Metric.closedBall 1 \u03b4 = Metric.closedBall x \u03b4"}]}
{"declaration": "theorem closedBall_one_div_singleton : closedBall 1 \u03b4 / {x} = closedBall x\u207b\u00b9 \u03b4 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Pointwise.lean", "context": {"open": ["Metric Set Pointwise Topology", "EMetric"], "variables": ["{E : Type*}", "[SeminormedGroup E] {s t : Set E}", "[SeminormedCommGroup E] {\u03b4 : \u211d} {s : Set E} {x y : E}", "(\u03b4 s x y)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 Metric.closedBall 1 \u03b4 / {x} = Metric.closedBall x\u207b\u00b9 \u03b4"}, {"line": "simp", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\n\u03b4 : \u211d\nx : E\n\u22a2 (fun x_1 => x_1 / x) '' Metric.closedBall 1 \u03b4 = Metric.closedBall x\u207b\u00b9 \u03b4"}]}
{"declaration": "lemma id_apply (M : SemiNormedGrp) (r : M) :\n    (\ud835\udfd9 M : M \u27f6 M) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : SemiNormedGrp\nr : M.carrier\n\u22a2 (ConcreteCategory.hom (CategoryStruct.id M)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N O : SemiNormedGrp} (f : M \u27f6 N) (g : N \u27f6 O) (r : M) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N O : SemiNormedGrp\nf : M \u27f6 N\ng : N \u27f6 O\nr : M.carrier\n\u22a2 (ConcreteCategory.hom (CategoryStruct.comp f g)) r = (ConcreteCategory.hom g) ((ConcreteCategory.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_hom_apply {M N : SemiNormedGrp} (e : M \u2245 N) (r : M) : e.inv (e.hom r) = r := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : SemiNormedGrp\ne : M \u2245 N\nr : M.carrier\n\u22a2 (ConcreteCategory.hom e.inv) ((ConcreteCategory.hom e.hom) r) = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hom_inv_apply {M N : SemiNormedGrp} (e : M \u2245 N) (s : N) : e.hom (e.inv s) = s := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N : SemiNormedGrp\ne : M \u2245 N\ns : N.carrier\n\u22a2 (ConcreteCategory.hom e.hom) ((ConcreteCategory.hom e.inv) s) = s"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isZero_of_subsingleton (V : SemiNormedGrp) [Subsingleton V] : Limits.IsZero V := by\n  refine \u27e8fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9, fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9\u27e9\n  \u00b7 ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  \u00b7 ext; apply Subsingleton.elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : SemiNormedGrp\ninst\u271d : Subsingleton V.carrier\n\u22a2 Limits.IsZero V"}, {"line": "refine \u27e8fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9, fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9\u27e9", "tactic_state": "case refine_1\nV : SemiNormedGrp\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\nf : V \u27f6 X\n\u22a2 f = default\n---\ncase refine_2\nV : SemiNormedGrp\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\nf : X \u27f6 V\n\u22a2 f = default"}, {"line": "\u00b7 ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]", "tactic_state": "case refine_2\nV : SemiNormedGrp\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\nf : X \u27f6 V\n\u22a2 f = default"}, {"line": "\u00b7 ext; apply Subsingleton.elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iso_isometry_of_normNoninc {V W : SemiNormedGrp} (i : V \u2245 W) (h1 : i.hom.hom.NormNoninc)\n    (h2 : i.inv.hom.NormNoninc) : Isometry i.hom := by\n  apply AddMonoidHomClass.isometry_of_norm\n  intro v\n  apply le_antisymm (h1 v)\n  calc\n    \u2016v\u2016 = \u2016i.inv (i.hom v)\u2016 := by rw [\u2190 comp_apply, Iso.hom_inv_id, id_apply]\n    _ \u2264 \u2016i.hom v\u2016 := h2 _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "V W : SemiNormedGrp\ni : V \u2245 W\nh1 : (SemiNormedGrp.Hom.hom i.hom).NormNoninc\nh2 : (SemiNormedGrp.Hom.hom i.inv).NormNoninc\n\u22a2 Isometry \u21d1(ConcreteCategory.hom i.hom)"}, {"line": "apply AddMonoidHomClass.isometry_of_norm", "tactic_state": "case a\nV W : SemiNormedGrp\ni : V \u2245 W\nh1 : (SemiNormedGrp.Hom.hom i.hom).NormNoninc\nh2 : (SemiNormedGrp.Hom.hom i.inv).NormNoninc\n\u22a2 \u2200 (x : V.carrier), \u2016(ConcreteCategory.hom i.hom) x\u2016 = \u2016x\u2016"}, {"line": "intro v", "tactic_state": "case a\nV W : SemiNormedGrp\ni : V \u2245 W\nh1 : (SemiNormedGrp.Hom.hom i.hom).NormNoninc\nh2 : (SemiNormedGrp.Hom.hom i.inv).NormNoninc\nv : V.carrier\n\u22a2 \u2016(ConcreteCategory.hom i.hom) v\u2016 = \u2016v\u2016"}, {"line": "apply le_antisymm (h1 v)", "tactic_state": "case a\nV W : SemiNormedGrp\ni : V \u2245 W\nh1 : (SemiNormedGrp.Hom.hom i.hom).NormNoninc\nh2 : (SemiNormedGrp.Hom.hom i.inv).NormNoninc\nv : V.carrier\n\u22a2 \u2016v\u2016 \u2264 \u2016(SemiNormedGrp.Hom.hom i.hom) v\u2016"}, {"line": "calc\n    \u2016v\u2016 = \u2016i.inv (i.hom v)\u2016 := by rw [\u2190 comp_apply, Iso.hom_inv_id, id_apply]\n    _ \u2264 \u2016i.hom v\u2016 := h2 _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma id_apply (M : SemiNormedGrp\u2081) (r : M) :\n    (\ud835\udfd9 M : M \u27f6 M) r = r := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : SemiNormedGrp\u2081\nr : M.carrier\n\u22a2 \u2191(SemiNormedGrp\u2081.Hom.hom (CategoryStruct.id M)) r = r"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comp_apply {M N O : SemiNormedGrp\u2081} (f : M \u27f6 N) (g : N \u27f6 O) (r : M) :\n    (f \u226b g) r = g (f r) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "M N O : SemiNormedGrp\u2081\nf : M \u27f6 N\ng : N \u27f6 O\nr : M.carrier\n\u22a2 \u2191(SemiNormedGrp\u2081.Hom.hom (CategoryStruct.comp f g)) r = \u2191(SemiNormedGrp\u2081.Hom.hom g) (\u2191(SemiNormedGrp\u2081.Hom.hom f) r)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isZero_of_subsingleton (V : SemiNormedGrp\u2081) [Subsingleton V] : Limits.IsZero V := by\n  refine \u27e8fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9, fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9\u27e9\n  \u00b7 ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]\n  \u00b7 ext; apply Subsingleton.elim\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "V : SemiNormedGrp\u2081\ninst\u271d : Subsingleton V.carrier\n\u22a2 Limits.IsZero V"}, {"line": "refine \u27e8fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9, fun X => \u27e8\u27e8\u27e80\u27e9, fun f => ?_\u27e9\u27e9\u27e9", "tactic_state": "case refine_1\nV : SemiNormedGrp\u2081\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\u2081\nf : V \u27f6 X\n\u22a2 f = default\n---\ncase refine_2\nV : SemiNormedGrp\u2081\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\u2081\nf : X \u27f6 V\n\u22a2 f = default"}, {"line": "\u00b7 ext x; have : x = 0 := Subsingleton.elim _ _; simp only [this, map_zero]", "tactic_state": "case refine_2\nV : SemiNormedGrp\u2081\ninst\u271d : Subsingleton V.carrier\nX : SemiNormedGrp\u2081\nf : X \u27f6 V\n\u22a2 f = default"}, {"line": "\u00b7 ext; apply Subsingleton.elim", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iso_isometry {V W : SemiNormedGrp\u2081} (i : V \u2245 W) : Isometry i.hom := by\n  change Isometry (\u27e8\u27e8i.hom, map_zero _\u27e9, fun _ _ => map_add _ _ _\u27e9 : V \u2192+ W)\n  refine AddMonoidHomClass.isometry_of_norm _ ?_\n  intro v\n  apply le_antisymm (i.hom.2 v)\n  calc\n    \u2016v\u2016 = \u2016i.inv (i.hom v)\u2016 := by rw [\u2190 comp_apply, Iso.hom_inv_id, id_apply]\n    _ \u2264 \u2016i.hom v\u2016 := i.inv.2 _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp.lean", "context": {"open": ["CategoryTheory"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "V W : SemiNormedGrp\u2081\ni : V \u2245 W\n\u22a2 Isometry \u21d1\u2191(SemiNormedGrp\u2081.Hom.hom i.hom)"}, {"line": "change Isometry (\u27e8\u27e8i.hom, map_zero _\u27e9, fun _ _ => map_add _ _ _\u27e9 : V \u2192+ W)", "tactic_state": "V W : SemiNormedGrp\u2081\ni : V \u2245 W\n\u22a2 Isometry \u21d1{ toFun := \u21d1\u2191(SemiNormedGrp\u2081.Hom.hom i.hom), map_zero' := \u22ef, map_add' := \u22ef }"}, {"line": "refine AddMonoidHomClass.isometry_of_norm _ ?_", "tactic_state": "V W : SemiNormedGrp\u2081\ni : V \u2245 W\n\u22a2 \u2200 (x : V.carrier), \u2016{ toFun := \u21d1\u2191(SemiNormedGrp\u2081.Hom.hom i.hom), map_zero' := \u22ef, map_add' := \u22ef } x\u2016 = \u2016x\u2016"}, {"line": "intro v", "tactic_state": "V W : SemiNormedGrp\u2081\ni : V \u2245 W\nv : V.carrier\n\u22a2 \u2016{ toFun := \u21d1\u2191(SemiNormedGrp\u2081.Hom.hom i.hom), map_zero' := \u22ef, map_add' := \u22ef } v\u2016 = \u2016v\u2016"}, {"line": "apply le_antisymm (i.hom.2 v)", "tactic_state": "V W : SemiNormedGrp\u2081\ni : V \u2245 W\nv : V.carrier\n\u22a2 \u2016v\u2016 \u2264 \u2016i.hom.hom' v\u2016"}, {"line": "calc\n    \u2016v\u2016 = \u2016i.inv (i.hom v)\u2016 := by rw [\u2190 comp_apply, Iso.hom_inv_id, id_apply]\n    _ \u2264 \u2016i.hom v\u2016 := i.inv.2 _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_mul_le_max (x y : S) :\n    \u2016x * y\u2016 \u2264 max \u2016x\u2016 \u2016y\u2016 := by\n  simpa only [le_max_iff,dist_eq_norm_div,div_inv_eq_mul,div_one,one_mul] using\n    dist_triangle_max x 1 y\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : SeminormedGroup S\ninst\u271d : IsUltrametricDist S\nx y : S\n\u22a2 \u2016x * y\u2016 \u2264 max \u2016x\u2016 \u2016y\u2016"}, {"line": "simpa only [le_max_iff,dist_eq_norm_div,div_inv_eq_mul,div_one,one_mul] using\n    dist_triangle_max x 1 y\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isNonarchimedean_norm {R} [SeminormedAddCommGroup R] [IsUltrametricDist R] :\n    IsNonarchimedean (\u2016\u00b7\u2016 : R \u2192 \u211d) := by\n  intro x y\n  convert dist_triangle_max 0 x (x + y) using 1\n  \u00b7 simp\n  \u00b7 congr <;> simp [SeminormedAddGroup.dist_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\n\u22a2 IsNonarchimedean fun x => \u2016x\u2016"}, {"line": "intro x y", "tactic_state": "R : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 (fun x => \u2016x\u2016) (x + y) \u2264 max ((fun x => \u2016x\u2016) x) ((fun x => \u2016x\u2016) y)"}, {"line": "convert dist_triangle_max 0 x (x + y) using 1", "tactic_state": "case h.e'_3\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 (fun x => \u2016x\u2016) (x + y) = dist 0 (x + y)\n---\ncase h.e'_4\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 max ((fun x => \u2016x\u2016) x) ((fun x => \u2016x\u2016) y) = max (dist 0 x) (dist x (x + y))\n---\ncase convert_1\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 PseudoMetricSpace R\n---\ncase convert_2\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 IsUltrametricDist R\n---\ncase convert_3\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 OfNat R 0\n---\ncase convert_4\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 HAdd R R R"}, {"line": "\u00b7 simp", "tactic_state": "case h.e'_4\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 max ((fun x => \u2016x\u2016) x) ((fun x => \u2016x\u2016) y) = max (dist 0 x) (dist x (x + y))\n---\ncase convert_1\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 PseudoMetricSpace R\n---\ncase convert_2\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 IsUltrametricDist R\n---\ncase convert_3\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 OfNat R 0\n---\ncase convert_4\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 HAdd R R R"}, {"line": "\u00b7 congr <;> simp [SeminormedAddGroup.dist_eq]", "tactic_state": "case convert_1\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 PseudoMetricSpace R\n---\ncase convert_2\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 IsUltrametricDist R\n---\ncase convert_3\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 OfNat R 0\n---\ncase convert_4\nR : Type u_4\ninst\u271d\u00b9 : SeminormedAddCommGroup R\ninst\u271d : IsUltrametricDist R\nx y : R\n\u22a2 HAdd R R R"}]}
{"declaration": "lemma nnnorm_mul_eq_max_of_nnnorm_ne_nnnorm\n    {x y : S} (h : \u2016x\u2016\u208a \u2260 \u2016y\u2016\u208a) : \u2016x * y\u2016\u208a = max \u2016x\u2016\u208a \u2016y\u2016\u208a := by\n  simpa only [\u2190 NNReal.coe_inj,NNReal.coe_max] using\n    norm_mul_eq_max_of_norm_ne_norm (NNReal.coe_injective.ne h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : SeminormedGroup S\ninst\u271d : IsUltrametricDist S\nx y : S\nh : \u2016x\u2016\u208a \u2260 \u2016y\u2016\u208a\n\u22a2 \u2016x * y\u2016\u208a = max \u2016x\u2016\u208a \u2016y\u2016\u208a"}, {"line": "simpa only [\u2190 NNReal.coe_inj,NNReal.coe_max] using\n    norm_mul_eq_max_of_norm_ne_norm (NNReal.coe_injective.ne h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_div_eq_max_of_norm_div_ne_norm_div (x y z : S) (h : \u2016x / y\u2016 \u2260 \u2016y / z\u2016) :\n    \u2016x / z\u2016 = max \u2016x / y\u2016 \u2016y / z\u2016 := by\n  simpa only [div_mul_div_cancel] using norm_mul_eq_max_of_norm_ne_norm h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : SeminormedGroup S\ninst\u271d : IsUltrametricDist S\nx y z : S\nh : \u2016x / y\u2016 \u2260 \u2016y / z\u2016\n\u22a2 \u2016x / z\u2016 = max \u2016x / y\u2016 \u2016y / z\u2016"}, {"line": "simpa only [div_mul_div_cancel] using norm_mul_eq_max_of_norm_ne_norm h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnnorm_div_eq_max_of_nnnorm_div_ne_nnnorm_div (x y z : S) (h : \u2016x / y\u2016\u208a \u2260 \u2016y / z\u2016\u208a) :\n    \u2016x / z\u2016\u208a = max \u2016x / y\u2016\u208a \u2016y / z\u2016\u208a := by\n  simpa only [\u2190 NNReal.coe_inj,NNReal.coe_max] using\n    norm_div_eq_max_of_norm_div_ne_norm_div _ _ _ (NNReal.coe_injective.ne h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "S : Type u_1\ninst\u271d\u00b9 : SeminormedGroup S\ninst\u271d : IsUltrametricDist S\nx y z : S\nh : \u2016x / y\u2016\u208a \u2260 \u2016y / z\u2016\u208a\n\u22a2 \u2016x / z\u2016\u208a = max \u2016x / y\u2016\u208a \u2016y / z\u2016\u208a"}, {"line": "simpa only [\u2190 NNReal.coe_inj,NNReal.coe_max] using\n    norm_div_eq_max_of_norm_div_ne_norm_div _ _ _ (NNReal.coe_injective.ne h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Finset.nnnorm_prod_le_sup_nnnorm (s : Finset \u03b9) (f : \u03b9 \u2192 M) :\n    \u2016\u220f i \u2208 s, f i\u2016\u208a \u2264 s.sup (\u2016f \u00b7\u2016\u208a) := by\n  rcases s.eq_empty_or_nonempty with rfl|hs\n  \u00b7 simp only [Finset.prod_empty, nnnorm_one', Finset.sup_empty, bot_eq_zero', le_refl]\n  \u00b7 simpa only [\u2190 Finset.sup'_eq_sup hs,Finset.le_sup'_iff,coe_le_coe,coe_nnnorm']\n      using hs.norm_prod_le_sup'_norm f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]", "(S)", "{M \u03b9 : Type*} [SeminormedCommGroup M] [IsUltrametricDist M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016\u208a \u2264 s.sup fun x => \u2016f x\u2016\u208a"}, {"line": "rcases s.eq_empty_or_nonempty with rfl|hs", "tactic_state": "case inl\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\n\u22a2 \u2016\u220f i \u2208 \u2205, f i\u2016\u208a \u2264 \u2205.sup fun x => \u2016f x\u2016\u208a\n---\ncase inr\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\nhs : s.Nonempty\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016\u208a \u2264 s.sup fun x => \u2016f x\u2016\u208a"}, {"line": "\u00b7 simp only [Finset.prod_empty, nnnorm_one', Finset.sup_empty, bot_eq_zero', le_refl]", "tactic_state": "case inr\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\nhs : s.Nonempty\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016\u208a \u2264 s.sup fun x => \u2016f x\u2016\u208a"}, {"line": "\u00b7 simpa only [\u2190 Finset.sup'_eq_sup hs,Finset.le_sup'_iff,coe_le_coe,coe_nnnorm']\n      using hs.norm_prod_le_sup'_norm f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_prod_le_of_forall_le_of_nonneg {s : Finset \u03b9} {f : \u03b9 \u2192 M} {C : \u211d}\n    (h_nonneg : 0 \u2264 C) (hC : \u2200 i \u2208 s, \u2016f i\u2016 \u2264 C) : \u2016\u220f i \u2208 s, f i\u2016 \u2264 C := by\n  lift C to NNReal using h_nonneg\n  exact nnnorm_prod_le_of_forall_le hC\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]", "(S)", "{M \u03b9 : Type*} [SeminormedCommGroup M] [IsUltrametricDist M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\nC : \u211d\nh_nonneg : 0 \u2264 C\nhC : \u2200 i \u2208 s, \u2016f i\u2016 \u2264 C\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016 \u2264 C"}, {"line": "lift C to NNReal using h_nonneg", "tactic_state": "case intro\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\ns : Finset \u03b9\nf : \u03b9 \u2192 M\nC : NNReal\nhC : \u2200 i \u2208 s, \u2016f i\u2016 \u2264 \u2191C\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016 \u2264 \u2191C"}, {"line": "exact nnnorm_prod_le_of_forall_le hC", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnnorm_tprod_le (f : \u03b9 \u2192 M) : \u2016\u220f' i, f i\u2016\u208a \u2264 \u2a06 i, \u2016f i\u2016\u208a := by\n  simpa only [\u2190 NNReal.coe_le_coe,coe_nnnorm',coe_iSup] using norm_tprod_le f\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]", "(S)", "{M \u03b9 : Type*} [SeminormedCommGroup M] [IsUltrametricDist M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\n\u22a2 \u2016\u220f' (i : \u03b9), f i\u2016\u208a \u2264 \u2a06 i, \u2016f i\u2016\u208a"}, {"line": "simpa only [\u2190 NNReal.coe_le_coe,coe_nnnorm',coe_iSup] using norm_tprod_le f", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_tprod_le_of_forall_le_of_nonneg {f : \u03b9 \u2192 M} {C : \u211d} (hC : 0 \u2264 C) (h : \u2200 i, \u2016f i\u2016 \u2264 C) :\n    \u2016\u220f' i, f i\u2016 \u2264 C := by\n  rcases isEmpty_or_nonempty \u03b9\n  \u00b7 simpa only [tprod_empty,norm_one'] using hC\n  \u00b7 exact norm_tprod_le_of_forall_le h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{S S' \u03b9 : Type*} [SeminormedGroup S] [SeminormedGroup S'] [IsUltrametricDist S]", "(S)", "{M \u03b9 : Type*} [SeminormedCommGroup M] [IsUltrametricDist M]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "M : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\nC : \u211d\nhC : 0 \u2264 C\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 C\n\u22a2 \u2016\u220f' (i : \u03b9), f i\u2016 \u2264 C"}, {"line": "rcases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\nC : \u211d\nhC : 0 \u2264 C\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 C\nh\u271d : IsEmpty \u03b9\n\u22a2 \u2016\u220f' (i : \u03b9), f i\u2016 \u2264 C\n---\ncase inr\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\nC : \u211d\nhC : 0 \u2264 C\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 C\nh\u271d : Nonempty \u03b9\n\u22a2 \u2016\u220f' (i : \u03b9), f i\u2016 \u2264 C"}, {"line": "\u00b7 simpa only [tprod_empty,norm_one'] using hC", "tactic_state": "case inr\nM : Type u_4\n\u03b9 : Type u_5\ninst\u271d\u00b9 : SeminormedCommGroup M\ninst\u271d : IsUltrametricDist M\nf : \u03b9 \u2192 M\nC : \u211d\nhC : 0 \u2264 C\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 C\nh\u271d : Nonempty \u03b9\n\u22a2 \u2016\u220f' (i : \u03b9), f i\u2016 \u2264 C"}, {"line": "\u00b7 exact norm_tprod_le_of_forall_le h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq_of_zero {x : \u211d} : \u2016(x : AddCircle (0 : \u211d))\u2016 = |x| := by\n  suffices { y : \u211d | (y : AddCircle (0 : \u211d)) = (x : AddCircle (0 : \u211d)) } = {x} by\n    simp [norm_eq_infDist, this]\n  ext y\n  simp [eq_iff_sub_mem, mem_zmultiples_iff, sub_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddCircle.lean", "context": {"open": ["Metric QuotientAddGroup Set", "Int hiding mem_zmultiples_iff", "AddSubgroup"], "variables": ["(p : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016\u2191x\u2016 = |x|"}, {"line": "suffices { y : \u211d | (y : AddCircle (0 : \u211d)) = (x : AddCircle (0 : \u211d)) } = {x} by\n    simp [norm_eq_infDist, this]", "tactic_state": "x : \u211d\n\u22a2 {y | \u2191y = \u2191x} = {x}"}, {"line": "ext y", "tactic_state": "case h\nx y : \u211d\n\u22a2 y \u2208 {y | \u2191y = \u2191x} \u2194 y \u2208 {x}"}, {"line": "simp [eq_iff_sub_mem, mem_zmultiples_iff, sub_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_coe_eq_abs_iff {x : \u211d} (hp : p \u2260 0) : \u2016(x : AddCircle p)\u2016 = |x| \u2194 |x| \u2264 |p| / 2 := by\n  refine \u27e8fun hx => hx \u25b8 norm_le_half_period p hp, fun hx => ?_\u27e9\n  suffices \u2200 p : \u211d, 0 < p \u2192 |x| \u2264 p / 2 \u2192 \u2016(x : AddCircle p)\u2016 = |x| by\n    rcases hp.symm.lt_or_lt with (hp | hp)\n    \u00b7 rw [abs_eq_self.mpr hp.le] at hx\n      exact this p hp hx\n    \u00b7 rw [\u2190 norm_neg_period]\n      rw [abs_eq_neg_self.mpr hp.le] at hx\n      exact this (-p) (neg_pos.mpr hp) hx\n  clear hx\n  intro p hp hx\n  rcases eq_or_ne x (p / (2 : \u211d)) with (rfl | hx')\n  \u00b7 simp [abs_div, abs_two]\n  suffices round (p\u207b\u00b9 * x) = 0 by simp [norm_eq, this]\n  rw [round_eq_zero_iff]\n  obtain \u27e8hx\u2081, hx\u2082\u27e9 := abs_le.mp hx\n  replace hx\u2082 := Ne.lt_of_le hx' hx\u2082\n  constructor\n  \u00b7 rwa [\u2190 mul_le_mul_left hp, \u2190 mul_assoc, mul_inv_cancel\u2080 hp.ne.symm, one_mul, mul_neg, \u2190\n      mul_div_assoc, mul_one]\n  \u00b7 rwa [\u2190 mul_lt_mul_left hp, \u2190 mul_assoc, mul_inv_cancel\u2080 hp.ne.symm, one_mul, \u2190 mul_div_assoc,\n      mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddCircle.lean", "context": {"open": ["Metric QuotientAddGroup Set", "Int hiding mem_zmultiples_iff", "AddSubgroup"], "variables": ["(p : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p x : \u211d\nhp : p \u2260 0\n\u22a2 \u2016\u2191x\u2016 = |x| \u2194 |x| \u2264 |p| / 2"}, {"line": "refine \u27e8fun hx => hx \u25b8 norm_le_half_period p hp, fun hx => ?_\u27e9", "tactic_state": "p x : \u211d\nhp : p \u2260 0\nhx : |x| \u2264 |p| / 2\n\u22a2 \u2016\u2191x\u2016 = |x|"}, {"line": "suffices \u2200 p : \u211d, 0 < p \u2192 |x| \u2264 p / 2 \u2192 \u2016(x : AddCircle p)\u2016 = |x| by\n    rcases hp.symm.lt_or_lt with (hp | hp)\n    \u00b7 rw [abs_eq_self.mpr hp.le] at hx\n      exact this p hp hx\n    \u00b7 rw [\u2190 norm_neg_period]\n      rw [abs_eq_neg_self.mpr hp.le] at hx\n      exact this (-p) (neg_pos.mpr hp) hx", "tactic_state": "p x : \u211d\nhp : p \u2260 0\nhx : |x| \u2264 |p| / 2\n\u22a2 \u2200 (p : \u211d), 0 < p \u2192 |x| \u2264 p / 2 \u2192 \u2016\u2191x\u2016 = |x|"}, {"line": "clear hx", "tactic_state": "p x : \u211d\nhp : p \u2260 0\n\u22a2 \u2200 (p : \u211d), 0 < p \u2192 |x| \u2264 p / 2 \u2192 \u2016\u2191x\u2016 = |x|"}, {"line": "intro p hp hx", "tactic_state": "p\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\n\u22a2 \u2016\u2191x\u2016 = |x|"}, {"line": "rcases eq_or_ne x (p / (2 : \u211d)) with (rfl | hx')", "tactic_state": "case inl\np\u271d : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |p / 2| \u2264 p / 2\n\u22a2 \u2016\u2191(p / 2)\u2016 = |p / 2|\n---\ncase inr\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\n\u22a2 \u2016\u2191x\u2016 = |x|"}, {"line": "\u00b7 simp [abs_div, abs_two]", "tactic_state": "case inr\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\n\u22a2 \u2016\u2191x\u2016 = |x|"}, {"line": "suffices round (p\u207b\u00b9 * x) = 0 by simp [norm_eq, this]", "tactic_state": "case inr\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\n\u22a2 round (p\u207b\u00b9 * x) = 0"}, {"line": "rw [round_eq_zero_iff]", "tactic_state": "case inr\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\n\u22a2 p\u207b\u00b9 * x \u2208 Ico (-(1 / 2)) (1 / 2)"}, {"line": "obtain \u27e8hx\u2081, hx\u2082\u27e9 := abs_le.mp hx", "tactic_state": "case inr.intro\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\nhx\u2081 : -(p / 2) \u2264 x\nhx\u2082 : x \u2264 p / 2\n\u22a2 p\u207b\u00b9 * x \u2208 Ico (-(1 / 2)) (1 / 2)"}, {"line": "replace hx\u2082 := Ne.lt_of_le hx' hx\u2082", "tactic_state": "case inr.intro\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\nhx\u2081 : -(p / 2) \u2264 x\nhx\u2082 : x < p / 2\n\u22a2 p\u207b\u00b9 * x \u2208 Ico (-(1 / 2)) (1 / 2)"}, {"line": "constructor", "tactic_state": "case inr.intro.left\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\nhx\u2081 : -(p / 2) \u2264 x\nhx\u2082 : x < p / 2\n\u22a2 -(1 / 2) \u2264 p\u207b\u00b9 * x\n---\ncase inr.intro.right\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\nhx\u2081 : -(p / 2) \u2264 x\nhx\u2082 : x < p / 2\n\u22a2 p\u207b\u00b9 * x < 1 / 2"}, {"line": "\u00b7 rwa [\u2190 mul_le_mul_left hp, \u2190 mul_assoc, mul_inv_cancel\u2080 hp.ne.symm, one_mul, mul_neg, \u2190\n      mul_div_assoc, mul_one]", "tactic_state": "case inr.intro.right\np\u271d x : \u211d\nhp\u271d : p\u271d \u2260 0\np : \u211d\nhp : 0 < p\nhx : |x| \u2264 p / 2\nhx' : x \u2260 p / 2\nhx\u2081 : -(p / 2) \u2264 x\nhx\u2082 : x < p / 2\n\u22a2 p\u207b\u00b9 * x < 1 / 2"}, {"line": "\u00b7 rwa [\u2190 mul_lt_mul_left hp, \u2190 mul_assoc, mul_inv_cancel\u2080 hp.ne.symm, one_mul, \u2190 mul_div_assoc,\n      mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_real_preimage_closedBall_period_zero (x \u03b5 : \u211d) :\n    (\u2191) \u207b\u00b9' closedBall (x : AddCircle (0 : \u211d)) \u03b5 = closedBall x \u03b5 := by\n  ext y\n  simp [dist_eq_norm, \u2190 QuotientAddGroup.mk_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddCircle.lean", "context": {"open": ["Metric QuotientAddGroup Set", "Int hiding mem_zmultiples_iff", "AddSubgroup", "Metric"], "variables": ["(p : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03b5 : \u211d\n\u22a2 QuotientAddGroup.mk \u207b\u00b9' closedBall (\u2191x) \u03b5 = closedBall x \u03b5"}, {"line": "ext y", "tactic_state": "case h\nx \u03b5 y : \u211d\n\u22a2 y \u2208 QuotientAddGroup.mk \u207b\u00b9' closedBall (\u2191x) \u03b5 \u2194 y \u2208 closedBall x \u03b5"}, {"line": "simp [dist_eq_norm, \u2190 QuotientAddGroup.mk_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq {x : \u211d} : \u2016(x : UnitAddCircle)\u2016 = |x - round x| := by simp [AddCircle.norm_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/AddCircle.lean", "context": {"open": ["Metric QuotientAddGroup Set", "Int hiding mem_zmultiples_iff", "AddSubgroup", "Metric"], "variables": ["(p : \u211d)", "{p} [hp : Fact (0 < p)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 \u2016\u2191x\u2016 = |x - \u2191(round x)|"}, {"line": "simp [AddCircle.norm_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_eq_norm_div' (a b : E) : dist a b = \u2016b / a\u2016 := by rw [dist_comm, dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 dist a b = \u2016b / a\u2016"}, {"line": "rw [dist_comm, dist_eq_norm_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_one_right (a : E) : dist a 1 = \u2016a\u2016 := by rw [dist_eq_norm_div, div_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 dist a 1 = \u2016a\u2016"}, {"line": "rw [dist_eq_norm_div, div_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inseparable_one_iff_norm {a : E} : Inseparable a 1 \u2194 \u2016a\u2016 = 0 := by\n  rw [Metric.inseparable_iff]\n  rw [dist_one_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 Inseparable a 1 \u2194 \u2016a\u2016 = 0"}, {"line": "rw [Metric.inseparable_iff]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 dist a 1 = 0 \u2194 \u2016a\u2016 = 0"}, {"line": "rw [dist_one_right]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_one_left (a : E) : dist 1 a = \u2016a\u2016 := by rw [dist_comm, dist_one_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 dist 1 a = \u2016a\u2016"}, {"line": "rw [dist_comm, dist_one_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_div_rev (a b : E) : \u2016a / b\u2016 = \u2016b / a\u2016 := by\n  simpa only [dist_eq_norm_div] using dist_comm a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 \u2016a / b\u2016 = \u2016b / a\u2016"}, {"line": "simpa only [dist_eq_norm_div] using dist_comm a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_inv' (a : E) : \u2016a\u207b\u00b9\u2016 = \u2016a\u2016 := by simpa using norm_div_rev 1 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2016a\u207b\u00b9\u2016 = \u2016a\u2016"}, {"line": "simpa using norm_div_rev 1 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_zpow_abs (a : E) (n : \u2124) : \u2016a ^ |n|\u2016 = \u2016a ^ n\u2016 := by\n  rcases le_total 0 n with hn | hn <;> simp [hn, abs_of_nonneg, abs_of_nonpos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\n\u22a2 \u2016a ^ |n|\u2016 = \u2016a ^ n\u2016"}, {"line": "rcases le_total 0 n with hn | hn <;> simp [hn, abs_of_nonneg, abs_of_nonpos]", "tactic_state": "case inr\nE : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\nhn : n \u2264 0\n\u22a2 \u2016a ^ (-n)\u2016 = \u2016a ^ n\u2016"}]}
{"declaration": "theorem norm_pow_natAbs (a : E) (n : \u2124) : \u2016a ^ n.natAbs\u2016 = \u2016a ^ n\u2016 := by\n  rw [\u2190 zpow_natCast]\n  rw [\u2190 Int.abs_eq_natAbs]\n  rw [norm_zpow_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\n\u22a2 \u2016a ^ n.natAbs\u2016 = \u2016a ^ n\u2016"}, {"line": "rw [\u2190 zpow_natCast]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\n\u22a2 \u2016a ^ \u2191n.natAbs\u2016 = \u2016a ^ n\u2016"}, {"line": "rw [\u2190 Int.abs_eq_natAbs]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\n\u22a2 \u2016a ^ |n|\u2016 = \u2016a ^ n\u2016"}, {"line": "rw [norm_zpow_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_zpow_isUnit (a : E) {n : \u2124} (hn : IsUnit n) : \u2016a ^ n\u2016 = \u2016a\u2016 := by\n  rw [\u2190 norm_pow_natAbs]\n  rw [Int.isUnit_iff_natAbs_eq.mp hn]\n  rw [pow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\nhn : IsUnit n\n\u22a2 \u2016a ^ n\u2016 = \u2016a\u2016"}, {"line": "rw [\u2190 norm_pow_natAbs]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\nhn : IsUnit n\n\u22a2 \u2016a ^ n.natAbs\u2016 = \u2016a\u2016"}, {"line": "rw [Int.isUnit_iff_natAbs_eq.mp hn]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\nn : \u2124\nhn : IsUnit n\n\u22a2 \u2016a ^ 1\u2016 = \u2016a\u2016"}, {"line": "rw [pow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_mul_le' (a b : E) : \u2016a * b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016 := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 \u2016a * b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016"}, {"line": "simpa [dist_eq_norm_div] using dist_triangle a 1 b\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_div_le_norm_div_add_norm_div (a b c : E) : \u2016a / c\u2016 \u2264 \u2016a / b\u2016 + \u2016b / c\u2016 := by\n  simpa only [dist_eq_norm_div] using dist_triangle a b c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b c : E\n\u22a2 \u2016a / c\u2016 \u2264 \u2016a / b\u2016 + \u2016b / c\u2016"}, {"line": "simpa only [dist_eq_norm_div] using dist_triangle a b c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_nonneg' (a : E) : 0 \u2264 \u2016a\u2016 := by\n  rw [\u2190 dist_one_right]\n  exact dist_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 0 \u2264 \u2016a\u2016"}, {"line": "rw [\u2190 dist_one_right]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 0 \u2264 dist a 1"}, {"line": "exact dist_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_one' : \u2016(1 : E)\u2016 = 0 := by rw [\u2190 dist_one_right, dist_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\n\u22a2 \u20161\u2016 = 0"}, {"line": "rw [\u2190 dist_one_right, dist_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_lt_one_add_norm_sq' (x : E) : 0 < 1 + \u2016x\u2016 ^ 2 := by\n  positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 0 < 1 + \u2016x\u2016 ^ 2"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_div_le (a b : E) : \u2016a / b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016 := by\n  simpa [dist_eq_norm_div] using dist_triangle a 1 b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 \u2016a / b\u2016 \u2264 \u2016a\u2016 + \u2016b\u2016"}, {"line": "simpa [dist_eq_norm_div] using dist_triangle a 1 b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_norm_sub_norm_le' (a b : E) : |\u2016a\u2016 - \u2016b\u2016| \u2264 \u2016a / b\u2016 := by\n  simpa [dist_eq_norm_div] using abs_dist_sub_le a b 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 |\u2016a\u2016 - \u2016b\u2016| \u2264 \u2016a / b\u2016"}, {"line": "simpa [dist_eq_norm_div] using abs_dist_sub_le a b 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_sub_le_norm_mul (a b : E) : \u2016a\u2016 - \u2016b\u2016 \u2264 \u2016a * b\u2016 := by\n  simpa using norm_mul_le' (a * b) (b\u207b\u00b9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 \u2016a\u2016 - \u2016b\u2016 \u2264 \u2016a * b\u2016"}, {"line": "simpa using norm_mul_le' (a * b) (b\u207b\u00b9)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_div_eq_norm_right {x : E} (y : E) (h : \u2016x\u2016 = 0) : \u2016x / y\u2016 = \u2016y\u2016 := by\n  apply le_antisymm ?_ ?_\n  \u00b7 simpa [h] using norm_div_le x y\n  \u00b7 simpa [h, norm_div_rev x y] using norm_sub_norm_le' y x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016x\u2016 = 0\n\u22a2 \u2016x / y\u2016 = \u2016y\u2016"}, {"line": "apply le_antisymm ?_ ?_", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016x\u2016 = 0\n\u22a2 \u2016x / y\u2016 \u2264 \u2016y\u2016\n---\nE : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016x\u2016 = 0\n\u22a2 \u2016y\u2016 \u2264 \u2016x / y\u2016"}, {"line": "\u00b7 simpa [h] using norm_div_le x y", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016x\u2016 = 0\n\u22a2 \u2016y\u2016 \u2264 \u2016x / y\u2016"}, {"line": "\u00b7 simpa [h, norm_div_rev x y] using norm_sub_norm_le' y x", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_div_eq_norm_left (x : E) {y : E} (h : \u2016y\u2016 = 0) : \u2016x / y\u2016 = \u2016x\u2016 := by\n  apply le_antisymm ?_ ?_\n  \u00b7 simpa [h] using norm_div_le x y\n  \u00b7 simpa [h] using norm_sub_norm_le' x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016y\u2016 = 0\n\u22a2 \u2016x / y\u2016 = \u2016x\u2016"}, {"line": "apply le_antisymm ?_ ?_", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016y\u2016 = 0\n\u22a2 \u2016x / y\u2016 \u2264 \u2016x\u2016\n---\nE : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016y\u2016 = 0\n\u22a2 \u2016x\u2016 \u2264 \u2016x / y\u2016"}, {"line": "\u00b7 simpa [h] using norm_div_le x y", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx y : E\nh : \u2016y\u2016 = 0\n\u22a2 \u2016x\u2016 \u2264 \u2016x / y\u2016"}, {"line": "\u00b7 simpa [h] using norm_sub_norm_le' x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_ball_one_iff : a \u2208 ball (1 : E) r \u2194 \u2016a\u2016 < r := by rw [mem_ball, dist_one_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\nr : NNReal\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 a \u2208 ball 1 \u2191r \u2194 \u2016a\u2016 < \u2191r"}, {"line": "rw [mem_ball, dist_one_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_closedBall_one_iff : a \u2208 closedBall (1 : E) r \u2194 \u2016a\u2016 \u2264 r := by\n  rw [mem_closedBall]\n  rw [dist_one_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\nr : NNReal\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 a \u2208 closedBall 1 \u2191r \u2194 \u2016a\u2016 \u2264 \u2191r"}, {"line": "rw [mem_closedBall]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\nr : NNReal\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 dist a 1 \u2264 \u2191r \u2194 \u2016a\u2016 \u2264 \u2191r"}, {"line": "rw [dist_one_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedCommGroup.tendsto_nhds_nhds {f : E \u2192 F} {x : E} {y : F} :\n    Tendsto f (\ud835\udcdd x) (\ud835\udcdd y) \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x', \u2016x' / x\u2016 < \u03b4 \u2192 \u2016f x' / y\u2016 < \u03b5 := by\n  simp_rw [Metric.tendsto_nhds_nhds, dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_2\nE : Type u_1\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nf : E \u2192 F\nx : E\ny : F\n\u22a2 Tendsto f (nhds x) (nhds y) \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 (x' : E), \u2016x' / x\u2016 < \u03b4 \u2192 \u2016f x' / y\u2016 < \u03b5"}, {"line": "simp_rw [Metric.tendsto_nhds_nhds, dist_eq_norm_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedCommGroup.nhds_basis_norm_lt (x : E) :\n    (\ud835\udcdd x).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { y | \u2016y / x\u2016 < \u03b5 } := by\n  simp_rw [\u2190 ball_eq']\n  exact Metric.nhds_basis_ball\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 (nhds x).HasBasis (fun \u03b5 => 0 < \u03b5) fun \u03b5 => {y | \u2016y / x\u2016 < \u03b5}"}, {"line": "simp_rw [\u2190 ball_eq']", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 (nhds x).HasBasis (fun \u03b5 => 0 < \u03b5) fun \u03b5 => ball x \u03b5"}, {"line": "exact Metric.nhds_basis_ball", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedCommGroup.nhds_one_basis_norm_lt :\n    (\ud835\udcdd (1 : E)).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { y | \u2016y\u2016 < \u03b5 } := by\n  convert NormedCommGroup.nhds_basis_norm_lt (1 : E)\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\n\u22a2 (nhds 1).HasBasis (fun \u03b5 => 0 < \u03b5) fun \u03b5 => {y | \u2016y\u2016 < \u03b5}"}, {"line": "convert NormedCommGroup.nhds_basis_norm_lt (1 : E)", "tactic_state": "case h.e'_5.h.h.e'_2.h.h.e'_3.h.e'_3\nE : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx\u271d\u00b9 : \u211d\nx\u271d : E\n\u22a2 x\u271d = x\u271d / 1"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem NormedCommGroup.uniformity_basis_dist :\n    (\ud835\udce4 E).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { p : E \u00d7 E | \u2016p.fst / p.snd\u2016 < \u03b5 } := by\n  convert Metric.uniformity_basis_dist (\u03b1 := E) using 1\n  simp [dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\n\u22a2 (uniformity E).HasBasis (fun \u03b5 => 0 < \u03b5) fun \u03b5 => {p | \u2016p.1 / p.2\u2016 < \u03b5}"}, {"line": "convert Metric.uniformity_basis_dist (\u03b1 := E) using 1", "tactic_state": "case h.e'_5\nE : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\n\u22a2 (fun \u03b5 => {p | \u2016p.1 / p.2\u2016 < \u03b5}) = fun \u03b5 => {p | dist p.1 p.2 < \u03b5}"}, {"line": "simp [dist_eq_norm_div]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toReal_enorm' (x : E) : \u2016x\u2016\u2091.toReal = \u2016x\u2016 := by simp [enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 \u2016x\u2016\u2091.toReal = \u2016x\u2016"}, {"line": "simp [enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ofReal_norm' (x : E) : .ofReal \u2016x\u2016 = \u2016x\u2016\u2091 := by\n  simp [enorm, ENNReal.ofReal, Real.toNNReal, nnnorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 ENNReal.ofReal \u2016x\u2016 = \u2016x\u2016\u2091"}, {"line": "simp [enorm, ENNReal.ofReal, Real.toNNReal, nnnorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm'_eq_iff_norm_eq {x : E} {y : F} : \u2016x\u2016\u2091 = \u2016y\u2016\u2091 \u2194 \u2016x\u2016 = \u2016y\u2016 := by\n  simp only [\u2190 ofReal_norm']\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by congr\u27e9\n  exact (Real.toNNReal_eq_toNNReal_iff (norm_nonneg' _) (norm_nonneg' _)).mp (ENNReal.coe_inj.mp h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\n\u22a2 \u2016x\u2016\u2091 = \u2016y\u2016\u2091 \u2194 \u2016x\u2016 = \u2016y\u2016"}, {"line": "simp only [\u2190 ofReal_norm']", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\n\u22a2 ENNReal.ofReal \u2016x\u2016 = ENNReal.ofReal \u2016y\u2016 \u2194 \u2016x\u2016 = \u2016y\u2016"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by congr\u27e9", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\nh : ENNReal.ofReal \u2016x\u2016 = ENNReal.ofReal \u2016y\u2016\n\u22a2 \u2016x\u2016 = \u2016y\u2016"}, {"line": "exact (Real.toNNReal_eq_toNNReal_iff (norm_nonneg' _) (norm_nonneg' _)).mp (ENNReal.coe_inj.mp h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm'_le_iff_norm_le {x : E} {y : F} : \u2016x\u2016\u2091 \u2264 \u2016y\u2016\u2091 \u2194 \u2016x\u2016 \u2264 \u2016y\u2016 := by\n  simp only [\u2190 ofReal_norm']\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by gcongr\u27e9\n  rw [ENNReal.ofReal_le_ofReal_iff (norm_nonneg' _)] at h\n  exact h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\n\u22a2 \u2016x\u2016\u2091 \u2264 \u2016y\u2016\u2091 \u2194 \u2016x\u2016 \u2264 \u2016y\u2016"}, {"line": "simp only [\u2190 ofReal_norm']", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\n\u22a2 ENNReal.ofReal \u2016x\u2016 \u2264 ENNReal.ofReal \u2016y\u2016 \u2194 \u2016x\u2016 \u2264 \u2016y\u2016"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 by gcongr\u27e9", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\nh : ENNReal.ofReal \u2016x\u2016 \u2264 ENNReal.ofReal \u2016y\u2016\n\u22a2 \u2016x\u2016 \u2264 \u2016y\u2016"}, {"line": "rw [ENNReal.ofReal_le_ofReal_iff (norm_nonneg' _)] at h", "tactic_state": "F : Type u_6\nE : Type u_8\ninst\u271d\u00b2 : NNNorm E\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nx : E\ny : F\nh : \u2016x\u2016 \u2264 \u2016y\u2016\n\u22a2 \u2016x\u2016 \u2264 \u2016y\u2016"}, {"line": "exact h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_one_right (a : E) : nndist a 1 = \u2016a\u2016\u208a := by simp [nndist_eq_nnnorm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 nndist a 1 = \u2016a\u2016\u208a"}, {"line": "simp [nndist_eq_nnnorm_div]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2016a\u2016\u208a = \u2016a\u2016\u208a"}]}
{"declaration": "lemma edist_one_right (a : E) : edist a 1 = \u2016a\u2016\u2091 := by simp [edist_nndist, nndist_one_right, enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 edist a 1 = \u2016a\u2016\u2091"}, {"line": "simp [edist_nndist, nndist_one_right, enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_one_left (a : E) : nndist 1 a = \u2016a\u2016\u208a := by simp [nndist_eq_nnnorm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 nndist 1 a = \u2016a\u2016\u208a"}, {"line": "simp [nndist_eq_nnnorm_div]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2016a\u2016\u208a = \u2016a\u2016\u208a"}]}
{"declaration": "theorem edist_one_left (a : E) : edist 1 a = \u2016a\u2016\u208a := by\n  rw [edist_nndist]\n  rw [nndist_one_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 edist 1 a = \u2191\u2016a\u2016\u208a"}, {"line": "rw [edist_nndist]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2191(nndist 1 a) = \u2191\u2016a\u2016\u208a"}, {"line": "rw [nndist_one_left]", "tactic_state": "E : Type u_8\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2191\u2016a\u2016\u208a = \u2191\u2016a\u2016\u208a"}]}
{"declaration": "lemma enorm_one' {E : Type*} [TopologicalSpace E] [ENormedMonoid E] : \u2016(1 : E)\u2016\u2091 = 0 := by\n  rw [ENormedMonoid.enorm_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ENormedMonoid E\n\u22a2 \u20161\u2016\u2091 = 0"}, {"line": "rw [ENormedMonoid.enorm_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_inv' (a : E) : \u2016a\u207b\u00b9\u2016\u2091 = \u2016a\u2016\u2091 := by simp [enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na : E\n\u22a2 \u2016a\u207b\u00b9\u2016\u2091 = \u2016a\u2016\u2091"}, {"line": "simp [enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_eq_enorm_div (a b : E) : edist a b = \u2016a / b\u2016\u2091 := by\n  rw [edist_dist]\n  rw [dist_eq_norm_div]\n  rw [ofReal_norm_eq_enorm']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 edist a b = \u2016a / b\u2016\u2091"}, {"line": "rw [edist_dist]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 ENNReal.ofReal (dist a b) = \u2016a / b\u2016\u2091"}, {"line": "rw [dist_eq_norm_div]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 ENNReal.ofReal \u2016a / b\u2016 = \u2016a / b\u2016\u2091"}, {"line": "rw [ofReal_norm_eq_enorm']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_one_eq_enorm (x : E) : edist x 1 = \u2016x\u2016\u2091 := by rw [edist_eq_enorm_div, div_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NNNorm E\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 edist x 1 = \u2016x\u2016\u2091"}, {"line": "rw [edist_eq_enorm_div, div_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma ContinuousAt.enorm {a : X} (h : ContinuousAt f a) : ContinuousAt (\u2016f \u00b7\u2016\u2091) a := by fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ContinuousENorm E\nX : Type u_3\ninst\u271d : TopologicalSpace X\nf : X \u2192 E\na : X\nh : ContinuousAt f a\n\u22a2 ContinuousAt (fun x => \u2016f x\u2016\u2091) a"}, {"line": "fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_eq_zero' {a : E} : \u2016a\u2016\u2091 = 0 \u2194 a = 1 := by\n  simp [enorm, ENormedMonoid.enorm_eq_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b9 : TopologicalSpace E\ninst\u271d : ENormedMonoid E\na : E\n\u22a2 \u2016a\u2016\u2091 = 0 \u2194 a = 1"}, {"line": "simp [enorm, ENormedMonoid.enorm_eq_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnnorm_nnratCast (q : \u211a\u22650) : \u2016(q : \u211d)\u2016\u208a = q := by simp [nnnorm, -norm_eq_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\u22650\n\u22a2 \u2016\u2191q\u2016\u208a = \u2191q"}, {"line": "simp [nnnorm, -norm_eq_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_of_nonneg (hr : 0 \u2264 r) : \u2016r\u2016\u2091 = .ofReal r := by\n  simp [enorm, nnnorm_of_nonneg hr, ENNReal.ofReal, toNNReal, hr]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\n\u22a2 \u2016r\u2016\u2091 = ENNReal.ofReal r"}, {"line": "simp [enorm, nnnorm_of_nonneg hr, ENNReal.ofReal, toNNReal, hr]", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\n\u22a2 \u2016r\u2016\u208a = r.toNNReal"}]}
{"declaration": "theorem toNNReal_eq_nnnorm_of_nonneg (hr : 0 \u2264 r) : r.toNNReal = \u2016r\u2016\u208a := by\n  rw [Real.toNNReal_of_nonneg hr]\n  ext\n  rw [coe_mk]\n  rw [coe_nnnorm r]\n  rw [Real.norm_eq_abs r]\n  rw [abs_of_nonneg hr]\n  -- Porting note: this is due to the change from `Subtype.val` to `NNReal.toReal` for the coercion\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\n\u22a2 r.toNNReal = \u2016r\u2016\u208a"}, {"line": "rw [Real.toNNReal_of_nonneg hr]", "tactic_state": "r : \u211d\nhr : 0 \u2264 r\n\u22a2 \u27e8r, hr\u27e9 = \u2016r\u2016\u208a"}, {"line": "ext", "tactic_state": "case a\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 \u2191\u27e8r, hr\u27e9 = \u2191\u2016r\u2016\u208a"}, {"line": "rw [coe_mk]", "tactic_state": "case a\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 r = \u2191\u2016r\u2016\u208a"}, {"line": "rw [coe_nnnorm r]", "tactic_state": "case a\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 r = \u2016r\u2016"}, {"line": "rw [Real.norm_eq_abs r]", "tactic_state": "case a\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 r = |r|"}, {"line": "rw [abs_of_nonneg hr]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_closedBall'' : a \u2022 closedBall b r = closedBall (a \u2022 b) r := by\n  ext\n  simp [mem_closedBall, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, \u2190\n    eq_inv_mul_iff_mul_eq, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\n\u22a2 a \u2022 closedBall b r = closedBall (a \u2022 b) r"}, {"line": "ext", "tactic_state": "case h\nE : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 a \u2022 closedBall b r \u2194 x\u271d \u2208 closedBall (a \u2022 b) r"}, {"line": "simp [mem_closedBall, Set.mem_smul_set, dist_eq_norm_div, div_eq_inv_mul, \u2190\n    eq_inv_mul_iff_mul_eq, mul_assoc]", "tactic_state": "case h\nE : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\nx\u271d : E\n\u22a2 (\u2203 y, dist y b \u2264 r \u2227 a * y = x\u271d) \u2194 dist x\u271d (a * b) \u2264 r"}]}
{"declaration": "theorem smul_ball'' : a \u2022 ball b r = ball (a \u2022 b) r := by\n  ext\n  simp [mem_ball, Set.mem_smul_set, dist_eq_norm_div, _root_.div_eq_inv_mul,\n    \u2190 eq_inv_mul_iff_mul_eq, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\n\u22a2 a \u2022 ball b r = ball (a \u2022 b) r"}, {"line": "ext", "tactic_state": "case h\nE : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\nx\u271d : E\n\u22a2 x\u271d \u2208 a \u2022 ball b r \u2194 x\u271d \u2208 ball (a \u2022 b) r"}, {"line": "simp [mem_ball, Set.mem_smul_set, dist_eq_norm_div, _root_.div_eq_inv_mul,\n    \u2190 eq_inv_mul_iff_mul_eq, mul_assoc]", "tactic_state": "case h\nE : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\na b : E\nr : \u211d\nx\u271d : E\n\u22a2 (\u2203 y, dist y b < r \u2227 a * y = x\u271d) \u2194 dist x\u271d (a * b) < r"}]}
{"declaration": "lemma enorm_norm' (x : E) : \u2016\u2016x\u2016\u2016\u2091 = \u2016x\u2016\u2091 := by simp [enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b2 : TopologicalSpace E\ninst\u271d\u00b9 : ENormedMonoid E\ninst\u271d : SeminormedCommGroup E\nx : E\n\u22a2 \u2016\u2016x\u2016\u2016\u2091 = \u2016x\u2016\u2091"}, {"line": "simp [enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma enorm_enorm {\u03b5 : Type*} [ENorm \u03b5] (x : \u03b5) : \u2016\u2016x\u2016\u2091\u2016\u2091 = \u2016x\u2016\u2091 := by simp [enorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b5 : Type u_5\ninst\u271d : ENorm \u03b5\nx : \u03b5\n\u22a2 \u2016\u2016x\u2016\u2091\u2016\u2091 = \u2016x\u2016\u2091"}, {"line": "simp [enorm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_one_or_norm_pos (a : E) : a = 1 \u2228 0 < \u2016a\u2016 := by\n  simpa [eq_comm] using (norm_nonneg' a).eq_or_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Basic.lean", "context": {"open": ["Filter Function Metric Bornology", "ENNReal Filter NNReal Uniformity Pointwise Topology", "scoped symmDiff in", "Finset", "scoped symmDiff in", "scoped symmDiff in", "Set in"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "{E : Type*} [NNNorm E] {x : E} {r : \u211d\u22650}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E}", "(E)", "{E}", "[FunLike \ud835\udcd5 E F]", "{E : Type*} [TopologicalSpace E] [ContinuousENorm E]", "{X : Type*} [TopologicalSpace X] {f : X \u2192 E} {s : Set X} {a : X}", "{E : Type*} [TopologicalSpace E] [ENormedMonoid E]", "(E F)", "[FunLike \ud835\udcd5 E F]", "{r : \u211d}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}", "[NormedGroup E] {a b : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_4\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : ENormedMonoid E\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : NormedGroup E\na : E\n\u22a2 a = 1 \u2228 0 < \u2016a\u2016"}, {"line": "simpa [eq_comm] using (norm_nonneg' a).eq_or_lt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_norm_le_iff_of_nonneg' (hr : 0 \u2264 r) : \u2016x\u2016 \u2264 r \u2194 \u2200 i, \u2016x i\u2016 \u2264 r := by\n  simp only [\u2190 dist_one_right]\n  simp only [dist_pi_le_iff hr]\n  simp only [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Constructions.lean", "context": {"open": ["NNReal", "Additive Multiplicative", "OrderDual"], "variables": ["{\u03b9 E F : Type*} {G : \u03b9 \u2192 Type*}", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E] [Norm F] {x : E \u00d7 F} {r : \u211d}", "[SeminormedGroup E] [SeminormedGroup F]", "[Fintype \u03b9]", "[\u2200 i, SeminormedGroup (G i)] [SeminormedGroup E] (f : \u2200 i, G i) {x : \u2200 i, G i} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 \u2016x\u2016 \u2264 r \u2194 \u2200 (i : \u03b9), \u2016x i\u2016 \u2264 r"}, {"line": "simp only [\u2190 dist_one_right]", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 dist x 1 \u2264 r \u2194 \u2200 (i : \u03b9), dist (x i) 1 \u2264 r"}, {"line": "simp only [dist_pi_le_iff hr]", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 (\u2200 (b : \u03b9), dist (x b) (1 b) \u2264 r) \u2194 \u2200 (i : \u03b9), dist (x i) 1 \u2264 r"}, {"line": "simp only [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_norm_le_iff_of_nonempty' [Nonempty \u03b9] : \u2016f\u2016 \u2264 r \u2194 \u2200 b, \u2016f b\u2016 \u2264 r := by\n  by_cases hr : 0 \u2264 r\n  \u00b7 exact pi_norm_le_iff_of_nonneg' hr\n  \u00b7 exact\n      iff_of_false (fun h => hr <| (norm_nonneg' _).trans h) fun h =>\n        hr <| (norm_nonneg' _).trans <| h <| Classical.arbitrary _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Constructions.lean", "context": {"open": ["NNReal", "Additive Multiplicative", "OrderDual"], "variables": ["{\u03b9 E F : Type*} {G : \u03b9 \u2192 Type*}", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E] [Norm F] {x : E \u00d7 F} {r : \u211d}", "[SeminormedGroup E] [SeminormedGroup F]", "[Fintype \u03b9]", "[\u2200 i, SeminormedGroup (G i)] [SeminormedGroup E] (f : \u2200 i, G i) {x : \u2200 i, G i} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedGroup (G i)\nf : (i : \u03b9) \u2192 G i\nr : \u211d\ninst\u271d : Nonempty \u03b9\n\u22a2 \u2016f\u2016 \u2264 r \u2194 \u2200 (b : \u03b9), \u2016f b\u2016 \u2264 r"}, {"line": "by_cases hr : 0 \u2264 r", "tactic_state": "case pos\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedGroup (G i)\nf : (i : \u03b9) \u2192 G i\nr : \u211d\ninst\u271d : Nonempty \u03b9\nhr : 0 \u2264 r\n\u22a2 \u2016f\u2016 \u2264 r \u2194 \u2200 (b : \u03b9), \u2016f b\u2016 \u2264 r\n---\ncase neg\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedGroup (G i)\nf : (i : \u03b9) \u2192 G i\nr : \u211d\ninst\u271d : Nonempty \u03b9\nhr : \u00ac0 \u2264 r\n\u22a2 \u2016f\u2016 \u2264 r \u2194 \u2200 (b : \u03b9), \u2016f b\u2016 \u2264 r"}, {"line": "\u00b7 exact pi_norm_le_iff_of_nonneg' hr", "tactic_state": "case neg\n\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedGroup (G i)\nf : (i : \u03b9) \u2192 G i\nr : \u211d\ninst\u271d : Nonempty \u03b9\nhr : \u00ac0 \u2264 r\n\u22a2 \u2016f\u2016 \u2264 r \u2194 \u2200 (b : \u03b9), \u2016f b\u2016 \u2264 r"}, {"line": "\u00b7 exact\n      iff_of_false (fun h => hr <| (norm_nonneg' _).trans h) fun h =>\n        hr <| (norm_nonneg' _).trans <| h <| Classical.arbitrary _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_norm_lt_iff' (hr : 0 < r) : \u2016x\u2016 < r \u2194 \u2200 i, \u2016x i\u2016 < r := by\n  simp only [\u2190 dist_one_right]\n  simp only [dist_pi_lt_iff hr]\n  simp only [Pi.one_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Constructions.lean", "context": {"open": ["NNReal", "Additive Multiplicative", "OrderDual"], "variables": ["{\u03b9 E F : Type*} {G : \u03b9 \u2192 Type*}", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E] [Norm F] {x : E \u00d7 F} {r : \u211d}", "[SeminormedGroup E] [SeminormedGroup F]", "[Fintype \u03b9]", "[\u2200 i, SeminormedGroup (G i)] [SeminormedGroup E] (f : \u2200 i, G i) {x : \u2200 i, G i} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 < r\n\u22a2 \u2016x\u2016 < r \u2194 \u2200 (i : \u03b9), \u2016x i\u2016 < r"}, {"line": "simp only [\u2190 dist_one_right]", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 < r\n\u22a2 dist x 1 < r \u2194 \u2200 (i : \u03b9), dist (x i) 1 < r"}, {"line": "simp only [dist_pi_lt_iff hr]", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedGroup (G i)\nx : (i : \u03b9) \u2192 G i\nr : \u211d\nhr : 0 < r\n\u22a2 (\u2200 (b : \u03b9), dist (x b) (1 b) < r) \u2194 \u2200 (i : \u03b9), dist (x i) 1 < r"}, {"line": "simp only [Pi.one_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pi_norm_const' [Nonempty \u03b9] (a : E) : \u2016fun _i : \u03b9 => a\u2016 = \u2016a\u2016 := by\n  simpa only [\u2190 dist_one_right] using dist_pi_const a 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Constructions.lean", "context": {"open": ["NNReal", "Additive Multiplicative", "OrderDual"], "variables": ["{\u03b9 E F : Type*} {G : \u03b9 \u2192 Type*}", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E] [Norm F] {x : E \u00d7 F} {r : \u211d}", "[SeminormedGroup E] [SeminormedGroup F]", "[Fintype \u03b9]", "[\u2200 i, SeminormedGroup (G i)] [SeminormedGroup E] (f : \u2200 i, G i) {x : \u2200 i, G i} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2070 : Norm E\ninst\u271d\u2079 : NNNorm E\ninst\u271d\u2078 : Norm E\ninst\u271d\u2077 : NNNorm E\ninst\u271d\u2076 : Norm E\ninst\u271d\u2075 : NNNorm E\ninst\u271d\u2074 : Norm E\ninst\u271d\u00b3 : SeminormedGroup E\ninst\u271d\u00b2 : Fintype \u03b9\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : Nonempty \u03b9\na : E\n\u22a2 \u2016fun _i => a\u2016 = \u2016a\u2016"}, {"line": "simpa only [\u2190 dist_one_right] using dist_pi_const a 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Pi.enorm_single [DecidableEq \u03b9] [\u2200 i, NormedAddCommGroup (G i)] {i : \u03b9} (y : G i) :\n    \u2016Pi.single i y\u2016\u2091 = \u2016y\u2016\u2091 := by simp [enorm, Pi.nnnorm_single]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Constructions.lean", "context": {"open": ["NNReal", "Additive Multiplicative", "OrderDual"], "variables": ["{\u03b9 E F : Type*} {G : \u03b9 \u2192 Type*}", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E]", "[NNNorm E]", "[Norm E] [Norm F] {x : E \u00d7 F} {r : \u211d}", "[SeminormedGroup E] [SeminormedGroup F]", "[Fintype \u03b9]", "[\u2200 i, SeminormedGroup (G i)] [SeminormedGroup E] (f : \u2200 i, G i) {x : \u2200 i, G i} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nG : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : (i : \u03b9) \u2192 SeminormedGroup (G i)\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : (i : \u03b9) \u2192 NormedAddCommGroup (G i)\ni : \u03b9\ny : G i\n\u22a2 \u2016single i y\u2016\u2091 = \u2016y\u2016\u2091"}, {"line": "simp [enorm, Pi.nnnorm_single]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_iff_norm_div_tendsto_zero {f : \u03b1 \u2192 E} {a : Filter \u03b1} {b : E} :\n    Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (fun e => \u2016f e / b\u2016) a (\ud835\udcdd 0) := by\n  simp only [\u2190 dist_eq_norm_div]\n  simp only [\u2190 tendsto_iff_dist_tendsto_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nE : Type u_5\ninst\u271d : SeminormedGroup E\nf : \u03b1 \u2192 E\na : Filter \u03b1\nb : E\n\u22a2 Tendsto f a (nhds b) \u2194 Tendsto (fun e => \u2016f e / b\u2016) a (nhds 0)"}, {"line": "simp only [\u2190 dist_eq_norm_div]", "tactic_state": "\u03b1 : Type u_2\nE : Type u_5\ninst\u271d : SeminormedGroup E\nf : \u03b1 \u2192 E\na : Filter \u03b1\nb : E\n\u22a2 Tendsto f a (nhds b) \u2194 Tendsto (fun e => dist (f e) b) a (nhds 0)"}, {"line": "simp only [\u2190 tendsto_iff_dist_tendsto_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_norm_nhds_one : comap norm (\ud835\udcdd 0) = \ud835\udcdd (1 : E) := by\n  simpa only [dist_one_right] using nhds_comap_dist (1 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\ninst\u271d : SeminormedGroup E\n\u22a2 comap norm (nhds 0) = nhds 1"}, {"line": "simpa only [dist_one_right] using nhds_comap_dist (1 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_norm' {x : E} : Tendsto (fun a => \u2016a\u2016) (\ud835\udcdd x) (\ud835\udcdd \u2016x\u2016) := by\n  simpa using tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (1 : E)) _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\ninst\u271d : SeminormedGroup E\nx : E\n\u22a2 Tendsto (fun a => \u2016a\u2016) (nhds x) (nhds \u2016x\u2016)"}, {"line": "simpa using tendsto_id.dist (tendsto_const_nhds : Tendsto (fun _a => (1 : E)) _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_norm_one : Tendsto (fun a : E => \u2016a\u2016) (\ud835\udcdd 1) (\ud835\udcdd 0) := by\n  simpa using tendsto_norm_div_self (1 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\ninst\u271d : SeminormedGroup E\n\u22a2 Tendsto (fun a => \u2016a\u2016) (nhds 1) (nhds 0)"}, {"line": "simpa using tendsto_norm_div_self (1 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SeminormedGroup.tendstoUniformlyOn_one {f : \u03b9 \u2192 \u03ba \u2192 G} {s : Set \u03ba} {l : Filter \u03b9} :\n    TendstoUniformlyOn f 1 l s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 i in l, \u2200 x \u2208 s, \u2016f i x\u2016 < \u03b5 := by\n  simp only [tendstoUniformlyOn_iff]\n  simp only [Pi.one_apply]\n  simp only [dist_one_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "{l : Filter \u03b1} {f : \u03b1 \u2192 E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 TendstoUniformlyOn f 1 l s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (i : \u03b9) in l, \u2200 x \u2208 s, \u2016f i x\u2016 < \u03b5"}, {"line": "simp only [tendstoUniformlyOn_iff]", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 (\u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9) in l, \u2200 x \u2208 s, dist (1 x) (f n x) < \u03b5) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (i : \u03b9) in l, \u2200 x \u2208 s, \u2016f i x\u2016 < \u03b5"}, {"line": "simp only [Pi.one_apply]", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 (\u2200 \u03b5 > 0, \u2200\u1da0 (n : \u03b9) in l, \u2200 x \u2208 s, dist 1 (f n x) < \u03b5) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 (i : \u03b9) in l, \u2200 x \u2208 s, \u2016f i x\u2016 < \u03b5"}, {"line": "simp only [dist_one_left]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SeminormedGroup.uniformCauchySeqOn_iff_tendstoUniformlyOn_one {f : \u03b9 \u2192 \u03ba \u2192 G} {s : Set \u03ba}\n    {l : Filter \u03b9} :\n    UniformCauchySeqOn f l s \u2194\n      TendstoUniformlyOn (fun n : \u03b9 \u00d7 \u03b9 => fun z => f n.fst z / f n.snd z) 1 (l \u00d7\u02e2 l) s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]\n  rw [SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "{l : Filter \u03b1} {f : \u03b1 \u2192 E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 UniformCauchySeqOn f l s \u2194 TendstoUniformlyOn (fun n z => f n.1 z / f n.2 z) 1 (l \u00d7\u02e2 l) s"}, {"line": "rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 UniformCauchySeqOn f l s \u2194 TendstoUniformlyOnFilter (fun n z => f n.1 z / f n.2 z) 1 (l \u00d7\u02e2 l) (principal s)"}, {"line": "rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]", "tactic_state": "\u03b9 : Type u_3\n\u03ba : Type u_4\nG : Type u_7\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : SeminormedGroup G\nf : \u03b9 \u2192 \u03ba \u2192 G\ns : Set \u03ba\nl : Filter \u03b9\n\u22a2 UniformCauchySeqOnFilter f l (principal s) \u2194\n    TendstoUniformlyOnFilter (fun n z => f n.1 z / f n.2 z) 1 (l \u00d7\u02e2 l) (principal s)"}, {"line": "rw [SeminormedGroup.uniformCauchySeqOnFilter_iff_tendstoUniformlyOnFilter_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma comap_norm_nhdsGT_zero' : comap norm (\ud835\udcdd[>] 0) = \ud835\udcdd[\u2260] (1 : E) := by\n  simp [nhdsWithin, comap_norm_nhds_one, Set.preimage, Set.compl_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Continuity.lean", "context": {"open": ["Filter Function Metric Bornology ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 \u03b1 \u03b9 \u03ba E F G : Type*}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "{l : Filter \u03b1} {f : \u03b1 \u2192 E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}", "[SeminormedGroup E] [SeminormedGroup F] [SeminormedGroup G] {s : Set E} {a : E}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 E} {s : Set \u03b1} {a : \u03b1}", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a b : E} {r : \u211d}", "[NormedGroup E] {a b : E}", "(E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_5\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : NormedGroup E\n\u22a2 comap norm (nhdsWithin 0 (Set.Ioi 0)) = nhdsWithin 1 {1}\u1d9c"}, {"line": "simp [nhdsWithin, comap_norm_nhds_one, Set.preimage, Set.compl_def]", "tactic_state": "E : Type u_5\ninst\u271d\u2074 inst\u271d\u00b3 inst\u271d\u00b2 : SeminormedGroup E\ninst\u271d\u00b9 : SeminormedCommGroup E\ninst\u271d : NormedGroup E\n\u22a2 comap norm (nhds 0) \u2293 principal {x | 0 < \u2016x\u2016} = nhds 1 \u2293 principal {x | \u00acx = 1}"}]}
{"declaration": "theorem controlled_closure_range_of_complete {f : NormedAddGroupHom G H} {K : Type*}\n    [SeminormedAddCommGroup K] {j : NormedAddGroupHom K H} (hj : \u2200 x, \u2016j x\u2016 = \u2016x\u2016) {C \u03b5 : \u211d}\n    (hC : 0 < C) (h\u03b5 : 0 < \u03b5) (hyp : \u2200 k, \u2203 g, f g = j k \u2227 \u2016g\u2016 \u2264 C * \u2016k\u2016) :\n    f.SurjectiveOnWith j.range.topologicalClosure (C + \u03b5) := by\n  replace hyp : \u2200 h \u2208 j.range, \u2203 g, f g = h \u2227 \u2016g\u2016 \u2264 C * \u2016h\u2016 := by\n    intro h h_in\n    rcases (j.mem_range _).mp h_in with \u27e8k, rfl\u27e9\n    rw [hj]\n    exact hyp k\n  exact controlled_closure_of_complete hC h\u03b5 hyp", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/ControlledClosure.lean", "context": {"open": ["Filter Finset", "Topology"], "variables": ["{G : Type*} [NormedAddCommGroup G] [CompleteSpace G]", "{H : Type*} [NormedAddCommGroup H]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : CompleteSpace G\nH : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : Type u_3\ninst\u271d : SeminormedAddCommGroup K\nj : NormedAddGroupHom K H\nhj : \u2200 (x : K), \u2016j x\u2016 = \u2016x\u2016\nC \u03b5 : \u211d\nhC : 0 < C\nh\u03b5 : 0 < \u03b5\nhyp : \u2200 (k : K), \u2203 g, f g = j k \u2227 \u2016g\u2016 \u2264 C * \u2016k\u2016\n\u22a2 f.SurjectiveOnWith j.range.topologicalClosure (C + \u03b5)"}, {"line": "replace hyp : \u2200 h \u2208 j.range, \u2203 g, f g = h \u2227 \u2016g\u2016 \u2264 C * \u2016h\u2016 := by\n    intro h h_in\n    rcases (j.mem_range _).mp h_in with \u27e8k, rfl\u27e9\n    rw [hj]\n    exact hyp k", "tactic_state": "G : Type u_1\ninst\u271d\u00b3 : NormedAddCommGroup G\ninst\u271d\u00b2 : CompleteSpace G\nH : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup H\nf : NormedAddGroupHom G H\nK : Type u_3\ninst\u271d : SeminormedAddCommGroup K\nj : NormedAddGroupHom K H\nhj : \u2200 (x : K), \u2016j x\u2016 = \u2016x\u2016\nC \u03b5 : \u211d\nhC : 0 < C\nh\u03b5 : 0 < \u03b5\nhyp : \u2200 h \u2208 sorry, \u2203 g, f g = h \u2227 sorry \u2264 C * sorry\n\u22a2 f.SurjectiveOnWith j.range.topologicalClosure (C + \u03b5)"}, {"line": "exact controlled_closure_of_complete hC h\u03b5 hyp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem SurjectiveOnWith.exists_pos {f : NormedAddGroupHom V\u2081 V\u2082} {K : AddSubgroup V\u2082} {C : \u211d}\n    (h : f.SurjectiveOnWith K C) : \u2203 C' > 0, f.SurjectiveOnWith K C' := by\n  refine \u27e8|C| + 1, ?_, ?_\u27e9\n  \u00b7 linarith [abs_nonneg C]\n  \u00b7 apply h.mono\n    linarith [le_abs_self C]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Hom.lean", "context": {"open": ["NNReal"], "variables": ["{V W : Type*} [SeminormedAddCommGroup V] [SeminormedAddCommGroup W]", "{V V\u2081 V\u2082 V\u2083 : Type*} [SeminormedAddCommGroup V] [SeminormedAddCommGroup V\u2081]", "{f g : NormedAddGroupHom V\u2081 V\u2082}", "(f g)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\nK : sorry\nC : \u211d\nh : sorry\n\u22a2 \u2203 C' > 0, sorry"}, {"line": "refine \u27e8|C| + 1, ?_, ?_\u27e9", "tactic_state": "case refine_1\nf : sorry\nK : sorry\nC : \u211d\nh : sorry\n\u22a2 sorry > 0\n---\ncase refine_2\nf : sorry\nK : sorry\nC : \u211d\nh : sorry\n\u22a2 sorry"}, {"line": "\u00b7 linarith [abs_nonneg C]", "tactic_state": "case refine_2\nf : sorry\nK : sorry\nC : \u211d\nh : sorry\n\u22a2 sorry"}, {"line": "\u00b7 apply h.mono\n    linarith [le_abs_self C]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem summable_iff_vanishing_norm [CompleteSpace E] {f : \u03b9 \u2192 E} :\n    Summable f \u2194 \u2200 \u03b5 > (0 : \u211d), \u2203 s : Finset \u03b9, \u2200 t, Disjoint t s \u2192 \u2016\u2211 i \u2208 t, f i\u2016 < \u03b5 := by\n  rw [summable_iff_cauchySeq_finset]\n  rw [cauchySeq_finset_iff_vanishing_norm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "context": {"open": ["Topology NNReal", "Finset Filter Metric"], "variables": ["{\u03b9 \u03b1 E F : Type*} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\n\u22a2 Summable f \u2194 \u2200 \u03b5 > 0, \u2203 s, \u2200 (t : Finset \u03b9), Disjoint t s \u2192 \u2016\u2211 i \u2208 t, f i\u2016 < \u03b5"}, {"line": "rw [summable_iff_cauchySeq_finset]", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\n\u22a2 (CauchySeq fun s => \u2211 b \u2208 s, f b) \u2194 \u2200 \u03b5 > 0, \u2203 s, \u2200 (t : Finset \u03b9), Disjoint t s \u2192 \u2016\u2211 i \u2208 t, f i\u2016 < \u03b5\n---\n\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\n\u22a2 CompleteSpace E"}, {"line": "rw [cauchySeq_finset_iff_vanishing_norm]", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\n\u22a2 CompleteSpace E"}]}
{"declaration": "theorem Summable.of_norm_bounded [CompleteSpace E] {f : \u03b9 \u2192 E} (g : \u03b9 \u2192 \u211d) (hg : Summable g)\n    (h : \u2200 i, \u2016f i\u2016 \u2264 g i) : Summable f := by\n  rw [summable_iff_cauchySeq_finset]\n  exact cauchySeq_finset_of_norm_bounded g hg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "context": {"open": ["Topology NNReal", "Finset Filter Metric"], "variables": ["{\u03b9 \u03b1 E F : Type*} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 \u211d\nhg : Summable g\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 g i\n\u22a2 Summable f"}, {"line": "rw [summable_iff_cauchySeq_finset]", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 \u211d\nhg : Summable g\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 g i\n\u22a2 CauchySeq fun s => \u2211 b \u2208 s, f b\n---\n\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 \u211d\nhg : Summable g\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 g i\n\u22a2 CompleteSpace E"}, {"line": "exact cauchySeq_finset_of_norm_bounded g hg h", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : CompleteSpace E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 \u211d\nhg : Summable g\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 g i\n\u22a2 CompleteSpace E"}]}
{"declaration": "theorem tsum_of_nnnorm_bounded {f : \u03b9 \u2192 E} {g : \u03b9 \u2192 \u211d\u22650} {a : \u211d\u22650} (hg : HasSum g a)\n    (h : \u2200 i, \u2016f i\u2016\u208a \u2264 g i) : \u2016\u2211' i : \u03b9, f i\u2016\u208a \u2264 a := by\n  simp only [\u2190 NNReal.coe_le_coe] at *\n  simp only [\u2190 NNReal.hasSum_coe] at *\n  simp only [coe_nnnorm] at *\n  exact tsum_of_norm_bounded hg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/InfiniteSum.lean", "context": {"open": ["Topology NNReal", "Finset Filter Metric"], "variables": ["{\u03b9 \u03b1 E F : Type*} [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d : SeminormedAddCommGroup E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 NNReal\na : NNReal\nhg : HasSum g a\nh : \u2200 (i : \u03b9), \u2016f i\u2016\u208a \u2264 g i\n\u22a2 \u2016\u2211' (i : \u03b9), f i\u2016\u208a \u2264 a"}, {"line": "simp only [\u2190 NNReal.coe_le_coe] at *", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d : SeminormedAddCommGroup E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 NNReal\na : NNReal\nhg : HasSum g a\nh : \u2200 (i : \u03b9), \u2191\u2016f i\u2016\u208a \u2264 \u2191(g i)\n\u22a2 \u2191\u2016\u2211' (i : \u03b9), f i\u2016\u208a \u2264 \u2191a"}, {"line": "simp only [\u2190 NNReal.hasSum_coe] at *", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d : SeminormedAddCommGroup E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 NNReal\na : NNReal\nh : \u2200 (i : \u03b9), \u2191\u2016f i\u2016\u208a \u2264 \u2191(g i)\nhg : HasSum (fun a => \u2191(g a)) \u2191a\n\u22a2 \u2191\u2016\u2211' (i : \u03b9), f i\u2016\u208a \u2264 \u2191a"}, {"line": "simp only [coe_nnnorm] at *", "tactic_state": "\u03b9 : Type u_1\nE : Type u_3\ninst\u271d : SeminormedAddCommGroup E\nf : \u03b9 \u2192 E\ng : \u03b9 \u2192 NNReal\na : NNReal\nh : \u2200 (i : \u03b9), \u2016f i\u2016 \u2264 \u2191(g i)\nhg : HasSum (fun a => \u2191(g a)) \u2191a\n\u22a2 \u2016\u2211' (i : \u03b9), f i\u2016 \u2264 \u2191a"}, {"line": "exact tsum_of_norm_bounded hg h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toZeroHom_eq_coe : \u21d1p.toZeroHom = p := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Seminorm.lean", "context": {"open": ["Set", "NNReal"], "variables": ["{R R' E F G : Type*}", "[AddGroup E] [FunLike F E \u211d] [NonarchAddGroupSeminormClass F E] (f : F) (x y : E)", "[Group E] [Group F] [Group G] {p q : GroupSeminorm E}", "(p q) (f : F \u2192* E)", "{p q}", "[CommGroup E] [CommGroup F] (p q : GroupSeminorm E) (x : E)", "[AddGroup E] [SMul R \u211d] [SMul R \u211d\u22650] [IsScalarTower R \u211d\u22650 \u211d]", "[AddGroup E] {p q : NonarchAddGroupSeminorm E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u2074 : AddGroup E\ninst\u271d\u00b3 : Group E\ninst\u271d\u00b2 : CommGroup E\ninst\u271d\u00b9 inst\u271d : AddGroup E\np : NonarchAddGroupSeminorm E\n\u22a2 \u21d1p.toZeroHom = \u21d1p"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_mul_self_left (a b : E) : dist (a * b) b = \u2016a\u2016 := by\n  rw [dist_comm]\n  rw [dist_mul_self_right]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 dist (a * b) b = \u2016a\u2016"}, {"line": "rw [dist_comm]", "tactic_state": "E : Type u_2\ninst\u271d : SeminormedGroup E\na b : E\n\u22a2 dist b (a * b) = \u2016a\u2016"}, {"line": "rw [dist_mul_self_right]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzOnWith_iff_norm_div_le {f : E \u2192 F} {C : \u211d\u22650} :\n    LipschitzOnWith C f s \u2194 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 \u2016f x / f y\u2016 \u2264 C * \u2016x / y\u2016 := by\n  simp only [lipschitzOnWith_iff_dist_le_mul]\n  simp only [dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\ns : Set E\nf : E \u2192 F\nC : NNReal\n\u22a2 LipschitzOnWith C f s \u2194 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 \u2016f x / f y\u2016 \u2264 \u2191C * \u2016x / y\u2016"}, {"line": "simp only [lipschitzOnWith_iff_dist_le_mul]", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\ns : Set E\nf : E \u2192 F\nC : NNReal\n\u22a2 (\u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 \u2191C * dist x y) \u2194\n    \u2200 \u2983x : E\u2984, x \u2208 s \u2192 \u2200 \u2983y : E\u2984, y \u2208 s \u2192 \u2016f x / f y\u2016 \u2264 \u2191C * \u2016x / y\u2016"}, {"line": "simp only [dist_eq_norm_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzWith_iff_norm_div_le {f : E \u2192 F} {C : \u211d\u22650} :\n    LipschitzWith C f \u2194 \u2200 x y, \u2016f x / f y\u2016 \u2264 C * \u2016x / y\u2016 := by\n  simp only [lipschitzWith_iff_dist_le_mul]\n  simp only [dist_eq_norm_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nf : E \u2192 F\nC : NNReal\n\u22a2 LipschitzWith C f \u2194 \u2200 (x y : E), \u2016f x / f y\u2016 \u2264 \u2191C * \u2016x / y\u2016"}, {"line": "simp only [lipschitzWith_iff_dist_le_mul]", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nf : E \u2192 F\nC : NNReal\n\u22a2 (\u2200 (x y : E), dist (f x) (f y) \u2264 \u2191C * dist x y) \u2194 \u2200 (x y : E), \u2016f x / f y\u2016 \u2264 \u2191C * \u2016x / y\u2016"}, {"line": "simp only [dist_eq_norm_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem LipschitzWith.norm_le_mul' {f : E \u2192 F} {K : \u211d\u22650} (h : LipschitzWith K f) (hf : f 1 = 1)\n    (x) : \u2016f x\u2016 \u2264 K * \u2016x\u2016 := by simpa only [dist_one_right, hf] using h.dist_le_mul x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nf : E \u2192 F\nK : NNReal\nh : LipschitzWith K f\nhf : f 1 = 1\nx : E\n\u22a2 \u2016f x\u2016 \u2264 \u2191K * \u2016x\u2016"}, {"line": "simpa only [dist_one_right, hf] using h.dist_le_mul x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AntilipschitzWith.le_mul_norm' {f : E \u2192 F} {K : \u211d\u22650} (h : AntilipschitzWith K f)\n    (hf : f 1 = 1) (x) : \u2016x\u2016 \u2264 K * \u2016f x\u2016 := by\n  simpa only [dist_one_right,hf] using h.le_mul_dist x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedGroup F\nf : E \u2192 F\nK : NNReal\nh : AntilipschitzWith K f\nhf : f 1 = 1\nx : E\n\u22a2 \u2016x\u2016 \u2264 \u2191K * \u2016f x\u2016"}, {"line": "simpa only [dist_one_right,hf] using h.le_mul_dist x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzWith_one_norm' : LipschitzWith 1 (norm : E \u2192 \u211d) := by\n  simpa using LipschitzWith.dist_right (1 : E)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d : SeminormedGroup E\n\u22a2 LipschitzWith 1 norm"}, {"line": "simpa using LipschitzWith.dist_right (1 : E)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem dist_div_div_le (a\u2081 a\u2082 b\u2081 b\u2082 : E) : dist (a\u2081 / a\u2082) (b\u2081 / b\u2082) \u2264 dist a\u2081 b\u2081 + dist a\u2082 b\u2082 := by\n  simpa only [div_eq_mul_inv,dist_inv_inv] using dist_mul_mul_le a\u2081 a\u2082\u207b\u00b9 b\u2081 b\u2082\u207b\u00b9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a\u2081 a\u2082 b\u2081 b\u2082 : E} {r\u2081 r\u2082 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : SeminormedGroup E\ninst\u271d : SeminormedCommGroup E\na\u2081 a\u2082 b\u2081 b\u2082 : E\n\u22a2 dist (a\u2081 / a\u2082) (b\u2081 / b\u2082) \u2264 dist a\u2081 b\u2081 + dist a\u2082 b\u2082"}, {"line": "simpa only [div_eq_mul_inv,dist_inv_inv] using dist_mul_mul_le a\u2081 a\u2082\u207b\u00b9 b\u2081 b\u2082\u207b\u00b9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_mul_norm_div {f : E \u2192 F} (hf : AntilipschitzWith K f) (x y : E) :\n    \u2016x / y\u2016 \u2264 K * \u2016f x / f y\u2016 := by simp [\u2190 dist_eq_norm_div, hf.le_mul_dist x y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/Uniform.lean", "context": {"open": ["Filter Function Metric Bornology", "scoped ENNReal NNReal Uniformity Pointwise Topology", "Finset", "Finset"], "variables": ["{\ud835\udcd5 E F : Type*}", "[SeminormedGroup E] [SeminormedGroup F] {s : Set E} {a b : E} {r : \u211d}", "[FunLike \ud835\udcd5 E F]", "[SeminormedCommGroup E] [SeminormedCommGroup F] {a\u2081 a\u2082 b\u2081 b\u2082 : E} {r\u2081 r\u2082 : \u211d}", "{\u03b1 E : Type*} [SeminormedCommGroup E] [PseudoEMetricSpace \u03b1] {K Kf Kg : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "F : Type u_3\ninst\u271d\u00b2 : SeminormedGroup F\ninst\u271d\u00b9 : SeminormedCommGroup F\nE : Type u_5\ninst\u271d : SeminormedCommGroup E\nK : NNReal\nf : E \u2192 F\nhf : AntilipschitzWith K f\nx y : E\n\u22a2 \u2016x / y\u2016 \u2264 \u2191K * \u2016f x / f y\u2016"}, {"line": "simp [\u2190 dist_eq_norm_div, hf.le_mul_dist x y]", "tactic_state": "F : Type u_3\ninst\u271d\u00b2 : SeminormedGroup F\ninst\u271d\u00b9 : SeminormedCommGroup F\nE : Type u_5\ninst\u271d : SeminormedCommGroup E\nK : NNReal\nf : E \u2192 F\nhf : AntilipschitzWith K f\nx y : E\n\u22a2 dist x y \u2264 \u2191K * \u2016f x / f y\u2016"}]}
{"declaration": "example : HasCokernels SemiNormedGrp := by infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 HasCokernels SemiNormedGrp"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem explicitCokernelIso_hom_\u03c0 {X Y : SemiNormedGrp.{u}} (f : X \u27f6 Y) :\n    explicitCokernel\u03c0 f \u226b (explicitCokernelIso f).hom = cokernel.\u03c0 _ := by\n  simp [explicitCokernel\u03c0, explicitCokernelIso, IsColimit.coconePointUniqueUpToIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nexplicitCokernel\u03c0 : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernelIso : x\u271d\nX Y : SemiNormedGrp\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp sorry sorry = cokernel.\u03c0 (?m.9912 f)"}, {"line": "simp [explicitCokernel\u03c0, explicitCokernelIso, IsColimit.coconePointUniqueUpToIso]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nexplicitCokernel\u03c0 : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernelIso : x\u271d\nX Y : SemiNormedGrp\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (sorry ()) (sorry ()) = cokernel.\u03c0 (?m.9912 f)"}]}
{"declaration": "theorem explicitCokernelIso_inv_\u03c0 {X Y : SemiNormedGrp.{u}} (f : X \u27f6 Y) :\n    cokernel.\u03c0 f \u226b (explicitCokernelIso f).inv = explicitCokernel\u03c0 f := by\n  simp [explicitCokernel\u03c0, explicitCokernelIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nexplicitCokernelIso : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernel\u03c0 : x\u271d\nX Y : SemiNormedGrp\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (cokernel.\u03c0 f) sorry = sorry"}, {"line": "simp [explicitCokernel\u03c0, explicitCokernelIso]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nexplicitCokernelIso : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernel\u03c0 : x\u271d\nX Y : SemiNormedGrp\nf : X \u27f6 Y\n\u22a2 CategoryStruct.comp (cokernel.\u03c0 f) (sorry ()) = sorry ()"}]}
{"declaration": "theorem explicitCokernelIso_hom_desc {X Y Z : SemiNormedGrp.{u}} {f : X \u27f6 Y} {g : Y \u27f6 Z}\n    (w : f \u226b g = 0) :\n    (explicitCokernelIso f).hom \u226b cokernel.desc f g w = explicitCokernelDesc w := by\n  ext1\n  simp [explicitCokernelDesc, explicitCokernel\u03c0, explicitCokernelIso,\n    IsColimit.coconePointUniqueUpToIso]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Group/SemiNormedGrp/Kernels.lean", "context": {"open": ["CategoryTheory CategoryTheory.Limits", "scoped NNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nexplicitCokernelIso : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernelDesc : x\u271d\nX Y Z : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nw : CategoryStruct.comp f g = 0\n\u22a2 CategoryStruct.comp sorry (cokernel.desc f g w) = sorry"}, {"line": "ext1", "tactic_state": "case hf\nx\u271d\u00b9 : Sort u_1\nexplicitCokernelIso : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernelDesc : x\u271d\nX Y Z : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nw : CategoryStruct.comp f g = 0\n\u22a2 SemiNormedGrp.Hom.hom (CategoryStruct.comp sorry (cokernel.desc f g w)) = SemiNormedGrp.Hom.hom sorry"}, {"line": "simp [explicitCokernelDesc, explicitCokernel\u03c0, explicitCokernelIso,\n    IsColimit.coconePointUniqueUpToIso]", "tactic_state": "case hf\nx\u271d\u00b9 : Sort u_1\nexplicitCokernelIso : x\u271d\u00b9\nx\u271d : Sort u_2\nexplicitCokernelDesc : x\u271d\nX Y Z : SemiNormedGrp\nf : X \u27f6 Y\ng : Y \u27f6 Z\nw : CategoryStruct.comp f g = 0\n\u22a2 (SemiNormedGrp.Hom.hom (cokernel.desc f g w)).comp (SemiNormedGrp.Hom.hom (sorry ())) =\n    SemiNormedGrp.Hom.hom (sorry ())"}]}
{"declaration": "theorem Mem\u2113p.all (f : \u2200 i, E i) : Mem\u2113p f p := by\n  rcases p.trichotomy with (rfl | rfl | _h)\n  \u00b7 exact mem\u2113p_zero_iff.mpr { i : \u03b1 | f i \u2260 0 }.toFinite\n  \u00b7 exact mem\u2113p_infty_iff.mpr (Set.Finite.bddAbove (Set.range fun i : \u03b1 \u21a6 \u2016f i\u2016).toFinite)\n  \u00b7 cases nonempty_fintype \u03b1; exact mem\u2113p_gen \u27e8Finset.univ.sum _, hasSum_fintype _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/LpEquiv.lean", "context": {"open": ["scoped ENNReal"], "variables": ["{\u03b1 : Type*} {E : \u03b1 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)] {p : \u211d\u22650\u221e}", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f p"}, {"line": "rcases p.trichotomy with (rfl | rfl | _h)", "tactic_state": "case inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f 0\n---\ncase inr.inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f \u22a4\n---\ncase inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n_h : 0 < p.toReal\n\u22a2 Mem\u2113p f p"}, {"line": "\u00b7 exact mem\u2113p_zero_iff.mpr { i : \u03b1 | f i \u2260 0 }.toFinite", "tactic_state": "case inr.inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f \u22a4\n---\ncase inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n_h : 0 < p.toReal\n\u22a2 Mem\u2113p f p"}, {"line": "\u00b7 exact mem\u2113p_infty_iff.mpr (Set.Finite.bddAbove (Set.range fun i : \u03b1 \u21a6 \u2016f i\u2016).toFinite)", "tactic_state": "case inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d : Finite \u03b1\nf : (i : \u03b1) \u2192 E i\n_h : 0 < p.toReal\n\u22a2 Mem\u2113p f p"}, {"line": "\u00b7 cases nonempty_fintype \u03b1; exact mem\u2113p_gen \u27e8Finset.univ.sum _, hasSum_fintype _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem equiv_lpPiLp_norm [Fintype \u03b1] (f : lp E p) : \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  \u00b7 simp [Equiv.lpPiLp, PiLp.norm_eq_card, lp.norm_eq_card_dsupport]\n  \u00b7 rw [PiLp.norm_eq_ciSup, lp.norm_eq_ciSup]; rfl\n  \u00b7 rw [PiLp.norm_eq_sum h, lp.norm_eq_tsum_rpow h, tsum_fintype]; rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/LpEquiv.lean", "context": {"open": ["scoped ENNReal"], "variables": ["{\u03b1 : Type*} {E : \u03b1 \u2192 Type*} [\u2200 i, NormedAddCommGroup (E i)] {p : \u211d\u22650\u221e}", "[Finite \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E p)\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016"}, {"line": "rcases p.trichotomy with (rfl | rfl | h)", "tactic_state": "case inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E 0)\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016\n---\ncase inr.inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E \u22a4)\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016\n---\ncase inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E p)\nh : 0 < p.toReal\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016"}, {"line": "\u00b7 simp [Equiv.lpPiLp, PiLp.norm_eq_card, lp.norm_eq_card_dsupport]", "tactic_state": "case inr.inl\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E \u22a4)\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016\n---\ncase inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E p)\nh : 0 < p.toReal\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016"}, {"line": "\u00b7 rw [PiLp.norm_eq_ciSup, lp.norm_eq_ciSup]; rfl", "tactic_state": "case inr.inr\n\u03b1 : Type u_1\nE : \u03b1 \u2192 Type u_2\ninst\u271d\u00b2 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\np : ENNReal\ninst\u271d\u00b9 : Finite \u03b1\ninst\u271d : Fintype \u03b1\nf : \u21a5(lp E p)\nh : 0 < p.toReal\n\u22a2 \u2016Equiv.lpPiLp f\u2016 = \u2016f\u2016"}, {"line": "\u00b7 rw [PiLp.norm_eq_sum h, lp.norm_eq_tsum_rpow h, tsum_fintype]; rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_apply_le [\u2200 i, PseudoMetricSpace (\u03b2 i)] (x y : PiLp p \u03b2) (i : \u03b9) :\n    nndist (x i) (y i) \u2264 nndist x y := by\n  simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_apply_le x y i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u2074 : Fact (1 \u2264 p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 PseudoMetricSpace (\u03b2 i)\nx y : PiLp p \u03b2\ni : \u03b9\n\u22a2 nndist (x i) (y i) \u2264 nndist x y"}, {"line": "simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_apply_le x y i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_apply_le [\u2200 i, SeminormedAddCommGroup (\u03b2 i)] (x : PiLp p \u03b2) (i : \u03b9) :\n    \u2016x i\u2016\u2091 \u2264 \u2016x\u2016\u2091 := by\n  simpa using edist_apply_le x 0 i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u2074 : Fact (1 \u2264 p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx : PiLp p \u03b2\ni : \u03b9\n\u22a2 \u2016x i\u2016\u2091 \u2264 \u2016x\u2016\u2091"}, {"line": "simpa using edist_apply_le x 0 i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnnorm_apply_le [\u2200 i, SeminormedAddCommGroup (\u03b2 i)] (x : PiLp p \u03b2) (i : \u03b9) :\n    \u2016x i\u2016\u208a \u2264 \u2016x\u2016\u208a := by\n  simpa using nndist_apply_le x 0 i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u2074 : Fact (1 \u2264 p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx : PiLp p \u03b2\ni : \u03b9\n\u22a2 \u2016x i\u2016\u208a \u2264 \u2016x\u2016\u208a"}, {"line": "simpa using nndist_apply_le x 0 i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_apply_le [\u2200 i, SeminormedAddCommGroup (\u03b2 i)] (x : PiLp p \u03b2) (i : \u03b9) :\n    \u2016x i\u2016 \u2264 \u2016x\u2016 := by\n  simpa using dist_apply_le x 0 i\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2078 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2077 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u2074 : Fact (1 \u2264 p)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx : PiLp p \u03b2\ni : \u03b9\n\u22a2 \u2016x i\u2016 \u2264 \u2016x\u2016"}, {"line": "simpa using dist_apply_le x 0 i", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnnorm_eq_sum {p : \u211d\u22650\u221e} [Fact (1 \u2264 p)] {\u03b2 : \u03b9 \u2192 Type*} (hp : p \u2260 \u221e)\n    [\u2200 i, SeminormedAddCommGroup (\u03b2 i)] (f : PiLp p \u03b2) :\n    \u2016f\u2016\u208a = (\u2211 i, \u2016f i\u2016\u208a ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [NNReal.coe_sum, norm_eq_sum (p.toReal_pos_iff_ne_top.mpr hp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype \u03b9\np : ENNReal\ninst\u271d\u00b9 : Fact (1 \u2264 p)\n\u03b2 : \u03b9 \u2192 Type u_5\nhp : p \u2260 \u22a4\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp p \u03b2\n\u22a2 \u2016f\u2016\u208a = (\u2211 i, \u2016f i\u2016\u208a ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "ext", "tactic_state": "case a\n\u03b9 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype \u03b9\np : ENNReal\ninst\u271d\u00b9 : Fact (1 \u2264 p)\n\u03b2 : \u03b9 \u2192 Type u_5\nhp : p \u2260 \u22a4\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp p \u03b2\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191((\u2211 i, \u2016f i\u2016\u208a ^ p.toReal) ^ (1 / p.toReal))"}, {"line": "simp [NNReal.coe_sum, norm_eq_sum (p.toReal_pos_iff_ne_top.mpr hp)]", "tactic_state": "case a\n\u03b9 : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 : Fintype \u03b9\np : ENNReal\ninst\u271d\u00b9 : Fact (1 \u2264 p)\n\u03b2 : \u03b9 \u2192 Type u_5\nhp : p \u2260 \u22a4\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp p \u03b2\n\u22a2 \u2016f\u2016 = (\u2211 x, \u2016f x\u2016 ^ p.toReal) ^ p.toReal\u207b\u00b9"}]}
{"declaration": "theorem nnnorm_eq_ciSup (f : PiLp \u221e \u03b2) : \u2016f\u2016\u208a = \u2a06 i, \u2016f i\u2016\u208a := by\n  ext\n  simp [NNReal.coe_iSup, norm_eq_ciSup]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}", "{\u03b2}", "[\u2200 i, SeminormedAddCommGroup (\u03b2 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2077 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp \u22a4 \u03b2\n\u22a2 \u2016f\u2016\u208a = \u2a06 i, \u2016f i\u2016\u208a"}, {"line": "ext", "tactic_state": "case a\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2077 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp \u22a4 \u03b2\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191(\u2a06 i, \u2016f i\u2016\u208a)"}, {"line": "simp [NNReal.coe_iSup, norm_eq_ciSup]", "tactic_state": "case a\n\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2077 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nf : PiLp \u22a4 \u03b2\n\u22a2 \u2016f\u2016 = \u2a06 i, \u2016f i\u2016"}]}
{"declaration": "theorem edist_eq_of_L1 (x y : PiLp 1 \u03b2) : edist x y = \u2211 i, edist (x i) (y i) := by\n  simp [PiLp.edist_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}", "{\u03b2}", "[\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\u03b2} [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2077 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx y : PiLp 1 \u03b2\n\u22a2 edist x y = \u2211 i, edist (x i) (y i)"}, {"line": "simp [PiLp.edist_eq_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem edist_eq_of_L2 (x y : PiLp 2 \u03b2) :\n    edist x y = (\u2211 i, edist (x i) (y i) ^ 2) ^ (1 / 2 : \u211d) := by simp [PiLp.edist_eq_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}", "{\u03b2}", "[\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\u03b2} [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\u03b2} [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\n\u03b2 : \u03b9 \u2192 Type u_4\ninst\u271d\u2077 : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\ninst\u271d\u2076 : (i : \u03b9) \u2192 EDist (\u03b2 i)\ninst\u271d\u2075 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u2074 : (i : \u03b9) \u2192 Norm (\u03b2 i)\ninst\u271d\u00b3 : (i : \u03b9) \u2192 PseudoEMetricSpace (\u03b2 i)\ninst\u271d\u00b2 inst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (\u03b2 i)\nx y : PiLp 2 \u03b2\n\u22a2 edist x y = (\u2211 i, edist (x i) (y i) ^ 2) ^ (1 / 2)"}, {"line": "simp [PiLp.edist_eq_sum]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.LinearIsometryEquiv.piLpCongrLeft_single [DecidableEq \u03b9] [DecidableEq \u03b9']\n    (e : \u03b9 \u2243 \u03b9') (i : \u03b9) (v : E) :\n    LinearIsometryEquiv.piLpCongrLeft p \ud835\udd5c E e ((WithLp.equiv p (_ \u2192 E)).symm <| Pi.single i v) =\n      (WithLp.equiv p (_ \u2192 E)).symm (Pi.single (e i) v) := by\n  funext x\n  simp [LinearIsometryEquiv.piLpCongrLeft_apply, LinearEquiv.piCongrLeft', Equiv.piCongrLeft',\n    Pi.single, Function.update, Equiv.symm_apply_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/PiLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c : Type*) {\u03b9 : Type*} (\u03b1 : \u03b9 \u2192 Type*) (\u03b2 : \u03b9 \u2192 Type*)", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "(x y : PiLp p \u03b2) (i : \u03b9)", "(p) in", "[Fintype \u03b9]", "[\u2200 i, EDist (\u03b2 i)]", "{\u03b2}", "{\u03b2}", "[\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[\u2200 i, Dist (\u03b1 i)]", "{\u03b1}", "[\u2200 i, Norm (\u03b2 i)]", "{p \u03b2}", "[Fact (1 \u2264 p)] [\u2200 i, PseudoMetricSpace (\u03b1 i)] [\u2200 i, PseudoEMetricSpace (\u03b2 i)]", "[Fintype \u03b9]", "{p \u03b2} in", "[hp : Fact (1 \u2264 p)]", "[Fintype \u03b9]", "{\u03b2 p}", "{\u03b2 p}", "{\u03b2}", "[\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\u03b2} [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\u03b2} [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "{\ud835\udd5c p \u03b1}", "[Semiring \ud835\udd5c] [\u2200 i, SeminormedAddCommGroup (\u03b1 i)] [\u2200 i, SeminormedAddCommGroup (\u03b2 i)]", "[\u2200 i, Module \ud835\udd5c (\u03b1 i)] [\u2200 i, Module \ud835\udd5c (\u03b2 i)] (c : \ud835\udd5c)", "{\u03b9' : Type*}", "[Fintype \u03b9']", "(p \ud835\udd5c)", "(E : Type*) [SeminormedAddCommGroup E] [Module \ud835\udd5c E]", "{p \ud835\udd5c E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : Fact (1 \u2264 p)\ninst\u271d\u2077 inst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : Semiring \ud835\udd5c\n\u03b9' : Type u_5\ninst\u271d\u2074 : Fintype \u03b9'\nE : Type u_6\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq \u03b9'\ne : \u03b9 \u2243 \u03b9'\ni : \u03b9\nv : E\n\u22a2 (LinearIsometryEquiv.piLpCongrLeft p \ud835\udd5c E e) ((WithLp.equiv p (\u03b9 \u2192 E)).symm (Pi.single i v)) =\n    (WithLp.equiv p (\u03b9' \u2192 E)).symm (Pi.single (e i) v)"}, {"line": "funext x", "tactic_state": "case h\np : ENNReal\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : Fact (1 \u2264 p)\ninst\u271d\u2077 inst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : Semiring \ud835\udd5c\n\u03b9' : Type u_5\ninst\u271d\u2074 : Fintype \u03b9'\nE : Type u_6\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq \u03b9'\ne : \u03b9 \u2243 \u03b9'\ni : \u03b9\nv : E\nx : \u03b9'\n\u22a2 (LinearIsometryEquiv.piLpCongrLeft p \ud835\udd5c E e) ((WithLp.equiv p (\u03b9 \u2192 E)).symm (Pi.single i v)) x =\n    (WithLp.equiv p (\u03b9' \u2192 E)).symm (Pi.single (e i) v) x"}, {"line": "simp [LinearIsometryEquiv.piLpCongrLeft_apply, LinearEquiv.piCongrLeft', Equiv.piCongrLeft',\n    Pi.single, Function.update, Equiv.symm_apply_eq]", "tactic_state": "case h\np : ENNReal\n\ud835\udd5c : Type u_1\n\u03b9 : Type u_2\ninst\u271d\u2079 : Semiring \ud835\udd5c\ninst\u271d\u2078 : Fact (1 \u2264 p)\ninst\u271d\u2077 inst\u271d\u2076 : Fintype \u03b9\ninst\u271d\u2075 : Semiring \ud835\udd5c\n\u03b9' : Type u_5\ninst\u271d\u2074 : Fintype \u03b9'\nE : Type u_6\ninst\u271d\u00b3 : SeminormedAddCommGroup E\ninst\u271d\u00b2 : Module \ud835\udd5c E\ninst\u271d\u00b9 : DecidableEq \u03b9\ninst\u271d : DecidableEq \u03b9'\ne : \u03b9 \u2243 \u03b9'\ni : \u03b9\nv : E\nx : \u03b9'\n\u22a2 (if e.symm x = i then v else 0) = if x = e i then v else 0"}]}
{"declaration": "theorem prod_edist_eq_card (f g : WithLp 0 (\u03b1 \u00d7 \u03b2)) :\n    edist f g =\n      (if edist f.fst g.fst = 0 then 0 else 1) + (if edist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\ninst\u271d\u00b9 : EDist \u03b1\ninst\u271d : EDist \u03b2\nf g : WithLp 0 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist f g = (if edist f.1 g.1 = 0 then 0 else 1) + if edist f.2 g.2 = 0 then 0 else 1"}, {"line": "convert if_pos rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_edist_self (f : WithLp p (\u03b1 \u00d7 \u03b2)) : edist f f = 0 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  \u00b7 classical\n    simp\n  \u00b7 simp [prod_edist_eq_sup]\n  \u00b7 simp [prod_edist_eq_add h, ENNReal.zero_rpow_of_pos h,\n      ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 edist f f = 0"}, {"line": "rcases p.trichotomy with (rfl | rfl | h)", "tactic_state": "case inl\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp 0 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist f f = 0\n---\ncase inr.inl\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp \u22a4 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist f f = 0\n---\ncase inr.inr\np : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp p (\u03b1 \u00d7 \u03b2)\nh : 0 < p.toReal\n\u22a2 edist f f = 0"}, {"line": "\u00b7 classical\n    simp", "tactic_state": "case inr.inl\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp \u22a4 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist f f = 0\n---\ncase inr.inr\np : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp p (\u03b1 \u00d7 \u03b2)\nh : 0 < p.toReal\n\u22a2 edist f f = 0"}, {"line": "\u00b7 simp [prod_edist_eq_sup]", "tactic_state": "case inr.inr\np : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2075 : AddCommGroup \u03b1\ninst\u271d\u2074 : AddCommGroup \u03b2\ninst\u271d\u00b3 : EDist \u03b1\ninst\u271d\u00b2 : EDist \u03b2\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nf : WithLp p (\u03b1 \u00d7 \u03b2)\nh : 0 < p.toReal\n\u22a2 edist f f = 0"}, {"line": "\u00b7 simp [prod_edist_eq_add h, ENNReal.zero_rpow_of_pos h,\n      ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_dist_eq_card (f g : WithLp 0 (\u03b1 \u00d7 \u03b2)) : dist f g =\n    (if dist f.fst g.fst = 0 then 0 else 1) + (if dist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2077 : AddCommGroup \u03b1\ninst\u271d\u2076 : AddCommGroup \u03b2\ninst\u271d\u2075 : EDist \u03b1\ninst\u271d\u2074 : EDist \u03b2\ninst\u271d\u00b3 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b2 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9 : Dist \u03b1\ninst\u271d : Dist \u03b2\nf g : WithLp 0 (\u03b1 \u00d7 \u03b2)\n\u22a2 dist f g = (if dist f.1 g.1 = 0 then 0 else 1) + if dist f.2 g.2 = 0 then 0 else 1"}, {"line": "convert if_pos rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_norm_eq_card (f : WithLp 0 (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016 = (if \u2016f.fst\u2016 = 0 then 0 else 1) + (if \u2016f.snd\u2016 = 0 then 0 else 1) := by\n  convert if_pos rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u2079 : AddCommGroup \u03b1\ninst\u271d\u2078 : AddCommGroup \u03b2\ninst\u271d\u2077 : EDist \u03b1\ninst\u271d\u2076 : EDist \u03b2\ninst\u271d\u2075 : PseudoEMetricSpace \u03b1\ninst\u271d\u2074 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b3 : Dist \u03b1\ninst\u271d\u00b2 : Dist \u03b2\ninst\u271d\u00b9 : Norm \u03b1\ninst\u271d : Norm \u03b2\nf : WithLp 0 (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016f\u2016 = (if \u2016f.1\u2016 = 0 then 0 else 1) + if \u2016f.2\u2016 = 0 then 0 else 1"}, {"line": "convert if_pos rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_lipschitzWith_equiv_aux [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] :\n    LipschitzWith 1 (WithLp.equiv p (\u03b1 \u00d7 \u03b2)) := by\n  intro x y\n  change max _ _ \u2264 _\n  rw [ENNReal.coe_one]\n  rw [one_mul]\n  rw [sup_le_iff]\n  exact edist_proj_le_edist_aux p x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\n\u22a2 LipschitzWith 1 \u21d1(WithLp.equiv p (\u03b1 \u00d7 \u03b2))"}, {"line": "intro x y", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x) ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y) \u2264 \u21911 * edist x y"}, {"line": "change max _ _ \u2264 _", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 max (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).1 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).1)\n      (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).2 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).2) \u2264\n    \u21911 * edist x y"}, {"line": "rw [ENNReal.coe_one]", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 max (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).1 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).1)\n      (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).2 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).2) \u2264\n    1 * edist x y"}, {"line": "rw [one_mul]", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 max (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).1 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).1)\n      (edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).2 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).2) \u2264\n    edist x y"}, {"line": "rw [sup_le_iff]", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b9\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b9\u2070 : AddCommGroup \u03b2\ninst\u271d\u2079 : EDist \u03b1\ninst\u271d\u2078 : EDist \u03b2\ninst\u271d\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u2075 : Dist \u03b1\ninst\u271d\u2074 : Dist \u03b2\ninst\u271d\u00b3 : Norm \u03b1\ninst\u271d\u00b2 : Norm \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoEMetricSpace \u03b1\ninst\u271d : PseudoEMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).1 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).1 \u2264 edist x y \u2227\n    edist ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) x).2 ((WithLp.equiv p (\u03b1 \u00d7 \u03b2)) y).2 \u2264 edist x y"}, {"line": "exact edist_proj_le_edist_aux p x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_fst_le [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (x y : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    nndist x.fst y.fst \u2264 nndist x y := by\n  simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_fst_le x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 nndist x.1 y.1 \u2264 nndist x y"}, {"line": "simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_fst_le x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nndist_snd_le [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] (x y : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    nndist x.snd y.snd \u2264 nndist x y := by\n  simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_snd_le x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : PseudoMetricSpace \u03b1\ninst\u271d : PseudoMetricSpace \u03b2\nx y : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 nndist x.2 y.2 \u2264 nndist x y"}, {"line": "simpa [\u2190 coe_nnreal_ennreal_nndist] using edist_snd_le x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_fst_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.fst\u2016\u2091 \u2264 \u2016x\u2016\u2091 := by\n  simpa using edist_fst_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.1\u2016\u2091 \u2264 \u2016x\u2016\u2091"}, {"line": "simpa using edist_fst_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_snd_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.snd\u2016\u2091 \u2264 \u2016x\u2016\u2091 := by\n  simpa using edist_snd_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.2\u2016\u2091 \u2264 \u2016x\u2016\u2091"}, {"line": "simpa using edist_snd_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnnorm_fst_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.fst\u2016\u208a \u2264 \u2016x\u2016\u208a := by\n  simpa using nndist_fst_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.1\u2016\u208a \u2264 \u2016x\u2016\u208a"}, {"line": "simpa using nndist_fst_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nnnorm_snd_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.snd\u2016\u208a \u2264 \u2016x\u2016\u208a := by\n  simpa using nndist_snd_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.2\u2016\u208a \u2264 \u2016x\u2016\u208a"}, {"line": "simpa using nndist_snd_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_fst_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.fst\u2016 \u2264 \u2016x\u2016 := by\n  simpa using dist_fst_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.1\u2016 \u2264 \u2016x\u2016"}, {"line": "simpa using dist_fst_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_snd_le [SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2] (x : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016x.snd\u2016 \u2264 \u2016x\u2016 := by\n  simpa using dist_snd_le x 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_1\n\u03b2 : Type u_2\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016x.2\u2016 \u2264 \u2016x\u2016"}, {"line": "simpa using dist_snd_le x 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_nnnorm_eq_add (hp : p \u2260 \u221e) (f : WithLp p (\u03b1 \u00d7 \u03b2)) :\n    \u2016f\u2016\u208a = (\u2016f.fst\u2016\u208a ^ p.toReal + \u2016f.snd\u2016\u208a ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [prod_norm_eq_add (p.toReal_pos_iff_ne_top.mpr hp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}", "{p \u03b1 \u03b2}", "[SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d\u00b9 : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nhp : p \u2260 \u22a4\nf : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016f\u2016\u208a = (\u2016f.1\u2016\u208a ^ p.toReal + \u2016f.2\u2016\u208a ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "ext", "tactic_state": "case a\np : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d\u00b9 : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nhp : p \u2260 \u22a4\nf : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191((\u2016f.1\u2016\u208a ^ p.toReal + \u2016f.2\u2016\u208a ^ p.toReal) ^ (1 / p.toReal))"}, {"line": "simp [prod_norm_eq_add (p.toReal_pos_iff_ne_top.mpr hp)]", "tactic_state": "case a\np : ENNReal\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\nhp\u271d\u00b9 : Fact (1 \u2264 p)\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\nhp\u271d : Fact (1 \u2264 p)\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nhp : p \u2260 \u22a4\nf : WithLp p (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016f\u2016 = (\u2016f.1\u2016 ^ p.toReal + \u2016f.2\u2016 ^ p.toReal) ^ p.toReal\u207b\u00b9"}]}
{"declaration": "theorem prod_nnnorm_eq_sup (f : WithLp \u221e (\u03b1 \u00d7 \u03b2)) : \u2016f\u2016\u208a = \u2016f.fst\u2016\u208a \u2294  \u2016f.snd\u2016\u208a := by\n  ext\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}", "{p \u03b1 \u03b2}", "[SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nf : WithLp \u22a4 (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2016f\u2016\u208a = max \u2016f.1\u2016\u208a \u2016f.2\u2016\u208a"}, {"line": "ext", "tactic_state": "case a\n\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nf : WithLp \u22a4 (\u03b1 \u00d7 \u03b2)\n\u22a2 \u2191\u2016f\u2016\u208a = \u2191(max \u2016f.1\u2016\u208a \u2016f.2\u2016\u208a)"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem prod_edist_eq_of_L2 (x y : WithLp 2 (\u03b1 \u00d7 \u03b2)) :\n    edist x y = (edist x.fst y.fst ^ 2 + edist x.snd y.snd ^ 2) ^ (1 / 2 : \u211d) := by\n  simp [prod_edist_eq_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/ProdLp.lean", "context": {"open": ["Real Set Filter RCLike Bornology Uniformity Topology NNReal ENNReal", "scoped Classical in", "scoped Classical in", "scoped Classical in"], "variables": ["(p : \u211d\u22650\u221e) (\ud835\udd5c \u03b1 \u03b2 : Type*)", "{p \ud835\udd5c \u03b1 \u03b2}", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "(x y : WithLp p (\u03b1 \u00d7 \u03b2)) (c : \ud835\udd5c)", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "{p \u03b1 \u03b2}", "[EDist \u03b1] [EDist \u03b2]", "{p \u03b1 \u03b2}", "{\u03b1 \u03b2}", "[PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]", "[Dist \u03b1] [Dist \u03b2]", "{p \u03b1 \u03b2}", "[Norm \u03b1] [Norm \u03b2]", "{p \u03b1 \u03b2}", "[hp : Fact (1 \u2264 p)]", "{\u03b1 \u03b2}", "(\u03b1 \u03b2)", "{\u03b1 \u03b2} in", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[T0Space \u03b1] [T0Space \u03b2]", "[UniformSpace \u03b1] [UniformSpace \u03b2]", "[CompleteSpace \u03b1] [CompleteSpace \u03b2]", "[TopologicalSpace \u03b1] [TopologicalSpace \u03b2]", "[Semiring \ud835\udd5c] [AddCommGroup \u03b1] [AddCommGroup \u03b2]", "[Module \ud835\udd5c \u03b1] [Module \ud835\udd5c \u03b2]", "[hp : Fact (1 \u2264 p)]", "{p \u03b1 \u03b2}", "(p \u03b1 \u03b2)", "{\u03b2 p}", "{p \u03b1 \u03b2}", "[SeminormedAddCommGroup \u03b1] [SeminormedAddCommGroup \u03b2]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx y : WithLp 2 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist x y = (edist x.1 y.1 ^ 2 + edist x.2 y.2 ^ 2) ^ (1 / 2)"}, {"line": "simp [prod_edist_eq_add]", "tactic_state": "\u03b1 : Type u_2\n\u03b2 : Type u_1\ninst\u271d\u00b2\u00b9 : AddCommGroup \u03b1\ninst\u271d\u00b2\u2070 : AddCommGroup \u03b2\ninst\u271d\u00b9\u2079 : EDist \u03b1\ninst\u271d\u00b9\u2078 : EDist \u03b2\ninst\u271d\u00b9\u2077 : PseudoEMetricSpace \u03b1\ninst\u271d\u00b9\u2076 : PseudoEMetricSpace \u03b2\ninst\u271d\u00b9\u2075 : Dist \u03b1\ninst\u271d\u00b9\u2074 : Dist \u03b2\ninst\u271d\u00b9\u00b3 : Norm \u03b1\ninst\u271d\u00b9\u00b2 : Norm \u03b2\ninst\u271d\u00b9\u00b9 : T0Space \u03b1\ninst\u271d\u00b9\u2070 : T0Space \u03b2\ninst\u271d\u2079 : UniformSpace \u03b1\ninst\u271d\u2078 : UniformSpace \u03b2\ninst\u271d\u2077 : CompleteSpace \u03b1\ninst\u271d\u2076 : CompleteSpace \u03b2\ninst\u271d\u2075 : TopologicalSpace \u03b1\ninst\u271d\u2074 : TopologicalSpace \u03b2\ninst\u271d\u00b3 : AddCommGroup \u03b1\ninst\u271d\u00b2 : AddCommGroup \u03b2\ninst\u271d\u00b9 : SeminormedAddCommGroup \u03b1\ninst\u271d : SeminormedAddCommGroup \u03b2\nx y : WithLp 2 (\u03b1 \u00d7 \u03b2)\n\u22a2 edist x y = (edist x.1 y.1 ^ 2 + edist x.2 y.2 ^ 2) ^ 2\u207b\u00b9"}]}
{"declaration": "theorem mem\u2113p_zero_iff {f : \u2200 i, E i} : Mem\u2113p f 0 \u2194 Set.Finite { i | f i \u2260 0 } := by\n  dsimp [Mem\u2113p]\n  rw [if_pos rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f 0 \u2194 {i | f i \u2260 0}.Finite"}, {"line": "dsimp [Mem\u2113p]", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : (i : \u03b1) \u2192 E i\n\u22a2 (if 0 = 0 then {i | \u00acf i = 0}.Finite else Summable fun i => \u2016f i\u2016 ^ 0) \u2194 {i | \u00acf i = 0}.Finite"}, {"line": "rw [if_pos rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem\u2113p_infty_iff {f : \u2200 i, E i} : Mem\u2113p f \u221e \u2194 BddAbove (Set.range fun i => \u2016f i\u2016) := by\n  simp [Mem\u2113p]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f \u22a4 \u2194 BddAbove (Set.range fun i => \u2016f i\u2016)"}, {"line": "simp [Mem\u2113p]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem\u2113p_gen_iff (hp : 0 < p.toReal) {f : \u2200 i, E i} :\n    Mem\u2113p f p \u2194 Summable fun i => \u2016f i\u2016 ^ p.toReal := by\n  rw [ENNReal.toReal_pos_iff] at hp\n  dsimp [Mem\u2113p]\n  rw [if_neg hp.1.ne']\n  rw [if_neg hp.2.ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f p \u2194 Summable fun i => \u2016f i\u2016 ^ p.toReal"}, {"line": "rw [ENNReal.toReal_pos_iff] at hp", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p \u2227 p < \u22a4\nf : (i : \u03b1) \u2192 E i\n\u22a2 Mem\u2113p f p \u2194 Summable fun i => \u2016f i\u2016 ^ p.toReal"}, {"line": "dsimp [Mem\u2113p]", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p \u2227 p < \u22a4\nf : (i : \u03b1) \u2192 E i\n\u22a2 (if p = 0 then {i | \u00acf i = 0}.Finite\n    else if p = \u22a4 then BddAbove (Set.range fun i => \u2016f i\u2016) else Summable fun i => \u2016f i\u2016 ^ p.toReal) \u2194\n    Summable fun i => \u2016f i\u2016 ^ p.toReal"}, {"line": "rw [if_neg hp.1.ne']", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p \u2227 p < \u22a4\nf : (i : \u03b1) \u2192 E i\n\u22a2 (if p = \u22a4 then BddAbove (Set.range fun i => \u2016f i\u2016) else Summable fun i => \u2016f i\u2016 ^ p.toReal) \u2194\n    Summable fun i => \u2016f i\u2016 ^ p.toReal"}, {"line": "rw [if_neg hp.2.ne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mem\u2113p : Mem\u2113p (0 : \u2200 i, E i) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  \u00b7 apply mem\u2113p_zero\n    simp\n  \u00b7 apply mem\u2113p_infty\n    simp only [norm_zero]\n    simp only [Pi.zero_apply]\n    exact bddAbove_singleton.mono Set.range_const_subset\n  \u00b7 apply mem\u2113p_gen\n    simp [Real.zero_rpow hp.ne', summable_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 Mem\u2113p 0 p"}, {"line": "rcases p.trichotomy with (rfl | rfl | hp)", "tactic_state": "case inl\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 Mem\u2113p 0 0\n---\ncase inr.inl\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 Mem\u2113p 0 \u22a4\n---\ncase inr.inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\n\u22a2 Mem\u2113p 0 p"}, {"line": "\u00b7 apply mem\u2113p_zero\n    simp", "tactic_state": "case inr.inl\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u22a2 Mem\u2113p 0 \u22a4\n---\ncase inr.inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\n\u22a2 Mem\u2113p 0 p"}, {"line": "\u00b7 apply mem\u2113p_infty\n    simp only [norm_zero]\n    simp only [Pi.zero_apply]\n    exact bddAbove_singleton.mono Set.range_const_subset", "tactic_state": "case inr.inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\n\u22a2 Mem\u2113p 0 p"}, {"line": "\u00b7 apply mem\u2113p_gen\n    simp [Real.zero_rpow hp.ne', summable_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem finset_sum {\u03b9} (s : Finset \u03b9) {f : \u03b9 \u2192 \u2200 i, E i} (hf : \u2200 i \u2208 s, Mem\u2113p (f i) p) :\n    Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p := by\n  haveI : DecidableEq \u03b9 := Classical.decEq _\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  \u00b7 simp only [zero_mem_\u2113p', Finset.sum_empty, imp_true_iff]\n  \u00b7 intro i s his ih hf\n    simp only [his]\n    simp only [Finset.sum_insert]\n    simp only [not_false_iff]\n    exact (hf i (s.mem_insert_self i)).add (ih fun j hj => hf j (Finset.mem_insert_of_mem hj))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nhf : \u2200 i \u2208 s, Mem\u2113p (f i) p\n\u22a2 Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p"}, {"line": "haveI : DecidableEq \u03b9 := Classical.decEq _", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nhf : \u2200 i \u2208 s, Mem\u2113p (f i) p\nthis : DecidableEq \u03b9\n\u22a2 Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p"}, {"line": "revert hf", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nthis : DecidableEq \u03b9\n\u22a2 (\u2200 i \u2208 s, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p"}, {"line": "refine Finset.induction_on s ?_ ?_", "tactic_state": "case refine_1\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nthis : DecidableEq \u03b9\n\u22a2 (\u2200 i \u2208 \u2205, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a => \u2211 i \u2208 \u2205, f i a) p\n---\ncase refine_2\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nthis : DecidableEq \u03b9\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    a \u2209 s \u2192\n      ((\u2200 i \u2208 s, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p) \u2192\n        (\u2200 i \u2208 insert a s, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a_3 => \u2211 i \u2208 insert a s, f i a_3) p"}, {"line": "\u00b7 simp only [zero_mem_\u2113p', Finset.sum_empty, imp_true_iff]", "tactic_state": "case refine_2\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\ns : Finset \u03b9\nf : \u03b9 \u2192 (i : \u03b1) \u2192 E i\nthis : DecidableEq \u03b9\n\u22a2 \u2200 (a : \u03b9) (s : Finset \u03b9),\n    a \u2209 s \u2192\n      ((\u2200 i \u2208 s, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a => \u2211 i \u2208 s, f i a) p) \u2192\n        (\u2200 i \u2208 insert a s, Mem\u2113p (f i) p) \u2192 Mem\u2113p (fun a_3 => \u2211 i \u2208 insert a s, f i a_3) p"}, {"line": "\u00b7 intro i s his ih hf\n    simp only [his]\n    simp only [Finset.sum_insert]\n    simp only [not_false_iff]\n    exact (hf i (s.mem_insert_self i)).add (ih fun j hj => hf j (Finset.mem_insert_of_mem hj))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeFn_sum {\u03b9 : Type*} (f : \u03b9 \u2192 lp E p) (s : Finset \u03b9) :\n    \u21d1(\u2211 i \u2208 s, f i) = \u2211 i \u2208 s, \u21d1(f i) := by\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\n\u03b9 : Type u_5\nf : \u03b9 \u2192 \u21a5(lp E p)\ns : Finset \u03b9\n\u22a2 \u2191(\u2211 i \u2208 s, f i) = \u2211 i \u2208 s, \u2191(f i)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLUB_norm [Nonempty \u03b1] (f : lp E \u221e) : IsLUB (Set.range fun i => \u2016f i\u2016) \u2016f\u2016 := by\n  rw [lp.norm_eq_ciSup]\n  exact isLUB_ciSup (lp.mem\u2113p f)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d : Nonempty \u03b1\nf : \u21a5(lp E \u22a4)\n\u22a2 IsLUB (Set.range fun i => \u2016\u2191f i\u2016) \u2016f\u2016"}, {"line": "rw [lp.norm_eq_ciSup]", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d\u00b9 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d : Nonempty \u03b1\nf : \u21a5(lp E \u22a4)\n\u22a2 IsLUB (Set.range fun i => \u2016\u2191f i\u2016) (\u2a06 i, \u2016\u2191f i\u2016)"}, {"line": "exact isLUB_ciSup (lp.mem\u2113p f)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq_tsum_rpow (hp : 0 < p.toReal) (f : lp E p) :\n    \u2016f\u2016 = (\u2211' i, \u2016f i\u2016 ^ p.toReal) ^ (1 / p.toReal) := by\n  dsimp [norm]\n  rw [ENNReal.toReal_pos_iff] at hp\n  rw [dif_neg hp.1.ne']\n  rw [if_neg hp.2.ne]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\nf : \u21a5(lp E p)\n\u22a2 \u2016f\u2016 = (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "dsimp [norm]", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p.toReal\nf : \u21a5(lp E p)\n\u22a2 (if hp : p = 0 then Eq.rec (motive := fun x x_1 => \u21a5(lp E x) \u2192 \u211d) (fun f => \u2191\u22ef.toFinset.card) \u22ef f\n    else if p = \u22a4 then \u2a06 i, \u2016\u2191f i\u2016 else (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)) =\n    (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "rw [ENNReal.toReal_pos_iff] at hp", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p \u2227 p < \u22a4\nf : \u21a5(lp E p)\n\u22a2 (if hp : p = 0 then Eq.rec (motive := fun x x_1 => \u21a5(lp E x) \u2192 \u211d) (fun f => \u2191\u22ef.toFinset.card) \u22ef f\n    else if p = \u22a4 then \u2a06 i, \u2016\u2191f i\u2016 else (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)) =\n    (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "rw [dif_neg hp.1.ne']", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nhp : 0 < p \u2227 p < \u22a4\nf : \u21a5(lp E p)\n\u22a2 (if p = \u22a4 then \u2a06 i, \u2016\u2191f i\u2016 else (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)) =\n    (\u2211' (i : \u03b1), \u2016\u2191f i\u2016 ^ p.toReal) ^ (1 / p.toReal)"}, {"line": "rw [if_neg hp.2.ne]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_le_of_forall_le {f : lp E \u221e} {C : \u211d} (hC : 0 \u2264 C) (hCf : \u2200 i, \u2016f i\u2016 \u2264 C) :\n    \u2016f\u2016 \u2264 C := by\n  cases isEmpty_or_nonempty \u03b1\n  \u00b7 simpa [eq_zero' f] using hC\n  \u00b7 exact norm_le_of_forall_le' C hCf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : \u21a5(lp E \u22a4)\nC : \u211d\nhC : 0 \u2264 C\nhCf : \u2200 (i : \u03b1), \u2016\u2191f i\u2016 \u2264 C\n\u22a2 \u2016f\u2016 \u2264 C"}, {"line": "cases isEmpty_or_nonempty \u03b1", "tactic_state": "case inl\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : \u21a5(lp E \u22a4)\nC : \u211d\nhC : 0 \u2264 C\nhCf : \u2200 (i : \u03b1), \u2016\u2191f i\u2016 \u2264 C\nh\u271d : IsEmpty \u03b1\n\u22a2 \u2016f\u2016 \u2264 C\n---\ncase inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : \u21a5(lp E \u22a4)\nC : \u211d\nhC : 0 \u2264 C\nhCf : \u2200 (i : \u03b1), \u2016\u2191f i\u2016 \u2264 C\nh\u271d : Nonempty \u03b1\n\u22a2 \u2016f\u2016 \u2264 C"}, {"line": "\u00b7 simpa [eq_zero' f] using hC", "tactic_state": "case inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\nf : \u21a5(lp E \u22a4)\nC : \u211d\nhC : 0 \u2264 C\nhCf : \u2200 (i : \u03b1), \u2016\u2191f i\u2016 \u2264 C\nh\u271d : Nonempty \u03b1\n\u22a2 \u2016f\u2016 \u2264 C"}, {"line": "\u00b7 exact norm_le_of_forall_le' C hCf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem\u2113p_of_tendsto {F : \u03b9 \u2192 lp E p} (hF : Bornology.IsBounded (Set.range F)) {f : \u2200 a, E a}\n    (hf : Tendsto (id fun i => F i : \u03b9 \u2192 \u2200 a, E a) l (\ud835\udcdd f)) : Mem\u2113p f p := by\n  obtain \u27e8C, hCF\u27e9 : \u2203 C, \u2200 k, \u2016F k\u2016 \u2264 C := hF.exists_norm_le.imp fun _ \u21a6 Set.forall_mem_range.1\n  rcases eq_top_or_lt_top p with (rfl | hp)\n  \u00b7 apply mem\u2113p_infty\n    use C\n    rintro _ \u27e8a, rfl\u27e9\n    exact norm_apply_le_of_tendsto (Eventually.of_forall hCF) hf a\n  \u00b7 apply mem\u2113p_gen'\n    exact sum_rpow_le_of_tendsto hp.ne (Eventually.of_forall hCF) hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function", "Filter", "scoped Topology uniformity"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in", "[NormedRing \ud835\udd5c] [NormedRing \ud835\udd5c']", "[\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, Module \ud835\udd5c' (E i)]", "[\u2200 i, IsBoundedSMul \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c' (E i)]", "(\ud835\udd5c E p)", "{\ud835\udd5c E p}", "[NormedDivisionRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "[NormedField \ud835\udd5c] [\u2200 i, NormedSpace \ud835\udd5c (E i)]", "[\u2200 i, StarAddMonoid (E i)] [\u2200 i, NormedStarGroup (E i)]", "[Star \ud835\udd5c] [NormedRing \ud835\udd5c]", "[\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)] [\u2200 i, StarModule \ud835\udd5c (E i)]", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NonUnitalNormedRing (B i)]", "[\u2200 i, StarRing (B i)] [\u2200 i, NormedStarGroup (B i)]", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NormedRing (B i)]", "[\u2200 i, NormOneClass (B i)]", "(B) in", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NormedCommRing (B i)] [\u2200 i, NormOneClass (B i)]", "{I : Type*} {B : I \u2192 Type*}", "[NormedField \ud835\udd5c] [\u2200 i, NormedRing (B i)] [\u2200 i, NormedAlgebra \ud835\udd5c (B i)]", "[\u2200 i, NormOneClass (B i)]", "(\ud835\udd5c B)", "{\ud835\udd5c B}", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "[DecidableEq \u03b1]", "(p E) in", "(\ud835\udd5c p E) in", "{\u03b9 : Type*} {l : Filter \u03b9} [Filter.NeBot l]", "[_i : Fact (1 \u2264 p)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d\u00b3 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b2 : (i : \u03b1) \u2192 StarAddMonoid (E i)\ninst\u271d\u00b9 : \u2200 (i : \u03b1), NormedStarGroup (E i)\ninst\u271d : DecidableEq \u03b1\n_i : Fact (1 \u2264 p)\n\u03b9 : Type u_11\nl : Filter \u03b9\nF : \u03b9 \u2192 \u21a5(lp E p)\nhF : Bornology.IsBounded (Set.range F)\nf : (a : \u03b1) \u2192 E a\nhf : Tendsto (id fun i => \u2191(F i)) l (nhds f)\n\u22a2 Mem\u2113p f p"}, {"line": "obtain \u27e8C, hCF\u27e9 : \u2203 C, \u2200 k, \u2016F k\u2016 \u2264 C := hF.exists_norm_le.imp fun _ \u21a6 Set.forall_mem_range.1", "tactic_state": "case intro\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d\u00b3 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b2 : (i : \u03b1) \u2192 StarAddMonoid (E i)\ninst\u271d\u00b9 : \u2200 (i : \u03b1), NormedStarGroup (E i)\ninst\u271d : DecidableEq \u03b1\n_i : Fact (1 \u2264 p)\n\u03b9 : Type u_11\nl : Filter \u03b9\nF : \u03b9 \u2192 \u21a5(lp E p)\nhF : Bornology.IsBounded (Set.range F)\nf : (a : \u03b1) \u2192 E a\nhf : Tendsto (id fun i => \u2191(F i)) l (nhds f)\nC : \u211d\nhCF : \u2200 (k : \u03b9), \u2016F k\u2016 \u2264 C\n\u22a2 Mem\u2113p f p"}, {"line": "rcases eq_top_or_lt_top p with (rfl | hp)", "tactic_state": "case intro.inl\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\ninst\u271d\u00b3 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b2 : (i : \u03b1) \u2192 StarAddMonoid (E i)\ninst\u271d\u00b9 : \u2200 (i : \u03b1), NormedStarGroup (E i)\ninst\u271d : DecidableEq \u03b1\n\u03b9 : Type u_11\nl : Filter \u03b9\nf : (a : \u03b1) \u2192 E a\nC : \u211d\n_i : Fact (1 \u2264 \u22a4)\nF : \u03b9 \u2192 \u21a5(lp E \u22a4)\nhF : Bornology.IsBounded (Set.range F)\nhf : Tendsto (id fun i => \u2191(F i)) l (nhds f)\nhCF : \u2200 (k : \u03b9), \u2016F k\u2016 \u2264 C\n\u22a2 Mem\u2113p f \u22a4\n---\ncase intro.inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d\u00b3 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b2 : (i : \u03b1) \u2192 StarAddMonoid (E i)\ninst\u271d\u00b9 : \u2200 (i : \u03b1), NormedStarGroup (E i)\ninst\u271d : DecidableEq \u03b1\n_i : Fact (1 \u2264 p)\n\u03b9 : Type u_11\nl : Filter \u03b9\nF : \u03b9 \u2192 \u21a5(lp E p)\nhF : Bornology.IsBounded (Set.range F)\nf : (a : \u03b1) \u2192 E a\nhf : Tendsto (id fun i => \u2191(F i)) l (nhds f)\nC : \u211d\nhCF : \u2200 (k : \u03b9), \u2016F k\u2016 \u2264 C\nhp : p < \u22a4\n\u22a2 Mem\u2113p f p"}, {"line": "\u00b7 apply mem\u2113p_infty\n    use C\n    rintro _ \u27e8a, rfl\u27e9\n    exact norm_apply_le_of_tendsto (Eventually.of_forall hCF) hf a", "tactic_state": "case intro.inr\n\u03b1 : Type u_3\nE : \u03b1 \u2192 Type u_4\np : ENNReal\ninst\u271d\u00b3 : (i : \u03b1) \u2192 NormedAddCommGroup (E i)\ninst\u271d\u00b2 : (i : \u03b1) \u2192 StarAddMonoid (E i)\ninst\u271d\u00b9 : \u2200 (i : \u03b1), NormedStarGroup (E i)\ninst\u271d : DecidableEq \u03b1\n_i : Fact (1 \u2264 p)\n\u03b9 : Type u_11\nl : Filter \u03b9\nF : \u03b9 \u2192 \u21a5(lp E p)\nhF : Bornology.IsBounded (Set.range F)\nf : (a : \u03b1) \u2192 E a\nhf : Tendsto (id fun i => \u2191(F i)) l (nhds f)\nC : \u211d\nhCF : \u2200 (k : \u03b9), \u2016F k\u2016 \u2264 C\nhp : p < \u22a4\n\u22a2 Mem\u2113p f p"}, {"line": "\u00b7 apply mem\u2113p_gen'\n    exact sum_rpow_le_of_tendsto hp.ne (Eventually.of_forall hCF) hf", "tactic_state": "No Goals!"}]}
{"declaration": "lemma LipschitzWith.uniformly_bounded [PseudoMetricSpace \u03b1] (g : \u03b1 \u2192 \u03b9 \u2192 \u211d) {K : \u211d\u22650}\n    (hg : \u2200 i, LipschitzWith K (g \u00b7 i)) (a\u2080 : \u03b1) (hga\u2080b : Mem\u2113p (g a\u2080) \u221e) (a : \u03b1) :\n    Mem\u2113p (g a) \u221e := by\n  rcases hga\u2080b with \u27e8M, hM\u27e9\n  use \u2191K * dist a a\u2080 + M\n  rintro - \u27e8i, rfl\u27e9\n  calc\n    |g a i| = |g a i - g a\u2080 i + g a\u2080 i| := by simp\n    _ \u2264 |g a i - g a\u2080 i| + |g a\u2080 i| := abs_add _ _\n    _ \u2264 \u2191K * dist a a\u2080 + M := by\n        gcongr\n        \u00b7 exact lipschitzWith_iff_dist_le_mul.1 (hg i) a a\u2080\n        \u00b7 exact hM \u27e8i, rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Lp/lpSpace.lean", "context": {"open": ["scoped NNReal ENNReal Function", "Filter", "scoped Topology uniformity", "ENNReal lp"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} {\u03b1 : Type*} {E : \u03b1 \u2192 Type*} {p q : \u211d\u22650\u221e} [\u2200 i, NormedAddCommGroup (E i)]", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "(E p)", "{E p}", "(p E) in", "[NormedRing \ud835\udd5c] [NormedRing \ud835\udd5c']", "[\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, Module \ud835\udd5c' (E i)]", "[\u2200 i, IsBoundedSMul \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c' (E i)]", "(\ud835\udd5c E p)", "{\ud835\udd5c E p}", "[NormedDivisionRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "[NormedField \ud835\udd5c] [\u2200 i, NormedSpace \ud835\udd5c (E i)]", "[\u2200 i, StarAddMonoid (E i)] [\u2200 i, NormedStarGroup (E i)]", "[Star \ud835\udd5c] [NormedRing \ud835\udd5c]", "[\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)] [\u2200 i, StarModule \ud835\udd5c (E i)]", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NonUnitalNormedRing (B i)]", "[\u2200 i, StarRing (B i)] [\u2200 i, NormedStarGroup (B i)]", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NormedRing (B i)]", "[\u2200 i, NormOneClass (B i)]", "(B) in", "{I : Type*} {B : I \u2192 Type*} [\u2200 i, NormedCommRing (B i)] [\u2200 i, NormOneClass (B i)]", "{I : Type*} {B : I \u2192 Type*}", "[NormedField \ud835\udd5c] [\u2200 i, NormedRing (B i)] [\u2200 i, NormedAlgebra \ud835\udd5c (B i)]", "[\u2200 i, NormOneClass (B i)]", "(\ud835\udd5c B)", "{\ud835\udd5c B}", "[NormedRing \ud835\udd5c] [\u2200 i, Module \ud835\udd5c (E i)] [\u2200 i, IsBoundedSMul \ud835\udd5c (E i)]", "[DecidableEq \u03b1]", "(p E) in", "(\ud835\udd5c p E) in", "{\u03b9 : Type*} {l : Filter \u03b9} [Filter.NeBot l]", "[_i : Fact (1 \u2264 p)]", "[\u2200 a, CompleteSpace (E a)]", "{\u03b9 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\n\u03b9 : Type u_11\ninst\u271d : PseudoMetricSpace \u03b1\ng : \u03b1 \u2192 \u03b9 \u2192 \u211d\nK : NNReal\nhg : \u2200 (i : \u03b9), LipschitzWith K fun x => g x i\na\u2080 : \u03b1\nhga\u2080b : Mem\u2113p (g a\u2080) \u22a4\na : \u03b1\n\u22a2 Mem\u2113p (g a) \u22a4"}, {"line": "rcases hga\u2080b with \u27e8M, hM\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\n\u03b9 : Type u_11\ninst\u271d : PseudoMetricSpace \u03b1\ng : \u03b1 \u2192 \u03b9 \u2192 \u211d\nK : NNReal\nhg : \u2200 (i : \u03b9), LipschitzWith K fun x => g x i\na\u2080 a : \u03b1\nM : \u211d\nhM : M \u2208 upperBounds (Set.range fun i => \u2016g a\u2080 i\u2016)\n\u22a2 Mem\u2113p (g a) \u22a4"}, {"line": "use \u2191K * dist a a\u2080 + M", "tactic_state": "case h\n\u03b1 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\n\u03b9 : Type u_11\ninst\u271d : PseudoMetricSpace \u03b1\ng : \u03b1 \u2192 \u03b9 \u2192 \u211d\nK : NNReal\nhg : \u2200 (i : \u03b9), LipschitzWith K fun x => g x i\na\u2080 a : \u03b1\nM : \u211d\nhM : M \u2208 upperBounds (Set.range fun i => \u2016g a\u2080 i\u2016)\n\u22a2 \u2191K * sorry + M \u2208 upperBounds (Set.range fun i => \u2016g a i\u2016)"}, {"line": "rintro - \u27e8i, rfl\u27e9", "tactic_state": "case h.intro\n\u03b1 : Type u_3\ninst\u271d\u00b9 : DecidableEq \u03b1\n\u03b9 : Type u_11\ninst\u271d : PseudoMetricSpace \u03b1\ng : \u03b1 \u2192 \u03b9 \u2192 \u211d\nK : NNReal\nhg : \u2200 (i : \u03b9), LipschitzWith K fun x => g x i\na\u2080 a : \u03b1\nM : \u211d\nhM : M \u2208 upperBounds (Set.range fun i => \u2016g a\u2080 i\u2016)\ni : \u03b9\n\u22a2 (fun i => \u2016g a i\u2016) i \u2264 \u2191K * sorry + M"}, {"line": "calc\n    |g a i| = |g a i - g a\u2080 i + g a\u2080 i| := by simp\n    _ \u2264 |g a i - g a\u2080 i| + |g a\u2080 i| := abs_add _ _\n    _ \u2264 \u2191K * dist a a\u2080 + M := by\n        gcongr\n        \u00b7 exact lipschitzWith_iff_dist_le_mul.1 (hg i) a a\u2080\n        \u00b7 exact hM \u27e8i, rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma NormedSpace.cobounded_neBot : NeBot (cobounded E) := by\n  rw [neBot_iff]\n  rw [Ne]\n  rw [cobounded_eq_bot_iff]\n  rw [\u2190 isBounded_univ]\n  exact NormedSpace.unbounded_univ \ud835\udd5c E\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Basic.lean", "context": {"open": ["Filter Metric Function Set Topology Bornology", "scoped NNReal ENNReal uniformity", "NormedField"], "variables": ["{\ud835\udd5c \ud835\udd5c' E F \u03b1 : Type*}", "[NormedField \ud835\udd5c] [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]", "[NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c) in", "{S \ud835\udd5c R E : Type*} [SMul \ud835\udd5c R] [NormedField \ud835\udd5c] [Ring R] [SeminormedAddCommGroup E]", "[NormedSpace \ud835\udd5c E] [Module R E] [IsScalarTower \ud835\udd5c R E] [SetLike S E] [AddSubgroupClass S E]", "[SMulMemClass S R E] (s : S)", "(\ud835\udd5c E)", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [Nontrivial E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : Nontrivial E\n\u22a2 (cobounded E).NeBot"}, {"line": "rw [neBot_iff]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : Nontrivial E\n\u22a2 cobounded E \u2260 \u22a5"}, {"line": "rw [Ne]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : Nontrivial E\n\u22a2 \u00accobounded E = \u22a5"}, {"line": "rw [cobounded_eq_bot_iff]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : Nontrivial E\n\u22a2 \u00acBoundedSpace E"}, {"line": "rw [\u2190 isBounded_univ]", "tactic_state": "E : Type u_3\ninst\u271d\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : Nontrivial E\n\u22a2 \u00acBornology.IsBounded univ"}, {"line": "exact NormedSpace.unbounded_univ \ud835\udd5c E", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_algebraMap' [NormOneClass \ud835\udd5c'] (x : \ud835\udd5c) : \u2016algebraMap \ud835\udd5c \ud835\udd5c' x\u2016 = \u2016x\u2016 := by\n  rw [norm_algebraMap]\n  rw [norm_one]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Basic.lean", "context": {"open": ["Filter Metric Function Set Topology Bornology", "scoped NNReal ENNReal uniformity", "NormedField"], "variables": ["{\ud835\udd5c \ud835\udd5c' E F \u03b1 : Type*}", "[NormedField \ud835\udd5c] [SeminormedAddCommGroup E] [SeminormedAddCommGroup F]", "[NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c) in", "{S \ud835\udd5c R E : Type*} [SMul \ud835\udd5c R] [NormedField \ud835\udd5c] [Ring R] [SeminormedAddCommGroup E]", "[NormedSpace \ud835\udd5c E] [Module R E] [IsScalarTower \ud835\udd5c R E] [SetLike S E] [AddSubgroupClass S E]", "[SMulMemClass S R E] (s : S)", "(\ud835\udd5c E)", "[NontriviallyNormedField \ud835\udd5c] [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] [Nontrivial E]", "(\ud835\udd5c E)", "[NormedField \ud835\udd5c] [Infinite \ud835\udd5c] [NormedAddCommGroup E] [Nontrivial E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c')", "[NormedField \ud835\udd5c] [SeminormedRing \ud835\udd5c'] [NormedAlgebra \ud835\udd5c \ud835\udd5c']"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : Infinite \ud835\udd5c\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormOneClass \ud835\udd5c'\nx : \ud835\udd5c\n\u22a2 \u2016(algebraMap \ud835\udd5c \ud835\udd5c') x\u2016 = \u2016x\u2016"}, {"line": "rw [norm_algebraMap]", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : Infinite \ud835\udd5c\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormOneClass \ud835\udd5c'\nx : \ud835\udd5c\n\u22a2 \u2016x\u2016 * \u20161\u2016 = \u2016x\u2016"}, {"line": "rw [norm_one]", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : Infinite \ud835\udd5c\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormOneClass \ud835\udd5c'\nx : \ud835\udd5c\n\u22a2 \u2016x\u2016 * 1 = \u2016x\u2016\n---\n\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : Infinite \ud835\udd5c\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormOneClass \ud835\udd5c'\nx : \ud835\udd5c\n\u22a2 NormOneClass \ud835\udd5c'"}, {"line": "rw [mul_one]", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : Infinite \ud835\udd5c\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : SeminormedRing \ud835\udd5c'\ninst\u271d\u00b9 : NormedAlgebra \ud835\udd5c \ud835\udd5c'\ninst\u271d : NormOneClass \ud835\udd5c'\nx : \ud835\udd5c\n\u22a2 NormOneClass \ud835\udd5c'"}]}
{"declaration": "theorem convexOn_dist (z : E) (hs : Convex \u211d s) : ConvexOn \u211d s fun z' => dist z' z := by\n  simpa [dist_eq_norm, preimage_preimage] using\n    (convexOn_norm (hs.translate (-z))).comp_affineMap (AffineMap.id \u211d E - AffineMap.const \u211d E z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Convex.lean", "context": {"open": ["Metric Set"], "variables": ["{E : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\nz : E\nhs : Convex \u211d s\n\u22a2 ConvexOn \u211d s fun z' => dist z' z"}, {"line": "simpa [dist_eq_norm, preimage_preimage] using\n    (convexOn_norm (hs.translate (-z))).comp_affineMap (AffineMap.id \u211d E - AffineMap.const \u211d E z)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convex_ball (a : E) (r : \u211d) : Convex \u211d (Metric.ball a r) := by\n  simpa only [Metric.ball,sep_univ] using (convexOn_univ_dist a).convex_lt r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Convex.lean", "context": {"open": ["Metric Set"], "variables": ["{E : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na : E\nr : \u211d\n\u22a2 Convex \u211d (ball a r)"}, {"line": "simpa only [Metric.ball,sep_univ] using (convexOn_univ_dist a).convex_lt r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convex_closedBall (a : E) (r : \u211d) : Convex \u211d (Metric.closedBall a r) := by\n  simpa only [Metric.closedBall,sep_univ] using (convexOn_univ_dist a).convex_le r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Convex.lean", "context": {"open": ["Metric Set"], "variables": ["{E : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\na : E\nr : \u211d\n\u22a2 Convex \u211d (closedBall a r)"}, {"line": "simpa only [Metric.closedBall,sep_univ] using (convexOn_univ_dist a).convex_le r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem convexHull_diam (s : Set E) : Metric.diam (convexHull \u211d s) = Metric.diam s := by\n  simp only [Metric.diam]\n  simp only [convexHull_ediam]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Convex.lean", "context": {"open": ["Metric Set"], "variables": ["{E : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\n\u22a2 diam ((convexHull \u211d) s) = diam s"}, {"line": "simp only [Metric.diam]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\n\u22a2 (EMetric.diam ((convexHull \u211d) s)).toReal = (EMetric.diam s).toReal"}, {"line": "simp only [convexHull_ediam]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBounded_convexHull {s : Set E} :\n    Bornology.IsBounded (convexHull \u211d s) \u2194 Bornology.IsBounded s := by\n  simp only [Metric.isBounded_iff_ediam_ne_top]\n  simp only [convexHull_ediam]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Convex.lean", "context": {"open": ["Metric Set"], "variables": ["{E : Type*}", "[SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\n\u22a2 Bornology.IsBounded ((convexHull \u211d) s) \u2194 Bornology.IsBounded s"}, {"line": "simp only [Metric.isBounded_iff_ediam_ne_top]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\ns : Set E\n\u22a2 EMetric.diam ((convexHull \u211d) s) \u2260 \u22a4 \u2194 EMetric.diam s \u2260 \u22a4"}, {"line": "simp only [convexHull_ediam]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polar_singleton {a : E} : polar \ud835\udd5c {a} = { x | \u2016x a\u2016 \u2264 1 } := by\n  simp only [polar]\n  simp only [LinearMap.polar_singleton]\n  simp only [LinearMap.flip_apply]\n  simp only [dualPairing_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Dual.lean", "context": {"open": ["Topology Bornology", "Metric Set NormedSpace"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "(E : Type*) [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(F : Type*) [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c : Type v) [RCLike \ud835\udd5c] {E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c}", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\n\u22a2 polar \ud835\udd5c {a} = {x | \u2016x a\u2016 \u2264 1}"}, {"line": "simp only [polar]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\n\u22a2 (dualPairing \ud835\udd5c E).flip.polar {a} = {x | \u2016x a\u2016 \u2264 1}"}, {"line": "simp only [LinearMap.polar_singleton]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\n\u22a2 {y | \u2016((dualPairing \ud835\udd5c E).flip a) y\u2016 \u2264 1} = {x | \u2016x a\u2016 \u2264 1}"}, {"line": "simp only [LinearMap.flip_apply]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\n\u22a2 {y | \u2016((dualPairing \ud835\udd5c E) y) a\u2016 \u2264 1} = {x | \u2016x a\u2016 \u2264 1}"}, {"line": "simp only [dualPairing_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mem_polar_singleton {a : E} (y : Dual \ud835\udd5c E) : y \u2208 polar \ud835\udd5c {a} \u2194 \u2016y a\u2016 \u2264 1 := by\n  simp only [polar_singleton]\n  simp only [mem_setOf_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/Dual.lean", "context": {"open": ["Topology Bornology", "Metric Set NormedSpace"], "variables": ["(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "(E : Type*) [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(F : Type*) [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F]", "(\ud835\udd5c : Type v) [RCLike \ud835\udd5c] {E : Type u} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "(\ud835\udd5c : Type*) [NontriviallyNormedField \ud835\udd5c]", "{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{\ud835\udd5c}", "(\ud835\udd5c)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\ny : Dual \ud835\udd5c E\n\u22a2 y \u2208 polar \ud835\udd5c {a} \u2194 \u2016y a\u2016 \u2264 1"}, {"line": "simp only [polar_singleton]", "tactic_state": "\ud835\udd5c : Type u_4\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd5c\nE : Type u_5\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\na : E\ny : Dual \ud835\udd5c E\n\u22a2 y \u2208 {x | \u2016x a\u2016 \u2264 1} \u2194 \u2016y a\u2016 \u2264 1"}, {"line": "simp only [mem_setOf_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lipschitzExtensionConstant_pos (E' : Type*) [NormedAddCommGroup E'] [NormedSpace \u211d E']\n    [FiniteDimensional \u211d E'] : 0 < lipschitzExtensionConstant E' := by\n  rw [lipschitzExtensionConstant]\n  exact zero_lt_one.trans_le (le_max_right _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Module/FiniteDimension.lean", "context": {"open": ["Asymptotics Filter Module Metric Module NNReal Set TopologicalSpace Topology", "LinearMap", "AffineMap"], "variables": ["{F E\u2081 : Type*} [SeminormedAddCommGroup F] [NormedAddCommGroup E\u2081]", "{R\u2081 : Type*} [Field R\u2081] [Module R\u2081 E\u2081] [Module R\u2081 F] [FiniteDimensional R\u2081 E\u2081]", "{\ud835\udd5c : Type*} {V\u2081 V\u2082 : Type*} {P\u2081 P\u2082 : Type*} [NormedField \ud835\udd5c] [NormedAddCommGroup V\u2081]", "[FiniteDimensional \ud835\udd5c V\u2081] [FiniteDimensional \ud835\udd5c V\u2082]", "{\ud835\udd5c : Type u} [NontriviallyNormedField \ud835\udd5c] {E : Type v} [NormedAddCommGroup E]", "{PE PF : Type*} [MetricSpace PE] [NormedAddTorsor E PE] [MetricSpace PF]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E' : Type u_11\ninst\u271d\u00b2 : NormedAddCommGroup E'\ninst\u271d\u00b9 : NormedSpace \u211d E'\ninst\u271d : FiniteDimensional \u211d E'\n\u22a2 0 < lipschitzExtensionConstant E'"}, {"line": "rw [lipschitzExtensionConstant]", "tactic_state": "E' : Type u_11\ninst\u271d\u00b2 : NormedAddCommGroup E'\ninst\u271d\u00b9 : NormedSpace \u211d E'\ninst\u271d : FiniteDimensional \u211d E'\n\u22a2 0 <\n    let A := (Basis.ofVectorSpace \u211d E').equivFun.toContinuousLinearEquiv;\n    max (\u2016\u2191A.symm\u2016\u208a * \u2016\u2191A\u2016\u208a) 1"}, {"line": "exact zero_lt_one.trans_le (le_max_right _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma equivRange_symm_toLinearEquiv (hinj : Injective f) (hclo : IsClosed (range f)) :\n    (f.equivRange hinj hclo).symm.toLinearEquiv =\n      (LinearEquiv.ofInjective f.toLinearMap hinj).symm := by\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Operator/Banach.lean", "context": {"open": ["Function Metric Set Filter Finset Topology NNReal", "LinearMap (range ker)"], "variables": ["{\ud835\udd5c \ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c'] {\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "{F : Type*} [NormedAddCommGroup F] [NormedSpace \ud835\udd5c' F] (f : E \u2192SL[\u03c3] F)", "{\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c} [RingHomInvPair \u03c3 \u03c3'] [RingHomIsometric \u03c3] [RingHomIsometric \u03c3']", "[CompleteSpace F]", "[CompleteSpace E]", "[CompleteSpace E] [RingHomInvPair \u03c3' \u03c3]", "[CompleteSpace E] [RingHomInvPair \u03c3' \u03c3] {f : E \u2192SL[\u03c3] F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\n\ud835\udd5c' : Type u_2\ninst\u271d\u00b9\u2074 : NontriviallyNormedField \ud835\udd5c\ninst\u271d\u00b9\u00b3 : NontriviallyNormedField \ud835\udd5c'\n\u03c3 : \ud835\udd5c \u2192+* \ud835\udd5c'\nE : Type u_3\ninst\u271d\u00b9\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : NormedSpace \ud835\udd5c E\nF : Type u_4\ninst\u271d\u00b9\u2070 : NormedAddCommGroup F\ninst\u271d\u2079 : NormedSpace \ud835\udd5c' F\n\u03c3' : \ud835\udd5c' \u2192+* \ud835\udd5c\ninst\u271d\u2078 : RingHomInvPair \u03c3 \u03c3'\ninst\u271d\u2077 : RingHomIsometric \u03c3\ninst\u271d\u2076 : RingHomIsometric \u03c3'\ninst\u271d\u2075 : CompleteSpace F\ninst\u271d\u2074 inst\u271d\u00b3 : CompleteSpace E\ninst\u271d\u00b2 : RingHomInvPair \u03c3' \u03c3\ninst\u271d\u00b9 : CompleteSpace E\ninst\u271d : RingHomInvPair \u03c3' \u03c3\nf : E \u2192SL[\u03c3] F\nhinj : Injective \u21d1f\nhclo : IsClosed (Set.range \u21d1f)\n\u22a2 (ContinuousLinearMap.equivRange hinj hclo).symm.toLinearEquiv = (LinearEquiv.ofInjective (\u2191f) hinj).symm"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sub (hf : IsBoundedLinearMap \ud835\udd5c f) (hg : IsBoundedLinearMap \ud835\udd5c g) :\n    IsBoundedLinearMap \ud835\udd5c fun e => f e - g e := by simpa [sub_eq_add_neg] using add hf (neg hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Operator/BoundedLinearMaps.lean", "context": {"open": ["Topology", "Filter (Tendsto)", "Metric ContinuousLinearMap"], "variables": ["{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] {E : Type*} [SeminormedAddCommGroup E]", "{f g : E \u2192 F}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "hf : sorry\nhg : sorry\n\u22a2 sorry"}, {"line": "simpa [sub_eq_add_neg] using add hf (neg hg)", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsUpperSet.cthickening' (hs : IsUpperSet s) (\u03b5 : \u211d) :\n    IsUpperSet (cthickening \u03b5 s) := by\n  rw [cthickening_eq_iInter_thickening'']\n  exact isUpperSet_iInter\u2082 fun \u03b4 _ => hs.thickening' _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : NormedCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\ns : Set \u03b1\nhs : IsUpperSet s\n\u03b5 : \u211d\n\u22a2 IsUpperSet (cthickening \u03b5 s)"}, {"line": "rw [cthickening_eq_iInter_thickening'']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : NormedCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\ns : Set \u03b1\nhs : IsUpperSet s\n\u03b5 : \u211d\n\u22a2 IsUpperSet (\u22c2 \u03b5_1, \u22c2 (_ : max 0 \u03b5 < \u03b5_1), thickening \u03b5_1 s)"}, {"line": "exact isUpperSet_iInter\u2082 fun \u03b4 _ => hs.thickening' _", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem IsLowerSet.cthickening' (hs : IsLowerSet s) (\u03b5 : \u211d) :\n    IsLowerSet (cthickening \u03b5 s) := by\n  rw [cthickening_eq_iInter_thickening'']\n  exact isLowerSet_iInter\u2082 fun \u03b4 _ => hs.thickening' _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : NormedCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\ns : Set \u03b1\nhs : IsLowerSet s\n\u03b5 : \u211d\n\u22a2 IsLowerSet (cthickening \u03b5 s)"}, {"line": "rw [cthickening_eq_iInter_thickening'']", "tactic_state": "\u03b1 : Type u_1\ninst\u271d\u00b2 : NormedCommGroup \u03b1\ninst\u271d\u00b9 : PartialOrder \u03b1\ninst\u271d : IsOrderedMonoid \u03b1\ns : Set \u03b1\nhs : IsLowerSet s\n\u03b5 : \u211d\n\u22a2 IsLowerSet (\u22c2 \u03b5_1, \u22c2 (_ : max 0 \u03b5 < \u03b5_1), thickening \u03b5_1 s)"}, {"line": "exact isLowerSet_iInter\u2082 fun \u03b4 _ => hs.thickening' _", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_mono_left_pi : MonotoneOn (dist \u00b7 y) (Ici y) := by\n  refine fun y\u2081 hy\u2081 y\u2082 hy\u2082 hy \u21a6 NNReal.coe_le_coe.2 (Finset.sup_mono_fun fun i _ \u21a6 ?_)\n  rw [Real.nndist_eq]\n  rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039y \u2264 _\u203a i : y i \u2264 y\u2081 i))]\n  rw [Real.nndist_eq]\n  rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039y \u2264 _\u203a i : y i \u2264 y\u2082 i))]\n  exact Real.toNNReal_mono (sub_le_sub_right (hy _) _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}", "[Finite \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {x y : \u03b9 \u2192 \u211d}", "[Fintype \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {a\u2081 a\u2082 b\u2081 b\u2082 x y : \u03b9 \u2192 \u211d} {\u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny : \u03b9 \u2192 \u211d\n\u22a2 MonotoneOn (fun x => dist x y) (Ici y)"}, {"line": "refine fun y\u2081 hy\u2081 y\u2082 hy\u2082 hy \u21a6 NNReal.coe_le_coe.2 (Finset.sup_mono_fun fun i _ \u21a6 ?_)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Ici y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Ici y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 nndist (y\u2081 i) (y i) \u2264 nndist (y\u2082 i) (y i)"}, {"line": "rw [Real.nndist_eq]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Ici y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Ici y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 Real.nnabs (y\u2081 i - y i) \u2264 nndist (y\u2082 i) (y i)"}, {"line": "rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039y \u2264 _\u203a i : y i \u2264 y\u2081 i))]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Ici y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Ici y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y\u2081 i - y i).toNNReal \u2264 nndist (y\u2082 i) (y i)"}, {"line": "rw [Real.nndist_eq]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Ici y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Ici y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y\u2081 i - y i).toNNReal \u2264 Real.nnabs (y\u2082 i - y i)"}, {"line": "rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039y \u2264 _\u203a i : y i \u2264 y\u2082 i))]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Ici y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Ici y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y\u2081 i - y i).toNNReal \u2264 (y\u2082 i - y i).toNNReal"}, {"line": "exact Real.toNNReal_mono (sub_le_sub_right (hy _) _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_mono_right_pi : MonotoneOn (dist x) (Ici x) := by\n  simpa only [dist_comm _ x] using dist_mono_left_pi (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}", "[Finite \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {x y : \u03b9 \u2192 \u211d}", "[Fintype \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {a\u2081 a\u2082 b\u2081 b\u2082 x y : \u03b9 \u2192 \u211d} {\u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\nx : \u03b9 \u2192 \u211d\n\u22a2 MonotoneOn (dist x) (Ici x)"}, {"line": "simpa only [dist_comm _ x] using dist_mono_left_pi (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_anti_left_pi : AntitoneOn (dist \u00b7 y) (Iic y) := by\n  refine fun y\u2081 hy\u2081 y\u2082 hy\u2082 hy \u21a6 NNReal.coe_le_coe.2 (Finset.sup_mono_fun fun i _ \u21a6 ?_)\n  rw [Real.nndist_eq']\n  rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039_ \u2264 y\u203a i : y\u2082 i \u2264 y i))]\n  rw [Real.nndist_eq']\n  rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039_ \u2264 y\u203a i : y\u2081 i \u2264 y i))]\n  exact Real.toNNReal_mono (sub_le_sub_left (hy _) _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}", "[Finite \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {x y : \u03b9 \u2192 \u211d}", "[Fintype \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {a\u2081 a\u2082 b\u2081 b\u2082 x y : \u03b9 \u2192 \u211d} {\u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny : \u03b9 \u2192 \u211d\n\u22a2 AntitoneOn (fun x => dist x y) (Iic y)"}, {"line": "refine fun y\u2081 hy\u2081 y\u2082 hy\u2082 hy \u21a6 NNReal.coe_le_coe.2 (Finset.sup_mono_fun fun i _ \u21a6 ?_)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Iic y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Iic y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 nndist (y\u2082 i) (y i) \u2264 nndist (y\u2081 i) (y i)"}, {"line": "rw [Real.nndist_eq']", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Iic y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Iic y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 Real.nnabs (y i - y\u2082 i) \u2264 nndist (y\u2081 i) (y i)"}, {"line": "rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039_ \u2264 y\u203a i : y\u2082 i \u2264 y i))]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Iic y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Iic y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y i - y\u2082 i).toNNReal \u2264 nndist (y\u2081 i) (y i)"}, {"line": "rw [Real.nndist_eq']", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Iic y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Iic y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y i - y\u2082 i).toNNReal \u2264 Real.nnabs (y i - y\u2081 i)"}, {"line": "rw [Real.nnabs_of_nonneg (sub_nonneg_of_le (\u2039_ \u2264 y\u203a i : y\u2081 i \u2264 y i))]", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\ny y\u2081 : \u03b9 \u2192 \u211d\nhy\u2081 : y\u2081 \u2208 Iic y\ny\u2082 : \u03b9 \u2192 \u211d\nhy\u2082 : y\u2082 \u2208 Iic y\nhy : y\u2081 \u2264 y\u2082\ni : \u03b9\nx\u271d : i \u2208 Finset.univ\n\u22a2 (y i - y\u2082 i).toNNReal \u2264 (y i - y\u2081 i).toNNReal"}, {"line": "exact Real.toNNReal_mono (sub_le_sub_left (hy _) _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma dist_anti_right_pi : AntitoneOn (dist x) (Iic x) := by\n  simpa only [dist_comm] using dist_anti_left_pi (y := x)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Order/UpperLower.lean", "context": {"open": ["Bornology Function Metric Set", "scoped Pointwise"], "variables": ["{\u03b1 \u03b9 : Type*}", "[NormedCommGroup \u03b1] [PartialOrder \u03b1] [IsOrderedMonoid \u03b1] {s : Set \u03b1}", "[Finite \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {x y : \u03b9 \u2192 \u211d}", "[Fintype \u03b9] {s : Set (\u03b9 \u2192 \u211d)} {a\u2081 a\u2082 b\u2081 b\u2082 x y : \u03b9 \u2192 \u211d} {\u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_2\ninst\u271d\u00b9 : Finite \u03b9\ninst\u271d : Fintype \u03b9\nx : \u03b9 \u2192 \u211d\n\u22a2 AntitoneOn (dist x) (Iic x)"}, {"line": "simpa only [dist_comm] using dist_anti_left_pi (y := x)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Finset.norm_prod_le {\u03b1 : Type*} [NormedCommRing \u03b1] [NormOneClass \u03b1] (s : Finset \u03b9)\n    (f : \u03b9 \u2192 \u03b1) : \u2016\u220f i \u2208 s, f i\u2016 \u2264 \u220f i \u2208 s, \u2016f i\u2016 := by\n  rcases s with \u27e8\u27e8l\u27e9, hl\u27e9\n  simpa using (l.map f).norm_prod_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[SeminormedAddCommGroup G] [One G] [NormOneClass G]", "[NonUnitalSeminormedRing \u03b1] {a a\u2081 a\u2082 b c : \u03b1}", "[SeminormedRing \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b9 : NormedCommRing \u03b1\ninst\u271d : NormOneClass \u03b1\ns : Finset \u03b9\nf : \u03b9 \u2192 \u03b1\n\u22a2 \u2016\u220f i \u2208 s, f i\u2016 \u2264 \u220f i \u2208 s, \u2016f i\u2016"}, {"line": "rcases s with \u27e8\u27e8l\u27e9, hl\u27e9", "tactic_state": "case mk.mk\n\u03b9 : Type u_4\n\u03b1 : Type u_5\ninst\u271d\u00b9 : NormedCommRing \u03b1\ninst\u271d : NormOneClass \u03b1\nf : \u03b9 \u2192 \u03b1\nval\u271d : Multiset \u03b9\nl : List \u03b9\nhl : Multiset.Nodup (Quot.mk (\u21d1(List.isSetoid \u03b9)) l)\n\u22a2 \u2016\u220f i \u2208 { val := Quot.mk (\u21d1(List.isSetoid \u03b9)) l, nodup := hl }, f i\u2016 \u2264\n    \u220f i \u2208 { val := Quot.mk (\u21d1(List.isSetoid \u03b9)) l, nodup := hl }, \u2016f i\u2016"}, {"line": "simpa using (l.map f).norm_prod_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_pow_le' (a : \u03b1) {n : \u2115} (h : 0 < n) : \u2016a ^ n\u2016 \u2264 \u2016a\u2016 ^ n := by\n  simpa only [NNReal.coe_pow,coe_nnnorm] using NNReal.coe_mono (nnnorm_pow_le' a h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[SeminormedAddCommGroup G] [One G] [NormOneClass G]", "[NonUnitalSeminormedRing \u03b1] {a a\u2081 a\u2082 b c : \u03b1}", "[SeminormedRing \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : NonUnitalSeminormedRing \u03b1\ninst\u271d : SeminormedRing \u03b1\na : \u03b1\nn : \u2115\nh : 0 < n\n\u22a2 \u2016a ^ n\u2016 \u2264 \u2016a\u2016 ^ n"}, {"line": "simpa only [NNReal.coe_pow,coe_nnnorm] using NNReal.coe_mono (nnnorm_pow_le' a h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnnorm_commutator_units_sub_one_le (a b : \u03b1\u02e3) :\n    \u2016(a * b * a\u207b\u00b9 * b\u207b\u00b9).val - 1\u2016\u208a \u2264 2 * \u2016a\u207b\u00b9.val\u2016\u208a * \u2016b\u207b\u00b9.val\u2016\u208a * \u2016a.val - 1\u2016\u208a * \u2016b.val - 1\u2016\u208a := by\n  simpa using norm_commutator_units_sub_one_le a b\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[SeminormedAddCommGroup G] [One G] [NormOneClass G]", "[NonUnitalSeminormedRing \u03b1] {a a\u2081 a\u2082 b c : \u03b1}", "[SeminormedRing \u03b1] {a b c : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\ninst\u271d\u00b9 : NonUnitalSeminormedRing \u03b1\ninst\u271d : SeminormedRing \u03b1\na b : \u03b1\u02e3\n\u22a2 \u2016\u2191(a * b * a\u207b\u00b9 * b\u207b\u00b9) - 1\u2016\u208a \u2264 2 * \u2016\u2191a\u207b\u00b9\u2016\u208a * \u2016\u2191b\u207b\u00b9\u2016\u208a * \u2016\u2191a - 1\u2016\u208a * \u2016\u2191b - 1\u2016\u208a"}, {"line": "simpa using norm_commutator_units_sub_one_le a b", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq (x : \u211d\u22650) : \u2016(x : \u211d)\u2016 = x := by rw [Real.norm_eq_abs, x.abs_eq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Basic.lean", "context": {"open": ["Filter", "scoped Topology NNReal", "NNReal"], "variables": ["{G \u03b1 \u03b2 \u03b9 : Type*}", "[SeminormedAddCommGroup G] [One G] [NormOneClass G]", "[NonUnitalSeminormedRing \u03b1] {a a\u2081 a\u2082 b c : \u03b1}", "[SeminormedRing \u03b1] {a b c : \u03b1}", "[NonUnitalNormedRing \u03b1]", "[NormedRing \u03b1]", "[NonUnitalSeminormedCommRing \u03b1]", "[NonUnitalNormedCommRing \u03b1]", "[SeminormedCommRing \u03b1]", "[NormedCommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\n\u22a2 \u2016\u2191x\u2016 = \u2191x"}, {"line": "rw [Real.norm_eq_abs, x.abs_eq]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_add_one_le_max_norm_one (x : R) :\n    \u2016x + 1\u2016 \u2264 max \u2016x\u2016 1 := by\n  simpa only [le_max_iff,norm_one] using norm_add_le_max x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Ultra.lean", "context": {"open": ["Metric NNReal"], "variables": ["{R : Type*} [SeminormedRing R] [NormOneClass R] [IsUltrametricDist R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b2 : SeminormedRing R\ninst\u271d\u00b9 : NormOneClass R\ninst\u271d : IsUltrametricDist R\nx : R\n\u22a2 \u2016x + 1\u2016 \u2264 max \u2016x\u2016 1"}, {"line": "simpa only [le_max_iff,norm_one] using norm_add_le_max x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasSum_sum_range_mul_of_summable_norm' {f g : \u2115 \u2192 R}\n    (hf : Summable fun x => \u2016f x\u2016) (h'f : Summable f)\n    (hg : Summable fun x => \u2016g x\u2016) (h'g : Summable g) :\n    HasSum (fun n \u21a6 \u2211 k \u2208 range (n + 1), f k * g (n - k)) ((\u2211' n, f n) * \u2211' n, g n) := by\n  convert (summable_sum_mul_range_of_summable_norm' hf h'f hg h'g).hasSum\n  exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' hf h'f hg h'g\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/InfiniteSum.lean", "context": {"open": ["scoped Topology", "Finset Filter", "Finset.Nat"], "variables": ["{R : Type*} {\u03b9 : Type*} {\u03b9' : Type*} [NormedRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NormedRing R\nf g : \u2115 \u2192 R\nhf : Summable fun x => \u2016f x\u2016\nh'f : Summable f\nhg : Summable fun x => \u2016g x\u2016\nh'g : Summable g\n\u22a2 HasSum (fun n => \u2211 k \u2208 range (n + 1), f k * g (n - k)) ((\u2211' (n : \u2115), f n) * \u2211' (n : \u2115), g n)"}, {"line": "convert (summable_sum_mul_range_of_summable_norm' hf h'f hg h'g).hasSum", "tactic_state": "case h.e'_6\nR : Type u_1\ninst\u271d : NormedRing R\nf g : \u2115 \u2192 R\nhf : Summable fun x => \u2016f x\u2016\nh'f : Summable f\nhg : Summable fun x => \u2016g x\u2016\nh'g : Summable g\n\u22a2 (\u2211' (n : \u2115), f n) * \u2211' (n : \u2115), g n = \u2211' (b : \u2115), \u2211 k \u2208 range (b + 1), f k * g (b - k)"}, {"line": "exact tsum_mul_tsum_eq_tsum_sum_range_of_summable_norm' hf h'f hg h'g", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lipschitzWith_sub : LipschitzWith 2 (fun (p : \u211d\u22650 \u00d7 \u211d\u22650) \u21a6 p.1 - p.2) := by\n  rw [\u2190 isometry_subtype_coe.lipschitzWith_iff]\n  have : Isometry (Prod.map ((\u2191) : \u211d\u22650 \u2192 \u211d) ((\u2191) : \u211d\u22650 \u2192 \u211d)) :=\n    isometry_subtype_coe.prodMap isometry_subtype_coe\n  convert (((LipschitzWith.prod_fst.comp this.lipschitz).sub\n    (LipschitzWith.prod_snd.comp this.lipschitz)).max_const 0)\n  norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Lemmas.lean", "context": {"open": ["Filter Bornology", "scoped Topology NNReal Pointwise", "Finset in"], "variables": ["{\u03b1 : Type*} {\u03b2 : Type*} {\u03b9 : Type*}", "[NonUnitalSeminormedRing \u03b1]", "[SeminormedRing \u03b1]", "[NonUnitalNormedRing \u03b1]", "[NormedRing \u03b1]", "[NonUnitalSeminormedCommRing \u03b1]", "[NonUnitalNormedCommRing \u03b1]", "[SeminormedCommRing \u03b1]", "[NormedCommRing \u03b1]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 LipschitzWith 2 fun p => p.1 - p.2"}, {"line": "rw [\u2190 isometry_subtype_coe.lipschitzWith_iff]", "tactic_state": "\u22a2 LipschitzWith 2 (Subtype.val \u2218 fun p => p.1 - p.2)"}, {"line": "have : Isometry (Prod.map ((\u2191) : \u211d\u22650 \u2192 \u211d) ((\u2191) : \u211d\u22650 \u2192 \u211d)) :=\n    isometry_subtype_coe.prodMap isometry_subtype_coe", "tactic_state": "this : sorry\n\u22a2 LipschitzWith 2 (Subtype.val \u2218 fun p => p.1 - p.2)"}, {"line": "convert (((LipschitzWith.prod_fst.comp this.lipschitz).sub\n    (LipschitzWith.prod_snd.comp this.lipschitz)).max_const 0)", "tactic_state": "case h.e'_5\nthis : sorry\n\u22a2 2 = 1 * ?convert_3 + 1 * ?convert_7\n---\ncase h.e'_6.h\nthis : sorry\nx\u271d : NNReal \u00d7 NNReal\n\u22a2 (Subtype.val \u2218 fun p => p.1 - p.2) x\u271d = max ((Prod.fst \u2218 ?convert_4) x\u271d - (Prod.snd \u2218 ?convert_8) x\u271d) 0\n---\ncase convert_1\nthis : sorry\n\u22a2 Type ?u.6642\n---\ncase convert_2\nthis : sorry\n\u22a2 PseudoEMetricSpace ?convert_1\n---\ncase convert_3\nthis : sorry\n\u22a2 NNReal\n---\ncase convert_4\nthis : sorry\n\u22a2 NNReal \u00d7 NNReal \u2192 \u211d \u00d7 ?convert_1\n---\ncase convert_5\nthis : sorry\n\u22a2 Type ?u.6853\n---\ncase convert_6\nthis : sorry\n\u22a2 PseudoEMetricSpace ?convert_5\n---\ncase convert_7\nthis : sorry\n\u22a2 NNReal\n---\ncase convert_8\nthis : sorry\n\u22a2 NNReal \u00d7 NNReal \u2192 ?convert_5 \u00d7 \u211d"}, {"line": "norm_num", "tactic_state": "case h.e'_5\nthis : sorry\n\u22a2 2 = ?convert_3 + ?convert_7\n---\ncase h.e'_6.h\nthis : sorry\nx\u271d : NNReal \u00d7 NNReal\n\u22a2 (Subtype.val \u2218 fun p => p.1 - p.2) x\u271d = max ((Prod.fst \u2218 ?convert_4) x\u271d - (Prod.snd \u2218 ?convert_8) x\u271d) 0\n---\ncase convert_1\nthis : sorry\n\u22a2 Type ?u.6642\n---\ncase convert_2\nthis : sorry\n\u22a2 PseudoEMetricSpace ?convert_1\n---\ncase convert_3\nthis : sorry\n\u22a2 NNReal\n---\ncase convert_4\nthis : sorry\n\u22a2 NNReal \u00d7 NNReal \u2192 \u211d \u00d7 ?convert_1\n---\ncase convert_5\nthis : sorry\n\u22a2 Type ?u.6853\n---\ncase convert_6\nthis : sorry\n\u22a2 PseudoEMetricSpace ?convert_5\n---\ncase convert_7\nthis : sorry\n\u22a2 NNReal\n---\ncase convert_8\nthis : sorry\n\u22a2 NNReal \u00d7 NNReal \u2192 ?convert_5 \u00d7 \u211d"}]}
{"declaration": "theorem inverse_add_norm_diff_first_order (x : R\u02e3) :\n    (fun t : R => inverse (\u2191x + t) - \u2191x\u207b\u00b9) =O[\ud835\udcdd 0] fun t => \u2016t\u2016 := by\n  simpa using inverse_add_norm_diff_nth_order x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Ring/Units.lean", "context": {"open": ["Topology", "Asymptotics Filter Metric Finset Ring"], "variables": ["{R : Type*} [NormedRing R] [HasSummableGeomSeries R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d\u00b9 : NormedRing R\ninst\u271d : HasSummableGeomSeries R\nx : R\u02e3\n\u22a2 (fun t => inverse (\u2191x + t) - \u2191x\u207b\u00b9) =O[nhds 0] fun t => \u2016t\u2016"}, {"line": "simpa using inverse_add_norm_diff_nth_order x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem map_mul_zero_of_map_zero (f_nonneg : 0 \u2264 f)\n    (f_mul : \u2200 x y : R, f (x * y) \u2264 c * f x * f y) {x : R} (hx : f x = 0)\n    (y : R) : f (x * y) = 0 := by\n  replace f_mul : f (x * y) \u2264 0 := by simpa [hx] using f_mul x y\n  exact le_antisymm f_mul (f_nonneg _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromBounded.lean", "context": {"open": ["scoped Topology NNReal"], "variables": ["{R : Type _} [CommRing R] (f : R \u2192 \u211d) {c : \u211d}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx : R\nhx : f x = 0\ny : R\n\u22a2 f (x * y) = 0"}, {"line": "replace f_mul : f (x * y) \u2264 0 := by simpa [hx] using f_mul x y", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nx : R\nhx : f x = 0\ny : R\nf_mul : f sorry \u2264 0\n\u22a2 f (x * y) = 0"}, {"line": "exact le_antisymm f_mul (f_nonneg _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seminormFromBounded_bddAbove_range (f_nonneg : 0 \u2264 f)\n    (f_mul : \u2200 x y : R, f (x * y) \u2264 c * f x * f y) (x : R) :\n    BddAbove (Set.range fun y \u21a6 f (x * y) / f y) := by\n  use c * f x\n  rintro r \u27e8y, rfl\u27e9\n  rcases (f_nonneg y).eq_or_gt with hy0 | hy0\n  \u00b7 simpa [hy0] using seminormFromBounded_aux f_nonneg f_mul x\n  \u00b7 simpa [div_le_iff\u2080 hy0] using f_mul x y\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromBounded.lean", "context": {"open": ["scoped Topology NNReal"], "variables": ["{R : Type _} [CommRing R] (f : R \u2192 \u211d) {c : \u211d}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx : R\n\u22a2 BddAbove (Set.range fun y => f (x * y) / f y)"}, {"line": "use c * f x", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx : R\n\u22a2 c * f x \u2208 upperBounds (Set.range fun y => f (x * y) / f y)"}, {"line": "rintro r \u27e8y, rfl\u27e9", "tactic_state": "case h.intro\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx y : R\n\u22a2 (fun y => f (x * y) / f y) y \u2264 c * f x"}, {"line": "rcases (f_nonneg y).eq_or_gt with hy0 | hy0", "tactic_state": "case h.intro.inl\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx y : R\nhy0 : f y = 0 y\n\u22a2 (fun y => f (x * y) / f y) y \u2264 c * f x\n---\ncase h.intro.inr\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx y : R\nhy0 : 0 y < f y\n\u22a2 (fun y => f (x * y) / f y) y \u2264 c * f x"}, {"line": "\u00b7 simpa [hy0] using seminormFromBounded_aux f_nonneg f_mul x", "tactic_state": "case h.intro.inr\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx y : R\nhy0 : 0 y < f y\n\u22a2 (fun y => f (x * y) / f y) y \u2264 c * f x"}, {"line": "\u00b7 simpa [div_le_iff\u2080 hy0] using f_mul x y", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seminormFromBounded_ker (f_nonneg : 0 \u2264 f)\n    (f_mul : \u2200 x y : R, f (x * y) \u2264 c * f x * f y) :\n    seminormFromBounded' f \u207b\u00b9' {0} = f \u207b\u00b9' {0} := by\n  ext x\n  exact seminormFromBounded_eq_zero_iff f_nonneg f_mul x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromBounded.lean", "context": {"open": ["scoped Topology NNReal"], "variables": ["{R : Type _} [CommRing R] (f : R \u2192 \u211d) {c : \u211d}", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\n\u22a2 seminormFromBounded' f \u207b\u00b9' {0} = f \u207b\u00b9' {0}"}, {"line": "ext x", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nf : R \u2192 \u211d\nc : \u211d\nf_nonneg : 0 \u2264 f\nf_mul : \u2200 (x y : R), f (x * y) \u2264 c * f x * f y\nx : R\n\u22a2 x \u2208 seminormFromBounded' f \u207b\u00b9' {0} \u2194 x \u2208 f \u207b\u00b9' {0}"}, {"line": "exact seminormFromBounded_eq_zero_iff f_nonneg f_mul x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ne_zero_iff {p : RingSeminorm R} : p \u2260 0 \u2194 \u2203 x, p x \u2260 0 := by simp [eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/RingSeminorm.lean", "context": {"open": ["NNReal"], "variables": ["{R : Type*}", "[NonUnitalRing R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalRing R\np : RingSeminorm R\n\u22a2 p \u2260 0 \u2194 \u2203 x, p x \u2260 0"}, {"line": "simp [eq_zero_iff]", "tactic_state": "R : Type u_1\ninst\u271d : NonUnitalRing R\np : RingSeminorm R\n\u22a2 \u00acp = 0 \u2194 \u2203 x, \u00acp x = 0"}]}
{"declaration": "lemma equiv_refl (f : MulRingNorm R) : equiv f f := by\n    exact \u27e81, Real.zero_lt_one, by simp only [Real.rpow_one]\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/RingSeminorm.lean", "context": {"open": ["NNReal", "Filter Nat Real"], "variables": ["{R : Type*}", "[NonUnitalRing R]", "[Ring R] (p : RingSeminorm R)", "[CommRing R] (p : RingSeminorm R)", "[Ring R] (p : RingSeminorm R)", "[NonUnitalRing R]", "(R)", "[NonAssocRing R]", "[DecidableEq R] [NoZeroDivisors R] [Nontrivial R]", "[NonAssocRing R]", "(R)", "[DecidableEq R] [NoZeroDivisors R] [Nontrivial R]", "{R : Type*} [Ring R] [Nontrivial R]", "{R : Type*} [Ring R]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_3\ninst\u271d : Ring R\nx\u271d : Sort u_4\nequiv : x\u271d\nf : MulRingNorm R\n\u22a2 sorry"}, {"line": "exact \u27e81, Real.zero_lt_one, by simp only [Real.rpow_one]\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seminormFromConst_bddBelow (x : R) :\n    BddBelow (Set.range (seminormFromConst_seq c f x)) := by\n  use 0\n  rintro r \u27e8n, rfl\u27e9\n  exact seminormFromConst_seq_nonneg c f x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{R : Type*} [CommRing R] (c : R) (f : RingSeminorm R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nx : R\n\u22a2 BddBelow (Set.range (seminormFromConst_seq c f x))"}, {"line": "use 0", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nx : R\n\u22a2 0 \u2208 lowerBounds (Set.range (seminormFromConst_seq c f x))"}, {"line": "rintro r \u27e8n, rfl\u27e9", "tactic_state": "case h.intro\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nx : R\nn : \u2115\n\u22a2 0 \u2264 seminormFromConst_seq c f x n"}, {"line": "exact seminormFromConst_seq_nonneg c f x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seminormFromConst_seq_zero (hf : f 0 = 0) : seminormFromConst_seq c f 0 = 0 := by\n  rw [seminormFromConst_seq_def]\n  ext n\n  rw [zero_mul]\n  rw [hf]\n  rw [zero_div]\n  rw [Pi.zero_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{R : Type*} [CommRing R] (c : R) (f : RingSeminorm R)", "{f}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\n\u22a2 seminormFromConst_seq c f 0 = 0"}, {"line": "rw [seminormFromConst_seq_def]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\n\u22a2 (fun n => f (0 * c ^ n) / f c ^ n) = 0"}, {"line": "ext n", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\nn : \u2115\n\u22a2 f (0 * c ^ n) / f c ^ n = 0 n"}, {"line": "rw [zero_mul]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\nn : \u2115\n\u22a2 f 0 / f c ^ n = 0 n"}, {"line": "rw [hf]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\nn : \u2115\n\u22a2 0 / f c ^ n = 0 n"}, {"line": "rw [zero_div]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf : f 0 = 0\nn : \u2115\n\u22a2 0 = 0 n"}, {"line": "rw [Pi.zero_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem seminormFromConst_le_seminorm (x : R) : seminormFromConst' hf1 hc hpm x \u2264 f x := by\n  apply le_of_tendsto (seminormFromConst_isLimit hf1 hc hpm x)\n  simp only [eventually_atTop]\n  simp only [ge_iff_le]\n  use 1\n  intro n hn\n  rw [seminormFromConst_seq]\n  rw [div_le_iff\u2080 (by positivity)]\n  rw [\u2190 hpm c hn]\n  exact map_mul_le_mul ..\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SeminormFromConst.lean", "context": {"open": ["Filter", "scoped Topology"], "variables": ["{R : Type*} [CommRing R] (c : R) (f : RingSeminorm R)", "{f}", "{c}", "(hf1 : f 1 \u2264 1) (hc : f c \u2260 0) (hpm : IsPowMul f)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\n\u22a2 seminormFromConst' hf1 hc hpm x \u2264 f x"}, {"line": "apply le_of_tendsto (seminormFromConst_isLimit hf1 hc hpm x)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\n\u22a2 \u2200\u1da0 (c_1 : \u2115) in atTop, seminormFromConst_seq c f x c_1 \u2264 f x"}, {"line": "simp only [eventually_atTop]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\n\u22a2 \u2203 a, \u2200 b \u2265 a, seminormFromConst_seq c f x b \u2264 f x"}, {"line": "simp only [ge_iff_le]", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\n\u22a2 \u2203 a, \u2200 (b : \u2115), a \u2264 b \u2192 seminormFromConst_seq c f x b \u2264 f x"}, {"line": "use 1", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\n\u22a2 \u2200 (b : \u2115), 1 \u2264 b \u2192 seminormFromConst_seq c f x b \u2264 f x"}, {"line": "intro n hn", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\nn : \u2115\nhn : 1 \u2264 n\n\u22a2 seminormFromConst_seq c f x n \u2264 f x"}, {"line": "rw [seminormFromConst_seq]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\nn : \u2115\nhn : 1 \u2264 n\n\u22a2 f (x * c ^ n) / f c ^ n \u2264 f x"}, {"line": "rw [div_le_iff\u2080 (by positivity)]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\nn : \u2115\nhn : 1 \u2264 n\n\u22a2 f (x * c ^ n) \u2264 f x * f c ^ n"}, {"line": "rw [\u2190 hpm c hn]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\nc : R\nf : RingSeminorm R\nhf1 : f 1 \u2264 1\nhc : f c \u2260 0\nhpm : IsPowMul \u21d1f\nx : R\nn : \u2115\nhn : 1 \u2264 n\n\u22a2 f (x * c ^ n) \u2264 f x * f (c ^ n)"}, {"line": "exact map_mul_le_mul ..", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_mem_lowerBounds_smoothingSeminormSeq_range (x : R) :\n    0 \u2208 lowerBounds (Set.range fun n : \u2115+ => \u03bc (x ^ (n : \u2115)) ^ (1 / (n : \u211d))) := by\n  rintro y \u27e8n, rfl\u27e9\n  exact rpow_nonneg (apply_nonneg \u03bc _) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nx : R\n\u22a2 0 \u2208 lowerBounds (Set.range fun n => \u03bc (x ^ \u2191n) ^ (1 / \u2191\u2191n))"}, {"line": "rintro y \u27e8n, rfl\u27e9", "tactic_state": "case intro\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nx : R\nn : \u2115+\n\u22a2 0 \u2264 (fun n => \u03bc (x ^ \u2191n) ^ (1 / \u2191\u2191n)) n"}, {"line": "exact rpow_nonneg (apply_nonneg \u03bc _) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_smoothingFun_of_map_one_le_one (h\u03bc1 : \u03bc 1 \u2264 1) (x : R) :\n    Tendsto (smoothingSeminormSeq \u03bc x) atTop (\ud835\udcdd (smoothingFun \u03bc x)) := by\n  by_cases hx : \u03bc x = 0\n  \u00b7 exact tendsto_smoothingFun_of_eq_zero \u03bc hx\n  \u00b7 exact tendsto_smoothingFun_of_ne_zero \u03bc h\u03bc1 hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\n\u22a2 Tendsto (smoothingSeminormSeq \u03bc x) atTop (nhds (smoothingFun \u03bc x))"}, {"line": "by_cases hx : \u03bc x = 0", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\nhx : \u03bc x = 0\n\u22a2 Tendsto (smoothingSeminormSeq \u03bc x) atTop (nhds (smoothingFun \u03bc x))\n---\ncase neg\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\nhx : \u00ac\u03bc x = 0\n\u22a2 Tendsto (smoothingSeminormSeq \u03bc x) atTop (nhds (smoothingFun \u03bc x))"}, {"line": "\u00b7 exact tendsto_smoothingFun_of_eq_zero \u03bc hx", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\nhx : \u00ac\u03bc x = 0\n\u22a2 Tendsto (smoothingSeminormSeq \u03bc x) atTop (nhds (smoothingFun \u03bc x))"}, {"line": "\u00b7 exact tendsto_smoothingFun_of_ne_zero \u03bc h\u03bc1 hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smoothingFun_nonneg (h\u03bc1 : \u03bc 1 \u2264 1) (x : R) : 0 \u2264 smoothingFun \u03bc x := by\n  apply ge_of_tendsto (tendsto_smoothingFun_of_map_one_le_one \u03bc h\u03bc1 x)\n  simpa [eventually_atTop, ge_iff_le] using \u27e81, fun _ _ \u21a6 rpow_nonneg (apply_nonneg \u03bc _) _\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\n\u22a2 0 \u2264 smoothingFun \u03bc x"}, {"line": "apply ge_of_tendsto (tendsto_smoothingFun_of_map_one_le_one \u03bc h\u03bc1 x)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\nh\u03bc1 : \u03bc 1 \u2264 1\nx : R\n\u22a2 \u2200\u1da0 (c : \u2115) in atTop, 0 \u2264 smoothingSeminormSeq \u03bc x c"}, {"line": "simpa [eventually_atTop, ge_iff_le] using \u27e81, fun _ _ \u21a6 rpow_nonneg (apply_nonneg \u03bc _) _\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem mu_le (n : \u2115) : mu \u03bc hn n \u2264 n := by\n  simpa [mu, \u2190 Nat.lt_succ_iff] using (Classical.choose_spec (hn n)).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)", "{x y : R} (hn : \u2200 n : \u2115, \u2203 m < n + 1, \u03bc ((x + y) ^ (n : \u2115)) ^ (1 / (n : \u211d)) \u2264"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nmu : x\u271d\nn : \u2115\n\u22a2 sorry \u2264 n"}, {"line": "simpa [mu, \u2190 Nat.lt_succ_iff] using (Classical.choose_spec (hn n)).1", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem \u03bc_bddBelow (s : \u2115 \u2192 \u2115) {x : R} (\u03c8 : \u2115 \u2192 \u2115) :\n    BddBelow {a : \u211d |\n      \u2200\u1da0 n : \u211d in map (fun n : \u2115 => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / (\u03c8 n : \u211d)))) atTop, n \u2264 a} := by\n  use 0\n  simp only [mem_lowerBounds]\n  simp only [eventually_map]\n  simp only [eventually_atTop]\n  simp only [ge_iff_le]\n  simp only [Set.mem_setOf_eq]\n  simp only [forall_exists_index]\n  intro r m hm\n  exact le_trans (rpow_nonneg (apply_nonneg \u03bc _) _) (hm m (le_refl _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)", "{x y : R} (hn : \u2200 n : \u2115, \u2203 m < n + 1, \u03bc ((x + y) ^ (n : \u2115)) ^ (1 / (n : \u211d)) \u2264"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 BddBelow {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}"}, {"line": "use 0", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 0 \u2208 lowerBounds {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}"}, {"line": "simp only [mem_lowerBounds]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 x_1 \u2208 {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}, 0 \u2264 x_1"}, {"line": "simp only [eventually_map]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 x_1 \u2208 {a | \u2200\u1da0 (a_1 : \u2115) in atTop, \u03bc x ^ (\u2191(s (\u03c8 a_1)) * (1 / \u2191(\u03c8 a_1))) \u2264 a}, 0 \u2264 x_1"}, {"line": "simp only [eventually_atTop]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 x_1 \u2208 {a | \u2203 a_1, \u2200 b \u2265 a_1, \u03bc x ^ (\u2191(s (\u03c8 b)) * (1 / \u2191(\u03c8 b))) \u2264 a}, 0 \u2264 x_1"}, {"line": "simp only [ge_iff_le]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 x_1 \u2208 {a | \u2203 a_1, \u2200 (b : \u2115), a_1 \u2264 b \u2192 \u03bc x ^ (\u2191(s (\u03c8 b)) * (1 / \u2191(\u03c8 b))) \u2264 a}, 0 \u2264 x_1"}, {"line": "simp only [Set.mem_setOf_eq]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 (x_1 : \u211d), (\u2203 a, \u2200 (b : \u2115), a \u2264 b \u2192 \u03bc x ^ (\u2191(s (\u03c8 b)) * (1 / \u2191(\u03c8 b))) \u2264 x_1) \u2192 0 \u2264 x_1"}, {"line": "simp only [forall_exists_index]", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 \u2200 (x_1 : \u211d) (x_2 : \u2115), (\u2200 (b : \u2115), x_2 \u2264 b \u2192 \u03bc x ^ (\u2191(s (\u03c8 b)) * (1 / \u2191(\u03c8 b))) \u2264 x_1) \u2192 0 \u2264 x_1"}, {"line": "intro r m hm", "tactic_state": "case h\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nx : R\n\u03c8 : \u2115 \u2192 \u2115\nr : \u211d\nm : \u2115\nhm : \u2200 (b : \u2115), m \u2264 b \u2192 \u03bc x ^ (\u2191(s (\u03c8 b)) * (1 / \u2191(\u03c8 b))) \u2264 r\n\u22a2 0 \u2264 r"}, {"line": "exact le_trans (rpow_nonneg (apply_nonneg \u03bc _) _) (hm m (le_refl _))", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem \u03bc_nonempty {s : \u2115 \u2192 \u2115} (hs_le : \u2200 n : \u2115, s n \u2264 n) {x : R} (\u03c8 : \u2115 \u2192 \u2115) :\n    {a : \u211d | \u2200\u1da0 n : \u211d in map (fun n : \u2115 => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / (\u03c8 n : \u211d)))) atTop,\n      n \u2264 a}.Nonempty := by\n  by_cases h\u03bcx : \u03bc x < 1\n  \u00b7 use 1\n    simp only [eventually_map]\n    simp only [eventually_atTop]\n    simp only [ge_iff_le]\n    simp only [Set.mem_setOf_eq]\n    exact \u27e80, fun _ _ \u21a6 rpow_le_one (apply_nonneg _ _) (le_of_lt h\u03bcx)\n      (mul_nonneg (cast_nonneg _) (one_div_nonneg.mpr (cast_nonneg _)))\u27e9\n  \u00b7 use \u03bc x\n    simp only [eventually_map]\n    simp only [eventually_atTop]\n    simp only [ge_iff_le]\n    simp only [Set.mem_setOf_eq]\n    use 0\n    intro b _\n    nth_rw 2 [\u2190 rpow_one (\u03bc x)]\n    apply rpow_le_rpow_of_exponent_le (not_lt.mp h\u03bcx)\n    rw [mul_one_div]\n    exact div_le_one_of_le\u2080 (cast_le.mpr (hs_le (\u03c8 b))) (cast_nonneg _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Normed/Unbundled/SmoothingSeminorm.lean", "context": {"open": ["Filter Nat Real", "scoped Topology NNReal"], "variables": ["{R : Type*} [CommRing R] (\u03bc : RingSeminorm R)", "{x y : R} (hn : \u2200 n : \u2115, \u2203 m < n + 1, \u03bc ((x + y) ^ (n : \u2115)) ^ (1 / (n : \u211d)) \u2264"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "R : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nhs_le : \u2200 (n : \u2115), s n \u2264 n\nx : R\n\u03c8 : \u2115 \u2192 \u2115\n\u22a2 {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}.Nonempty"}, {"line": "by_cases h\u03bcx : \u03bc x < 1", "tactic_state": "case pos\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nhs_le : \u2200 (n : \u2115), s n \u2264 n\nx : R\n\u03c8 : \u2115 \u2192 \u2115\nh\u03bcx : \u03bc x < 1\n\u22a2 {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}.Nonempty\n---\ncase neg\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nhs_le : \u2200 (n : \u2115), s n \u2264 n\nx : R\n\u03c8 : \u2115 \u2192 \u2115\nh\u03bcx : \u00ac\u03bc x < 1\n\u22a2 {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}.Nonempty"}, {"line": "\u00b7 use 1\n    simp only [eventually_map]\n    simp only [eventually_atTop]\n    simp only [ge_iff_le]\n    simp only [Set.mem_setOf_eq]\n    exact \u27e80, fun _ _ \u21a6 rpow_le_one (apply_nonneg _ _) (le_of_lt h\u03bcx)\n      (mul_nonneg (cast_nonneg _) (one_div_nonneg.mpr (cast_nonneg _)))\u27e9", "tactic_state": "case neg\nR : Type u_1\ninst\u271d : CommRing R\n\u03bc : RingSeminorm R\ns : \u2115 \u2192 \u2115\nhs_le : \u2200 (n : \u2115), s n \u2264 n\nx : R\n\u03c8 : \u2115 \u2192 \u2115\nh\u03bcx : \u00ac\u03bc x < 1\n\u22a2 {a | \u2200\u1da0 (n : \u211d) in map (fun n => \u03bc x ^ (\u2191(s (\u03c8 n)) * (1 / \u2191(\u03c8 n)))) atTop, n \u2264 a}.Nonempty"}, {"line": "\u00b7 use \u03bc x\n    simp only [eventually_map]\n    simp only [eventually_atTop]\n    simp only [ge_iff_le]\n    simp only [Set.mem_setOf_eq]\n    use 0\n    intro b _\n    nth_rw 2 [\u2190 rpow_one (\u03bc x)]\n    apply rpow_le_rpow_of_exponent_le (not_lt.mp h\u03bcx)\n    rw [mul_one_div]\n    exact div_le_one_of_le\u2080 (cast_le.mpr (hs_le (\u03c8 b))) (cast_nonneg _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PartialHomeomorph.univUnitBall_apply_zero : univUnitBall (0 : E) = 0 := by\n  simp [PartialHomeomorph.univUnitBall_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/HomeomorphBall.lean", "context": {"open": ["Set Metric Pointwise"], "variables": ["{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u22a2 \u2191univUnitBall 0 = 0"}, {"line": "simp [PartialHomeomorph.univUnitBall_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem PartialHomeomorph.univUnitBall_symm_apply_zero : univUnitBall.symm (0 : E) = 0 := by\n  simp [PartialHomeomorph.univUnitBall_symm_apply]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/HomeomorphBall.lean", "context": {"open": ["Set Metric Pointwise"], "variables": ["{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u22a2 \u2191univUnitBall.symm 0 = 0"}, {"line": "simp [PartialHomeomorph.univUnitBall_symm_apply]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem enorm_indicator_le_of_subset (h : s \u2286 t) (f : \u03b1 \u2192 \u03b5) (a : \u03b1) :\n    \u2016indicator s f a\u2016\u2091 \u2264 \u2016indicator t f a\u2016\u2091 := by\n  simp only [enorm_indicator_eq_indicator_enorm]\n  apply indicator_le_indicator_of_subset \u2039_\u203a (zero_le _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/IndicatorFunction.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5] {s t : Set \u03b1} (f : \u03b1 \u2192 \u03b5) (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\ns t : Set \u03b1\nh : s \u2286 t\nf : \u03b1 \u2192 \u03b5\na : \u03b1\n\u22a2 \u2016s.indicator f a\u2016\u2091 \u2264 \u2016t.indicator f a\u2016\u2091"}, {"line": "simp only [enorm_indicator_eq_indicator_enorm]", "tactic_state": "\u03b1 : Type u_1\n\u03b5 : Type u_2\ninst\u271d\u00b9 : TopologicalSpace \u03b5\ninst\u271d : ENormedAddMonoid \u03b5\ns t : Set \u03b1\nh : s \u2286 t\nf : \u03b1 \u2192 \u03b5\na : \u03b1\n\u22a2 s.indicator (fun a => \u2016f a\u2016\u2091) a \u2264 t.indicator (fun a => \u2016f a\u2016\u2091) a"}, {"line": "apply indicator_le_indicator_of_subset \u2039_\u203a (zero_le _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_indicator_le_of_subset (h : s \u2286 t) (f : \u03b1 \u2192 E) (a : \u03b1) :\n    \u2016indicator s f a\u2016 \u2264 \u2016indicator t f a\u2016 := by\n  simp only [norm_indicator_eq_indicator_norm]\n  exact indicator_le_indicator_of_subset \u2039_\u203a (fun _ => norm_nonneg _) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/IndicatorFunction.lean", "context": {"open": ["Set"], "variables": ["{\u03b1 \u03b5 : Type*} [TopologicalSpace \u03b5] [ENormedAddMonoid \u03b5] {s t : Set \u03b1} (f : \u03b1 \u2192 \u03b5) (a : \u03b1)", "{\u03b1 E : Type*} [SeminormedAddGroup E] {s t : Set \u03b1} (f : \u03b1 \u2192 E) (a : \u03b1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nE : Type u_4\ninst\u271d : SeminormedAddGroup E\ns t : Set \u03b1\nh : s \u2286 t\nf : \u03b1 \u2192 E\na : \u03b1\n\u22a2 \u2016s.indicator f a\u2016 \u2264 \u2016t.indicator f a\u2016"}, {"line": "simp only [norm_indicator_eq_indicator_norm]", "tactic_state": "\u03b1 : Type u_3\nE : Type u_4\ninst\u271d : SeminormedAddGroup E\ns t : Set \u03b1\nh : s \u2286 t\nf : \u03b1 \u2192 E\na : \u03b1\n\u22a2 s.indicator (fun a => \u2016f a\u2016) a \u2264 t.indicator (fun a => \u2016f a\u2016) a"}, {"line": "exact indicator_le_indicator_of_subset \u2039_\u203a (fun _ => norm_nonneg _) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_ball {x : E} {r : \u211d} (hr : 0 < r) :\n    IsPathConnected (ball x r) := by\n  rw [isPathConnected_iff_pathConnectedSpace]\n  exact @ContractibleSpace.instPathConnectedSpace _ _ (ball_contractible hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "context": {"open": ["Convex Set Metric"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nr : \u211d\nhr : 0 < r\n\u22a2 IsPathConnected (ball x r)"}, {"line": "rw [isPathConnected_iff_pathConnectedSpace]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nr : \u211d\nhr : 0 < r\n\u22a2 PathConnectedSpace \u2191(ball x r)"}, {"line": "exact @ContractibleSpace.instPathConnectedSpace _ _ (ball_contractible hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPathConnected_eball {x : E} {r : ENNReal} (hr : 0 < r) :\n    IsPathConnected (EMetric.ball x r) := by\n  rw [isPathConnected_iff_pathConnectedSpace]\n  exact @ContractibleSpace.instPathConnectedSpace _ _ (eball_contractible hr)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "context": {"open": ["Convex Set Metric"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nr : ENNReal\nhr : 0 < r\n\u22a2 IsPathConnected (EMetric.ball x r)"}, {"line": "rw [isPathConnected_iff_pathConnectedSpace]", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx : E\nr : ENNReal\nhr : 0 < r\n\u22a2 PathConnectedSpace \u2191(EMetric.ball x r)"}, {"line": "exact @ContractibleSpace.instPathConnectedSpace _ _ (eball_contractible hr)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isPreconnected_sphere (h : 1 < Module.rank \u211d E) (x : E) (r : \u211d) :\n    IsPreconnected (sphere x r) := by\n  rcases le_or_lt 0 r with hr|hr\n  \u00b7 exact (isConnected_sphere h x hr).isPreconnected\n  \u00b7 simpa [hr] using isPreconnected_empty\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Connected.lean", "context": {"open": ["Convex Set Metric"], "variables": ["{E : Type*} [AddCommGroup E] [Module \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\n\u22a2 IsPreconnected (sphere x r)"}, {"line": "rcases le_or_lt 0 r with hr|hr", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 IsPreconnected (sphere x r)\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : r < 0\n\u22a2 IsPreconnected (sphere x r)"}, {"line": "\u00b7 exact (isConnected_sphere h x hr).isPreconnected", "tactic_state": "case inr\nE : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nh : 1 < Module.rank \u211d E\nx : E\nr : \u211d\nhr : r < 0\n\u22a2 IsPreconnected (sphere x r)"}, {"line": "\u00b7 simpa [hr] using isPreconnected_empty", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coeFn_injective : Function.Injective ((\u2191) : ENormedSpace \ud835\udd5c V \u2192 V \u2192 \u211d\u22650\u221e) := by\n  intro e\u2081 e\u2082 h\n  cases e\u2081\n  cases e\u2082\n  congr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/ENormedSpace.lean", "context": {"open": ["ENNReal"], "variables": ["{\ud835\udd5c : Type*} {V : Type*} [NormedField \ud835\udd5c] [AddCommGroup V] [Module \ud835\udd5c V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\n\u22a2 Function.Injective ENormedSpace.toFun"}, {"line": "intro e\u2081 e\u2082 h", "tactic_state": "\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ne\u2081 e\u2082 : ENormedSpace \ud835\udd5c V\nh : \u2191e\u2081 = \u2191e\u2082\n\u22a2 e\u2081 = e\u2082"}, {"line": "cases e\u2081", "tactic_state": "case mk\n\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ne\u2082 : ENormedSpace \ud835\udd5c V\ntoFun\u271d : V \u2192 ENNReal\neq_zero'\u271d : \u2200 (x : V), toFun\u271d x = 0 \u2192 x = 0\nmap_add_le'\u271d : \u2200 (x y : V), toFun\u271d (x + y) \u2264 toFun\u271d x + toFun\u271d y\nmap_smul_le'\u271d : \u2200 (c : \ud835\udd5c) (x : V), toFun\u271d (c \u2022 x) \u2264 \u2191\u2016c\u2016\u208a * toFun\u271d x\nh : \u2191{ toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d } = \u2191e\u2082\n\u22a2 { toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d } = e\u2082"}, {"line": "cases e\u2082", "tactic_state": "case mk.mk\n\ud835\udd5c : Type u_1\nV : Type u_2\ninst\u271d\u00b2 : NormedField \ud835\udd5c\ninst\u271d\u00b9 : AddCommGroup V\ninst\u271d : Module \ud835\udd5c V\ntoFun\u271d\u00b9 : V \u2192 ENNReal\neq_zero'\u271d\u00b9 : \u2200 (x : V), toFun\u271d\u00b9 x = 0 \u2192 x = 0\nmap_add_le'\u271d\u00b9 : \u2200 (x y : V), toFun\u271d\u00b9 (x + y) \u2264 toFun\u271d\u00b9 x + toFun\u271d\u00b9 y\nmap_smul_le'\u271d\u00b9 : \u2200 (c : \ud835\udd5c) (x : V), toFun\u271d\u00b9 (c \u2022 x) \u2264 \u2191\u2016c\u2016\u208a * toFun\u271d\u00b9 x\ntoFun\u271d : V \u2192 ENNReal\neq_zero'\u271d : \u2200 (x : V), toFun\u271d x = 0 \u2192 x = 0\nmap_add_le'\u271d : \u2200 (x y : V), toFun\u271d (x + y) \u2264 toFun\u271d x + toFun\u271d y\nmap_smul_le'\u271d : \u2200 (c : \ud835\udd5c) (x : V), toFun\u271d (c \u2022 x) \u2264 \u2191\u2016c\u2016\u208a * toFun\u271d x\nh :\n  \u2191{ toFun := toFun\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, map_add_le' := map_add_le'\u271d\u00b9, map_smul_le' := map_smul_le'\u271d\u00b9 } =\n    \u2191{ toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d }\n\u22a2 { toFun := toFun\u271d\u00b9, eq_zero' := eq_zero'\u271d\u00b9, map_add_le' := map_add_le'\u271d\u00b9, map_smul_le' := map_smul_le'\u271d\u00b9 } =\n    { toFun := toFun\u271d, eq_zero' := eq_zero'\u271d, map_add_le' := map_add_le'\u271d, map_smul_le' := map_smul_le'\u271d }"}, {"line": "congr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendstoUniformly_tsum_of_cofinite_eventually {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2 \u2192 F} {u : \u03b9 \u2192 \u211d}\n    (hu : Summable u) (hfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 x : \u03b2, \u2016f n x\u2016 \u2264 u n) :\n    TendstoUniformly (fun t x => \u2211 n \u2208 t, f n x) (fun x => \u2211' n, f n x) atTop := by\n  rw [\u2190 tendstoUniformlyOn_univ]\n  apply tendstoUniformlyOn_tsum_of_cofinite_eventually hu\n  simpa using hfu\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/FunctionSeries.lean", "context": {"open": ["Set Metric TopologicalSpace Function Filter", "scoped Topology NNReal"], "variables": ["{\u03b1 \u03b2 F : Type*} [NormedAddCommGroup F] [CompleteSpace F] {u : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\nhfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 TendstoUniformly (fun t x => \u2211 n \u2208 t, f n x) (fun x => \u2211' (n : \u03b9), f n x) atTop"}, {"line": "rw [\u2190 tendstoUniformlyOn_univ]", "tactic_state": "\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\nhfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 TendstoUniformlyOn (fun t x => \u2211 n \u2208 t, f n x) (fun x => \u2211' (n : \u03b9), f n x) atTop univ"}, {"line": "apply tendstoUniformlyOn_tsum_of_cofinite_eventually hu", "tactic_state": "\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\nhfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 x \u2208 univ, \u2016f n x\u2016 \u2264 u n\n---\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\nhfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 CompleteSpace F"}, {"line": "simpa using hfu", "tactic_state": "\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b9 : NormedAddCommGroup F\ninst\u271d : CompleteSpace F\n\u03b9 : Type u_4\nf : \u03b9 \u2192 \u03b2 \u2192 F\nu : \u03b9 \u2192 \u211d\nhu : Summable u\nhfu : \u2200\u1da0 (n : \u03b9) in cofinite, \u2200 (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 CompleteSpace F"}]}
{"declaration": "theorem continuous_tsum [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2 \u2192 F} (hf : \u2200 i, Continuous (f i))\n    (hu : Summable u) (hfu : \u2200 n x, \u2016f n x\u2016 \u2264 u n) : Continuous fun x => \u2211' n, f n x := by\n  simp_rw [continuous_iff_continuousOn_univ] at hf \u22a2\n  exact continuousOn_tsum hf hu fun n x _ => hfu n x", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/FunctionSeries.lean", "context": {"open": ["Set Metric TopologicalSpace Function Filter", "scoped Topology NNReal"], "variables": ["{\u03b1 \u03b2 F : Type*} [NormedAddCommGroup F] [CompleteSpace F] {u : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : CompleteSpace F\nu : \u03b1 \u2192 \u211d\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 F\nhf : \u2200 (i : \u03b1), Continuous (f i)\nhu : Summable u\nhfu : \u2200 (n : \u03b1) (x : \u03b2), \u2016f n x\u2016 \u2264 u n\n\u22a2 Continuous fun x => \u2211' (n : \u03b1), f n x"}, {"line": "simp_rw [continuous_iff_continuousOn_univ] at hf \u22a2", "tactic_state": "\u03b1 : Type u_1\n\u03b2 : Type u_2\nF : Type u_3\ninst\u271d\u00b2 : NormedAddCommGroup F\ninst\u271d\u00b9 : CompleteSpace F\nu : \u03b1 \u2192 \u211d\ninst\u271d : TopologicalSpace \u03b2\nf : \u03b1 \u2192 \u03b2 \u2192 F\nhu : Summable u\nhfu : \u2200 (n : \u03b1) (x : \u03b2), \u2016f n x\u2016 \u2264 u n\nhf : \u2200 (i : \u03b1), ContinuousOn (f i) univ\n\u22a2 ContinuousOn (fun x => \u2211' (n : \u03b1), f n x) univ"}, {"line": "exact continuousOn_tsum hf hu fun n x _ => hfu n x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_unitBall_of_pos {r : \u211d} (hr : 0 < r) : r \u2022 ball (0 : E) 1 = ball (0 : E) r := by\n  rw [smul_unitBall hr.ne']\n  rw [Real.norm_of_nonneg hr.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nhr : 0 < r\n\u22a2 r \u2022 ball 0 1 = ball 0 r"}, {"line": "rw [smul_unitBall hr.ne']", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nr : \u211d\nhr : 0 < r\n\u22a2 ball 0 \u2016r\u2016 = ball 0 r"}, {"line": "rw [Real.norm_of_nonneg hr.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem disjoint_closedBall_ball_iff (h\u03b4 : 0 \u2264 \u03b4) (h\u03b5 : 0 < \u03b5) :\n    Disjoint (closedBall x \u03b4) (ball y \u03b5) \u2194 \u03b4 + \u03b5 \u2264 dist x y := by\n  rw [disjoint_comm]\n  rw [disjoint_ball_closedBall_iff h\u03b5 h\u03b4]\n  rw [add_comm]\n  rw [dist_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 Disjoint (closedBall x \u03b4) (ball y \u03b5) \u2194 \u03b4 + \u03b5 \u2264 dist x y"}, {"line": "rw [disjoint_comm]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 Disjoint (ball y \u03b5) (closedBall x \u03b4) \u2194 \u03b4 + \u03b5 \u2264 dist x y"}, {"line": "rw [disjoint_ball_closedBall_iff h\u03b5 h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 \u03b5 + \u03b4 \u2264 dist y x \u2194 \u03b4 + \u03b5 \u2264 dist x y\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [add_comm]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 \u03b4 + \u03b5 \u2264 dist y x \u2194 \u03b4 + \u03b5 \u2264 dist x y\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [dist_comm]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nx y : E\n\u03b4 \u03b5 : \u211d\nh\u03b4 : 0 \u2264 \u03b4\nh\u03b5 : 0 < \u03b5\n\u22a2 NormedSpace \u211d E"}]}
{"declaration": "theorem infEdist_cthickening (\u03b4 : \u211d) (s : Set E) (x : E) :\n    infEdist x (cthickening \u03b4 s) = infEdist x s - ENNReal.ofReal \u03b4 := by\n  obtain h\u03b4 | h\u03b4 := le_or_lt \u03b4 0\n  \u00b7 rw [cthickening_of_nonpos h\u03b4, infEdist_closure, ofReal_of_nonpos h\u03b4, tsub_zero]\n  \u00b7 rw [\u2190 closure_thickening h\u03b4, infEdist_closure, infEdist_thickening h\u03b4]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 : \u211d\ns : Set E\nx : E\n\u22a2 infEdist x (cthickening \u03b4 s) = infEdist x s - ENNReal.ofReal \u03b4"}, {"line": "obtain h\u03b4 | h\u03b4 := le_or_lt \u03b4 0", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 : \u211d\ns : Set E\nx : E\nh\u03b4 : \u03b4 \u2264 0\n\u22a2 infEdist x (cthickening \u03b4 s) = infEdist x s - ENNReal.ofReal \u03b4\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 : \u211d\ns : Set E\nx : E\nh\u03b4 : 0 < \u03b4\n\u22a2 infEdist x (cthickening \u03b4 s) = infEdist x s - ENNReal.ofReal \u03b4"}, {"line": "\u00b7 rw [cthickening_of_nonpos h\u03b4, infEdist_closure, ofReal_of_nonpos h\u03b4, tsub_zero]", "tactic_state": "case inr\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 : \u211d\ns : Set E\nx : E\nh\u03b4 : 0 < \u03b4\n\u22a2 infEdist x (cthickening \u03b4 s) = infEdist x s - ENNReal.ofReal \u03b4"}, {"line": "\u00b7 rw [\u2190 closure_thickening h\u03b4, infEdist_closure, infEdist_thickening h\u03b4]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickening_cthickening (h\u03b5 : 0 < \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (s : Set E) :\n    thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s := by\n  obtain rfl | h\u03b4 := h\u03b4.eq_or_lt\n  \u00b7 rw [cthickening_zero, thickening_closure, add_zero]\n  \u00b7 rw [\u2190 closure_thickening h\u03b4, thickening_closure, thickening_thickening h\u03b5 h\u03b4]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\ns : Set E\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s"}, {"line": "obtain rfl | h\u03b4 := h\u03b4.eq_or_lt", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\ns : Set E\nh\u03b4 : 0 \u2264 0\n\u22a2 thickening \u03b5 (cthickening 0 s) = thickening (\u03b5 + 0) s\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4\u271d : 0 \u2264 \u03b4\ns : Set E\nh\u03b4 : 0 < \u03b4\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s"}, {"line": "\u00b7 rw [cthickening_zero, thickening_closure, add_zero]", "tactic_state": "case inr\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4\u271d : 0 \u2264 \u03b4\ns : Set E\nh\u03b4 : 0 < \u03b4\n\u22a2 thickening \u03b5 (cthickening \u03b4 s) = thickening (\u03b5 + \u03b4) s"}, {"line": "\u00b7 rw [\u2190 closure_thickening h\u03b4, thickening_closure, thickening_thickening h\u03b5 h\u03b4]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem thickening_ball (h\u03b5 : 0 < \u03b5) (h\u03b4 : 0 < \u03b4) (x : E) :\n    thickening \u03b5 (ball x \u03b4) = ball x (\u03b5 + \u03b4) := by\n  rw [\u2190 thickening_singleton]\n  rw [thickening_thickening h\u03b5 h\u03b4]\n  rw [thickening_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 thickening \u03b5 (Metric.ball x \u03b4) = Metric.ball x (\u03b5 + \u03b4)"}, {"line": "rw [\u2190 thickening_singleton]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 thickening \u03b5 (thickening \u03b4 {x}) = Metric.ball x (\u03b5 + \u03b4)"}, {"line": "rw [thickening_thickening h\u03b5 h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 thickening (\u03b5 + \u03b4) {x} = Metric.ball x (\u03b5 + \u03b4)\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [thickening_singleton]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}]}
{"declaration": "theorem thickening_closedBall (h\u03b5 : 0 < \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (x : E) :\n    thickening \u03b5 (closedBall x \u03b4) = ball x (\u03b5 + \u03b4) := by\n  rw [\u2190 cthickening_singleton _ h\u03b4]\n  rw [thickening_cthickening h\u03b5 h\u03b4]\n  rw [thickening_singleton]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 thickening \u03b5 (Metric.closedBall x \u03b4) = Metric.ball x (\u03b5 + \u03b4)"}, {"line": "rw [\u2190 cthickening_singleton _ h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 thickening \u03b5 (cthickening \u03b4 {x}) = Metric.ball x (\u03b5 + \u03b4)"}, {"line": "rw [thickening_cthickening h\u03b5 h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 thickening (\u03b5 + \u03b4) {x} = Metric.ball x (\u03b5 + \u03b4)\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [thickening_singleton]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}]}
{"declaration": "theorem cthickening_ball (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 < \u03b4) (x : E) :\n    cthickening \u03b5 (ball x \u03b4) = closedBall x (\u03b5 + \u03b4) := by\n  rw [\u2190 thickening_singleton]\n  rw [cthickening_thickening h\u03b5 h\u03b4]\n  rw [cthickening_singleton _ (add_nonneg h\u03b5 h\u03b4.le)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 cthickening \u03b5 (Metric.ball x \u03b4) = Metric.closedBall x (\u03b5 + \u03b4)"}, {"line": "rw [\u2190 thickening_singleton]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 cthickening \u03b5 (thickening \u03b4 {x}) = Metric.closedBall x (\u03b5 + \u03b4)"}, {"line": "rw [cthickening_thickening h\u03b5 h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 cthickening (\u03b5 + \u03b4) {x} = Metric.closedBall x (\u03b5 + \u03b4)\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [cthickening_singleton _ (add_nonneg h\u03b5 h\u03b4.le)]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 < \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}]}
{"declaration": "theorem cthickening_closedBall (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (x : E) :\n    cthickening \u03b5 (closedBall x \u03b4) = closedBall x (\u03b5 + \u03b4) := by\n  rw [\u2190 cthickening_singleton _ h\u03b4]\n  rw [cthickening_cthickening h\u03b5 h\u03b4]\n  rw [cthickening_singleton _ (add_nonneg h\u03b5 h\u03b4)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 cthickening \u03b5 (Metric.closedBall x \u03b4) = Metric.closedBall x (\u03b5 + \u03b4)"}, {"line": "rw [\u2190 cthickening_singleton _ h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 cthickening \u03b5 (cthickening \u03b4 {x}) = Metric.closedBall x (\u03b5 + \u03b4)"}, {"line": "rw [cthickening_cthickening h\u03b5 h\u03b4]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 cthickening (\u03b5 + \u03b4) {x} = Metric.closedBall x (\u03b5 + \u03b4)\n---\nE : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}, {"line": "rw [cthickening_singleton _ (add_nonneg h\u03b5 h\u03b4)]", "tactic_state": "E : Type u_2\ninst\u271d\u00b3 inst\u271d\u00b2 inst\u271d\u00b9 : SeminormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\n\u03b4 \u03b5 : \u211d\nh\u03b5 : 0 \u2264 \u03b5\nh\u03b4 : 0 \u2264 \u03b4\nx : E\n\u22a2 NormedSpace \u211d E"}]}
{"declaration": "theorem smul_closedBall (c : \ud835\udd5c) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    c \u2022 closedBall x r = closedBall (c \u2022 x) (\u2016c\u2016 * r) := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  \u00b7 simp [hr, zero_smul_set, Set.singleton_zero, nonempty_closedBall]\n  \u00b7 exact smul_closedBall' hc x r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u2070 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2079 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u2078 : SeminormedAddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 c \u2022 Metric.closedBall x r = Metric.closedBall (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "rcases eq_or_ne c 0 with (rfl | hc)", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u2070 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2079 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u2078 : SeminormedAddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 sorry \u2022 Metric.closedBall x r = Metric.closedBall (sorry \u2022 x) (\u2016sorry\u2016 * r)\n---\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u2070 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2079 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u2078 : SeminormedAddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\nhc : c \u2260 sorry\n\u22a2 c \u2022 Metric.closedBall x r = Metric.closedBall (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "\u00b7 simp [hr, zero_smul_set, Set.singleton_zero, nonempty_closedBall]", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u00b2 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b9 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u2070 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2079 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u2078 : SeminormedAddCommGroup E\ninst\u271d\u2077 : Module \ud835\udd5c E\ninst\u271d\u2076 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2075 : NormedField \ud835\udd5c\ninst\u271d\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b2 : NormedSpace \u211d E\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \ud835\udd5c E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\nhc : c \u2260 sorry\n\u22a2 c \u2022 Metric.closedBall x r = Metric.closedBall (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "\u00b7 exact smul_closedBall' hc x r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem smul_sphere [Nontrivial E] (c : \ud835\udd5c) (x : E) {r : \u211d} (hr : 0 \u2264 r) :\n    c \u2022 sphere x r = sphere (c \u2022 x) (\u2016c\u2016 * r) := by\n  rcases eq_or_ne c 0 with (rfl | hc)\n  \u00b7 simp [zero_smul_set, Set.singleton_zero, hr]\n  \u00b7 exact smul_sphere' hc x r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Pointwise.lean", "context": {"open": ["Metric Set", "Pointwise Topology", "EMetric ENNReal"], "variables": ["{\ud835\udd5c E : Type*}", "[SeminormedAddCommGroup \ud835\udd5c] [SeminormedAddCommGroup E]", "[SMulZeroClass \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedDivisionRing \ud835\udd5c] [SeminormedAddCommGroup E]", "[Module \ud835\udd5c E] [IsBoundedSMul \ud835\udd5c E]", "[NormedField \ud835\udd5c]", "[SeminormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E] {x y z : E} {\u03b4 \u03b5 : \u211d}", "[NormedAddCommGroup E] [NormedSpace \ud835\udd5c E]", "[NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b3 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : SeminormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 c \u2022 sphere x r = sphere (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "rcases eq_or_ne c 0 with (rfl | hc)", "tactic_state": "case inl\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b3 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : SeminormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\nhr : 0 \u2264 r\n\u22a2 sorry \u2022 sphere x r = sphere (sorry \u2022 x) (\u2016sorry\u2016 * r)\n---\ncase inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b3 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : SeminormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\nhc : c \u2260 sorry\n\u22a2 c \u2022 sphere x r = sphere (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "\u00b7 simp [zero_smul_set, Set.singleton_zero, hr]", "tactic_state": "case inr\n\ud835\udd5c : Type u_1\nE : Type u_2\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup \ud835\udd5c\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\ninst\u271d\u00b9\u00b3 : SMulZeroClass \ud835\udd5c E\ninst\u271d\u00b9\u00b2 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u00b9\u00b9 : NormedDivisionRing \ud835\udd5c\ninst\u271d\u00b9\u2070 : SeminormedAddCommGroup E\ninst\u271d\u2079 : Module \ud835\udd5c E\ninst\u271d\u2078 : IsBoundedSMul \ud835\udd5c E\ninst\u271d\u2077 : NormedField \ud835\udd5c\ninst\u271d\u2076 : SeminormedAddCommGroup E\ninst\u271d\u2075 : NormedSpace \ud835\udd5c E\ninst\u271d\u2074 : NormedSpace \u211d E\ninst\u271d\u00b3 : NormedAddCommGroup E\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nc : \ud835\udd5c\nx : E\nr : \u211d\nhr : 0 \u2264 r\nhc : c \u2260 sorry\n\u22a2 c \u2022 sphere x r = sphere (c \u2022 x) (\u2016c\u2016 * r)"}, {"line": "\u00b7 exact smul_sphere' hc x r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem interior_closedBall' (x : E) (r : \u211d) : interior (closedBall x r) = ball x r := by\n  rcases eq_or_ne r 0 with (rfl | hr)\n  \u00b7 rw [closedBall_zero, ball_zero, interior_singleton]\n  \u00b7 exact interior_closedBall x hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Real.lean", "context": {"open": ["Metric Set Function Filter", "scoped NNReal Topology"], "variables": ["{E : Type*} [SeminormedAddCommGroup E] [NormedSpace \u211d E]", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [Nontrivial E]", "(E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\n\u22a2 interior (closedBall x r) = ball x r"}, {"line": "rcases eq_or_ne r 0 with (rfl | hr)", "tactic_state": "case inl\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\n\u22a2 interior (closedBall x 0) = ball x 0\n---\ncase inr\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\nhr : r \u2260 0\n\u22a2 interior (closedBall x r) = ball x r"}, {"line": "\u00b7 rw [closedBall_zero, ball_zero, interior_singleton]", "tactic_state": "case inr\nE : Type u_2\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace \u211d E\ninst\u271d : Nontrivial E\nx : E\nr : \u211d\nhr : r \u2260 0\n\u22a2 interior (closedBall x r) = ball x r"}, {"line": "\u00b7 exact interior_closedBall x hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_mkPiAlgebraFin_le :\n    \u2016ContinuousMultilinearMap.mkPiAlgebraFin \ud835\udd5c n A\u2016 \u2264 max 1 \u2016(1 : A)\u2016 := by\n  cases n\n  \u00b7 exact norm_mkPiAlgebraFin_zero.le.trans (le_max_right _ _)\n  \u00b7 exact (norm_mkPiAlgebraFin_le_of_pos (Nat.zero_lt_succ _)).trans (le_max_left _ _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "context": {"open": ["scoped NNReal Topology Uniformity", "Finset Metric Function Filter", "Real"], "variables": ["{\ud835\udd5c \u03b9 : Type*} {E : \u03b9 \u2192 Type*} {F : Type*}", "{G : Type*} [AddCommGroup G] [TopologicalSpace G] [Module \ud835\udd5c G] [ContinuousConstSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {E : \u03b9 \u2192 Type wE} {E\u2081 : \u03b9 \u2192 Type wE\u2081}", "[Fintype \u03b9]", "[Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' G] [SMulCommClass \ud835\udd5c \ud835\udd5c' G]", "(\ud835\udd5c E G) in", "(\ud835\udd5c G)", "{G} (E)", "(\ud835\udd5c E E' G G')", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c' \ud835\udd5c]", "[NormedSpace \ud835\udd5c' G] [IsScalarTower \ud835\udd5c' \ud835\udd5c G]", "[\u2200 i, NormedSpace \ud835\udd5c' (E i)] [\u2200 i, IsScalarTower \ud835\udd5c' \ud835\udd5c (E i)]", "(\ud835\udd5c')", "[Fintype \u03b9]", "{A : Type*} [NormedCommRing A] [NormedAlgebra \ud835\udd5c A]", "{n : \u2115} {A : Type*} [SeminormedRing A] [NormedAlgebra \ud835\udd5c A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u\nn : \u2115\nA : Type u_5\n\u22a2 \u2016sorry\u2016 \u2264 max 1 sorry"}, {"line": "cases n", "tactic_state": "case zero\n\ud835\udd5c : Type u\nA : Type u_5\n\u22a2 \u2016sorry\u2016 \u2264 max 1 sorry\n---\ncase succ\n\ud835\udd5c : Type u\nA : Type u_5\nn\u271d : \u2115\n\u22a2 \u2016sorry\u2016 \u2264 max 1 sorry"}, {"line": "\u00b7 exact norm_mkPiAlgebraFin_zero.le.trans (le_max_right _ _)", "tactic_state": "case succ\n\ud835\udd5c : Type u\nA : Type u_5\nn\u271d : \u2115\n\u22a2 \u2016sorry\u2016 \u2264 max 1 sorry"}, {"line": "\u00b7 exact (norm_mkPiAlgebraFin_le_of_pos (Nat.zero_lt_succ _)).trans (le_max_left _ _)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_compContinuousLinearMap_le (g : ContinuousMultilinearMap \ud835\udd5c E\u2081 G)\n    (f : \u2200 i, E i \u2192L[\ud835\udd5c] E\u2081 i) : \u2016g.compContinuousLinearMap f\u2016 \u2264 \u2016g\u2016 * \u220f i, \u2016f i\u2016 :=\n  opNorm_le_bound (by positivity) fun m =>\n    calc\n      \u2016g fun i => f i (m i)\u2016 \u2264 \u2016g\u2016 * \u220f i, \u2016f i (m i)\u2016 := g.le_opNorm _\n      _ \u2264 \u2016g\u2016 * \u220f i, \u2016f i\u2016 * \u2016m i\u2016 :=\n        (mul_le_mul_of_nonneg_left\n          (prod_le_prod (fun _ _ => norm_nonneg _) fun i _ => (f i).le_opNorm (m i))\n          (norm_nonneg g))\n      _ = (\u2016g\u2016 * \u220f i, \u2016f i\u2016) * \u220f i, \u2016m i\u2016 := by rw [prod_mul_distrib, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "context": {"open": ["scoped NNReal Topology Uniformity", "Finset Metric Function Filter", "Real", "ContinuousMultilinearMap"], "variables": ["{\ud835\udd5c \u03b9 : Type*} {E : \u03b9 \u2192 Type*} {F : Type*}", "{G : Type*} [AddCommGroup G] [TopologicalSpace G] [Module \ud835\udd5c G] [ContinuousConstSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {E : \u03b9 \u2192 Type wE} {E\u2081 : \u03b9 \u2192 Type wE\u2081}", "[Fintype \u03b9]", "[Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' G] [SMulCommClass \ud835\udd5c \ud835\udd5c' G]", "(\ud835\udd5c E G) in", "(\ud835\udd5c G)", "{G} (E)", "(\ud835\udd5c E E' G G')", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c' \ud835\udd5c]", "[NormedSpace \ud835\udd5c' G] [IsScalarTower \ud835\udd5c' \ud835\udd5c G]", "[\u2200 i, NormedSpace \ud835\udd5c' (E i)] [\u2200 i, IsScalarTower \ud835\udd5c' \ud835\udd5c (E i)]", "(\ud835\udd5c')", "[Fintype \u03b9]", "{A : Type*} [NormedCommRing A] [NormedAlgebra \ud835\udd5c A]", "{n : \u2115} {A : Type*} [SeminormedRing A] [NormedAlgebra \ud835\udd5c A]", "(\ud835\udd5c E G) in", "(\ud835\udd5c \u03b9 G)", "(\ud835\udd5c E G G')", "{\ud835\udd5c G G'}", "{E}", "[\u2200 i, SeminormedAddCommGroup (E' i)] [\u2200 i, NormedSpace \ud835\udd5c (E' i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : Fintype \u03b9\ng : sorry\nf : \u03b9 \u2192 sorry\nm : (i : \u03b9) \u2192 ?m.11682 i\n\u22a2 sorry * \u220f i, sorry * \u2016m i\u2016 = (sorry * \u220f i, sorry) * \u220f i, \u2016m i\u2016"}, {"line": "rw [prod_mul_distrib, mul_assoc]", "tactic_state": "\u03b9 : Type v\ninst\u271d\u00b2 inst\u271d\u00b9 inst\u271d : Fintype \u03b9\ng : sorry\nf : \u03b9 \u2192 sorry\n\u22a2 \u03b9 \u2192 Type ?u.11677"}]}
{"declaration": "theorem opNorm_zero_iff {f : ContinuousMultilinearMap \ud835\udd5c E G} : \u2016f\u2016 = 0 \u2194 f = 0 := by\n  simp [\u2190 (opNorm_nonneg f).le_iff_eq, opNorm_le_iff le_rfl, ContinuousMultilinearMap.ext_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Basic.lean", "context": {"open": ["scoped NNReal Topology Uniformity", "Finset Metric Function Filter", "Real", "ContinuousMultilinearMap", "Function in", "Classical in"], "variables": ["{\ud835\udd5c \u03b9 : Type*} {E : \u03b9 \u2192 Type*} {F : Type*}", "{G : Type*} [AddCommGroup G] [TopologicalSpace G] [Module \ud835\udd5c G] [ContinuousConstSMul \ud835\udd5c F]", "{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {E : \u03b9 \u2192 Type wE} {E\u2081 : \u03b9 \u2192 Type wE\u2081}", "[Fintype \u03b9]", "[Fintype \u03b9]", "{\ud835\udd5c' : Type*} [NormedField \ud835\udd5c'] [NormedSpace \ud835\udd5c' G] [SMulCommClass \ud835\udd5c \ud835\udd5c' G]", "(\ud835\udd5c E G) in", "(\ud835\udd5c G)", "{G} (E)", "(\ud835\udd5c E E' G G')", "{\ud835\udd5c' : Type*} [NontriviallyNormedField \ud835\udd5c'] [NormedAlgebra \ud835\udd5c' \ud835\udd5c]", "[NormedSpace \ud835\udd5c' G] [IsScalarTower \ud835\udd5c' \ud835\udd5c G]", "[\u2200 i, NormedSpace \ud835\udd5c' (E i)] [\u2200 i, IsScalarTower \ud835\udd5c' \ud835\udd5c (E i)]", "(\ud835\udd5c')", "[Fintype \u03b9]", "{A : Type*} [NormedCommRing A] [NormedAlgebra \ud835\udd5c A]", "{n : \u2115} {A : Type*} [SeminormedRing A] [NormedAlgebra \ud835\udd5c A]", "(\ud835\udd5c E G) in", "(\ud835\udd5c \u03b9 G)", "(\ud835\udd5c E G G')", "{\ud835\udd5c G G'}", "{E}", "[\u2200 i, SeminormedAddCommGroup (E' i)] [\u2200 i, NormedSpace \ud835\udd5c (E' i)]", "(G) in", "(E) in", "(\ud835\udd5c E E\u2081 G)", "{\ud835\udd5c E E\u2081}", "{G}", "{\ud835\udd5c : Type u} {\u03b9 : Type v} {E : \u03b9 \u2192 Type wE} {G : Type wG} {G' : Type wG'} [Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\n\u22a2 sorry = 0 \u2194 f = 0"}, {"line": "simp [\u2190 (opNorm_nonneg f).le_iff_eq, opNorm_le_iff le_rfl, ContinuousMultilinearMap.ext_iff]", "tactic_state": "f : sorry\n\u22a2 sorry () = 0 \u2194 f = 0"}]}
{"declaration": "theorem ContinuousMultilinearMap.norm_map_cons_le (f : ContinuousMultilinearMap \ud835\udd5c Ei G) (x : Ei 0)\n    (m : \u2200 i : Fin n, Ei i.succ) : \u2016f (cons x m)\u2016 \u2264 \u2016f\u2016 * \u2016x\u2016 * \u220f i, \u2016m i\u2016 :=\n  calc\n    \u2016f (cons x m)\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016cons x m i\u2016 := f.le_opNorm _\n    _ = \u2016f\u2016 * \u2016x\u2016 * \u220f i, \u2016m i\u2016 := by\n      rw [prod_univ_succ]\n      simp [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "context": {"open": ["NNReal Finset Metric ContinuousMultilinearMap Fin Function"], "variables": ["{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {n : \u2115} {E : \u03b9 \u2192 Type wE}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nEi : Fin (n + 1) \u2192 Type u_1\nG : Type u_2\nf : sorry\nx : Ei 0\nm : (i : Fin n) \u2192 Ei i.succ\n\u22a2 sorry * \u220f i, sorry = sorry * sorry * \u220f i, sorry"}, {"line": "rw [prod_univ_succ]", "tactic_state": "n : \u2115\nEi : Fin (n + 1) \u2192 Type u_1\nG : Type u_2\nf : sorry\nx : Ei 0\nm : (i : Fin n) \u2192 Ei i.succ\n\u22a2 sorry * (sorry * \u220f i, sorry) = sorry * sorry * \u220f i, sorry"}, {"line": "simp [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousMultilinearMap.norm_map_snoc_le (f : ContinuousMultilinearMap \ud835\udd5c Ei G)\n    (m : \u2200 i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    \u2016f (snoc m x)\u2016 \u2264 (\u2016f\u2016 * \u220f i, \u2016m i\u2016) * \u2016x\u2016 :=\n  calc\n    \u2016f (snoc m x)\u2016 \u2264 \u2016f\u2016 * \u220f i, \u2016snoc m x i\u2016 := f.le_opNorm _\n    _ = (\u2016f\u2016 * \u220f i, \u2016m i\u2016) * \u2016x\u2016 := by\n      rw [prod_univ_castSucc]\n      simp [mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "context": {"open": ["NNReal Finset Metric ContinuousMultilinearMap Fin Function"], "variables": ["{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {n : \u2115} {E : \u03b9 \u2192 Type wE}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nEi : Fin (n + 1) \u2192 Type u_1\nG : Type u_2\nf : sorry\nm : (i : Fin n) \u2192 Ei i.castSucc\nx : Ei (last n)\n\u22a2 sorry * \u220f i, sorry = (sorry * \u220f i, sorry) * sorry"}, {"line": "rw [prod_univ_castSucc]", "tactic_state": "n : \u2115\nEi : Fin (n + 1) \u2192 Type u_1\nG : Type u_2\nf : sorry\nm : (i : Fin n) \u2192 Ei i.castSucc\nx : Ei (last n)\n\u22a2 sorry * ((\u220f i, sorry) * sorry) = (sorry * \u220f i, sorry) * sorry"}, {"line": "simp [mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContinuousMultilinearMap.uncurry0_curry0 (f : G [\u00d70]\u2192L[\ud835\udd5c] G') :\n    ContinuousMultilinearMap.uncurry0 \ud835\udd5c G f.curry0 = f := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "context": {"open": ["NNReal Finset Metric ContinuousMultilinearMap Fin Function"], "variables": ["{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {n : \u2115} {E : \u03b9 \u2192 Type wE}", "(\ud835\udd5c Ei G)", "{\ud835\udd5c Ei G}", "(\ud835\udd5c Ei G)", "(n G')", "{n \ud835\udd5c G Ei G'}", "(\ud835\udd5c G) in", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\n\u22a2 sorry = f"}, {"line": "simp", "tactic_state": "f : sorry\n\u22a2 sorry () = f"}]}
{"declaration": "theorem ContinuousMultilinearMap.curry0_norm (f : G [\u00d70]\u2192L[\ud835\udd5c] G') : \u2016f.curry0\u2016 = \u2016f\u2016 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/Multilinear/Curry.lean", "context": {"open": ["NNReal Finset Metric ContinuousMultilinearMap Fin Function"], "variables": ["{\ud835\udd5c : Type u} {\u03b9 : Type v} {\u03b9' : Type v'} {n : \u2115} {E : \u03b9 \u2192 Type wE}", "(\ud835\udd5c Ei G)", "{\ud835\udd5c Ei G}", "(\ud835\udd5c Ei G)", "(n G')", "{n \ud835\udd5c G Ei G'}", "(\ud835\udd5c G) in", "(\ud835\udd5c) in", "(\ud835\udd5c G) in", "(\ud835\udd5c G) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : sorry\n\u22a2 \u2016sorry\u2016 = sorry"}, {"line": "simp", "tactic_state": "f : sorry\n\u22a2 \u2016sorry ()\u2016 = sorry ()"}]}
{"declaration": "theorem exists_lt_apply_of_lt_opNorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) {r : \u211d}\n    (hr : r < \u2016f\u2016) : \u2203 x : E, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016 := by\n  by_cases hr\u2080 : r < 0\n  \u00b7 exact \u27e80, by simpa using hr\u2080\u27e9\n  \u00b7 lift r to \u211d\u22650 using not_lt.1 hr\u2080\n    exact f.exists_lt_apply_of_lt_opNNNorm hr\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/OperatorNorm/NNNorm.lean", "context": {"open": ["Bornology", "Filter hiding map_smul", "scoped NNReal Topology Uniformity", "Metric ContinuousLinearMap", "Set Real"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 E E\u2097 F F\u2097 G G\u2097 \ud835\udcd5 : Type*}", "[SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2097] [SeminormedAddCommGroup F]", "[NontriviallyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] [NontriviallyNormedField \ud835\udd5c\u2083]", "[FunLike \ud835\udcd5 E F]", "[RingHomIsometric \u03c3\u2081\u2082] [RingHomIsometric \u03c3\u2082\u2083] (f g : E \u2192SL[\u03c3\u2081\u2082] F) (h : F \u2192SL[\u03c3\u2082\u2083] G)", "[RingHomIsometric \u03c3\u2081\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\nhr : r < \u2016f\u2016\n\u22a2 \u2203 x, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016"}, {"line": "by_cases hr\u2080 : r < 0", "tactic_state": "case pos\n\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\nhr : r < \u2016f\u2016\nhr\u2080 : r < 0\n\u22a2 \u2203 x, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016\n---\ncase neg\n\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\nhr : r < \u2016f\u2016\nhr\u2080 : \u00acr < 0\n\u22a2 \u2203 x, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016"}, {"line": "\u00b7 exact \u27e80, by simpa using hr\u2080\u27e9", "tactic_state": "case neg\n\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nr : \u211d\nhr : r < \u2016f\u2016\nhr\u2080 : \u00acr < 0\n\u22a2 \u2203 x, \u2016x\u2016 < 1 \u2227 r < \u2016f x\u2016"}, {"line": "\u00b7 lift r to \u211d\u22650 using not_lt.1 hr\u2080\n    exact f.exists_lt_apply_of_lt_opNNNorm hr", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sSup_unitClosedBall_eq_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type*} [NormedAddCommGroup E]\n    [SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n    [NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\n    sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a := by\n  have hbdd : \u2200 y \u2208 (fun x => \u2016f x\u2016\u208a) '' closedBall 0 1, y \u2264 \u2016f\u2016\u208a := by\n    rintro - \u27e8x, hx, rfl\u27e9\n    exact f.unit_le_opNorm x (mem_closedBall_zero_iff.1 hx)\n  refine le_antisymm (csSup_le ((nonempty_closedBall.mpr zero_le_one).image _) hbdd) ?_\n  rw [\u2190 sSup_unit_ball_eq_nnnorm]\n  exact csSup_le_csSup \u27e8\u2016f\u2016\u208a, hbdd\u27e9 ((nonempty_ball.2 zero_lt_one).image _)\n    (Set.image_subset _ ball_subset_closedBall)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/OperatorNorm/NNNorm.lean", "context": {"open": ["Bornology", "Filter hiding map_smul", "scoped NNReal Topology Uniformity", "Metric ContinuousLinearMap", "Set Real"], "variables": ["{\ud835\udd5c \ud835\udd5c\u2082 \ud835\udd5c\u2083 E E\u2097 F F\u2097 G G\u2097 \ud835\udcd5 : Type*}", "[SeminormedAddCommGroup E] [SeminormedAddCommGroup E\u2097] [SeminormedAddCommGroup F]", "[NontriviallyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] [NontriviallyNormedField \ud835\udd5c\u2083]", "[FunLike \ud835\udcd5 E F]", "[RingHomIsometric \u03c3\u2081\u2082] [RingHomIsometric \u03c3\u2082\u2083] (f g : E \u2192SL[\u03c3\u2081\u2082] F) (h : F \u2192SL[\u03c3\u2082\u2083] G)", "[RingHomIsometric \u03c3\u2081\u2082]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\n\u22a2 sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a"}, {"line": "have hbdd : \u2200 y \u2208 (fun x => \u2016f x\u2016\u208a) '' closedBall 0 1, y \u2264 \u2016f\u2016\u208a := by\n    rintro - \u27e8x, hx, rfl\u27e9\n    exact f.unit_le_opNorm x (mem_closedBall_zero_iff.1 hx)", "tactic_state": "\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nhbdd : \u2200 y \u2208 (fun x => sorry) '' sorry, y \u2264 sorry\n\u22a2 sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a"}, {"line": "refine le_antisymm (csSup_le ((nonempty_closedBall.mpr zero_le_one).image _) hbdd) ?_", "tactic_state": "\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nhbdd : \u2200 y \u2208 (fun x => sorry) '' sorry, y \u2264 sorry\n\u22a2 \u2016f\u2016\u208a \u2264 sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1)"}, {"line": "rw [\u2190 sSup_unit_ball_eq_nnnorm]", "tactic_state": "\u03c3\u2081\u2082\u271d : ?m.38927 \u2192+* ?m.38928\n\u03c3\u2082\u2083 : ?m.40167 \u2192+* ?m.40168\n\ud835\udd5c\u271d : Type u_1\n\ud835\udd5c\u2082\u271d : Type u_2\n\ud835\udd5c\u2083 : Type u_3\nE\u271d : Type u_4\nE\u2097 : Type u_5\nF\u271d : Type u_6\nF\u2097 : Type u_7\nG : Type u_8\nG\u2097 : Type u_9\n\ud835\udcd5 : Type u_10\ninst\u271d\u00b9\u2075 : SeminormedAddCommGroup E\u271d\ninst\u271d\u00b9\u2074 : SeminormedAddCommGroup E\u2097\ninst\u271d\u00b9\u00b3 : SeminormedAddCommGroup F\u271d\ninst\u271d\u00b9\u00b2 : NontriviallyNormedField \ud835\udd5c\u271d\ninst\u271d\u00b9\u00b9 : NontriviallyNormedField \ud835\udd5c\u2082\u271d\ninst\u271d\u00b9\u2070 : NontriviallyNormedField \ud835\udd5c\u2083\ninst\u271d\u2079 : FunLike \ud835\udcd5 E\u271d F\u271d\ninst\u271d\u2078 : RingHomIsometric \u03c3\u2081\u2082\u271d\ninst\u271d\u2077 : RingHomIsometric \u03c3\u2082\u2083\nf\u271d : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\ng : E\u271d \u2192SL[\u03c3\u2081\u2082\u271d] F\u271d\nh : sorry\n\ud835\udd5c : Type u_11\n\ud835\udd5c\u2082 : Type u_12\nE : Type u_13\nF : Type u_14\ninst\u271d\u2076 : NormedAddCommGroup E\ninst\u271d\u2075 : SeminormedAddCommGroup F\ninst\u271d\u2074 : DenselyNormedField \ud835\udd5c\ninst\u271d\u00b3 : NontriviallyNormedField \ud835\udd5c\u2082\n\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082\ninst\u271d\u00b2 : NormedSpace \ud835\udd5c E\ninst\u271d\u00b9 : NormedSpace \ud835\udd5c\u2082 F\ninst\u271d : RingHomIsometric \u03c3\u2081\u2082\nf : E \u2192SL[\u03c3\u2081\u2082] F\nhbdd : \u2200 y \u2208 (fun x => sorry) '' sorry, y \u2264 sorry\n\u22a2 sSup ((fun x => \u2016f x\u2016\u208a) '' ball 0 1) \u2264 sSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1)"}, {"line": "exact csSup_le_csSup \u27e8\u2016f\u2016\u208a, hbdd\u27e9 ((nonempty_ball.2 zero_lt_one).image _)\n    (Set.image_subset _ ball_subset_closedBall)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem projectiveSeminormAux_add_le (p q : FreeAddMonoid (\ud835\udd5c \u00d7 \u03a0 i, E i)) :\n    projectiveSeminormAux (p + q) \u2264 projectiveSeminormAux p + projectiveSeminormAux q := by\n  simp [projectiveSeminormAux]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/PiTensorProduct/ProjectiveSeminorm.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{\u03b9 : Type u\u03b9} [Fintype \u03b9]", "{\ud835\udd5c : Type u\ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]", "{E : \u03b9 \u2192 Type uE} [\u2200 i, SeminormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\ud835\udd5c : Type u\ud835\udd5c\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : \u03b9 \u2192 Type uE\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\nx\u271d : Sort u_1\nprojectiveSeminormAux : x\u271d\np q : FreeAddMonoid (\ud835\udd5c \u00d7 ((i : \u03b9) \u2192 E i))\n\u22a2 sorry \u2264 sorry + sorry"}, {"line": "simp [projectiveSeminormAux]", "tactic_state": "\u03b9 : Type u\u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\ud835\udd5c : Type u\ud835\udd5c\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : \u03b9 \u2192 Type uE\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\nx\u271d : Sort u_1\nprojectiveSeminormAux : x\u271d\np q : FreeAddMonoid (\ud835\udd5c \u00d7 ((i : \u03b9) \u2192 E i))\n\u22a2 sorry () \u2264 sorry () + sorry ()"}]}
{"declaration": "theorem projectiveSeminormAux_smul (p : FreeAddMonoid (\ud835\udd5c \u00d7 \u03a0 i, E i)) (a : \ud835\udd5c) :\n    projectiveSeminormAux (p.map (fun (y : \ud835\udd5c \u00d7 \u03a0 i, E i) \u21a6 (a * y.1, y.2))) =\n    \u2016a\u2016 * projectiveSeminormAux p := by\n  simp [projectiveSeminormAux, Function.comp_def, mul_assoc, List.sum_map_mul_left]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/NormedSpace/PiTensorProduct/ProjectiveSeminorm.lean", "context": {"open": ["scoped TensorProduct"], "variables": ["{\u03b9 : Type u\u03b9} [Fintype \u03b9]", "{\ud835\udd5c : Type u\ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]", "{E : \u03b9 \u2192 Type uE} [\u2200 i, SeminormedAddCommGroup (E i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u\u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\ud835\udd5c : Type u\ud835\udd5c\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : \u03b9 \u2192 Type uE\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\nx\u271d : Sort u_1\nprojectiveSeminormAux : x\u271d\np : FreeAddMonoid (\ud835\udd5c \u00d7 ((i : \u03b9) \u2192 E i))\na : \ud835\udd5c\n\u22a2 sorry = \u2016a\u2016 * sorry"}, {"line": "simp [projectiveSeminormAux, Function.comp_def, mul_assoc, List.sum_map_mul_left]", "tactic_state": "\u03b9 : Type u\u03b9\ninst\u271d\u00b2 : Fintype \u03b9\n\ud835\udd5c : Type u\ud835\udd5c\ninst\u271d\u00b9 : NontriviallyNormedField \ud835\udd5c\nE : \u03b9 \u2192 Type uE\ninst\u271d : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\nx\u271d : Sort u_1\nprojectiveSeminormAux : x\u271d\np : FreeAddMonoid (\ud835\udd5c \u00d7 ((i : \u03b9) \u2192 E i))\na : \ud835\udd5c\n\u22a2 sorry () = \u2016a\u2016 * sorry ()"}]}
{"declaration": "theorem hasDerivAt_gronwallBound_shift (\u03b4 K \u03b5 x a : \u211d) :\n    HasDerivAt (fun y => gronwallBound \u03b4 K \u03b5 (y - a)) (K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5) x := by\n  convert (hasDerivAt_gronwallBound \u03b4 K \u03b5 _).comp x ((hasDerivAt_id x).sub_const a) using 1\n  rw [id]\n  rw [mul_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b4 K \u03b5 x a : \u211d\n\u22a2 HasDerivAt (fun y => gronwallBound \u03b4 K \u03b5 (y - a)) (K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5) x"}, {"line": "convert (hasDerivAt_gronwallBound \u03b4 K \u03b5 _).comp x ((hasDerivAt_id x).sub_const a) using 1", "tactic_state": "case h.e'_9\n\u03b4 K \u03b5 x a : \u211d\n\u22a2 K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5 = (K * gronwallBound \u03b4 K \u03b5 (id x - a) + \u03b5) * 1"}, {"line": "rw [id]", "tactic_state": "case h.e'_9\n\u03b4 K \u03b5 x a : \u211d\n\u22a2 K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5 = (K * gronwallBound \u03b4 K \u03b5 (x - a) + \u03b5) * 1"}, {"line": "rw [mul_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gronwallBound_x0 (\u03b4 K \u03b5 : \u211d) : gronwallBound \u03b4 K \u03b5 0 = \u03b4 := by\n  by_cases hK : K = 0\n  \u00b7 simp only [gronwallBound, if_pos hK, mul_zero, add_zero]\n  \u00b7 simp only [gronwallBound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one,\n      add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b4 K \u03b5 : \u211d\n\u22a2 gronwallBound \u03b4 K \u03b5 0 = \u03b4"}, {"line": "by_cases hK : K = 0", "tactic_state": "case pos\n\u03b4 K \u03b5 : \u211d\nhK : K = 0\n\u22a2 gronwallBound \u03b4 K \u03b5 0 = \u03b4\n---\ncase neg\n\u03b4 K \u03b5 : \u211d\nhK : \u00acK = 0\n\u22a2 gronwallBound \u03b4 K \u03b5 0 = \u03b4"}, {"line": "\u00b7 simp only [gronwallBound, if_pos hK, mul_zero, add_zero]", "tactic_state": "case neg\n\u03b4 K \u03b5 : \u211d\nhK : \u00acK = 0\n\u22a2 gronwallBound \u03b4 K \u03b5 0 = \u03b4"}, {"line": "\u00b7 simp only [gronwallBound, if_neg hK, mul_zero, exp_zero, sub_self, mul_one,\n      add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gronwallBound_\u03b50 (\u03b4 K x : \u211d) : gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x) := by\n  by_cases hK : K = 0\n  \u00b7 simp only [gronwallBound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]\n  \u00b7 simp only [gronwallBound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b4 K x : \u211d\n\u22a2 gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x)"}, {"line": "by_cases hK : K = 0", "tactic_state": "case pos\n\u03b4 K x : \u211d\nhK : K = 0\n\u22a2 gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x)\n---\ncase neg\n\u03b4 K x : \u211d\nhK : \u00acK = 0\n\u22a2 gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x)"}, {"line": "\u00b7 simp only [gronwallBound_K0, hK, zero_mul, exp_zero, add_zero, mul_one]", "tactic_state": "case neg\n\u03b4 K x : \u211d\nhK : \u00acK = 0\n\u22a2 gronwallBound \u03b4 K 0 x = \u03b4 * exp (K * x)"}, {"line": "\u00b7 simp only [gronwallBound_of_K_ne_0 hK, zero_div, zero_mul, add_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem gronwallBound_\u03b50_\u03b40 (K x : \u211d) : gronwallBound 0 K 0 x = 0 := by\n  simp only [gronwallBound_\u03b50]\n  simp only [zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K x : \u211d\n\u22a2 gronwallBound 0 K 0 x = 0"}, {"line": "simp only [gronwallBound_\u03b50]", "tactic_state": "K x : \u211d\n\u22a2 0 * exp (K * x) = 0"}, {"line": "simp only [zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_gronwallBound_of_liminf_deriv_right_le {f f' : \u211d \u2192 \u211d} {\u03b4 K \u03b5 : \u211d} {a b : \u211d}\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 x \u2208 Ico a b, \u2200 r, f' x < r \u2192 \u2203\u1da0 z in \ud835\udcdd[>] x, (z - x)\u207b\u00b9 * (f z - f x) < r)\n    (ha : f a \u2264 \u03b4) (bound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5) :\n    \u2200 x \u2208 Icc a b, f x \u2264 gronwallBound \u03b4 K \u03b5 (x - a) := by\n  have H : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a) := by\n    intro x hx \u03b5' h\u03b5'\n    apply image_le_of_liminf_slope_right_lt_deriv_boundary hf hf'\n    \u00b7 rwa [sub_self, gronwallBound_x0]\n    \u00b7 exact fun x => hasDerivAt_gronwallBound_shift \u03b4 K \u03b5' x a\n    \u00b7 intro x hx hfB\n      rw [\u2190 hfB]\n      apply lt_of_le_of_lt (bound x hx)\n      exact add_lt_add_left (mem_Ioi.1 h\u03b5') _\n    \u00b7 exact hx\n  intro x hx\n  change f x \u2264 (fun \u03b5' => gronwallBound \u03b4 K \u03b5' (x - a)) \u03b5\n  convert continuousWithinAt_const.closure_le _ _ (H x hx)\n  \u00b7 simp only [closure_Ioi, left_mem_Ici]\n  exact (gronwallBound_continuous_\u03b5 \u03b4 K (x - a)).continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\n\u22a2 \u2200 x \u2208 Icc a b, f x \u2264 gronwallBound \u03b4 K \u03b5 (x - a)"}, {"line": "have H : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a) := sorry", "tactic_state": "f f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\n\u22a2 \u2200 x \u2208 Icc a b, f x \u2264 gronwallBound \u03b4 K \u03b5 (x - a)"}, {"line": "intro x hx", "tactic_state": "f f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 f x \u2264 gronwallBound \u03b4 K \u03b5 (x - a)"}, {"line": "change f x \u2264 (fun \u03b5' => gronwallBound \u03b4 K \u03b5' (x - a)) \u03b5", "tactic_state": "f f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 f x \u2264 (fun \u03b5' => gronwallBound \u03b4 K \u03b5' (x - a)) \u03b5"}, {"line": "convert continuousWithinAt_const.closure_le _ _ (H x hx)", "tactic_state": "case convert_2\nf f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 \u03b5 \u2208 closure (Ioi \u03b5)\n---\ncase convert_3\nf f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 ContinuousWithinAt (fun y => gronwallBound \u03b4 K y (x - a)) (Ioi \u03b5) \u03b5"}, {"line": "\u00b7 simp only [closure_Ioi, left_mem_Ici]", "tactic_state": "case convert_3\nf f' : \u211d \u2192 \u211d\n\u03b4 K \u03b5 a b : \u211d\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 x \u2208 Ico a b, \u2200 (r : \u211d), f' x < r \u2192 \u2203\u1da0 (z : \u211d) in nhdsWithin x (Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r\nha : f a \u2264 \u03b4\nbound : \u2200 x \u2208 Ico a b, f' x \u2264 K * f x + \u03b5\nH : \u2200 x \u2208 Icc a b, \u2200 \u03b5' \u2208 Ioi \u03b5, f x \u2264 gronwallBound \u03b4 K \u03b5' (x - a)\nx : \u211d\nhx : x \u2208 Icc a b\n\u22a2 ContinuousWithinAt (fun y => gronwallBound \u03b4 K y (x - a)) (Ioi \u03b5) \u03b5"}, {"line": "exact (gronwallBound_continuous_\u03b5 \u03b4 K (x - a)).continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ODE_solution_unique_of_mem_Icc\n    (hv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t))\n    (ht : t\u2080 \u2208 Ioo a b)\n    (hf : ContinuousOn f (Icc a b))\n    (hf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t)\n    (hfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t)\n    (hg : ContinuousOn g (Icc a b))\n    (hg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t)\n    (hgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t)\n    (heq : f t\u2080 = g t\u2080) :\n    EqOn f g (Icc a b) := by\n  rw [\u2190 Icc_union_Icc_eq_Icc (le_of_lt ht.1) (le_of_lt ht.2)]\n  apply EqOn.union\n  \u00b7 have hss : Ioc a t\u2080 \u2286 Ioo a b := Ioc_subset_Ioo_right ht.2\n    exact ODE_solution_unique_of_mem_Icc_left (fun t ht \u21a6 hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' \u21a6 (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' \u21a6 (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hgs _ (hss ht'))) heq\n  \u00b7 have hss : Ico t\u2080 b \u2286 Ioo a b := Ico_subset_Ioo_left ht.1\n    exact ODE_solution_unique_of_mem_Icc_right (fun t ht \u21a6 hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' \u21a6 (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' \u21a6 (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hgs _ (hss ht'))) heq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d\u22650} {f g f' g' : \u211d \u2192 E} {a b t\u2080 : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t\nhfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t\nhg : ContinuousOn g (Icc a b)\nhg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t\nhgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Icc a b)"}, {"line": "rw [\u2190 Icc_union_Icc_eq_Icc (le_of_lt ht.1) (le_of_lt ht.2)]", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t\nhfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t\nhg : ContinuousOn g (Icc a b)\nhg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t\nhgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Icc a t\u2080 \u222a Icc t\u2080 b)"}, {"line": "apply EqOn.union", "tactic_state": "case h\u2081\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t\nhfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t\nhg : ContinuousOn g (Icc a b)\nhg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t\nhgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Icc a t\u2080)\n---\ncase h\u2082\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t\nhfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t\nhg : ContinuousOn g (Icc a b)\nhg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t\nhgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Icc t\u2080 b)"}, {"line": "\u00b7 have hss : Ioc a t\u2080 \u2286 Ioo a b := Ioc_subset_Ioo_right ht.2\n    exact ODE_solution_unique_of_mem_Icc_left (fun t ht \u21a6 hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' \u21a6 (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_right <| le_of_lt ht.2)\n      (fun _ ht' \u21a6 (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hgs _ (hss ht'))) heq", "tactic_state": "case h\u2082\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : ContinuousOn f (Icc a b)\nhf' : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t\nhfs : \u2200 t \u2208 Ioo a b, f t \u2208 s t\nhg : ContinuousOn g (Icc a b)\nhg' : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t\nhgs : \u2200 t \u2208 Ioo a b, g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Icc t\u2080 b)"}, {"line": "\u00b7 have hss : Ico t\u2080 b \u2286 Ioo a b := Ico_subset_Ioo_left ht.1\n    exact ODE_solution_unique_of_mem_Icc_right (fun t ht \u21a6 hv t (hss ht))\n      (hf.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' \u21a6 (hf' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hfs _ (hss ht')))\n      (hg.mono <| Icc_subset_Icc_left <| le_of_lt ht.1)\n      (fun _ ht' \u21a6 (hg' _ (hss ht')).hasDerivWithinAt) (fun _ ht' \u21a6 (hgs _ (hss ht'))) heq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ODE_solution_unique_of_mem_Ioo\n    (hv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t))\n    (ht : t\u2080 \u2208 Ioo a b)\n    (hf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t)\n    (hg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t)\n    (heq : f t\u2080 = g t\u2080) :\n    EqOn f g (Ioo a b) := by\n  intros t' ht'\n  rcases lt_or_le t' t\u2080 with (h | h)\n  \u00b7 have hss : Icc t' t\u2080 \u2286 Ioo a b :=\n      fun _ ht'' \u21a6 \u27e8lt_of_lt_of_le ht'.1 ht''.1, lt_of_le_of_lt ht''.2 ht.2\u27e9\n    exact ODE_solution_unique_of_mem_Icc_left\n      (fun t'' ht'' \u21a6 hv t'' ((Ioc_subset_Icc_self.trans hss) ht''))\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hf _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ioc_subset_Icc_self ht'').2)\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hg _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ioc_subset_Icc_self ht'').2) heq\n      \u27e8le_rfl, le_of_lt h\u27e9\n  \u00b7 have hss : Icc t\u2080 t' \u2286 Ioo a b :=\n      fun _ ht'' \u21a6 \u27e8lt_of_lt_of_le ht.1 ht''.1, lt_of_le_of_lt ht''.2 ht'.2\u27e9\n    exact ODE_solution_unique_of_mem_Icc_right\n      (fun t'' ht'' \u21a6 hv t'' ((Ico_subset_Icc_self.trans hss) ht''))\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hf _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ico_subset_Icc_self ht'').2)\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hg _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ico_subset_Icc_self ht'').2) heq\n      \u27e8h, le_rfl\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d\u22650} {f g f' g' : \u211d \u2192 E} {a b t\u2080 : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 EqOn f g (Ioo a b)"}, {"line": "intros t' ht'", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt' : \u211d\nht' : t' \u2208 Ioo a b\n\u22a2 f t' = g t'"}, {"line": "rcases lt_or_le t' t\u2080 with (h | h)", "tactic_state": "case inl\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt' : \u211d\nht' : t' \u2208 Ioo a b\nh : t' < t\u2080\n\u22a2 f t' = g t'\n---\ncase inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt' : \u211d\nht' : t' \u2208 Ioo a b\nh : t\u2080 \u2264 t'\n\u22a2 f t' = g t'"}, {"line": "\u00b7 have hss : Icc t' t\u2080 \u2286 Ioo a b :=\n      fun _ ht'' \u21a6 \u27e8lt_of_lt_of_le ht'.1 ht''.1, lt_of_le_of_lt ht''.2 ht.2\u27e9\n    exact ODE_solution_unique_of_mem_Icc_left\n      (fun t'' ht'' \u21a6 hv t'' ((Ioc_subset_Icc_self.trans hss) ht''))\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hf _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ioc_subset_Icc_self ht'').2)\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hg _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ioc_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ioc_subset_Icc_self ht'').2) heq\n      \u27e8le_rfl, le_of_lt h\u27e9", "tactic_state": "case inr\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\na b t\u2080 : \u211d\nhv : \u2200 t \u2208 Ioo a b, LipschitzOnWith K (v t) (s t)\nht : t\u2080 \u2208 Ioo a b\nhf : \u2200 t \u2208 Ioo a b, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 t \u2208 Ioo a b, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt' : \u211d\nht' : t' \u2208 Ioo a b\nh : t\u2080 \u2264 t'\n\u22a2 f t' = g t'"}, {"line": "\u00b7 have hss : Icc t\u2080 t' \u2286 Ioo a b :=\n      fun _ ht'' \u21a6 \u27e8lt_of_lt_of_le ht.1 ht''.1, lt_of_le_of_lt ht''.2 ht'.2\u27e9\n    exact ODE_solution_unique_of_mem_Icc_right\n      (fun t'' ht'' \u21a6 hv t'' ((Ico_subset_Icc_self.trans hss) ht''))\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hf _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hf _ <| hss <| Ico_subset_Icc_self ht'').2)\n      (HasDerivAt.continuousOn fun _ ht'' \u21a6 (hg _ <| hss ht'').1)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ico_subset_Icc_self ht'').1.hasDerivWithinAt)\n      (fun _ ht'' \u21a6 (hg _ <| hss <| Ico_subset_Icc_self ht'').2) heq\n      \u27e8h, le_rfl\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ODE_solution_unique_of_eventually\n    (hv : \u2200\u1da0 t in \ud835\udcdd t\u2080, LipschitzOnWith K (v t) (s t))\n    (hf : \u2200\u1da0 t in \ud835\udcdd t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t)\n    (hg : \u2200\u1da0 t in \ud835\udcdd t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t)\n    (heq : f t\u2080 = g t\u2080) : f =\u1da0[\ud835\udcdd t\u2080] g := by\n  obtain \u27e8\u03b5, h\u03b5, h\u27e9 := eventually_nhds_iff_ball.mp (hv.and (hf.and hg))\n  rw [Filter.eventuallyEq_iff_exists_mem]\n  refine \u27e8ball t\u2080 \u03b5, ball_mem_nhds _ h\u03b5, ?_\u27e9\n  simp_rw [Real.ball_eq_Ioo] at *\n  apply ODE_solution_unique_of_mem_Ioo (fun _ ht \u21a6 (h _ ht).1)\n    (Real.ball_eq_Ioo t\u2080 \u03b5 \u25b8 mem_ball_self h\u03b5)\n    (fun _ ht \u21a6 (h _ ht).2.1) (fun _ ht \u21a6 (h _ ht).2.2) heq\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d\u22650} {f g f' g' : \u211d \u2192 E} {a b t\u2080 : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200\u1da0 (t : \u211d) in nhds t\u2080, LipschitzOnWith K (v t) (s t)\nhf : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 f =\u1da0[nhds t\u2080] g"}, {"line": "obtain \u27e8\u03b5, h\u03b5, h\u27e9 := eventually_nhds_iff_ball.mp (hv.and (hf.and hg))", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200\u1da0 (t : \u211d) in nhds t\u2080, LipschitzOnWith K (v t) (s t)\nhf : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh :\n  \u2200 y \u2208 ball t\u2080 \u03b5,\n    LipschitzOnWith K (v y) (s y) \u2227 (HasDerivAt f (v y (f y)) y \u2227 f y \u2208 s y) \u2227 HasDerivAt g (v y (g y)) y \u2227 g y \u2208 s y\n\u22a2 f =\u1da0[nhds t\u2080] g"}, {"line": "rw [Filter.eventuallyEq_iff_exists_mem]", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200\u1da0 (t : \u211d) in nhds t\u2080, LipschitzOnWith K (v t) (s t)\nhf : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh :\n  \u2200 y \u2208 ball t\u2080 \u03b5,\n    LipschitzOnWith K (v y) (s y) \u2227 (HasDerivAt f (v y (f y)) y \u2227 f y \u2208 s y) \u2227 HasDerivAt g (v y (g y)) y \u2227 g y \u2208 s y\n\u22a2 \u2203 s \u2208 nhds t\u2080, EqOn f g s"}, {"line": "refine \u27e8ball t\u2080 \u03b5, ball_mem_nhds _ h\u03b5, ?_\u27e9", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200\u1da0 (t : \u211d) in nhds t\u2080, LipschitzOnWith K (v t) (s t)\nhf : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh :\n  \u2200 y \u2208 ball t\u2080 \u03b5,\n    LipschitzOnWith K (v y) (s y) \u2227 (HasDerivAt f (v y (f y)) y \u2227 f y \u2208 s y) \u2227 HasDerivAt g (v y (g y)) y \u2227 g y \u2208 s y\n\u22a2 EqOn f g (ball t\u2080 \u03b5)"}, {"line": "simp_rw [Real.ball_eq_Ioo] at *", "tactic_state": "case intro.intro\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200\u1da0 (t : \u211d) in nhds t\u2080, LipschitzOnWith K (v t) (s t)\nhf : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200\u1da0 (t : \u211d) in nhds t\u2080, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u03b5 : \u211d\nh\u03b5 : \u03b5 > 0\nh :\n  \u2200 y \u2208 Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5),\n    LipschitzOnWith K (v y) (s y) \u2227 (HasDerivAt f (v y (f y)) y \u2227 f y \u2208 s y) \u2227 HasDerivAt g (v y (g y)) y \u2227 g y \u2208 s y\n\u22a2 EqOn f g (Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5))"}, {"line": "apply ODE_solution_unique_of_mem_Ioo (fun _ ht \u21a6 (h _ ht).1)\n    (Real.ball_eq_Ioo t\u2080 \u03b5 \u25b8 mem_ball_self h\u03b5)\n    (fun _ ht \u21a6 (h _ ht).2.1) (fun _ ht \u21a6 (h _ ht).2.2) heq", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ODE_solution_unique_univ\n    (hv : \u2200 t, LipschitzOnWith K (v t) (s t))\n    (hf : \u2200 t, HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t)\n    (hg : \u2200 t, HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t)\n    (heq : f t\u2080 = g t\u2080) : f = g := by\n  ext t\n  obtain \u27e8A, B, Ht, Ht\u2080\u27e9 : \u2203 A B, t \u2208 Set.Ioo A B \u2227 t\u2080 \u2208 Set.Ioo A B := by\n    use (min (-|t|) (-|t\u2080|) - 1), (max |t| |t\u2080| + 1)\n    rw [Set.mem_Ioo]\n    rw [Set.mem_Ioo]\n    refine \u27e8\u27e8?_, ?_\u27e9, ?_, ?_\u27e9\n    \u00b7 exact sub_one_lt _ |>.trans_le <| min_le_left _ _ |>.trans <| neg_abs_le t\n    \u00b7 exact le_abs_self _ |>.trans_lt <| le_max_left _ _ |>.trans_lt <| lt_add_one _\n    \u00b7 exact sub_one_lt _ |>.trans_le <| min_le_right _ _ |>.trans <| neg_abs_le t\u2080\n    \u00b7 exact le_abs_self _ |>.trans_lt <| le_max_right _ _ |>.trans_lt <| lt_add_one _\n  exact ODE_solution_unique_of_mem_Ioo\n    (fun t _ => hv t) Ht\u2080 (fun t _ => hf t) (fun t _ => hg t) heq Ht", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/ODE/Gronwall.lean", "context": {"open": ["Metric Set Asymptotics Filter Real", "scoped Topology NNReal"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E]", "{v : \u211d \u2192 E \u2192 E} {s : \u211d \u2192 Set E} {K : \u211d\u22650} {f g f' g' : \u211d \u2192 E} {a b t\u2080 : \u211d} {\u03b5f \u03b5g \u03b4 : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200 (t : \u211d), LipschitzOnWith K (v t) (s t)\nhf : \u2200 (t : \u211d), HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 (t : \u211d), HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\n\u22a2 f = g"}, {"line": "ext t", "tactic_state": "case h\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200 (t : \u211d), LipschitzOnWith K (v t) (s t)\nhf : \u2200 (t : \u211d), HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 (t : \u211d), HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt : \u211d\n\u22a2 f t = g t"}, {"line": "obtain \u27e8A, B, Ht, Ht\u2080\u27e9 : \u2203 A B, t \u2208 Set.Ioo A B \u2227 t\u2080 \u2208 Set.Ioo A B := by\n    use (min (-|t|) (-|t\u2080|) - 1), (max |t| |t\u2080| + 1)\n    rw [Set.mem_Ioo]\n    rw [Set.mem_Ioo]\n    refine \u27e8\u27e8?_, ?_\u27e9, ?_, ?_\u27e9\n    \u00b7 exact sub_one_lt _ |>.trans_le <| min_le_left _ _ |>.trans <| neg_abs_le t\n    \u00b7 exact le_abs_self _ |>.trans_lt <| le_max_left _ _ |>.trans_lt <| lt_add_one _\n    \u00b7 exact sub_one_lt _ |>.trans_le <| min_le_right _ _ |>.trans <| neg_abs_le t\u2080\n    \u00b7 exact le_abs_self _ |>.trans_lt <| le_max_right _ _ |>.trans_lt <| lt_add_one _", "tactic_state": "case h.intro.intro.intro\nE : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nv : \u211d \u2192 E \u2192 E\ns : \u211d \u2192 Set E\nK : NNReal\nf g : \u211d \u2192 E\nt\u2080 : \u211d\nhv : \u2200 (t : \u211d), LipschitzOnWith K (v t) (s t)\nhf : \u2200 (t : \u211d), HasDerivAt f (v t (f t)) t \u2227 f t \u2208 s t\nhg : \u2200 (t : \u211d), HasDerivAt g (v t (g t)) t \u2227 g t \u2208 s t\nheq : f t\u2080 = g t\u2080\nt A B : \u211d\nHt : t \u2208 Ioo A B\nHt\u2080 : t\u2080 \u2208 Ioo A B\n\u22a2 f t = g t"}, {"line": "exact ODE_solution_unique_of_mem_Ioo\n    (fun t _ => hv t) Ht\u2080 (fun t _ => hf t) (fun t _ => hg t) heq Ht", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_isBoundedUnder_iff :\n    (IsBoundedUnder (\u00b7 \u2264 \u00b7) atTop fun x => |eval x P|) \u2194 P.degree \u2264 0 := by\n  refine \u27e8fun h => ?_, fun h => \u27e8|P.coeff 0|, eventually_map.mpr (Eventually.of_forall\n    (forall_imp (fun _ => le_of_eq) fun x => congr_arg abs <| _root_.trans (congr_arg (eval x)\n    (eq_C_of_degree_le_zero h)) eval_C))\u27e9\u27e9\n  contrapose! h\n  exact not_isBoundedUnder_of_tendsto_atTop (abs_tendsto_atTop P h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/Basic.lean", "context": {"open": ["Filter Finset Asymptotics", "Asymptotics Polynomial Topology"], "variables": ["{\ud835\udd5c : Type*} [NormedField \ud835\udd5c] [LinearOrder \ud835\udd5c] [IsStrictOrderedRing \ud835\udd5c] (P Q : \ud835\udd5c[X])", "[OrderTopology \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9 : IsStrictOrderedRing \ud835\udd5c\nP : Polynomial \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\n\u22a2 (IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) atTop fun x => |eval x P|) \u2194 P.degree \u2264 0"}, {"line": "refine \u27e8fun h => ?_, fun h => \u27e8|P.coeff 0|, eventually_map.mpr (Eventually.of_forall\n    (forall_imp (fun _ => le_of_eq) fun x => congr_arg abs <| _root_.trans (congr_arg (eval x)\n    (eq_C_of_degree_le_zero h)) eval_C))\u27e9\u27e9", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9 : IsStrictOrderedRing \ud835\udd5c\nP : Polynomial \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\nh : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) atTop fun x => |eval x P|\n\u22a2 P.degree \u2264 0"}, {"line": "contrapose! h", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d\u00b3 : NormedField \ud835\udd5c\ninst\u271d\u00b2 : LinearOrder \ud835\udd5c\ninst\u271d\u00b9 : IsStrictOrderedRing \ud835\udd5c\nP : Polynomial \ud835\udd5c\ninst\u271d : OrderTopology \ud835\udd5c\nh : 0 < P.degree\n\u22a2 \u00acIsBoundedUnder (fun x1 x2 => x1 \u2264 x2) atTop fun x => |eval x P|"}, {"line": "exact not_isBoundedUnder_of_tendsto_atTop (abs_tendsto_atTop P h)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_le_cauchyBound (p : K[X]) : 1 \u2264 cauchyBound p := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nidx\u271d : Type u_2\nX : idx\u271d\nvalid\u271d : outParam (Type u_1 \u2192 idx\u271d \u2192 Prop)\ncauchyBound : valid\u271d K X\np : K[X]\n\u22a2 1 \u2264 sorry"}, {"line": "simp [cauchyBound]", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nidx\u271d : Type u_2\nX : idx\u271d\nvalid\u271d : outParam (Type u_1 \u2192 idx\u271d \u2192 Prop)\ncauchyBound : valid\u271d K X\np : K[X]\n\u22a2 1 \u2264 sorry ()"}]}
{"declaration": "lemma cauchyBound_zero : cauchyBound (0 : K[X]) = 1 := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ncauchyBound : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [cauchyBound]", "tactic_state": "x\u271d : Sort u_2\ncauchyBound : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma cauchyBound_C (x : K) : cauchyBound (C x) = 1 := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry = 1"}, {"line": "simp [cauchyBound]", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma cauchyBound_X : cauchyBound (X : K[X]) = 1 := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\ncauchyBound : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [cauchyBound]", "tactic_state": "x\u271d : Sort u_2\ncauchyBound : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma cauchyBound_X_add_C (x : K) : cauchyBound (X + C x) = \u2016x\u2016\u208a + 1 := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry = \u2016x\u2016\u208a + 1"}, {"line": "simp [cauchyBound]", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry () = \u2016x\u2016\u208a + 1"}]}
{"declaration": "lemma cauchyBound_X_sub_C (x : K) : cauchyBound (X - C x) = \u2016x\u2016\u208a + 1 := by\n  simp [cauchyBound]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/Polynomial/CauchyBound.lean", "context": {"open": ["Finset NNReal"], "variables": ["{K : Type*} [NormedDivisionRing K]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry = \u2016x\u2016\u208a + 1"}, {"line": "simp [cauchyBound]", "tactic_state": "K : Type u_1\ninst\u271d : NormedDivisionRing K\nx\u271d : Sort u_2\ncauchyBound : x\u271d\nx : K\n\u22a2 sorry () = \u2016x\u2016\u208a + 1"}]}
{"declaration": "theorem proper_rclike [FiniteDimensional K E] : ProperSpace E := by\n  letI : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d K E\n  letI : FiniteDimensional \u211d E := FiniteDimensional.trans \u211d K E\n  infer_instance\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Lemmas.lean", "context": {"open": ["scoped Finset", "RCLike"], "variables": ["{K E : Type*} [RCLike K]", "(K) in", "(K) in", "(K) in", "(K E)", "[NormedAddCommGroup E] [NormedSpace K E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike K\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace K E\ninst\u271d : FiniteDimensional K E\n\u22a2 ProperSpace E"}, {"line": "letI : NormedSpace \u211d E := RestrictScalars.normedSpace \u211d K E", "tactic_state": "K : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike K\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace K E\ninst\u271d : FiniteDimensional K E\nthis : sorry := sorry\n\u22a2 ProperSpace E"}, {"line": "letI : FiniteDimensional \u211d E := FiniteDimensional.trans \u211d K E", "tactic_state": "K : Type u_1\nE : Type u_2\ninst\u271d\u00b3 : RCLike K\ninst\u271d\u00b2 : NormedAddCommGroup E\ninst\u271d\u00b9 : NormedSpace K E\ninst\u271d : FiniteDimensional K E\nthis\u271d : sorry := sorry\nthis : sorry := sorry\n\u22a2 ProperSpace E"}, {"line": "infer_instance", "tactic_state": "No Goals!"}]}
{"declaration": "theorem conj_eq_iff_real {z : K} : conj z = z \u2194 \u2203 r : \u211d, z = (r : K) :=\n  calc\n    _ \u2194 \u2203 r : \u211d, (r : K) = z := (is_real_TFAE z).out 0 1\n    _ \u2194 _                    := by simp only [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\nz : K\n\u22a2 (\u2203 r, sorry = z) \u2194 \u2203 r, z = sorry"}, {"line": "simp only [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_conj (z : K) : z * conj z = \u2016z\u2016 ^ 2 := by\n  apply ext <;> simp [\u2190 ofReal_pow, norm_sq_eq_def, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.36\nz : K\n\u22a2 sorry"}, {"line": "apply ext <;> simp [\u2190 ofReal_pow, norm_sq_eq_def, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_I : (I : K)\u207b\u00b9 = -I := by\n  by_cases h : (I : K) = 0\n  \u00b7 simp [h]\n  \u00b7 field_simp [I_mul_I_of_nonzero h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type ?u.40\nI : K\n\u22a2 sorry"}, {"line": "by_cases h : (I : K) = 0", "tactic_state": "K : Type ?u.40\nI : K\n\u22a2 OfNat K 0\n---\ncase pos\nK : Type ?u.40\nI : K\nh : I = 0\n\u22a2 sorry\n---\ncase neg\nK : Type ?u.40\nI : K\nh : \u00acI = 0\n\u22a2 sorry"}, {"line": "\u00b7 simp [h]", "tactic_state": "case pos\nK : Type ?u.40\nI : K\nh : I = 0\n\u22a2 sorry\n---\ncase neg\nK : Type ?u.40\nI : K\nh : \u00acI = 0\n\u22a2 sorry"}, {"line": "\u00b7 field_simp [I_mul_I_of_nonzero h]", "tactic_state": "case neg\nK : Type ?u.40\nI : K\nh : \u00acI = 0\n\u22a2 sorry"}]}
{"declaration": "lemma nnnorm_nnratCast (q : \u211a\u22650) : \u2016(q : K)\u2016\u208a = q := by simp [nnnorm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "q : \u211a\u22650\n\u22a2 \u2016sorry\u2016\u208a = \u2191q"}, {"line": "simp [nnnorm]", "tactic_state": "q : \u211a\u22650\n\u22a2 \u2016sorry ()\u2016\u208a = \u2191q"}]}
{"declaration": "theorem nonneg_iff : 0 \u2264 z \u2194 0 \u2264 re z \u2227 im z = 0 := by\n  simpa only [map_zero,eq_comm] using le_iff_re_im (z := 0) (w := z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nx\u271d\u00b9 : Sort u_3\nre : x\u271d\u00b9\nx\u271d : Sort u_4\nim : x\u271d\n\u22a2 0 \u2264 z \u2194 0 \u2264 sorry \u2227 sorry = 0"}, {"line": "simpa only [map_zero,eq_comm] using le_iff_re_im (z := 0) (w := z)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pos_iff : 0 < z \u2194 0 < re z \u2227 im z = 0 := by\n  simpa only [map_zero,eq_comm] using lt_iff_re_im (z := 0) (w := z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nx\u271d\u00b9 : Sort u_3\nre : x\u271d\u00b9\nx\u271d : Sort u_4\nim : x\u271d\n\u22a2 0 < z \u2194 0 < sorry \u2227 sorry = 0"}, {"line": "simpa only [map_zero,eq_comm] using lt_iff_re_im (z := 0) (w := z)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem nonpos_iff : z \u2264 0 \u2194 re z \u2264 0 \u2227 im z = 0 := by\n  simpa only [map_zero] using le_iff_re_im (z := z) (w := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nx\u271d\u00b9 : Sort u_3\nre : x\u271d\u00b9\nx\u271d : Sort u_4\nim : x\u271d\n\u22a2 z \u2264 0 \u2194 sorry \u2264 0 \u2227 sorry = 0"}, {"line": "simpa only [map_zero] using le_iff_re_im (z := z) (w := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_iff : z < 0 \u2194 re z < 0 \u2227 im z = 0 := by\n  simpa only [map_zero] using lt_iff_re_im (z := z) (w := 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2115\nx\u271d\u00b9 : Sort u_3\nre : x\u271d\u00b9\nx\u271d : Sort u_4\nim : x\u271d\n\u22a2 z < 0 \u2194 sorry < 0 \u2227 sorry = 0"}, {"line": "simpa only [map_zero] using lt_iff_re_im (z := z) (w := 0)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma toZeroLEOneClass : ZeroLEOneClass K where\n  zero_le_one := by simp [@RCLike.le_iff_re_im K]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : RCLike K\n\u22a2 0 \u2264 1"}, {"line": "simp [@RCLike.le_iff_re_im K]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ofReal_mul_neg_iff (x : \u211d) (z : K) :\n    x * z < 0 \u2194 (x < 0 \u2227 0 < z) \u2228 (0 < x \u2227 z < 0) := by\n  simpa only [mul_neg,neg_pos,neg_neg_iff_pos] using ofReal_mul_pos_iff x (-z)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "K : Type u_1\ninst\u271d : RCLike K\nx : \u211d\nz : K\n\u22a2 \u2191x * z < 0 \u2194 x < 0 \u2227 0 < z \u2228 0 < x \u2227 z < 0"}, {"line": "simpa only [mul_neg,neg_pos,neg_neg_iff_pos] using ofReal_mul_pos_iff x (-z)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem normSq_to_real {x : \u211d} : normSq x = x * x := by simp [RCLike.normSq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Basic.lean", "context": {"open": ["Fintype", "scoped BigOperators ComplexConjugate", "List in", "IsAbsoluteValue", "scoped ComplexOrder"], "variables": ["{K E : Type*} [RCLike K]", "(\ud835\udd5c) in", "(K)", "{K} {z : K}", "(K) in", "(K) in", "[NormedField E] [CharZero E] [NormedSpace K E]", "(K) in", "(K) in", "{z w : K}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nx : \u211d\n\u22a2 sorry = x * x"}, {"line": "simp [RCLike.normSq]", "tactic_state": "x\u271d : Sort u_3\nnormSq : x\u271d\nx : \u211d\n\u22a2 sorry () = x * x"}]}
{"declaration": "lemma wInner_cWeight_eq_expect (f g : \u2200 i, E i) : \u27eaf, g\u27eb\u2099_[\ud835\udd5c] = \ud835\udd3c i, inner (f i) (g i) := by\n  simp [wInner, expect, smul_sum, \u2190 NNRat.cast_smul_eq_nnqsmul \u211d]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\nE : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (E i)\nf g : (i : \u03b9) \u2192 E i\n\u22a2 RCLike.wInner RCLike.cWeight f g = univ.expect fun i => inner (f i) (g i)"}, {"line": "simp [wInner, expect, smul_sum, \u2190 NNRat.cast_smul_eq_nnqsmul \u211d]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\nE : \u03b9 \u2192 Type u_4\ninst\u271d\u00b3 : Fintype \u03b9\ninst\u271d\u00b2 : RCLike \ud835\udd5c\ninst\u271d\u00b9 : (i : \u03b9) \u2192 SeminormedAddCommGroup (E i)\ninst\u271d : (i : \u03b9) \u2192 InnerProductSpace \ud835\udd5c (E i)\nf g : (i : \u03b9) \u2192 E i\n\u22a2 RCLike.wInner RCLike.cWeight f g = \u2211 x, (\u2191(Fintype.card \u03b9))\u207b\u00b9 \u2022 inner (f x) (g x)"}]}
{"declaration": "lemma wInner_const_left (a : \ud835\udd5c) (f : \u03b9 \u2192 \ud835\udd5c) :\n    \u27eaconst _ a, f\u27eb_[\ud835\udd5c, w] = (\u2211 i, w i \u2022 f i) * conj a := by simp [wInner, const_apply, sum_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nw : \u03b9 \u2192 \u211d\na : \ud835\udd5c\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 RCLike.wInner w (const \u03b9 a) f = (\u2211 i, w i \u2022 f i) * (starRingEnd \ud835\udd5c) a"}, {"line": "simp [wInner, const_apply, sum_mul]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nw : \u03b9 \u2192 \u211d\na : \ud835\udd5c\nf : \u03b9 \u2192 \ud835\udd5c\n\u22a2 RCLike.wInner w (const \u03b9 a) f = \u2211 x, w x \u2022 (f x * (starRingEnd \ud835\udd5c) a)"}]}
{"declaration": "lemma wInner_const_right (f : \u03b9 \u2192 \ud835\udd5c) (a : \ud835\udd5c) :\n    \u27eaf, const _ a\u27eb_[\ud835\udd5c, w] = a * (\u2211 i, w i \u2022 conj (f i)) := by simp [wInner, const_apply, mul_sum]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nw : \u03b9 \u2192 \u211d\nf : \u03b9 \u2192 \ud835\udd5c\na : \ud835\udd5c\n\u22a2 RCLike.wInner w f (const \u03b9 a) = a * \u2211 i, w i \u2022 (starRingEnd \ud835\udd5c) (f i)"}, {"line": "simp [wInner, const_apply, mul_sum]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nw : \u03b9 \u2192 \u211d\nf : \u03b9 \u2192 \ud835\udd5c\na : \ud835\udd5c\n\u22a2 RCLike.wInner w f (const \u03b9 a) = \u2211 x, w x \u2022 (a * (starRingEnd \ud835\udd5c) (f x))"}]}
{"declaration": "lemma wInner_one_eq_inner (f g : \u03b9 \u2192 \ud835\udd5c) :\n    \u27eaf, g\u27eb_[\ud835\udd5c, 1] = inner ((WithLp.equiv 2 _).symm f) ((WithLp.equiv 2 _).symm g) := by\n  simp [wInner]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf g : \u03b9 \u2192 \ud835\udd5c\n\u22a2 RCLike.wInner 1 f g = inner ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)).symm f) ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)).symm g)"}, {"line": "simp [wInner]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf g : \u03b9 \u2192 \ud835\udd5c\n\u22a2 RCLike.wInner 1 f g = \u2211 x, g x * (starRingEnd \ud835\udd5c) (f x)"}]}
{"declaration": "lemma inner_eq_wInner_one (f g : PiLp 2 fun _i : \u03b9 \u21a6 \ud835\udd5c) :\n    inner f g = \u27eaWithLp.equiv 2 _ f, WithLp.equiv 2 _ g\u27eb_[\ud835\udd5c, 1] := by simp [wInner]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf g : PiLp 2 fun _i => \ud835\udd5c\n\u22a2 inner f g = RCLike.wInner 1 ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)) f) ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)) g)"}, {"line": "simp [wInner]", "tactic_state": "\u03b9 : Type u_1\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf g : PiLp 2 fun _i => \ud835\udd5c\n\u22a2 \u2211 x, g x * (starRingEnd \ud835\udd5c) (f x) = RCLike.wInner 1 ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)) f) ((WithLp.equiv 2 (\u03b9 \u2192 \ud835\udd5c)) g)"}]}
{"declaration": "lemma linearIndependent_of_ne_zero_of_wInner_cWeight_eq_zero {f : \u03ba \u2192 \u03b9 \u2192 \ud835\udd5c} (hf : \u2200 k, f k \u2260 0)\n    (hinner : Pairwise fun k\u2081 k\u2082 \u21a6 \u27eaf k\u2081, f k\u2082\u27eb\u2099_[\ud835\udd5c] = 0) : LinearIndependent \ud835\udd5c f := by\n  cases isEmpty_or_nonempty \u03b9\n  \u00b7 have : IsEmpty \u03ba := \u27e8fun k \u21a6 hf k <| Subsingleton.elim ..\u27e9\n    exact linearIndependent_empty_type\n  \u00b7 exact linearIndependent_of_ne_zero_of_wInner_one_eq_zero hf <| by\n      simpa [wInner_cWeight_eq_smul_wInner_one, \u2190 NNRat.cast_smul_eq_nnqsmul \ud835\udd5c] using hinner\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\n\u03ba : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf : \u03ba \u2192 \u03b9 \u2192 \ud835\udd5c\nhf : \u2200 (k : \u03ba), f k \u2260 0\nhinner : Pairwise fun k\u2081 k\u2082 => RCLike.wInner RCLike.cWeight (f k\u2081) (f k\u2082) = 0\n\u22a2 LinearIndependent \ud835\udd5c f"}, {"line": "cases isEmpty_or_nonempty \u03b9", "tactic_state": "case inl\n\u03b9 : Type u_1\n\u03ba : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf : \u03ba \u2192 \u03b9 \u2192 \ud835\udd5c\nhf : \u2200 (k : \u03ba), f k \u2260 0\nhinner : Pairwise fun k\u2081 k\u2082 => RCLike.wInner RCLike.cWeight (f k\u2081) (f k\u2082) = 0\nh\u271d : IsEmpty \u03b9\n\u22a2 LinearIndependent \ud835\udd5c f\n---\ncase inr\n\u03b9 : Type u_1\n\u03ba : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf : \u03ba \u2192 \u03b9 \u2192 \ud835\udd5c\nhf : \u2200 (k : \u03ba), f k \u2260 0\nhinner : Pairwise fun k\u2081 k\u2082 => RCLike.wInner RCLike.cWeight (f k\u2081) (f k\u2082) = 0\nh\u271d : Nonempty \u03b9\n\u22a2 LinearIndependent \ud835\udd5c f"}, {"line": "\u00b7 have : IsEmpty \u03ba := \u27e8fun k \u21a6 hf k <| Subsingleton.elim ..\u27e9\n    exact linearIndependent_empty_type", "tactic_state": "case inr\n\u03b9 : Type u_1\n\u03ba : Type u_2\n\ud835\udd5c : Type u_3\ninst\u271d\u00b9 : Fintype \u03b9\ninst\u271d : RCLike \ud835\udd5c\nf : \u03ba \u2192 \u03b9 \u2192 \ud835\udd5c\nhf : \u2200 (k : \u03ba), f k \u2260 0\nhinner : Pairwise fun k\u2081 k\u2082 => RCLike.wInner RCLike.cWeight (f k\u2081) (f k\u2082) = 0\nh\u271d : Nonempty \u03b9\n\u22a2 LinearIndependent \ud835\udd5c f"}, {"line": "\u00b7 exact linearIndependent_of_ne_zero_of_wInner_one_eq_zero hf <| by\n      simpa [wInner_cWeight_eq_smul_wInner_one, \u2190 NNRat.cast_smul_eq_nnqsmul \ud835\udd5c] using hinner", "tactic_state": "No Goals!"}]}
{"declaration": "lemma abs_wInner_le (hw : 0 \u2264 w) : |\u27eaf, g\u27eb_[\u211d, w]| \u2264 \u27ea|f|, |g|\u27eb_[\u211d, w] := by\n  simpa using norm_wInner_le (\ud835\udd5c := \u211d) hw\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/RCLike/Inner.lean", "context": {"open": ["Finset Function Real", "scoped BigOperators ComplexConjugate ComplexOrder ENNReal NNReal NNRat"], "variables": ["{\u03b9 \u03ba \ud835\udd5c : Type*} {E : \u03b9 \u2192 Type*} [Fintype \u03b9]", "[RCLike \ud835\udd5c]", "[\u2200 i, SeminormedAddCommGroup (E i)] [\u2200 i, InnerProductSpace \ud835\udd5c (E i)] {w : \u03b9 \u2192 \u211d}", "{w : \u03b9 \u2192 \u211d} {f g : \u03b9 \u2192 \ud835\udd5c}", "{w f g : \u03b9 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nw f g : \u03b9 \u2192 \u211d\nhw : 0 \u2264 w\n\u22a2 |RCLike.wInner w f g| \u2264 RCLike.wInner w |f| |g|"}, {"line": "simpa using norm_wInner_le (\ud835\udd5c := \u211d) hw", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isEquivalent_choose (k : \u2115) :\n    (fun (n : \u2115) \u21a6 (n.choose k : \u211d)) ~[atTop] (fun (n : \u2115) \u21a6 (n^k / k.factorial : \u211d)) := by\n  conv_lhs =>\n    intro n\n    rw [choose_eq_descFactorial_div_factorial]\n    rw [cast_div (n.factorial_dvd_descFactorial k) (mod_cast k.factorial_ne_zero)]\n  exact (isEquivalent_descFactorial k).div IsEquivalent.refl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Choose.lean", "context": {"open": ["Asymptotics Filter Nat Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 IsEquivalent atTop (fun n => \u2191(n.choose k)) fun n => \u2191n ^ k / \u2191k.factorial"}, {"line": "conv_lhs =>\n    intro n\n    rw [choose_eq_descFactorial_div_factorial]\n    rw [cast_div (n.factorial_dvd_descFactorial k) (mod_cast k.factorial_ne_zero)]", "tactic_state": "k : \u2115\n\u22a2 IsEquivalent atTop (fun n => \u2191(n.descFactorial k) / \u2191k.factorial) fun n => \u2191n ^ k / \u2191k.factorial"}, {"line": "exact (isEquivalent_descFactorial k).div IsEquivalent.refl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_choose (k : \u2115) :\n    (fun (n : \u2115) \u21a6 (n.choose k : \u211d)) =\u0398[atTop] (fun (n : \u2115) \u21a6 (n^k : \u211d)) := by\n  apply (isEquivalent_choose k).trans_isTheta\n  simp_rw [div_eq_mul_inv, mul_comm _ (_\u207b\u00b9)]\n  exact isTheta_rfl.const_mul_left <| inv_ne_zero (mod_cast k.factorial_ne_zero)", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Choose.lean", "context": {"open": ["Asymptotics Filter Nat Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\n\u22a2 (fun n => \u2191(n.choose k)) =\u0398[atTop] fun n => \u2191n ^ k"}, {"line": "apply (isEquivalent_choose k).trans_isTheta", "tactic_state": "k : \u2115\n\u22a2 (fun n => \u2191n ^ k / \u2191k.factorial) =\u0398[atTop] fun n => \u2191n ^ k"}, {"line": "simp_rw [div_eq_mul_inv, mul_comm _ (_\u207b\u00b9)]", "tactic_state": "k : \u2115\n\u22a2 (fun n => (\u2191k.factorial)\u207b\u00b9 * \u2191n ^ k) =\u0398[atTop] fun n => \u2191n ^ k"}, {"line": "exact isTheta_rfl.const_mul_left <| inv_ne_zero (mod_cast k.factorial_ne_zero)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_im_pow_eventuallyLE_exp_re (hl : IsExpCmpFilter l) (n : \u2115) :\n    (fun z : \u2102 => |z.im| ^ n) \u2264\u1da0[l] fun z => Real.exp z.re := by\n  simpa using (hl.isLittleO_im_pow_exp_re n).bound zero_lt_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "context": {"open": ["Asymptotics Filter Function", "scoped Topology"], "variables": ["{l : Filter \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u2102\nx\u271d : Sort u_1\nIsExpCmpFilter : x\u271d\nhl : sorry\nn : \u2115\n\u22a2 (fun z => |z.im| ^ n) \u2264\u1da0[l] fun z => Real.exp z.re"}, {"line": "simpa using (hl.isLittleO_im_pow_exp_re n).bound zero_lt_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : b < 0) :\n    (fun z => exp (b * z)) =o[l] fun z => z ^ a := by simpa using hl.isLittleO_cpow_mul_exp hb 0 a\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "context": {"open": ["Asymptotics Filter Function", "scoped Topology"], "variables": ["{l : Filter \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u2102\nx\u271d\u00b9 : Sort u_1\nIsExpCmpFilter : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nhl : sorry\na : \u2102\nb : \u211d\nhb : b < 0\n\u22a2 (fun z => ?m.423) =o[l] fun z => z ^ a"}, {"line": "simpa using hl.isLittleO_cpow_mul_exp hb 0 a", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_pow_mul_exp {b\u2081 b\u2082 : \u211d} (hl : IsExpCmpFilter l) (hb : b\u2081 < b\u2082) (m n : \u2115) :\n    (fun z => z ^ m * exp (b\u2081 * z)) =o[l] fun z => z ^ n * exp (b\u2082 * z) := by\n  simpa only [cpow_natCast] using hl.isLittleO_cpow_mul_exp hb m n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "context": {"open": ["Asymptotics Filter Function", "scoped Topology"], "variables": ["{l : Filter \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u2102\nx\u271d\u00b9 : Sort u_1\nIsExpCmpFilter : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nb\u2081 b\u2082 : \u211d\nhl : sorry\nhb : b\u2081 < b\u2082\nm n : \u2115\n\u22a2 (fun z => z ^ m * sorry) =o[l] fun z => z ^ n * sorry"}, {"line": "simpa only [cpow_natCast] using hl.isLittleO_cpow_mul_exp hb m n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_zpow_mul_exp {b\u2081 b\u2082 : \u211d} (hl : IsExpCmpFilter l) (hb : b\u2081 < b\u2082) (m n : \u2124) :\n    (fun z => z ^ m * exp (b\u2081 * z)) =o[l] fun z => z ^ n * exp (b\u2082 * z) := by\n  simpa only [cpow_intCast] using hl.isLittleO_cpow_mul_exp hb m n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/CompareExp.lean", "context": {"open": ["Asymptotics Filter Function", "scoped Topology"], "variables": ["{l : Filter \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "l : Filter \u2102\nx\u271d\u00b9 : Sort u_1\nIsExpCmpFilter : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nb\u2081 b\u2082 : \u211d\nhl : sorry\nhb : b\u2081 < b\u2082\nm n : \u2124\n\u22a2 (fun z => z ^ m * sorry) =o[l] fun z => z ^ n * sorry"}, {"line": "simpa only [cpow_intCast] using hl.isLittleO_cpow_mul_exp hb m n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_sub_sum_range_isBigO_pow (n : \u2115) :\n    (fun x \u21a6 exp x - \u2211 i \u2208 Finset.range n, x ^ i / i !) =O[\ud835\udcdd 0] (\u00b7 ^ n) := by\n  have := (Complex.exp_sub_sum_range_isBigO_pow n).comp_tendsto\n    (Complex.continuous_ofReal.tendsto' 0 0 rfl)\n  simp only [Function.comp_def] at this\n  norm_cast at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exp.lean", "context": {"open": ["Asymptotics Bornology Finset Filter Function Metric Set Topology", "scoped Nat", "Complex"], "variables": ["{z y x : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} {x : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 (fun x => exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) =O[nhds 0] fun x => x ^ n"}, {"line": "have := (Complex.exp_sub_sum_range_isBigO_pow n).comp_tendsto\n    (Complex.continuous_ofReal.tendsto' 0 0 rfl)", "tactic_state": "n : \u2115\nthis : ((fun x => exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) \u2218 ofReal) =O[nhds 0] ((fun x => x ^ n) \u2218 ofReal)\n\u22a2 (fun x => exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) =O[nhds 0] fun x => x ^ n"}, {"line": "simp only [Function.comp_def] at this", "tactic_state": "n : \u2115\nthis : (fun x => exp \u2191x - \u2211 i \u2208 Finset.range n, \u2191x ^ i / \u2191i.factorial) =O[nhds 0] fun x => \u2191x ^ n\n\u22a2 (fun x => exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) =O[nhds 0] fun x => x ^ n"}, {"line": "norm_cast at this", "tactic_state": "n : \u2115\nthis : (fun x => Real.exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) =O[nhds 0] fun x => x ^ n\n\u22a2 (fun x => exp x - \u2211 i \u2208 Finset.range n, x ^ i / \u2191i.factorial) =O[nhds 0] fun x => x ^ n"}]}
{"declaration": "theorem tendsto_exp_nhds_zero_nhds_one : Tendsto exp (\ud835\udcdd 0) (\ud835\udcdd 1) := by\n  convert continuous_exp.tendsto 0\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exp.lean", "context": {"open": ["Asymptotics Bornology Finset Filter Function Metric Set Topology", "scoped Nat", "Complex", "Real"], "variables": ["{z y x : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*} {x y z : \u211d} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto sorry (nhds 0) (nhds 1)"}, {"line": "convert continuous_exp.tendsto 0", "tactic_state": "case h.e'_3\n\u22a2 sorry = Complex.exp\n---\ncase h.e'_5.h.e'_3\n\u22a2 1 = Complex.exp 0"}, {"line": "simp", "tactic_state": "case h.e'_3\n\u22a2 sorry () = Complex.exp\n---\ncase h.e'_5.h.e'_3\n\u22a2 1 = Complex.exp 0"}]}
{"declaration": "theorem tendsto_comp_exp_atBot {f : \u211d \u2192 \u03b1} :\n    Tendsto (fun x => f (exp x)) atBot l \u2194 Tendsto f (\ud835\udcdd[>] 0) l := by\n  rw [\u2190 map_exp_atBot]\n  rw [tendsto_map'_iff]\n  rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exp.lean", "context": {"open": ["Asymptotics Bornology Finset Filter Function Metric Set Topology", "scoped Nat", "Complex", "Real"], "variables": ["{z y x : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*} {x y z : \u211d} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_3\nl : Filter \u03b1\nf : \u211d \u2192 \u03b1\n\u22a2 Tendsto (fun x => f (Real.exp x)) atBot l \u2194 Tendsto f (nhdsWithin 0 (Set.Ioi 0)) l"}, {"line": "rw [\u2190 map_exp_atBot]", "tactic_state": "\u03b1 : Type u_3\nl : Filter \u03b1\nf : \u211d \u2192 \u03b1\n\u22a2 Tendsto (fun x => f (Real.exp x)) atBot l \u2194 Tendsto f (Filter.map Real.exp atBot) l"}, {"line": "rw [tendsto_map'_iff]", "tactic_state": "\u03b1 : Type u_3\nl : Filter \u03b1\nf : \u211d \u2192 \u03b1\n\u22a2 Tendsto (fun x => f (Real.exp x)) atBot l \u2194 Tendsto (f \u2218 Real.exp) atBot l"}, {"line": "rfl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem comap_exp_nhdsNE : comap exp (\ud835\udcdd[\u2260] 0) = comap re atBot := by\n  have : (exp \u207b\u00b9' {0})\u1d9c = Set.univ := eq_univ_of_forall exp_ne_zero\n  simp [nhdsWithin, comap_exp_nhds_zero, this]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exp.lean", "context": {"open": ["Asymptotics Bornology Finset Filter Function Metric Set Topology", "scoped Nat", "Complex", "Real", "Real in"], "variables": ["{z y x : \u211d}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u2102} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1}", "{\u03b1 : Type*} {x y z : \u211d} {l : Filter \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 comap sorry (nhdsWithin 0 {0}\u1d9c) = comap re atBot"}, {"line": "have : (exp \u207b\u00b9' {0})\u1d9c = Set.univ := eq_univ_of_forall exp_ne_zero", "tactic_state": "this : (sorry \u207b\u00b9' {0})\u1d9c = Set.univ\n\u22a2 comap sorry (nhdsWithin 0 {0}\u1d9c) = comap re atBot"}, {"line": "simp [nhdsWithin, comap_exp_nhds_zero, this]", "tactic_state": "this : (sorry \u207b\u00b9' {0})\u1d9c = Set.univ\n\u22a2 comap (sorry ()) (nhds 0) = comap re atBot"}]}
{"declaration": "theorem hasStrictDerivAt_exp_of_mem_ball [CharZero \ud835\udd42] {x : \ud835\udd42}\n    (hx : x \u2208 EMetric.ball (0 : \ud835\udd42) (expSeries \ud835\udd42 \ud835\udd42).radius) :\n    HasStrictDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x := by\n  simpa using (hasStrictFDerivAt_exp_of_mem_ball hx).hasStrictDerivAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exponential.lean", "context": {"open": ["Filter RCLike ContinuousMultilinearMap NormedField NormedSpace Asymptotics", "scoped Nat Topology ENNReal"], "variables": ["{\ud835\udd42 \ud835\udd38 : Type*} [NontriviallyNormedField \ud835\udd42] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38]", "{\ud835\udd42 \ud835\udd38 : Type*} [NontriviallyNormedField \ud835\udd42] [NormedCommRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38]", "{\ud835\udd42 : Type*} [NontriviallyNormedField \ud835\udd42] [CompleteSpace \ud835\udd42]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd42 : Type u_5\ninst\u271d\u00b2 : NontriviallyNormedField \ud835\udd42\ninst\u271d\u00b9 : CompleteSpace \ud835\udd42\ninst\u271d : CharZero \ud835\udd42\nx : \ud835\udd42\nhx : x \u2208 EMetric.ball 0 (expSeries \ud835\udd42 \ud835\udd42).radius\n\u22a2 HasStrictDerivAt (exp \ud835\udd42) (exp \ud835\udd42 x) x"}, {"line": "simpa using (hasStrictFDerivAt_exp_of_mem_ball hx).hasStrictDerivAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.exp_eq_exp_\u2102 : Complex.exp = NormedSpace.exp \u2102 := by\n  refine funext fun x => ?_\n  rw [Complex.exp]\n  rw [exp_eq_tsum_div]\n  have : CauSeq.IsComplete \u2102 norm := Complex.instIsComplete\n  exact tendsto_nhds_unique x.exp'.tendsto_limit (expSeries_div_summable \u211d x).hasSum.tendsto_sum_nat\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Exponential.lean", "context": {"open": ["Filter RCLike ContinuousMultilinearMap NormedField NormedSpace Asymptotics", "scoped Nat Topology ENNReal"], "variables": ["{\ud835\udd42 \ud835\udd38 : Type*} [NontriviallyNormedField \ud835\udd42] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38]", "{\ud835\udd42 \ud835\udd38 : Type*} [NontriviallyNormedField \ud835\udd42] [NormedCommRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38]", "{\ud835\udd42 : Type*} [NontriviallyNormedField \ud835\udd42] [CompleteSpace \ud835\udd42]", "{\ud835\udd42 \ud835\udd38 : Type*} [RCLike \ud835\udd42] [NormedRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38] [CompleteSpace \ud835\udd38]", "{\ud835\udd42 \ud835\udd38 : Type*} [RCLike \ud835\udd42] [NormedCommRing \ud835\udd38] [NormedAlgebra \ud835\udd42 \ud835\udd38] [CompleteSpace \ud835\udd38]", "{\ud835\udd42 : Type*} [RCLike \ud835\udd42]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 exp = NormedSpace.exp \u2102"}, {"line": "refine funext fun x => ?_", "tactic_state": "x : \u2102\n\u22a2 exp x = NormedSpace.exp \u2102 x"}, {"line": "rw [Complex.exp]", "tactic_state": "x : \u2102\n\u22a2 (exp' x).lim = NormedSpace.exp \u2102 x"}, {"line": "rw [exp_eq_tsum_div]", "tactic_state": "x : \u2102\n\u22a2 (exp' x).lim = (fun x => \u2211' (n : \u2115), x ^ n / \u2191n.factorial) x"}, {"line": "have : CauSeq.IsComplete \u2102 norm := Complex.instIsComplete", "tactic_state": "x : \u2102\nthis : CauSeq.IsComplete \u2102 norm\n\u22a2 (exp' x).lim = (fun x => \u2211' (n : \u2115), x ^ n / \u2191n.factorial) x"}, {"line": "exact tendsto_nhds_unique x.exp'.tendsto_limit (expSeries_div_summable \u211d x).hasSum.tendsto_sum_nat", "tactic_state": "No Goals!"}]}
{"declaration": "theorem differentiable_descPochhammer_eval : Differentiable \ud835\udd5c (descPochhammer \ud835\udd5c n).eval := by\n  simp [descPochhammer_eval_eq_prod_range, Differentiable.finset_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u22a2 Differentiable \ud835\udd5c fun a => Polynomial.eval a (descPochhammer \ud835\udd5c n)"}, {"line": "simp [descPochhammer_eval_eq_prod_range, Differentiable.finset_prod]", "tactic_state": "n : \u2115\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u22a2 Differentiable \ud835\udd5c fun a => \u220f j \u2208 Finset.range n, (a - \u2191j)"}]}
{"declaration": "theorem continuous_descPochhammer_eval : Continuous (descPochhammer \ud835\udd5c n).eval := by\n  exact differentiable_descPochhammer_eval.continuous\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\n\u22a2 Continuous fun a => Polynomial.eval a (descPochhammer \ud835\udd5c n)"}, {"line": "exact differentiable_descPochhammer_eval.continuous", "tactic_state": "No Goals!"}]}
{"declaration": "lemma deriv_descPochhammer_eval_eq_sum_prod_range_erase (n : \u2115) (k : \ud835\udd5c) :\n    deriv (descPochhammer \ud835\udd5c n).eval k\n      = \u2211 i \u2208 Finset.range n, \u220f j \u2208 (Finset.range n).erase i, (k - j) := by\n  simp [descPochhammer_eval_eq_prod_range, deriv_finset_prod]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn : \u2115\nk : \ud835\udd5c\n\u22a2 deriv (fun a => Polynomial.eval a (descPochhammer \ud835\udd5c n)) k =\n    \u2211 i \u2208 Finset.range n, \u220f j \u2208 (Finset.range n).erase i, (k - \u2191j)"}, {"line": "simp [descPochhammer_eval_eq_prod_range, deriv_finset_prod]", "tactic_state": "\ud835\udd5c : Type u_1\ninst\u271d : NontriviallyNormedField \ud835\udd5c\nn : \u2115\nk : \ud835\udd5c\n\u22a2 deriv (fun a => \u220f j \u2208 Finset.range n, (a - \u2191j)) k = \u2211 i \u2208 Finset.range n, \u220f j \u2208 (Finset.range n).erase i, (k - \u2191j)"}]}
{"declaration": "theorem convexOn_descPochhammer_eval (n : \u2115) :\n    ConvexOn \u211d (Set.Ici (n - 1 : \u211d)) (descPochhammer \u211d n).eval := by\n  rcases n.eq_zero_or_pos with h_eq | _\n  \u00b7 simp [h_eq, convexOn_const, convex_Ici]\n  \u00b7 apply MonotoneOn.convexOn_of_deriv (convex_Ici (n - 1 : \u211d))\n      continuous_descPochhammer_eval.continuousOn\n      differentiable_descPochhammer_eval.differentiableOn\n    rw [interior_Ici]\n    exact monotoneOn_deriv_descPochhammer_eval n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 ConvexOn \u211d (Set.Ici (\u2191n - 1)) fun a => Polynomial.eval a (descPochhammer \u211d n)"}, {"line": "rcases n.eq_zero_or_pos with h_eq | _", "tactic_state": "case inl\nn : \u2115\nh_eq : n = 0\n\u22a2 ConvexOn \u211d (Set.Ici (\u2191n - 1)) fun a => Polynomial.eval a (descPochhammer \u211d n)\n---\ncase inr\nn : \u2115\nh\u271d : n > 0\n\u22a2 ConvexOn \u211d (Set.Ici (\u2191n - 1)) fun a => Polynomial.eval a (descPochhammer \u211d n)"}, {"line": "\u00b7 simp [h_eq, convexOn_const, convex_Ici]", "tactic_state": "case inr\nn : \u2115\nh\u271d : n > 0\n\u22a2 ConvexOn \u211d (Set.Ici (\u2191n - 1)) fun a => Polynomial.eval a (descPochhammer \u211d n)"}, {"line": "\u00b7 apply MonotoneOn.convexOn_of_deriv (convex_Ici (n - 1 : \u211d))\n      continuous_descPochhammer_eval.continuousOn\n      differentiable_descPochhammer_eval.differentiableOn\n    rw [interior_Ici]\n    exact monotoneOn_deriv_descPochhammer_eval n", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma piecewise_Ici_descPochhammer_eval_zero_eq_descFactorial (k n : \u2115) :\n    (Set.Ici (n - 1 : \u211d)).piecewise (descPochhammer \u211d n).eval 0 k\n      = k.descFactorial n := by\n  rw [Set.piecewise]\n  rw [descPochhammer_eval_eq_descFactorial]\n  rw [ite_eq_left_iff]\n  rw [Set.mem_Ici]\n  rw [not_le]\n  rw [eq_comm]\n  rw [Pi.zero_apply]\n  rw [Nat.cast_eq_zero]\n  rw [Nat.descFactorial_eq_zero_iff_lt]\n  rw [\u2190 @Nat.cast_lt \u211d]\n  exact (sub_lt_self (n : \u211d) zero_lt_one).trans'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k n : \u2115\n\u22a2 (Set.Ici (\u2191n - 1)).piecewise (fun a => Polynomial.eval a (descPochhammer \u211d n)) 0 \u2191k = \u2191(k.descFactorial n)"}, {"line": "rw [Set.piecewise]", "tactic_state": "k n : \u2115\n\u22a2 (if \u2191k \u2208 Set.Ici (\u2191n - 1) then Polynomial.eval (\u2191k) (descPochhammer \u211d n) else 0 \u2191k) = \u2191(k.descFactorial n)"}, {"line": "rw [descPochhammer_eval_eq_descFactorial]", "tactic_state": "k n : \u2115\n\u22a2 (if \u2191k \u2208 Set.Ici (\u2191n - 1) then \u2191(k.descFactorial n) else 0 \u2191k) = \u2191(k.descFactorial n)"}, {"line": "rw [ite_eq_left_iff]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k \u2209 Set.Ici (\u2191n - 1) \u2192 0 \u2191k = \u2191(k.descFactorial n)"}, {"line": "rw [Set.mem_Ici]", "tactic_state": "k n : \u2115\n\u22a2 \u00ac\u2191n - 1 \u2264 \u2191k \u2192 0 \u2191k = \u2191(k.descFactorial n)"}, {"line": "rw [not_le]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 0 \u2191k = \u2191(k.descFactorial n)"}, {"line": "rw [eq_comm]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 \u2191(k.descFactorial n) = 0 \u2191k"}, {"line": "rw [Pi.zero_apply]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 \u2191(k.descFactorial n) = 0"}, {"line": "rw [Nat.cast_eq_zero]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 k.descFactorial n = 0"}, {"line": "rw [Nat.descFactorial_eq_zero_iff_lt]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 k < n"}, {"line": "rw [\u2190 @Nat.cast_lt \u211d]", "tactic_state": "k n : \u2115\n\u22a2 \u2191k < \u2191n - 1 \u2192 \u2191k < \u2191n"}, {"line": "exact (sub_lt_self (n : \u211d) zero_lt_one).trans'", "tactic_state": "No Goals!"}]}
{"declaration": "private lemma convexOn_piecewise_Ici_descPochhammer_eval_zero (hn : n \u2260 0) :\n    ConvexOn \u211d Set.univ ((Set.Ici (n - 1 : \u211d)).piecewise (descPochhammer \u211d n).eval 0) := by\n  rw [\u2190 Nat.pos_iff_ne_zero] at hn\n  apply convexOn_univ_piecewise_Ici_of_monotoneOn_Ici_antitoneOn_Iic\n    (convexOn_descPochhammer_eval n) (convexOn_const 0 (convex_Iic (n - 1 : \u211d)))\n    (monotoneOn_descPochhammer_eval n) antitoneOn_const\n  simpa [\u2190 Nat.cast_pred hn] using descPochhammer_eval_coe_nat_of_lt (Nat.sub_one_lt_of_lt hn)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u22a2 ConvexOn \u211d Set.univ ((Set.Ici (\u2191n - 1)).piecewise (fun a => Polynomial.eval a (descPochhammer \u211d n)) 0)"}, {"line": "rw [\u2190 Nat.pos_iff_ne_zero] at hn", "tactic_state": "n : \u2115\nhn : 0 < n\n\u22a2 ConvexOn \u211d Set.univ ((Set.Ici (\u2191n - 1)).piecewise (fun a => Polynomial.eval a (descPochhammer \u211d n)) 0)"}, {"line": "apply convexOn_univ_piecewise_Ici_of_monotoneOn_Ici_antitoneOn_Iic\n    (convexOn_descPochhammer_eval n) (convexOn_const 0 (convex_Iic (n - 1 : \u211d)))\n    (monotoneOn_descPochhammer_eval n) antitoneOn_const", "tactic_state": "n : \u2115\nhn : 0 < n\n\u22a2 Polynomial.eval (\u2191n - 1) (descPochhammer \u211d n) = 0"}, {"line": "simpa [\u2190 Nat.cast_pred hn] using descPochhammer_eval_coe_nat_of_lt (Nat.sub_one_lt_of_lt hn)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem descPochhammer_eval_div_factorial_le_sum_choose\n    (hn : n \u2260 0) {\u03b9 : Type*} {t : Finset \u03b9} (p : \u03b9 \u2192 \u2115) (w : \u03b9 \u2192 \u211d)\n    (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : \u2211 i \u2208 t, w i = 1) (h_avg : n - 1 \u2264 \u2211 i \u2208 t, w i * p i) :\n    (descPochhammer \u211d n).eval (\u2211 i \u2208 t, w i * p i) / n.factorial\n      \u2264 \u2211 i \u2208 t, w i * (p i).choose n := by\n  simp_rw [Nat.cast_choose_eq_descPochhammer_div,\n    mul_div, \u2190 Finset.sum_div, descPochhammer_eval_eq_descFactorial]\n  apply div_le_div_of_nonneg_right _ (Nat.cast_nonneg n.factorial)\n  exact descPochhammer_eval_le_sum_descFactorial hn p w h\u2080 h\u2081 h_avg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pochhammer.lean", "context": {"open": [], "variables": ["{n : \u2115} {\ud835\udd5c : Type*} {k : \ud835\udd5c} [NontriviallyNormedField \ud835\udd5c]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u03b9 : Type u_2\nt : Finset \u03b9\np : \u03b9 \u2192 \u2115\nw : \u03b9 \u2192 \u211d\nh\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nh\u2081 : \u2211 i \u2208 t, w i = 1\nh_avg : \u2191n - 1 \u2264 \u2211 i \u2208 t, w i * \u2191(p i)\n\u22a2 Polynomial.eval (\u2211 i \u2208 t, w i * \u2191(p i)) (descPochhammer \u211d n) / \u2191n.factorial \u2264 \u2211 i \u2208 t, w i * \u2191((p i).choose n)"}, {"line": "simp_rw [Nat.cast_choose_eq_descPochhammer_div,\n    mul_div, \u2190 Finset.sum_div, descPochhammer_eval_eq_descFactorial]", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u03b9 : Type u_2\nt : Finset \u03b9\np : \u03b9 \u2192 \u2115\nw : \u03b9 \u2192 \u211d\nh\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nh\u2081 : \u2211 i \u2208 t, w i = 1\nh_avg : \u2191n - 1 \u2264 \u2211 i \u2208 t, w i * \u2191(p i)\n\u22a2 Polynomial.eval (\u2211 i \u2208 t, w i * \u2191(p i)) (descPochhammer \u211d n) / \u2191n.factorial \u2264\n    (\u2211 x \u2208 t, w x * \u2191((p x).descFactorial n)) / \u2191n.factorial"}, {"line": "apply div_le_div_of_nonneg_right _ (Nat.cast_nonneg n.factorial)", "tactic_state": "n : \u2115\nhn : n \u2260 0\n\u03b9 : Type u_2\nt : Finset \u03b9\np : \u03b9 \u2192 \u2115\nw : \u03b9 \u2192 \u211d\nh\u2080 : \u2200 i \u2208 t, 0 \u2264 w i\nh\u2081 : \u2211 i \u2208 t, w i = 1\nh_avg : \u2191n - 1 \u2264 \u2211 i \u2208 t, w i * \u2191(p i)\n\u22a2 Polynomial.eval (\u2211 i \u2208 t, w i * \u2191(p i)) (descPochhammer \u211d n) \u2264 \u2211 x \u2208 t, w x * \u2191((p x).descFactorial n)"}, {"line": "exact descPochhammer_eval_le_sum_descFactorial hn p w h\u2080 h\u2081 h_avg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arsinh_zero : arsinh 0 = 0 := by simp [arsinh]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Arsinh.lean", "context": {"open": ["Function Filter Set", "scoped Topology"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narsinh : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [arsinh]", "tactic_state": "x\u271d : Sort u_1\narsinh : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem bernstein_nonneg {n \u03bd : \u2115} {x : I} : 0 \u2264 bernstein n \u03bd x := by\n  simp only [bernstein_apply]\n  have h\u2081 : (0 : \u211d) \u2264 x := by unit_interval\n  have h\u2082 : (0 : \u211d) \u2264 1 - x := by unit_interval\n  positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "context": {"open": ["scoped BoundedContinuousFunction unitInterval"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n \u03bd : \u2115\nx : \u2191unitInterval\n\u22a2 0 \u2264 (bernstein n \u03bd) x"}, {"line": "simp only [bernstein_apply]", "tactic_state": "n \u03bd : \u2115\nx : \u2191unitInterval\n\u22a2 0 \u2264 \u2191(n.choose \u03bd) * \u2191x ^ \u03bd * (1 - \u2191x) ^ (n - \u03bd)"}, {"line": "have h\u2081 : (0 : \u211d) \u2264 x := sorry", "tactic_state": "n \u03bd : \u2115\nx : \u2191unitInterval\nh\u2081 : 0 \u2264 \u2191x\n\u22a2 0 \u2264 \u2191(n.choose \u03bd) * \u2191x ^ \u03bd * (1 - \u2191x) ^ (n - \u03bd)"}, {"line": "have h\u2082 : (0 : \u211d) \u2264 1 - x := sorry", "tactic_state": "n \u03bd : \u2115\nx : \u2191unitInterval\nh\u2081 : 0 \u2264 \u2191x\nh\u2082 : 0 \u2264 1 - \u2191x\n\u22a2 0 \u2264 \u2191(n.choose \u03bd) * \u2191x ^ \u03bd * (1 - \u2191x) ^ (n - \u03bd)"}, {"line": "positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem probability (n : \u2115) (x : I) : (\u2211 k : Fin (n + 1), bernstein n k x) = 1 := by\n  have := bernsteinPolynomial.sum \u211d n\n  apply_fun fun p => Polynomial.aeval (x : \u211d) p at this\n  simp? [map_sum, Finset.sum_range] at this says\n    simp only [Finset.sum_range] at this\n    simp only [map_sum] at this\n    simp only [Polynomial.coe_aeval_eq_eval] at this\n    simp only [Polynomial.eval_one] at this\n  exact this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nx : \u2191unitInterval\n\u22a2 \u2211 k, (bernstein n \u2191k) x = 1"}, {"line": "have := bernsteinPolynomial.sum \u211d n", "tactic_state": "n : \u2115\nx : \u2191unitInterval\nthis : \u2211 \u03bd \u2208 Finset.range (n + 1), bernsteinPolynomial \u211d n \u03bd = 1\n\u22a2 \u2211 k, (bernstein n \u2191k) x = 1"}, {"line": "apply_fun fun p => Polynomial.aeval (x : \u211d) p at this", "tactic_state": "n : \u2115\nx : \u2191unitInterval\nthis : (Polynomial.aeval \u2191x) (\u2211 \u03bd \u2208 Finset.range (n + 1), bernsteinPolynomial \u211d n \u03bd) = (Polynomial.aeval \u2191x) 1\n\u22a2 \u2211 k, (bernstein n \u2191k) x = 1"}, {"line": "simp? [map_sum, Finset.sum_range] at this says\n    simp only [Finset.sum_range] at this\n    simp only [map_sum] at this\n    simp only [Polynomial.coe_aeval_eq_eval] at this\n    simp only [Polynomial.eval_one] at this", "tactic_state": "n : \u2115\nx : \u2191unitInterval\nthis : \u2211 x_1, Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) = 1\n\u22a2 \u2211 k, (bernstein n \u2191k) x = 1"}, {"line": "exact this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem variance {n : \u2115} (h : 0 < (n : \u211d)) (x : I) :\n    (\u2211 k : Fin (n + 1), (x - k/\u2099 : \u211d) ^ 2 * bernstein n k x) = (x : \u211d) * (1 - x) / n := by\n  have h' : (n : \u211d) \u2260 0 := ne_of_gt h\n  apply_fun fun x : \u211d => x * n using GroupWithZero.mul_left_injective h'\n  apply_fun fun x : \u211d => x * n using GroupWithZero.mul_left_injective h'\n  dsimp\n  conv_lhs => simp only [Finset.sum_mul, z]\n  conv_rhs => rw [div_mul_cancel\u2080 _ h']\n  have := bernsteinPolynomial.variance \u211d n\n  apply_fun fun p => Polynomial.aeval (x : \u211d) p at this\n  simp? [map_sum, Finset.sum_range, \u2190 Polynomial.natCast_mul] at this says\n    simp only [nsmul_eq_mul] at this\n    simp only [Finset.sum_range] at this\n    simp only [map_sum] at this\n    simp only [Polynomial.coe_aeval_eq_eval] at this\n    simp only [Polynomial.eval_mul] at this\n    simp only [Polynomial.eval_pow] at this\n    simp only [Polynomial.eval_sub] at this\n    simp only [Polynomial.eval_natCast] at this\n    simp only [Polynomial.eval_X] at this\n    simp only [Polynomial.eval_one] at this\n  convert this using 1\n  \u00b7 congr 1; funext k\n    rw [mul_comm _ (n : \u211d)]\n    rw [mul_comm _ (n : \u211d)]\n    rw [\u2190 mul_assoc]\n    rw [\u2190 mul_assoc]\n    congr 1\n    field_simp [h]\n    ring\n  \u00b7 ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\n\u22a2 \u2211 k, sorry ^ 2 * (bernstein n \u2191k) x = \u2191x * (1 - \u2191x) / \u2191n"}, {"line": "have h' : (n : \u211d) \u2260 0 := ne_of_gt h", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 \u2211 k, sorry ^ 2 * (bernstein n \u2191k) x = \u2191x * (1 - \u2191x) / \u2191n"}, {"line": "apply_fun fun x : \u211d => x * n using GroupWithZero.mul_left_injective h'", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 (fun x => x * \u2191n) (\u2211 k, sorry ^ 2 * (bernstein n \u2191k) x) = (fun x => x * \u2191n) (\u2191x * (1 - \u2191x) / \u2191n)"}, {"line": "apply_fun fun x : \u211d => x * n using GroupWithZero.mul_left_injective h'", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 (fun x => x * \u2191n) ((fun x => x * \u2191n) (\u2211 k, sorry ^ 2 * (bernstein n \u2191k) x)) =\n    (fun x => x * \u2191n) ((fun x => x * \u2191n) (\u2191x * (1 - \u2191x) / \u2191n))"}, {"line": "dsimp", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 (\u2211 k, sorry () ^ 2 * (bernstein n \u2191k) x) * \u2191n * \u2191n = \u2191x * (1 - \u2191x) / \u2191n * \u2191n * \u2191n"}, {"line": "conv_lhs => simp only [Finset.sum_mul, z]", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n = \u2191x * (1 - \u2191x) / \u2191n * \u2191n * \u2191n"}, {"line": "conv_rhs => rw [div_mul_cancel\u2080 _ h']", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n = \u2191x * (1 - \u2191x) * \u2191n"}, {"line": "have := bernsteinPolynomial.variance \u211d n", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  \u2211 \u03bd \u2208 Finset.range (n + 1), (n \u2022 Polynomial.X - \u2191\u03bd) ^ 2 * bernsteinPolynomial \u211d n \u03bd =\n    n \u2022 Polynomial.X * (1 - Polynomial.X)\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n = \u2191x * (1 - \u2191x) * \u2191n"}, {"line": "apply_fun fun p => Polynomial.aeval (x : \u211d) p at this", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  (Polynomial.aeval \u2191x) (\u2211 \u03bd \u2208 Finset.range (n + 1), (n \u2022 Polynomial.X - \u2191\u03bd) ^ 2 * bernsteinPolynomial \u211d n \u03bd) =\n    (Polynomial.aeval \u2191x) (n \u2022 Polynomial.X * (1 - Polynomial.X))\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n = \u2191x * (1 - \u2191x) * \u2191n"}, {"line": "simp? [map_sum, Finset.sum_range, \u2190 Polynomial.natCast_mul] at this says\n    simp only [nsmul_eq_mul] at this\n    simp only [Finset.sum_range] at this\n    simp only [map_sum] at this\n    simp only [Polynomial.coe_aeval_eq_eval] at this\n    simp only [Polynomial.eval_mul] at this\n    simp only [Polynomial.eval_pow] at this\n    simp only [Polynomial.eval_sub] at this\n    simp only [Polynomial.eval_natCast] at this\n    simp only [Polynomial.eval_X] at this\n    simp only [Polynomial.eval_one] at this", "tactic_state": "n : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  \u2211 x_1, (Polynomial.eval (\u2191x) (\u2191n * Polynomial.X) - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) =\n    \u2191n * \u2191x * (1 - \u2191x)\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n = \u2191x * (1 - \u2191x) * \u2191n"}, {"line": "convert this using 1", "tactic_state": "case h.e'_2\nn : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  \u2211 x_1, (Polynomial.eval (\u2191x) (\u2191n * Polynomial.X) - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) =\n    \u2191n * \u2191x * (1 - \u2191x)\n\u22a2 \u2211 i, sorry () ^ 2 * (bernstein n \u2191i) x * \u2191n * \u2191n =\n    \u2211 x_1, (Polynomial.eval (\u2191x) (\u2191n * Polynomial.X) - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1)\n---\ncase h.e'_3\nn : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  \u2211 x_1, (Polynomial.eval (\u2191x) (\u2191n * Polynomial.X) - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) =\n    \u2191n * \u2191x * (1 - \u2191x)\n\u22a2 \u2191x * (1 - \u2191x) * \u2191n = \u2191n * \u2191x * (1 - \u2191x)"}, {"line": "\u00b7 congr 1; funext k\n    rw [mul_comm _ (n : \u211d)]\n    rw [mul_comm _ (n : \u211d)]\n    rw [\u2190 mul_assoc]\n    rw [\u2190 mul_assoc]\n    congr 1\n    field_simp [h]\n    ring", "tactic_state": "case h.e'_3\nn : \u2115\nh : 0 < \u2191n\nx : \u2191unitInterval\nh' : \u2191n \u2260 0\nthis :\n  \u2211 x_1, (Polynomial.eval (\u2191x) (\u2191n * Polynomial.X) - \u2191\u2191x_1) ^ 2 * Polynomial.eval (\u2191x) (bernsteinPolynomial \u211d n \u2191x_1) =\n    \u2191n * \u2191x * (1 - \u2191x)\n\u22a2 \u2191x * (1 - \u2191x) * \u2191n = \u2191n * \u2191x * (1 - \u2191x)"}, {"line": "\u00b7 ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem apply (n : \u2115) (f : C(I, \u211d)) (x : I) :\n    bernsteinApproximation n f x = \u2211 k : Fin (n + 1), f k/\u2099 * bernstein n k x := by\n  simp [bernsteinApproximation]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function", "bernstein"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nf : C(\u2191unitInterval, \u211d)\nx : \u2191unitInterval\n\u22a2 (bernsteinApproximation n f) x = \u2211 k, sorry"}, {"line": "simp [bernsteinApproximation]", "tactic_state": "n : \u2115\nf : C(\u2191unitInterval, \u211d)\nx : \u2191unitInterval\n\u22a2 \u2211 x_1, f (z x_1) * (\u2191(n.choose \u2191x_1) * \u2191x ^ \u2191x_1 * (1 - \u2191x) ^ (n - \u2191x_1)) = (\u2191n + 1) * sorry ()"}]}
{"declaration": "theorem bernsteinApproximation_uniform (f : C(I, \u211d)) :\n    Tendsto (fun n : \u2115 => bernsteinApproximation n f) atTop (\ud835\udcdd f) := by\n  simp only [Metric.nhds_basis_ball.tendsto_right_iff]\n  simp only [Metric.mem_ball]\n  simp only [dist_eq_norm]\n  intro \u03b5 h\n  let \u03b4 := \u03b4 f \u03b5 h\n  have nhds_zero := tendsto_const_div_atTop_nhds_zero_nat (2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124))\n  filter_upwards [nhds_zero.eventually (gt_mem_nhds (half_pos h)), eventually_gt_atTop 0] with n nh\n    npos'\n  have npos : 0 < (n : \u211d) := by positivity\n  -- As `[0,1]` is compact, it suffices to check the inequality pointwise.\n  rw [ContinuousMap.norm_lt_iff _ h]\n  intro x\n  -- The idea is to split up the sum over `k` into two sets,\n  -- `S`, where `x - k/n < \u03b4`, and its complement.\n  let S := S f \u03b5 h n x\n  calc\n    |(bernsteinApproximation n f - f) x| = |bernsteinApproximation n f x - f x| := rfl\n    _ = |bernsteinApproximation n f x - f x * 1| := by rw [mul_one]\n    _ = |bernsteinApproximation n f x - f x * \u2211 k : Fin (n + 1), bernstein n k x| := by\n      rw [bernstein.probability]\n    _ = |\u2211 k : Fin (n + 1), (f k/\u2099 - f x) * bernstein n k x| := by\n      simp [bernsteinApproximation, Finset.mul_sum, sub_mul]\n    _ \u2264 \u2211 k : Fin (n + 1), |(f k/\u2099 - f x) * bernstein n k x| := Finset.abs_sum_le_sum_abs _ _\n    _ = \u2211 k : Fin (n + 1), |f k/\u2099 - f x| * bernstein n k x := by\n      simp_rw [abs_mul, abs_eq_self.mpr bernstein_nonneg]\n    _ = (\u2211 k \u2208 S, |f k/\u2099 - f x| * bernstein n k x) + \u2211 k \u2208 S\u1d9c, |f k/\u2099 - f x| * bernstein n k x :=\n      (S.sum_add_sum_compl _).symm\n    -- We'll now deal with the terms in `S` and the terms in `S\u1d9c` in separate calc blocks.\n    _ < \u03b5 / 2 + \u03b5 / 2 :=\n      (add_lt_add_of_le_of_lt ?_ ?_)\n    _ = \u03b5 := add_halves \u03b5\n  \u00b7 -- We now work on the terms in `S`: uniform continuity and `bernstein.probability`\n    -- quickly give us a bound.\n    calc\n      \u2211 k \u2208 S, |f k/\u2099 - f x| * bernstein n k x \u2264 \u2211 k \u2208 S, \u03b5 / 2 * bernstein n k x := by\n        gcongr with _ m\n        exact le_of_lt (lt_of_mem_S m)\n      _ = \u03b5 / 2 * \u2211 k \u2208 S, bernstein n k x := by rw [Finset.mul_sum]\n      -- In this step we increase the sum over `S` back to a sum over all of `Fin (n+1)`,\n      -- so that we can use `bernstein.probability`.\n      _ \u2264 \u03b5 / 2 * \u2211 k : Fin (n + 1), bernstein n k x := by gcongr; exact S.subset_univ\n      _ = \u03b5 / 2 := by rw [bernstein.probability, mul_one]\n  \u00b7 -- We now turn to working on `S\u1d9c`: we control the difference term just using `\u2016f\u2016`,\n    -- and then insert a `\u03b4^(-2) * (x - k/n)^2` factor\n    -- (which is at least one because we are not in `S`).\n    calc\n      \u2211 k \u2208 S\u1d9c, |f k/\u2099 - f x| * bernstein n k x \u2264 \u2211 k \u2208 S\u1d9c, 2 * \u2016f\u2016 * bernstein n k x := by\n        gcongr\n        apply f.dist_le_two_norm\n      _ = 2 * \u2016f\u2016 * \u2211 k \u2208 S\u1d9c, bernstein n k x := by rw [Finset.mul_sum]\n      _ \u2264 2 * \u2016f\u2016 * \u2211 k \u2208 S\u1d9c, \u03b4 ^ (-2 : \u2124) * ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        gcongr with _ m\n        conv_lhs => rw [\u2190 one_mul (bernstein _ _ _)]\n        gcongr\n        exact le_of_mem_S_compl m\n      -- Again enlarging the sum from `S\u1d9c` to all of `Fin (n+1)`\n      _ \u2264 2 * \u2016f\u2016 * \u2211 k : Fin (n + 1), \u03b4 ^ (-2 : \u2124) * ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        gcongr; exact S\u1d9c.subset_univ\n      _ = 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * \u2211 k : Fin (n + 1), ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        conv_rhs =>\n          rw [mul_assoc]\n          rw [Finset.mul_sum]\n          simp only [\u2190 mul_assoc]\n      -- `bernstein.variance` and `x \u2208 [0,1]` gives the uniform bound\n      _ = 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * x * (1 - x) / n := by rw [variance npos]; ring\n      _ \u2264 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * 1 * 1 / n := by gcongr <;> unit_interval\n      _ < \u03b5 / 2 := by simp only [mul_one]; exact nh", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Bernstein.lean", "context": {"open": ["scoped BoundedContinuousFunction unitInterval", "Lean Meta Qq Function", "bernstein", "bernsteinApproximation", "BoundedContinuousFunction", "Filter", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 Tendsto (fun n => bernsteinApproximation n f) atTop (nhds f)"}, {"line": "simp only [Metric.nhds_basis_ball.tendsto_right_iff]", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 \u2200 (i : \u211d), 0 < i \u2192 \u2200\u1da0 (x : \u2115) in atTop, bernsteinApproximation x f \u2208 Metric.ball f i"}, {"line": "simp only [Metric.mem_ball]", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 \u2200 (i : \u211d), 0 < i \u2192 \u2200\u1da0 (x : \u2115) in atTop, dist (bernsteinApproximation x f) f < i"}, {"line": "simp only [dist_eq_norm]", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u22a2 \u2200 (i : \u211d), 0 < i \u2192 \u2200\u1da0 (x : \u2115) in atTop, \u2016bernsteinApproximation x f - f\u2016 < i"}, {"line": "intro \u03b5 h", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2016bernsteinApproximation x f - f\u2016 < \u03b5"}, {"line": "let \u03b4 := \u03b4 f \u03b5 h", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2016bernsteinApproximation x f - f\u2016 < \u03b5"}, {"line": "have nhds_zero := tendsto_const_div_atTop_nhds_zero_nat (2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124))", "tactic_state": "f : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\n\u22a2 \u2200\u1da0 (x : \u2115) in atTop, \u2016bernsteinApproximation x f - f\u2016 < \u03b5"}, {"line": "filter_upwards [nhds_zero.eventually (gt_mem_nhds (half_pos h)), eventually_gt_atTop 0] with n nh\n    npos'", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\n\u22a2 \u2016bernsteinApproximation n f - f\u2016 < \u03b5"}, {"line": "have npos : 0 < (n : \u211d) := sorry", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\n\u22a2 \u2016bernsteinApproximation n f - f\u2016 < \u03b5"}, {"line": "rw [ContinuousMap.norm_lt_iff _ h]", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\n\u22a2 \u2200 (x : \u2191unitInterval), \u2016(bernsteinApproximation n f - f) x\u2016 < \u03b5"}, {"line": "intro x", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191unitInterval\n\u22a2 \u2016(bernsteinApproximation n f - f) x\u2016 < \u03b5"}, {"line": "let S := S f \u03b5 h n x", "tactic_state": "case h\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191unitInterval\nS : Finset (Fin (n + 1)) := bernsteinApproximation.S f \u03b5 h n x\n\u22a2 \u2016(bernsteinApproximation n f - f) x\u2016 < \u03b5"}, {"line": "calc\n    |(bernsteinApproximation n f - f) x| = |bernsteinApproximation n f x - f x| := rfl\n    _ = |bernsteinApproximation n f x - f x * 1| := by rw [mul_one]\n    _ = |bernsteinApproximation n f x - f x * \u2211 k : Fin (n + 1), bernstein n k x| := by\n      rw [bernstein.probability]\n    _ = |\u2211 k : Fin (n + 1), (f k/\u2099 - f x) * bernstein n k x| := by\n      simp [bernsteinApproximation, Finset.mul_sum, sub_mul]\n    _ \u2264 \u2211 k : Fin (n + 1), |(f k/\u2099 - f x) * bernstein n k x| := Finset.abs_sum_le_sum_abs _ _\n    _ = \u2211 k : Fin (n + 1), |f k/\u2099 - f x| * bernstein n k x := by\n      simp_rw [abs_mul, abs_eq_self.mpr bernstein_nonneg]\n    _ = (\u2211 k \u2208 S, |f k/\u2099 - f x| * bernstein n k x) + \u2211 k \u2208 S\u1d9c, |f k/\u2099 - f x| * bernstein n k x :=\n      (S.sum_add_sum_compl _).symm\n    _ < \u03b5 / 2 + \u03b5 / 2 :=\n      (add_lt_add_of_le_of_lt ?_ ?_)\n    _ = \u03b5 := add_halves \u03b5", "tactic_state": "case h.calc_1\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191unitInterval\nS : Finset (Fin (n + 1)) := bernsteinApproximation.S f \u03b5 h n x\n\u22a2 \u2211 k \u2208 S, |sorry| * (bernstein n \u2191k) x \u2264 \u03b5 / 2\n---\ncase h.calc_2\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191unitInterval\nS : Finset (Fin (n + 1)) := bernsteinApproximation.S f \u03b5 h n x\n\u22a2 \u2211 k \u2208 S\u1d9c, |sorry| * (bernstein n \u2191k) x < \u03b5 / 2"}, {"line": "\u00b7 -- We now work on the terms in `S`: uniform continuity and `bernstein.probability`\n    calc\n      \u2211 k \u2208 S, |f k/\u2099 - f x| * bernstein n k x \u2264 \u2211 k \u2208 S, \u03b5 / 2 * bernstein n k x := by\n        gcongr with _ m\n        exact le_of_lt (lt_of_mem_S m)\n      _ = \u03b5 / 2 * \u2211 k \u2208 S, bernstein n k x := by rw [Finset.mul_sum]\n      _ \u2264 \u03b5 / 2 * \u2211 k : Fin (n + 1), bernstein n k x := by gcongr; exact S.subset_univ\n      _ = \u03b5 / 2 := by rw [bernstein.probability, mul_one]", "tactic_state": "case h.calc_2\nf : C(\u2191unitInterval, \u211d)\n\u03b5 : \u211d\nh : 0 < \u03b5\n\u03b4 : \u211d := bernsteinApproximation.\u03b4 f \u03b5 h\nnhds_zero : Tendsto (fun n => 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n) atTop (nhds 0)\nn : \u2115\nnh : 2 * \u2016f\u2016 * \u03b4 ^ (-2) / \u2191n < \u03b5 / 2\nnpos' : 0 < n\nnpos : 0 < \u2191n\nx : \u2191unitInterval\nS : Finset (Fin (n + 1)) := bernsteinApproximation.S f \u03b5 h n x\n\u22a2 \u2211 k \u2208 S\u1d9c, |sorry| * (bernstein n \u2191k) x < \u03b5 / 2"}, {"line": "\u00b7 -- We now turn to working on `S\u1d9c`: we control the difference term just using `\u2016f\u2016`,\n    calc\n      \u2211 k \u2208 S\u1d9c, |f k/\u2099 - f x| * bernstein n k x \u2264 \u2211 k \u2208 S\u1d9c, 2 * \u2016f\u2016 * bernstein n k x := by\n        gcongr\n        apply f.dist_le_two_norm\n      _ = 2 * \u2016f\u2016 * \u2211 k \u2208 S\u1d9c, bernstein n k x := by rw [Finset.mul_sum]\n      _ \u2264 2 * \u2016f\u2016 * \u2211 k \u2208 S\u1d9c, \u03b4 ^ (-2 : \u2124) * ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        gcongr with _ m\n        conv_lhs => rw [\u2190 one_mul (bernstein _ _ _)]\n        gcongr\n        exact le_of_mem_S_compl m\n      _ \u2264 2 * \u2016f\u2016 * \u2211 k : Fin (n + 1), \u03b4 ^ (-2 : \u2124) * ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        gcongr; exact S\u1d9c.subset_univ\n      _ = 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * \u2211 k : Fin (n + 1), ((x : \u211d) - k/\u2099) ^ 2 * bernstein n k x := by\n        conv_rhs =>\n          rw [mul_assoc]\n          rw [Finset.mul_sum]\n          simp only [\u2190 mul_assoc]\n      _ = 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * x * (1 - x) / n := by rw [variance npos]; ring\n      _ \u2264 2 * \u2016f\u2016 * \u03b4 ^ (-2 : \u2124) * 1 * 1 / n := by gcongr <;> unit_interval\n      _ < \u03b5 / 2 := by simp only [mul_one]; exact nh", "tactic_state": "No Goals!"}]}
{"declaration": "lemma binEntropy_eq_negMulLog_add_negMulLog_one_sub (p : \u211d) :\n    binEntropy p = negMulLog p + negMulLog (1 - p) := by simp [binEntropy, negMulLog, \u2190 neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean", "context": {"open": [], "variables": ["{q : \u2115} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\nbinEntropy : x\u271d\u00b9\nx\u271d : Sort u_2\nnegMulLog : x\u271d\np : \u211d\n\u22a2 sorry = sorry + sorry"}, {"line": "simp [binEntropy, negMulLog, \u2190 neg_mul]", "tactic_state": "x\u271d\u00b9 : Sort u_1\nbinEntropy : x\u271d\u00b9\nx\u271d : Sort u_2\nnegMulLog : x\u271d\np : \u211d\n\u22a2 sorry () = sorry () + sorry ()"}]}
{"declaration": "lemma binEntropy_nonneg (hp\u2080 : 0 \u2264 p) (hp\u2081 : p \u2264 1) : 0 \u2264 binEntropy p := by\n  obtain rfl | hp\u2080 := hp\u2080.eq_or_lt\n  \u00b7 simp\n  obtain rfl | hp\u2081 := hp\u2081.eq_or_lt\n  \u00b7 simp\n  exact (binEntropy_pos hp\u2080 hp\u2081).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean", "context": {"open": [], "variables": ["{q : \u2115} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080 : 0 \u2264 p\nhp\u2081 : p \u2264 1\n\u22a2 0 \u2264 sorry"}, {"line": "obtain rfl | hp\u2080 := hp\u2080.eq_or_lt", "tactic_state": "case inl\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080 : 0 \u2264 0\nhp\u2081 : 0 \u2264 1\n\u22a2 0 \u2264 sorry\n---\ncase inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 0 \u2264 sorry"}, {"line": "obtain rfl | hp\u2081 := hp\u2081.eq_or_lt", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 1\nhp\u2081 : 1 \u2264 1\nhp\u2080 : 0 < 1\n\u22a2 0 \u2264 sorry\n---\ncase inr.inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case inr.inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 0 \u2264 sorry"}, {"line": "exact (binEntropy_pos hp\u2080 hp\u2081).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma binEntropy_nonpos_of_nonpos (hp : p \u2264 0) : binEntropy p \u2264 0 := by\n  obtain rfl | hp := hp.eq_or_lt\n  \u00b7 simp\n  \u00b7 exact (binEntropy_neg_of_neg hp).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean", "context": {"open": [], "variables": ["{q : \u2115} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp : p \u2264 0\n\u22a2 sorry \u2264 0"}, {"line": "obtain rfl | hp := hp.eq_or_lt", "tactic_state": "case inl\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp : 0 \u2264 0\n\u22a2 sorry \u2264 0\n---\ncase inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u271d : p \u2264 0\nhp : p < 0\n\u22a2 sorry \u2264 0"}, {"line": "\u00b7 simp", "tactic_state": "case inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nhp\u271d : p \u2264 0\nhp : p < 0\n\u22a2 sorry \u2264 0"}, {"line": "\u00b7 exact (binEntropy_neg_of_neg hp).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma binEntropy_eq_zero : binEntropy p = 0 \u2194 p = 0 \u2228 p = 1 := by\n  refine \u27e8fun h \u21a6 ?_, by rintro (rfl | rfl) <;> simp\u27e9\n  contrapose! h\n  obtain hp\u2080 | hp\u2080 := h.1.lt_or_lt\n  \u00b7 exact (binEntropy_neg_of_neg hp\u2080).ne\n  obtain hp\u2081 | hp\u2081 := h.2.lt_or_lt.symm\n  \u00b7 exact (binEntropy_neg_of_one_lt hp\u2081).ne\n  \u00b7 exact (binEntropy_pos hp\u2080 hp\u2081).ne'\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean", "context": {"open": [], "variables": ["{q : \u2115} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\n\u22a2 sorry = 0 \u2194 p = 0 \u2228 p = 1"}, {"line": "refine \u27e8fun h \u21a6 ?_, by rintro (rfl | rfl) <;> simp\u27e9", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : sorry = 0\n\u22a2 p = 0 \u2228 p = 1"}, {"line": "contrapose! h", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\n\u22a2 sorry \u2260 0"}, {"line": "obtain hp\u2080 | hp\u2080 := h.1.lt_or_lt", "tactic_state": "case inl\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : p < 0\n\u22a2 sorry \u2260 0\n---\ncase inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : 0 < p\n\u22a2 sorry \u2260 0"}, {"line": "\u00b7 exact (binEntropy_neg_of_neg hp\u2080).ne", "tactic_state": "case inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : 0 < p\n\u22a2 sorry \u2260 0"}, {"line": "obtain hp\u2081 | hp\u2081 := h.2.lt_or_lt.symm", "tactic_state": "case inr.inl\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : 0 < p\nhp\u2081 : 1 < p\n\u22a2 sorry \u2260 0\n---\ncase inr.inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 sorry \u2260 0"}, {"line": "\u00b7 exact (binEntropy_neg_of_one_lt hp\u2081).ne", "tactic_state": "case inr.inr\np : \u211d\nx\u271d : Sort u_1\nbinEntropy : x\u271d\nh : p \u2260 0 \u2227 p \u2260 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 sorry \u2260 0"}, {"line": "\u00b7 exact (binEntropy_pos hp\u2080 hp\u2081).ne'", "tactic_state": "No Goals!"}]}
{"declaration": "lemma qaryEntropy_nonneg (hp\u2080 : 0 \u2264 p) (hp\u2081 : p \u2264 1) : 0 \u2264 qaryEntropy q p := by\n  obtain rfl | hp\u2080 := hp\u2080.eq_or_lt\n  \u00b7 simp\n  obtain rfl | hp\u2081 := hp\u2081.eq_or_lt\n  \u00b7 simpa [qaryEntropy, -Int.cast_sub] using log_intCast_nonneg _\n  exact (qaryEntropy_pos hp\u2080 hp\u2081).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/BinaryEntropy.lean", "context": {"open": [], "variables": ["{q : \u2115} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080 : 0 \u2264 p\nhp\u2081 : p \u2264 1\n\u22a2 0 \u2264 sorry"}, {"line": "obtain rfl | hp\u2080 := hp\u2080.eq_or_lt", "tactic_state": "case inl\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080 : 0 \u2264 0\nhp\u2081 : 0 \u2264 1\n\u22a2 0 \u2264 sorry\n---\ncase inr\np : \u211d\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 simp", "tactic_state": "case inr\np : \u211d\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081 : p \u2264 1\nhp\u2080 : 0 < p\n\u22a2 0 \u2264 sorry"}, {"line": "obtain rfl | hp\u2081 := hp\u2081.eq_or_lt", "tactic_state": "case inr.inl\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 1\nhp\u2081 : 1 \u2264 1\nhp\u2080 : 0 < 1\n\u22a2 0 \u2264 sorry\n---\ncase inr.inr\np : \u211d\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 0 \u2264 sorry"}, {"line": "\u00b7 simpa [qaryEntropy, -Int.cast_sub] using log_intCast_nonneg _", "tactic_state": "case inr.inr\np : \u211d\nx\u271d : Sort u_1\nqaryEntropy : x\u271d\nhp\u2080\u271d : 0 \u2264 p\nhp\u2081\u271d : p \u2264 1\nhp\u2080 : 0 < p\nhp\u2081 : p < 1\n\u22a2 0 \u2264 sorry"}, {"line": "exact (qaryEntropy_pos hp\u2080 hp\u2081).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticOnNhd_cexp : AnalyticOnNhd \u2102 exp univ := by\n  rw [Complex.exp_eq_exp_\u2102]\n  exact fun x _ \u21a6 NormedSpace.exp_analytic x\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "context": {"open": ["Filter Asymptotics Set Function", "scoped Topology", "Complex"], "variables": ["{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{f g : E \u2192 \u2102} {z : \u2102} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 AnalyticOnNhd \u2102 exp univ"}, {"line": "rw [Complex.exp_eq_exp_\u2102]", "tactic_state": "\u22a2 AnalyticOnNhd \u2102 (NormedSpace.exp \u2102) univ"}, {"line": "exact fun x _ \u21a6 NormedSpace.exp_analytic x", "tactic_state": "No Goals!"}]}
{"declaration": "theorem iteratedDeriv_cexp_const_mul (n : \u2115) (c : \u2102) :\n    (iteratedDeriv n fun s : \u2102 => exp (c * s)) = fun s => c ^ n * exp (c * s) := by\n  rw [iteratedDeriv_comp_const_mul contDiff_exp]\n  rw [iteratedDeriv_eq_iterate]\n  rw [iter_deriv_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ExpDeriv.lean", "context": {"open": ["Filter Asymptotics Set Function", "scoped Topology", "Complex", "Complex in"], "variables": ["{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{f g : E \u2192 \u2102} {z : \u2102} {x : E} {s : Set E}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c \u2102]", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c \u2102] {f : \ud835\udd5c \u2192 \u2102} {f' : \u2102} {x : \ud835\udd5c}", "{\ud835\udd5c : Type*} [NontriviallyNormedField \ud835\udd5c] [NormedAlgebra \ud835\udd5c \u2102] {E : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nc : \u2102\n\u22a2 (iteratedDeriv n fun s => exp (c * s)) = fun s => c ^ n * exp (c * s)"}, {"line": "rw [iteratedDeriv_comp_const_mul contDiff_exp]", "tactic_state": "n : \u2115\nc : \u2102\n\u22a2 (fun x => c ^ n * iteratedDeriv n exp (c * x)) = fun s => c ^ n * exp (c * s)"}, {"line": "rw [iteratedDeriv_eq_iterate]", "tactic_state": "n : \u2115\nc : \u2102\n\u22a2 (fun x => c ^ n * deriv^[n] exp (c * x)) = fun s => c ^ n * exp (c * s)"}, {"line": "rw [iter_deriv_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_exp_Iic (c : \u211d) : IntegrableOn exp (Iic c) := by\n  refine\n    integrableOn_Iic_of_intervalIntegral_norm_bounded (exp c) c\n      (fun y => intervalIntegrable_exp.1) tendsto_id\n      (eventually_of_mem (Iic_mem_atBot 0) fun y _ => ?_)\n  simp_rw [norm_of_nonneg (exp_pos _).le, integral_exp, sub_le_self_iff]\n  exact (exp_pos _).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\n\u22a2 IntegrableOn exp (Iic c) volume"}, {"line": "refine\n    integrableOn_Iic_of_intervalIntegral_norm_bounded (exp c) c\n      (fun y => intervalIntegrable_exp.1) tendsto_id\n      (eventually_of_mem (Iic_mem_atBot 0) fun y _ => ?_)", "tactic_state": "c y : \u211d\nx\u271d : y \u2208 Iic 0\n\u22a2 \u222b (x : \u211d) in id y..c, \u2016exp x\u2016 \u2264 exp c"}, {"line": "simp_rw [norm_of_nonneg (exp_pos _).le, integral_exp, sub_le_self_iff]", "tactic_state": "c y : \u211d\nx\u271d : y \u2208 Iic 0\n\u22a2 0 \u2264 exp (id y)"}, {"line": "exact (exp_pos _).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_neg_Ioi (c : \u211d) : (\u222b x : \u211d in Ioi c, exp (-x)) = exp (-c) := by\n  simpa only [integral_comp_neg_Ioi] using integral_exp_Iic (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u211d\n\u22a2 \u222b (x : \u211d) in Ioi c, exp (-x) = exp (-c)"}, {"line": "simpa only [integral_comp_neg_Ioi] using integral_exp_Iic (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_neg_Ioi_zero : (\u222b x : \u211d in Ioi 0, exp (-x)) = 1 := by\n  simpa only [neg_zero,exp_zero] using integral_exp_neg_Ioi 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-x) = 1"}, {"line": "simpa only [neg_zero,exp_zero] using integral_exp_neg_Ioi 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_exp_mul_complex_Ioi {a : \u2102} (ha : a.re < 0) (c : \u211d) :\n    IntegrableOn (fun x : \u211d => Complex.exp (a * x)) (Ioi c) := by\n  refine (integrable_norm_iff ?_).mp ?_\n  \u00b7 apply Continuous.aestronglyMeasurable\n    fun_prop\n  \u00b7 simpa [Complex.norm_exp] using\n      (integrableOn_Ioi_comp_mul_left_iff (fun x => exp (-x)) c (a := -a.re) (by simpa)).mpr <|\n        integrableOn_exp_neg_Ioi _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : a.re < 0\nc : \u211d\n\u22a2 IntegrableOn (fun x => Complex.exp (a * \u2191x)) (Ioi c) volume"}, {"line": "refine (integrable_norm_iff ?_).mp ?_", "tactic_state": "case refine_1\na : \u2102\nha : a.re < 0\nc : \u211d\n\u22a2 AEStronglyMeasurable (fun x => Complex.exp (a * \u2191x)) (volume.restrict (Ioi c))\n---\ncase refine_2\na : \u2102\nha : a.re < 0\nc : \u211d\n\u22a2 Integrable (fun a_1 => \u2016Complex.exp (a * \u2191a_1)\u2016) (volume.restrict (Ioi c))"}, {"line": "\u00b7 apply Continuous.aestronglyMeasurable\n    fun_prop", "tactic_state": "case refine_2\na : \u2102\nha : a.re < 0\nc : \u211d\n\u22a2 Integrable (fun a_1 => \u2016Complex.exp (a * \u2191a_1)\u2016) (volume.restrict (Ioi c))"}, {"line": "\u00b7 simpa [Complex.norm_exp] using\n      (integrableOn_Ioi_comp_mul_left_iff (fun x => exp (-x)) c (a := -a.re) (by simpa)).mpr <|\n        integrableOn_exp_neg_Ioi _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_exp_mul_complex_Iic {a : \u2102} (ha : 0 < a.re) (c : \u211d) :\n    IntegrableOn (fun x : \u211d => Complex.exp (a * x)) (Iic c) := by\n  simpa using integrableOn_Iic_iff_integrableOn_Iio.mpr\n    (integrableOn_exp_mul_complex_Ioi (a := -a) (by simpa) (-c)).comp_neg_Iio\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : 0 < a.re\nc : \u211d\n\u22a2 IntegrableOn (fun x => Complex.exp (a * \u2191x)) (Iic c) volume"}, {"line": "simpa using integrableOn_Iic_iff_integrableOn_Iio.mpr\n    (integrableOn_exp_mul_complex_Ioi (a := -a) (by simpa) (-c)).comp_neg_Iio", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_exp_mul_Ioi {a : \u211d} (ha : a < 0) (c : \u211d) :\n    IntegrableOn (fun x : \u211d => Real.exp (a * x)) (Ioi c) := by\n  have := Integrable.norm <| integrableOn_exp_mul_complex_Ioi (a := a) (by simpa using ha) c\n  simpa [Complex.norm_exp] using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 IntegrableOn (fun x => exp (a * x)) (Ioi c) volume"}, {"line": "have := Integrable.norm <| integrableOn_exp_mul_complex_Ioi (a := a) (by simpa using ha) c", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\nthis : Integrable (fun a_1 => \u2016Complex.exp (\u2191a * \u2191a_1)\u2016) (volume.restrict (Ioi c))\n\u22a2 IntegrableOn (fun x => exp (a * x)) (Ioi c) volume"}, {"line": "simpa [Complex.norm_exp] using this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_exp_mul_Iic {a : \u211d} (ha : 0 < a) (c : \u211d) :\n    IntegrableOn (fun x : \u211d => Real.exp (a * x)) (Iic c) := by\n  have := Integrable.norm <| integrableOn_exp_mul_complex_Iic (a := a) (by simpa using ha) c\n  simpa [Complex.norm_exp] using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : 0 < a\nc : \u211d\n\u22a2 IntegrableOn (fun x => exp (a * x)) (Iic c) volume"}, {"line": "have := Integrable.norm <| integrableOn_exp_mul_complex_Iic (a := a) (by simpa using ha) c", "tactic_state": "a : \u211d\nha : 0 < a\nc : \u211d\nthis : Integrable (fun a_1 => \u2016Complex.exp (\u2191a * \u2191a_1)\u2016) (volume.restrict (Iic c))\n\u22a2 IntegrableOn (fun x => exp (a * x)) (Iic c) volume"}, {"line": "simpa [Complex.norm_exp] using this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_mul_complex_Iic {a : \u2102} (ha : 0 < a.re) (c : \u211d) :\n    \u222b x : \u211d in Set.Iic c, Complex.exp (a * x) = Complex.exp (a * c) / a := by\n  simpa [neg_mul, \u2190 mul_neg, \u2190 Complex.ofReal_neg,\n    integral_comp_neg_Ioi (f := fun x : \u211d \u21a6 Complex.exp (a * x))]\n    using integral_exp_mul_complex_Ioi (a := -a) (by simpa) (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : 0 < a.re\nc : \u211d\n\u22a2 \u222b (x : \u211d) in Iic c, Complex.exp (a * \u2191x) = Complex.exp (a * \u2191c) / a"}, {"line": "simpa [neg_mul, \u2190 mul_neg, \u2190 Complex.ofReal_neg,\n    integral_comp_neg_Ioi (f := fun x : \u211d \u21a6 Complex.exp (a * x))]\n    using integral_exp_mul_complex_Ioi (a := -a) (by simpa) (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_mul_Ioi {a : \u211d} (ha : a < 0) (c : \u211d) :\n    \u222b x : \u211d in Set.Ioi c, Real.exp (a * x) = - Real.exp (a * c) / a := by\n  simp_rw [Real.exp, \u2190 RCLike.re_to_complex, Complex.ofReal_mul]\n  rw [integral_re]\n  rw [integral_exp_mul_complex_Ioi (by simpa using ha)]\n  rw [RCLike.re_to_complex]\n  rw [RCLike.re_to_complex]\n  rw [Complex.div_ofReal_re]\n  rw [Complex.neg_re]\n  exact integrableOn_exp_mul_complex_Ioi  (by simpa using ha) _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 \u222b (x : \u211d) in Ioi c, exp (a * x) = -exp (a * c) / a"}, {"line": "simp_rw [Real.exp, \u2190 RCLike.re_to_complex, Complex.ofReal_mul]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 \u222b (x : \u211d) in Ioi c, RCLike.re (Complex.exp (\u2191a * \u2191x)) = -RCLike.re (Complex.exp (\u2191a * \u2191c)) / a"}, {"line": "rw [integral_re]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 RCLike.re (\u222b (x : \u211d) in Ioi c, Complex.exp (\u2191a * \u2191x)) = -RCLike.re (Complex.exp (\u2191a * \u2191c)) / a\n---\na : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "rw [integral_exp_mul_complex_Ioi (by simpa using ha)]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 RCLike.re (-Complex.exp (\u2191a * \u2191c) / \u2191a) = -RCLike.re (Complex.exp (\u2191a * \u2191c)) / a\n---\na : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "rw [RCLike.re_to_complex]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 (-Complex.exp (\u2191a * \u2191c) / \u2191a).re = -RCLike.re (Complex.exp (\u2191a * \u2191c)) / a\n---\na : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "rw [RCLike.re_to_complex]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 (-Complex.exp (\u2191a * \u2191c) / \u2191a).re = -(Complex.exp (\u2191a * \u2191c)).re / a\n---\na : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "rw [Complex.div_ofReal_re]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 (-Complex.exp (\u2191a * \u2191c)).re / a = -(Complex.exp (\u2191a * \u2191c)).re / a\n---\na : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "rw [Complex.neg_re]", "tactic_state": "a : \u211d\nha : a < 0\nc : \u211d\n\u22a2 Integrable (fun x => Complex.exp (\u2191a * \u2191x)) (volume.restrict (Ioi c))"}, {"line": "exact integrableOn_exp_mul_complex_Ioi  (by simpa using ha) _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_mul_Iic {a : \u211d} (ha : 0 < a) (c : \u211d) :\n    \u222b x : \u211d in Set.Iic c, Real.exp (a * x) = Real.exp (a * c) / a := by\n  simpa [neg_mul, \u2190 mul_neg, integral_comp_neg_Ioi (f := fun x : \u211d \u21a6 Real.exp (a * x))]\n    using integral_exp_mul_Ioi (a := -a) (by simpa) (-c)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : 0 < a\nc : \u211d\n\u22a2 \u222b (x : \u211d) in Iic c, exp (a * x) = exp (a * c) / a"}, {"line": "simpa [neg_mul, \u2190 mul_neg, integral_comp_neg_Ioi (f := fun x : \u211d \u21a6 Real.exp (a * x))]\n    using integral_exp_mul_Ioi (a := -a) (by simpa) (-c)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableAtFilter_rpow_atTop_iff {s : \u211d} :\n    IntegrableAtFilter (fun x : \u211d \u21a6 x ^ s) atTop \u2194 s < -1 := by\n  refine \u27e8fun \u27e8t, ht, hint\u27e9 \u21a6 ?_, fun h \u21a6\n    \u27e8Set.Ioi 1, Ioi_mem_atTop 1, (integrableOn_Ioi_rpow_iff zero_lt_one).mpr h\u27e9\u27e9\n  obtain \u27e8a, ha\u27e9 := mem_atTop_sets.mp ht\n  refine (integrableOn_Ioi_rpow_iff (zero_lt_one.trans_le (le_max_right a 1))).mp ?_\n  exact hint.mono_set <| fun x hx \u21a6 ha _ <| (le_max_left a 1).trans hx.le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 IntegrableAtFilter (fun x => x ^ s) atTop volume \u2194 s < -1"}, {"line": "refine \u27e8fun \u27e8t, ht, hint\u27e9 \u21a6 ?_, fun h \u21a6\n    \u27e8Set.Ioi 1, Ioi_mem_atTop 1, (integrableOn_Ioi_rpow_iff zero_lt_one).mpr h\u27e9\u27e9", "tactic_state": "s : \u211d\nx\u271d : IntegrableAtFilter (fun x => x ^ s) atTop volume\nt : Set \u211d\nht : t \u2208 atTop\nhint : IntegrableOn (fun x => x ^ s) t volume\n\u22a2 s < -1"}, {"line": "obtain \u27e8a, ha\u27e9 := mem_atTop_sets.mp ht", "tactic_state": "case intro\ns : \u211d\nx\u271d : IntegrableAtFilter (fun x => x ^ s) atTop volume\nt : Set \u211d\nht : t \u2208 atTop\nhint : IntegrableOn (fun x => x ^ s) t volume\na : \u211d\nha : \u2200 b \u2265 a, b \u2208 t\n\u22a2 s < -1"}, {"line": "refine (integrableOn_Ioi_rpow_iff (zero_lt_one.trans_le (le_max_right a 1))).mp ?_", "tactic_state": "case intro\ns : \u211d\nx\u271d : IntegrableAtFilter (fun x => x ^ s) atTop volume\nt : Set \u211d\nht : t \u2208 atTop\nhint : IntegrableOn (fun x => x ^ s) t volume\na : \u211d\nha : \u2200 b \u2265 a, b \u2208 t\n\u22a2 IntegrableOn (fun x => x ^ s) (Ioi (max a 1)) volume"}, {"line": "exact hint.mono_set <| fun x hx \u21a6 ha _ <| (le_max_left a 1).trans hx.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_norm_cpow_of_lt {a : \u2102} (ha : a.re < -1) {c : \u211d} (hc : 0 < c) :\n    IntegrableOn (fun t : \u211d \u21a6 \u2016(t : \u2102) ^ a\u2016) (Ioi c) := by\n  refine (integrableOn_Ioi_rpow_of_lt ha hc).congr_fun (fun x hx => ?_) measurableSet_Ioi\n  rw [Complex.norm_cpow_eq_rpow_re_of_pos (hc.trans hx)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : a.re < -1\nc : \u211d\nhc : 0 < c\n\u22a2 IntegrableOn (fun t => \u2016\u2191t ^ a\u2016) (Ioi c) volume"}, {"line": "refine (integrableOn_Ioi_rpow_of_lt ha hc).congr_fun (fun x hx => ?_) measurableSet_Ioi", "tactic_state": "a : \u2102\nha : a.re < -1\nc : \u211d\nhc : 0 < c\nx : \u211d\nhx : x \u2208 Ioi c\n\u22a2 x ^ a.re = \u2016\u2191x ^ a\u2016"}, {"line": "rw [Complex.norm_cpow_eq_rpow_re_of_pos (hc.trans hx)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_cpow_of_lt {a : \u2102} (ha : a.re < -1) {c : \u211d} (hc : 0 < c) :\n    IntegrableOn (fun t : \u211d => (t : \u2102) ^ a) (Ioi c) := by\n  refine (integrable_norm_iff ?_).mp <| integrableOn_Ioi_norm_cpow_of_lt ha hc\n  refine ContinuousOn.aestronglyMeasurable (fun t ht \u21a6 ?_) measurableSet_Ioi\n  exact (Complex.continuousAt_ofReal_cpow_const _ _ (Or.inr (hc.trans ht).ne')).continuousWithinAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : a.re < -1\nc : \u211d\nhc : 0 < c\n\u22a2 IntegrableOn (fun t => \u2191t ^ a) (Ioi c) volume"}, {"line": "refine (integrable_norm_iff ?_).mp <| integrableOn_Ioi_norm_cpow_of_lt ha hc", "tactic_state": "a : \u2102\nha : a.re < -1\nc : \u211d\nhc : 0 < c\n\u22a2 AEStronglyMeasurable (fun t => \u2191t ^ a) (volume.restrict (Ioi c))"}, {"line": "refine ContinuousOn.aestronglyMeasurable (fun t ht \u21a6 ?_) measurableSet_Ioi", "tactic_state": "a : \u2102\nha : a.re < -1\nc : \u211d\nhc : 0 < c\nt : \u211d\nht : t \u2208 Ioi c\n\u22a2 ContinuousWithinAt (fun t => \u2191t ^ a) (Ioi c) t"}, {"line": "exact (Complex.continuousAt_ofReal_cpow_const _ _ (Or.inr (hc.trans ht).ne')).continuousWithinAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_norm_cpow_iff {s : \u2102} {t : \u211d} (ht : 0 < t) :\n    IntegrableOn (fun x : \u211d \u21a6 \u2016(x : \u2102) ^ s\u2016) (Ioi t) \u2194 s.re < -1 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 integrableOn_Ioi_norm_cpow_of_lt h ht\u27e9\n  refine (integrableOn_Ioi_rpow_iff ht).mp <| h.congr_fun (fun a ha \u21a6 ?_) measurableSet_Ioi\n  rw [Complex.norm_cpow_eq_rpow_re_of_pos (ht.trans ha)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\n\u22a2 IntegrableOn (fun x => \u2016\u2191x ^ s\u2016) (Ioi t) volume \u2194 s.re < -1"}, {"line": "refine \u27e8fun h \u21a6 ?_, fun h \u21a6 integrableOn_Ioi_norm_cpow_of_lt h ht\u27e9", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\nh : IntegrableOn (fun x => \u2016\u2191x ^ s\u2016) (Ioi t) volume\n\u22a2 s.re < -1"}, {"line": "refine (integrableOn_Ioi_rpow_iff ht).mp <| h.congr_fun (fun a ha \u21a6 ?_) measurableSet_Ioi", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\nh : IntegrableOn (fun x => \u2016\u2191x ^ s\u2016) (Ioi t) volume\na : \u211d\nha : a \u2208 Ioi t\n\u22a2 \u2016\u2191a ^ s\u2016 = a ^ s.re"}, {"line": "rw [Complex.norm_cpow_eq_rpow_re_of_pos (ht.trans ha)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_Ioi_deriv_ofReal_cpow {s : \u2102} {t : \u211d} (ht : 0 < t) (hs : s.re < 0) :\n    IntegrableOn (deriv fun x : \u211d \u21a6 (x : \u2102) ^ s) (Set.Ioi t) := by\n  have h : IntegrableOn (fun x : \u211d \u21a6 s * x ^ (s - 1)) (Set.Ioi t) := by\n    refine (integrableOn_Ioi_cpow_of_lt ?_ ht).const_mul _\n    rwa [Complex.sub_re, Complex.one_re, sub_lt_iff_lt_add, neg_add_cancel]\n  refine h.congr_fun (fun x hx \u21a6 ?_) measurableSet_Ioi\n  rw [Complex.deriv_ofReal_cpow_const (ht.trans hx).ne' (fun h \u21a6 (Complex.zero_re \u25b8 h \u25b8 hs).false)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\nhs : s.re < 0\n\u22a2 IntegrableOn (deriv fun x => \u2191x ^ s) (Ioi t) volume"}, {"line": "have h : IntegrableOn (fun x : \u211d \u21a6 s * x ^ (s - 1)) (Set.Ioi t) := sorry", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\nhs : s.re < 0\nh : IntegrableOn (fun x => s * \u2191x ^ (s - 1)) (Ioi t) volume\n\u22a2 IntegrableOn (deriv fun x => \u2191x ^ s) (Ioi t) volume"}, {"line": "refine h.congr_fun (fun x hx \u21a6 ?_) measurableSet_Ioi", "tactic_state": "s : \u2102\nt : \u211d\nht : 0 < t\nhs : s.re < 0\nh : IntegrableOn (fun x => s * \u2191x ^ (s - 1)) (Ioi t) volume\nx : \u211d\nhx : x \u2208 Ioi t\n\u22a2 s * \u2191x ^ (s - 1) = deriv (fun x => \u2191x ^ s) x"}, {"line": "rw [Complex.deriv_ofReal_cpow_const (ht.trans hx).ne' (fun h \u21a6 (Complex.zero_re \u25b8 h \u25b8 hs).false)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_inv_one_add_sq : Integrable fun (x : \u211d) \u21a6 (1 + x ^ 2)\u207b\u00b9 := by\n  suffices Integrable fun (x : \u211d) \u21a6 (1 + \u2016x\u2016 ^ 2) ^ ((-2 : \u211d) / 2) by simpa [rpow_neg_one]\n  exact integrable_rpow_neg_one_add_norm_sq (by simp)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ImproperIntegrals.lean", "context": {"open": ["Real Set Filter MeasureTheory intervalIntegral", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Integrable (fun x => (1 + x ^ 2)\u207b\u00b9) volume"}, {"line": "suffices Integrable fun (x : \u211d) \u21a6 (1 + \u2016x\u2016 ^ 2) ^ ((-2 : \u211d) / 2) by simpa [rpow_neg_one]", "tactic_state": "\u22a2 Integrable (fun x => (1 + \u2016x\u2016 ^ 2) ^ (-2 / 2)) volume"}, {"line": "exact integrable_rpow_neg_one_add_norm_sq (by simp)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_inv (h : \u2200 x : \u211d, x \u2208 [[a, b]] \u2192 f x \u2260 0)\n    (hf : ContinuousOn f [[a, b]]) : IntervalIntegrable (fun x => (f x)\u207b\u00b9) \u03bc a b := by\n  simpa only [one_div] using intervalIntegrable_one_div h hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nf : \u211d \u2192 \u211d\n\u03bc : Measure \u211d\ninst\u271d : IsLocallyFiniteMeasure \u03bc\nh : \u2200 x \u2208 Set.uIcc a b, f x \u2260 0\nhf : ContinuousOn f (Set.uIcc a b)\n\u22a2 IntervalIntegrable (fun x => (f x)\u207b\u00b9) \u03bc a b"}, {"line": "simpa only [one_div] using intervalIntegrable_one_div h hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_log' : IntervalIntegrable log volume a b := by\n  -- Log is even, so it suffices to consider the case 0 < a and b = 0\n  apply intervalIntegrable_of_even (log_neg_eq_log \u00b7 |>.symm)\n  intro x hx\n  -- Split integral\n  apply IntervalIntegrable.trans (b := 1)\n  \u00b7 -- Show integrability on [0\u20261] using non-negativity of the derivative\n    rw [\u2190 neg_neg log]\n    apply IntervalIntegrable.neg\n    apply intervalIntegrable_deriv_of_nonneg (g := fun x \u21a6 -(x * log x - x))\n    \u00b7 exact (continuous_mul_log.continuousOn.sub continuous_id.continuousOn).neg\n    \u00b7 intro s \u27e8hs, _\u27e9\n      norm_num at *\n      simpa using (hasDerivAt_id s).sub (hasDerivAt_mul_log hs.ne.symm)\n    \u00b7 intro s \u27e8hs\u2081, hs\u2082\u27e9\n      norm_num at *\n      exact (log_nonpos_iff hs\u2081.le).mpr hs\u2082.le\n  \u00b7 -- Show integrability on [1\u2026t] by continuity\n    apply ContinuousOn.intervalIntegrable\n    apply Real.continuousOn_log.mono\n    apply Set.not_mem_uIcc_of_lt zero_lt_one at hx\n    simpa\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 IntervalIntegrable log volume a b"}, {"line": "apply intervalIntegrable_of_even (log_neg_eq_log \u00b7 |>.symm)", "tactic_state": "case h\u2082f\na b : \u211d\n\u22a2 \u2200 (x : \u211d), 0 < x \u2192 IntervalIntegrable log volume 0 x"}, {"line": "intro x hx", "tactic_state": "case h\u2082f\na b x : \u211d\nhx : 0 < x\n\u22a2 IntervalIntegrable log volume 0 x"}, {"line": "apply IntervalIntegrable.trans (b := 1)", "tactic_state": "case h\u2082f.hab\na b x : \u211d\nhx : 0 < x\n\u22a2 IntervalIntegrable log volume 0 1\n---\ncase h\u2082f.hbc\na b x : \u211d\nhx : 0 < x\n\u22a2 IntervalIntegrable log volume 1 x"}, {"line": "\u00b7 -- Show integrability on [0\u20261] using non-negativity of the derivative\n    rw [\u2190 neg_neg log]\n    apply IntervalIntegrable.neg\n    apply intervalIntegrable_deriv_of_nonneg (g := fun x \u21a6 -(x * log x - x))\n    \u00b7 exact (continuous_mul_log.continuousOn.sub continuous_id.continuousOn).neg\n    \u00b7 intro s \u27e8hs, _\u27e9\n      norm_num at *\n      simpa using (hasDerivAt_id s).sub (hasDerivAt_mul_log hs.ne.symm)\n    \u00b7 intro s \u27e8hs\u2081, hs\u2082\u27e9\n      norm_num at *\n      exact (log_nonpos_iff hs\u2081.le).mpr hs\u2082.le", "tactic_state": "case h\u2082f.hbc\na b x : \u211d\nhx : 0 < x\n\u22a2 IntervalIntegrable log volume 1 x"}, {"line": "\u00b7 -- Show integrability on [1\u2026t] by continuity\n    apply ContinuousOn.intervalIntegrable\n    apply Real.continuousOn_log.mono\n    apply Set.not_mem_uIcc_of_lt zero_lt_one at hx\n    simpa", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_pow : \u222b x in a..b, x ^ n = (b ^ (n + 1) - a ^ (n + 1)) / (n + 1) := by\n  simpa only [\u2190 Int.natCast_succ,zpow_natCast] using integral_zpow (Or.inl n.cast_nonneg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nn : \u2115\n\u22a2 \u222b (x : \u211d) in a..b, x ^ n = (b ^ (n + 1) - a ^ (n + 1)) / (\u2191n + 1)"}, {"line": "simpa only [\u2190 Int.natCast_succ,zpow_natCast] using integral_zpow (Or.inl n.cast_nonneg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_pow_abs_sub_uIoc : \u222b x in \u0399 a b, |x - a| ^ n = |b - a| ^ (n + 1) / (n + 1) := by\n  rcases le_or_lt a b with hab | hab\n  \u00b7 calc\n      \u222b x in \u0399 a b, |x - a| ^ n = \u222b x in a..b, |x - a| ^ n := by\n        rw [uIoc_of_le hab]\n        rw [\u2190 integral_of_le hab]\n      _ = \u222b x in (0)..(b - a), x ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n]\n        simp only [sub_self]\n        refine integral_congr fun x hx => congr_arg\u2082 Pow.pow (abs_of_nonneg <| ?_) rfl\n        rw [uIcc_of_le (sub_nonneg.2 hab)] at hx\n        exact hx.1\n      _ = |b - a| ^ (n + 1) / (n + 1) := by simp [abs_of_nonneg (sub_nonneg.2 hab)]\n  \u00b7 calc\n      \u222b x in \u0399 a b, |x - a| ^ n = \u222b x in b..a, |x - a| ^ n := by\n        rw [uIoc_of_ge hab.le]\n        rw [\u2190 integral_of_le hab.le]\n      _ = \u222b x in b - a..0, (-x) ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n]\n        simp only [sub_self]\n        refine integral_congr fun x hx => congr_arg\u2082 Pow.pow (abs_of_nonpos <| ?_) rfl\n        rw [uIcc_of_le (sub_nonpos.2 hab.le)] at hx\n        exact hx.2\n      _ = |b - a| ^ (n + 1) / (n + 1) := by\n        simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nn : \u2115\n\u22a2 \u222b (x : \u211d) in uIoc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (\u2191n + 1)"}, {"line": "rcases le_or_lt a b with hab | hab", "tactic_state": "case inl\na b : \u211d\nn : \u2115\nhab : a \u2264 b\n\u22a2 \u222b (x : \u211d) in uIoc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (\u2191n + 1)\n---\ncase inr\na b : \u211d\nn : \u2115\nhab : b < a\n\u22a2 \u222b (x : \u211d) in uIoc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (\u2191n + 1)"}, {"line": "\u00b7 calc\n      \u222b x in \u0399 a b, |x - a| ^ n = \u222b x in a..b, |x - a| ^ n := by\n        rw [uIoc_of_le hab]\n        rw [\u2190 integral_of_le hab]\n      _ = \u222b x in (0)..(b - a), x ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n]\n        simp only [sub_self]\n        refine integral_congr fun x hx => congr_arg\u2082 Pow.pow (abs_of_nonneg <| ?_) rfl\n        rw [uIcc_of_le (sub_nonneg.2 hab)] at hx\n        exact hx.1\n      _ = |b - a| ^ (n + 1) / (n + 1) := by simp [abs_of_nonneg (sub_nonneg.2 hab)]", "tactic_state": "case inr\na b : \u211d\nn : \u2115\nhab : b < a\n\u22a2 \u222b (x : \u211d) in uIoc a b, |x - a| ^ n = |b - a| ^ (n + 1) / (\u2191n + 1)"}, {"line": "\u00b7 calc\n      \u222b x in \u0399 a b, |x - a| ^ n = \u222b x in b..a, |x - a| ^ n := by\n        rw [uIoc_of_ge hab.le]\n        rw [\u2190 integral_of_le hab.le]\n      _ = \u222b x in b - a..0, (-x) ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n]\n        simp only [sub_self]\n        refine integral_congr fun x hx => congr_arg\u2082 Pow.pow (abs_of_nonpos <| ?_) rfl\n        rw [uIcc_of_le (sub_nonpos.2 hab.le)] at hx\n        exact hx.2\n      _ = |b - a| ^ (n + 1) / (n + 1) := by\n        simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_const_on_unit_interval : \u222b _ in a..a + 1, b = b := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..a + 1, b = b"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_one_div (h : (0 : \u211d) \u2209 [[a, b]]) : \u222b x : \u211d in a..b, 1 / x = log (b / a) := by\n  simp only [one_div]\n  simp only [integral_inv h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : 0 \u2209 Set.uIcc a b\n\u22a2 \u222b (x : \u211d) in a..b, 1 / x = log (b / a)"}, {"line": "simp only [one_div]", "tactic_state": "a b : \u211d\nh : 0 \u2209 Set.uIcc a b\n\u22a2 \u222b (x : \u211d) in a..b, x\u207b\u00b9 = log (b / a)"}, {"line": "simp only [integral_inv h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_one_div_of_pos (ha : 0 < a) (hb : 0 < b) :\n    \u222b x : \u211d in a..b, 1 / x = log (b / a) := by simp only [one_div, integral_inv_of_pos ha hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nha : 0 < a\nhb : 0 < b\n\u22a2 \u222b (x : \u211d) in a..b, 1 / x = log (b / a)"}, {"line": "simp only [one_div, integral_inv_of_pos ha hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_one_div_of_neg (ha : a < 0) (hb : b < 0) :\n    \u222b x : \u211d in a..b, 1 / x = log (b / a) := by simp only [one_div, integral_inv_of_neg ha hb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nha : a < 0\nhb : b < 0\n\u22a2 \u222b (x : \u211d) in a..b, 1 / x = log (b / a)"}, {"line": "simp only [one_div, integral_inv_of_neg ha hb]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp : \u222b x in a..b, exp x = exp b - exp a := by\n  rw [integral_deriv_eq_sub']\n  \u00b7 simp\n  \u00b7 exact fun _ _ => differentiableAt_exp\n  \u00b7 exact continuousOn_exp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, exp x = exp b - exp a"}, {"line": "rw [integral_deriv_eq_sub']", "tactic_state": "case hderiv\na b : \u211d\n\u22a2 deriv exp = exp\n---\ncase hdiff\na b : \u211d\n\u22a2 \u2200 x \u2208 Set.uIcc a b, DifferentiableAt \u211d exp x\n---\ncase hcont\na b : \u211d\n\u22a2 ContinuousOn exp (Set.uIcc a b)"}, {"line": "\u00b7 simp", "tactic_state": "case hdiff\na b : \u211d\n\u22a2 \u2200 x \u2208 Set.uIcc a b, DifferentiableAt \u211d exp x\n---\ncase hcont\na b : \u211d\n\u22a2 ContinuousOn exp (Set.uIcc a b)"}, {"line": "\u00b7 exact fun _ _ => differentiableAt_exp", "tactic_state": "case hcont\na b : \u211d\n\u22a2 ContinuousOn exp (Set.uIcc a b)"}, {"line": "\u00b7 exact continuousOn_exp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_exp_mul_complex {c : \u2102} (hc : c \u2260 0) :\n    (\u222b x in a..b, Complex.exp (c * x)) = (Complex.exp (c * b) - Complex.exp (c * a)) / c := by\n  have D : \u2200 x : \u211d, HasDerivAt (fun y : \u211d => Complex.exp (c * y) / c) (Complex.exp (c * x)) x := by\n    intro x\n    conv => congr\n    rw [\u2190 mul_div_cancel_right\u2080 (Complex.exp (c * x)) hc]\n    apply ((Complex.hasDerivAt_exp _).comp x _).div_const c\n    simpa only [mul_one] using ((hasDerivAt_id (x : \u2102)).const_mul _).comp_ofReal\n  rw [integral_deriv_eq_sub' _ (funext fun x => (D x).deriv) fun x _ => (D x).differentiableAt]\n  \u00b7 ring\n  \u00b7 fun_prop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nc : \u2102\nhc : c \u2260 0\n\u22a2 \u222b (x : \u211d) in a..b, Complex.exp (c * \u2191x) = (Complex.exp (c * \u2191b) - Complex.exp (c * \u2191a)) / c"}, {"line": "have D : \u2200 x : \u211d, HasDerivAt (fun y : \u211d => Complex.exp (c * y) / c) (Complex.exp (c * x)) x := by\n    intro x\n    conv => congr\n    rw [\u2190 mul_div_cancel_right\u2080 (Complex.exp (c * x)) hc]\n    apply ((Complex.hasDerivAt_exp _).comp x _).div_const c\n    simpa only [mul_one] using ((hasDerivAt_id (x : \u2102)).const_mul _).comp_ofReal", "tactic_state": "a b : \u211d\nc : \u2102\nhc : c \u2260 0\nD : \u2200 (x : \u211d), HasDerivAt (fun y => Complex.exp (c * \u2191y) / c) (Complex.exp (c * \u2191x)) x\n\u22a2 \u222b (x : \u211d) in a..b, Complex.exp (c * \u2191x) = (Complex.exp (c * \u2191b) - Complex.exp (c * \u2191a)) / c"}, {"line": "rw [integral_deriv_eq_sub' _ (funext fun x => (D x).deriv) fun x _ => (D x).differentiableAt]", "tactic_state": "a b : \u211d\nc : \u2102\nhc : c \u2260 0\nD : \u2200 (x : \u211d), HasDerivAt (fun y => Complex.exp (c * \u2191y) / c) (Complex.exp (c * \u2191x)) x\n\u22a2 Complex.exp (c * \u2191b) / c - Complex.exp (c * \u2191a) / c = (Complex.exp (c * \u2191b) - Complex.exp (c * \u2191a)) / c\n---\na b : \u211d\nc : \u2102\nhc : c \u2260 0\nD : \u2200 (x : \u211d), HasDerivAt (fun y => Complex.exp (c * \u2191y) / c) (Complex.exp (c * \u2191x)) x\n\u22a2 ContinuousOn (fun x => Complex.exp (c * \u2191x)) (Set.uIcc a b)"}, {"line": "\u00b7 ring", "tactic_state": "a b : \u211d\nc : \u2102\nhc : c \u2260 0\nD : \u2200 (x : \u211d), HasDerivAt (fun y => Complex.exp (c * \u2191y) / c) (Complex.exp (c * \u2191x)) x\n\u22a2 ContinuousOn (fun x => Complex.exp (c * \u2191x)) (Set.uIcc a b)"}, {"line": "\u00b7 fun_prop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma integral_log_from_zero {b : \u211d} : \u222b s in (0)..b, log s = b * log b - b := by\n  rcases lt_trichotomy b 0 with h | h | h\n  \u00b7 -- If t is negative, use that log is an even function to reduce to the positive case.\n    conv => arg 1; arg 1; intro t; rw [\u2190 log_neg_eq_log]\n    rw [intervalIntegral.integral_comp_neg]\n    rw [intervalIntegral.integral_symm]\n    rw [neg_zero]\n    rw [integral_log_from_zero_of_pos (Left.neg_pos_iff.mpr h)]\n    rw [log_neg_eq_log]\n    ring\n  \u00b7 simp [h]\n  \u00b7 exact integral_log_from_zero_of_pos h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b"}, {"line": "rcases lt_trichotomy b 0 with h | h | h", "tactic_state": "case inl\nb : \u211d\nh : b < 0\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b\n---\ncase inr.inl\nb : \u211d\nh : b = 0\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b\n---\ncase inr.inr\nb : \u211d\nh : 0 < b\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b"}, {"line": "\u00b7 -- If t is negative, use that log is an even function to reduce to the positive case.\n    conv => arg 1; arg 1; intro t; rw [\u2190 log_neg_eq_log]\n    rw [intervalIntegral.integral_comp_neg]\n    rw [intervalIntegral.integral_symm]\n    rw [neg_zero]\n    rw [integral_log_from_zero_of_pos (Left.neg_pos_iff.mpr h)]\n    rw [log_neg_eq_log]\n    ring", "tactic_state": "case inr.inl\nb : \u211d\nh : b = 0\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b\n---\ncase inr.inr\nb : \u211d\nh : 0 < b\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b"}, {"line": "\u00b7 simp [h]", "tactic_state": "case inr.inr\nb : \u211d\nh : 0 < b\n\u22a2 \u222b (s : \u211d) in 0 ..b, log s = b * log b - b"}, {"line": "\u00b7 exact integral_log_from_zero_of_pos h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_cos : \u222b x in a..b, cos x = sin b - sin a := by\n  rw [integral_deriv_eq_sub']\n  \u00b7 norm_num\n  \u00b7 simp only [differentiableAt_sin, implies_true]\n  \u00b7 exact continuousOn_cos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, cos x = sin b - sin a"}, {"line": "rw [integral_deriv_eq_sub']", "tactic_state": "case hderiv\na b : \u211d\n\u22a2 deriv sin = cos\n---\ncase hdiff\na b : \u211d\n\u22a2 \u2200 x \u2208 Set.uIcc a b, DifferentiableAt \u211d sin x\n---\ncase hcont\na b : \u211d\n\u22a2 ContinuousOn cos (Set.uIcc a b)"}, {"line": "\u00b7 norm_num", "tactic_state": "case hdiff\na b : \u211d\n\u22a2 \u2200 x \u2208 Set.uIcc a b, DifferentiableAt \u211d sin x\n---\ncase hcont\na b : \u211d\n\u22a2 ContinuousOn cos (Set.uIcc a b)"}, {"line": "\u00b7 simp only [differentiableAt_sin, implies_true]", "tactic_state": "case hcont\na b : \u211d\n\u22a2 ContinuousOn cos (Set.uIcc a b)"}, {"line": "\u00b7 exact continuousOn_cos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_cos_sq_sub_sin_sq :\n    \u222b x in a..b, cos x ^ 2 - sin x ^ 2 = sin b * cos b - sin a * cos a := by\n  simpa only [sq,sub_eq_add_neg,neg_mul_eq_mul_neg] using\n    integral_deriv_mul_eq_sub (fun x _ => hasDerivAt_sin x) (fun x _ => hasDerivAt_cos x)\n      continuousOn_cos.intervalIntegrable continuousOn_sin.neg.intervalIntegrable\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, cos x ^ 2 - sin x ^ 2 = sin b * cos b - sin a * cos a"}, {"line": "simpa only [sq,sub_eq_add_neg,neg_mul_eq_mul_neg] using\n    integral_deriv_mul_eq_sub (fun x _ => hasDerivAt_sin x) (fun x _ => hasDerivAt_cos x)\n      continuousOn_cos.intervalIntegrable continuousOn_sin.neg.intervalIntegrable", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_one_div_one_add_sq :\n    (\u222b x : \u211d in a..b, \u21911 / (\u21911 + x ^ 2)) = arctan b - arctan a := by\n  refine integral_deriv_eq_sub' _ Real.deriv_arctan (fun _ _ => differentiableAt_arctan _)\n    (continuous_const.div ?_ fun x => ?_).continuousOn\n  \u00b7 fun_prop\n  \u00b7 nlinarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, 1 / (1 + x ^ 2) = arctan b - arctan a"}, {"line": "refine integral_deriv_eq_sub' _ Real.deriv_arctan (fun _ _ => differentiableAt_arctan _)\n    (continuous_const.div ?_ fun x => ?_).continuousOn", "tactic_state": "case refine_1\na b : \u211d\n\u22a2 Continuous fun x => 1 + x ^ 2\n---\ncase refine_2\na b x : \u211d\n\u22a2 1 + x ^ 2 \u2260 0"}, {"line": "\u00b7 fun_prop", "tactic_state": "case refine_2\na b x : \u211d\n\u22a2 1 + x ^ 2 \u2260 0"}, {"line": "\u00b7 nlinarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_inv_one_add_sq : (\u222b x : \u211d in a..b, (\u21911 + x ^ 2)\u207b\u00b9) = arctan b - arctan a := by\n  simp only [\u2190 one_div]\n  simp only [integral_one_div_one_add_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, (1 + x ^ 2)\u207b\u00b9 = arctan b - arctan a"}, {"line": "simp only [\u2190 one_div]", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, 1 / (1 + x ^ 2) = arctan b - arctan a"}, {"line": "simp only [integral_one_div_one_add_sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_sin_sq : \u222b x in a..b, sin x ^ 2 = (sin a * cos a - sin b * cos b + b - a) / 2 := by\n  field_simp [integral_sin_pow, add_sub_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral", "Complex", "Nat"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, sorry ^ 2 = (sorry * sorry - sorry * sorry + b - a) / 2"}, {"line": "field_simp [integral_sin_pow, add_sub_assoc]", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, sorry () ^ 2 = (b - a) / 2"}]}
{"declaration": "theorem integral_cos_sq : \u222b x in a..b, cos x ^ 2 = (cos b * sin b - cos a * sin a + b - a) / 2 := by\n  field_simp [integral_cos_pow, add_sub_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral", "Complex", "Nat"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, sorry ^ 2 = (sorry * sorry - sorry * sorry + b - a) / 2"}, {"line": "field_simp [integral_cos_pow, add_sub_assoc]", "tactic_state": "a b : \u211d\n\u22a2 \u222b (x : \u211d) in a..b, sorry () ^ 2 = (b - a) / 2"}]}
{"declaration": "theorem integral_sin_pow_even_mul_cos_pow_even (m n : \u2115) :\n    (\u222b x in a..b, sin x ^ (2 * m) * cos x ^ (2 * n)) =\n      \u222b x in a..b, ((1 - cos (2 * x)) / 2) ^ m * ((1 + cos (2 * x)) / 2) ^ n := by\n  field_simp [pow_mul, sin_sq, cos_sq, \u2190 sub_sub, (by ring : (2 : \u211d) - 1 = 1)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Integrals.lean", "context": {"open": ["Real Set Finset", "scoped Real Interval", "MeasureTheory", "intervalIntegral", "Complex", "Nat"], "variables": ["{a b : \u211d} (n : \u2115)", "{f : \u211d \u2192 \u211d} {\u03bc : Measure \u211d} [IsLocallyFiniteMeasure \u03bc] (c d : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nm n : \u2115\n\u22a2 \u222b (x : \u211d) in a..b, sorry ^ (2 * m) * sorry ^ (2 * n) = sorry"}, {"line": "field_simp [pow_mul, sin_sq, cos_sq, \u2190 sub_sub, (by ring : (2 : \u211d) - 1 = 1)]", "tactic_state": "a b : \u211d\nm n : \u2115\n\u22a2 \u222b (x : \u211d) in a..b, sorry () ^ (2 * m) * sorry () ^ (2 * n) = sorry ()"}]}
{"declaration": "theorem sqrt_one_add_norm_sq_le (x : E) : \u221a((1 : \u211d) + \u2016x\u2016 ^ 2) \u2264 1 + \u2016x\u2016 := by\n  rw [sqrt_le_left (by positivity)]\n  simp [add_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean", "context": {"open": ["scoped NNReal Filter Topology ENNReal", "Asymptotics Filter Set Real MeasureTheory Module"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 \u221a(1 + \u2016x\u2016 ^ 2) \u2264 1 + \u2016x\u2016"}, {"line": "rw [sqrt_le_left (by positivity)]", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 1 + \u2016x\u2016 ^ 2 \u2264 (1 + \u2016x\u2016) ^ 2"}, {"line": "simp [add_sq]", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nx : E\n\u22a2 0 \u2264 \u2016x\u2016"}]}
{"declaration": "theorem le_rpow_one_add_norm_iff_norm_le {r t : \u211d} (hr : 0 < r) (ht : 0 < t) (x : E) :\n    t \u2264 (1 + \u2016x\u2016) ^ (-r) \u2194 \u2016x\u2016 \u2264 t ^ (-r\u207b\u00b9) - 1 := by\n  rw [le_sub_iff_add_le']\n  rw [neg_inv]\n  exact (Real.le_rpow_inv_iff_of_neg (by positivity) ht (neg_lt_zero.mpr hr)).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean", "context": {"open": ["scoped NNReal Filter Topology ENNReal", "Asymptotics Filter Set Real MeasureTheory Module"], "variables": ["{E : Type*} [NormedAddCommGroup E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 0 < t\nx : E\n\u22a2 t \u2264 (1 + \u2016x\u2016) ^ (-r) \u2194 \u2016x\u2016 \u2264 t ^ (-r\u207b\u00b9) - 1"}, {"line": "rw [le_sub_iff_add_le']", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 0 < t\nx : E\n\u22a2 t \u2264 (1 + \u2016x\u2016) ^ (-r) \u2194 1 + \u2016x\u2016 \u2264 t ^ (-r\u207b\u00b9)"}, {"line": "rw [neg_inv]", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 0 < t\nx : E\n\u22a2 t \u2264 (1 + \u2016x\u2016) ^ (-r) \u2194 1 + \u2016x\u2016 \u2264 t ^ (-r)\u207b\u00b9"}, {"line": "exact (Real.le_rpow_inv_iff_of_neg (by positivity) ht (neg_lt_zero.mpr hr)).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem closedBall_rpow_sub_one_eq_empty_aux {r t : \u211d} (hr : 0 < r) (ht : 1 < t) :\n    Metric.closedBall (0 : E) (t ^ (-r\u207b\u00b9) - 1) = \u2205 := by\n  rw [Metric.closedBall_eq_empty]\n  rw [sub_neg]\n  exact Real.rpow_lt_one_of_one_lt_of_neg ht (by simp only [hr, Right.neg_neg_iff, inv_pos])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/JapaneseBracket.lean", "context": {"open": ["scoped NNReal Filter Topology ENNReal", "Asymptotics Filter Set Real MeasureTheory Module"], "variables": ["{E : Type*} [NormedAddCommGroup E]", "(E)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 1 < t\n\u22a2 Metric.closedBall 0 (t ^ (-r\u207b\u00b9) - 1) = \u2205"}, {"line": "rw [Metric.closedBall_eq_empty]", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 1 < t\n\u22a2 t ^ (-r\u207b\u00b9) - 1 < 0"}, {"line": "rw [sub_neg]", "tactic_state": "E : Type u_1\ninst\u271d : NormedAddCommGroup E\nr t : \u211d\nhr : 0 < r\nht : 1 < t\n\u22a2 t ^ (-r\u207b\u00b9) < 1"}, {"line": "exact Real.rpow_lt_one_of_one_lt_of_neg ht (by simp only [hr, Right.neg_neg_iff, inv_pos])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_mulExpNegMulSq_neg (\u03b5 x : \u211d) : - mulExpNegMulSq \u03b5 (-x) = mulExpNegMulSq \u03b5 x := by\n  simp [mulExpNegMulSq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/MulExpNegMulSq.lean", "context": {"open": ["NNReal ENNReal BoundedContinuousFunction Filter", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nmulExpNegMulSq : x\u271d\n\u03b5 x : \u211d\n\u22a2 -sorry = sorry"}, {"line": "simp [mulExpNegMulSq]", "tactic_state": "x\u271d : Sort u_1\nmulExpNegMulSq : x\u271d\n\u03b5 x : \u211d\n\u22a2 -sorry () = sorry ()"}]}
{"declaration": "theorem tendsto_integral_mulExpNegMulSq_comp (g : E \u2192\u1d47 \u211d) :\n    Tendsto (fun \u03b5 => \u222b x, mulExpNegMulSq \u03b5 (g x) \u2202P) (\ud835\udcdd[>] 0) (\ud835\udcdd (\u222b x, g x \u2202P)) := by\n  apply tendsto_of_seq_tendsto\n  intro u hu\n  obtain \u27e8N, hupos\u27e9 := eventually_atTop.mp (tendsto_nhdsWithin_iff.mp hu).2\n  apply tendsto_integral_filter_of_norm_le_const ?h_meas ?h_bound ?h_lim\n  \u00b7 exact Eventually.of_forall (fun n => g.continuous.mulExpNegMulSq.aestronglyMeasurable)\n  \u00b7 use norm g\n    rw [eventually_atTop]\n    use N\n    intro n hn\n    exact Eventually.of_forall\n      (fun _ => abs_mulExpNegMulSq_comp_le_norm g (le_of_lt (Set.mem_Ioi.mp (hupos n hn))))\n  \u00b7 exact Eventually.of_forall (fun _ => (tendsto_nhdsWithin_of_tendsto_nhds\n        tendsto_mulExpNegMulSq).comp hu)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/MulExpNegMulSqIntegral.lean", "context": {"open": ["MeasureTheory Real NNReal ENNReal BoundedContinuousFunction Filter", "scoped Topology"], "variables": ["{E : Type*} [TopologicalSpace E] [MeasurableSpace E] [BorelSpace E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\n\u22a2 Tendsto (fun \u03b5 => \u222b (x : E), \u03b5.mulExpNegMulSq (g x) \u2202P) (nhdsWithin 0 (Set.Ioi 0)) (nhds (\u222b (x : E), g x \u2202P))"}, {"line": "apply tendsto_of_seq_tendsto", "tactic_state": "case a\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\n\u22a2 \u2200 (x : \u2115 \u2192 \u211d),\n    Tendsto x atTop (nhdsWithin 0 (Set.Ioi 0)) \u2192\n      Tendsto ((fun \u03b5 => \u222b (x : E), \u03b5.mulExpNegMulSq (g x) \u2202P) \u2218 x) atTop (nhds (\u222b (x : E), g x \u2202P))"}, {"line": "intro u hu", "tactic_state": "case a\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\n\u22a2 Tendsto ((fun \u03b5 => \u222b (x : E), \u03b5.mulExpNegMulSq (g x) \u2202P) \u2218 u) atTop (nhds (\u222b (x : E), g x \u2202P))"}, {"line": "obtain \u27e8N, hupos\u27e9 := eventually_atTop.mp (tendsto_nhdsWithin_iff.mp hu).2", "tactic_state": "case a.intro\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 Tendsto ((fun \u03b5 => \u222b (x : E), \u03b5.mulExpNegMulSq (g x) \u2202P) \u2218 u) atTop (nhds (\u222b (x : E), g x \u2202P))"}, {"line": "apply tendsto_integral_filter_of_norm_le_const ?h_meas ?h_bound ?h_lim", "tactic_state": "E : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 IsFiniteMeasure P\n---\ncase h_meas\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, AEStronglyMeasurable (fun \u03c9 => (u n).mulExpNegMulSq (g \u03c9)) P\n---\ncase h_bound\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2203 C, \u2200\u1da0 (n : \u2115) in atTop, \u2200\u1d50 (\u03c9 : E) \u2202P, \u2016(u n).mulExpNegMulSq (g \u03c9)\u2016 \u2264 C\n---\ncase h_lim\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1d50 (\u03c9 : E) \u2202P, Tendsto (fun n => (u n).mulExpNegMulSq (g \u03c9)) atTop (nhds (g \u03c9))"}, {"line": "\u00b7 exact Eventually.of_forall (fun n => g.continuous.mulExpNegMulSq.aestronglyMeasurable)", "tactic_state": "case h_meas\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, AEStronglyMeasurable (fun \u03c9 => (u n).mulExpNegMulSq (g \u03c9)) P\n---\ncase h_bound\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2203 C, \u2200\u1da0 (n : \u2115) in atTop, \u2200\u1d50 (\u03c9 : E) \u2202P, \u2016(u n).mulExpNegMulSq (g \u03c9)\u2016 \u2264 C\n---\ncase h_lim\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1d50 (\u03c9 : E) \u2202P, Tendsto (fun n => (u n).mulExpNegMulSq (g \u03c9)) atTop (nhds (g \u03c9))"}, {"line": "\u00b7 use norm g\n    rw [eventually_atTop]\n    use N\n    intro n hn\n    exact Eventually.of_forall\n      (fun _ => abs_mulExpNegMulSq_comp_le_norm g (le_of_lt (Set.mem_Ioi.mp (hupos n hn))))", "tactic_state": "case h_bound\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2203 C, \u2200\u1da0 (n : \u2115) in atTop, \u2200\u1d50 (\u03c9 : E) \u2202P, \u2016(u n).mulExpNegMulSq (g \u03c9)\u2016 \u2264 C\n---\ncase h_lim\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1d50 (\u03c9 : E) \u2202P, Tendsto (fun n => (u n).mulExpNegMulSq (g \u03c9)) atTop (nhds (g \u03c9))"}, {"line": "\u00b7 exact Eventually.of_forall (fun _ => (tendsto_nhdsWithin_of_tendsto_nhds\n        tendsto_mulExpNegMulSq).comp hu)", "tactic_state": "case h_lim\nE : Type u_1\ninst\u271d\u00b3 : TopologicalSpace E\ninst\u271d\u00b2 : MeasurableSpace E\ninst\u271d\u00b9 : BorelSpace E\ninst\u271d : MeasurableSpace E\nP : Measure E\ng : BoundedContinuousFunction E \u211d\nu : \u2115 \u2192 \u211d\nhu : Tendsto u atTop (nhdsWithin 0 (Set.Ioi 0))\nN : \u2115\nhupos : \u2200 b \u2265 N, u b \u2208 Set.Ioi 0\n\u22a2 \u2200\u1d50 (\u03c9 : E) \u2202P, Tendsto (fun n => (u n).mulExpNegMulSq (g \u03c9)) atTop (nhds (g \u03c9))"}]}
{"declaration": "theorem not_intervalIntegrable_of_tendsto_norm_atTop_of_deriv_isBigO_filter {f : \u211d \u2192 E} {g : \u211d \u2192 F}\n    {a b : \u211d} (l : Filter \u211d) [NeBot l] [TendstoIxxClass Icc l l] (hl : [[a, b]] \u2208 l)\n    (hd : \u2200\u1da0 x in l, DifferentiableAt \u211d f x) (hf : Tendsto (fun x => \u2016f x\u2016) l atTop)\n    (hfg : deriv f =O[l] g) : \u00acIntervalIntegrable g volume a b := by\n  rw [intervalIntegrable_iff']\n  exact not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter _ hl hd hf hfg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean", "context": {"open": ["scoped MeasureTheory Topology Interval NNReal ENNReal", "MeasureTheory TopologicalSpace Set Filter Asymptotics intervalIntegral"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : NormedAddCommGroup F\nf : \u211d \u2192 E\ng : \u211d \u2192 F\na b : \u211d\nl : Filter \u211d\ninst\u271d\u00b9 : l.NeBot\ninst\u271d : TendstoIxxClass Icc l l\nhl : uIcc a b \u2208 l\nhd : \u2200\u1da0 (x : \u211d) in l, DifferentiableAt \u211d f x\nhf : Tendsto (fun x => \u2016f x\u2016) l atTop\nhfg : deriv f =O[l] g\n\u22a2 \u00acIntervalIntegrable g volume a b"}, {"line": "rw [intervalIntegrable_iff']", "tactic_state": "E : Type u_1\nF : Type u_2\ninst\u271d\u2074 : NormedAddCommGroup E\ninst\u271d\u00b3 : NormedSpace \u211d E\ninst\u271d\u00b2 : NormedAddCommGroup F\nf : \u211d \u2192 E\ng : \u211d \u2192 F\na b : \u211d\nl : Filter \u211d\ninst\u271d\u00b9 : l.NeBot\ninst\u271d : TendstoIxxClass Icc l l\nhl : uIcc a b \u2208 l\nhd : \u2200\u1da0 (x : \u211d) in l, DifferentiableAt \u211d f x\nhf : Tendsto (fun x => \u2016f x\u2016) l atTop\nhfg : deriv f =O[l] g\n\u22a2 \u00acIntegrableOn g (uIcc a b) volume"}, {"line": "exact not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter _ hl hd hf hfg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intervalIntegrable_inv_iff {a b : \u211d} :\n    IntervalIntegrable (fun x => x\u207b\u00b9) volume a b \u2194 a = b \u2228 (0 : \u211d) \u2209 [[a, b]] := by\n  simp only [\u2190 intervalIntegrable_sub_inv_iff]\n  simp only [sub_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean", "context": {"open": ["scoped MeasureTheory Topology Interval NNReal ENNReal", "MeasureTheory TopologicalSpace Set Filter Asymptotics intervalIntegral"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\n\u22a2 IntervalIntegrable (fun x => x\u207b\u00b9) volume a b \u2194 a = b \u2228 0 \u2209 uIcc a b"}, {"line": "simp only [\u2190 intervalIntegrable_sub_inv_iff]", "tactic_state": "a b : \u211d\n\u22a2 IntervalIntegrable (fun x => x\u207b\u00b9) volume a b \u2194 IntervalIntegrable (fun x => (x - 0)\u207b\u00b9) volume a b"}, {"line": "simp only [sub_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_IntegrableOn_Ici_inv {a : \u211d} :\n    \u00ac IntegrableOn (fun x => x\u207b\u00b9) (Ici a) := by\n  have A : \u2200\u1da0 x in atTop, HasDerivAt (fun x => Real.log x) x\u207b\u00b9 x := by\n    filter_upwards [Ioi_mem_atTop 0] with x hx using Real.hasDerivAt_log (ne_of_gt hx)\n  have B : Tendsto (fun x => \u2016Real.log x\u2016) atTop atTop :=\n    tendsto_norm_atTop_atTop.comp Real.tendsto_log_atTop\n  exact not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter atTop (Ici_mem_atTop a)\n    (A.mono (fun x hx \u21a6 hx.differentiableAt)) B\n    (Filter.EventuallyEq.isBigO (A.mono (fun x hx \u21a6 hx.deriv)))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean", "context": {"open": ["scoped MeasureTheory Topology Interval NNReal ENNReal", "MeasureTheory TopologicalSpace Set Filter Asymptotics intervalIntegral"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 \u00acIntegrableOn (fun x => x\u207b\u00b9) (Ici a) volume"}, {"line": "have A : \u2200\u1da0 x in atTop, HasDerivAt (fun x => Real.log x) x\u207b\u00b9 x := by\n    filter_upwards [Ioi_mem_atTop 0] with x hx using Real.hasDerivAt_log (ne_of_gt hx)", "tactic_state": "a : \u211d\nA : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt (fun x => Real.log x) x\u207b\u00b9 x\n\u22a2 \u00acIntegrableOn (fun x => x\u207b\u00b9) (Ici a) volume"}, {"line": "have B : Tendsto (fun x => \u2016Real.log x\u2016) atTop atTop :=\n    tendsto_norm_atTop_atTop.comp Real.tendsto_log_atTop", "tactic_state": "a : \u211d\nA : \u2200\u1da0 (x : \u211d) in atTop, HasDerivAt (fun x => Real.log x) x\u207b\u00b9 x\nB : Tendsto (fun x => \u2016Real.log x\u2016) atTop atTop\n\u22a2 \u00acIntegrableOn (fun x => x\u207b\u00b9) (Ici a) volume"}, {"line": "exact not_integrableOn_of_tendsto_norm_atTop_of_deriv_isBigO_filter atTop (Ici_mem_atTop a)\n    (A.mono (fun x hx \u21a6 hx.differentiableAt)) B\n    (Filter.EventuallyEq.isBigO (A.mono (fun x hx \u21a6 hx.deriv)))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem not_IntegrableOn_Ioi_inv {a : \u211d} :\n    \u00ac IntegrableOn (\u00b7\u207b\u00b9) (Ioi a) := by\n  simpa only [IntegrableOn,restrict_Ioi_eq_restrict_Ici] using not_IntegrableOn_Ici_inv", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/NonIntegrable.lean", "context": {"open": ["scoped MeasureTheory Topology Interval NNReal ENNReal", "MeasureTheory TopologicalSpace Set Filter Asymptotics intervalIntegral"], "variables": ["{E F : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] [NormedAddCommGroup F]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\n\u22a2 \u00acIntegrableOn (fun x => x\u207b\u00b9) (Ioi a) volume"}, {"line": "simpa only [IntegrableOn,restrict_Ioi_eq_restrict_Ici] using not_IntegrableOn_Ici_inv", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ordinaryHypergeometric_zero : \u2082F\u2081 a b c (0 : \ud835\udd38) = 1 := by\n  simp [ordinaryHypergeometric_eq_tsum, \u2190 ordinaryHypergeometricSeries_apply_eq,\n    ordinaryHypergeometricSeries_apply_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/OrdinaryHypergeometric.lean", "context": {"open": ["Nat FormalMultilinearSeries"], "variables": ["{\ud835\udd42 : Type*} (\ud835\udd38 : Type*) [Field \ud835\udd42] [Ring \ud835\udd38] [Algebra \ud835\udd42 \ud835\udd38] [TopologicalSpace \ud835\udd38]", "{\ud835\udd38} (a b c : \ud835\udd42)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\ud835\udd42 : Type u_1\n\ud835\udd38 : Type u_2\ninst\u271d\u00b3 : Field \ud835\udd42\ninst\u271d\u00b2 : Ring \ud835\udd38\ninst\u271d\u00b9 : Algebra \ud835\udd42 \ud835\udd38\ninst\u271d : TopologicalSpace \ud835\udd38\na b c : \ud835\udd42\n\u22a2 \u2082F\u2081 a b c 0 = 1"}, {"line": "simp [ordinaryHypergeometric_eq_tsum, \u2190 ordinaryHypergeometricSeries_apply_eq,\n    ordinaryHypergeometricSeries_apply_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem polarCoord_source_ae_eq_univ : polarCoord.source =\u1d50[volume] univ := by\n  have A : polarCoord.source\u1d9c \u2286 LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) := by\n    intro x hx\n    simp only [polarCoord_source] at hx\n    simp only [compl_union] at hx\n    simp only [mem_inter_iff] at hx\n    simp only [mem_compl_iff] at hx\n    simp only [mem_setOf_eq] at hx\n    simp only [not_lt] at hx\n    simp only [Classical.not_not] at hx\n    exact hx.2\n  have B : volume (LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) : Set (\u211d \u00d7 \u211d)) = 0 := by\n    apply Measure.addHaar_submodule\n    rw [Ne]\n    rw [LinearMap.ker_eq_top]\n    intro h\n    have : (LinearMap.snd \u211d \u211d \u211d) (0, 1) = (0 : \u211d \u00d7 \u211d \u2192\u2097[\u211d] \u211d) (0, 1) := by rw [h]\n    simp at this\n  simp only [ae_eq_univ]\n  exact le_antisymm ((measure_mono A).trans (le_of_eq B)) bot_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/PolarCoord.lean", "context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 polarCoord.source =\u1da0[ae volume] univ"}, {"line": "have A : polarCoord.source\u1d9c \u2286 LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) := sorry", "tactic_state": "A : polarCoord.source\u1d9c \u2286 \u2191(LinearMap.ker (LinearMap.snd \u211d \u211d \u211d))\n\u22a2 polarCoord.source =\u1da0[ae volume] univ"}, {"line": "have B : volume (LinearMap.ker (LinearMap.snd \u211d \u211d \u211d) : Set (\u211d \u00d7 \u211d)) = 0 := by\n    apply Measure.addHaar_submodule\n    rw [Ne]\n    rw [LinearMap.ker_eq_top]\n    intro h\n    have : (LinearMap.snd \u211d \u211d \u211d) (0, 1) = (0 : \u211d \u00d7 \u211d \u2192\u2097[\u211d] \u211d) (0, 1) := by rw [h]\n    simp at this", "tactic_state": "A : polarCoord.source\u1d9c \u2286 \u2191(LinearMap.ker (LinearMap.snd \u211d \u211d \u211d))\nB : volume \u2191(LinearMap.ker (LinearMap.snd \u211d \u211d \u211d)) = 0\n\u22a2 polarCoord.source =\u1da0[ae volume] univ"}, {"line": "simp only [ae_eq_univ]", "tactic_state": "A : polarCoord.source\u1d9c \u2286 \u2191(LinearMap.ker (LinearMap.snd \u211d \u211d \u211d))\nB : volume \u2191(LinearMap.ker (LinearMap.snd \u211d \u211d \u211d)) = 0\n\u22a2 volume polarCoord.source\u1d9c = 0"}, {"line": "exact le_antisymm ((measure_mono A).trans (le_of_eq B)) bot_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lintegral_comp_polarCoord_symm (f : \u211d \u00d7 \u211d \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal p.1 \u2022 f (polarCoord.symm p) =\n      \u222b\u207b (p : \u211d \u00d7 \u211d), f p := by\n  symm\n  calc\n    _ = \u222b\u207b p in polarCoord.symm '' polarCoord.target, f p := by\n      rw [\u2190 setLIntegral_univ]\n      rw [setLIntegral_congr polarCoord_source_ae_eq_univ.symm]\n      rw [polarCoord.symm_image_target_eq_source]\n    _ = \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal |p.1| \u2022 f (polarCoord.symm p) := by\n      rw [lintegral_image_eq_lintegral_abs_det_fderiv_mul volume _         (fun p _ \u21a6 (hasFDerivAt_polarCoord_symm p).hasFDerivWithinAt)]\n      \u00b7 simp_rw [det_fderivPolarCoordSymm]; rfl\n      exacts [polarCoord.symm.injOn, measurableSet_Ioi.prod measurableSet_Ioo]\n    _ = \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal p.1 \u2022 f (polarCoord.symm p) := by\n      refine setLIntegral_congr_fun polarCoord.open_target.measurableSet ?_\n      filter_upwards with _ hx using by rw [abs_of_pos hx.1]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/PolarCoord.lean", "context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u00d7 \u211d \u2192 ENNReal\n\u22a2 \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal p.1 \u2022 f (\u2191polarCoord.symm p) = \u222b\u207b (p : \u211d \u00d7 \u211d), f p"}, {"line": "symm", "tactic_state": "f : \u211d \u00d7 \u211d \u2192 ENNReal\n\u22a2 \u222b\u207b (p : \u211d \u00d7 \u211d), f p = \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal p.1 \u2022 f (\u2191polarCoord.symm p)"}, {"line": "calc\n    _ = \u222b\u207b p in polarCoord.symm '' polarCoord.target, f p := by\n      rw [\u2190 setLIntegral_univ]\n      rw [setLIntegral_congr polarCoord_source_ae_eq_univ.symm]\n      rw [polarCoord.symm_image_target_eq_source]\n    _ = \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal |p.1| \u2022 f (polarCoord.symm p) := by\n      rw [lintegral_image_eq_lintegral_abs_det_fderiv_mul volume _         (fun p _ \u21a6 (hasFDerivAt_polarCoord_symm p).hasFDerivWithinAt)]\n      \u00b7 simp_rw [det_fderivPolarCoordSymm]; rfl\n      exacts [polarCoord.symm.injOn, measurableSet_Ioi.prod measurableSet_Ioo]\n    _ = \u222b\u207b (p : \u211d \u00d7 \u211d) in polarCoord.target, ENNReal.ofReal p.1 \u2022 f (polarCoord.symm p) := by\n      refine setLIntegral_congr_fun polarCoord.open_target.measurableSet ?_\n      filter_upwards with _ hx using by rw [abs_of_pos hx.1]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pi_polarCoord_symm_target_ae_eq_univ :\n    (Pi.map (fun _ : \u03b9 \u21a6 polarCoord.symm) '' Set.univ.pi fun _ \u21a6 polarCoord.target)\n        =\u1d50[volume] Set.univ := by\n  rw [Set.piMap_image_univ_pi]\n  rw [polarCoord.symm_image_target_eq_source]\n  rw [volume_pi]\n  rw [\u2190 Set.pi_univ]\n  exact ae_eq_set_pi fun _ _ \u21a6 polarCoord_source_ae_eq_univ\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/PolarCoord.lean", "context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology", "scoped Real ENNReal", "ENNReal MeasureTheory MeasureTheory.Measure", "ContinuousLinearMap in"], "variables": ["{\u03b9 : Type*}", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 ((Pi.map fun x => \u2191polarCoord.symm) '' univ.pi fun x => polarCoord.target) =\u1da0[ae volume] univ"}, {"line": "rw [Set.piMap_image_univ_pi]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 (univ.pi fun i => \u2191polarCoord.symm '' polarCoord.target) =\u1da0[ae volume] univ"}, {"line": "rw [polarCoord.symm_image_target_eq_source]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 (univ.pi fun i => polarCoord.source) =\u1da0[ae volume] univ"}, {"line": "rw [volume_pi]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 (univ.pi fun i => polarCoord.source) =\u1da0[ae (Measure.pi fun x => volume)] univ"}, {"line": "rw [\u2190 Set.pi_univ]", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 (univ.pi fun i => polarCoord.source) =\u1da0[ae (Measure.pi fun x => volume)] pi ?m.2180 fun i => univ\n---\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\n\u22a2 Set \u03b9"}, {"line": "exact ae_eq_set_pi fun _ _ \u21a6 polarCoord_source_ae_eq_univ", "tactic_state": "No Goals!"}]}
{"declaration": "protected theorem Complex.lintegral_comp_pi_polarCoord_symm (f : (\u03b9 \u2192 \u2102) \u2192 \u211d\u22650\u221e) :\n    \u222b\u207b p in (Set.univ.pi fun _ : \u03b9 \u21a6 Complex.polarCoord.target),\n      (\u220f i, .ofReal (p i).1) * f (fun i \u21a6 Complex.polarCoord.symm (p i)) = \u222b\u207b p, f p := by\n  let e := MeasurableEquiv.piCongrRight (fun _ : \u03b9 \u21a6 measurableEquivRealProd.symm)\n  have := volume_preserving_pi (fun _ : \u03b9 \u21a6 Complex.volume_preserving_equiv_real_prod.symm)\n  rw [\u2190 MeasurePreserving.lintegral_comp_emb this e.measurableEmbedding]\n  exact lintegral_comp_pi_polarCoord_symm (f \u2218 e)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/PolarCoord.lean", "context": {"open": ["Real Set MeasureTheory", "scoped ENNReal Real Topology", "scoped Real ENNReal", "ENNReal MeasureTheory MeasureTheory.Measure", "ContinuousLinearMap in"], "variables": ["{\u03b9 : Type*}", "[Fintype \u03b9]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nf : (\u03b9 \u2192 \u2102) \u2192 ENNReal\n\u22a2 (\u222b\u207b (p : \u03b9 \u2192 \u211d \u00d7 \u211d) in univ.pi fun x => Complex.polarCoord.target,\n      (\u220f i, ENNReal.ofReal (p i).1) * f fun i => \u2191Complex.polarCoord.symm (p i)) =\n    \u222b\u207b (p : \u03b9 \u2192 \u2102), f p"}, {"line": "let e := MeasurableEquiv.piCongrRight (fun _ : \u03b9 \u21a6 measurableEquivRealProd.symm)", "tactic_state": "\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nf : (\u03b9 \u2192 \u2102) \u2192 ENNReal\ne : (\u03b9 \u2192 \u211d \u00d7 \u211d) \u2243\u1d50 (\u03b9 \u2192 \u2102) := MeasurableEquiv.piCongrRight fun x => measurableEquivRealProd.symm\n\u22a2 (\u222b\u207b (p : \u03b9 \u2192 \u211d \u00d7 \u211d) in univ.pi fun x => Complex.polarCoord.target,\n      (\u220f i, ENNReal.ofReal (p i).1) * f fun i => \u2191Complex.polarCoord.symm (p i)) =\n    \u222b\u207b (p : \u03b9 \u2192 \u2102), f p"}, {"line": "have := volume_preserving_pi (fun _ : \u03b9 \u21a6 Complex.volume_preserving_equiv_real_prod.symm)", "tactic_state": "case refine_2\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nf : (\u03b9 \u2192 \u2102) \u2192 ENNReal\ne : (\u03b9 \u2192 \u211d \u00d7 \u211d) \u2243\u1d50 (\u03b9 \u2192 \u2102) := MeasurableEquiv.piCongrRight fun x => measurableEquivRealProd.symm\nthis : MeasurePreserving (fun a i => measurableEquivRealProd.symm (a i)) volume volume\n\u22a2 (\u222b\u207b (p : \u03b9 \u2192 \u211d \u00d7 \u211d) in univ.pi fun x => Complex.polarCoord.target,\n      (\u220f i, ENNReal.ofReal (p i).1) * f fun i => \u2191Complex.polarCoord.symm (p i)) =\n    \u222b\u207b (p : \u03b9 \u2192 \u2102), f p\n---\ncase refine_1\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nf : (\u03b9 \u2192 \u2102) \u2192 ENNReal\ne : (\u03b9 \u2192 \u211d \u00d7 \u211d) \u2243\u1d50 (\u03b9 \u2192 \u2102) := MeasurableEquiv.piCongrRight fun x => measurableEquivRealProd.symm\n\u22a2 Fintype \u03b9"}, {"line": "rw [\u2190 MeasurePreserving.lintegral_comp_emb this e.measurableEmbedding]", "tactic_state": "case refine_2\n\u03b9 : Type u_1\ninst\u271d : Fintype \u03b9\nf : (\u03b9 \u2192 \u2102) \u2192 ENNReal\ne : (\u03b9 \u2192 \u211d \u00d7 \u211d) \u2243\u1d50 (\u03b9 \u2192 \u2102) := MeasurableEquiv.piCongrRight fun x => measurableEquivRealProd.symm\nthis : MeasurePreserving (fun a i => measurableEquivRealProd.symm (a i)) volume volume\n\u22a2 (\u222b\u207b (p : \u03b9 \u2192 \u211d \u00d7 \u211d) in univ.pi fun x => Complex.polarCoord.target,\n      (\u220f i, ENNReal.ofReal (p i).1) * f fun i => \u2191Complex.polarCoord.symm (p i)) =\n    \u222b\u207b (a : \u03b9 \u2192 \u211d \u00d7 \u211d), f fun i => measurableEquivRealProd.symm (a i) \u2202volume"}, {"line": "exact lintegral_comp_pi_polarCoord_symm (f \u2218 e)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_of_nonpos {x : \u211d} (hx : x \u2264 0) : expNegInvGlue x = 0 := by simp [expNegInvGlue, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/SmoothTransition.lean", "context": {"open": ["scoped Topology", "Polynomial Real Filter Set Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2264 0\n\u22a2 expNegInvGlue x = 0"}, {"line": "simp [expNegInvGlue, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pos_of_pos {x : \u211d} (hx : 0 < x) : 0 < expNegInvGlue x := by\n  simp [expNegInvGlue, not_le.2 hx, exp_pos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/SmoothTransition.lean", "context": {"open": ["scoped Topology", "Polynomial Real Filter Set Function"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\n\u22a2 0 < expNegInvGlue x"}, {"line": "simp [expNegInvGlue, not_le.2 hx, exp_pos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.sqrt (hf : HasDerivWithinAt f f' s x) (hx : f x \u2260 0) :\n    HasDerivWithinAt (fun y => \u221a(f y)) (f' / (2 * \u221a(f x))) s x := by\n  simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using\n    (hasDerivAt_sqrt hx).comp_hasDerivWithinAt x hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Sqrt.lean", "context": {"open": ["Set", "scoped Topology", "Real"], "variables": ["{f : \u211d \u2192 \u211d} {s : Set \u211d} {f' x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\ns : Set \u211d\nf' x : \u211d\nhf : HasDerivWithinAt f f' s x\nhx : f x \u2260 0\n\u22a2 HasDerivWithinAt (fun y => \u221a(f y)) (f' / (2 * \u221a(f x))) s x"}, {"line": "simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using\n    (hasDerivAt_sqrt hx).comp_hasDerivWithinAt x hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.sqrt (hf : HasDerivAt f f' x) (hx : f x \u2260 0) :\n    HasDerivAt (fun y => \u221a(f y)) (f' / (2 * \u221a(f x))) x := by\n  simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using (hasDerivAt_sqrt hx).comp x hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Sqrt.lean", "context": {"open": ["Set", "scoped Topology", "Real"], "variables": ["{f : \u211d \u2192 \u211d} {s : Set \u211d} {f' x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nf' x : \u211d\nhf : HasDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasDerivAt (fun y => \u221a(f y)) (f' / (2 * \u221a(f x))) x"}, {"line": "simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using (hasDerivAt_sqrt hx).comp x hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasStrictDerivAt.sqrt (hf : HasStrictDerivAt f f' x) (hx : f x \u2260 0) :\n    HasStrictDerivAt (fun t => \u221a(f t)) (f' / (2 * \u221a(f x))) x := by\n  simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using (hasStrictDerivAt_sqrt hx).comp x hf\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Sqrt.lean", "context": {"open": ["Set", "scoped Topology", "Real"], "variables": ["{f : \u211d \u2192 \u211d} {s : Set \u211d} {f' x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nf' x : \u211d\nhf : HasStrictDerivAt f f' x\nhx : f x \u2260 0\n\u22a2 HasStrictDerivAt (fun t => \u221a(f t)) (f' / (2 * \u221a(f x))) x"}, {"line": "simpa only [(\u00b7 \u2218 \u00b7),div_eq_inv_mul,mul_one] using (hasStrictDerivAt_sqrt hx).comp x hf", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_stirlingSeq_formula (n : \u2115) :\n    log (stirlingSeq n) = Real.log n ! - 1 / 2 * Real.log (2 * n) - n * log (n / exp 1) := by\n  cases n\n  \u00b7 simp\n  \u00b7 rw [stirlingSeq, log_div, log_mul, sqrt_eq_rpow, log_rpow, Real.log_pow, tsub_tsub]\n      <;> positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Stirling.lean", "context": {"open": ["scoped Topology Real Nat Asymptotics", "Finset Filter Nat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nstirlingSeq : x\u271d\nn : \u2115\n\u22a2 sorry = Real.log \u2191n.factorial - 1 / 2 * Real.log (2 * \u2191n) - \u2191n * Real.log (\u2191n / exp 1)"}, {"line": "cases n", "tactic_state": "case zero\nx\u271d : Sort u_1\nstirlingSeq : x\u271d\n\u22a2 sorry = Real.log \u2191(factorial 0) - 1 / 2 * Real.log (2 * \u21910) - \u21910 * Real.log (\u21910 / exp 1)\n---\ncase succ\nx\u271d : Sort u_1\nstirlingSeq : x\u271d\nn\u271d : \u2115\n\u22a2 sorry = Real.log \u2191(n\u271d + 1).factorial - 1 / 2 * Real.log (2 * \u2191(n\u271d + 1)) - \u2191(n\u271d + 1) * Real.log (\u2191(n\u271d + 1) / exp 1)"}, {"line": "\u00b7 simp", "tactic_state": "case succ\nx\u271d : Sort u_1\nstirlingSeq : x\u271d\nn\u271d : \u2115\n\u22a2 sorry = Real.log \u2191(n\u271d + 1).factorial - 1 / 2 * Real.log (2 * \u2191(n\u271d + 1)) - \u2191(n\u271d + 1) * Real.log (\u2191(n\u271d + 1) / exp 1)"}, {"line": "\u00b7 rw [stirlingSeq, log_div, log_mul, sqrt_eq_rpow, log_rpow, Real.log_pow, tsub_tsub]\n      <;> positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_self_div_two_mul_self_add_one :\n    Tendsto (fun n : \u2115 => (n : \u211d) / (2 * n + 1)) atTop (\ud835\udcdd (1 / 2)) := by\n  conv =>\n    congr\n    \u00b7 skip\n    \u00b7 skip\n    rw [one_div]\n    rw [\u2190 add_zero (2 : \u211d)]\n  refine (((tendsto_const_div_atTop_nhds_zero_nat 1).const_add (2 : \u211d)).inv\u2080\n    ((add_zero (2 : \u211d)).symm \u25b8 two_ne_zero)).congr' (eventually_atTop.mpr \u27e81, fun n hn => ?_\u27e9)\n  rw [add_div' (1 : \u211d) 2 n (cast_ne_zero.mpr (one_le_iff_ne_zero.mp hn))]\n  rw [inv_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Stirling.lean", "context": {"open": ["scoped Topology Real Nat Asymptotics", "Finset Filter Nat Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto (fun n => \u2191n / (2 * \u2191n + 1)) atTop (nhds (1 / 2))"}, {"line": "conv =>\n    congr\n    \u00b7 skip\n    \u00b7 skip\n    rw [one_div]\n    rw [\u2190 add_zero (2 : \u211d)]", "tactic_state": "\u22a2 Tendsto (fun n => \u2191n / (2 * \u2191n + 1)) atTop (nhds (2 + 0)\u207b\u00b9)"}, {"line": "refine (((tendsto_const_div_atTop_nhds_zero_nat 1).const_add (2 : \u211d)).inv\u2080\n    ((add_zero (2 : \u211d)).symm \u25b8 two_ne_zero)).congr' (eventually_atTop.mpr \u27e81, fun n hn => ?_\u27e9)", "tactic_state": "n : \u2115\nhn : n \u2265 1\n\u22a2 (2 + 1 / \u2191n)\u207b\u00b9 = (fun n => \u2191n / (2 * \u2191n + 1)) n"}, {"line": "rw [add_div' (1 : \u211d) 2 n (cast_ne_zero.mpr (one_le_iff_ne_zero.mp hn))]", "tactic_state": "n : \u2115\nhn : n \u2265 1\n\u22a2 ((2 * \u2191n + 1) / \u2191n)\u207b\u00b9 = (fun n => \u2191n / (2 * \u2191n + 1)) n"}, {"line": "rw [inv_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem analyticAt_clog (m : z \u2208 slitPlane) : AnalyticAt \u2102 log z := by\n  rw [analyticAt_iff_eventually_differentiableAt]\n  filter_upwards [isOpen_slitPlane.eventually_mem m]\n  intro z m\n  exact differentiableAt_id.clog m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Analytic.lean", "context": {"open": ["Complex Set", "scoped Topology"], "variables": ["{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{f g : E \u2192 \u2102} {z : \u2102} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\nm : z \u2208 slitPlane\n\u22a2 AnalyticAt \u2102 log z"}, {"line": "rw [analyticAt_iff_eventually_differentiableAt]", "tactic_state": "z : \u2102\nm : z \u2208 slitPlane\n\u22a2 \u2200\u1da0 (z : \u2102) in nhds z, DifferentiableAt \u2102 log z"}, {"line": "filter_upwards [isOpen_slitPlane.eventually_mem m]", "tactic_state": "case h\nz : \u2102\nm : z \u2208 slitPlane\n\u22a2 \u2200 a \u2208 slitPlane, DifferentiableAt \u2102 log a"}, {"line": "intro z m", "tactic_state": "case h\nz\u271d : \u2102\nm\u271d : z\u271d \u2208 slitPlane\nz : \u2102\nm : z \u2208 slitPlane\n\u22a2 DifferentiableAt \u2102 log z"}, {"line": "exact differentiableAt_id.clog m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem AnalyticAt.cpow (fa : AnalyticAt \u2102 f x) (ga : AnalyticAt \u2102 g x)\n    (m : f x \u2208 slitPlane) : AnalyticAt \u2102 (fun z \u21a6 f z ^ g z) x := by\n  rw [\u2190 analyticWithinAt_univ] at fa ga \u22a2\n  exact fa.cpow ga m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Analytic.lean", "context": {"open": ["Complex Set", "scoped Topology"], "variables": ["{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{f g : E \u2192 \u2102} {z : \u2102} {x : E} {s : Set E}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf g : E \u2192 \u2102\nx : E\nfa : AnalyticAt \u2102 f x\nga : AnalyticAt \u2102 g x\nm : f x \u2208 slitPlane\n\u22a2 AnalyticAt \u2102 (fun z => f z ^ g z) x"}, {"line": "rw [\u2190 analyticWithinAt_univ] at fa ga \u22a2", "tactic_state": "E : Type\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf g : E \u2192 \u2102\nx : E\nfa : AnalyticWithinAt \u2102 f univ x\nga : AnalyticWithinAt \u2102 g univ x\nm : f x \u2208 slitPlane\n\u22a2 AnalyticWithinAt \u2102 (fun z => f z ^ g z) univ x"}, {"line": "exact fa.cpow ga m", "tactic_state": "No Goals!"}]}
{"declaration": "lemma analyticAt_log (hx : 0 < x) : AnalyticAt \u211d Real.log x := by\n  have : Real.log = fun x : \u211d \u21a6 (Complex.log x).re := by ext x; exact (Complex.log_ofReal_re x).symm\n  rw [this]\n  refine AnalyticAt.re_ofReal <| analyticAt_clog ?_\n  simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Analytic.lean", "context": {"open": ["Complex Set", "scoped Topology"], "variables": ["{E : Type} [NormedAddCommGroup E] [NormedSpace \u2102 E]", "{f g : E \u2192 \u2102} {z : \u2102} {x : E} {s : Set E}", "{f : \u2102 \u2192 \u2102} {s : Set \u211d} {x : \u211d}", "{f : \u211d \u2192 \u211d} {s : Set \u211d} {x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\n\u22a2 AnalyticAt \u211d Real.log x"}, {"line": "have : Real.log = fun x : \u211d \u21a6 (Complex.log x).re := by ext x; exact (Complex.log_ofReal_re x).symm", "tactic_state": "x : \u211d\nhx : 0 < x\nthis : Real.log = fun x => (log \u2191x).re\n\u22a2 AnalyticAt \u211d Real.log x"}, {"line": "rw [this]", "tactic_state": "x : \u211d\nhx : 0 < x\nthis : Real.log = fun x => (log \u2191x).re\n\u22a2 AnalyticAt \u211d (fun x => (log \u2191x).re) x"}, {"line": "refine AnalyticAt.re_ofReal <| analyticAt_clog ?_", "tactic_state": "x : \u211d\nhx : 0 < x\nthis : Real.log = fun x => (log \u2191x).re\n\u22a2 \u2191x \u2208 slitPlane"}, {"line": "simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_two_pi_mul_int (n : \u2124) : exp (2 * \u03c0 * n) = 1 := by\n  simpa only [mul_comm] using exp_int_mul_two_pi n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "context": {"open": ["Complex Function Set", "Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 sorry = 1"}, {"line": "simpa only [mul_comm] using exp_int_mul_two_pi n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_eq_one {r : \u211d} : exp r = 1 \u2194 \u2203 n : \u2124, r = n * (2 * \u03c0) := by\n  simp [Circle.ext_iff, Complex.exp_eq_one_iff, \u2190 mul_assoc, Complex.I_ne_zero,\n    \u2190 Complex.ofReal_inj]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "context": {"open": ["Complex Function Set", "Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r : \u211d\n\u22a2 sorry = 1 \u2194 \u2203 n, r = \u2191n * (2 * Real.pi)"}, {"line": "simp [Circle.ext_iff, Complex.exp_eq_one_iff, \u2190 mul_assoc, Complex.I_ne_zero,\n    \u2190 Complex.ofReal_inj]", "tactic_state": "r : \u211d\n\u22a2 sorry () = 1 \u2194 \u2203 n, \u2191r = \u2191n * 2 * \u2191Real.pi"}]}
{"declaration": "lemma exp_inj {r s : \u211d} : exp r = exp s \u2194 r \u2261 s [PMOD (2 * \u03c0)] := by\n  simp [AddCommGroup.ModEq, \u2190 exp_eq_one, div_eq_one, eq_comm (a := exp r)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "context": {"open": ["Complex Function Set", "Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "r s : \u211d\n\u22a2 sorry = sorry \u2194 r \u2261 s [PMOD 2 * Real.pi]"}, {"line": "simp [AddCommGroup.ModEq, \u2190 exp_eq_one, div_eq_one, eq_comm (a := exp r)]", "tactic_state": "r s : \u211d\n\u22a2 \u2203 z, s - r = \u2191z * (2 * Real.pi)"}]}
{"declaration": "lemma coe_toCircle (\u03b8 : Angle) : (\u03b8.toCircle : \u2102) = \u03b8.cos + \u03b8.sin * I := by\n  induction \u03b8 using Real.Angle.induction_on\n  simp [exp_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "context": {"open": ["Complex Function Set", "Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 \u2191\u03b8.toCircle = \u2191\u03b8.cos + \u2191\u03b8.sin * I"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 \u2191(\u2191x\u271d).toCircle = \u2191(\u2191x\u271d).cos + \u2191(\u2191x\u271d).sin * I"}, {"line": "simp [exp_mul_I]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem scaled_exp_map_periodic : Function.Periodic (fun x => Circle.exp (2 * \u03c0 / T * x)) T := by\n  -- The case T = 0 is not interesting, but it is true, so we prove it to save hypotheses\n  rcases eq_or_ne T 0 with (rfl | hT)\n  \u00b7 intro x; simp\n  \u00b7 intro x; simp_rw [mul_add]; rw [div_mul_cancel\u2080 _ hT, Circle.periodic_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Circle.lean", "context": {"open": ["Complex Function Set", "Real"], "variables": ["{T : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "T : \u211d\n\u22a2 Periodic (fun x => Circle.exp (2 * Real.pi / T * x)) T"}, {"line": "rcases eq_or_ne T 0 with (rfl | hT)", "tactic_state": "case inl\n\u22a2 Periodic (fun x => Circle.exp (2 * Real.pi / 0 * x)) 0\n---\ncase inr\nT : \u211d\nhT : T \u2260 0\n\u22a2 Periodic (fun x => Circle.exp (2 * Real.pi / T * x)) T"}, {"line": "\u00b7 intro x; simp", "tactic_state": "case inr\nT : \u211d\nhT : T \u2260 0\n\u22a2 Periodic (fun x => Circle.exp (2 * Real.pi / T * x)) T"}, {"line": "\u00b7 intro x; simp_rw [mul_add]; rw [div_mul_cancel\u2080 _ hT, Circle.periodic_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_ofReal_re (x : \u211d) : (log (x : \u2102)).re = Real.log x := by simp [log_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\n\u22a2 sorry = Real.log x"}, {"line": "simp [log_re]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\n\u22a2 sorry () = Real.log x"}]}
{"declaration": "theorem log_zero : log 0 = 0 := by simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [log]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem log_one : log 1 = 0 := by simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [log]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem log_neg_one : log (-1) = \u03c0 * I := by simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry = Real.pi * I"}, {"line": "simp [log]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry () = Real.pi * I"}]}
{"declaration": "theorem log_I : log I = \u03c0 / 2 * I := by simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry = Real.pi / 2 * I"}, {"line": "simp [log]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry () = Real.pi / 2 * I"}]}
{"declaration": "theorem log_neg_I : log (-I) = -(\u03c0 / 2) * I := by simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry = -(Real.pi / 2) * I"}, {"line": "simp [log]", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nI : \u211d\n\u22a2 sorry () = -(Real.pi / 2 * I)"}]}
{"declaration": "theorem two_pi_I_ne_zero : (2 * \u03c0 * I : \u2102) \u2260 0 := by norm_num [Real.pi_ne_zero, I_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u2102\n\u22a2 2 * \u2191Real.pi * I \u2260 0"}, {"line": "norm_num [Real.pi_ne_zero, I_ne_zero]", "tactic_state": "I : \u2102\n\u22a2 \u00acI = 0"}]}
{"declaration": "theorem tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto log (\ud835\udcdd[{ z : \u2102 | 0 \u2264 z.im }] z) (\ud835\udcdd <| Real.log \u2016z\u2016 + \u03c0 * I) := by\n  simpa only [log,arg_eq_pi_iff.2 \u27e8hre,him\u27e9] using\n    (continuousWithinAt_log_of_re_neg_of_im_zero hre him).tendsto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "log : \u2102 \u2192 \u211d\nI : \u211d\nz : \u2102\nhre : z.re < 0\nhim : z.im = 0\n\u22a2 Tendsto log (nhdsWithin z {z | 0 \u2264 z.im}) (nhds (Real.log \u2016z\u2016 + Real.pi * I))"}, {"line": "simpa only [log,arg_eq_pi_iff.2 \u27e8hre,him\u27e9] using\n    (continuousWithinAt_log_of_re_neg_of_im_zero hre him).tendsto", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_clog {x : \u2102} (h : x \u2208 slitPlane) : ContinuousAt log x := by\n  refine ContinuousAt.add ?_ ?_\n  \u00b7 refine continuous_ofReal.continuousAt.comp ?_\n    refine (Real.continuousAt_log ?_).comp continuous_norm.continuousAt\n    exact norm_ne_zero_iff.mpr <| slitPlane_ne_zero h\n  \u00b7 have h_cont_mul : Continuous fun x : \u2102 => x * I := continuous_id'.mul continuous_const\n    refine h_cont_mul.continuousAt.comp (continuous_ofReal.continuousAt.comp ?_)\n    exact continuousAt_arg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Log.lean", "context": {"open": ["Set Filter Bornology", "scoped Real Topology ComplexConjugate", "Complex Filter", "Topology"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nh : x \u2208 slitPlane\n\u22a2 ContinuousAt log x"}, {"line": "refine ContinuousAt.add ?_ ?_", "tactic_state": "case refine_1\nx : \u2102\nh : x \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => \u2191(Real.log \u2016x\u2016)) x\n---\ncase refine_2\nx : \u2102\nh : x \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => \u2191x.arg * I) x"}, {"line": "\u00b7 refine continuous_ofReal.continuousAt.comp ?_\n    refine (Real.continuousAt_log ?_).comp continuous_norm.continuousAt\n    exact norm_ne_zero_iff.mpr <| slitPlane_ne_zero h", "tactic_state": "case refine_2\nx : \u2102\nh : x \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => \u2191x.arg * I) x"}, {"line": "\u00b7 have h_cont_mul : Continuous fun x : \u2102 => x * I := continuous_id'.mul continuous_const\n    refine h_cont_mul.continuousAt.comp (continuous_ofReal.continuousAt.comp ?_)\n    exact continuousAt_arg h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.deriv_log_comp_eq_logDeriv {f : \u2102 \u2192 \u2102} {x : \u2102} (h\u2081 : DifferentiableAt \u2102 f x)\n    (h\u2082 : f x \u2208 Complex.slitPlane) : deriv (Complex.log \u2218 f) x = logDeriv f x := by\n  have A := (HasDerivAt.clog h\u2081.hasDerivAt h\u2082).deriv\n  rw [\u2190 h\u2081.hasDerivAt.deriv] at A\n  simp only [logDeriv]\n  simp only [Pi.div_apply]\n  simp only [\u2190 A]\n  simp only [Function.comp_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/LogDeriv.lean", "context": {"open": ["Set Filter", "scoped Real Topology", "Complex Filter", "scoped Topology"], "variables": ["{\u03b1 : Type*} [TopologicalSpace \u03b1] {E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\n\u22a2 deriv (log \u2218 f) x = logDeriv f x"}, {"line": "have A := (HasDerivAt.clog h\u2081.hasDerivAt h\u2082).deriv", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\nA : deriv (fun t => log (f t)) x = deriv f x / f x\n\u22a2 deriv (log \u2218 f) x = logDeriv f x"}, {"line": "rw [\u2190 h\u2081.hasDerivAt.deriv] at A", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\nA : deriv (fun t => log (f t)) x = deriv f x / f x\n\u22a2 deriv (log \u2218 f) x = logDeriv f x"}, {"line": "simp only [logDeriv]", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\nA : deriv (fun t => log (f t)) x = deriv f x / f x\n\u22a2 deriv (log \u2218 f) x = (deriv f / f) x"}, {"line": "simp only [Pi.div_apply]", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\nA : deriv (fun t => log (f t)) x = deriv f x / f x\n\u22a2 deriv (log \u2218 f) x = deriv f x / f x"}, {"line": "simp only [\u2190 A]", "tactic_state": "f : \u2102 \u2192 \u2102\nx : \u2102\nh\u2081 : DifferentiableAt \u2102 f x\nh\u2082 : f x \u2208 slitPlane\nA : deriv (fun t => log (f t)) x = deriv f x / f x\n\u22a2 deriv (log \u2218 f) x = deriv (fun t => log (f t)) x"}, {"line": "simp only [Function.comp_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_mul_exp_arg_mul_I (x : \u2102) : \u2016x\u2016 * exp (arg x * I) = x := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  \u00b7 simp\n  \u00b7 have : \u2016x\u2016 \u2260 0 := norm_ne_zero_iff.mpr hx\n    apply Complex.ext <;> field_simp [sin_arg, cos_arg hx, this, mul_comm \u2016x\u2016]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexp : x\u271d\nx : \u2102\n\u22a2 \u2191\u2016x\u2016 * sorry = x"}, {"line": "rcases eq_or_ne x 0 with (rfl | hx)", "tactic_state": "case inl\nx\u271d : Sort u_1\nexp : x\u271d\n\u22a2 \u2191\u20160\u2016 * sorry = 0\n---\ncase inr\nx\u271d : Sort u_1\nexp : x\u271d\nx : \u2102\nhx : x \u2260 0\n\u22a2 \u2191\u2016x\u2016 * sorry = x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx\u271d : Sort u_1\nexp : x\u271d\nx : \u2102\nhx : x \u2260 0\n\u22a2 \u2191\u2016x\u2016 * sorry = x"}, {"line": "\u00b7 have : \u2016x\u2016 \u2260 0 := norm_ne_zero_iff.mpr hx\n    apply Complex.ext <;> field_simp [sin_arg, cos_arg hx, this, mul_comm \u2016x\u2016]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_eq_one_iff (z : \u2102) : \u2016z\u2016 = 1 \u2194 \u2203 \u03b8 : \u211d, exp (\u03b8 * I) = z := by\n  refine \u27e8fun hz => \u27e8arg z, ?_\u27e9, ?_\u27e9\n  \u00b7 calc\n      exp (arg z * I) = \u2016z\u2016 * exp (arg z * I) := by rw [hz, ofReal_one, one_mul]\n      _ = z :=norm_mul_exp_arg_mul_I z\n  \u00b7 rintro \u27e8\u03b8, rfl\u27e9\n    exact Complex.norm_exp_ofReal_mul_I \u03b8\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexp : x\u271d\nz : \u2102\n\u22a2 \u2016z\u2016 = 1 \u2194 \u2203 \u03b8, sorry = z"}, {"line": "refine \u27e8fun hz => \u27e8arg z, ?_\u27e9, ?_\u27e9", "tactic_state": "case refine_1\nx\u271d : Sort u_1\nexp : x\u271d\nz : \u2102\nhz : \u2016z\u2016 = 1\n\u22a2 sorry = z\n---\ncase refine_2\nx\u271d : Sort u_1\nexp : x\u271d\nz : \u2102\n\u22a2 (\u2203 \u03b8, sorry = z) \u2192 \u2016z\u2016 = 1"}, {"line": "\u00b7 calc\n      exp (arg z * I) = \u2016z\u2016 * exp (arg z * I) := by rw [hz, ofReal_one, one_mul]\n      _ = z :=norm_mul_exp_arg_mul_I z", "tactic_state": "case refine_2\nx\u271d : Sort u_1\nexp : x\u271d\nz : \u2102\n\u22a2 (\u2203 \u03b8, sorry = z) \u2192 \u2016z\u2016 = 1"}, {"line": "\u00b7 rintro \u27e8\u03b8, rfl\u27e9\n    exact Complex.norm_exp_ofReal_mul_I \u03b8", "tactic_state": "No Goals!"}]}
{"declaration": "theorem arg_zero : arg 0 = 0 := by simp [arg, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [arg, le_refl]", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem arg_neg_one : arg (-1) = \u03c0 := by simp [arg, le_refl, not_le.2 (zero_lt_one' \u211d)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry = Real.pi"}, {"line": "simp [arg, le_refl, not_le.2 (zero_lt_one' \u211d)]", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry () = Real.pi"}]}
{"declaration": "theorem arg_I : arg I = \u03c0 / 2 := by simp [arg, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry = Real.pi / 2"}, {"line": "simp [arg, le_refl]", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry () = Real.pi / 2"}]}
{"declaration": "theorem arg_neg_I : arg (-I) = -(\u03c0 / 2) := by simp [arg, le_refl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry = -(Real.pi / 2)"}, {"line": "simp [arg, le_refl]", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\n\u22a2 sorry () = -(Real.pi / 2)"}]}
{"declaration": "theorem arg_ofReal_of_nonneg {x : \u211d} (hx : 0 \u2264 x) : arg x = 0 := by simp [arg, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\nx : \u211d\nhx : 0 \u2264 x\n\u22a2 sorry = 0"}, {"line": "simp [arg, hx]", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\nx : \u211d\nhx : 0 \u2264 x\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem arg_pow_coe_angle (x : \u2102) (n : \u2115) :\n    (arg (x ^ n) : Real.Angle) = n \u2022 (arg x : Real.Angle) := by\n  obtain rfl | x0 := eq_or_ne x 0\n  \u00b7 by_cases n0 : n = 0 <;> simp [n0]\n  \u00b7 induction n with\n    | zero => simp [x0]\n    | succ n ih => rw [pow_succ, arg_mul_coe_angle (pow_ne_zero n x0) x0, ih, succ_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology", "ComplexOrder in", "ComplexOrder in"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narg : x\u271d\nx : \u2102\nn : \u2115\n\u22a2 sorry = n \u2022 sorry"}, {"line": "obtain rfl | x0 := eq_or_ne x 0", "tactic_state": "case inl\nx\u271d : Sort u_1\narg : x\u271d\nn : \u2115\n\u22a2 sorry = n \u2022 sorry\n---\ncase inr\nx\u271d : Sort u_1\narg : x\u271d\nx : \u2102\nn : \u2115\nx0 : x \u2260 0\n\u22a2 sorry = n \u2022 sorry"}, {"line": "\u00b7 by_cases n0 : n = 0 <;> simp [n0]", "tactic_state": "case inr\nx\u271d : Sort u_1\narg : x\u271d\nx : \u2102\nn : \u2115\nx0 : x \u2260 0\n\u22a2 sorry = n \u2022 sorry"}, {"line": "\u00b7 induction n with\n    | zero => simp [x0]\n    | succ n ih => rw [pow_succ, arg_mul_coe_angle (pow_ne_zero n x0) x0, ih, succ_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_arg_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : \u2102} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto arg (\ud835\udcdd[{ z : \u2102 | 0 \u2264 z.im }] z) (\ud835\udcdd \u03c0) := by\n  simpa only [arg_eq_pi_iff.2 \u27e8hre,him\u27e9] using\n    (continuousWithinAt_arg_of_re_neg_of_im_zero hre him).tendsto\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/Arg.lean", "context": {"open": ["Filter Metric Set", "scoped ComplexConjugate Real Topology", "ComplexOrder in", "ComplexOrder in", "ComplexOrder in"], "variables": ["{a x z : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "arg : \u2102 \u2192 \u211d\nz : \u2102\nhre : z.re < 0\nhim : z.im = 0\n\u22a2 Tendsto arg (nhdsWithin z {z | 0 \u2264 z.im}) (nhds Real.pi)"}, {"line": "simpa only [arg_eq_pi_iff.2 \u27e8hre,him\u27e9] using\n    (continuousWithinAt_arg_of_re_neg_of_im_zero hre him).tendsto", "tactic_state": "No Goals!"}]}
{"declaration": "lemma stdAddChar_coe (j : \u2124) :\n    stdAddChar (j : ZMod N) = exp (2 * \u03c0 * I * j / N) := by simp [stdAddChar, toCircle_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleAddChar.lean", "context": {"open": ["Complex Function", "scoped Real", "AddCircle", "scoped Real"], "variables": ["{N : \u2115} [NeZero N]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\nx\u271d : Sort u_1\nstdAddChar : x\u271d\nj : \u2124\n\u22a2 sorry = exp (2 * \u2191Real.pi * I * \u2191j / \u2191N)"}, {"line": "simp [stdAddChar, toCircle_intCast]", "tactic_state": "N : \u2115\ninst\u271d : NeZero N\nx\u271d : Sort u_1\nstdAddChar : x\u271d\nj : \u2124\n\u22a2 sorry () = exp (2 * \u2191Real.pi * I * \u2191j / \u2191N)"}]}
{"declaration": "theorem circleMap_sub_center (c : \u2102) (R : \u211d) (\u03b8 : \u211d) : circleMap c R \u03b8 - c = circleMap 0 R \u03b8 := by\n  simp [circleMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 circleMap c R \u03b8 - c = circleMap 0 R \u03b8"}, {"line": "simp [circleMap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_circleMap_zero (R : \u211d) (\u03b8 : \u211d) : \u2016circleMap 0 R \u03b8\u2016 = |R| := by simp [circleMap]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R \u03b8 : \u211d\n\u22a2 \u2016circleMap 0 R \u03b8\u2016 = |R|"}, {"line": "simp [circleMap]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleMap_not_mem_ball (c : \u2102) (R : \u211d) (\u03b8 : \u211d) : circleMap c R \u03b8 \u2209 ball c R := by\n  simp [Complex.dist_eq, le_abs_self]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 circleMap c R \u03b8 \u2209 ball c R"}, {"line": "simp [Complex.dist_eq, le_abs_self]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleMap_mem_sphere' (c : \u2102) (R : \u211d) (\u03b8 : \u211d) : circleMap c R \u03b8 \u2208 sphere c |R| := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 circleMap c R \u03b8 \u2208 sphere c |R|"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleMap_mem_sphere (c : \u2102) {R : \u211d} (hR : 0 \u2264 R) (\u03b8 : \u211d) :\n    circleMap c R \u03b8 \u2208 sphere c R := by\n  simpa only [abs_of_nonneg hR] using circleMap_mem_sphere' c R \u03b8\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\nhR : 0 \u2264 R\n\u03b8 : \u211d\n\u22a2 circleMap c R \u03b8 \u2208 sphere c R"}, {"line": "simpa only [abs_of_nonneg hR] using circleMap_mem_sphere' c R \u03b8", "tactic_state": "No Goals!"}]}
{"declaration": "theorem circleMap_eq_center_iff {c : \u2102} {R : \u211d} {\u03b8 : \u211d} : circleMap c R \u03b8 = c \u2194 R = 0 := by\n  simp [circleMap, Complex.exp_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR \u03b8 : \u211d\n\u22a2 circleMap c R \u03b8 = c \u2194 R = 0"}, {"line": "simp [circleMap, Complex.exp_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_zero_div (R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d) :\n    (circleMap 0 R\u2081 \u03b8\u2081) / (circleMap 0 R\u2082 \u03b8\u2082) = circleMap 0 (R\u2081 / R\u2082) (\u03b8\u2081 - \u03b8\u2082) := by\n  simp only [circleMap_zero]\n  simp only [ofReal_div]\n  simp only [ofReal_sub]\n  simp only [sub_mul]\n  simp only [Complex.exp_sub]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 circleMap 0 R\u2081 \u03b8\u2081 / circleMap 0 R\u2082 \u03b8\u2082 = circleMap 0 (R\u2081 / R\u2082) (\u03b8\u2081 - \u03b8\u2082)"}, {"line": "simp only [circleMap_zero]", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 \u2191R\u2081 * Complex.exp (\u2191\u03b8\u2081 * I) / (\u2191R\u2082 * Complex.exp (\u2191\u03b8\u2082 * I)) = \u2191(R\u2081 / R\u2082) * Complex.exp (\u2191(\u03b8\u2081 - \u03b8\u2082) * I)"}, {"line": "simp only [ofReal_div]", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 \u2191R\u2081 * Complex.exp (\u2191\u03b8\u2081 * I) / (\u2191R\u2082 * Complex.exp (\u2191\u03b8\u2082 * I)) = \u2191R\u2081 / \u2191R\u2082 * Complex.exp (\u2191(\u03b8\u2081 - \u03b8\u2082) * I)"}, {"line": "simp only [ofReal_sub]", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 \u2191R\u2081 * Complex.exp (\u2191\u03b8\u2081 * I) / (\u2191R\u2082 * Complex.exp (\u2191\u03b8\u2082 * I)) = \u2191R\u2081 / \u2191R\u2082 * Complex.exp ((\u2191\u03b8\u2081 - \u2191\u03b8\u2082) * I)"}, {"line": "simp only [sub_mul]", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 \u2191R\u2081 * Complex.exp (\u2191\u03b8\u2081 * I) / (\u2191R\u2082 * Complex.exp (\u2191\u03b8\u2082 * I)) = \u2191R\u2081 / \u2191R\u2082 * Complex.exp (\u2191\u03b8\u2081 * I - \u2191\u03b8\u2082 * I)"}, {"line": "simp only [Complex.exp_sub]", "tactic_state": "R\u2081 R\u2082 \u03b8\u2081 \u03b8\u2082 : \u211d\n\u22a2 \u2191R\u2081 * Complex.exp (\u2191\u03b8\u2081 * I) / (\u2191R\u2082 * Complex.exp (\u2191\u03b8\u2082 * I)) =\n    \u2191R\u2081 / \u2191R\u2082 * (Complex.exp (\u2191\u03b8\u2081 * I) / Complex.exp (\u2191\u03b8\u2082 * I))"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_zero_inv (R \u03b8 : \u211d) : (circleMap 0 R \u03b8)\u207b\u00b9 = circleMap 0 R\u207b\u00b9 (-\u03b8) := by\n  simp [circleMap_zero, Complex.exp_neg, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "R \u03b8 : \u211d\n\u22a2 (circleMap 0 R \u03b8)\u207b\u00b9 = circleMap 0 R\u207b\u00b9 (-\u03b8)"}, {"line": "simp [circleMap_zero, Complex.exp_neg, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_zero_pow (n : \u2115) (R \u03b8 : \u211d) :\n    (circleMap 0 R \u03b8) ^ n = circleMap 0 (R ^ n) (n * \u03b8) := by\n  simp [circleMap_zero, mul_pow, \u2190 Complex.exp_nat_mul, \u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\nR \u03b8 : \u211d\n\u22a2 circleMap 0 R \u03b8 ^ n = circleMap 0 (R ^ n) (\u2191n * \u03b8)"}, {"line": "simp [circleMap_zero, mul_pow, \u2190 Complex.exp_nat_mul, \u2190 mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_zero_zpow (n : \u2124) (R \u03b8 : \u211d) :\n    (circleMap 0 R \u03b8) ^ n = circleMap 0 (R ^ n) (n * \u03b8) := by\n  simp [circleMap_zero, mul_zpow, \u2190 exp_int_mul, \u2190 mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\nR \u03b8 : \u211d\n\u22a2 circleMap 0 R \u03b8 ^ n = circleMap 0 (R ^ n) (\u2191n * \u03b8)"}, {"line": "simp [circleMap_zero, mul_zpow, \u2190 exp_int_mul, \u2190 mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_pi_div_two (c : \u2102) (R : \u211d) : circleMap c R (\u03c0 / 2) = c + R * I := by\n  simp only [circleMap]\n  simp only [ofReal_div]\n  simp only [ofReal_ofNat]\n  simp only [exp_pi_div_two_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 circleMap c R (Real.pi / 2) = c + \u2191R * I"}, {"line": "simp only [circleMap]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (\u2191(Real.pi / 2) * I) = c + \u2191R * I"}, {"line": "simp only [ofReal_div]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (\u2191Real.pi / \u21912 * I) = c + \u2191R * I"}, {"line": "simp only [ofReal_ofNat]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (\u2191Real.pi / 2 * I) = c + \u2191R * I"}, {"line": "simp only [exp_pi_div_two_mul_I]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_neg_pi_div_two (c : \u2102) (R : \u211d) : circleMap c R (-\u03c0 / 2) = c - R * I := by\n  simp only [circleMap]\n  simp only [ofReal_div]\n  simp only [ofReal_neg]\n  simp only [ofReal_ofNat]\n  simp only [exp_neg_pi_div_two_mul_I]\n  simp only [mul_neg]\n  simp only [sub_eq_add_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 circleMap c R (-Real.pi / 2) = c - \u2191R * I"}, {"line": "simp only [circleMap]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (\u2191(-Real.pi / 2) * I) = c - \u2191R * I"}, {"line": "simp only [ofReal_div]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (\u2191(-Real.pi) / \u21912 * I) = c - \u2191R * I"}, {"line": "simp only [ofReal_neg]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (-\u2191Real.pi / \u21912 * I) = c - \u2191R * I"}, {"line": "simp only [ofReal_ofNat]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * Complex.exp (-\u2191Real.pi / 2 * I) = c - \u2191R * I"}, {"line": "simp only [exp_neg_pi_div_two_mul_I]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + \u2191R * -I = c - \u2191R * I"}, {"line": "simp only [mul_neg]", "tactic_state": "c : \u2102\nR : \u211d\n\u22a2 c + -(\u2191R * I) = c - \u2191R * I"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma circleMap_eq_circleMap_iff {a b R : \u211d} (c : \u2102) (h_R : R \u2260 0) :\n    circleMap c R a = circleMap c R b \u2194 \u2203 (n : \u2124), a * I = b * I + n * (2 * \u03c0 * I) := by\n  have : circleMap c R a = circleMap c R b \u2194 (exp (a * I)).arg = (exp (b * I)).arg := by\n    simp [circleMap, ext_norm_arg_iff, h_R]\n  simp [this, arg_eq_arg_iff, exp_eq_exp_iff_exists_int]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\n\u22a2 circleMap c R a = circleMap c R b \u2194 \u2203 n, \u2191a * I = \u2191b * I + \u2191n * (2 * \u2191Real.pi * I)"}, {"line": "have : circleMap c R a = circleMap c R b \u2194 (exp (a * I)).arg = (exp (b * I)).arg := by\n    simp [circleMap, ext_norm_arg_iff, h_R]", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nthis : circleMap c R a = circleMap c R b \u2194 (Complex.exp (\u2191a * I)).arg = (Complex.exp (\u2191b * I)).arg\n\u22a2 circleMap c R a = circleMap c R b \u2194 \u2203 n, \u2191a * I = \u2191b * I + \u2191n * (2 * \u2191Real.pi * I)"}, {"line": "simp [this, arg_eq_arg_iff, exp_eq_exp_iff_exists_int]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injOn_circleMap_of_abs_sub_le {a b R : \u211d} {c : \u2102} (h_R : R \u2260 0) (_ : |a - b| \u2264 2 * \u03c0) :\n    (\u0399 a b).InjOn (circleMap c R) := by\n  rintro _ \u27e8_, _\u27e9 _ \u27e8_, _\u27e9 h\n  apply eq_of_circleMap_eq h_R _ h\n  rw [abs_lt]\n  constructor <;> linarith [max_sub_min_eq_abs' a b]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real", "scoped Interval in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : |a - b| \u2264 2 * Real.pi\n\u22a2 Set.InjOn (circleMap c R) (Set.uIoc a b)"}, {"line": "rintro _ \u27e8_, _\u27e9 _ \u27e8_, _\u27e9 h", "tactic_state": "case intro.intro\na b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : |a - b| \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : min a b < x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d \u2264 max a b\nx\u2082\u271d : \u211d\nleft\u271d : min a b < x\u2082\u271d\nright\u271d : x\u2082\u271d \u2264 max a b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 x\u2081\u271d = x\u2082\u271d"}, {"line": "apply eq_of_circleMap_eq h_R _ h", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : |a - b| \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : min a b < x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d \u2264 max a b\nx\u2082\u271d : \u211d\nleft\u271d : min a b < x\u2082\u271d\nright\u271d : x\u2082\u271d \u2264 max a b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 |x\u2081\u271d - x\u2082\u271d| < 2 * Real.pi"}, {"line": "rw [abs_lt]", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : |a - b| \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : min a b < x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d \u2264 max a b\nx\u2082\u271d : \u211d\nleft\u271d : min a b < x\u2082\u271d\nright\u271d : x\u2082\u271d \u2264 max a b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 -(2 * Real.pi) < x\u2081\u271d - x\u2082\u271d \u2227 x\u2081\u271d - x\u2082\u271d < 2 * Real.pi"}, {"line": "constructor <;> linarith [max_sub_min_eq_abs' a b]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem injOn_circleMap_of_abs_sub_le' {a b R : \u211d} {c : \u2102} (h_R : R \u2260 0) (_ : b - a \u2264 2 * \u03c0) :\n    (Set.Ico a b).InjOn (circleMap c R) := by\n  rintro _ \u27e8_, _\u27e9 _ \u27e8_, _\u27e9 h\n  apply eq_of_circleMap_eq h_R _ h\n  rw [abs_lt]\n  constructor <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/CircleMap.lean", "context": {"open": ["Complex Function Metric Real", "scoped Interval in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : b - a \u2264 2 * Real.pi\n\u22a2 Set.InjOn (circleMap c R) (Set.Ico a b)"}, {"line": "rintro _ \u27e8_, _\u27e9 _ \u27e8_, _\u27e9 h", "tactic_state": "case intro.intro\na b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : b - a \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : a \u2264 x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d < b\nx\u2082\u271d : \u211d\nleft\u271d : a \u2264 x\u2082\u271d\nright\u271d : x\u2082\u271d < b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 x\u2081\u271d = x\u2082\u271d"}, {"line": "apply eq_of_circleMap_eq h_R _ h", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : b - a \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : a \u2264 x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d < b\nx\u2082\u271d : \u211d\nleft\u271d : a \u2264 x\u2082\u271d\nright\u271d : x\u2082\u271d < b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 |x\u2081\u271d - x\u2082\u271d| < 2 * Real.pi"}, {"line": "rw [abs_lt]", "tactic_state": "a b R : \u211d\nc : \u2102\nh_R : R \u2260 0\nx\u271d : b - a \u2264 2 * Real.pi\nx\u2081\u271d : \u211d\nleft\u271d\u00b9 : a \u2264 x\u2081\u271d\nright\u271d\u00b9 : x\u2081\u271d < b\nx\u2082\u271d : \u211d\nleft\u271d : a \u2264 x\u2082\u271d\nright\u271d : x\u2082\u271d < b\nh : circleMap c R x\u2081\u271d = circleMap c R x\u2082\u271d\n\u22a2 -(2 * Real.pi) < x\u2081\u271d - x\u2082\u271d \u2227 x\u2081\u271d - x\u2082\u271d < 2 * Real.pi"}, {"line": "constructor <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "lemma norm_one_add_mul_inv_le {t : \u211d} (ht : t \u2208 Set.Icc 0 1) {z : \u2102} (hz : \u2016z\u2016 < 1) :\n    \u2016(1 + t * z)\u207b\u00b9\u2016 \u2264 (1 - \u2016z\u2016)\u207b\u00b9 := by\n  rw [Set.mem_Icc] at ht\n  rw [norm_inv]\n  refine inv_anti\u2080 (by linarith) ?_\n  calc 1 - \u2016z\u2016\n    _ \u2264 1 - t * \u2016z\u2016 := by\n      nlinarith [norm_nonneg z]\n    _ = 1 - \u2016t * z\u2016 := by\n      rw [norm_mul]\n      rw [Complex.norm_of_nonneg ht.1]\n    _ \u2264 \u20161 + t * z\u2016 := by\n      rw [\u2190 norm_neg (t * z)]\n      rw [\u2190 sub_neg_eq_add]\n      convert norm_sub_norm_le 1 (-(t * z))\n      exact norm_one.symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Complex/LogBounds.lean", "context": {"open": ["intervalIntegral in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "t : \u211d\nht : t \u2208 Set.Icc 0 1\nz : \u2102\nhz : \u2016z\u2016 < 1\n\u22a2 \u2016(1 + \u2191t * z)\u207b\u00b9\u2016 \u2264 (1 - \u2016z\u2016)\u207b\u00b9"}, {"line": "rw [Set.mem_Icc] at ht", "tactic_state": "t : \u211d\nht : 0 \u2264 t \u2227 t \u2264 1\nz : \u2102\nhz : \u2016z\u2016 < 1\n\u22a2 \u2016(1 + \u2191t * z)\u207b\u00b9\u2016 \u2264 (1 - \u2016z\u2016)\u207b\u00b9"}, {"line": "rw [norm_inv]", "tactic_state": "t : \u211d\nht : 0 \u2264 t \u2227 t \u2264 1\nz : \u2102\nhz : \u2016z\u2016 < 1\n\u22a2 \u20161 + \u2191t * z\u2016\u207b\u00b9 \u2264 (1 - \u2016z\u2016)\u207b\u00b9"}, {"line": "refine inv_anti\u2080 (by linarith) ?_", "tactic_state": "t : \u211d\nht : 0 \u2264 t \u2227 t \u2264 1\nz : \u2102\nhz : \u2016z\u2016 < 1\n\u22a2 1 - \u2016z\u2016 \u2264 \u20161 + \u2191t * z\u2016"}, {"line": "calc 1 - \u2016z\u2016\n    _ \u2264 1 - t * \u2016z\u2016 := by\n      nlinarith [norm_nonneg z]\n    _ = 1 - \u2016t * z\u2016 := by\n      rw [norm_mul]\n      rw [Complex.norm_of_nonneg ht.1]\n    _ \u2264 \u20161 + t * z\u2016 := by\n      rw [\u2190 norm_neg (t * z)]\n      rw [\u2190 sub_neg_eq_add]\n      convert norm_sub_norm_le 1 (-(t * z))\n      exact norm_one.symm", "tactic_state": "No Goals!"}]}
{"declaration": "lemma log_algebraMap {r : \u211d} : log (algebraMap \u211d A r) = algebraMap \u211d A (Real.log r) := by\n  simp [log]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/ExpLog.lean", "context": {"open": ["NormedSpace", "scoped ComplexOrder"], "variables": ["{\ud835\udd5c : Type*} {\u03b1 : Type*} [RCLike \ud835\udd5c] [TopologicalSpace \u03b1] [CompactSpace \u03b1]", "{\ud835\udd5c : Type*} {A : Type*} [RCLike \ud835\udd5c] {p : A \u2192 Prop} [NormedRing A]", "{A : Type*} [NormedRing A] [StarRing A]", "{A : Type*} {p : A \u2192 Prop} [NormedRing A] [StarRing A]", "{A : Type*} [NormedRing A] [StarRing A] [NormedAlgebra \u211d A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_7\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : NormedAlgebra \u211d A\nx\u271d : Sort u_8\nlog : x\u271d\nr : \u211d\n\u22a2 sorry = (algebraMap \u211d A) (Real.log r)"}, {"line": "simp [log]", "tactic_state": "A : Type u_7\ninst\u271d\u00b2 : NormedRing A\ninst\u271d\u00b9 : StarRing A\ninst\u271d : NormedAlgebra \u211d A\nx\u271d : Sort u_8\nlog : x\u271d\nr : \u211d\n\u22a2 sorry () = (algebraMap \u211d A) (Real.log r)"}]}
{"declaration": "lemma posPart_zero : (0 : A)\u207a = 0 := by simp [posPart_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [NonUnitalRing A] [Module \u211d A] [SMulCommClass \u211d A A] [IsScalarTower \u211d A A]", "[StarRing A] [TopologicalSpace A]", "[NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module \u211d A\ninst\u271d\u2074 : SMulCommClass \u211d A A\ninst\u271d\u00b3 : IsScalarTower \u211d A A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint\n\u22a2 0\u207a = 0"}, {"line": "simp [posPart_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma negPart_zero : (0 : A)\u207b = 0 := by simp [negPart_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [NonUnitalRing A] [Module \u211d A] [SMulCommClass \u211d A A] [IsScalarTower \u211d A A]", "[StarRing A] [TopologicalSpace A]", "[NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : Module \u211d A\ninst\u271d\u2074 : SMulCommClass \u211d A A\ninst\u271d\u00b3 : IsScalarTower \u211d A A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint\n\u22a2 0\u207b = 0"}, {"line": "simp [negPart_def]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma negPart_smul {r : \u211d\u22650} {a : A} : (r \u2022 a)\u207b = r \u2022 a\u207b := by\n  simpa using posPart_smul (r := r) (a := -a)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/PosPart/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [NonUnitalRing A] [Module \u211d A] [SMulCommClass \u211d A A] [IsScalarTower \u211d A A]", "[StarRing A] [TopologicalSpace A]", "[NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint]", "[T2Space A]", "[StarModule \u211d A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2078 : NonUnitalRing A\ninst\u271d\u2077 : Module \u211d A\ninst\u271d\u2076 : SMulCommClass \u211d A A\ninst\u271d\u2075 : IsScalarTower \u211d A A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : NonUnitalContinuousFunctionalCalculus \u211d A IsSelfAdjoint\ninst\u271d\u00b9 : T2Space A\ninst\u271d : StarModule \u211d A\nr : NNReal\na : A\n\u22a2 (r \u2022 a)\u207b = r \u2022 a\u207b"}, {"line": "simpa using posPart_smul (r := r) (a := -a)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma nnrpow_zero {a : A} : a ^ (0 : \u211d\u22650) = 0 := by\n  simp [nnrpow_def, cfc\u2099_apply_of_not_map_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : NonUnitalRing A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : StarRing A\na : A\n\u22a2 sorry"}, {"line": "simp [nnrpow_def, cfc\u2099_apply_of_not_map_zero]", "tactic_state": "A : Type u_1\ninst\u271d\u00b3 : PartialOrder A\ninst\u271d\u00b2 : NonUnitalRing A\ninst\u271d\u00b9 : TopologicalSpace A\ninst\u271d : StarRing A\na : A\n\u22a2 sorry ()"}]}
{"declaration": "lemma zero_nnrpow {x : \u211d\u22650} : (0 : A) ^ x = 0 := by simp [nnrpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\n\u22a2 sorry"}, {"line": "simp [nnrpow_def]", "tactic_state": "x : NNReal\n\u22a2 sorry ()"}]}
{"declaration": "lemma nnrpow_nnrpow {a : A} {x y : \u211d\u22650} : (a ^ x) ^ y = a ^ (x * y) := by\n  by_cases ha : 0 \u2264 a\n  case pos =>\n    obtain (rfl | hx) := eq_zero_or_pos x <;> obtain (rfl | hy) := eq_zero_or_pos y\n    all_goals try simp\n    simp only [nnrpow_def]\n    simp only [NNReal.coe_mul]\n    rw [\u2190 cfc\u2099_comp _ _ a]\n    congr! 2 with u\n    ext\n    simp [Real.rpow_mul]\n  case neg =>\n    simp [nnrpow_def, cfc\u2099_apply_of_not_predicate a ha]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na : A\nx y : NNReal\n\u22a2 sorry"}, {"line": "by_cases ha : 0 \u2264 a", "tactic_state": "case pos\nA : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na : A\nx y : NNReal\nha : sorry\n\u22a2 sorry\n---\ncase neg\nA : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na : A\nx y : NNReal\nha : \u00acsorry\n\u22a2 sorry"}, {"line": "case pos =>\n    obtain (rfl | hx) := eq_zero_or_pos x <;> obtain (rfl | hy) := eq_zero_or_pos y\n    all_goals try simp\n    simp only [nnrpow_def]\n    simp only [NNReal.coe_mul]\n    rw [\u2190 cfc\u2099_comp _ _ a]\n    congr! 2 with u\n    ext\n    simp [Real.rpow_mul]", "tactic_state": "case neg\nA : Type u_1\ninst\u271d\u2075 : PartialOrder A\ninst\u271d\u2074 : NonUnitalRing A\ninst\u271d\u00b3 : TopologicalSpace A\ninst\u271d\u00b2 : StarRing A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\na : A\nx y : NNReal\nha : \u00acsorry\n\u22a2 sorry"}, {"line": "case neg =>\n    simp [nnrpow_def, cfc\u2099_apply_of_not_predicate a ha]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sqrt_zero : sqrt (0 : A) = 0 := by simp [sqrt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_5\nsqrt : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [sqrt]", "tactic_state": "x\u271d : Sort u_5\nsqrt : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma sqrt_nnrpow {a : A} {x : \u211d\u22650} : sqrt (a ^ x) = a ^ (x / 2) := by\n  simp [sqrt_eq_nnrpow, div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_1\ninst\u271d\u2077 : PartialOrder A\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : TopologicalSpace A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_5\nsqrt : x\u271d\na : A\nx : NNReal\n\u22a2 sorry"}, {"line": "simp [sqrt_eq_nnrpow, div_eq_mul_inv]", "tactic_state": "A : Type u_1\ninst\u271d\u2077 : PartialOrder A\ninst\u271d\u2076 : NonUnitalRing A\ninst\u271d\u2075 : TopologicalSpace A\ninst\u271d\u2074 : StarRing A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_5\nsqrt : x\u271d\na : A\nx : NNReal\n\u22a2 sorry ()"}]}
{"declaration": "lemma one_rpow {x : \u211d} : (1 : A) ^ x = (1 : A) := by simp [rpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "{A : Type*} [PartialOrder A] [Ring A] [StarRing A] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sorry"}, {"line": "simp [rpow_def]", "tactic_state": "x : \u211d\n\u22a2 sorry ()"}]}
{"declaration": "lemma zero_rpow {x : \u211d} (hx : x \u2260 0) : rpow (0 : A) x = 0 := by simp [rpow, NNReal.zero_rpow hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "{A : Type*} [PartialOrder A] [Ring A] [StarRing A] [TopologicalSpace A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_9\nrpow : x\u271d\nx : \u211d\nhx : x \u2260 0\n\u22a2 sorry = 0"}, {"line": "simp [rpow, NNReal.zero_rpow hx]", "tactic_state": "x\u271d : Sort u_9\nrpow : x\u271d\nx : \u211d\nhx : x \u2260 0\n\u22a2 sorry () = 0"}]}
{"declaration": "lemma sqrt_one : sqrt (1 : A) = 1 := by simp [sqrt_eq_cfc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal", "scoped ContinuousFunctionalCalculus"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "{A : Type*} [PartialOrder A] [Ring A] [StarRing A] [TopologicalSpace A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [Ring B] [StarRing B] [TopologicalSpace B]", "[IsTopologicalRing A] [T2Space A]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, Ring (C i)]", "[IsTopologicalRing A] [T2Space A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_12\nsqrt : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [sqrt_eq_cfc]", "tactic_state": "x\u271d : Sort u_12\nsqrt : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "lemma sqrt_rpow {a : A} {x : \u211d} (h : 0 \u2209 spectrum \u211d\u22650 a)\n    (hx : x \u2260 0) : sqrt (a ^ x) = a ^ (x / 2) := by\n  by_cases hnonneg : 0 \u2264 a\n  case pos =>\n    simp only [sqrt_eq_rpow]\n    simp only [div_eq_mul_inv]\n    simp only [one_mul]\n    simp only [rpow_rpow _ _ _ h hx]\n  case neg =>\n    simp [sqrt_eq_cfc, rpow_def, cfc_apply_of_not_predicate a hnonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal", "scoped ContinuousFunctionalCalculus"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "{A : Type*} [PartialOrder A] [Ring A] [StarRing A] [TopologicalSpace A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [Ring B] [StarRing B] [TopologicalSpace B]", "[IsTopologicalRing A] [T2Space A]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, Ring (C i)]", "[IsTopologicalRing A] [T2Space A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : \u211d\nh : 0 \u2209 sorry\nhx : x \u2260 0\n\u22a2 sorry"}, {"line": "by_cases hnonneg : 0 \u2264 a", "tactic_state": "case pos\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : \u211d\nh : 0 \u2209 sorry\nhx : x \u2260 0\nhnonneg : sorry\n\u22a2 sorry\n---\ncase neg\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : \u211d\nh : 0 \u2209 sorry\nhx : x \u2260 0\nhnonneg : \u00acsorry\n\u22a2 sorry"}, {"line": "case pos =>\n    simp only [sqrt_eq_rpow]\n    simp only [div_eq_mul_inv]\n    simp only [one_mul]\n    simp only [rpow_rpow _ _ _ h hx]", "tactic_state": "case neg\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : \u211d\nh : 0 \u2209 sorry\nhx : x \u2260 0\nhnonneg : \u00acsorry\n\u22a2 sorry"}, {"line": "case neg =>\n    simp [sqrt_eq_cfc, rpow_def, cfc_apply_of_not_predicate a hnonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sqrt_rpow_nnreal {a : A} {x : \u211d\u22650} : sqrt (a ^ (x : \u211d)) = a ^ (x / 2 : \u211d) := by\n  by_cases htriv : 0 \u2264 a\n  case neg => simp [sqrt_eq_cfc, rpow_def, cfc_apply_of_not_predicate a htriv]\n  case pos =>\n    cases eq_zero_or_pos x with\n    | inl hx => simp [hx, rpow_zero _ htriv]\n    | inr h\u2081 =>\n      have h\u2082 : (x : \u211d) / 2 = NNReal.toReal (x / 2) := by simp\n      have h\u2083 : 0 < x / 2 := by positivity\n      rw [\u2190 nnrpow_eq_rpow h\u2081]\n      rw [h\u2082]\n      rw [\u2190 nnrpow_eq_rpow h\u2083]\n      rw [sqrt_nnrpow (A := A)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/ContinuousFunctionalCalculus/Rpow/Basic.lean", "context": {"open": ["scoped NNReal", "scoped ContinuousFunctionalCalculus"], "variables": ["{A : Type*} [PartialOrder A] [NonUnitalRing A] [TopologicalSpace A] [StarRing A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [NonUnitalRing B] [TopologicalSpace B] [StarRing B]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, NonUnitalRing (C i)]", "{A : Type*} [PartialOrder A] [Ring A] [StarRing A] [TopologicalSpace A]", "[IsTopologicalRing A] [T2Space A]", "{B : Type*} [PartialOrder B] [Ring B] [StarRing B] [TopologicalSpace B]", "[IsTopologicalRing A] [T2Space A]", "{\u03b9 : Type*} {C : \u03b9 \u2192 Type*} [\u2200 i, PartialOrder (C i)] [\u2200 i, Ring (C i)]", "[IsTopologicalRing A] [T2Space A]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "A : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : NNReal\n\u22a2 sorry"}, {"line": "by_cases htriv : 0 \u2264 a", "tactic_state": "case pos\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : NNReal\nhtriv : sorry\n\u22a2 sorry\n---\ncase neg\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : NNReal\nhtriv : \u00acsorry\n\u22a2 sorry"}, {"line": "case neg => simp [sqrt_eq_cfc, rpow_def, cfc_apply_of_not_predicate a htriv]", "tactic_state": "case pos\nA : Type u_8\ninst\u271d\u2079 : PartialOrder A\ninst\u271d\u2078 : Ring A\ninst\u271d\u2077 : StarRing A\ninst\u271d\u2076 : TopologicalSpace A\ninst\u271d\u2075 : IsTopologicalRing A\ninst\u271d\u2074 : T2Space A\ninst\u271d\u00b3 : IsTopologicalRing A\ninst\u271d\u00b2 : T2Space A\ninst\u271d\u00b9 : IsTopologicalRing A\ninst\u271d : T2Space A\nx\u271d : Sort u_12\nsqrt : x\u271d\na : A\nx : NNReal\nhtriv : sorry\n\u22a2 sorry"}, {"line": "case pos =>\n    cases eq_zero_or_pos x with\n    | inl hx => simp [hx, rpow_zero _ htriv]\n    | inr h\u2081 =>\n      have h\u2082 : (x : \u211d) / 2 = NNReal.toReal (x / 2) := by simp\n      have h\u2083 : 0 < x / 2 := by positivity\n      rw [\u2190 nnrpow_eq_rpow h\u2081]\n      rw [h\u2082]\n      rw [\u2190 nnrpow_eq_rpow h\u2083]\n      rw [sqrt_nnrpow (A := A)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u211d_add_two {s : \u2102} (hs : s \u2260 0) : Gamma\u211d (s + 2) = Gamma\u211d s * s / 2 / \u03c0 := by\n  rw [Gamma\u211d_def]\n  rw [Gamma\u211d_def]\n  rw [neg_div]\n  rw [add_div]\n  rw [neg_add]\n  rw [div_self two_ne_zero]\n  rw [Gamma_add_one _ (div_ne_zero hs two_ne_zero)]\n  rw [cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero)]\n  rw [cpow_neg_one]\n  field_simp [pi_ne_zero]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 (s + 2).Gamma\u211d = s.Gamma\u211d * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma\u211d_def]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s + 2) / 2) * Complex.Gamma ((s + 2) / 2) = s.Gamma\u211d * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma\u211d_def]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s + 2) / 2) * Complex.Gamma ((s + 2) / 2) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [neg_div]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-((s + 2) / 2)) * Complex.Gamma ((s + 2) / 2) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [add_div]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2 + 2 / 2)) * Complex.Gamma (s / 2 + 2 / 2) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [neg_add]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2) + -(2 / 2)) * Complex.Gamma (s / 2 + 2 / 2) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [div_self two_ne_zero]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2) + -1) * Complex.Gamma (s / 2 + 1) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma_add_one _ (div_ne_zero hs two_ne_zero)]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2) + -1) * (s / 2 * Complex.Gamma (s / 2)) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [cpow_add _ _ (ofReal_ne_zero.mpr pi_ne_zero)]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2)) * \u2191Real.pi ^ (-1) * (s / 2 * Complex.Gamma (s / 2)) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "rw [cpow_neg_one]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-(s / 2)) * (\u2191Real.pi)\u207b\u00b9 * (s / 2 * Complex.Gamma (s / 2)) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s / 2 / \u2191Real.pi"}, {"line": "field_simp [pi_ne_zero]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 \u2191Real.pi ^ (-s / 2) * (s * Complex.Gamma (s / 2)) * (2 * \u2191Real.pi) =\n    \u2191Real.pi ^ (-s / 2) * Complex.Gamma (s / 2) * s * (\u2191Real.pi * 2)"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u2102_add_one {s : \u2102} (hs : s \u2260 0) : Gamma\u2102 (s + 1) = Gamma\u2102 s * s / 2 / \u03c0 := by\n  rw [Gamma\u2102_def]\n  rw [Gamma\u2102_def]\n  rw [Gamma_add_one _ hs]\n  rw [neg_add]\n  rw [cpow_add _ _ (mul_ne_zero two_ne_zero (ofReal_ne_zero.mpr pi_ne_zero))]\n  rw [cpow_neg_one]\n  field_simp [pi_ne_zero]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 (s + 1).Gamma\u2102 = s.Gamma\u2102 * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma\u2102_def]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * (2 * \u2191Real.pi) ^ (-(s + 1)) * Complex.Gamma (s + 1) = s.Gamma\u2102 * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma\u2102_def]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * (2 * \u2191Real.pi) ^ (-(s + 1)) * Complex.Gamma (s + 1) =\n    2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s / 2 / \u2191Real.pi"}, {"line": "rw [Gamma_add_one _ hs]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * (2 * \u2191Real.pi) ^ (-(s + 1)) * (s * Complex.Gamma s) =\n    2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s / 2 / \u2191Real.pi"}, {"line": "rw [neg_add]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * (2 * \u2191Real.pi) ^ (-s + -1) * (s * Complex.Gamma s) =\n    2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s / 2 / \u2191Real.pi"}, {"line": "rw [cpow_add _ _ (mul_ne_zero two_ne_zero (ofReal_ne_zero.mpr pi_ne_zero))]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * ((2 * \u2191Real.pi) ^ (-s) * (2 * \u2191Real.pi) ^ (-1)) * (s * Complex.Gamma s) =\n    2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s / 2 / \u2191Real.pi"}, {"line": "rw [cpow_neg_one]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * ((2 * \u2191Real.pi) ^ (-s) * (2 * \u2191Real.pi)\u207b\u00b9) * (s * Complex.Gamma s) =\n    2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s / 2 / \u2191Real.pi"}, {"line": "field_simp [pi_ne_zero]", "tactic_state": "s : \u2102\nhs : s \u2260 0\n\u22a2 2 * (2 * \u2191Real.pi) ^ (-s) * (s * Complex.Gamma s) = 2 * (2 * \u2191Real.pi) ^ (-s) * Complex.Gamma s * s"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u211d_ne_zero_of_re_pos {s : \u2102} (hs : 0 < re s) : Gamma\u211d s \u2260 0 := by\n  apply mul_ne_zero\n  \u00b7 simp [pi_ne_zero]\n  \u00b7 apply Gamma_ne_zero_of_re_pos\n    rw [div_ofNat_re]\n    exact div_pos hs two_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : 0 < s.re\n\u22a2 s.Gamma\u211d \u2260 0"}, {"line": "apply mul_ne_zero", "tactic_state": "case ha\ns : \u2102\nhs : 0 < s.re\n\u22a2 \u2191Real.pi ^ (-s / 2) \u2260 0\n---\ncase hb\ns : \u2102\nhs : 0 < s.re\n\u22a2 Complex.Gamma (s / 2) \u2260 0"}, {"line": "\u00b7 simp [pi_ne_zero]", "tactic_state": "case hb\ns : \u2102\nhs : 0 < s.re\n\u22a2 Complex.Gamma (s / 2) \u2260 0"}, {"line": "\u00b7 apply Gamma_ne_zero_of_re_pos\n    rw [div_ofNat_re]\n    exact div_pos hs two_pos", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u211d_eq_zero_iff {s : \u2102} : Gamma\u211d s = 0 \u2194 \u2203 n : \u2115, s = -(2 * n) := by\n  simp [Gamma\u211d_def, Complex.Gamma_eq_zero_iff, pi_ne_zero, div_eq_iff (two_ne_zero' \u2102), mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\n\u22a2 s.Gamma\u211d = 0 \u2194 \u2203 n, s = -(2 * \u2191n)"}, {"line": "simp [Gamma\u211d_def, Complex.Gamma_eq_zero_iff, pi_ne_zero, div_eq_iff (two_ne_zero' \u2102), mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u211d_one : Gamma\u211d 1 = 1 := by\n  rw [Gamma\u211d_def]\n  rw [Complex.Gamma_one_half_eq]\n  simp [neg_div, cpow_neg, inv_mul_cancel, pi_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma\u211d 1 = 1"}, {"line": "rw [Gamma\u211d_def]", "tactic_state": "\u22a2 \u2191Real.pi ^ (-1 / 2) * Complex.Gamma (1 / 2) = 1"}, {"line": "rw [Complex.Gamma_one_half_eq]", "tactic_state": "\u22a2 \u2191Real.pi ^ (-1 / 2) * \u2191Real.pi ^ (1 / 2) = 1"}, {"line": "simp [neg_div, cpow_neg, inv_mul_cancel, pi_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Gamma\u2102_one : Gamma\u2102 1 = 1 / \u03c0 := by\n  rw [Gamma\u2102_def]\n  rw [cpow_neg_one]\n  rw [Complex.Gamma_one]\n  field_simp [pi_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma\u2102 1 = 1 / \u2191Real.pi"}, {"line": "rw [Gamma\u2102_def]", "tactic_state": "\u22a2 2 * (2 * \u2191Real.pi) ^ (-1) * Complex.Gamma 1 = 1 / \u2191Real.pi"}, {"line": "rw [cpow_neg_one]", "tactic_state": "\u22a2 2 * (2 * \u2191Real.pi)\u207b\u00b9 * Complex.Gamma 1 = 1 / \u2191Real.pi"}, {"line": "rw [Complex.Gamma_one]", "tactic_state": "\u22a2 2 * (2 * \u2191Real.pi)\u207b\u00b9 * 1 = 1 / \u2191Real.pi"}, {"line": "field_simp [pi_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiable_Gamma\u211d_inv : Differentiable \u2102 (fun s \u21a6 (Gamma\u211d s)\u207b\u00b9) := by\n  conv => enter [2, s]; rw [Gamma\u211d, mul_inv]\n  refine Differentiable.mul (fun s \u21a6 .inv ?_ (by simp [pi_ne_zero])) ?_\n  \u00b7 refine ((differentiableAt_id.neg.div_const (2 : \u2102)).const_cpow ?_)\n    exact Or.inl (ofReal_ne_zero.mpr pi_ne_zero)\n  \u00b7 exact differentiable_one_div_Gamma.comp (differentiable_id.div_const _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Differentiable \u2102 fun s => s.Gamma\u211d\u207b\u00b9"}, {"line": "conv => enter [2, s]; rw [Gamma\u211d, mul_inv]", "tactic_state": "\u22a2 Differentiable \u2102 fun s => (\u2191Real.pi ^ (-s / 2))\u207b\u00b9 * (Complex.Gamma (s / 2))\u207b\u00b9"}, {"line": "refine Differentiable.mul (fun s \u21a6 .inv ?_ (by simp [pi_ne_zero])) ?_", "tactic_state": "case refine_1\ns : \u2102\n\u22a2 DifferentiableAt \u2102 (fun s => \u2191Real.pi ^ (-s / 2)) s\n---\ncase refine_2\n\u22a2 Differentiable \u2102 fun s => (Complex.Gamma (s / 2))\u207b\u00b9"}, {"line": "\u00b7 refine ((differentiableAt_id.neg.div_const (2 : \u2102)).const_cpow ?_)\n    exact Or.inl (ofReal_ne_zero.mpr pi_ne_zero)", "tactic_state": "case refine_2\n\u22a2 Differentiable \u2102 fun s => (Complex.Gamma (s / 2))\u207b\u00b9"}, {"line": "\u00b7 exact differentiable_one_div_Gamma.comp (differentiable_id.div_const _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma inv_Gamma\u211d_one_sub {s : \u2102} (hs : \u2200 (n : \u2115), s \u2260 -n) :\n    (Gamma\u211d (1 - s))\u207b\u00b9 = Gamma\u2102 s * cos (\u03c0 * s / 2) * (Gamma\u211d s)\u207b\u00b9 := by\n  have h1 : Gamma\u211d s \u2260 0 := by\n    rw [Ne]\n    rw [Gamma\u211d_eq_zero_iff]\n    rw [not_exists]\n    intro n h\n    specialize hs (2 * n)\n    simp_all\n  have h2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1) := by\n    intro n h\n    specialize hs (2 * n + 1)\n    simp_all\n  rw [\u2190 Gamma\u211d_div_Gamma\u211d_one_sub h2]\n  rw [\u2190 div_eq_mul_inv]\n  rw [div_right_comm]\n  rw [div_self h1]\n  rw [one_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deligne.lean", "context": {"open": ["Filter Topology Asymptotics Real Set MeasureTheory", "Complex hiding abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u2102 * Complex.cos (\u2191Real.pi * s / 2) * s.Gamma\u211d\u207b\u00b9"}, {"line": "have h1 : Gamma\u211d s \u2260 0 := sorry", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u2102 * Complex.cos (\u2191Real.pi * s / 2) * s.Gamma\u211d\u207b\u00b9"}, {"line": "have h2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1) := sorry", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\nh2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1)\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u2102 * Complex.cos (\u2191Real.pi * s / 2) * s.Gamma\u211d\u207b\u00b9"}, {"line": "rw [\u2190 Gamma\u211d_div_Gamma\u211d_one_sub h2]", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\nh2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1)\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u211d / (1 - s).Gamma\u211d * s.Gamma\u211d\u207b\u00b9"}, {"line": "rw [\u2190 div_eq_mul_inv]", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\nh2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1)\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u211d / (1 - s).Gamma\u211d / s.Gamma\u211d"}, {"line": "rw [div_right_comm]", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\nh2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1)\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = s.Gamma\u211d / s.Gamma\u211d / (1 - s).Gamma\u211d"}, {"line": "rw [div_self h1]", "tactic_state": "s : \u2102\nhs : \u2200 (n : \u2115), s \u2260 -\u2191n\nh1 : s.Gamma\u211d \u2260 0\nh2 : \u2200 (n : \u2115), s \u2260 -(2 * \u2191n + 1)\n\u22a2 (1 - s).Gamma\u211d\u207b\u00b9 = 1 / (1 - s).Gamma\u211d"}, {"line": "rw [one_div]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_integrand_isLittleO (s : \u211d) :\n    (fun x : \u211d => exp (-x) * x ^ s) =o[atTop] fun x : \u211d => exp (-(1 / 2) * x) := by\n  refine isLittleO_of_tendsto (fun x hx => ?_) ?_\n  \u00b7 exfalso; exact (exp_pos (-(1 / 2) * x)).ne' hx\n  have : (fun x : \u211d => exp (-x) * x ^ s / exp (-(1 / 2) * x)) =\n      (fun x : \u211d => exp (1 / 2 * x) / x ^ s)\u207b\u00b9 := by\n    ext1 x\n    field_simp [exp_ne_zero, exp_neg, \u2190 Real.exp_add]\n    left\n    ring\n  rw [this]\n  exact (tendsto_exp_mul_div_rpow_atTop s (1 / 2) one_half_pos).inv_tendsto_atTop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 (fun x => exp (-x) * x ^ s) =o[atTop] fun x => exp (-(1 / 2) * x)"}, {"line": "refine isLittleO_of_tendsto (fun x hx => ?_) ?_", "tactic_state": "case refine_1\ns x : \u211d\nhx : exp (-(1 / 2) * x) = 0\n\u22a2 exp (-x) * x ^ s = 0\n---\ncase refine_2\ns : \u211d\n\u22a2 Tendsto (fun x => exp (-x) * x ^ s / exp (-(1 / 2) * x)) atTop (nhds 0)"}, {"line": "\u00b7 exfalso; exact (exp_pos (-(1 / 2) * x)).ne' hx", "tactic_state": "case refine_2\ns : \u211d\n\u22a2 Tendsto (fun x => exp (-x) * x ^ s / exp (-(1 / 2) * x)) atTop (nhds 0)"}, {"line": "have : (fun x : \u211d => exp (-x) * x ^ s / exp (-(1 / 2) * x)) =\n      (fun x : \u211d => exp (1 / 2 * x) / x ^ s)\u207b\u00b9 := by\n    ext1 x\n    field_simp [exp_ne_zero, exp_neg, \u2190 Real.exp_add]\n    left\n    ring", "tactic_state": "case refine_2\ns : \u211d\nthis : (fun x => exp (-x) * x ^ s / exp (-(1 / 2) * x)) = (fun x => exp (1 / 2 * x) / x ^ s)\u207b\u00b9\n\u22a2 Tendsto (fun x => exp (-x) * x ^ s / exp (-(1 / 2) * x)) atTop (nhds 0)"}, {"line": "rw [this]", "tactic_state": "case refine_2\ns : \u211d\nthis : (fun x => exp (-x) * x ^ s / exp (-(1 / 2) * x)) = (fun x => exp (1 / 2 * x) / x ^ s)\u207b\u00b9\n\u22a2 Tendsto (fun x => exp (1 / 2 * x) / x ^ s)\u207b\u00b9 atTop (nhds 0)"}, {"line": "exact (tendsto_exp_mul_div_rpow_atTop s (1 / 2) one_half_pos).inv_tendsto_atTop", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem Gamma_integrand_intervalIntegrable (s : \u2102) {X : \u211d} (hs : 0 < s.re) (hX : 0 \u2264 X) :\n    IntervalIntegrable (fun x => (-x).exp * x ^ (s - 1) : \u211d \u2192 \u2102) volume 0 X := by\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hX]\n  exact IntegrableOn.mono_set (GammaIntegral_convergent hs) Ioc_subset_Ioi_self\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nX : \u211d\nhs : 0 < s.re\nhX : 0 \u2264 X\n\u22a2 IntervalIntegrable (fun x => \u2191(exp (-x)) * \u2191x ^ (s - 1)) volume 0 X"}, {"line": "rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hX]", "tactic_state": "s : \u2102\nX : \u211d\nhs : 0 < s.re\nhX : 0 \u2264 X\n\u22a2 IntegrableOn (fun x => \u2191(exp (-x)) * \u2191x ^ (s - 1)) (Ioc 0 X) volume"}, {"line": "exact IntegrableOn.mono_set (GammaIntegral_convergent hs) Ioc_subset_Ioi_self", "tactic_state": "No Goals!"}]}
{"declaration": "private theorem Gamma_integrand_deriv_integrable_B {s : \u2102} (hs : 0 < s.re) {Y : \u211d} (hY : 0 \u2264 Y) :\n    IntervalIntegrable (fun x : \u211d => (-x).exp * (s * x ^ (s - 1)) : \u211d \u2192 \u2102) volume 0 Y := by\n  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : \u211d \u2192 \u2102) =\n      (fun x => s * ((-x).exp * x ^ (s - 1)) : \u211d \u2192 \u2102) := by ext1; ring\n  rw [this]\n  rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hY]\n  constructor\n  \u00b7 refine (continuousOn_const.mul ?_).aestronglyMeasurable measurableSet_Ioc\n    apply (continuous_ofReal.comp continuous_neg.rexp).continuousOn.mul\n    apply continuousOn_of_forall_continuousAt\n    intro x hx\n    refine (?_ : ContinuousAt (fun x : \u2102 => x ^ (s - 1)) _).comp continuous_ofReal.continuousAt\n    exact continuousAt_cpow_const <| ofReal_mem_slitPlane.2 hx.1\n  rw [\u2190 hasFiniteIntegral_norm_iff]\n  simp_rw [norm_mul]\n  refine (((Real.GammaIntegral_convergent hs).mono_set\n    Ioc_subset_Ioi_self).hasFiniteIntegral.congr ?_).const_mul _\n  rw [EventuallyEq]\n  rw [ae_restrict_iff']\n  \u00b7 filter_upwards with x hx\n    rw [Complex.norm_of_nonneg (exp_pos _).le]\n    rw [norm_cpow_eq_rpow_re_of_pos hx.1]\n    simp\n  \u00b7 exact measurableSet_Ioc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\n\u22a2 IntervalIntegrable (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) volume 0 Y"}, {"line": "have : (fun x => (-x).exp * (s * x ^ (s - 1)) : \u211d \u2192 \u2102) =\n      (fun x => s * ((-x).exp * x ^ (s - 1)) : \u211d \u2192 \u2102) := by ext1; ring", "tactic_state": "s : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 IntervalIntegrable (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) volume 0 Y"}, {"line": "rw [this]", "tactic_state": "s : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 IntervalIntegrable (fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))) volume 0 Y"}, {"line": "rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hY]", "tactic_state": "s : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 IntegrableOn (fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))) (Ioc 0 Y) volume"}, {"line": "constructor", "tactic_state": "case left\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 AEStronglyMeasurable (fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))) (volume.restrict (Ioc 0 Y))\n---\ncase right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 HasFiniteIntegral (fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))) (volume.restrict (Ioc 0 Y))"}, {"line": "\u00b7 refine (continuousOn_const.mul ?_).aestronglyMeasurable measurableSet_Ioc\n    apply (continuous_ofReal.comp continuous_neg.rexp).continuousOn.mul\n    apply continuousOn_of_forall_continuousAt\n    intro x hx\n    refine (?_ : ContinuousAt (fun x : \u2102 => x ^ (s - 1)) _).comp continuous_ofReal.continuousAt\n    exact continuousAt_cpow_const <| ofReal_mem_slitPlane.2 hx.1", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 HasFiniteIntegral (fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))) (volume.restrict (Ioc 0 Y))"}, {"line": "rw [\u2190 hasFiniteIntegral_norm_iff]", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 HasFiniteIntegral (fun a => \u2016s * (\u2191(exp (-a)) * \u2191a ^ (s - 1))\u2016) (volume.restrict (Ioc 0 Y))"}, {"line": "simp_rw [norm_mul]", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 HasFiniteIntegral (fun a => \u2016s\u2016 * (\u2016\u2191(exp (-a))\u2016 * \u2016\u2191a ^ (s - 1)\u2016)) (volume.restrict (Ioc 0 Y))"}, {"line": "refine (((Real.GammaIntegral_convergent hs).mono_set\n    Ioc_subset_Ioi_self).hasFiniteIntegral.congr ?_).const_mul _", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 (fun x => exp (-x) * x ^ (s.re - 1)) =\u1da0[ae (volume.restrict (Ioc 0 Y))] fun a => \u2016\u2191(exp (-a))\u2016 * \u2016\u2191a ^ (s - 1)\u2016"}, {"line": "rw [EventuallyEq]", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 \u2200\u1d50 (x : \u211d) \u2202volume.restrict (Ioc 0 Y), exp (-x) * x ^ (s.re - 1) = \u2016\u2191(exp (-x))\u2016 * \u2016\u2191x ^ (s - 1)\u2016"}, {"line": "rw [ae_restrict_iff']", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 \u2200\u1d50 (x : \u211d), x \u2208 Ioc 0 Y \u2192 exp (-x) * x ^ (s.re - 1) = \u2016\u2191(exp (-x))\u2016 * \u2016\u2191x ^ (s - 1)\u2016\n---\ncase right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 MeasurableSet (Ioc 0 Y)"}, {"line": "\u00b7 filter_upwards with x hx\n    rw [Complex.norm_of_nonneg (exp_pos _).le]\n    rw [norm_cpow_eq_rpow_re_of_pos hx.1]\n    simp", "tactic_state": "case right\ns : \u2102\nhs : 0 < s.re\nY : \u211d\nhY : 0 \u2264 Y\nthis : (fun x => \u2191(exp (-x)) * (s * \u2191x ^ (s - 1))) = fun x => s * (\u2191(exp (-x)) * \u2191x ^ (s - 1))\n\u22a2 MeasurableSet (Ioc 0 Y)"}, {"line": "\u00b7 exact measurableSet_Ioc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_one : Gamma 1 = 1 := by rw [Gamma_eq_integral] <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma 1 = 1"}, {"line": "rw [Gamma_eq_integral] <;> simp", "tactic_state": "\u22a2 \u222b (x : \u211d) in Ioi 0, exp (-x) = 1"}]}
{"declaration": "theorem Gamma_add_one {s : \u211d} (hs : s \u2260 0) : Gamma (s + 1) = s * Gamma s := by\n  simp_rw [Gamma]\n  rw [Complex.ofReal_add]\n  rw [Complex.ofReal_one]\n  rw [Complex.Gamma_add_one]\n  rw [Complex.re_ofReal_mul]\n  rwa [Complex.ofReal_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\nhs : s \u2260 0\n\u22a2 Gamma (s + 1) = s * Gamma s"}, {"line": "simp_rw [Gamma]", "tactic_state": "s : \u211d\nhs : s \u2260 0\n\u22a2 (Complex.Gamma \u2191(s + 1)).re = s * (Complex.Gamma \u2191s).re"}, {"line": "rw [Complex.ofReal_add]", "tactic_state": "s : \u211d\nhs : s \u2260 0\n\u22a2 (Complex.Gamma (\u2191s + \u21911)).re = s * (Complex.Gamma \u2191s).re"}, {"line": "rw [Complex.ofReal_one]", "tactic_state": "s : \u211d\nhs : s \u2260 0\n\u22a2 (Complex.Gamma (\u2191s + 1)).re = s * (Complex.Gamma \u2191s).re"}, {"line": "rw [Complex.Gamma_add_one]", "tactic_state": "s : \u211d\nhs : s \u2260 0\n\u22a2 (\u2191s * Complex.Gamma \u2191s).re = s * (Complex.Gamma \u2191s).re\n---\ncase h2\ns : \u211d\nhs : s \u2260 0\n\u22a2 \u2191s \u2260 0"}, {"line": "rw [Complex.re_ofReal_mul]", "tactic_state": "case h2\ns : \u211d\nhs : s \u2260 0\n\u22a2 \u2191s \u2260 0"}, {"line": "rwa [Complex.ofReal_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_one : Gamma 1 = 1 := by\n  rw [Gamma]\n  rw [Complex.ofReal_one]\n  rw [Complex.Gamma_one]\n  rw [Complex.one_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma 1 = 1"}, {"line": "rw [Gamma]", "tactic_state": "\u22a2 (Complex.Gamma \u21911).re = 1"}, {"line": "rw [Complex.ofReal_one]", "tactic_state": "\u22a2 (Complex.Gamma 1).re = 1"}, {"line": "rw [Complex.Gamma_one]", "tactic_state": "\u22a2 Complex.re 1 = 1"}, {"line": "rw [Complex.one_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_nat_eq_factorial (n : \u2115) : Gamma (n + 1) = n ! := by\n  rw [Gamma]\n  rw [Complex.ofReal_add]\n  rw [Complex.ofReal_natCast]\n  rw [Complex.ofReal_one]\n  rw [Complex.Gamma_nat_eq_factorial]\n  rw [\u2190 Complex.ofReal_natCast]\n  rw [Complex.ofReal_re]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Gamma (\u2191n + 1) = \u2191n.factorial"}, {"line": "rw [Gamma]", "tactic_state": "n : \u2115\n\u22a2 (Complex.Gamma \u2191(\u2191n + 1)).re = \u2191n.factorial"}, {"line": "rw [Complex.ofReal_add]", "tactic_state": "n : \u2115\n\u22a2 (Complex.Gamma (\u2191\u2191n + \u21911)).re = \u2191n.factorial"}, {"line": "rw [Complex.ofReal_natCast]", "tactic_state": "n : \u2115\n\u22a2 (Complex.Gamma (\u2191n + \u21911)).re = \u2191n.factorial"}, {"line": "rw [Complex.ofReal_one]", "tactic_state": "n : \u2115\n\u22a2 (Complex.Gamma (\u2191n + 1)).re = \u2191n.factorial"}, {"line": "rw [Complex.Gamma_nat_eq_factorial]", "tactic_state": "n : \u2115\n\u22a2 (\u2191n.factorial).re = \u2191n.factorial"}, {"line": "rw [\u2190 Complex.ofReal_natCast]", "tactic_state": "n : \u2115\n\u22a2 (\u2191\u2191n.factorial).re = \u2191n.factorial"}, {"line": "rw [Complex.ofReal_re]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_zero : Gamma 0 = 0 := by\n  simpa only [\u2190 Complex.ofReal_zero,Complex.Gamma_ofReal,Complex.ofReal_inj] using\n    Complex.Gamma_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma 0 = 0"}, {"line": "simpa only [\u2190 Complex.ofReal_zero,Complex.Gamma_ofReal,Complex.ofReal_inj] using\n    Complex.Gamma_zero", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_neg_nat_eq_zero (n : \u2115) : Gamma (-n) = 0 := by\n  simpa only [\u2190 Complex.ofReal_natCast,\u2190 Complex.ofReal_neg,Complex.Gamma_ofReal,Complex.ofReal_eq_zero] using Complex.Gamma_neg_nat_eq_zero n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 Gamma (-\u2191n) = 0"}, {"line": "simpa only [\u2190 Complex.ofReal_natCast,\u2190 Complex.ofReal_neg,Complex.Gamma_ofReal,Complex.ofReal_eq_zero] using Complex.Gamma_neg_nat_eq_zero n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_nonneg_of_nonneg {s : \u211d} (hs : 0 \u2264 s) : 0 \u2264 Gamma s := by\n  obtain rfl | h := eq_or_lt_of_le hs\n  \u00b7 rw [Gamma_zero]\n  \u00b7 exact (Gamma_pos_of_pos h).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Basic.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory Asymptotics", "scoped Nat Topology ComplexConjugate"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\nhs : 0 \u2264 s\n\u22a2 0 \u2264 Gamma s"}, {"line": "obtain rfl | h := eq_or_lt_of_le hs", "tactic_state": "case inl\nhs : 0 \u2264 0\n\u22a2 0 \u2264 Gamma 0\n---\ncase inr\ns : \u211d\nhs : 0 \u2264 s\nh : 0 < s\n\u22a2 0 \u2264 Gamma s"}, {"line": "\u00b7 rw [Gamma_zero]", "tactic_state": "case inr\ns : \u211d\nhs : 0 \u2264 s\nh : 0 < s\n\u22a2 0 \u2264 Gamma s"}, {"line": "\u00b7 exact (Gamma_pos_of_pos h).le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GammaSeq_tendsto_Gamma (s : \u2102) : Tendsto (GammaSeq s) atTop (\ud835\udcdd <| Gamma s) := by\n  suffices \u2200 m : \u2115, -\u2191m < re s \u2192 Tendsto (GammaSeq s) atTop (\ud835\udcdd <| GammaAux m s) by\n    rw [Gamma]\n    apply this\n    rw [neg_lt]\n    rcases lt_or_le 0 (re s) with (hs | hs)\n    \u00b7 exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)\n    \u00b7 refine (Nat.lt_floor_add_one _).trans_le ?_\n      rw [sub_eq_neg_add]\n      rw [Nat.floor_add_one (neg_nonneg.mpr hs)]\n      rw [Nat.cast_add_one]\n  intro m\n  induction' m with m IH generalizing s\n  \u00b7 -- Base case: `0 < re s`, so Gamma is given by the integral formula\n    intro hs\n    rw [Nat.cast_zero] at hs\n    rw [neg_zero] at hs\n    rw [\u2190 Gamma_eq_GammaAux]\n    \u00b7 refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)\n      refine (eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)\n      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm\n    \u00b7 rwa [Nat.cast_zero, neg_lt_zero]\n  \u00b7 -- Induction step: use recurrence formulae in `s` for Gamma and GammaSeq\n    intro hs\n    rw [Nat.cast_succ] at hs\n    rw [neg_add] at hs\n    rw [\u2190 sub_eq_add_neg] at hs\n    rw [sub_lt_iff_lt_add] at hs\n    rw [\u2190 one_re] at hs\n    rw [\u2190 add_re] at hs\n    rw [GammaAux]\n    have := @Tendsto.congr' _ _ _ ?_ _ _\n      ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)) ((IH _ hs).div_const s)\n    pick_goal 3; \u00b7 exact GammaSeq_add_one_left s hn -- doesn't work if inlined?\n    conv at this => arg 1; intro n; rw [mul_comm]\n    rwa [\u2190 mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' \u2102)] at this\n    simp_rw [add_assoc]\n    exact tendsto_natCast_div_add_atTop (1 + s)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory", "scoped Nat Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\n\u22a2 Tendsto sorry.GammaSeq atTop (nhds (Gamma sorry))"}, {"line": "suffices \u2200 m : \u2115, -\u2191m < re s \u2192 Tendsto (GammaSeq s) atTop (\ud835\udcdd <| GammaAux m s) by\n    rw [Gamma]\n    apply this\n    rw [neg_lt]\n    rcases lt_or_le 0 (re s) with (hs | hs)\n    \u00b7 exact (neg_neg_of_pos hs).trans_le (Nat.cast_nonneg _)\n    \u00b7 refine (Nat.lt_floor_add_one _).trans_le ?_\n      rw [sub_eq_neg_add]\n      rw [Nat.floor_add_one (neg_nonneg.mpr hs)]\n      rw [Nat.cast_add_one]", "tactic_state": "case refine_2\ns : \u2102\n\u22a2 \u2200 (m : \u2115), -m < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry\n---\ncase refine_1\ns : \u2102\n\u22a2 \u2115 \u2192 Neg \u2115"}, {"line": "intro m", "tactic_state": "case refine_2\ns : \u2102\nm : \u2115\n\u22a2 -m < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry\n---\ncase refine_1\ns : \u2102\n\u22a2 \u2115 \u2192 Neg \u2115"}, {"line": "induction' m with m IH generalizing s", "tactic_state": "case refine_2.zero\ns : \u2102\n\u22a2 -0 < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry\n---\ncase refine_2.succ\nm : \u2115\nIH : \u2200 (s : \u2102), -m < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry\ns : \u2102\n\u22a2 -(m + 1) < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry"}, {"line": "\u00b7 -- Base case: `0 < re s`, so Gamma is given by the integral formula\n    intro hs\n    rw [Nat.cast_zero] at hs\n    rw [neg_zero] at hs\n    rw [\u2190 Gamma_eq_GammaAux]\n    \u00b7 refine Tendsto.congr' ?_ (approx_Gamma_integral_tendsto_Gamma_integral hs)\n      refine (eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)\n      exact (GammaSeq_eq_approx_Gamma_integral hs hn).symm\n    \u00b7 rwa [Nat.cast_zero, neg_lt_zero]", "tactic_state": "case refine_2.succ\nm : \u2115\nIH : \u2200 (s : \u2102), -m < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry\ns : \u2102\n\u22a2 -(m + 1) < sorry \u2192 Tendsto sorry.GammaSeq atTop sorry"}, {"line": "\u00b7 -- Induction step: use recurrence formulae in `s` for Gamma and GammaSeq\n    intro hs\n    rw [Nat.cast_succ] at hs\n    rw [neg_add] at hs\n    rw [\u2190 sub_eq_add_neg] at hs\n    rw [sub_lt_iff_lt_add] at hs\n    rw [\u2190 one_re] at hs\n    rw [\u2190 add_re] at hs\n    rw [GammaAux]\n    have := @Tendsto.congr' _ _ _ ?_ _ _\n      ((eventually_ne_atTop 0).mp (Eventually.of_forall fun n hn => ?_)) ((IH _ hs).div_const s)\n    pick_goal 3; \u00b7 exact GammaSeq_add_one_left s hn -- doesn't work if inlined?\n    conv at this => arg 1; intro n; rw [mul_comm]\n    rwa [\u2190 mul_one (GammaAux m (s + 1) / s), tendsto_mul_iff_of_ne_zero _ (one_ne_zero' \u2102)] at this\n    simp_rw [add_assoc]\n    exact tendsto_natCast_div_add_atTop (1 + s)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_eq_zero_iff (s : \u2102) : Gamma s = 0 \u2194 \u2203 m : \u2115, s = -m := by\n  constructor\n  \u00b7 contrapose!; exact Gamma_ne_zero\n  \u00b7 rintro \u27e8m, rfl\u27e9; exact Gamma_neg_nat_eq_zero m\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory", "scoped Nat Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\n\u22a2 Gamma sorry = 0 \u2194 \u2203 m, s = -\u2191m"}, {"line": "constructor", "tactic_state": "case mp\ns : \u2102\n\u22a2 Gamma sorry = 0 \u2192 \u2203 m, s = -\u2191m\n---\ncase mpr\ns : \u2102\n\u22a2 (\u2203 m, s = -\u2191m) \u2192 Gamma sorry = 0"}, {"line": "\u00b7 contrapose!; exact Gamma_ne_zero", "tactic_state": "case mpr\ns : \u2102\n\u22a2 (\u2203 m, s = -\u2191m) \u2192 Gamma sorry = 0"}, {"line": "\u00b7 rintro \u27e8m, rfl\u27e9; exact Gamma_neg_nat_eq_zero m", "tactic_state": "No Goals!"}]}
{"declaration": "theorem GammaSeq_tendsto_Gamma (s : \u211d) : Tendsto (GammaSeq s) atTop (\ud835\udcdd <| Gamma s) := by\n  suffices Tendsto ((\u2191) \u2218 GammaSeq s : \u2115 \u2192 \u2102) atTop (\ud835\udcdd <| Complex.Gamma s) by\n    exact (Complex.continuous_re.tendsto (Complex.Gamma \u2191s)).comp this\n  convert Complex.GammaSeq_tendsto_Gamma s\n  ext1 n\n  dsimp only [GammaSeq, Function.comp_apply, Complex.GammaSeq]\n  push_cast\n  rw [Complex.ofReal_cpow n.cast_nonneg]\n  rw [Complex.ofReal_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory", "scoped Nat Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 Tendsto s.GammaSeq atTop (nhds (Gamma s))"}, {"line": "suffices Tendsto ((\u2191) \u2218 GammaSeq s : \u2115 \u2192 \u2102) atTop (\ud835\udcdd <| Complex.Gamma s) by\n    exact (Complex.continuous_re.tendsto (Complex.Gamma \u2191s)).comp this", "tactic_state": "s : \u211d\n\u22a2 Tendsto (Complex.ofReal \u2218 s.GammaSeq) atTop sorry"}, {"line": "convert Complex.GammaSeq_tendsto_Gamma s", "tactic_state": "case h.e'_3\ns : \u211d\n\u22a2 Complex.ofReal \u2218 s.GammaSeq = (\u2191s).GammaSeq\n---\ncase h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}, {"line": "ext1 n", "tactic_state": "case h.e'_3.h\ns : \u211d\nn : \u2115\n\u22a2 (Complex.ofReal \u2218 s.GammaSeq) n = (\u2191s).GammaSeq n\n---\ncase h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}, {"line": "dsimp only [GammaSeq, Function.comp_apply, Complex.GammaSeq]", "tactic_state": "case h.e'_3.h\ns : \u211d\nn : \u2115\n\u22a2 \u2191(\u2191n ^ s * \u2191n.factorial / \u220f j \u2208 Finset.range (n + 1), (s + \u2191j)) =\n    \u2191n ^ \u2191s * \u2191n.factorial / \u220f j \u2208 Finset.range (n + 1), (\u2191s + \u2191j)\n---\ncase h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}, {"line": "push_cast", "tactic_state": "case h.e'_3.h\ns : \u211d\nn : \u2115\n\u22a2 \u2191(\u2191n ^ s) * \u2191n.factorial / \u220f x \u2208 Finset.range (n + 1), (\u2191s + \u2191x) =\n    \u2191n ^ \u2191s * \u2191n.factorial / \u220f x \u2208 Finset.range (n + 1), (\u2191s + \u2191x)\n---\ncase h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}, {"line": "rw [Complex.ofReal_cpow n.cast_nonneg]", "tactic_state": "case h.e'_3.h\ns : \u211d\nn : \u2115\n\u22a2 \u2191\u2191n ^ \u2191s * \u2191n.factorial / \u220f x \u2208 Finset.range (n + 1), (\u2191s + \u2191x) =\n    \u2191n ^ \u2191s * \u2191n.factorial / \u220f x \u2208 Finset.range (n + 1), (\u2191s + \u2191x)\n---\ncase h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}, {"line": "rw [Complex.ofReal_natCast]", "tactic_state": "case h.e'_5\ns : \u211d\n\u22a2 sorry = nhds (Complex.Gamma \u2191s)"}]}
{"declaration": "theorem Gamma_mul_Gamma_one_sub (s : \u211d) : Gamma s * Gamma (1 - s) = \u03c0 / sin (\u03c0 * s) := by\n  simp_rw [\u2190 Complex.ofReal_inj, Complex.ofReal_div, Complex.ofReal_sin, Complex.ofReal_mul, \u2190\n    Complex.Gamma_ofReal, Complex.ofReal_sub, Complex.ofReal_one]\n  exact Complex.Gamma_mul_Gamma_one_sub s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory", "scoped Nat Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 Gamma s * Gamma (1 - s) = Real.pi / sin (Real.pi * s)"}, {"line": "simp_rw [\u2190 Complex.ofReal_inj, Complex.ofReal_div, Complex.ofReal_sin, Complex.ofReal_mul, \u2190\n    Complex.Gamma_ofReal, Complex.ofReal_sub, Complex.ofReal_one]", "tactic_state": "s : \u211d\n\u22a2 Complex.Gamma \u2191s * Complex.Gamma (1 - \u2191s) = \u2191Real.pi / Complex.sin (\u2191Real.pi * \u2191s)"}, {"line": "exact Complex.Gamma_mul_Gamma_one_sub s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_div_Gamma_eq_self_mul_one_div_Gamma_add_one (s : \u2102) :\n    (Gamma s)\u207b\u00b9 = s * (Gamma (s + 1))\u207b\u00b9 := by\n  rcases ne_or_eq s 0 with (h | rfl)\n  \u00b7 rw [Gamma_add_one s h, mul_inv, mul_inv_cancel_left\u2080 h]\n  \u00b7 rw [zero_add, Gamma_zero, inv_zero, zero_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Beta.lean", "context": {"open": ["Filter intervalIntegral Set Real MeasureTheory", "scoped Nat Topology Real", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u2102\n\u22a2 \u2191(Gamma sorry)\u207b\u00b9 = s * \u2191(Gamma sorry)\u207b\u00b9"}, {"line": "rcases ne_or_eq s 0 with (h | rfl)", "tactic_state": "case inl\ns : \u2102\nh : s \u2260 0\n\u22a2 \u2191(Gamma sorry)\u207b\u00b9 = s * \u2191(Gamma sorry)\u207b\u00b9\n---\ncase inr\n\u22a2 \u2191(Gamma sorry)\u207b\u00b9 = 0 * \u2191(Gamma sorry)\u207b\u00b9"}, {"line": "\u00b7 rw [Gamma_add_one s h, mul_inv, mul_inv_cancel_left\u2080 h]", "tactic_state": "case inr\n\u22a2 \u2191(Gamma sorry)\u207b\u00b9 = 0 * \u2191(Gamma sorry)\u207b\u00b9"}, {"line": "\u00b7 rw [zero_add, Gamma_zero, inv_zero, zero_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem f_add_nat_le (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hn : n \u2260 0) (hx : 0 < x) (hx' : x \u2264 1) :\n    f (n + x) \u2264 f n + x * log n := by\n  have hn' : 0 < (n : \u211d) := Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)\n  have : f n + x * log n = (1 - x) * f n + x * f (n + 1) := by rw [hf_feq hn']; ring\n  rw [this]\n  rw [(by ring : (n : \u211d) + x = (1 - x) * n + x * (n + 1))]\n  simpa only [smul_eq_mul] using\n    hf_conv.2 hn' (by linarith : 0 < (n + 1 : \u211d)) (by linarith : 0 \u2264 1 - x) hx.le (by linarith)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "context": {"open": ["Filter Set MeasureTheory", "scoped Nat ENNReal Topology Real"], "variables": ["{f : \u211d \u2192 \u211d} {x : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\n\u22a2 f (\u2191n + x) \u2264 f \u2191n + x * sorry"}, {"line": "have hn' : 0 < (n : \u211d) := Nat.cast_pos.mpr (Nat.pos_of_ne_zero hn)", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\n\u22a2 f (\u2191n + x) \u2264 f \u2191n + x * sorry"}, {"line": "have : f n + x * log n = (1 - x) * f n + x * f (n + 1) := by rw [hf_feq hn']; ring", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\nthis : f \u2191n + x * sorry = (1 - x) * f \u2191n + x * f (\u2191n + 1)\n\u22a2 f (\u2191n + x) \u2264 f \u2191n + x * sorry"}, {"line": "rw [this]", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\nthis : f \u2191n + x * sorry = (1 - x) * f \u2191n + x * f (\u2191n + 1)\n\u22a2 f (\u2191n + x) \u2264 (1 - x) * f \u2191n + x * f (\u2191n + 1)"}, {"line": "rw [(by ring : (n : \u211d) + x = (1 - x) * n + x * (n + 1))]", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : n \u2260 0\nhx : 0 < x\nhx' : x \u2264 1\nhn' : 0 < \u2191n\nthis : f \u2191n + x * sorry = (1 - x) * f \u2191n + x * f (\u2191n + 1)\n\u22a2 f ((1 - x) * \u2191n + x * (\u2191n + 1)) \u2264 (1 - x) * f \u2191n + x * f (\u2191n + 1)"}, {"line": "simpa only [smul_eq_mul] using\n    hf_conv.2 hn' (by linarith : 0 < (n + 1 : \u211d)) (by linarith : 0 \u2264 1 - x) hx.le (by linarith)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem f_add_nat_ge (hf_conv : ConvexOn \u211d (Ioi 0) f)\n    (hf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + log y) (hn : 2 \u2264 n) (hx : 0 < x) :\n    f n + x * log (n - 1) \u2264 f (n + x) := by\n  have npos : 0 < (n : \u211d) - 1 := by rw [\u2190 Nat.cast_one, sub_pos, Nat.cast_lt]; omega\n  have c :=\n    (convexOn_iff_slope_mono_adjacent.mp <| hf_conv).2 npos (by linarith : 0 < (n : \u211d) + x)\n      (by linarith : (n : \u211d) - 1 < (n : \u211d)) (by linarith)\n  rw [add_sub_cancel_left] at c\n  rw [sub_sub_cancel] at c\n  rw [div_one] at c\n  have : f (\u2191n - 1) = f n - log (\u2191n - 1) := by\n    rw [eq_sub_iff_add_eq]\n    rw [\u2190 hf_feq npos]\n    rw [sub_add_cancel]\n  rwa [this, le_div_iff\u2080 hx, sub_sub_cancel, le_sub_iff_add_le, mul_comm _ x, add_comm] at c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "context": {"open": ["Filter Set MeasureTheory", "scoped Nat ENNReal Topology Real"], "variables": ["{f : \u211d \u2192 \u211d} {x : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "have npos : 0 < (n : \u211d) - 1 := sorry", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "have c :=\n    (convexOn_iff_slope_mono_adjacent.mp <| hf_conv).2 npos (by linarith : 0 < (n : \u211d) + x)\n      (by linarith : (n : \u211d) - 1 < (n : \u211d)) (by linarith)", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\nc : (f \u2191n - f (\u2191n - 1)) / (\u2191n - (\u2191n - 1)) \u2264 (f (\u2191n + x) - f \u2191n) / (\u2191n + x - \u2191n)\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "rw [add_sub_cancel_left] at c", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\nc : (f \u2191n - f (\u2191n - 1)) / (\u2191n - (\u2191n - 1)) \u2264 (f (\u2191n + x) - f \u2191n) / x\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "rw [sub_sub_cancel] at c", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\nc : (f \u2191n - f (\u2191n - 1)) / 1 \u2264 (f (\u2191n + x) - f \u2191n) / x\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "rw [div_one] at c", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\nc : f \u2191n - f (\u2191n - 1) \u2264 (f (\u2191n + x) - f \u2191n) / x\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "have : f (\u2191n - 1) = f n - log (\u2191n - 1) := by\n    rw [eq_sub_iff_add_eq]\n    rw [\u2190 hf_feq npos]\n    rw [sub_add_cancel]", "tactic_state": "f : \u211d \u2192 \u211d\nx : \u211d\nn : \u2115\nx\u271d : Sort u_1\nlog : x\u271d\nhf_conv : ConvexOn \u211d (Ioi 0) f\nhf_feq : \u2200 {y : \u211d}, 0 < y \u2192 f (y + 1) = f y + sorry\nhn : 2 \u2264 n\nhx : 0 < x\nnpos : 0 < \u2191n - 1\nc : f \u2191n - f (\u2191n - 1) \u2264 (f (\u2191n + x) - f \u2191n) / x\nthis : f (\u2191n - 1) = f \u2191n - sorry\n\u22a2 f \u2191n + x * sorry \u2264 f (\u2191n + x)"}, {"line": "rwa [this, le_div_iff\u2080 hx, sub_sub_cancel, le_sub_iff_add_le, mul_comm _ x, add_comm] at c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Gamma_two : Gamma 2 = 1 := by simp [Nat.factorial_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/BohrMollerup.lean", "context": {"open": ["Filter Set MeasureTheory", "scoped Nat ENNReal Topology Real"], "variables": ["{f : \u211d \u2192 \u211d} {x : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nGamma : x\u271d\n\u22a2 sorry = 1"}, {"line": "simp [Nat.factorial_one]", "tactic_state": "x\u271d : Sort u_1\nGamma : x\u271d\n\u22a2 sorry () = 1"}]}
{"declaration": "theorem differentiableAt_Gamma {s : \u211d} (hs : \u2200 m : \u2115, s \u2260 -m) : DifferentiableAt \u211d Gamma s := by\n  refine (Complex.differentiableAt_Gamma _ ?_).hasDerivAt.real_of_complex.differentiableAt\n  simp_rw [\u2190 Complex.ofReal_natCast, \u2190 Complex.ofReal_neg, Ne, Complex.ofReal_inj]\n  exact hs\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gamma/Deriv.lean", "context": {"open": ["Filter Set Real Asymptotics", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\nhs : \u2200 (m : \u2115), s \u2260 -\u2191m\n\u22a2 DifferentiableAt \u211d Gamma s"}, {"line": "refine (Complex.differentiableAt_Gamma _ ?_).hasDerivAt.real_of_complex.differentiableAt", "tactic_state": "s : \u211d\nhs : \u2200 (m : \u2115), s \u2260 -\u2191m\n\u22a2 \u2200 (m : \u2115), \u2191s \u2260 -\u2191m"}, {"line": "simp_rw [\u2190 Complex.ofReal_natCast, \u2190 Complex.ofReal_neg, Ne, Complex.ofReal_inj]", "tactic_state": "s : \u211d\nhs : \u2200 (m : \u2115), s \u2260 -\u2191m\n\u22a2 \u2200 (m : \u2115), \u00acs = -\u2191m"}, {"line": "exact hs", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cexp_neg_quadratic_isLittleO_rpow_atTop {a : \u2102} (ha : a.re < 0) (b : \u2102) (s : \u211d) :\n    (fun x : \u211d \u21a6 cexp (a * x ^ 2 + b * x)) =o[atTop] (\u00b7 ^ s) := by\n  apply Asymptotics.IsLittleO.of_norm_left\n  convert rexp_neg_quadratic_isLittleO_rpow_atTop ha b.re s with x\n  simp_rw [Complex.norm_exp, add_re, \u2190 ofReal_pow, mul_comm (_ : \u2102) \u2191(_ : \u211d),\n      re_ofReal_mul, mul_comm _ (re _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atTop] fun x => x ^ s"}, {"line": "apply Asymptotics.IsLittleO.of_norm_left", "tactic_state": "case a\na : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => \u2016Complex.exp (a * \u2191x ^ 2 + b * \u2191x)\u2016) =o[atTop] fun x => x ^ s"}, {"line": "convert rexp_neg_quadratic_isLittleO_rpow_atTop ha b.re s with x", "tactic_state": "case h.e'_7.h\na : \u2102\nha : a.re < 0\nb : \u2102\ns x : \u211d\n\u22a2 \u2016Complex.exp (a * \u2191x ^ 2 + b * \u2191x)\u2016 = exp (a.re * x ^ 2 + b.re * x)"}, {"line": "simp_rw [Complex.norm_exp, add_re, \u2190 ofReal_pow, mul_comm (_ : \u2102) \u2191(_ : \u211d),\n      re_ofReal_mul, mul_comm _ (re _)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cexp_neg_quadratic_isLittleO_abs_rpow_cocompact {a : \u2102} (ha : a.re < 0) (b : \u2102) (s : \u211d) :\n    (fun x : \u211d \u21a6 cexp (a * x ^ 2 + b * x)) =o[cocompact \u211d] (|\u00b7| ^ s) := by\n  rw [cocompact_eq_atBot_atTop]\n  rw [isLittleO_sup]\n  constructor\n  \u00b7 refine ((cexp_neg_quadratic_isLittleO_rpow_atTop ha (-b) s).comp_tendsto\n      Filter.tendsto_neg_atBot_atTop).congr' (Eventually.of_forall fun x \u21a6 ?_) ?_\n    \u00b7 simp only [neg_mul, Function.comp_apply, ofReal_neg, neg_sq, mul_neg, neg_neg]\n    \u00b7 refine (eventually_lt_atBot 0).mp (Eventually.of_forall fun x hx \u21a6 ?_)\n      simp only [Function.comp_apply]\n      simp only [abs_of_neg hx]\n  \u00b7 refine (cexp_neg_quadratic_isLittleO_rpow_atTop ha b s).congr' EventuallyEq.rfl ?_\n    refine (eventually_gt_atTop 0).mp (Eventually.of_forall fun x hx \u21a6 ?_)\n    simp_rw [abs_of_pos hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[cocompact \u211d] fun x => |x| ^ s"}, {"line": "rw [cocompact_eq_atBot_atTop]", "tactic_state": "a : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atBot \u2294 atTop] fun x => |x| ^ s"}, {"line": "rw [isLittleO_sup]", "tactic_state": "a : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 ((fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atBot] fun x => |x| ^ s) \u2227\n    (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atTop] fun x => |x| ^ s"}, {"line": "constructor", "tactic_state": "case left\na : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atBot] fun x => |x| ^ s\n---\ncase right\na : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atTop] fun x => |x| ^ s"}, {"line": "\u00b7 refine ((cexp_neg_quadratic_isLittleO_rpow_atTop ha (-b) s).comp_tendsto\n      Filter.tendsto_neg_atBot_atTop).congr' (Eventually.of_forall fun x \u21a6 ?_) ?_\n    \u00b7 simp only [neg_mul, Function.comp_apply, ofReal_neg, neg_sq, mul_neg, neg_neg]\n    \u00b7 refine (eventually_lt_atBot 0).mp (Eventually.of_forall fun x hx \u21a6 ?_)\n      simp only [Function.comp_apply]\n      simp only [abs_of_neg hx]", "tactic_state": "case right\na : \u2102\nha : a.re < 0\nb : \u2102\ns : \u211d\n\u22a2 (fun x => Complex.exp (a * \u2191x ^ 2 + b * \u2191x)) =o[atTop] fun x => |x| ^ s"}, {"line": "\u00b7 refine (cexp_neg_quadratic_isLittleO_rpow_atTop ha b s).congr' EventuallyEq.rfl ?_\n    refine (eventually_gt_atTop 0).mp (Eventually.of_forall fun x hx \u21a6 ?_)\n    simp_rw [abs_of_pos hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_exp_neg_mul_sq_cocompact {a : \u2102} (ha : 0 < a.re) (s : \u211d) :\n    (fun x : \u211d => Complex.exp (-a * x ^ 2)) =o[cocompact \u211d] fun x : \u211d => |x| ^ s := by\n  convert cexp_neg_quadratic_isLittleO_abs_rpow_cocompact (?_ : (-a).re < 0) 0 s using 1\n  \u00b7 simp_rw [zero_mul, add_zero]\n  \u00b7 rwa [neg_re, neg_lt_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : 0 < a.re\ns : \u211d\n\u22a2 (fun x => Complex.exp (-a * \u2191x ^ 2)) =o[cocompact \u211d] fun x => |x| ^ s"}, {"line": "convert cexp_neg_quadratic_isLittleO_abs_rpow_cocompact (?_ : (-a).re < 0) 0 s using 1", "tactic_state": "case h.e'_7\na : \u2102\nha : 0 < a.re\ns : \u211d\n\u22a2 (fun x => Complex.exp (-a * \u2191x ^ 2)) = fun x => Complex.exp (-a * \u2191x ^ 2 + 0 * \u2191x)\n---\na : \u2102\nha : 0 < a.re\ns : \u211d\n\u22a2 (-a).re < 0"}, {"line": "\u00b7 simp_rw [zero_mul, add_zero]", "tactic_state": "a : \u2102\nha : 0 < a.re\ns : \u211d\n\u22a2 (-a).re < 0"}, {"line": "\u00b7 rwa [neg_re, neg_lt_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.tsum_exp_neg_mul_int_sq {a : \u2102} (ha : 0 < a.re) :\n    (\u2211' n : \u2124, cexp (-\u03c0 * a * (n : \u2102) ^ 2)) =\n      1 / a ^ (1 / 2 : \u2102) * \u2211' n : \u2124, cexp (-\u03c0 / a * (n : \u2102) ^ 2) := by\n  simpa only [mul_zero,zero_mul,add_zero] using Complex.tsum_exp_neg_quadratic ha 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u2102\nha : 0 < a.re\n\u22a2 \u2211' (n : \u2124), exp (-\u2191Real.pi * a * \u2191n ^ 2) = 1 / a ^ (1 / 2) * \u2211' (n : \u2124), exp (-\u2191Real.pi / a * \u2191n ^ 2)"}, {"line": "simpa only [mul_zero,zero_mul,add_zero] using Complex.tsum_exp_neg_quadratic ha 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Real.tsum_exp_neg_mul_int_sq {a : \u211d} (ha : 0 < a) :\n    (\u2211' n : \u2124, exp (-\u03c0 * a * (n : \u211d) ^ 2)) =\n      (1 : \u211d) / a ^ (1 / 2 : \u211d) * (\u2211' n : \u2124, exp (-\u03c0 / a * (n : \u211d) ^ 2)) := by\n  simpa only [\u2190 ofReal_inj,ofReal_tsum,ofReal_exp,ofReal_mul,ofReal_neg,ofReal_pow,ofReal_intCast,ofReal_div,ofReal_one,ofReal_cpow ha.le,ofReal_ofNat,mul_zero,zero_mul,add_zero] using Complex.tsum_exp_neg_quadratic (by rwa [ofReal_re] : 0 < (a : \u2102).re) 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/PoissonSummation.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a : \u211d\nha : 0 < a\n\u22a2 \u2211' (n : \u2124), exp (-Real.pi * a * \u2191n ^ 2) = 1 / a ^ (1 / 2) * \u2211' (n : \u2124), exp (-Real.pi / a * \u2191n ^ 2)"}, {"line": "simpa only [\u2190 ofReal_inj,ofReal_tsum,ofReal_exp,ofReal_mul,ofReal_neg,ofReal_pow,ofReal_intCast,ofReal_div,ofReal_one,ofReal_cpow ha.le,ofReal_ofNat,mul_zero,zero_mul,add_zero] using Complex.tsum_exp_neg_quadratic (by rwa [ofReal_re] : 0 < (a : \u2102).re) 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.fourierIntegral_gaussian_pi (hb : 0 < b.re) :\n    (\ud835\udcd5 fun (x : \u211d) \u21a6 cexp (-\u03c0 * b * x ^ 2)) =\n    fun t : \u211d \u21a6 1 / b ^ (1 / 2 : \u2102) * cexp (-\u03c0 / b * t ^ 2) := by\n  simpa only [mul_zero,zero_mul,add_zero] using fourierIntegral_gaussian_pi' hb 0\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": ["{b : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 (fourierIntegral fun x => Complex.exp (-\u2191Real.pi * b * \u2191x ^ 2)) = fun t =>\n    1 / b ^ (1 / 2) * Complex.exp (-\u2191Real.pi / b * \u2191t ^ 2)"}, {"line": "simpa only [mul_zero,zero_mul,add_zero] using fourierIntegral_gaussian_pi' hb 0", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_cexp_neg_mul_sum_add {\u03b9 : Type*} [Fintype \u03b9] (hb : 0 < b.re) (c : \u03b9 \u2192 \u2102) :\n    Integrable (fun (v : \u03b9 \u2192 \u211d) \u21a6 cexp (- b * \u2211 i, (v i : \u2102) ^ 2 + \u2211 i, c i * v i)) := by\n  simp_rw [neg_mul, Finset.mul_sum]\n  exact integrable_cexp_neg_sum_mul_add (fun _ \u21a6 hb) c\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": ["{b : \u2102}", "{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nhb : 0 < b.re\nc : \u03b9 \u2192 \u2102\n\u22a2 Integrable (fun v => Complex.exp (-b * \u2211 i, \u2191(v i) ^ 2 + \u2211 i, c i * \u2191(v i))) volume"}, {"line": "simp_rw [neg_mul, Finset.mul_sum]", "tactic_state": "b : \u2102\n\u03b9 : Type u_2\ninst\u271d : Fintype \u03b9\nhb : 0 < b.re\nc : \u03b9 \u2192 \u2102\n\u22a2 Integrable (fun v => Complex.exp (-\u2211 i, b * \u2191(v i) ^ 2 + \u2211 i, c i * \u2191(v i))) volume"}, {"line": "exact integrable_cexp_neg_sum_mul_add (fun _ \u21a6 hb) c", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_cexp_neg_mul_sq_norm (hb : 0 < b.re) :\n    \u222b v : V, cexp (- b * \u2016v\u2016^2) = (\u03c0 / b) ^ (Module.finrank \u211d V / 2 : \u2102) := by\n  simpa using integral_cexp_neg_mul_sq_norm_add hb 0 (0 : V)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": ["{b : \u2102}", "{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nhb : 0 < b.re\n\u22a2 \u222b (v : V), Complex.exp (-b * \u2191\u2016v\u2016 ^ 2) = (\u2191Real.pi / b) ^ (\u2191(Module.finrank \u211d V) / 2)"}, {"line": "simpa using integral_cexp_neg_mul_sq_norm_add hb 0 (0 : V)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.fourierIntegral_gaussian_innerProductSpace (hb : 0 < b.re) (w : V) :\n    \ud835\udcd5 (fun v \u21a6 cexp (- b * \u2016v\u2016^2)) w =\n      (\u03c0 / b) ^ (Module.finrank \u211d V / 2 : \u2102) * cexp (-\u03c0 ^ 2 * \u2016w\u2016^2 / b) := by\n  simpa using fourierIntegral_gaussian_innerProductSpace' hb 0 w\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/FourierTransform.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics intervalIntegral", "scoped Real Topology FourierTransform RealInnerProductSpace", "Complex hiding exp continuous_exp abs_of_nonneg sq_abs"], "variables": ["{b : \u2102}", "{V : Type*} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [FiniteDimensional \u211d V]"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nV : Type u_1\ninst\u271d\u00b2 : NormedAddCommGroup V\ninst\u271d\u00b9 : InnerProductSpace \u211d V\ninst\u271d : FiniteDimensional \u211d V\nhb : 0 < b.re\nw : V\n\u22a2 fourierIntegral (fun v => Complex.exp (-b * \u2191\u2016v\u2016 ^ 2)) w =\n    (\u2191Real.pi / b) ^ (\u2191(Module.finrank \u211d V) / 2) * Complex.exp (-\u2191Real.pi ^ 2 * \u2191\u2016w\u2016 ^ 2 / b)"}, {"line": "simpa using fourierIntegral_gaussian_innerProductSpace' hb 0 w", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_neg_mul_rpow_isLittleO_exp_neg {p b : \u211d} (hb : 0 < b) (hp : 1 < p) :\n    (fun x : \u211d => exp (- b * x ^ p)) =o[atTop] fun x : \u211d => exp (-x) := by\n  rw [isLittleO_exp_comp_exp_comp]\n  suffices Tendsto (fun x => x * (b * x ^ (p - 1) + -1)) atTop atTop by\n    refine Tendsto.congr' ?_ this\n    refine eventuallyEq_of_mem (Ioi_mem_atTop (0 : \u211d)) (fun x hx => ?_)\n    rw [mem_Ioi] at hx\n    rw [rpow_sub_one hx.ne']\n    field_simp [hx.ne']\n    ring\n  apply tendsto_id.atTop_mul_atTop\u2080\n  refine tendsto_atTop_add_const_right atTop (-1 : \u211d) ?_\n  exact Tendsto.const_mul_atTop hb (tendsto_rpow_atTop (by linarith))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "p b : \u211d\nhb : 0 < b\nhp : 1 < p\n\u22a2 (fun x => exp (-b * x ^ p)) =o[atTop] fun x => exp (-x)"}, {"line": "rw [isLittleO_exp_comp_exp_comp]", "tactic_state": "p b : \u211d\nhb : 0 < b\nhp : 1 < p\n\u22a2 Tendsto (fun x => -x - -b * x ^ p) atTop atTop"}, {"line": "suffices Tendsto (fun x => x * (b * x ^ (p - 1) + -1)) atTop atTop by\n    refine Tendsto.congr' ?_ this\n    refine eventuallyEq_of_mem (Ioi_mem_atTop (0 : \u211d)) (fun x hx => ?_)\n    rw [mem_Ioi] at hx\n    rw [rpow_sub_one hx.ne']\n    field_simp [hx.ne']\n    ring", "tactic_state": "p b : \u211d\nhb : 0 < b\nhp : 1 < p\n\u22a2 Tendsto (fun x => x * (b * x ^ (p - 1) + -1)) atTop atTop"}, {"line": "apply tendsto_id.atTop_mul_atTop\u2080", "tactic_state": "p b : \u211d\nhb : 0 < b\nhp : 1 < p\n\u22a2 Tendsto (fun x => b * x ^ (p - 1) + -1) atTop atTop"}, {"line": "refine tendsto_atTop_add_const_right atTop (-1 : \u211d) ?_", "tactic_state": "p b : \u211d\nhb : 0 < b\nhp : 1 < p\n\u22a2 Tendsto (fun x => b * x ^ (p - 1)) atTop atTop"}, {"line": "exact Tendsto.const_mul_atTop hb (tendsto_rpow_atTop (by linarith))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_neg_mul_sq_isLittleO_exp_neg {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => exp (-b * x ^ 2)) =o[atTop] fun x : \u211d => exp (-x) := by\n  simp_rw [\u2190 rpow_two]\n  exact exp_neg_mul_rpow_isLittleO_exp_neg hb one_lt_two\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\n\u22a2 (fun x => exp (-b * x ^ 2)) =o[atTop] fun x => exp (-x)"}, {"line": "simp_rw [\u2190 rpow_two]", "tactic_state": "b : \u211d\nhb : 0 < b\n\u22a2 (fun x => exp (-b * x ^ 2)) =o[atTop] fun x => exp (-x)"}, {"line": "exact exp_neg_mul_rpow_isLittleO_exp_neg hb one_lt_two", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg (s : \u211d) {b p : \u211d} (hp : 1 < p) (hb : 0 < b) :\n    (fun x : \u211d => x ^ s * exp (- b * x ^ p)) =o[atTop] fun x : \u211d => exp (-(1 / 2) * x) := by\n  apply ((isBigO_refl (fun x : \u211d => x ^ s) atTop).mul_isLittleO\n      (exp_neg_mul_rpow_isLittleO_exp_neg hb hp)).trans\n  simpa only [mul_comm] using Real.Gamma_integrand_isLittleO s\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s b p : \u211d\nhp : 1 < p\nhb : 0 < b\n\u22a2 (fun x => x ^ s * exp (-b * x ^ p)) =o[atTop] fun x => exp (-(1 / 2) * x)"}, {"line": "apply ((isBigO_refl (fun x : \u211d => x ^ s) atTop).mul_isLittleO\n      (exp_neg_mul_rpow_isLittleO_exp_neg hb hp)).trans", "tactic_state": "s b p : \u211d\nhp : 1 < p\nhb : 0 < b\n\u22a2 (fun x => x ^ s * exp (-x)) =o[atTop] fun x => exp (-(1 / 2) * x)"}, {"line": "simpa only [mul_comm] using Real.Gamma_integrand_isLittleO s", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_mul_exp_neg_mul_sq_isLittleO_exp_neg {b : \u211d} (hb : 0 < b) (s : \u211d) :\n    (fun x : \u211d => x ^ s * exp (-b * x ^ 2)) =o[atTop] fun x : \u211d => exp (-(1 / 2) * x) := by\n  simp_rw [\u2190 rpow_two]\n  exact rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg s one_lt_two hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\ns : \u211d\n\u22a2 (fun x => x ^ s * exp (-b * x ^ 2)) =o[atTop] fun x => exp (-(1 / 2) * x)"}, {"line": "simp_rw [\u2190 rpow_two]", "tactic_state": "b : \u211d\nhb : 0 < b\ns : \u211d\n\u22a2 (fun x => x ^ s * exp (-b * x ^ 2)) =o[atTop] fun x => exp (-(1 / 2) * x)"}, {"line": "exact rpow_mul_exp_neg_mul_rpow_isLittleO_exp_neg s one_lt_two hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrableOn_rpow_mul_exp_neg_mul_sq {b : \u211d} (hb : 0 < b) {s : \u211d} (hs : -1 < s) :\n    IntegrableOn (fun x : \u211d => x ^ s * exp (-b * x ^ 2)) (Ioi 0) := by\n  simp_rw [\u2190 rpow_two]\n  exact integrableOn_rpow_mul_exp_neg_mul_rpow hs one_le_two hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\ns : \u211d\nhs : -1 < s\n\u22a2 IntegrableOn (fun x => x ^ s * exp (-b * x ^ 2)) (Ioi 0) volume"}, {"line": "simp_rw [\u2190 rpow_two]", "tactic_state": "b : \u211d\nhb : 0 < b\ns : \u211d\nhs : -1 < s\n\u22a2 IntegrableOn (fun x => x ^ s * exp (-b * x ^ 2)) (Ioi 0) volume"}, {"line": "exact integrableOn_rpow_mul_exp_neg_mul_rpow hs one_le_two hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_exp_neg_mul_sq {b : \u211d} (hb : 0 < b) :\n    Integrable fun x : \u211d => exp (-b * x ^ 2) := by\n  simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : \u211d) < 0)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\n\u22a2 Integrable (fun x => exp (-b * x ^ 2)) volume"}, {"line": "simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : \u211d) < 0)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_mul_exp_neg_mul_sq {b : \u211d} (hb : 0 < b) :\n    Integrable fun x : \u211d => x * exp (-b * x ^ 2) := by\n  simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : \u211d) < 1)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 0 < b\n\u22a2 Integrable (fun x => x * exp (-b * x ^ 2)) volume"}, {"line": "simpa using integrable_rpow_mul_exp_neg_mul_sq hb (by norm_num : (-1 : \u211d) < 1)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_cexp_neg_mul_sq (b : \u2102) (x : \u211d) :\n    \u2016Complex.exp (-b * (x : \u2102) ^ 2)\u2016 = exp (-b.re * x ^ 2) := by\n  rw [norm_exp]\n  rw [\u2190 ofReal_pow]\n  rw [mul_comm (-b) _]\n  rw [re_ofReal_mul]\n  rw [neg_re]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 \u2016Complex.exp (-b * \u2191x ^ 2)\u2016 = exp (-b.re * x ^ 2)"}, {"line": "rw [norm_exp]", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 exp (-b * \u2191x ^ 2).re = exp (-b.re * x ^ 2)"}, {"line": "rw [\u2190 ofReal_pow]", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 exp (-b * \u2191(x ^ 2)).re = exp (-b.re * x ^ 2)"}, {"line": "rw [mul_comm (-b) _]", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 exp (\u2191(x ^ 2) * -b).re = exp (-b.re * x ^ 2)"}, {"line": "rw [re_ofReal_mul]", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 exp (x ^ 2 * (-b).re) = exp (-b.re * x ^ 2)"}, {"line": "rw [neg_re]", "tactic_state": "b : \u2102\nx : \u211d\n\u22a2 exp (x ^ 2 * -b.re) = exp (-b.re * x ^ 2)"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_cexp_neg_mul_sq {b : \u2102} (hb : 0 < b.re) :\n    Integrable fun x : \u211d => cexp (-b * (x : \u2102) ^ 2) := by\n  refine \u27e8(Complex.continuous_exp.comp\n    (continuous_const.mul (continuous_ofReal.pow 2))).aestronglyMeasurable, ?_\u27e9\n  rw [\u2190 hasFiniteIntegral_norm_iff]\n  simp_rw [norm_cexp_neg_mul_sq]\n  exact (integrable_exp_neg_mul_sq hb).2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 Integrable (fun x => Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "refine \u27e8(Complex.continuous_exp.comp\n    (continuous_const.mul (continuous_ofReal.pow 2))).aestronglyMeasurable, ?_\u27e9", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 HasFiniteIntegral (fun x => Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "rw [\u2190 hasFiniteIntegral_norm_iff]", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 HasFiniteIntegral (fun a => \u2016Complex.exp (-b * \u2191a ^ 2)\u2016) volume"}, {"line": "simp_rw [norm_cexp_neg_mul_sq]", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 HasFiniteIntegral (fun a => exp (-b.re * a ^ 2)) volume"}, {"line": "exact (integrable_exp_neg_mul_sq hb).2", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integrable_mul_cexp_neg_mul_sq {b : \u2102} (hb : 0 < b.re) :\n    Integrable fun x : \u211d => \u2191x * cexp (-b * (x : \u2102) ^ 2) := by\n  refine \u27e8(continuous_ofReal.mul (Complex.continuous_exp.comp ?_)).aestronglyMeasurable, ?_\u27e9\n  \u00b7 exact continuous_const.mul (continuous_ofReal.pow 2)\n  have := (integrable_mul_exp_neg_mul_sq hb).hasFiniteIntegral\n  rw [\u2190 hasFiniteIntegral_norm_iff] at this \u22a2\n  convert this\n  rw [norm_mul]\n  rw [norm_mul]\n  rw [norm_cexp_neg_mul_sq b]\n  rw [norm_real]\n  rw [norm_of_nonneg (exp_pos _).le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 Integrable (fun x => \u2191x * Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "refine \u27e8(continuous_ofReal.mul (Complex.continuous_exp.comp ?_)).aestronglyMeasurable, ?_\u27e9", "tactic_state": "case refine_1\nb : \u2102\nhb : 0 < b.re\n\u22a2 Continuous fun x => -b * \u2191x ^ 2\n---\ncase refine_2\nb : \u2102\nhb : 0 < b.re\n\u22a2 HasFiniteIntegral (fun x => \u2191x * Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "\u00b7 exact continuous_const.mul (continuous_ofReal.pow 2)", "tactic_state": "case refine_2\nb : \u2102\nhb : 0 < b.re\n\u22a2 HasFiniteIntegral (fun x => \u2191x * Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "have := (integrable_mul_exp_neg_mul_sq hb).hasFiniteIntegral", "tactic_state": "case refine_2\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun x => x * exp (-b.re * x ^ 2)) volume\n\u22a2 HasFiniteIntegral (fun x => \u2191x * Complex.exp (-b * \u2191x ^ 2)) volume"}, {"line": "rw [\u2190 hasFiniteIntegral_norm_iff] at this \u22a2", "tactic_state": "case refine_2\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\n\u22a2 HasFiniteIntegral (fun a => \u2016\u2191a * Complex.exp (-b * \u2191a ^ 2)\u2016) volume"}, {"line": "convert this", "tactic_state": "case h.e'_5.h\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\nx\u271d : \u211d\n\u22a2 \u2016\u2191x\u271d * Complex.exp (-b * \u2191x\u271d ^ 2)\u2016 = \u2016x\u271d * exp (-b.re * x\u271d ^ 2)\u2016"}, {"line": "rw [norm_mul]", "tactic_state": "case h.e'_5.h\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\nx\u271d : \u211d\n\u22a2 \u2016\u2191x\u271d\u2016 * \u2016Complex.exp (-b * \u2191x\u271d ^ 2)\u2016 = \u2016x\u271d * exp (-b.re * x\u271d ^ 2)\u2016"}, {"line": "rw [norm_mul]", "tactic_state": "case h.e'_5.h\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\nx\u271d : \u211d\n\u22a2 \u2016\u2191x\u271d\u2016 * \u2016Complex.exp (-b * \u2191x\u271d ^ 2)\u2016 = \u2016x\u271d\u2016 * \u2016exp (-b.re * x\u271d ^ 2)\u2016"}, {"line": "rw [norm_cexp_neg_mul_sq b]", "tactic_state": "case h.e'_5.h\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\nx\u271d : \u211d\n\u22a2 \u2016\u2191x\u271d\u2016 * exp (-b.re * x\u271d ^ 2) = \u2016x\u271d\u2016 * \u2016exp (-b.re * x\u271d ^ 2)\u2016"}, {"line": "rw [norm_real]", "tactic_state": "case h.e'_5.h\nb : \u2102\nhb : 0 < b.re\nthis : HasFiniteIntegral (fun a => \u2016a * exp (-b.re * a ^ 2)\u2016) volume\nx\u271d : \u211d\n\u22a2 \u2016x\u271d\u2016 * exp (-b.re * x\u271d ^ 2) = \u2016x\u271d\u2016 * \u2016exp (-b.re * x\u271d ^ 2)\u2016"}, {"line": "rw [norm_of_nonneg (exp_pos _).le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem integral_gaussian_complex {b : \u2102} (hb : 0 < re b) :\n    \u222b x : \u211d, cexp (-b * (x : \u2102) ^ 2) = (\u03c0 / b) ^ (1 / 2 : \u2102) := by\n  have nv : \u2200 {b : \u2102}, 0 < re b \u2192 b \u2260 0 := by intro b hb; contrapose! hb; rw [hb]; simp\n  apply\n    (convex_halfSpace_re_gt 0).isPreconnected.eq_of_sq_eq ?_ ?_ (fun c hc => ?_) (fun {c} hc => ?_)\n      (by simp : 0 < re (1 : \u2102)) ?_ hb\n  \u00b7 -- integral is continuous\n    exact continuousOn_of_forall_continuousAt continuousAt_gaussian_integral\n  \u00b7 -- `(\u03c0 / b) ^ (1 / 2 : \u2102)` is continuous\n    refine\n      continuousOn_of_forall_continuousAt fun b hb =>\n        (continuousAt_cpow_const (Or.inl ?_)).comp (continuousAt_const.div continuousAt_id (nv hb))\n    rw [div_re]\n    rw [ofReal_im]\n    rw [ofReal_re]\n    rw [zero_mul]\n    rw [zero_div]\n    rw [add_zero]\n    exact div_pos (mul_pos pi_pos hb) (normSq_pos.mpr (nv hb))\n  \u00b7 -- equality at 1\n    have : \u2200 x : \u211d, cexp (-(1 : \u2102) * (x : \u2102) ^ 2) = exp (-(1 : \u211d) * x ^ 2) := by\n      intro x\n      simp only [ofReal_exp]\n      simp only [neg_mul]\n      simp only [one_mul]\n      simp only [ofReal_neg]\n      simp only [ofReal_pow]\n    simp_rw [this, \u2190 coe_algebraMap, RCLike.algebraMap_eq_ofReal, integral_ofReal,\n      \u2190 RCLike.algebraMap_eq_ofReal, coe_algebraMap]\n    conv_rhs =>\n      congr\n      \u00b7 rw [\u2190 ofReal_one, \u2190 ofReal_div]\n      \u00b7 rw [\u2190 ofReal_one, \u2190 ofReal_ofNat, \u2190 ofReal_div]\n    rw [\u2190 ofReal_cpow]\n    rw [ofReal_inj]\n    \u00b7 convert integral_gaussian (1 : \u211d) using 1\n      rw [sqrt_eq_rpow]\n    \u00b7 rw [div_one]; exact pi_pos.le\n  \u00b7 -- squares of both sides agree\n    dsimp only [Pi.pow_apply]\n    rw [integral_gaussian_sq_complex hc]\n    rw [sq]\n    conv_lhs => rw [\u2190 cpow_one (\u2191\u03c0 / c)]\n    rw [\u2190 cpow_add _ _ (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))]\n    norm_num\n  \u00b7 -- RHS doesn't vanish\n    rw [Ne]\n    rw [cpow_eq_zero_iff]\n    rw [not_and_or]\n    exact Or.inl (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u2102\nhb : 0 < b.re\n\u22a2 \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2) = (\u2191Real.pi / b) ^ (1 / 2)"}, {"line": "have nv : \u2200 {b : \u2102}, 0 < re b \u2192 b \u2260 0 := sorry", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2) = (\u2191Real.pi / b) ^ (1 / 2)"}, {"line": "apply\n    (convex_halfSpace_re_gt 0).isPreconnected.eq_of_sq_eq ?_ ?_ (fun c hc => ?_) (fun {c} hc => ?_)\n      (by simp : 0 < re (1 : \u2102)) ?_ hb", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 ContinuousOn (fun {b} => \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2)) {c | 0 < c.re}\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 ContinuousOn (fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) {c | 0 < c.re}\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 \u222b (x : \u211d), Complex.exp (-1 * \u2191x ^ 2) = (\u2191Real.pi / 1) ^ (1 / 2)\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 ((fun {b} => \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2)) ^ 2) c = ((fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) ^ 2) c\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191Real.pi / c) ^ (1 / 2) \u2260 0"}, {"line": "\u00b7 -- integral is continuous\n    exact continuousOn_of_forall_continuousAt continuousAt_gaussian_integral", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 ContinuousOn (fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) {c | 0 < c.re}\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 \u222b (x : \u211d), Complex.exp (-1 * \u2191x ^ 2) = (\u2191Real.pi / 1) ^ (1 / 2)\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 ((fun {b} => \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2)) ^ 2) c = ((fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) ^ 2) c\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191Real.pi / c) ^ (1 / 2) \u2260 0"}, {"line": "\u00b7 -- `(\u03c0 / b) ^ (1 / 2 : \u2102)` is continuous\n    refine\n      continuousOn_of_forall_continuousAt fun b hb =>\n        (continuousAt_cpow_const (Or.inl ?_)).comp (continuousAt_const.div continuousAt_id (nv hb))\n    rw [div_re]\n    rw [ofReal_im]\n    rw [ofReal_re]\n    rw [zero_mul]\n    rw [zero_div]\n    rw [add_zero]\n    exact div_pos (mul_pos pi_pos hb) (normSq_pos.mpr (nv hb))", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\n\u22a2 \u222b (x : \u211d), Complex.exp (-1 * \u2191x ^ 2) = (\u2191Real.pi / 1) ^ (1 / 2)\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 ((fun {b} => \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2)) ^ 2) c = ((fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) ^ 2) c\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191Real.pi / c) ^ (1 / 2) \u2260 0"}, {"line": "\u00b7 -- equality at 1\n    have : \u2200 x : \u211d, cexp (-(1 : \u2102) * (x : \u2102) ^ 2) = exp (-(1 : \u211d) * x ^ 2) := by\n      intro x\n      simp only [ofReal_exp]\n      simp only [neg_mul]\n      simp only [one_mul]\n      simp only [ofReal_neg]\n      simp only [ofReal_pow]\n    simp_rw [this, \u2190 coe_algebraMap, RCLike.algebraMap_eq_ofReal, integral_ofReal,\n      \u2190 RCLike.algebraMap_eq_ofReal, coe_algebraMap]\n    conv_rhs =>\n      congr\n      \u00b7 rw [\u2190 ofReal_one, \u2190 ofReal_div]\n      \u00b7 rw [\u2190 ofReal_one, \u2190 ofReal_ofNat, \u2190 ofReal_div]\n    rw [\u2190 ofReal_cpow]\n    rw [ofReal_inj]\n    \u00b7 convert integral_gaussian (1 : \u211d) using 1\n      rw [sqrt_eq_rpow]\n    \u00b7 rw [div_one]; exact pi_pos.le", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 ((fun {b} => \u222b (x : \u211d), Complex.exp (-b * \u2191x ^ 2)) ^ 2) c = ((fun {b} => (\u2191Real.pi / b) ^ (1 / 2)) ^ 2) c\n---\nb : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191Real.pi / c) ^ (1 / 2) \u2260 0"}, {"line": "\u00b7 -- squares of both sides agree\n    dsimp only [Pi.pow_apply]\n    rw [integral_gaussian_sq_complex hc]\n    rw [sq]\n    conv_lhs => rw [\u2190 cpow_one (\u2191\u03c0 / c)]\n    rw [\u2190 cpow_add _ _ (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))]\n    norm_num", "tactic_state": "b : \u2102\nhb : 0 < b.re\nnv : \u2200 {b : \u2102}, 0 < b.re \u2192 b \u2260 0\nc : \u2102\nhc : c \u2208 {c | 0 < c.re}\n\u22a2 (\u2191Real.pi / c) ^ (1 / 2) \u2260 0"}, {"line": "\u00b7 -- RHS doesn't vanish\n    rw [Ne]\n    rw [cpow_eq_zero_iff]\n    rw [not_and_or]\n    exact Or.inl (div_ne_zero (ofReal_ne_zero.mpr pi_ne_zero) (nv hc))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.Gamma_one_half_eq : Complex.Gamma (1 / 2) = (\u03c0 : \u2102) ^ (1 / 2 : \u2102) := by\n  convert congr_arg ((\u2191) : \u211d \u2192 \u2102) Real.Gamma_one_half_eq\n  \u00b7 simpa only [one_div,ofReal_inv,ofReal_ofNat] using Gamma_ofReal (1 / 2)\n  \u00b7 rw [sqrt_eq_rpow, ofReal_cpow pi_pos.le, ofReal_div, ofReal_ofNat, ofReal_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Gaussian/GaussianIntegral.lean", "context": {"open": ["Real Set MeasureTheory Filter Asymptotics", "scoped Real Topology", "Complex hiding exp abs_of_nonneg"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Gamma (1 / 2) = \u2191Real.pi ^ (1 / 2)"}, {"line": "convert congr_arg ((\u2191) : \u211d \u2192 \u2102) Real.Gamma_one_half_eq", "tactic_state": "case h.e'_2\n\u22a2 Gamma (1 / 2) = \u2191(Real.Gamma (1 / 2))\n---\ncase h.e'_3\n\u22a2 \u2191Real.pi ^ (1 / 2) = \u2191\u221aReal.pi"}, {"line": "\u00b7 simpa only [one_div,ofReal_inv,ofReal_ofNat] using Gamma_ofReal (1 / 2)", "tactic_state": "case h.e'_3\n\u22a2 \u2191Real.pi ^ (1 / 2) = \u2191\u221aReal.pi"}, {"line": "\u00b7 rw [sqrt_eq_rpow, ofReal_cpow pi_pos.le, ofReal_div, ofReal_ofNat, ofReal_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_nmul (x : EReal) (n : \u2115) : exp (n * x) = (exp x) ^ n := by\n  simp_rw [\u2190 log_eq_iff, log_pow, log_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/ENNRealLogExp.lean", "context": {"open": ["EReal ENNReal Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\nn : \u2115\n\u22a2 (\u2191n * x).exp = x.exp ^ n"}, {"line": "simp_rw [\u2190 log_eq_iff, log_pow, log_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_mul (x : EReal) (y : \u211d) : exp (x * y) = (exp x) ^ y := by\n  rw [\u2190 log_eq_iff]\n  rw [log_rpow]\n  rw [log_exp]\n  rw [log_exp]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/ENNRealLogExp.lean", "context": {"open": ["EReal ENNReal Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : EReal\ny : \u211d\n\u22a2 (x * \u2191y).exp = x.exp ^ y"}, {"line": "rw [\u2190 log_eq_iff]", "tactic_state": "x : EReal\ny : \u211d\n\u22a2 (x * \u2191y).exp.log = (x.exp ^ y).log"}, {"line": "rw [log_rpow]", "tactic_state": "x : EReal\ny : \u211d\n\u22a2 (x * \u2191y).exp.log = \u2191y * x.exp.log"}, {"line": "rw [log_exp]", "tactic_state": "x : EReal\ny : \u211d\n\u22a2 x * \u2191y = \u2191y * x.exp.log"}, {"line": "rw [log_exp]", "tactic_state": "x : EReal\ny : \u211d\n\u22a2 x * \u2191y = \u2191y * x"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem posLog_nonneg {x : \u211d} : 0 \u2264 log\u207a x := by simp [posLog]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/PosLog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Type u_1\nlog : x\u271d\nx : \u211d\n\u22a2 0 \u2264 sorry"}, {"line": "simp [posLog]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_of_nat_eq_posLog {n : \u2115} : log\u207a n = log n := by\n  by_cases hn : n = 0\n  \u00b7 simp [hn, posLog]\n  \u00b7 simp [posLog_eq_log, Nat.one_le_iff_ne_zero.2 hn]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/PosLog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Type u_1\nlog : x\u271d\nn : \u2115\n\u22a2 sorry = sorry"}, {"line": "by_cases hn : n = 0", "tactic_state": "case pos\nx\u271d : Type u_1\nlog : x\u271d\nn : \u2115\nhn : n = 0\n\u22a2 sorry = sorry\n---\ncase neg\nx\u271d : Type u_1\nlog : x\u271d\nn : \u2115\nhn : \u00acn = 0\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp [hn, posLog]", "tactic_state": "case neg\nx\u271d : Type u_1\nlog : x\u271d\nn : \u2115\nhn : \u00acn = 0\n\u22a2 sorry = sorry"}, {"line": "\u00b7 simp [posLog_eq_log, Nat.one_le_iff_ne_zero.2 hn]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem posLog_add {a b : \u211d} : log\u207a (a + b) \u2264 log 2 + log\u207a a + log\u207a b := by\n  convert posLog_sum Finset.univ ![a, b] using 1 <;> simp [add_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/PosLog.lean", "context": {"open": [], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Type u_1\nlog : x\u271d\na b : \u211d\n\u22a2 sorry \u2264 sorry + sorry + sorry"}, {"line": "convert posLog_sum Finset.univ ![a, b] using 1 <;> simp [add_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logb_zero : logb b 0 = 0 := by simp [logb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [logb]", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem logb_one : logb b 1 = 0 := by simp [logb]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [logb]", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem logb_inv (x : \u211d) : logb b x\u207b\u00b9 = -logb b x := by simp [logb, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\nx : \u211d\n\u22a2 sorry = -sorry"}, {"line": "simp [logb, neg_div]", "tactic_state": "x\u271d : Sort u_1\nlogb : x\u271d\nx : \u211d\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "private theorem log_b_ne_zero : log b \u2260 0 := by\n  have b_ne_zero : b \u2260 0 := by linarith\n  have b_ne_minus_one : b \u2260 -1 := by linarith\n  simp [b_ne_one, b_ne_zero, b_ne_minus_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\n\u22a2 sorry \u2260 0"}, {"line": "have b_ne_zero : b \u2260 0 := sorry", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb_ne_zero : sorry \u2260 0\n\u22a2 sorry \u2260 0"}, {"line": "have b_ne_minus_one : b \u2260 -1 := sorry", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nb_ne_zero : sorry \u2260 0\nb_ne_minus_one : sorry \u2260 -1\n\u22a2 sorry \u2260 0"}, {"line": "simp [b_ne_one, b_ne_zero, b_ne_minus_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logb_eq_iff_rpow_eq (hy : 0 < y) : logb b y = x \u2194 b ^ x = y := by\n  constructor <;> rintro rfl\n  \u00b7 exact rpow_logb b_pos b_ne_one hy\n  \u00b7 exact logb_rpow b_pos b_ne_one\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b x y : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhy : 0 < y\n\u22a2 sorry = x \u2194 b ^ x = y"}, {"line": "constructor <;> rintro rfl", "tactic_state": "case mp\nb y : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhy : 0 < y\n\u22a2 b ^ sorry = y\n---\ncase mpr\nb x : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhy : 0 < b ^ x\n\u22a2 sorry = x"}, {"line": "\u00b7 exact rpow_logb b_pos b_ne_one hy", "tactic_state": "case mpr\nb x : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhy : 0 < b ^ x\n\u22a2 sorry = x"}, {"line": "\u00b7 exact logb_rpow b_pos b_ne_one", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logb_nonpos_iff' (hx : 0 \u2264 x) : logb b x \u2264 0 \u2194 x \u2264 1 := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  \u00b7 simp [le_refl, zero_le_one]\n  exact logb_nonpos_iff hb hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)", "(hb : 1 < b)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhx : 0 \u2264 x\n\u22a2 sorry \u2264 0 \u2194 x \u2264 1"}, {"line": "rcases hx.eq_or_lt with (rfl | hx)", "tactic_state": "case inl\nx\u271d : Sort u_1\nlogb : x\u271d\nhx : 0 \u2264 0\n\u22a2 sorry \u2264 0 \u2194 0 \u2264 1\n---\ncase inr\nx : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 0 \u2194 x \u2264 1"}, {"line": "\u00b7 simp [le_refl, zero_le_one]", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\nlogb : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 0 \u2194 x \u2264 1"}, {"line": "exact logb_nonpos_iff hb hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma natLog_le_logb (a b : \u2115) : Nat.log b a \u2264 Real.logb b a := by\n  apply le_trans _ (Int.floor_le ((b : \u211d).logb a))\n  rw [Real.floor_logb_natCast (Nat.cast_nonneg a)]\n  rw [Int.log_natCast]\n  rw [Int.cast_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)", "(hb : 1 < b)", "(b_pos : 0 < b) (b_lt_one : b < 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2115\n\u22a2 \u2191(Nat.log b a) \u2264 Real.logb \u2191b \u2191a"}, {"line": "apply le_trans _ (Int.floor_le ((b : \u211d).logb a))", "tactic_state": "a b : \u2115\n\u22a2 \u2191(Nat.log b a) \u2264 \u2191\u230aReal.logb \u2191b \u2191a\u230b"}, {"line": "rw [Real.floor_logb_natCast (Nat.cast_nonneg a)]", "tactic_state": "a b : \u2115\n\u22a2 \u2191(Nat.log b a) \u2264 \u2191(Int.log b \u2191a)"}, {"line": "rw [Int.log_natCast]", "tactic_state": "a b : \u2115\n\u22a2 \u2191(Nat.log b a) \u2264 \u2191\u2191(Nat.log b a)"}, {"line": "rw [Int.cast_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem logb_prod {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d) (hf : \u2200 x \u2208 s, f x \u2260 0) :\n    logb b (\u220f i \u2208 s, f i) = \u2211 i \u2208 s, logb b (f i) := by\n  classical\n    induction' s using Finset.induction_on with a s ha ih\n    \u00b7 simp\n    simp only [Finset.mem_insert] at hf\n    simp only [forall_eq_or_imp] at hf\n    simp [ha, ih hf.2, logb_mul hf.1 (Finset.prod_ne_zero_iff.2 hf.2)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Base.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{b x y : \u211d}", "(b_pos : 0 < b) (b_ne_one : b \u2260 1)", "(hb : 1 < b)", "(b_pos : 0 < b) (b_lt_one : b < 1)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_2\nlogb : x\u271d\n\u03b1 : Type u_1\ns : Finset \u03b1\nf : \u03b1 \u2192 \u211d\nhf : \u2200 x \u2208 s, f x \u2260 0\n\u22a2 sorry = \u2211 i \u2208 s, ?m.837"}, {"line": "classical\n    induction' s using Finset.induction_on with a s ha ih\n    \u00b7 simp\n    simp only [Finset.mem_insert] at hf\n    simp only [forall_eq_or_imp] at hf\n    simp [ha, ih hf.2, logb_mul hf.1 (Finset.prod_ne_zero_iff.2 hf.2)]", "tactic_state": "case insert\nx\u271d : Sort u_2\nlogb : x\u271d\n\u03b1 : Type u_1\nf : \u03b1 \u2192 \u211d\na : \u03b1\ns : Finset \u03b1\nha : a \u2209 s\nih : \u2200 (hf : \u2200 x \u2208 s, f x \u2260 0), sorry = \u2211 i \u2208 s, ?m.837\nhf\u271d : \u2200 x \u2208 insert a s, f x \u2260 0\nhf : f a \u2260 0 \u2227 \u2200 a \u2208 s, f a \u2260 0\n\u22a2 sorry () = \u2211 i \u2208 insert a s, ?m.4110 (insert a s) f hf\u271d i"}]}
{"declaration": "theorem log_ne_zero {x : \u211d} : log x \u2260 0 \u2194 x \u2260 0 \u2227 x \u2260 1 \u2227 x \u2260 -1 := by\n  simpa only [not_or] using log_eq_zero.not\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\n\u22a2 sorry \u2260 0 \u2194 x \u2260 0 \u2227 x \u2260 1 \u2227 x \u2260 -1"}, {"line": "simpa only [not_or] using log_eq_zero.not", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_zpow (x : \u211d) (n : \u2124) : log (x ^ n) = n * log x := by\n  cases n\n  \u00b7 rw [Int.ofNat_eq_coe, zpow_natCast, log_pow, Int.cast_natCast]\n  \u00b7 rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\nn : \u2124\n\u22a2 sorry = n * sorry"}, {"line": "cases n", "tactic_state": "case ofNat\nx\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\na\u271d : \u2115\n\u22a2 sorry = Int.ofNat a\u271d * sorry\n---\ncase negSucc\nx\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\na\u271d : \u2115\n\u22a2 sorry = Int.negSucc a\u271d * sorry"}, {"line": "\u00b7 rw [Int.ofNat_eq_coe, zpow_natCast, log_pow, Int.cast_natCast]", "tactic_state": "case negSucc\nx\u271d : Sort u_1\nlog : x\u271d\nx : \u211d\na\u271d : \u2115\n\u22a2 sorry = Int.negSucc a\u271d * sorry"}, {"line": "\u00b7 rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_sub_inv_le_log_of_pos (hx : 0 < x) : 1 - x\u207b\u00b9 \u2264 log x := by\n  simpa [add_comm] using log_le_sub_one_of_pos (inv_pos.2 hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nlog : x\u271d\nhx : 0 < x\n\u22a2 1 - x\u207b\u00b9 \u2264 sorry"}, {"line": "simpa [add_comm] using log_le_sub_one_of_pos (inv_pos.2 hx)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma log_le_self (hx : 0 \u2264 x) : log x \u2264 x := by\n  obtain rfl | hx := hx.eq_or_lt\n  \u00b7 simp\n  \u00b7 exact (log_le_sub_one_of_pos hx).trans (by linarith)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Basic.lean", "context": {"open": ["Set Filter Function", "Topology"], "variables": ["{x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nlog : x\u271d\nhx : 0 \u2264 x\n\u22a2 sorry \u2264 x"}, {"line": "obtain rfl | hx := hx.eq_or_lt", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\nhx : 0 \u2264 0\n\u22a2 sorry \u2264 0\n---\ncase inr\nx : \u211d\nx\u271d : Sort u_1\nlog : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\nlog : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 exact (log_le_sub_one_of_pos hx).trans (by linarith)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_log_one_add_of_nonneg {x : \u211d} (hx : 0 \u2264 x) : 2 * x / (x + 2) \u2264 log (1 + x) := by\n  convert le_hasSum (hasSum_log_one_add hx) 0 (by intros; positivity) using 1\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "context": {"open": ["Filter Finset Set", "scoped Topology ContDiff", "Real"], "variables": ["{x : \u211d}", "{f : \u211d \u2192 \u211d} {x f' : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {x : E} {f' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\n\u22a2 2 * x / (x + 2) \u2264 log (1 + x)"}, {"line": "convert le_hasSum (hasSum_log_one_add hx) 0 (by intros; positivity) using 1", "tactic_state": "case h.e'_3\nx : \u211d\nhx : 0 \u2264 x\n\u22a2 2 * x / (x + 2) = 2 * (1 / (2 * \u21910 + 1)) * (x / (x + 2)) ^ (2 * 0 + 1)"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_log_one_add_of_pos {x : \u211d} (hx : 0 < x) : 2 * x / (x + 2) < log (1 + x) := by\n  convert lt_hasSum (hasSum_log_one_add hx.le) 0 (by intros; positivity)\n    1 (by positivity) (by positivity) using 1\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Deriv.lean", "context": {"open": ["Filter Finset Set", "scoped Topology ContDiff", "Real"], "variables": ["{x : \u211d}", "{f : \u211d \u2192 \u211d} {x f' : \u211d} {s : Set \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f : E \u2192 \u211d} {x : E} {f' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\n\u22a2 2 * x / (x + 2) < log (1 + x)"}, {"line": "convert lt_hasSum (hasSum_log_one_add hx.le) 0 (by intros; positivity)\n    1 (by positivity) (by positivity) using 1", "tactic_state": "case h.e'_3\nx : \u211d\nhx : 0 < x\n\u22a2 2 * x / (x + 2) = 2 * (1 / (2 * \u21910 + 1)) * (x / (x + 2)) ^ (2 * 0 + 1)"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_neg (x : EReal) : exp (-x) = (exp x)\u207b\u00b9 := by\n  induction x\n  \u00b7 simp\n  \u00b7 rw [exp_coe, \u2190 EReal.coe_neg, exp_coe, \u2190 ENNReal.ofReal_inv_of_pos (Real.exp_pos _),\n      Real.exp_neg]\n  \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/ERealExp.lean", "context": {"open": ["scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexp : x\u271d\nx : EReal\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "induction x", "tactic_state": "case bot\nx\u271d : Sort u_1\nexp : x\u271d\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase coe\nx\u271d : Sort u_1\nexp : x\u271d\na\u271d : \u211d\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase top\nx\u271d : Sort u_1\nexp : x\u271d\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "case coe\nx\u271d : Sort u_1\nexp : x\u271d\na\u271d : \u211d\n\u22a2 sorry = sorry\u207b\u00b9\n---\ncase top\nx\u271d : Sort u_1\nexp : x\u271d\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 rw [exp_coe, \u2190 EReal.coe_neg, exp_coe, \u2190 ENNReal.ofReal_inv_of_pos (Real.exp_pos _),\n      Real.exp_neg]", "tactic_state": "case top\nx\u271d : Sort u_1\nexp : x\u271d\n\u22a2 sorry = sorry\u207b\u00b9"}, {"line": "\u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma exp_add (x y : EReal) : exp (x + y) = exp x * exp y := by\n  induction x\n  \u00b7 simp\n  \u00b7 induction y\n    \u00b7 simp\n    \u00b7 simp only [\u2190 EReal.coe_add, exp_coe]\n      rw [\u2190 ENNReal.ofReal_mul (Real.exp_nonneg _)]\n      rw [Real.exp_add]\n    \u00b7 simp only [EReal.coe_add_top, exp_top, exp_coe]\n      rw [ENNReal.mul_top]\n      simp [Real.exp_pos]\n  \u00b7 induction y\n    \u00b7 simp\n    \u00b7 simp only [EReal.top_add_coe, exp_top, exp_coe]\n      rw [ENNReal.top_mul]\n      simp [Real.exp_pos]\n    \u00b7 simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/ERealExp.lean", "context": {"open": ["scoped ENNReal"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nexp : x\u271d\nx y : EReal\n\u22a2 sorry = sorry * sorry"}, {"line": "induction x", "tactic_state": "case bot\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\n\u22a2 sorry = sorry * sorry\n---\ncase coe\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\na\u271d : \u211d\n\u22a2 sorry = sorry * sorry\n---\ncase top\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\n\u22a2 sorry = sorry * sorry"}, {"line": "\u00b7 simp", "tactic_state": "case coe\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\na\u271d : \u211d\n\u22a2 sorry = sorry * sorry\n---\ncase top\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\n\u22a2 sorry = sorry * sorry"}, {"line": "\u00b7 induction y\n    \u00b7 simp\n    \u00b7 simp only [\u2190 EReal.coe_add, exp_coe]\n      rw [\u2190 ENNReal.ofReal_mul (Real.exp_nonneg _)]\n      rw [Real.exp_add]\n    \u00b7 simp only [EReal.coe_add_top, exp_top, exp_coe]\n      rw [ENNReal.mul_top]\n      simp [Real.exp_pos]", "tactic_state": "case top\nx\u271d : Sort u_1\nexp : x\u271d\ny : EReal\n\u22a2 sorry = sorry * sorry"}, {"line": "\u00b7 induction y\n    \u00b7 simp\n    \u00b7 simp only [EReal.top_add_coe, exp_top, exp_coe]\n      rw [ENNReal.top_mul]\n      simp [Real.exp_pos]\n    \u00b7 simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma negMulLog_nonneg {x : \u211d} (h1 : 0 \u2264 x) (h2 : x \u2264 1) : 0 \u2264 negMulLog x := by\n  simpa only [negMulLog_eq_neg,neg_nonneg] using mul_log_nonpos h1 h2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean", "context": {"open": ["scoped Topology", "Filter in", "Filter in", "Filter in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nnegMulLog : x\u271d\nx : \u211d\nh1 : 0 \u2264 x\nh2 : x \u2264 1\n\u22a2 0 \u2264 sorry"}, {"line": "simpa only [negMulLog_eq_neg,neg_nonneg] using mul_log_nonpos h1 h2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma differentiableOn_negMulLog : DifferentiableOn \u211d negMulLog {0}\u1d9c := by\n  simpa only [negMulLog_eq_neg] using differentiableOn_mul_log.neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/NegMulLog.lean", "context": {"open": ["scoped Topology", "Filter in", "Filter in", "Filter in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "F\u271d : Type u_1\nnegMulLog : \u2115 \u2192 F\u271d\n\u22a2 DifferentiableOn \u211d negMulLog {0}\u1d9c"}, {"line": "simpa only [negMulLog_eq_neg] using differentiableOn_mul_log.neg", "tactic_state": "No Goals!"}]}
{"declaration": "lemma multipliable_of_summable_log (hf : Summable fun i \u21a6 log (f i)) :\n    Multipliable f := by\n  by_cases hfn : \u2203 n, f n = 0\n  \u00b7 exact multipliable_of_exists_eq_zero hfn\n  \u00b7 exact \u27e8_, hasProd_of_hasSum_log (not_exists.mp hfn) hf.hasSum\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Summable.lean", "context": {"open": ["Filter Topology NNReal"], "variables": ["{\u03b9 : Type*}", "{f : \u03b9 \u2192 \u2102} {a : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nf : \u03b9 \u2192 \u2102\nx\u271d : Sort u_2\nlog : x\u271d\nhf : Summable fun i => ?m.927\n\u22a2 Multipliable f"}, {"line": "by_cases hfn : \u2203 n, f n = 0", "tactic_state": "case pos\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u2102\nx\u271d : Sort u_2\nlog : x\u271d\nhf : Summable fun i => ?m.927\nhfn : \u2203 n, f n = 0\n\u22a2 Multipliable f\n---\ncase neg\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u2102\nx\u271d : Sort u_2\nlog : x\u271d\nhf : Summable fun i => ?m.927\nhfn : \u00ac\u2203 n, f n = 0\n\u22a2 Multipliable f"}, {"line": "\u00b7 exact multipliable_of_exists_eq_zero hfn", "tactic_state": "case neg\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u2102\nx\u271d : Sort u_2\nlog : x\u271d\nhf : Summable fun i => ?m.927\nhfn : \u00ac\u2203 n, f n = 0\n\u22a2 Multipliable f"}, {"line": "\u00b7 exact \u27e8_, hasProd_of_hasSum_log (not_exists.mp hfn) hf.hasSum\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Multipliable.eventually_bounded_finset_prod {v : \u03b9 \u2192 \u211d} (hv : Multipliable v) :\n    \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 t, s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081 := by\n  obtain \u27e8r\u2081, hr\u2081\u27e9 := exists_gt (max 0 <| \u220f' i, v i)\n  rw [max_lt_iff] at hr\u2081\n  have := hv.hasProd.eventually_le_const hr\u2081.2\n  rw [eventually_atTop] at this\n  exact \u27e8r\u2081, hr\u2081.1, this\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Log/Summable.lean", "context": {"open": ["Filter Topology NNReal", "Complex in"], "variables": ["{\u03b9 : Type*}", "{f : \u03b9 \u2192 \u2102} {a : \u2102}", "{f : \u03b9 \u2192 \u211d} {a : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nv : \u03b9 \u2192 \u211d\nhv : Multipliable v\n\u22a2 \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 (t : Finset \u03b9), s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081"}, {"line": "obtain \u27e8r\u2081, hr\u2081\u27e9 := exists_gt (max 0 <| \u220f' i, v i)", "tactic_state": "case intro\n\u03b9 : Type u_1\nv : \u03b9 \u2192 \u211d\nhv : Multipliable v\nr\u2081 : \u211d\nhr\u2081 : max 0 (\u220f' (i : \u03b9), v i) < r\u2081\n\u22a2 \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 (t : Finset \u03b9), s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081"}, {"line": "rw [max_lt_iff] at hr\u2081", "tactic_state": "case intro\n\u03b9 : Type u_1\nv : \u03b9 \u2192 \u211d\nhv : Multipliable v\nr\u2081 : \u211d\nhr\u2081 : 0 < r\u2081 \u2227 \u220f' (i : \u03b9), v i < r\u2081\n\u22a2 \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 (t : Finset \u03b9), s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081"}, {"line": "have := hv.hasProd.eventually_le_const hr\u2081.2", "tactic_state": "case intro\n\u03b9 : Type u_1\nv : \u03b9 \u2192 \u211d\nhv : Multipliable v\nr\u2081 : \u211d\nhr\u2081 : 0 < r\u2081 \u2227 \u220f' (i : \u03b9), v i < r\u2081\nthis : \u2200\u1da0 (a : Finset \u03b9) in atTop, \u220f b \u2208 a, v b \u2264 r\u2081\n\u22a2 \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 (t : Finset \u03b9), s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081"}, {"line": "rw [eventually_atTop] at this", "tactic_state": "case intro\n\u03b9 : Type u_1\nv : \u03b9 \u2192 \u211d\nhv : Multipliable v\nr\u2081 : \u211d\nhr\u2081 : 0 < r\u2081 \u2227 \u220f' (i : \u03b9), v i < r\u2081\nthis : \u2203 a, \u2200 b \u2265 a, \u220f b \u2208 b, v b \u2264 r\u2081\n\u22a2 \u2203 r\u2081 > 0, \u2203 s\u2081, \u2200 (t : Finset \u03b9), s\u2081 \u2286 t \u2192 \u220f i \u2208 t, v i \u2264 r\u2081"}, {"line": "exact \u27e8r\u2081, hr\u2081.1, this\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cpow_zero (x : \u2102) : x ^ (0 : \u2102) = 1 := by simp [cpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 x ^ 0 = 1"}, {"line": "simp [cpow_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cpow_ne_zero_iff_of_exponent_ne_zero {x y : \u2102} (hy : y \u2260 0) :\n    x ^ y \u2260 0 \u2194 x \u2260 0 := by simp [hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u2102\nhy : y \u2260 0\n\u22a2 x ^ y \u2260 0 \u2194 x \u2260 0"}, {"line": "simp [hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_cpow {x : \u2102} (h : x \u2260 0) : (0 : \u2102) ^ x = 0 := by simp [cpow_def, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nh : x \u2260 0\n\u22a2 0 ^ x = 0"}, {"line": "simp [cpow_def, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cpow_neg_one (x : \u2102) : x ^ (-1 : \u2102) = x\u207b\u00b9 := by simpa using cpow_neg x 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 x ^ (-1) = x\u207b\u00b9"}, {"line": "simpa using cpow_neg x 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cpow_natCast (x : \u2102) (n : \u2115) : x ^ (n : \u2102) = x ^ n := by simpa using cpow_nat_mul x n 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nn : \u2115\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "simpa using cpow_nat_mul x n 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cpow_intCast (x : \u2102) (n : \u2124) : x ^ (n : \u2102) = x ^ n := by simpa using cpow_int_mul x n 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Complex.lean", "context": {"open": ["Real Topology Filter ComplexConjugate Finset Set"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\nn : \u2124\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "simpa using cpow_int_mul x n 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_rpow_atTop {y : \u211d} (hy : 0 < y) : Tendsto (fun x : \u211d => x ^ y) atTop atTop := by\n  rw [(atTop_basis' 0).tendsto_right_iff]\n  intro b hb\n  filter_upwards [eventually_ge_atTop 0, eventually_ge_atTop (b ^ (1 / y))] with x hx\u2080 hx\n  simpa (disch := positivity) [Real.rpow_inv_le_iff_of_pos] using hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nhy : 0 < y\n\u22a2 Tendsto (fun x => x ^ y) atTop atTop"}, {"line": "rw [(atTop_basis' 0).tendsto_right_iff]", "tactic_state": "y : \u211d\nhy : 0 < y\n\u22a2 \u2200 (i : \u211d), 0 \u2264 i \u2192 \u2200\u1da0 (x : \u211d) in atTop, x ^ y \u2208 Set.Ici i"}, {"line": "intro b hb", "tactic_state": "y : \u211d\nhy : 0 < y\nb : \u211d\nhb : 0 \u2264 b\n\u22a2 \u2200\u1da0 (x : \u211d) in atTop, x ^ y \u2208 Set.Ici b"}, {"line": "filter_upwards [eventually_ge_atTop 0, eventually_ge_atTop (b ^ (1 / y))] with x hx\u2080 hx", "tactic_state": "case h\ny : \u211d\nhy : 0 < y\nb : \u211d\nhb : 0 \u2264 b\nx : \u211d\nhx\u2080 : 0 \u2264 x\nhx : b ^ (1 / y) \u2264 x\n\u22a2 x ^ y \u2208 Set.Ici b"}, {"line": "simpa (disch := positivity) [Real.rpow_inv_le_iff_of_pos] using hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_rpow_atTop_of_base_lt_one (b : \u211d) (hb\u2080 : -1 < b) (hb\u2081 : b < 1) :\n    Tendsto (b ^ \u00b7 : \u211d \u2192 \u211d) atTop (\ud835\udcdd (0 : \u211d)) := by\n  rcases lt_trichotomy b 0 with hb|rfl|hb\n  case inl => -- b < 0\n    simp_rw [Real.rpow_def_of_nonpos hb.le, hb.ne, ite_false]\n    rw [\u2190 isLittleO_const_iff (c := (1 : \u211d)) one_ne_zero]\n    rw [(one_mul (1 : \u211d)).symm]\n    refine IsLittleO.mul_isBigO ?exp ?cos\n    case exp =>\n      rw [isLittleO_const_iff one_ne_zero]\n      refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n      rw [\u2190 log_neg_eq_log]\n      rw [log_neg_iff (by linarith)]\n      linarith\n    case cos =>\n      rw [isBigO_iff]\n      exact \u27e81, Eventually.of_forall fun x => by simp [Real.abs_cos_le_one]\u27e9\n  case inr.inl => -- b = 0\n    refine Tendsto.mono_right ?_ (Iff.mpr pure_le_nhds_iff rfl)\n    rw [tendsto_pure]\n    filter_upwards [eventually_ne_atTop 0] with _ hx\n    simp [hx]\n  case inr.inr => -- b > 0\n    simp_rw [Real.rpow_def_of_pos hb]\n    refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n    exact (log_neg_iff hb).mpr hb\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\n\u22a2 Tendsto (fun x => b ^ x) atTop (nhds 0)"}, {"line": "rcases lt_trichotomy b 0 with hb|rfl|hb", "tactic_state": "case inl\nb : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\nhb : b < 0\n\u22a2 Tendsto (fun x => b ^ x) atTop (nhds 0)\n---\ncase inr.inl\nhb\u2080 : -1 < 0\nhb\u2081 : 0 < 1\n\u22a2 Tendsto (fun x => 0 ^ x) atTop (nhds 0)\n---\ncase inr.inr\nb : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\nhb : 0 < b\n\u22a2 Tendsto (fun x => b ^ x) atTop (nhds 0)"}, {"line": "case inl => -- b < 0\n    simp_rw [Real.rpow_def_of_nonpos hb.le, hb.ne, ite_false]\n    rw [\u2190 isLittleO_const_iff (c := (1 : \u211d)) one_ne_zero]\n    rw [(one_mul (1 : \u211d)).symm]\n    refine IsLittleO.mul_isBigO ?exp ?cos\n    case exp =>\n      rw [isLittleO_const_iff one_ne_zero]\n      refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n      rw [\u2190 log_neg_eq_log]\n      rw [log_neg_iff (by linarith)]\n      linarith\n    case cos =>\n      rw [isBigO_iff]\n      exact \u27e81, Eventually.of_forall fun x => by simp [Real.abs_cos_le_one]\u27e9", "tactic_state": "case inr.inl\nhb\u2080 : -1 < 0\nhb\u2081 : 0 < 1\n\u22a2 Tendsto (fun x => 0 ^ x) atTop (nhds 0)\n---\ncase inr.inr\nb : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\nhb : 0 < b\n\u22a2 Tendsto (fun x => b ^ x) atTop (nhds 0)"}, {"line": "case inr.inl => -- b = 0\n    refine Tendsto.mono_right ?_ (Iff.mpr pure_le_nhds_iff rfl)\n    rw [tendsto_pure]\n    filter_upwards [eventually_ne_atTop 0] with _ hx\n    simp [hx]", "tactic_state": "case inr.inr\nb : \u211d\nhb\u2080 : -1 < b\nhb\u2081 : b < 1\nhb : 0 < b\n\u22a2 Tendsto (fun x => b ^ x) atTop (nhds 0)"}, {"line": "case inr.inr => -- b > 0\n    simp_rw [Real.rpow_def_of_pos hb]\n    refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_neg ?_).mpr tendsto_id\n    exact (log_neg_iff hb).mpr hb\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_rpow_atTop_of_base_gt_one (b : \u211d) (hb : 1 < b) :\n    Tendsto (b ^ \u00b7 : \u211d \u2192 \u211d) atBot (\ud835\udcdd (0 : \u211d)) := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_pos ?_).mpr tendsto_id\n  exact (log_pos_iff (by positivity)).mpr <| by aesop\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 Tendsto (fun x => b ^ x) atBot (nhds 0)"}, {"line": "simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 Tendsto (fun x => exp (Real.log b * x)) atBot (nhds 0)"}, {"line": "refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_of_pos ?_).mpr tendsto_id", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 0 < Real.log b"}, {"line": "exact (log_pos_iff (by positivity)).mpr <| by aesop", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_rpow_atBot_of_base_lt_one (b : \u211d) (hb\u2080 : 0 < b) (hb\u2081 : b < 1) :\n    Tendsto (b ^ \u00b7 : \u211d \u2192 \u211d) atBot atTop := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atTop.comp <| (tendsto_const_mul_atTop_iff_neg <| tendsto_id (\u03b1 := \u211d)).mpr ?_\n  exact (log_neg_iff hb\u2080).mpr hb\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b < 1\n\u22a2 Tendsto (fun x => b ^ x) atBot atTop"}, {"line": "simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b < 1\n\u22a2 Tendsto (fun x => exp (Real.log b * x)) atBot atTop"}, {"line": "refine tendsto_exp_atTop.comp <| (tendsto_const_mul_atTop_iff_neg <| tendsto_id (\u03b1 := \u211d)).mpr ?_", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b < 1\n\u22a2 Real.log b < 0"}, {"line": "exact (log_neg_iff hb\u2080).mpr hb\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "lemma tendsto_rpow_atBot_of_base_gt_one (b : \u211d) (hb : 1 < b) :\n    Tendsto (b ^ \u00b7 : \u211d \u2192 \u211d) atBot (\ud835\udcdd 0) := by\n  simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]\n  refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_iff_pos <| tendsto_id (\u03b1 := \u211d)).mpr ?_\n  exact (log_pos_iff (by positivity)).mpr <| by aesop\n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 Tendsto (fun x => b ^ x) atBot (nhds 0)"}, {"line": "simp_rw [Real.rpow_def_of_pos (by positivity : 0 < b)]", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 Tendsto (fun x => exp (Real.log b * x)) atBot (nhds 0)"}, {"line": "refine tendsto_exp_atBot.comp <| (tendsto_const_mul_atBot_iff_pos <| tendsto_id (\u03b1 := \u211d)).mpr ?_", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 0 < Real.log b"}, {"line": "exact (log_pos_iff (by positivity)).mpr <| by aesop", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_rpow_div_mul_add (a b c : \u211d) (hb : 0 \u2260 b) :\n    Tendsto (fun x => x ^ (a / (b * x + c))) atTop (\ud835\udcdd 1) := by\n  refine\n    Tendsto.congr' ?_\n      ((tendsto_exp_nhds_zero_nhds_one.comp\n            (by\n              simpa only [mul_zero,pow_one] using\n                (tendsto_const_nhds (x := a)).mul\n                  (tendsto_div_pow_mul_exp_add_atTop b c 1 hb))).comp\n        tendsto_log_atTop)\n  apply eventuallyEq_of_mem (Ioi_mem_atTop (0 : \u211d))\n  intro x hx\n  simp only [Set.mem_Ioi] at hx \u22a2\n  simp only [Function.comp_apply] at hx \u22a2\n  rw [exp_log hx]\n  rw [\u2190 exp_log (rpow_pos_of_pos hx (a / (b * x + c)))]\n  rw [log_rpow hx (a / (b * x + c))]\n  field_simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\n\u22a2 Tendsto (fun x => x ^ (a / (b * x + c))) atTop (nhds 1)"}, {"line": "refine\n    Tendsto.congr' ?_\n      ((tendsto_exp_nhds_zero_nhds_one.comp\n            (by\n              simpa only [mul_zero,pow_one] using\n                (tendsto_const_nhds (x := a)).mul\n                  (tendsto_div_pow_mul_exp_add_atTop b c 1 hb))).comp\n        tendsto_log_atTop)", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\n\u22a2 (exp \u2218 fun x => a * (x / (b * exp x + c))) \u2218 Real.log =\u1da0[atTop] fun x => x ^ (a / (b * x + c))"}, {"line": "apply eventuallyEq_of_mem (Ioi_mem_atTop (0 : \u211d))", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\n\u22a2 EqOn ((exp \u2218 fun x => a * (x / (b * exp x + c))) \u2218 Real.log) (fun x => x ^ (a / (b * x + c))) (Set.Ioi 0)"}, {"line": "intro x hx", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : x \u2208 Set.Ioi 0\n\u22a2 ((exp \u2218 fun x => a * (x / (b * exp x + c))) \u2218 Real.log) x = (fun x => x ^ (a / (b * x + c))) x"}, {"line": "simp only [Set.mem_Ioi] at hx \u22a2", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : 0 < x\n\u22a2 ((exp \u2218 fun x => a * (x / (b * exp x + c))) \u2218 Real.log) x = x ^ (a / (b * x + c))"}, {"line": "simp only [Function.comp_apply] at hx \u22a2", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : 0 < x\n\u22a2 exp (a * (Real.log x / (b * exp (Real.log x) + c))) = x ^ (a / (b * x + c))"}, {"line": "rw [exp_log hx]", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : 0 < x\n\u22a2 exp (a * (Real.log x / (b * x + c))) = x ^ (a / (b * x + c))"}, {"line": "rw [\u2190 exp_log (rpow_pos_of_pos hx (a / (b * x + c)))]", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : 0 < x\n\u22a2 exp (a * (Real.log x / (b * x + c))) = exp (Real.log (x ^ (a / (b * x + c))))"}, {"line": "rw [log_rpow hx (a / (b * x + c))]", "tactic_state": "a b c : \u211d\nhb : 0 \u2260 b\nx : \u211d\nhx : 0 < x\n\u22a2 exp (a * (Real.log x / (b * x + c))) = exp (a / (b * x + c) * Real.log x)"}, {"line": "field_simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_rpow_div : Tendsto (fun x => x ^ ((1 : \u211d) / x)) atTop (\ud835\udcdd 1) := by\n  convert tendsto_rpow_div_mul_add (1 : \u211d) _ (0 : \u211d) zero_ne_one\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto (fun x => x ^ (1 / x)) atTop (nhds 1)"}, {"line": "convert tendsto_rpow_div_mul_add (1 : \u211d) _ (0 : \u211d) zero_ne_one", "tactic_state": "case h.e'_3.h.h.e'_6.h.e'_6\nx\u271d : \u211d\n\u22a2 x\u271d = 1 * x\u271d + 0"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_rpow_neg_div : Tendsto (fun x => x ^ (-(1 : \u211d) / x)) atTop (\ud835\udcdd 1) := by\n  convert tendsto_rpow_div_mul_add (-(1 : \u211d)) _ (0 : \u211d) zero_ne_one\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto (fun x => x ^ (-1 / x)) atTop (nhds 1)"}, {"line": "convert tendsto_rpow_div_mul_add (-(1 : \u211d)) _ (0 : \u211d) zero_ne_one", "tactic_state": "case h.e'_3.h.h.e'_6.h.e'_6\nx\u271d : \u211d\n\u22a2 x\u271d = 1 * x\u271d + 0"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_exp_div_rpow_atTop (s : \u211d) : Tendsto (fun x : \u211d => exp x / x ^ s) atTop atTop := by\n  obtain \u27e8n, hn\u27e9 := archimedean_iff_nat_lt.1 Real.instArchimedean s\n  refine tendsto_atTop_mono' _ ?_ (tendsto_exp_div_pow_atTop n)\n  filter_upwards [eventually_gt_atTop (0 : \u211d), eventually_ge_atTop (1 : \u211d)] with x hx\u2080 hx\u2081\n  gcongr\n  simpa using rpow_le_rpow_of_exponent_le hx\u2081 hn.le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 Tendsto (fun x => exp x / x ^ s) atTop atTop"}, {"line": "obtain \u27e8n, hn\u27e9 := archimedean_iff_nat_lt.1 Real.instArchimedean s", "tactic_state": "case intro\ns : \u211d\nn : \u2115\nhn : s < \u2191n\n\u22a2 Tendsto (fun x => exp x / x ^ s) atTop atTop"}, {"line": "refine tendsto_atTop_mono' _ ?_ (tendsto_exp_div_pow_atTop n)", "tactic_state": "case intro\ns : \u211d\nn : \u2115\nhn : s < \u2191n\n\u22a2 (fun x => exp x / x ^ n) \u2264\u1da0[atTop] fun x => exp x / x ^ s"}, {"line": "filter_upwards [eventually_gt_atTop (0 : \u211d), eventually_ge_atTop (1 : \u211d)] with x hx\u2080 hx\u2081", "tactic_state": "case h\ns : \u211d\nn : \u2115\nhn : s < \u2191n\nx : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : 1 \u2264 x\n\u22a2 exp x / x ^ n \u2264 exp x / x ^ s"}, {"line": "gcongr", "tactic_state": "case h.h\ns : \u211d\nn : \u2115\nhn : s < \u2191n\nx : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : 1 \u2264 x\n\u22a2 x ^ s \u2264 x ^ n"}, {"line": "simpa using rpow_le_rpow_of_exponent_le hx\u2081 hn.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero (s : \u211d) (b : \u211d) (hb : 0 < b) :\n    Tendsto (fun x : \u211d => x ^ s * exp (-b * x)) atTop (\ud835\udcdd 0) := by\n  refine (tendsto_exp_mul_div_rpow_atTop s b hb).inv_tendsto_atTop.congr' ?_\n  filter_upwards with x using by simp [exp_neg, inv_div, div_eq_mul_inv _ (exp _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "s b : \u211d\nhb : 0 < b\n\u22a2 Tendsto (fun x => x ^ s * exp (-b * x)) atTop (nhds 0)"}, {"line": "refine (tendsto_exp_mul_div_rpow_atTop s b hb).inv_tendsto_atTop.congr' ?_", "tactic_state": "s b : \u211d\nhb : 0 < b\n\u22a2 (fun x => exp (b * x) / x ^ s)\u207b\u00b9 =\u1da0[atTop] fun x => x ^ s * exp (-b * x)"}, {"line": "filter_upwards with x using by simp [exp_neg, inv_div, div_eq_mul_inv _ (exp _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isTheta_exp_arg_mul_im (hl : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |(g x).im|) :\n    (fun x => Real.exp (arg (f x) * im (g x))) =\u0398[l] fun _ => (1 : \u211d) := by\n  rcases hl with \u27e8b, hb\u27e9\n  refine Real.isTheta_exp_comp_one.2 \u27e8\u03c0 * b, ?_\u27e9\n  rw [eventually_map] at hb \u22a2\n  refine hb.mono fun x hx => ?_\n  rw [abs_mul]\n  exact mul_le_mul (abs_arg_le_pi _) hx (abs_nonneg _) Real.pi_pos.le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nhl : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) l fun x => |(g x).im|\n\u22a2 (fun x => exp (sorry * sorry)) =\u0398[l] fun x => 1"}, {"line": "rcases hl with \u27e8b, hb\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nb : \u211d\nhb : \u2200\u1da0 (x : \u211d) in Filter.map (fun x => |(g x).im|) l, (fun x1 x2 => x1 \u2264 x2) x b\n\u22a2 (fun x => exp (sorry * sorry)) =\u0398[l] fun x => 1"}, {"line": "refine Real.isTheta_exp_comp_one.2 \u27e8\u03c0 * b, ?_\u27e9", "tactic_state": "case intro\n\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nb : \u211d\nhb : \u2200\u1da0 (x : \u211d) in Filter.map (fun x => |(g x).im|) l, (fun x1 x2 => x1 \u2264 x2) x b\n\u22a2 \u2200\u1da0 (x : \u211d) in Filter.map (fun x => |sorry * sorry|) l, (fun x1 x2 => x1 \u2264 x2) x (sorry * b)"}, {"line": "rw [eventually_map] at hb \u22a2", "tactic_state": "case intro\n\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nb : \u211d\nhb : \u2200\u1da0 (a : \u03b1) in l, (fun x1 x2 => x1 \u2264 x2) |(g a).im| b\n\u22a2 \u2200\u1da0 (a : \u03b1) in l, (fun x1 x2 => x1 \u2264 x2) |sorry * sorry| (sorry * b)"}, {"line": "refine hb.mono fun x hx => ?_", "tactic_state": "case intro\n\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nb : \u211d\nhb : \u2200\u1da0 (a : \u03b1) in l, (fun x1 x2 => x1 \u2264 x2) |(g a).im| b\nx : \u03b1\nhx : (fun x1 x2 => x1 \u2264 x2) |(g x).im| b\n\u22a2 (fun x1 x2 => x1 \u2264 x2) |sorry * sorry| (sorry * b)"}, {"line": "rw [abs_mul]", "tactic_state": "case intro\n\u03b1 : Type u_1\nl : Filter \u03b1\ng : \u03b1 \u2192 \u2102\nx\u271d\u00b9 : Sort u_2\narg : x\u271d\u00b9\nx\u271d : Sort u_3\nim : x\u271d\nb : \u211d\nhb : \u2200\u1da0 (a : \u03b1) in l, (fun x1 x2 => x1 \u2264 x2) |(g a).im| b\nx : \u03b1\nhx : (fun x1 x2 => x1 \u2264 x2) |(g x).im| b\n\u22a2 (fun x1 x2 => x1 \u2264 x2) (|sorry| * |sorry|) (sorry * b)"}, {"line": "exact mul_le_mul (abs_arg_le_pi _) hx (abs_nonneg _) Real.pi_pos.le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_cpow_rpow (hl : IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => |(g x).im|) :\n    (fun x => f x ^ g x) =O[l] fun x => \u2016f x\u2016 ^ (g x).re :=\n  calc\n    (fun x => f x ^ g x) =O[l]\n        (show \u03b1 \u2192 \u211d from fun x => \u2016f x\u2016 ^ (g x).re / Real.exp (arg (f x) * im (g x))) :=\n      isBigO_of_le _ fun _ => (norm_cpow_le _ _).trans (le_abs_self _)\n    _ =\u0398[l] (show \u03b1 \u2192 \u211d from fun x => \u2016f x\u2016 ^ (g x).re / (1 : \u211d)) :=\n      ((isTheta_refl _ _).div (isTheta_exp_arg_mul_im hl))\n    _ =\u1da0[l] (show \u03b1 \u2192 \u211d from fun x => \u2016f x\u2016 ^ (g x).re) := by\n      simp only [ofReal_one]\n      simp only [div_one]\n      simp only [EventuallyEq.rfl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u2102\nhl : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) l fun x => |(g x).im|\n\u22a2 (let_fun this := fun x => \u2016f x\u2016 ^ (g x).re / 1;\n    this) =\u1da0[l]\n    let_fun this := fun x => \u2016f x\u2016 ^ (g x).re;\n    this"}, {"line": "simp only [ofReal_one]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u2102\nhl : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) l fun x => |(g x).im|\n\u22a2 (fun x => \u2016f x\u2016 ^ (g x).re / 1) =\u1da0[l] fun x => \u2016f x\u2016 ^ (g x).re"}, {"line": "simp only [div_one]", "tactic_state": "\u03b1 : Type u_1\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u2102\nhl : IsBoundedUnder (fun x1 x2 => x1 \u2264 x2) l fun x => |(g x).im|\n\u22a2 (fun x => \u2016f x\u2016 ^ (g x).re) =\u1da0[l] fun x => \u2016f x\u2016 ^ (g x).re"}, {"line": "simp only [EventuallyEq.rfl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem IsLittleO.rpow (hr : 0 < r) (hg : 0 \u2264\u1da0[l] g) (h : f =o[l] g) :\n    (fun x => f x ^ r) =o[l] fun x => g x ^ r := by\n  refine .of_isBigOWith fun c hc \u21a6 ?_\n  rw [\u2190 rpow_inv_rpow hc.le hr.ne']\n  refine (h.forall_isBigOWith ?_).rpow ?_ ?_ hg <;> positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nr : \u211d\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\nhr : 0 < r\nhg : 0 \u2264\u1da0[l] g\nh : f =o[l] g\n\u22a2 (fun x => f x ^ r) =o[l] fun x => g x ^ r"}, {"line": "refine .of_isBigOWith fun c hc \u21a6 ?_", "tactic_state": "\u03b1 : Type u_2\nr : \u211d\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\nhr : 0 < r\nhg : 0 \u2264\u1da0[l] g\nh : f =o[l] g\nc : \u211d\nhc : 0 < c\n\u22a2 Asymptotics.IsBigOWith c l (fun x => f x ^ r) fun x => g x ^ r"}, {"line": "rw [\u2190 rpow_inv_rpow hc.le hr.ne']", "tactic_state": "\u03b1 : Type u_2\nr : \u211d\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\nhr : 0 < r\nhg : 0 \u2264\u1da0[l] g\nh : f =o[l] g\nc : \u211d\nhc : 0 < c\n\u22a2 Asymptotics.IsBigOWith ((c ^ r\u207b\u00b9) ^ r) l (fun x => f x ^ r) fun x => g x ^ r"}, {"line": "refine (h.forall_isBigOWith ?_).rpow ?_ ?_ hg <;> positivity", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma IsBigO.sqrt (hfg : f =O[l] g) (hg : 0 \u2264\u1da0[l] g) :\n    (Real.sqrt <| f \u00b7) =O[l] (Real.sqrt <| g \u00b7) := by\n  simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos.le hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\nhfg : f =O[l] g\nhg : 0 \u2264\u1da0[l] g\n\u22a2 (fun x => \u221a(f x)) =O[l] fun x => \u221a(g x)"}, {"line": "simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos.le hg", "tactic_state": "No Goals!"}]}
{"declaration": "protected lemma IsLittleO.sqrt (hfg : f =o[l] g) (hg : 0 \u2264\u1da0[l] g) :\n    (Real.sqrt <| f \u00b7) =o[l] (Real.sqrt <| g \u00b7) := by\n  simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos hg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b1 : Type u_2\nl : Filter \u03b1\nf g : \u03b1 \u2192 \u211d\nhfg : f =o[l] g\nhg : 0 \u2264\u1da0[l] g\n\u22a2 (fun x => \u221a(f x)) =o[l] fun x => \u221a(g x)"}, {"line": "simpa [Real.sqrt_eq_rpow] using hfg.rpow one_half_pos hg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_zpow_exp_pos_mul_atTop (k : \u2124) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ k) =o[atTop] fun x => exp (b * x) := by\n  simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real", "Asymptotics"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}", "{E : Type*} [SeminormedRing E] (a b c : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2124\nb : \u211d\nhb : 0 < b\n\u22a2 (fun x => x ^ k) =o[atTop] fun x => exp (b * x)"}, {"line": "simpa only [Real.rpow_intCast] using isLittleO_rpow_exp_pos_mul_atTop k hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_pow_exp_pos_mul_atTop (k : \u2115) {b : \u211d} (hb : 0 < b) :\n    (fun x : \u211d => x ^ k) =o[atTop] fun x => exp (b * x) := by\n  simpa using isLittleO_zpow_exp_pos_mul_atTop k hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real", "Asymptotics"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}", "{E : Type*} [SeminormedRing E] (a b c : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2115\nb : \u211d\nhb : 0 < b\n\u22a2 (fun x => x ^ k) =o[atTop] fun x => exp (b * x)"}, {"line": "simpa using isLittleO_zpow_exp_pos_mul_atTop k hb", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isLittleO_rpow_exp_atTop (s : \u211d) : (fun x : \u211d => x ^ s) =o[atTop] exp := by\n  simpa only [one_mul] using isLittleO_rpow_exp_pos_mul_atTop s one_pos\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Asymptotics.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Real Filter", "Asymptotics in", "Asymptotics", "Real", "Asymptotics"], "variables": ["{\u03b1 : Type*} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u2102}", "{\u03b1 : Type*} {r c : \u211d} {l : Filter \u03b1} {f g : \u03b1 \u2192 \u211d}", "{E : Type*} [SeminormedRing E] (a b c : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "s : \u211d\n\u22a2 (fun x => x ^ s) =o[atTop] exp"}, {"line": "simpa only [one_mul] using isLittleO_rpow_exp_pos_mul_atTop s one_pos", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_const_cpow {a b : \u2102} (ha : a \u2260 0) : ContinuousAt (fun x : \u2102 => a ^ x) b := by\n  have cpow_eq : (fun x : \u2102 => a ^ x) = fun x => exp (log a * x) := by\n    ext1 b\n    rw [cpow_def_of_ne_zero ha]\n  rw [cpow_eq]\n  exact continuous_exp.continuousAt.comp (ContinuousAt.mul continuousAt_const continuousAt_id)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u2102\nha : a \u2260 0\n\u22a2 ContinuousAt (fun x => a ^ x) b"}, {"line": "have cpow_eq : (fun x : \u2102 => a ^ x) = fun x => exp (log a * x) := by\n    ext1 b\n    rw [cpow_def_of_ne_zero ha]", "tactic_state": "a b : \u2102\nha : a \u2260 0\ncpow_eq : (fun x => a ^ x) = fun x => Complex.exp (Complex.log a * x)\n\u22a2 ContinuousAt (fun x => a ^ x) b"}, {"line": "rw [cpow_eq]", "tactic_state": "a b : \u2102\nha : a \u2260 0\ncpow_eq : (fun x => a ^ x) = fun x => Complex.exp (Complex.log a * x)\n\u22a2 ContinuousAt (fun x => Complex.exp (Complex.log a * x)) b"}, {"line": "exact continuous_exp.continuousAt.comp (ContinuousAt.mul continuousAt_const continuousAt_id)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_cpow {p : \u2102 \u00d7 \u2102} (hp_fst : p.fst \u2208 slitPlane) :\n    ContinuousAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) p := by\n  rw [continuousAt_congr (cpow_eq_nhds' <| slitPlane_ne_zero hp_fst)]\n  refine continuous_exp.continuousAt.comp ?_\n  exact\n    ContinuousAt.mul\n      (ContinuousAt.comp (continuousAt_clog hp_fst) continuous_fst.continuousAt)\n      continuous_snd.continuousAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex"], "variables": ["{\u03b1 : Type*}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2102 \u00d7 \u2102\nhp_fst : p.1 \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) p"}, {"line": "rw [continuousAt_congr (cpow_eq_nhds' <| slitPlane_ne_zero hp_fst)]", "tactic_state": "p : \u2102 \u00d7 \u2102\nhp_fst : p.1 \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => Complex.exp (Complex.log x.1 * x.2)) p"}, {"line": "refine continuous_exp.continuousAt.comp ?_", "tactic_state": "p : \u2102 \u00d7 \u2102\nhp_fst : p.1 \u2208 slitPlane\n\u22a2 ContinuousAt (fun x => Complex.log x.1 * x.2) p"}, {"line": "exact\n    ContinuousAt.mul\n      (ContinuousAt.comp (continuousAt_clog hp_fst) continuous_fst.continuousAt)\n      continuous_snd.continuousAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_const_rpow {a b : \u211d} (h : a \u2260 0) : ContinuousAt (a ^ \u00b7) b := by\n  simp only [rpow_def]\n  refine Complex.continuous_re.continuousAt.comp ?_\n  refine (continuousAt_const_cpow ?_).comp Complex.continuous_ofReal.continuousAt\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : a \u2260 0\n\u22a2 ContinuousAt (fun x => a ^ x) b"}, {"line": "simp only [rpow_def]", "tactic_state": "a b : \u211d\nh : a \u2260 0\n\u22a2 ContinuousAt (fun x => (\u2191a ^ \u2191x).re) b"}, {"line": "refine Complex.continuous_re.continuousAt.comp ?_", "tactic_state": "a b : \u211d\nh : a \u2260 0\n\u22a2 ContinuousAt (fun x => \u2191a ^ \u2191x) b"}, {"line": "refine (continuousAt_const_cpow ?_).comp Complex.continuous_ofReal.continuousAt", "tactic_state": "a b : \u211d\nh : a \u2260 0\n\u22a2 \u2191a \u2260 0"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_const_rpow' {a b : \u211d} (h : b \u2260 0) : ContinuousAt (a ^ \u00b7) b := by\n  simp only [rpow_def]\n  refine Complex.continuous_re.continuousAt.comp ?_\n  refine (continuousAt_const_cpow' ?_).comp Complex.continuous_ofReal.continuousAt\n  norm_cast\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a b : \u211d\nh : b \u2260 0\n\u22a2 ContinuousAt (fun x => a ^ x) b"}, {"line": "simp only [rpow_def]", "tactic_state": "a b : \u211d\nh : b \u2260 0\n\u22a2 ContinuousAt (fun x => (\u2191a ^ \u2191x).re) b"}, {"line": "refine Complex.continuous_re.continuousAt.comp ?_", "tactic_state": "a b : \u211d\nh : b \u2260 0\n\u22a2 ContinuousAt (fun x => \u2191a ^ \u2191x) b"}, {"line": "refine (continuousAt_const_cpow' ?_).comp Complex.continuous_ofReal.continuousAt", "tactic_state": "a b : \u211d\nh : b \u2260 0\n\u22a2 \u2191b \u2260 0"}, {"line": "norm_cast", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_rpow_const (x : \u211d) (q : \u211d) (h : x \u2260 0 \u2228 0 \u2264 q) :\n    ContinuousAt (fun x : \u211d => x ^ q) x := by", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x q : \u211d\nh : x \u2260 0 \u2228 0 \u2264 q\n\u22a2 ContinuousAt (fun x => x ^ q) x"}]}
{"declaration": "theorem continuousAt_cpow_of_re_pos {p : \u2102 \u00d7 \u2102} (h\u2081 : 0 \u2264 p.1.re \u2228 p.1.im \u2260 0) (h\u2082 : 0 < p.2.re) :\n    ContinuousAt (fun x : \u2102 \u00d7 \u2102 => x.1 ^ x.2) p := by\n  obtain \u27e8z, w\u27e9 := p\n  rw [\u2190 not_lt_zero_iff] at h\u2081\n  rw [lt_iff_le_and_ne] at h\u2081\n  rw [not_and_or] at h\u2081\n  rw [Ne] at h\u2081\n  rw [Classical.not_not] at h\u2081\n  rw [not_le_zero_iff] at h\u2081\n  rcases h\u2081 with (h\u2081 | (rfl : z = 0))\n  exacts [continuousAt_cpow h\u2081, continuousAt_cpow_zero_of_re_pos h\u2082]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex", "ComplexOrder in"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u2102 \u00d7 \u2102\nh\u2081 : 0 \u2264 p.1.re \u2228 p.1.im \u2260 0\nh\u2082 : 0 < p.2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) p"}, {"line": "obtain \u27e8z, w\u27e9 := p", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : 0 \u2264 (z, w).1.re \u2228 (z, w).1.im \u2260 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [\u2190 not_lt_zero_iff] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : \u00ac(z, w).1 < 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [lt_iff_le_and_ne] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : \u00ac((z, w).1 \u2264 0 \u2227 (z, w).1 \u2260 0)\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [not_and_or] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : \u00ac(z, w).1 \u2264 0 \u2228 \u00ac(z, w).1 \u2260 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [Ne] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : \u00ac(z, w).1 \u2264 0 \u2228 \u00ac\u00ac(z, w).1 = 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [Classical.not_not] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : \u00ac(z, w).1 \u2264 0 \u2228 (z, w).1 = 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rw [not_le_zero_iff] at h\u2081", "tactic_state": "case mk\nz w : \u2102\nh\u2081 : (0 < (z, w).1.re \u2228 (z, w).1.im \u2260 0) \u2228 (z, w).1 = 0\nh\u2082 : 0 < (z, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)"}, {"line": "rcases h\u2081 with (h\u2081 | (rfl : z = 0))", "tactic_state": "case mk.inl\nz w : \u2102\nh\u2082 : 0 < (z, w).2.re\nh\u2081 : 0 < (z, w).1.re \u2228 (z, w).1.im \u2260 0\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (z, w)\n---\ncase mk.inr\nw : \u2102\nh\u2082 : 0 < (0, w).2.re\n\u22a2 ContinuousAt (fun x => x.1 ^ x.2) (0, w)"}, {"line": "exacts [continuousAt_cpow h\u2081, continuousAt_cpow_zero_of_re_pos h\u2082]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem continuousAt_ofReal_cpow (x : \u211d) (y : \u2102) (h : 0 < y.re \u2228 x \u2260 0) :\n    ContinuousAt (fun p => (p.1 : \u2102) ^ p.2 : \u211d \u00d7 \u2102 \u2192 \u2102) (x, y) := by\n  rcases lt_trichotomy (0 : \u211d) x with (hx | rfl | hx)\n  \u00b7 -- x > 0 : easy case\n    have : ContinuousAt (fun p => \u27e8\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) (x, y) := by fun_prop\n    refine (continuousAt_cpow (Or.inl ?_)).comp this\n    rwa [ofReal_re]\n  \u00b7 -- x = 0 : reduce to continuousAt_cpow_zero_of_re_pos\n    have A : ContinuousAt (fun p => p.1 ^ p.2 : \u2102 \u00d7 \u2102 \u2192 \u2102) \u27e8\u2191(0 : \u211d), y\u27e9 := by\n      rw [ofReal_zero]\n      apply continuousAt_cpow_zero_of_re_pos\n      tauto\n    have B : ContinuousAt (fun p => \u27e8\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) \u27e80, y\u27e9 := by fun_prop\n    exact A.comp_of_eq B rfl\n  \u00b7 -- x < 0 : difficult case\n    suffices ContinuousAt (fun p => (-(p.1 : \u2102)) ^ p.2 * exp (\u03c0 * I * p.2) : \u211d \u00d7 \u2102 \u2192 \u2102) (x, y) by\n      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)\n      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm\n    have A : ContinuousAt (fun p => \u27e8-\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) (x, y) := by fun_prop\n    apply ContinuousAt.mul\n    \u00b7 refine (continuousAt_cpow (Or.inl ?_)).comp A\n      rwa [neg_re, ofReal_re, neg_pos]\n    \u00b7 exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex", "ComplexOrder in"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (x, y)"}, {"line": "rcases lt_trichotomy (0 : \u211d) x with (hx | rfl | hx)", "tactic_state": "case inl\nx : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : 0 < x\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (x, y)\n---\ncase inr.inl\ny : \u2102\nh : 0 < y.re \u2228 0 \u2260 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (0, y)\n---\ncase inr.inr\nx : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : x < 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (x, y)"}, {"line": "\u00b7 -- x > 0 : easy case\n    have : ContinuousAt (fun p => \u27e8\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) (x, y) := by fun_prop\n    refine (continuousAt_cpow (Or.inl ?_)).comp this\n    rwa [ofReal_re]", "tactic_state": "case inr.inl\ny : \u2102\nh : 0 < y.re \u2228 0 \u2260 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (0, y)\n---\ncase inr.inr\nx : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : x < 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (x, y)"}, {"line": "\u00b7 -- x = 0 : reduce to continuousAt_cpow_zero_of_re_pos\n    have A : ContinuousAt (fun p => p.1 ^ p.2 : \u2102 \u00d7 \u2102 \u2192 \u2102) \u27e8\u2191(0 : \u211d), y\u27e9 := by\n      rw [ofReal_zero]\n      apply continuousAt_cpow_zero_of_re_pos\n      tauto\n    have B : ContinuousAt (fun p => \u27e8\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) \u27e80, y\u27e9 := by fun_prop\n    exact A.comp_of_eq B rfl", "tactic_state": "case inr.inr\nx : \u211d\ny : \u2102\nh : 0 < y.re \u2228 x \u2260 0\nhx : x < 0\n\u22a2 ContinuousAt (fun p => \u2191p.1 ^ p.2) (x, y)"}, {"line": "\u00b7 -- x < 0 : difficult case\n    suffices ContinuousAt (fun p => (-(p.1 : \u2102)) ^ p.2 * exp (\u03c0 * I * p.2) : \u211d \u00d7 \u2102 \u2192 \u2102) (x, y) by\n      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)\n      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm\n    have A : ContinuousAt (fun p => \u27e8-\u2191p.1, p.2\u27e9 : \u211d \u00d7 \u2102 \u2192 \u2102 \u00d7 \u2102) (x, y) := by fun_prop\n    apply ContinuousAt.mul\n    \u00b7 refine (continuousAt_cpow (Or.inl ?_)).comp A\n      rwa [neg_re, ofReal_re, neg_pos]\n    \u00b7 exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eventually_pow_one_div_le (x : \u211d\u22650) {y : \u211d\u22650} (hy : 1 < y) :\n    \u2200\u1da0 n : \u2115 in atTop, x ^ (1 / n : \u211d) \u2264 y := by\n  obtain \u27e8m, hm\u27e9 := add_one_pow_unbounded_of_pos x (tsub_pos_of_lt hy)\n  rw [tsub_add_cancel_of_le hy.le] at hm\n  refine eventually_atTop.2 \u27e8m + 1, fun n hn => ?_\u27e9\n  simp only [one_div]\n  simpa only [NNReal.rpow_inv_le_iff (Nat.cast_pos.2 <| m.succ_pos.trans_le hn),NNReal.rpow_natCast] using hm.le.trans (pow_right_mono\u2080 hy.le (m.le_succ.trans hn))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex", "ComplexOrder in"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\nhy : 1 < y\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, x ^ (1 / \u2191n) \u2264 y"}, {"line": "obtain \u27e8m, hm\u27e9 := add_one_pow_unbounded_of_pos x (tsub_pos_of_lt hy)", "tactic_state": "case intro\nx y : NNReal\nhy : 1 < y\nm : \u2115\nhm : x < (y - 1 + 1) ^ m\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, x ^ (1 / \u2191n) \u2264 y"}, {"line": "rw [tsub_add_cancel_of_le hy.le] at hm", "tactic_state": "case intro\nx y : NNReal\nhy : 1 < y\nm : \u2115\nhm : x < y ^ m\n\u22a2 \u2200\u1da0 (n : \u2115) in atTop, x ^ (1 / \u2191n) \u2264 y"}, {"line": "refine eventually_atTop.2 \u27e8m + 1, fun n hn => ?_\u27e9", "tactic_state": "case intro\nx y : NNReal\nhy : 1 < y\nm : \u2115\nhm : x < y ^ m\nn : \u2115\nhn : n \u2265 m + 1\n\u22a2 x ^ (1 / \u2191n) \u2264 y"}, {"line": "simp only [one_div]", "tactic_state": "case intro\nx y : NNReal\nhy : 1 < y\nm : \u2115\nhm : x < y ^ m\nn : \u2115\nhn : n \u2265 m + 1\n\u22a2 x ^ (\u2191n)\u207b\u00b9 \u2264 y"}, {"line": "simpa only [NNReal.rpow_inv_le_iff (Nat.cast_pos.2 <| m.succ_pos.trans_le hn),NNReal.rpow_natCast] using hm.le.trans (pow_right_mono\u2080 hy.le (m.le_succ.trans hn))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_const_mul_rpow_nhds_zero_of_pos {c : \u211d\u22650\u221e} (hc : c \u2260 \u221e) {y : \u211d} (hy : 0 < y) :\n    Tendsto (fun x : \u211d\u22650\u221e => c * x ^ y) (\ud835\udcdd 0) (\ud835\udcdd 0) := by\n  convert ENNReal.Tendsto.const_mul (ENNReal.continuous_rpow_const.tendsto 0) _\n  \u00b7 simp [hy]\n  \u00b7 exact Or.inr hc\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Continuity.lean", "context": {"open": ["Real Topology NNReal ENNReal Filter ComplexConjugate Finset Set", "Complex", "ComplexOrder in", "Filter"], "variables": ["{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u2102} {s : Set \u03b1} {a : \u03b1}", "{\u03b1 : Type*}", "[TopologicalSpace \u03b1] {f g : \u03b1 \u2192 \u211d} {s : Set \u03b1} {x : \u03b1} {p : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : ENNReal\nhc : c \u2260 \u22a4\ny : \u211d\nhy : 0 < y\n\u22a2 Tendsto (fun x => c * x ^ y) (nhds 0) (nhds 0)"}, {"line": "convert ENNReal.Tendsto.const_mul (ENNReal.continuous_rpow_const.tendsto 0) _", "tactic_state": "case h.e'_5.h.e'_3\nc : ENNReal\nhc : c \u2260 \u22a4\ny : \u211d\nhy : 0 < y\n\u22a2 0 = c * 0 ^ y\n---\ncase convert_3\nc : ENNReal\nhc : c \u2260 \u22a4\ny : \u211d\nhy : 0 < y\n\u22a2 0 ^ y \u2260 0 \u2228 c \u2260 \u22a4"}, {"line": "\u00b7 simp [hy]", "tactic_state": "case convert_3\nc : ENNReal\nhc : c \u2260 \u22a4\ny : \u211d\nhy : 0 < y\n\u22a2 0 ^ y \u2260 0 \u2228 c \u2260 \u22a4"}, {"line": "\u00b7 exact Or.inr hc", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictDerivAt_const_cpow {x y : \u2102} (h : x \u2260 0 \u2228 y \u2260 0) :\n    HasStrictDerivAt (fun y => x ^ y) (x ^ y * log x) y := by\n  rcases em (x = 0) with (rfl | hx)\n  \u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero]\n    rw [mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm\n  \u00b7 simpa only [cpow_def_of_ne_zero hx,mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nlog : x\u271d\nx y : \u2102\nh : x \u2260 0 \u2228 y \u2260 0\n\u22a2 HasStrictDerivAt (fun y => x ^ y) (x ^ y * sorry) y"}, {"line": "rcases em (x = 0) with (rfl | hx)", "tactic_state": "case inl\nx\u271d : Sort u_1\nlog : x\u271d\ny : \u2102\nh : 0 \u2260 0 \u2228 y \u2260 0\n\u22a2 HasStrictDerivAt (fun y => 0 ^ y) (0 ^ y * sorry) y\n---\ncase inr\nx\u271d : Sort u_1\nlog : x\u271d\nx y : \u2102\nh : x \u2260 0 \u2228 y \u2260 0\nhx : \u00acx = 0\n\u22a2 HasStrictDerivAt (fun y => x ^ y) (x ^ y * sorry) y"}, {"line": "\u00b7 replace h := h.neg_resolve_left rfl\n    rw [log_zero]\n    rw [mul_zero]\n    refine (hasStrictDerivAt_const y 0).congr_of_eventuallyEq ?_\n    exact (isOpen_ne.eventually_mem h).mono fun y hy => (zero_cpow hy).symm", "tactic_state": "case inr\nx\u271d : Sort u_1\nlog : x\u271d\nx y : \u2102\nh : x \u2260 0 \u2228 y \u2260 0\nhx : \u00acx = 0\n\u22a2 HasStrictDerivAt (fun y => x ^ y) (x ^ y * sorry) y"}, {"line": "\u00b7 simpa only [cpow_def_of_ne_zero hx,mul_one] using\n      ((hasStrictDerivAt_id y).const_mul (log x)).cexp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.cpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf g : E \u2192 \u2102\nf' g' : E \u2192L[\u2102] \u2102\nx : E\nhf : HasFDerivAt f f' x\nhg : HasFDerivAt g g' x\nh0 : f x \u2208 slitPlane\n\u22a2 HasFDerivAt (fun x => f x ^ g x) ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') x"}, {"line": "convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.cpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h0 : f x \u2208 slitPlane) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x := by\n  convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x\n    (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_1\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u2102 E\nf g : E \u2192 \u2102\nf' g' : E \u2192L[\u2102] \u2102\ns : Set E\nx : E\nhf : HasFDerivWithinAt f f' s x\nhg : HasFDerivWithinAt g g' s x\nh0 : f x \u2208 slitPlane\n\u22a2 HasFDerivWithinAt (fun x => f x ^ g x) ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Complex.log (f x)) \u2022 g') s x"}, {"line": "convert (@Complex.hasFDerivAt_cpow ((fun x => (f x, g x)) x) h0).comp_hasFDerivWithinAt x\n    (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.hasStrictDerivAt_cpow_const (h : x \u2208 slitPlane) :\n    HasStrictDerivAt (fun z : \u2102 => z ^ c) (c * x ^ (c - 1)) x := by\n  simpa only [mul_zero,add_zero,mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x c : \u2102\nh : x \u2208 slitPlane\n\u22a2 HasStrictDerivAt (fun z => z ^ c) (c * x ^ (c - 1)) x"}, {"line": "simpa only [mul_zero,add_zero,mul_one] using\n    (hasStrictDerivAt_id x).cpow (hasStrictDerivAt_const x c) h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_ofReal_cpow_const' {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 -1) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1) / (r + 1)) (x ^ r) x := by\n  rw [Ne] at hr\n  rw [\u2190 add_eq_zero_iff_eq_neg] at hr\n  rw [\u2190 Ne] at hr\n  rcases lt_or_gt_of_ne hx.symm with (hx | hx)\n  \u00b7 -- easy case : `0 < x`\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]\n  \u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _)]\n    rw [mul_one]\n    rw [exp_add]\n    rw [exp_pi_mul_I]\n    rw [mul_comm (_ : \u2102) (-1 : \u2102)]\n    rw [neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul]; ring\n      rw [ofReal_neg 1]; ring\n      rw [ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : r \u2260 -1\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "rw [Ne] at hr", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : \u00acr = -1\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "rw [\u2190 add_eq_zero_iff_eq_neg] at hr", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : \u00acr + 1 = 0\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "rw [\u2190 Ne] at hr", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "rcases lt_or_gt_of_ne hx.symm with (hx | hx)", "tactic_state": "case inl\nx : \u211d\nhx\u271d : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\nhx : 0 < x\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x\n---\ncase inr\nx : \u211d\nhx\u271d : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\nhx : 0 > x\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "\u00b7 -- easy case : `0 < x`\n    apply HasDerivAt.comp_ofReal (e := fun y => (y : \u2102) ^ (r + 1) / (r + 1))\n    convert HasDerivAt.div_const (\ud835\udd5c := \u2102) ?_ (r + 1) using 1\n    \u00b7 exact (mul_div_cancel_right\u2080 _ hr).symm\n    \u00b7 convert HasDerivAt.cpow_const ?_ ?_ using 1\n      \u00b7 rw [add_sub_cancel_right, mul_comm]; exact (mul_one _).symm\n      \u00b7 exact hasDerivAt_id (x : \u2102)\n      \u00b7 simp [hx]", "tactic_state": "case inr\nx : \u211d\nhx\u271d : x \u2260 0\nr : \u2102\nhr : r + 1 \u2260 0\nhx : 0 > x\n\u22a2 HasDerivAt (fun y => \u2191y ^ (r + 1) / (r + 1)) (\u2191x ^ r) x"}, {"line": "\u00b7 -- harder case : `x < 0`\n    have : \u2200\u1da0 y : \u211d in \ud835\udcdd x,\n        (y : \u2102) ^ (r + 1) / (r + 1) = (-y : \u2102) ^ (r + 1) * exp (\u03c0 * I * (r + 1)) / (r + 1) := by\n      refine Filter.eventually_of_mem (Iio_mem_nhds hx) fun y hy => ?_\n      rw [ofReal_cpow_of_nonpos (le_of_lt hy)]\n    refine HasDerivAt.congr_of_eventuallyEq ?_ this\n    rw [ofReal_cpow_of_nonpos (le_of_lt hx)]\n    suffices HasDerivAt (fun y : \u211d => (-\u2191y) ^ (r + 1) * exp (\u2191\u03c0 * I * (r + 1)))\n        ((r + 1) * (-\u2191x) ^ r * exp (\u2191\u03c0 * I * r)) x by\n      convert this.div_const (r + 1) using 1\n      conv_rhs => rw [mul_assoc, mul_comm, mul_div_cancel_right\u2080 _ hr]\n    rw [mul_add ((\u03c0 : \u2102) * _)]\n    rw [mul_one]\n    rw [exp_add]\n    rw [exp_pi_mul_I]\n    rw [mul_comm (_ : \u2102) (-1 : \u2102)]\n    rw [neg_one_mul]\n    simp_rw [mul_neg, \u2190 neg_mul, \u2190 ofReal_neg]\n    suffices HasDerivAt (fun y : \u211d => (\u2191(-y) : \u2102) ^ (r + 1)) (-(r + 1) * \u2191(-x) ^ r) x by\n      convert this.neg.mul_const _ using 1; ring\n    suffices HasDerivAt (fun y : \u211d => (y : \u2102) ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) (-x) by\n      convert @HasDerivAt.scomp \u211d _ \u2102 _ _ x \u211d _ _ _ _ _ _ _ _ this (hasDerivAt_neg x) using 1\n      rw [real_smul]; ring\n      rw [ofReal_neg 1]; ring\n      rw [ofReal_one]; ring\n    suffices HasDerivAt (fun y : \u2102 => y ^ (r + 1)) ((r + 1) * \u2191(-x) ^ r) \u2191(-x) by\n      exact this.comp_ofReal\n    conv in \u2191_ ^ _ => rw [(by ring : r = r + 1 - 1)]\n    convert HasDerivAt.cpow_const ?_ ?_ using 1\n    \u00b7 rw [add_sub_cancel_right, add_sub_cancel_right]; exact (mul_one _).symm\n    \u00b7 exact hasDerivAt_id ((-x : \u211d) : \u2102)\n    \u00b7 simp [hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasDerivAt_ofReal_cpow_const {x : \u211d} (hx : x \u2260 0) {r : \u2102} (hr : r \u2260 0) :\n    HasDerivAt (fun y : \u211d => (y : \u2102) ^ r) (r * x ^ (r - 1)) x := by\n  have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])\n  simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : r \u2260 0\n\u22a2 HasDerivAt (fun y => \u2191y ^ r) (r * \u2191x ^ (r - 1)) x"}, {"line": "have := HasDerivAt.const_mul r <| hasDerivAt_ofReal_cpow_const' hx\n    (by rwa [ne_eq, sub_eq_neg_self])", "tactic_state": "x : \u211d\nhx : x \u2260 0\nr : \u2102\nhr : r \u2260 0\nthis : HasDerivAt (fun y => r * (\u2191y ^ (r - 1 + 1) / (r - 1 + 1))) (r * \u2191x ^ (r - 1)) x\n\u22a2 HasDerivAt (fun y => \u2191y ^ r) (r * \u2191x ^ (r - 1)) x"}, {"line": "simpa [sub_add_cancel, mul_div_cancel\u2080 _ hr] using this", "tactic_state": "No Goals!"}]}
{"declaration": "theorem isBigO_deriv_ofReal_cpow_const_atTop (c : \u2102) :\n    deriv (fun (x : \u211d) => (x : \u2102) ^ c) =O[atTop] fun x => x ^ (c.re - 1) := by\n  obtain rfl | hc := eq_or_ne c 0\n  \u00b7 simp_rw [cpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  \u00b7 exact (isTheta_deriv_ofReal_cpow_const_atTop hc).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\n\u22a2 (deriv fun x => \u2191x ^ c) =O[atTop] fun x => x ^ (c.re - 1)"}, {"line": "obtain rfl | hc := eq_or_ne c 0", "tactic_state": "case inl\n\u22a2 (deriv fun x => \u2191x ^ 0) =O[atTop] fun x => x ^ (re 0 - 1)\n---\ncase inr\nc : \u2102\nhc : c \u2260 0\n\u22a2 (deriv fun x => \u2191x ^ c) =O[atTop] fun x => x ^ (c.re - 1)"}, {"line": "\u00b7 simp_rw [cpow_zero, deriv_const', Asymptotics.isBigO_zero]", "tactic_state": "case inr\nc : \u2102\nhc : c \u2260 0\n\u22a2 (deriv fun x => \u2191x ^ c) =O[atTop] fun x => x ^ (c.re - 1)"}, {"line": "\u00b7 exact (isTheta_deriv_ofReal_cpow_const_atTop hc).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictDerivAt_const_rpow_of_neg {a x : \u211d} (ha : a < 0) :\n    HasStrictDerivAt (fun x => a ^ x) (a ^ x * log a - exp (log a * x) * sin (x * \u03c0) * \u03c0) x := by\n  simpa using (hasStrictFDerivAt_rpow_of_neg (a, x) ha).comp_hasStrictDerivAt x\n    ((hasStrictDerivAt_const _ _).prodMk (hasStrictDerivAt_id _))\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "a x : \u211d\nha : a < 0\n\u22a2 HasStrictDerivAt (fun x => a ^ x) sorry x"}, {"line": "simpa using (hasStrictFDerivAt_rpow_of_neg (a, x) ha).comp_hasStrictDerivAt x\n    ((hasStrictDerivAt_const _ _).prodMk (hasStrictDerivAt_id _))", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivWithinAt.rpow (hf : HasFDerivWithinAt f f' s x) (hg : HasFDerivWithinAt g g' s x)\n    (h : 0 < f x) : HasFDerivWithinAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') s x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp_hasFDerivWithinAt x\n    (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nf' g' : E \u2192L[\u211d] \u211d\nhf : HasFDerivWithinAt f f' sorry sorry\nhg : HasFDerivWithinAt g g' sorry sorry\nh : 0 < f sorry\n\u22a2 HasFDerivWithinAt (fun x => f x ^ g x)\n    ((g sorry * f sorry ^ (g sorry - 1)) \u2022 f' + (f sorry ^ g sorry * Real.log (f sorry)) \u2022 g') sorry sorry"}, {"line": "exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp_hasFDerivWithinAt x\n    (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasFDerivAt.rpow (hf : HasFDerivAt f f' x) (hg : HasFDerivAt g g' x) (h : 0 < f x) :\n    HasFDerivAt (fun x => f x ^ g x)\n      ((g x * f x ^ (g x - 1)) \u2022 f' + (f x ^ g x * Real.log (f x)) \u2022 g') x := by\n  exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nf' g' : E \u2192L[\u211d] \u211d\nhf : HasFDerivAt f f' sorry\nhg : HasFDerivAt g g' sorry\nh : 0 < f sorry\n\u22a2 HasFDerivAt (fun x => f x ^ g x)\n    ((g sorry * f sorry ^ (g sorry - 1)) \u2022 f' + (f sorry ^ g sorry * Real.log (f sorry)) \u2022 g') sorry"}, {"line": "exact (hasStrictFDerivAt_rpow_of_pos (f x, g x) h).hasFDerivAt.comp x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DifferentiableWithinAt.rpow (hf : DifferentiableWithinAt \u211d f s x)\n    (hg : DifferentiableWithinAt \u211d g s x) (h : f x \u2260 0) :\n    DifferentiableWithinAt \u211d (fun x => f x ^ g x) s x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp_differentiableWithinAt x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nhf : DifferentiableWithinAt \u211d f sorry sorry\nhg : DifferentiableWithinAt \u211d g sorry sorry\nh : f sorry \u2260 0\n\u22a2 DifferentiableWithinAt \u211d (fun x => f x ^ g x) sorry sorry"}, {"line": "exact (differentiableAt_rpow_of_ne (f x, g x) h).comp_differentiableWithinAt x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem DifferentiableAt.rpow (hf : DifferentiableAt \u211d f x) (hg : DifferentiableAt \u211d g x)\n    (h : f x \u2260 0) : DifferentiableAt \u211d (fun x => f x ^ g x) x := by\n  exact (differentiableAt_rpow_of_ne (f x, g x) h).comp x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nhf : DifferentiableAt \u211d f sorry\nhg : DifferentiableAt \u211d g sorry\nh : f sorry \u2260 0\n\u22a2 DifferentiableAt \u211d (fun x => f x ^ g x) sorry"}, {"line": "exact (differentiableAt_rpow_of_ne (f x, g x) h).comp x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffWithinAt.rpow (hf : ContDiffWithinAt \u211d n f s x) (hg : ContDiffWithinAt \u211d n g s x)\n    (h : f x \u2260 0) : ContDiffWithinAt \u211d n (fun x => f x ^ g x) s x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp_contDiffWithinAt x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nn : WithTop \u2115\u221e\nhf : ContDiffWithinAt \u211d n f sorry sorry\nhg : ContDiffWithinAt \u211d n g sorry sorry\nh : f sorry \u2260 0\n\u22a2 ContDiffWithinAt \u211d n (fun x => f x ^ g x) sorry sorry"}, {"line": "exact (contDiffAt_rpow_of_ne (f x, g x) h).comp_contDiffWithinAt x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem ContDiffAt.rpow (hf : ContDiffAt \u211d n f x) (hg : ContDiffAt \u211d n g x) (h : f x \u2260 0) :\n    ContDiffAt \u211d n (fun x => f x ^ g x) x := by\n  exact (contDiffAt_rpow_of_ne (f x, g x) h).comp x (hf.prodMk hg)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "E : Type u_2\ninst\u271d\u00b9 : NormedAddCommGroup E\ninst\u271d : NormedSpace \u211d E\nf g : E \u2192 \u211d\nn : WithTop \u2115\u221e\nhf : ContDiffAt \u211d n f sorry\nhg : ContDiffAt \u211d n g sorry\nh : f sorry \u2260 0\n\u22a2 ContDiffAt \u211d n (fun x => f x ^ g x) sorry"}, {"line": "exact (contDiffAt_rpow_of_ne (f x, g x) h).comp x (hf.prodMk hg)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.rpow (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x) (h : 0 < f x) :\n    HasDerivAt (fun x => f x ^ g x)\n      (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hf.rpow hg h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f g : \u211d \u2192 \u211d\nf' g' x : \u211d\nhf : HasDerivAt f f' x\nhg : HasDerivAt g g' x\nh : 0 < f x\n\u22a2 HasDerivAt (fun x => f x ^ g x) (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "f g : \u211d \u2192 \u211d\nf' g' x : \u211d\nhf : HasDerivWithinAt f f' Set.univ x\nhg : HasDerivWithinAt g g' Set.univ x\nh : 0 < f x\n\u22a2 HasDerivWithinAt (fun x => f x ^ g x) (f' * g x * f x ^ (g x - 1) + g' * f x ^ g x * Real.log (f x)) Set.univ x"}, {"line": "exact hf.rpow hg h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivWithinAt.rpow_const (hf : HasDerivWithinAt f f' s x) (hx : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivWithinAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) s x := by\n  convert (hasDerivAt_rpow_const hx).comp_hasDerivWithinAt x hf using 1\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nf' x p : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' s x\nhx : f x \u2260 0 \u2228 1 \u2264 p\n\u22a2 HasDerivWithinAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) s x"}, {"line": "convert (hasDerivAt_rpow_const hx).comp_hasDerivWithinAt x hf using 1", "tactic_state": "case h.e'_9\nf : \u211d \u2192 \u211d\nf' x p : \u211d\ns : Set \u211d\nhf : HasDerivWithinAt f f' s x\nhx : f x \u2260 0 \u2228 1 \u2264 p\n\u22a2 f' * p * f x ^ (p - 1) = p * f x ^ (p - 1) * f'"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem HasDerivAt.rpow_const (hf : HasDerivAt f f' x) (hx : f x \u2260 0 \u2228 1 \u2264 p) :\n    HasDerivAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) x := by\n  rw [\u2190 hasDerivWithinAt_univ] at *\n  exact hf.rpow_const hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "f : \u211d \u2192 \u211d\nf' x p : \u211d\nhf : HasDerivAt f f' x\nhx : f x \u2260 0 \u2228 1 \u2264 p\n\u22a2 HasDerivAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) x"}, {"line": "rw [\u2190 hasDerivWithinAt_univ] at *", "tactic_state": "f : \u211d \u2192 \u211d\nf' x p : \u211d\nhf : HasDerivWithinAt f f' Set.univ x\nhx : f x \u2260 0 \u2228 1 \u2264 p\n\u22a2 HasDerivWithinAt (fun y => f y ^ p) (f' * p * f x ^ (p - 1)) Set.univ x"}, {"line": "exact hf.rpow_const hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem deriv_norm_ofReal_cpow (c : \u2102) {t : \u211d} (ht : 0 < t) :\n    (deriv fun x : \u211d \u21a6 \u2016(x : \u2102) ^ c\u2016) t = c.re * t ^ (c.re - 1) := by\n  rw [EventuallyEq.deriv_eq (f := fun x \u21a6 x ^ c.re)]\n  \u00b7 rw [Real.deriv_rpow_const (Or.inl ht.ne')]\n  \u00b7 filter_upwards [eventually_gt_nhds ht] with x hx\n    rw [Complex.norm_cpow_eq_rpow_re_of_pos hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "c : \u2102\nt : \u211d\nht : 0 < t\n\u22a2 deriv (fun x => \u2016\u2191x ^ c\u2016) t = c.re * t ^ (c.re - 1)"}, {"line": "rw [EventuallyEq.deriv_eq (f := fun x \u21a6 x ^ c.re)]", "tactic_state": "c : \u2102\nt : \u211d\nht : 0 < t\n\u22a2 deriv (fun x => x ^ c.re) t = c.re * t ^ (c.re - 1)\n---\nc : \u2102\nt : \u211d\nht : 0 < t\n\u22a2 (fun x => \u2016\u2191x ^ c\u2016) =\u1da0[nhds t] fun x => x ^ c.re"}, {"line": "\u00b7 rw [Real.deriv_rpow_const (Or.inl ht.ne')]", "tactic_state": "c : \u2102\nt : \u211d\nht : 0 < t\n\u22a2 (fun x => \u2016\u2191x ^ c\u2016) =\u1da0[nhds t] fun x => x ^ c.re"}, {"line": "\u00b7 filter_upwards [eventually_gt_nhds ht] with x hx\n    rw [Complex.norm_cpow_eq_rpow_re_of_pos hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isTheta_deriv_rpow_const_atTop {p : \u211d} (hp : p \u2260 0) :\n    deriv (fun (x : \u211d) => x ^ p) =\u0398[atTop] fun x => x ^ (p-1) := by\n  calc deriv (fun (x : \u211d) => x ^ p) =\u1da0[atTop] fun x => p * x ^ (p - 1) := by\n              filter_upwards [eventually_ne_atTop 0] with x hx\n              rw [Real.deriv_rpow_const (Or.inl hx)]\n       _ =\u0398[atTop] fun x => x ^ (p-1) :=\n              Asymptotics.IsTheta.const_mul_left hp Asymptotics.isTheta_rfl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\nhp : p \u2260 0\n\u22a2 (deriv fun x => x ^ p) =\u0398[atTop] fun x => x ^ (p - 1)"}, {"line": "calc deriv (fun (x : \u211d) => x ^ p) =\u1da0[atTop] fun x => p * x ^ (p - 1) := by\n              filter_upwards [eventually_ne_atTop 0] with x hx\n              rw [Real.deriv_rpow_const (Or.inl hx)]\n       _ =\u0398[atTop] fun x => x ^ (p-1) :=\n              Asymptotics.IsTheta.const_mul_left hp Asymptotics.isTheta_rfl", "tactic_state": "No Goals!"}]}
{"declaration": "lemma isBigO_deriv_rpow_const_atTop (p : \u211d) :\n    deriv (fun (x : \u211d) => x ^ p) =O[atTop] fun x => x ^ (p-1) := by\n  rcases eq_or_ne p 0 with rfl | hp\n  case inl =>\n    simp [zero_sub, Real.rpow_neg_one, Real.rpow_zero, deriv_const', Asymptotics.isBigO_zero]\n  case inr =>\n    exact (isTheta_deriv_rpow_const_atTop hp).1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Deriv.lean", "context": {"open": ["scoped Real Topology NNReal ENNReal", "Filter", "Complex", "Complex", "Real"], "variables": ["{E : Type*} [NormedAddCommGroup E] [NormedSpace \u2102 E] {f g : E \u2192 \u2102} {f' g' : E \u2192L[\u2102] \u2102}", "{f g : \u2102 \u2192 \u2102} {s : Set \u2102} {f' g' x c : \u2102}", "{x y z : \u211d}", "{z x y : \u211d}", "{E : Type*} [NormedAddCommGroup E] [NormedSpace \u211d E] {f g : E \u2192 \u211d} {f' g' : E \u2192L[\u211d] \u211d}", "{m : \u2115}", "{f g : \u211d \u2192 \u211d} {f' g' x y p : \u211d} {s : Set \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "p : \u211d\n\u22a2 (deriv fun x => x ^ p) =O[atTop] fun x => x ^ (p - 1)"}, {"line": "rcases eq_or_ne p 0 with rfl | hp", "tactic_state": "case inl\n\u22a2 (deriv fun x => x ^ 0) =O[atTop] fun x => x ^ (0 - 1)\n---\ncase inr\np : \u211d\nhp : p \u2260 0\n\u22a2 (deriv fun x => x ^ p) =O[atTop] fun x => x ^ (p - 1)"}, {"line": "case inl =>\n    simp [zero_sub, Real.rpow_neg_one, Real.rpow_zero, deriv_const', Asymptotics.isBigO_zero]", "tactic_state": "case inr\np : \u211d\nhp : p \u2260 0\n\u22a2 (deriv fun x => x ^ p) =O[atTop] fun x => x ^ (p - 1)"}, {"line": "case inr =>\n    exact (isTheta_deriv_rpow_const_atTop hp).1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_eq_zero_iff {x : \u211d\u22650} {y : \u211d} : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0 := by\n  rw [\u2190 NNReal.coe_inj]\n  rw [coe_rpow]\n  rw [\u2190 NNReal.coe_eq_zero]\n  exact Real.rpow_eq_zero_iff_of_nonneg x.2\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\ny : \u211d\n\u22a2 x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0"}, {"line": "rw [\u2190 NNReal.coe_inj]", "tactic_state": "x : NNReal\ny : \u211d\n\u22a2 \u2191(x ^ y) = \u21910 \u2194 x = 0 \u2227 y \u2260 0"}, {"line": "rw [coe_rpow]", "tactic_state": "x : NNReal\ny : \u211d\n\u22a2 \u2191x ^ y = \u21910 \u2194 x = 0 \u2227 y \u2260 0"}, {"line": "rw [\u2190 NNReal.coe_eq_zero]", "tactic_state": "x : NNReal\ny : \u211d\n\u22a2 \u2191x ^ y = \u21910 \u2194 \u2191x = 0 \u2227 y \u2260 0"}, {"line": "exact Real.rpow_eq_zero_iff_of_nonneg x.2", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_eq_zero (hy : y \u2260 0) : x ^ y = 0 \u2194 x = 0 := by simp [hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\ny : \u211d\nhy : y \u2260 0\n\u22a2 x ^ y = 0 \u2194 x = 0"}, {"line": "simp [hy]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_intCast (x : \u211d\u22650) (n : \u2124) : x ^ (n : \u211d) = x ^ n := by\n  cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nn : \u2124\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]", "tactic_state": "case ofNat\nx : NNReal\na\u271d : \u2115\n\u22a2 x ^ \u2191a\u271d = x ^ a\u271d\n---\ncase negSucc\nx : NNReal\na\u271d : \u2115\n\u22a2 x ^ (-\u2191(a\u271d + 1)) = (x ^ (a\u271d + 1))\u207b\u00b9"}]}
{"declaration": "lemma rpow_add_one (hx : x \u2260 0) (y : \u211d) : x ^ (y + 1) = x ^ y * x := by\n  simpa using rpow_add_natCast hx y 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nhx : x \u2260 0\ny : \u211d\n\u22a2 x ^ (y + 1) = x ^ y * x"}, {"line": "simpa using rpow_add_natCast hx y 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_one (hx : x \u2260 0) (y : \u211d) : x ^ (y - 1) = x ^ y / x := by\n  simpa using rpow_sub_natCast hx y 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nhx : x \u2260 0\ny : \u211d\n\u22a2 x ^ (y - 1) = x ^ y / x"}, {"line": "simpa using rpow_sub_natCast hx y 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.list_prod_map_rpow' {\u03b9} (l : List \u03b9) (f : \u03b9 \u2192 \u211d)\n    (hl : \u2200 i \u2208 l, (0 : \u211d) \u2264 f i) (r : \u211d) :\n    (l.map (f \u00b7 ^ r)).prod = (l.map f).prod ^ r := by\n  rw [\u2190 Real.list_prod_map_rpow (l.map f) _ r]\n  rw [List.map_map]\n  \u00b7 rfl\n  simpa using hl\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map f l).prod ^ r"}, {"line": "rw [\u2190 Real.list_prod_map_rpow (l.map f) _ r]", "tactic_state": "\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map (fun x => x ^ r) (List.map f l)).prod\n---\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 \u2200 x \u2208 List.map f l, 0 \u2264 x"}, {"line": "rw [List.map_map]", "tactic_state": "\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 (List.map (fun x => f x ^ r) l).prod = (List.map ((fun x => x ^ r) \u2218 f) l).prod\n---\n\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 \u2200 x \u2208 List.map f l, 0 \u2264 x"}, {"line": "\u00b7 rfl", "tactic_state": "\u03b9 : Type u_1\nl : List \u03b9\nf : \u03b9 \u2192 \u211d\nhl : \u2200 i \u2208 l, 0 \u2264 f i\nr : \u211d\n\u22a2 \u2200 x \u2208 List.map f l, 0 \u2264 x"}, {"line": "simpa using hl", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.multiset_prod_map_rpow {\u03b9} (s : Multiset \u03b9) (f : \u03b9 \u2192 \u211d)\n    (hs : \u2200 i \u2208 s, (0 : \u211d) \u2264 f i) (r : \u211d) :\n    (s.map (f \u00b7 ^ r)).prod = (s.map f).prod ^ r := by\n  induction' s using Quotient.inductionOn with l\n  simpa using Real.list_prod_map_rpow' l f hs r\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b9 : Type u_1\ns : Multiset \u03b9\nf : \u03b9 \u2192 \u211d\nhs : \u2200 i \u2208 s, 0 \u2264 f i\nr : \u211d\n\u22a2 (Multiset.map (fun x => f x ^ r) s).prod = (Multiset.map f s).prod ^ r"}, {"line": "induction' s using Quotient.inductionOn with l", "tactic_state": "case h\n\u03b9 : Type u_1\nf : \u03b9 \u2192 \u211d\nr : \u211d\nl : List \u03b9\nhs : \u2200 i \u2208 \u27e6l\u27e7, 0 \u2264 f i\n\u22a2 (Multiset.map (fun x => f x ^ r) \u27e6l\u27e7).prod = (Multiset.map f \u27e6l\u27e7).prod ^ r"}, {"line": "simpa using Real.list_prod_map_rpow' l f hs r", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_rpow_inv_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x = y ^ z\u207b\u00b9 \u2194 x ^ z = y := by\n  rw [\u2190 rpow_eq_rpow_iff hz]\n  rw [\u2190 one_div]\n  rw [rpow_self_rpow_inv hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 x = y ^ z\u207b\u00b9 \u2194 x ^ z = y"}, {"line": "rw [\u2190 rpow_eq_rpow_iff hz]", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 x ^ z = (y ^ z\u207b\u00b9) ^ z \u2194 x ^ z = y"}, {"line": "rw [\u2190 one_div]", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 x ^ z = (y ^ (1 / z)) ^ z \u2194 x ^ z = y"}, {"line": "rw [rpow_self_rpow_inv hz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_inv_eq_iff {x y : \u211d\u22650} {z : \u211d} (hz : z \u2260 0) : x ^ z\u207b\u00b9 = y \u2194 x = y ^ z := by\n  rw [\u2190 rpow_eq_rpow_iff hz]\n  rw [\u2190 one_div]\n  rw [rpow_self_rpow_inv hz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 x ^ z\u207b\u00b9 = y \u2194 x = y ^ z"}, {"line": "rw [\u2190 rpow_eq_rpow_iff hz]", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 (x ^ z\u207b\u00b9) ^ z = y ^ z \u2194 x = y ^ z"}, {"line": "rw [\u2190 one_div]", "tactic_state": "x y : NNReal\nz : \u211d\nhz : z \u2260 0\n\u22a2 (x ^ (1 / z)) ^ z = y ^ z \u2194 x = y ^ z"}, {"line": "rw [rpow_self_rpow_inv hz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_rpow_inv_natCast (x : \u211d\u22650) {n : \u2115} (hn : n \u2260 0) : (x ^ n) ^ (n\u207b\u00b9 : \u211d) = x := by\n  rw [\u2190 NNReal.coe_inj]\n  rw [coe_rpow]\n  rw [NNReal.coe_pow]\n  exact Real.pow_rpow_inv_natCast x.2 hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 (x ^ n) ^ (\u2191n)\u207b\u00b9 = x"}, {"line": "rw [\u2190 NNReal.coe_inj]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191((x ^ n) ^ (\u2191n)\u207b\u00b9) = \u2191x"}, {"line": "rw [coe_rpow]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191(x ^ n) ^ (\u2191n)\u207b\u00b9 = \u2191x"}, {"line": "rw [NNReal.coe_pow]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 (\u2191x ^ n) ^ (\u2191n)\u207b\u00b9 = \u2191x"}, {"line": "exact Real.pow_rpow_inv_natCast x.2 hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_inv_natCast_pow (x : \u211d\u22650) {n : \u2115} (hn : n \u2260 0) : (x ^ (n\u207b\u00b9 : \u211d)) ^ n = x := by\n  rw [\u2190 NNReal.coe_inj]\n  rw [NNReal.coe_pow]\n  rw [coe_rpow]\n  exact Real.rpow_inv_natCast_pow x.2 hn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x"}, {"line": "rw [\u2190 NNReal.coe_inj]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191((x ^ (\u2191n)\u207b\u00b9) ^ n) = \u2191x"}, {"line": "rw [NNReal.coe_pow]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2191(x ^ (\u2191n)\u207b\u00b9) ^ n = \u2191x"}, {"line": "rw [coe_rpow]", "tactic_state": "x : NNReal\nn : \u2115\nhn : n \u2260 0\n\u22a2 (\u2191x ^ (\u2191n)\u207b\u00b9) ^ n = \u2191x"}, {"line": "exact Real.rpow_inv_natCast_pow x.2 hn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem _root_.Real.toNNReal_rpow_of_nonneg {x y : \u211d} (hx : 0 \u2264 x) :\n    Real.toNNReal (x ^ y) = Real.toNNReal x ^ y := by\n  nth_rw 1 [\u2190 Real.coe_toNNReal x hx]\n  rw [\u2190 NNReal.coe_rpow]\n  rw [Real.toNNReal_coe]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (x ^ y).toNNReal = x.toNNReal ^ y"}, {"line": "nth_rw 1 [\u2190 Real.coe_toNNReal x hx]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (\u2191x.toNNReal ^ y).toNNReal = x.toNNReal ^ y"}, {"line": "rw [\u2190 NNReal.coe_rpow]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (\u2191(x.toNNReal ^ y)).toNNReal = x.toNNReal ^ y"}, {"line": "rw [Real.toNNReal_coe]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_zero {x : \u211d\u22650\u221e} : x ^ (0 : \u211d) = 1 := by\n  cases x <;>\n    \u00b7 dsimp only [(\u00b7 ^ \u00b7), Pow.pow, rpow]\n      simp [lt_irrefl]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\n\u22a2 x ^ 0 = 1"}, {"line": "cases x <;>\n    \u00b7 dsimp only [(\u00b7 ^ \u00b7), Pow.pow, rpow]\n      simp [lt_irrefl]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_rpow_of_pos {y : \u211d} (h : 0 < y) : (\u22a4 : \u211d\u22650\u221e) ^ y = \u22a4 := by simp [top_rpow_def, h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nh : 0 < y\n\u22a2 \u22a4 ^ y = \u22a4"}, {"line": "simp [top_rpow_def, h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem top_rpow_of_neg {y : \u211d} (h : y < 0) : (\u22a4 : \u211d\u22650\u221e) ^ y = 0 := by\n  simp [top_rpow_def, asymm h, ne_of_lt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nh : y < 0\n\u22a2 \u22a4 ^ y = 0"}, {"line": "simp [top_rpow_def, asymm h, ne_of_lt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_of_pos {y : \u211d} (h : 0 < y) : (0 : \u211d\u22650\u221e) ^ y = 0 := by\n  rw [\u2190 ENNReal.coe_zero]\n  rw [\u2190 ENNReal.some_eq_coe]\n  dsimp only [(\u00b7 ^ \u00b7), rpow, Pow.pow]\n  simp [h, asymm h, ne_of_gt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nh : 0 < y\n\u22a2 0 ^ y = 0"}, {"line": "rw [\u2190 ENNReal.coe_zero]", "tactic_state": "y : \u211d\nh : 0 < y\n\u22a2 \u21910 ^ y = \u21910"}, {"line": "rw [\u2190 ENNReal.some_eq_coe]", "tactic_state": "y : \u211d\nh : 0 < y\n\u22a2 some 0 ^ y = some 0"}, {"line": "dsimp only [(\u00b7 ^ \u00b7), rpow, Pow.pow]", "tactic_state": "y : \u211d\nh : 0 < y\n\u22a2 ENNReal.rpow (some 0) y = some 0"}, {"line": "simp [h, asymm h, ne_of_gt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_of_neg {y : \u211d} (h : y < 0) : (0 : \u211d\u22650\u221e) ^ y = \u22a4 := by\n  rw [\u2190 ENNReal.coe_zero]\n  rw [\u2190 ENNReal.some_eq_coe]\n  dsimp only [(\u00b7 ^ \u00b7), rpow, Pow.pow]\n  simp [h, ne_of_gt h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\nh : y < 0\n\u22a2 0 ^ y = \u22a4"}, {"line": "rw [\u2190 ENNReal.coe_zero]", "tactic_state": "y : \u211d\nh : y < 0\n\u22a2 \u21910 ^ y = \u22a4"}, {"line": "rw [\u2190 ENNReal.some_eq_coe]", "tactic_state": "y : \u211d\nh : y < 0\n\u22a2 some 0 ^ y = \u22a4"}, {"line": "dsimp only [(\u00b7 ^ \u00b7), rpow, Pow.pow]", "tactic_state": "y : \u211d\nh : y < 0\n\u22a2 ENNReal.rpow (some 0) y = \u22a4"}, {"line": "simp [h, ne_of_gt h]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_def (y : \u211d) : (0 : \u211d\u22650\u221e) ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4 := by\n  rcases lt_trichotomy (0 : \u211d) y with (H | rfl | H)\n  \u00b7 simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]\n  \u00b7 simp [lt_irrefl]\n  \u00b7 simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 0 ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4"}, {"line": "rcases lt_trichotomy (0 : \u211d) y with (H | rfl | H)", "tactic_state": "case inl\ny : \u211d\nH : 0 < y\n\u22a2 0 ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4\n---\ncase inr.inl\n\u22a2 0 ^ 0 = if 0 < 0 then 0 else if 0 = 0 then 1 else \u22a4\n---\ncase inr.inr\ny : \u211d\nH : y < 0\n\u22a2 0 ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4"}, {"line": "\u00b7 simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]", "tactic_state": "case inr.inl\n\u22a2 0 ^ 0 = if 0 < 0 then 0 else if 0 = 0 then 1 else \u22a4\n---\ncase inr.inr\ny : \u211d\nH : y < 0\n\u22a2 0 ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4"}, {"line": "\u00b7 simp [lt_irrefl]", "tactic_state": "case inr.inr\ny : \u211d\nH : y < 0\n\u22a2 0 ^ y = if 0 < y then 0 else if y = 0 then 1 else \u22a4"}, {"line": "\u00b7 simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_mul_self (y : \u211d) : (0 : \u211d\u22650\u221e) ^ y * (0 : \u211d\u22650\u221e) ^ y = (0 : \u211d\u22650\u221e) ^ y := by\n  rw [zero_rpow_def]\n  split_ifs\n  exacts [zero_mul _, one_mul _, top_mul_top]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "y : \u211d\n\u22a2 0 ^ y * 0 ^ y = 0 ^ y"}, {"line": "rw [zero_rpow_def]", "tactic_state": "y : \u211d\n\u22a2 ((if 0 < y then 0 else if y = 0 then 1 else \u22a4) * if 0 < y then 0 else if y = 0 then 1 else \u22a4) =\n    if 0 < y then 0 else if y = 0 then 1 else \u22a4"}, {"line": "split_ifs", "tactic_state": "case pos\ny : \u211d\nh\u271d : 0 < y\n\u22a2 0 * 0 = 0\n---\ncase pos\ny : \u211d\nh\u271d\u00b9 : \u00ac0 < y\nh\u271d : y = 0\n\u22a2 1 * 1 = 1\n---\ncase neg\ny : \u211d\nh\u271d\u00b9 : \u00ac0 < y\nh\u271d : \u00acy = 0\n\u22a2 \u22a4 * \u22a4 = \u22a4"}, {"line": "exacts [zero_mul _, one_mul _, top_mul_top]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_rpow_of_ne_zero {x : \u211d\u22650} (h : x \u2260 0) (y : \u211d) : (\u2191(x ^ y) : \u211d\u22650\u221e) = x ^ y := by\n  rw [\u2190 ENNReal.some_eq_coe]\n  dsimp only [(\u00b7 ^ \u00b7), Pow.pow, rpow]\n  simp [h]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : NNReal\nh : x \u2260 0\ny : \u211d\n\u22a2 \u2191(x ^ y) = \u2191x ^ y"}, {"line": "rw [\u2190 ENNReal.some_eq_coe]", "tactic_state": "x : NNReal\nh : x \u2260 0\ny : \u211d\n\u22a2 some (x ^ y) = \u2191x ^ y"}, {"line": "dsimp only [(\u00b7 ^ \u00b7), Pow.pow, rpow]", "tactic_state": "x : NNReal\nh : x \u2260 0\ny : \u211d\n\u22a2 some (x.rpow y) = (\u2191x).rpow y"}, {"line": "simp [h]", "tactic_state": "x : NNReal\nh : x \u2260 0\ny : \u211d\n\u22a2 \u2191(x ^ y) = \u2191x ^ y"}]}
{"declaration": "theorem rpow_one (x : \u211d\u22650\u221e) : x ^ (1 : \u211d) = x := by\n  cases x\n  \u00b7 exact dif_pos zero_lt_one\n  \u00b7 change ite _ _ _ = _\n    simp only [NNReal.rpow_one]\n    simp only [some_eq_coe]\n    simp only [ite_eq_right_iff]\n    simp only [top_ne_coe]\n    simp only [and_imp]\n    exact fun _ => zero_le_one.not_lt\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\n\u22a2 x ^ 1 = x"}, {"line": "cases x", "tactic_state": "case top\n\u22a2 \u22a4 ^ 1 = \u22a4\n---\ncase coe\nx\u271d : NNReal\n\u22a2 \u2191x\u271d ^ 1 = \u2191x\u271d"}, {"line": "\u00b7 exact dif_pos zero_lt_one", "tactic_state": "case coe\nx\u271d : NNReal\n\u22a2 \u2191x\u271d ^ 1 = \u2191x\u271d"}, {"line": "\u00b7 change ite _ _ _ = _\n    simp only [NNReal.rpow_one]\n    simp only [some_eq_coe]\n    simp only [ite_eq_right_iff]\n    simp only [top_ne_coe]\n    simp only [and_imp]\n    exact fun _ => zero_le_one.not_lt", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_eq_zero_iff_of_pos {x : \u211d\u22650\u221e} {y : \u211d} (hy : 0 < y) : x ^ y = 0 \u2194 x = 0 := by\n  simp [hy, hy.not_lt]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\ny : \u211d\nhy : 0 < y\n\u22a2 x ^ y = 0 \u2194 x = 0"}, {"line": "simp [hy, hy.not_lt]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_eq_top_iff_of_pos {x : \u211d\u22650\u221e} {y : \u211d} (hy : 0 < y) : x ^ y = \u22a4 \u2194 x = \u22a4 := by\n  simp [rpow_eq_top_iff, hy, asymm hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\ny : \u211d\nhy : 0 < y\n\u22a2 x ^ y = \u22a4 \u2194 x = \u22a4"}, {"line": "simp [rpow_eq_top_iff, hy, asymm hy]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_lt_top_iff_of_pos {x : \u211d\u22650\u221e} {y : \u211d} (hy : 0 < y) : x ^ y < \u221e \u2194 x < \u221e := by\n  simp only [lt_top_iff_ne_top]\n  simp only [Ne]\n  simp only [rpow_eq_top_iff_of_pos hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\ny : \u211d\nhy : 0 < y\n\u22a2 x ^ y < \u22a4 \u2194 x < \u22a4"}, {"line": "simp only [lt_top_iff_ne_top]", "tactic_state": "x : ENNReal\ny : \u211d\nhy : 0 < y\n\u22a2 x ^ y \u2260 \u22a4 \u2194 x \u2260 \u22a4"}, {"line": "simp only [Ne]", "tactic_state": "x : ENNReal\ny : \u211d\nhy : 0 < y\n\u22a2 \u00acx ^ y = \u22a4 \u2194 \u00acx = \u22a4"}, {"line": "simp only [rpow_eq_top_iff_of_pos hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_natCast (x : \u211d\u22650\u221e) (n : \u2115) : x ^ (n : \u211d) = x ^ n := by\n  cases x\n  \u00b7 cases n <;> simp [top_rpow_of_pos (Nat.cast_add_one_pos _), top_pow (Nat.succ_ne_zero _)]\n  \u00b7 simp [\u2190 coe_rpow_of_nonneg _ (Nat.cast_nonneg n)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nn : \u2115\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "cases x", "tactic_state": "case top\nn : \u2115\n\u22a2 \u22a4 ^ \u2191n = \u22a4 ^ n\n---\ncase coe\nn : \u2115\nx\u271d : NNReal\n\u22a2 \u2191x\u271d ^ \u2191n = \u2191x\u271d ^ n"}, {"line": "\u00b7 cases n <;> simp [top_rpow_of_pos (Nat.cast_add_one_pos _), top_pow (Nat.succ_ne_zero _)]", "tactic_state": "case coe\nn : \u2115\nx\u271d : NNReal\n\u22a2 \u2191x\u271d ^ \u2191n = \u2191x\u271d ^ n"}, {"line": "\u00b7 simp [\u2190 coe_rpow_of_nonneg _ (Nat.cast_nonneg n)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_intCast (x : \u211d\u22650\u221e) (n : \u2124) : x ^ (n : \u211d) = x ^ n := by\n  cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nn : \u2124\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]", "tactic_state": "case ofNat\nx : ENNReal\na\u271d : \u2115\n\u22a2 x ^ \u2191a\u271d = x ^ a\u271d\n---\ncase negSucc\nx : ENNReal\na\u271d : \u2115\n\u22a2 x ^ (-\u2191(a\u271d + 1)) = (x ^ (a\u271d + 1))\u207b\u00b9"}]}
{"declaration": "theorem mul_rpow_of_ne_top {x y : \u211d\u22650\u221e} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) (z : \u211d) :\n    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ENNReal\nhx : x \u2260 \u22a4\nhy : y \u2260 \u22a4\nz : \u211d\n\u22a2 (x * y) ^ z = x ^ z * y ^ z"}, {"line": "simp [*, mul_rpow_eq_ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_rpow_of_ne_zero {x y : \u211d\u22650\u221e} (hx : x \u2260 0) (hy : y \u2260 0) (z : \u211d) :\n    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ENNReal\nhx : x \u2260 0\nhy : y \u2260 0\nz : \u211d\n\u22a2 (x * y) ^ z = x ^ z * y ^ z"}, {"line": "simp [*, mul_rpow_eq_ite]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_inv_le_iff {x y : \u211d\u22650\u221e} {z : \u211d} (hz : 0 < z) : x ^ z\u207b\u00b9 \u2264 y \u2194 x \u2264 y ^ z := by\n  nth_rw 1 [\u2190 ENNReal.rpow_one y]\n  nth_rw 1 [\u2190 @mul_inv_cancel\u2080 _ _ z hz.ne.symm]\n  rw [ENNReal.rpow_mul]\n  rw [ENNReal.rpow_le_rpow_iff (inv_pos.2 hz)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : ENNReal\nz : \u211d\nhz : 0 < z\n\u22a2 x ^ z\u207b\u00b9 \u2264 y \u2194 x \u2264 y ^ z"}, {"line": "nth_rw 1 [\u2190 ENNReal.rpow_one y]", "tactic_state": "x y : ENNReal\nz : \u211d\nhz : 0 < z\n\u22a2 x ^ z\u207b\u00b9 \u2264 y ^ 1 \u2194 x \u2264 y ^ z"}, {"line": "nth_rw 1 [\u2190 @mul_inv_cancel\u2080 _ _ z hz.ne.symm]", "tactic_state": "x y : ENNReal\nz : \u211d\nhz : 0 < z\n\u22a2 x ^ z\u207b\u00b9 \u2264 y ^ (z * z\u207b\u00b9) \u2194 x \u2264 y ^ z"}, {"line": "rw [ENNReal.rpow_mul]", "tactic_state": "x y : ENNReal\nz : \u211d\nhz : 0 < z\n\u22a2 x ^ z\u207b\u00b9 \u2264 (y ^ z) ^ z\u207b\u00b9 \u2194 x \u2264 y ^ z"}, {"line": "rw [ENNReal.rpow_le_rpow_iff (inv_pos.2 hz)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_self_of_le_one {x : \u211d\u22650\u221e} {z : \u211d} (hx : x \u2264 1) (h_one_le : 1 \u2264 z) : x ^ z \u2264 x := by\n  nth_rw 2 [\u2190 ENNReal.rpow_one x]\n  exact ENNReal.rpow_le_rpow_of_exponent_ge hx h_one_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nz : \u211d\nhx : x \u2264 1\nh_one_le : 1 \u2264 z\n\u22a2 x ^ z \u2264 x"}, {"line": "nth_rw 2 [\u2190 ENNReal.rpow_one x]", "tactic_state": "x : ENNReal\nz : \u211d\nhx : x \u2264 1\nh_one_le : 1 \u2264 z\n\u22a2 x ^ z \u2264 x ^ 1"}, {"line": "exact ENNReal.rpow_le_rpow_of_exponent_ge hx h_one_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_rpow_self_of_one_le {x : \u211d\u22650\u221e} {z : \u211d} (hx : 1 \u2264 x) (h_one_le : 1 \u2264 z) : x \u2264 x ^ z := by\n  nth_rw 1 [\u2190 ENNReal.rpow_one x]\n  exact ENNReal.rpow_le_rpow_of_exponent_le hx h_one_le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nz : \u211d\nhx : 1 \u2264 x\nh_one_le : 1 \u2264 z\n\u22a2 x \u2264 x ^ z"}, {"line": "nth_rw 1 [\u2190 ENNReal.rpow_one x]", "tactic_state": "x : ENNReal\nz : \u211d\nhx : 1 \u2264 x\nh_one_le : 1 \u2264 z\n\u22a2 x ^ 1 \u2264 x ^ z"}, {"line": "exact ENNReal.rpow_le_rpow_of_exponent_le hx h_one_le", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_rpow (x : \u211d\u22650\u221e) (z : \u211d) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [ENNReal.toReal]\n  rw [ENNReal.toReal]\n  rw [\u2190 NNReal.coe_rpow]\n  rw [ENNReal.toNNReal_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : ENNReal\nz : \u211d\n\u22a2 x.toReal ^ z = (x ^ z).toReal"}, {"line": "rw [ENNReal.toReal]", "tactic_state": "x : ENNReal\nz : \u211d\n\u22a2 \u2191x.toNNReal ^ z = (x ^ z).toReal"}, {"line": "rw [ENNReal.toReal]", "tactic_state": "x : ENNReal\nz : \u211d\n\u22a2 \u2191x.toNNReal ^ z = \u2191(x ^ z).toNNReal"}, {"line": "rw [\u2190 NNReal.coe_rpow]", "tactic_state": "x : ENNReal\nz : \u211d\n\u22a2 \u2191(x.toNNReal ^ z) = \u2191(x ^ z).toNNReal"}, {"line": "rw [ENNReal.toNNReal_rpow]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma _root_.Real.enorm_rpow_of_nonneg {x y : \u211d} (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    \u2016x ^ y\u2016\u2091 = \u2016x\u2016\u2091 ^ y := by simp [enorm, nnnorm_rpow_of_nonneg hx, coe_rpow_of_nonneg _ hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/NNReal.lean", "context": {"open": ["Real NNReal ENNReal ComplexConjugate Finset Function Set"], "variables": ["{x : \u211d\u22650} {w y z : \u211d}", "{y : \u211d\u22650}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 \u2016x ^ y\u2016\u2091 = \u2016x\u2016\u2091 ^ y"}, {"line": "simp [enorm, nnnorm_rpow_of_nonneg hx, coe_rpow_of_nonneg _ hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_def_of_pos {x : \u211d} (hx : 0 < x) (y : \u211d) : x ^ y = exp (log x * y) := by\n  rw [rpow_def_of_nonneg (le_of_lt hx)]\n  rw [if_neg (ne_of_gt hx)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 x ^ y = exp (log x * y)"}, {"line": "rw [rpow_def_of_nonneg (le_of_lt hx)]", "tactic_state": "x : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 (if x = 0 then if y = 0 then 1 else 0 else exp (log x * y)) = exp (log x * y)"}, {"line": "rw [if_neg (ne_of_gt hx)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_mul (x y : \u211d) : exp (x * y) = exp x ^ y := by rw [rpow_def_of_pos (exp_pos _), log_exp]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 exp (x * y) = exp x ^ y"}, {"line": "rw [rpow_def_of_pos (exp_pos _), log_exp]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_natCast (x : \u211d) (n : \u2115) : x ^ (n : \u211d) = x ^ n := by simpa using rpow_intCast x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 x ^ \u2191n = x ^ n"}, {"line": "simpa using rpow_intCast x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem exp_one_rpow (x : \u211d) : exp 1 ^ x = exp x := by rw [\u2190 exp_mul, one_mul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 exp 1 ^ x = exp x"}, {"line": "rw [\u2190 exp_mul, one_mul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_eq_zero_iff_of_nonneg (hx : 0 \u2264 x) : x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0 := by\n  simp only [rpow_def_of_nonneg hx]\n  split_ifs <;> simp [*, exp_ne_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 x ^ y = 0 \u2194 x = 0 \u2227 y \u2260 0"}, {"line": "simp only [rpow_def_of_nonneg hx]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 (if x = 0 then if y = 0 then 1 else 0 else exp (log x * y)) = 0 \u2194 x = 0 \u2227 y \u2260 0"}, {"line": "split_ifs <;> simp [*, exp_ne_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_eq_zero (hx : 0 \u2264 x) (hy : y \u2260 0) : x ^ y = 0 \u2194 x = 0 := by\n  simp [rpow_eq_zero_iff_of_nonneg, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : y \u2260 0\n\u22a2 x ^ y = 0 \u2194 x = 0"}, {"line": "simp [rpow_eq_zero_iff_of_nonneg, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_zero (x : \u211d) : x ^ (0 : \u211d) = 1 := by simp [rpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x ^ 0 = 1"}, {"line": "simp [rpow_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_zero_pos (x : \u211d) : 0 < x ^ (0 : \u211d) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 0 < x ^ 0"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow {x : \u211d} (h : x \u2260 0) : (0 : \u211d) ^ x = 0 := by simp [rpow_def, *]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh : x \u2260 0\n\u22a2 0 ^ x = 0"}, {"line": "simp [rpow_def, *]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_zero_rpow_iff {x : \u211d} {a : \u211d} : a = 0 ^ x \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1 := by\n  rw [\u2190 zero_rpow_eq_iff]\n  rw [eq_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x a : \u211d\n\u22a2 a = 0 ^ x \u2194 x \u2260 0 \u2227 a = 0 \u2228 x = 0 \u2227 a = 1"}, {"line": "rw [\u2190 zero_rpow_eq_iff]", "tactic_state": "x a : \u211d\n\u22a2 a = 0 ^ x \u2194 0 ^ x = a"}, {"line": "rw [eq_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_one (x : \u211d) : x ^ (1 : \u211d) = x := by simp [rpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x ^ 1 = x"}, {"line": "simp [rpow_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_rpow (x : \u211d) : (1 : \u211d) ^ x = 1 := by simp [rpow_def]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 1 ^ x = 1"}, {"line": "simp [rpow_def]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_le_one (x : \u211d) : (0 : \u211d) ^ x \u2264 1 := by\n  by_cases h : x = 0 <;> simp [h, zero_le_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 0 ^ x \u2264 1"}, {"line": "by_cases h : x = 0 <;> simp [h, zero_le_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem zero_rpow_nonneg (x : \u211d) : 0 \u2264 (0 : \u211d) ^ x := by\n  by_cases h : x = 0 <;> simp [h, zero_le_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 0 \u2264 0 ^ x"}, {"line": "by_cases h : x = 0 <;> simp [h, zero_le_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_rpow_of_nonneg {x y : \u211d} (hx_nonneg : 0 \u2264 x) : |x ^ y| = |x| ^ y := by\n  have h_rpow_nonneg : 0 \u2264 x ^ y := Real.rpow_nonneg hx_nonneg _\n  rw [abs_eq_self.mpr hx_nonneg]\n  rw [abs_eq_self.mpr h_rpow_nonneg]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx_nonneg : 0 \u2264 x\n\u22a2 |x ^ y| = |x| ^ y"}, {"line": "have h_rpow_nonneg : 0 \u2264 x ^ y := Real.rpow_nonneg hx_nonneg _", "tactic_state": "x y : \u211d\nhx_nonneg : 0 \u2264 x\nh_rpow_nonneg : 0 \u2264 x ^ y\n\u22a2 |x ^ y| = |x| ^ y"}, {"line": "rw [abs_eq_self.mpr hx_nonneg]", "tactic_state": "x y : \u211d\nhx_nonneg : 0 \u2264 x\nh_rpow_nonneg : 0 \u2264 x ^ y\n\u22a2 |x ^ y| = x ^ y"}, {"line": "rw [abs_eq_self.mpr h_rpow_nonneg]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_rpow_le_exp_log_mul (x y : \u211d) : |x ^ y| \u2264 exp (log x * y) := by\n  refine (abs_rpow_le_abs_rpow x y).trans ?_\n  by_cases hx : x = 0\n  \u00b7 by_cases hy : y = 0 <;> simp [hx, hy, zero_le_one]\n  \u00b7 rw [rpow_def_of_pos (abs_pos.2 hx), log_abs]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\n\u22a2 |x ^ y| \u2264 exp (log x * y)"}, {"line": "refine (abs_rpow_le_abs_rpow x y).trans ?_", "tactic_state": "x y : \u211d\n\u22a2 |x| ^ y \u2264 exp (log x * y)"}, {"line": "by_cases hx : x = 0", "tactic_state": "case pos\nx y : \u211d\nhx : x = 0\n\u22a2 |x| ^ y \u2264 exp (log x * y)\n---\ncase neg\nx y : \u211d\nhx : \u00acx = 0\n\u22a2 |x| ^ y \u2264 exp (log x * y)"}, {"line": "\u00b7 by_cases hy : y = 0 <;> simp [hx, hy, zero_le_one]", "tactic_state": "case neg\nx y : \u211d\nhx : \u00acx = 0\n\u22a2 |x| ^ y \u2264 exp (log x * y)"}, {"line": "\u00b7 rw [rpow_def_of_pos (abs_pos.2 hx), log_abs]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_inv_log (hx\u2080 : 0 < x) (hx\u2081 : x \u2260 1) : x ^ (log x)\u207b\u00b9 = exp 1 := by\n  rw [rpow_def_of_pos hx\u2080]\n  rw [mul_inv_cancel\u2080]\n  exact log_ne_zero.2 \u27e8hx\u2080.ne', hx\u2081, (hx\u2080.trans' <| by norm_num).ne'\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\n\u22a2 x ^ (log x)\u207b\u00b9 = exp 1"}, {"line": "rw [rpow_def_of_pos hx\u2080]", "tactic_state": "x : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\n\u22a2 exp (log x * (log x)\u207b\u00b9) = exp 1"}, {"line": "rw [mul_inv_cancel\u2080]", "tactic_state": "x : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\n\u22a2 log x \u2260 0"}, {"line": "exact log_ne_zero.2 \u27e8hx\u2080.ne', hx\u2081, (hx\u2080.trans' <| by norm_num).ne'\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem norm_rpow_of_nonneg {x y : \u211d} (hx_nonneg : 0 \u2264 x) : \u2016x ^ y\u2016 = \u2016x\u2016 ^ y := by\n  simp_rw [Real.norm_eq_abs]\n  exact abs_rpow_of_nonneg hx_nonneg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx_nonneg : 0 \u2264 x\n\u22a2 \u2016x ^ y\u2016 = \u2016x\u2016 ^ y"}, {"line": "simp_rw [Real.norm_eq_abs]", "tactic_state": "x y : \u211d\nhx_nonneg : 0 \u2264 x\n\u22a2 |x ^ y| = |x| ^ y"}, {"line": "exact abs_rpow_of_nonneg hx_nonneg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add (hx : 0 < x) (y z : \u211d) : x ^ (y + z) = x ^ y * x ^ z := by\n  simp only [rpow_def_of_pos hx]\n  simp only [mul_add]\n  simp only [exp_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 x ^ (y + z) = x ^ y * x ^ z"}, {"line": "simp only [rpow_def_of_pos hx]", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 exp (log x * (y + z)) = exp (log x * y) * exp (log x * z)"}, {"line": "simp only [mul_add]", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 exp (log x * y + log x * z) = exp (log x * y) * exp (log x * z)"}, {"line": "simp only [exp_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_of_nonneg (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hz : 0 \u2264 z) :\n    x ^ (y + z) = x ^ y * x ^ z := by\n  rcases hy.eq_or_lt with (rfl | hy)\n  \u00b7 rw [zero_add, rpow_zero, one_mul]\n  exact rpow_add' hx (ne_of_gt <| add_pos_of_pos_of_nonneg hy hz)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhz : 0 \u2264 z\n\u22a2 x ^ (y + z) = x ^ y * x ^ z"}, {"line": "rcases hy.eq_or_lt with (rfl | hy)", "tactic_state": "case inl\nx z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhy : 0 \u2264 0\n\u22a2 x ^ (0 + z) = x ^ 0 * x ^ z\n---\ncase inr\nx y z : \u211d\nhx : 0 \u2264 x\nhy\u271d : 0 \u2264 y\nhz : 0 \u2264 z\nhy : 0 < y\n\u22a2 x ^ (y + z) = x ^ y * x ^ z"}, {"line": "\u00b7 rw [zero_add, rpow_zero, one_mul]", "tactic_state": "case inr\nx y z : \u211d\nhx : 0 \u2264 x\nhy\u271d : 0 \u2264 y\nhz : 0 \u2264 z\nhy : 0 < y\n\u22a2 x ^ (y + z) = x ^ y * x ^ z"}, {"line": "exact rpow_add' hx (ne_of_gt <| add_pos_of_pos_of_nonneg hy hz)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_sub {x : \u211d} (hx : 0 < x) (y z : \u211d) : x ^ (y - z) = x ^ y / x ^ z := by\n  simp only [sub_eq_add_neg]\n  simp only [rpow_add hx]\n  simp only [rpow_neg (le_of_lt hx)]\n  simp only [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 x ^ (y - z) = x ^ y / x ^ z"}, {"line": "simp only [sub_eq_add_neg]", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 x ^ (y + -z) = x ^ y / x ^ z"}, {"line": "simp only [rpow_add hx]", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 x ^ y * x ^ (-z) = x ^ y / x ^ z"}, {"line": "simp only [rpow_neg (le_of_lt hx)]", "tactic_state": "x : \u211d\nhx : 0 < x\ny z : \u211d\n\u22a2 x ^ y * (x ^ z)\u207b\u00b9 = x ^ y / x ^ z"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_sub' {x : \u211d} (hx : 0 \u2264 x) {y z : \u211d} (h : y - z \u2260 0) : x ^ (y - z) = x ^ y / x ^ z := by\n  simp only [sub_eq_add_neg] at h \u22a2\n  simp only [rpow_add' hx h]\n  simp only [rpow_neg hx]\n  simp only [div_eq_mul_inv]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny z : \u211d\nh : y - z \u2260 0\n\u22a2 x ^ (y - z) = x ^ y / x ^ z"}, {"line": "simp only [sub_eq_add_neg] at h \u22a2", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny z : \u211d\nh : y + -z \u2260 0\n\u22a2 x ^ (y + -z) = x ^ y / x ^ z"}, {"line": "simp only [rpow_add' hx h]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny z : \u211d\nh : y + -z \u2260 0\n\u22a2 x ^ y * x ^ (-z) = x ^ y / x ^ z"}, {"line": "simp only [rpow_neg hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny z : \u211d\nh : y + -z \u2260 0\n\u22a2 x ^ y * (x ^ z)\u207b\u00b9 = x ^ y / x ^ z"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_pow_comm {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) (n : \u2115) : (x ^ y) ^ n = (x ^ n) ^ y := by\n  simp_rw [\u2190 rpow_natCast, \u2190 rpow_mul hx, mul_comm y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2115\n\u22a2 (x ^ y) ^ n = (x ^ n) ^ y"}, {"line": "simp_rw [\u2190 rpow_natCast, \u2190 rpow_mul hx, mul_comm y]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_zpow_comm {x : \u211d} (hx : 0 \u2264 x) (y : \u211d) (n : \u2124) : (x ^ y) ^ n = (x ^ n) ^ y := by\n  simp_rw [\u2190 rpow_intCast, \u2190 rpow_mul hx, mul_comm y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2124\n\u22a2 (x ^ y) ^ n = (x ^ n) ^ y"}, {"line": "simp_rw [\u2190 rpow_intCast, \u2190 rpow_mul hx, mul_comm y]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_intCast {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2124) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_def]\n  rw [rpow_def]\n  rw [Complex.ofReal_add]\n  rw [Complex.cpow_add _ _ (Complex.ofReal_ne_zero.mpr hx)]\n  rw [Complex.ofReal_intCast]\n  rw [Complex.cpow_intCast]\n  rw [\u2190 Complex.ofReal_zpow]\n  rw [mul_comm]\n  rw [Complex.re_ofReal_mul]\n  rw [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 x ^ (y + \u2191n) = x ^ y * x ^ n"}, {"line": "rw [rpow_def]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191(y + \u2191n)).re = x ^ y * x ^ n"}, {"line": "rw [rpow_def]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191(y + \u2191n)).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [Complex.ofReal_add]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ (\u2191y + \u2191\u2191n)).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [Complex.cpow_add _ _ (Complex.ofReal_ne_zero.mpr hx)]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191y * \u2191x ^ \u2191\u2191n).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [Complex.ofReal_intCast]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191y * \u2191x ^ \u2191n).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [Complex.cpow_intCast]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191y * \u2191x ^ n).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [\u2190 Complex.ofReal_zpow]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191x ^ \u2191y * \u2191(x ^ n)).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [mul_comm]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 (\u2191(x ^ n) * \u2191x ^ \u2191y).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [Complex.re_ofReal_mul]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2124\n\u22a2 x ^ n * (\u2191x ^ \u2191y).re = (\u2191x ^ \u2191y).re * x ^ n"}, {"line": "rw [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_natCast {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y + n) = x ^ y * x ^ n := by\n  simpa using rpow_add_intCast hx y n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2115\n\u22a2 x ^ (y + \u2191n) = x ^ y * x ^ n"}, {"line": "simpa using rpow_add_intCast hx y n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_intCast {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y - n) = x ^ y / x ^ n := by\n  simpa using rpow_add_intCast hx y (-n)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2115\n\u22a2 x ^ (y - \u2191n) = x ^ y / x ^ n"}, {"line": "simpa using rpow_add_intCast hx y (-n)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_natCast {x : \u211d} (hx : x \u2260 0) (y : \u211d) (n : \u2115) : x ^ (y - n) = x ^ y / x ^ n := by\n  simpa using rpow_sub_intCast hx y n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nn : \u2115\n\u22a2 x ^ (y - \u2191n) = x ^ y / x ^ n"}, {"line": "simpa using rpow_sub_intCast hx y n", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_intCast' (hx : 0 \u2264 x) {n : \u2124} (h : y + n \u2260 0) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_add' hx h]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nn : \u2124\nh : y + \u2191n \u2260 0\n\u22a2 x ^ (y + \u2191n) = x ^ y * x ^ n"}, {"line": "rw [rpow_add' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nn : \u2124\nh : y + \u2191n \u2260 0\n\u22a2 x ^ y * x ^ \u2191n = x ^ y * x ^ n"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_natCast' (hx : 0 \u2264 x) (h : y + n \u2260 0) : x ^ (y + n) = x ^ y * x ^ n := by\n  rw [rpow_add' hx h]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 \u2264 x\nh : y + \u2191n \u2260 0\n\u22a2 x ^ (y + \u2191n) = x ^ y * x ^ n"}, {"line": "rw [rpow_add' hx h]", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 \u2264 x\nh : y + \u2191n \u2260 0\n\u22a2 x ^ y * x ^ \u2191n = x ^ y * x ^ n"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_intCast' (hx : 0 \u2264 x) {n : \u2124} (h : y - n \u2260 0) : x ^ (y - n) = x ^ y / x ^ n := by\n  rw [rpow_sub' hx h]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nn : \u2124\nh : y - \u2191n \u2260 0\n\u22a2 x ^ (y - \u2191n) = x ^ y / x ^ n"}, {"line": "rw [rpow_sub' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nn : \u2124\nh : y - \u2191n \u2260 0\n\u22a2 x ^ y / x ^ \u2191n = x ^ y / x ^ n"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_natCast' (hx : 0 \u2264 x) (h : y - n \u2260 0) : x ^ (y - n) = x ^ y / x ^ n := by\n  rw [rpow_sub' hx h]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 \u2264 x\nh : y - \u2191n \u2260 0\n\u22a2 x ^ (y - \u2191n) = x ^ y / x ^ n"}, {"line": "rw [rpow_sub' hx h]", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 \u2264 x\nh : y - \u2191n \u2260 0\n\u22a2 x ^ y / x ^ \u2191n = x ^ y / x ^ n"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_add_one {x : \u211d} (hx : x \u2260 0) (y : \u211d) : x ^ (y + 1) = x ^ y * x := by\n  simpa using rpow_add_natCast hx y 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\n\u22a2 x ^ (y + 1) = x ^ y * x"}, {"line": "simpa using rpow_add_natCast hx y 1", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_sub_one {x : \u211d} (hx : x \u2260 0) (y : \u211d) : x ^ (y - 1) = x ^ y / x := by\n  simpa using rpow_sub_natCast hx y 1\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\n\u22a2 x ^ (y - 1) = x ^ y / x"}, {"line": "simpa using rpow_sub_natCast hx y 1", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_add_one' (hx : 0 \u2264 x) (h : y + 1 \u2260 0) : x ^ (y + 1) = x ^ y * x := by\n  rw [rpow_add' hx h]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : y + 1 \u2260 0\n\u22a2 x ^ (y + 1) = x ^ y * x"}, {"line": "rw [rpow_add' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : y + 1 \u2260 0\n\u22a2 x ^ y * x ^ 1 = x ^ y * x"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_one_add' (hx : 0 \u2264 x) (h : 1 + y \u2260 0) : x ^ (1 + y) = x * x ^ y := by\n  rw [rpow_add' hx h]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : 1 + y \u2260 0\n\u22a2 x ^ (1 + y) = x * x ^ y"}, {"line": "rw [rpow_add' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : 1 + y \u2260 0\n\u22a2 x ^ 1 * x ^ y = x * x ^ y"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_sub_one' (hx : 0 \u2264 x) (h : y - 1 \u2260 0) : x ^ (y - 1) = x ^ y / x := by\n  rw [rpow_sub' hx h]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : y - 1 \u2260 0\n\u22a2 x ^ (y - 1) = x ^ y / x"}, {"line": "rw [rpow_sub' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : y - 1 \u2260 0\n\u22a2 x ^ y / x ^ 1 = x ^ y / x"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_one_sub' (hx : 0 \u2264 x) (h : 1 - y \u2260 0) : x ^ (1 - y) = x / x ^ y := by\n  rw [rpow_sub' hx h]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : 1 - y \u2260 0\n\u22a2 x ^ (1 - y) = x / x ^ y"}, {"line": "rw [rpow_sub' hx h]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nh : 1 - y \u2260 0\n\u22a2 x ^ 1 / x ^ y = x / x ^ y"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_two (x : \u211d) : x ^ (2 : \u211d) = x ^ 2 := by\n  rw [\u2190 rpow_natCast]\n  simp only [Nat.cast_ofNat]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x ^ 2 = x ^ 2"}, {"line": "rw [\u2190 rpow_natCast]", "tactic_state": "x : \u211d\n\u22a2 x ^ 2 = x ^ \u21912"}, {"line": "simp only [Nat.cast_ofNat]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_rpow (hx : 0 \u2264 x) (hy : 0 \u2264 y) : (x * y) ^ z = x ^ z * y ^ z := by\n  iterate 2 rw [Real.rpow_def_of_nonneg]; split_ifs with h_ifs <;> simp_all\n  \u00b7 rw [log_mul \u2039_\u203a \u2039_\u203a, add_mul, exp_add, rpow_def_of_pos (hy.lt_of_ne' \u2039_\u203a)]\n  all_goals positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 (x * y) ^ z = x ^ z * y ^ z"}, {"line": "iterate 2 rw [Real.rpow_def_of_nonneg]; split_ifs with h_ifs <;> simp_all", "tactic_state": "case neg\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nh_ifs\u271d : \u00acy = 0\nh_ifs : \u00acx = 0\n\u22a2 exp (log (x * y) * z) = exp (log x * z) * y ^ z\n---\ncase neg.hx\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nh_ifs : \u00acx = 0 \u2227 \u00acy = 0\n\u22a2 0 \u2264 x\n---\ncase hx\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 0 \u2264 x * y"}, {"line": "\u00b7 rw [log_mul \u2039_\u203a \u2039_\u203a, add_mul, exp_add, rpow_def_of_pos (hy.lt_of_ne' \u2039_\u203a)]", "tactic_state": "case neg.hx\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nh_ifs : \u00acx = 0 \u2227 \u00acy = 0\n\u22a2 0 \u2264 x\n---\ncase hx\nx y z : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\n\u22a2 0 \u2264 x * y"}, {"line": "all_goals positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem inv_rpow (hx : 0 \u2264 x) (y : \u211d) : x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9 := by\n  simp only [\u2190 rpow_neg_one]\n  simp only [\u2190 rpow_mul hx]\n  simp only [mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 x\u207b\u00b9 ^ y = (x ^ y)\u207b\u00b9"}, {"line": "simp only [\u2190 rpow_neg_one]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 (x ^ (-1)) ^ y = (x ^ y) ^ (-1)"}, {"line": "simp only [\u2190 rpow_mul hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\n\u22a2 x ^ (-1 * y) = x ^ (y * -1)"}, {"line": "simp only [mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem div_rpow (hx : 0 \u2264 x) (hy : 0 \u2264 y) (z : \u211d) : (x / y) ^ z = x ^ z / y ^ z := by\n  simp only [div_eq_mul_inv]\n  simp only [mul_rpow hx (inv_nonneg.2 hy)]\n  simp only [inv_rpow hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nz : \u211d\n\u22a2 (x / y) ^ z = x ^ z / y ^ z"}, {"line": "simp only [div_eq_mul_inv]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nz : \u211d\n\u22a2 (x * y\u207b\u00b9) ^ z = x ^ z * (y ^ z)\u207b\u00b9"}, {"line": "simp only [mul_rpow hx (inv_nonneg.2 hy)]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nz : \u211d\n\u22a2 x ^ z * y\u207b\u00b9 ^ z = x ^ z * (y ^ z)\u207b\u00b9"}, {"line": "simp only [inv_rpow hy]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem log_rpow {x : \u211d} (hx : 0 < x) (y : \u211d) : log (x ^ y) = y * log x := by\n  apply exp_injective\n  rw [exp_log (rpow_pos_of_pos hx y)]\n  rw [\u2190 exp_log hx]\n  rw [mul_comm]\n  rw [rpow_def_of_pos (exp_pos (log x)) y]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 log (x ^ y) = y * log x"}, {"line": "apply exp_injective", "tactic_state": "case a\nx : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 exp (log (x ^ y)) = exp (y * log x)"}, {"line": "rw [exp_log (rpow_pos_of_pos hx y)]", "tactic_state": "case a\nx : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 x ^ y = exp (y * log x)"}, {"line": "rw [\u2190 exp_log hx]", "tactic_state": "case a\nx : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 exp (log x) ^ y = exp (y * log (exp (log x)))"}, {"line": "rw [mul_comm]", "tactic_state": "case a\nx : \u211d\nhx : 0 < x\ny : \u211d\n\u22a2 exp (log x) ^ y = exp (log (exp (log x)) * y)"}, {"line": "rw [rpow_def_of_pos (exp_pos (log x)) y]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem pow_rpow_inv_natCast (hx : 0 \u2264 x) (hn : n \u2260 0) : (x ^ n) ^ (n\u207b\u00b9 : \u211d) = x := by\n  have hn0 : (n : \u211d) \u2260 0 := Nat.cast_ne_zero.2 hn\n  rw [\u2190 rpow_natCast]\n  rw [\u2190 rpow_mul hx]\n  rw [mul_inv_cancel\u2080 hn0]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\n\u22a2 (x ^ n) ^ (\u2191n)\u207b\u00b9 = x"}, {"line": "have hn0 : (n : \u211d) \u2260 0 := Nat.cast_ne_zero.2 hn", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ n) ^ (\u2191n)\u207b\u00b9 = x"}, {"line": "rw [\u2190 rpow_natCast]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ \u2191n) ^ (\u2191n)\u207b\u00b9 = x"}, {"line": "rw [\u2190 rpow_mul hx]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 x ^ (\u2191n * (\u2191n)\u207b\u00b9) = x"}, {"line": "rw [mul_inv_cancel\u2080 hn0]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 x ^ 1 = x"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_inv_natCast_pow (hx : 0 \u2264 x) (hn : n \u2260 0) : (x ^ (n\u207b\u00b9 : \u211d)) ^ n = x := by\n  have hn0 : (n : \u211d) \u2260 0 := Nat.cast_ne_zero.2 hn\n  rw [\u2190 rpow_natCast]\n  rw [\u2190 rpow_mul hx]\n  rw [inv_mul_cancel\u2080 hn0]\n  rw [rpow_one]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x"}, {"line": "have hn0 : (n : \u211d) \u2260 0 := Nat.cast_ne_zero.2 hn", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ n = x"}, {"line": "rw [\u2190 rpow_natCast]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 (x ^ (\u2191n)\u207b\u00b9) ^ \u2191n = x"}, {"line": "rw [\u2190 rpow_mul hx]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 x ^ ((\u2191n)\u207b\u00b9 * \u2191n) = x"}, {"line": "rw [inv_mul_cancel\u2080 hn0]", "tactic_state": "x : \u211d\nn : \u2115\nhx : 0 \u2264 x\nhn : n \u2260 0\nhn0 : \u2191n \u2260 0\n\u22a2 x ^ 1 = x"}, {"line": "rw [rpow_one]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_natCast_mul (hx : 0 \u2264 x) (n : \u2115) (z : \u211d) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul hx]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\nz : \u211d\n\u22a2 x ^ (\u2191n * z) = (x ^ n) ^ z"}, {"line": "rw [rpow_mul hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2115\nz : \u211d\n\u22a2 (x ^ \u2191n) ^ z = (x ^ n) ^ z"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_mul_natCast (hx : 0 \u2264 x) (y : \u211d) (n : \u2115) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul hx]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2115\n\u22a2 x ^ (y * \u2191n) = (x ^ y) ^ n"}, {"line": "rw [rpow_mul hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2115\n\u22a2 (x ^ y) ^ \u2191n = (x ^ y) ^ n"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_intCast_mul (hx : 0 \u2264 x) (n : \u2124) (z : \u211d) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul hx]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\nz : \u211d\n\u22a2 x ^ (\u2191n * z) = (x ^ n) ^ z"}, {"line": "rw [rpow_mul hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\nn : \u2124\nz : \u211d\n\u22a2 (x ^ \u2191n) ^ z = (x ^ n) ^ z"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_mul_intCast (hx : 0 \u2264 x) (y : \u211d) (n : \u2124) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul hx]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2124\n\u22a2 x ^ (y * \u2191n) = (x ^ y) ^ n"}, {"line": "rw [rpow_mul hx]", "tactic_state": "x : \u211d\nhx : 0 \u2264 x\ny : \u211d\nn : \u2124\n\u22a2 (x ^ y) ^ \u2191n = (x ^ y) ^ n"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_lt_rpow_of_neg (hx : 0 < x) (hxy : x < y) (hz : z < 0) : y ^ z < x ^ z := by\n  have := hx.trans hxy\n  rw [\u2190 inv_lt_inv\u2080]\n  rw [\u2190 rpow_neg]\n  rw [\u2190 rpow_neg]\n  on_goal 1 => refine rpow_lt_rpow ?_ hxy (neg_pos.2 hz)\n  all_goals positivity\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\n\u22a2 y ^ z < x ^ z"}, {"line": "have := hx.trans hxy", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 y ^ z < x ^ z"}, {"line": "rw [\u2190 inv_lt_inv\u2080]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 (x ^ z)\u207b\u00b9 < (y ^ z)\u207b\u00b9\n---\ncase ha\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < x ^ z\n---\ncase hb\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < y ^ z"}, {"line": "rw [\u2190 rpow_neg]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 x ^ (-z) < (y ^ z)\u207b\u00b9\n---\ncase hx\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 x\n---\ncase ha\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < x ^ z\n---\ncase hb\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < y ^ z"}, {"line": "rw [\u2190 rpow_neg]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 x ^ (-z) < y ^ (-z)\n---\ncase hx\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 y\n---\ncase hx\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 x\n---\ncase ha\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < x ^ z\n---\ncase hb\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < y ^ z"}, {"line": "on_goal 1 => refine rpow_lt_rpow ?_ hxy (neg_pos.2 hz)", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 x\n---\ncase hx\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 y\n---\ncase hx\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 \u2264 x\n---\ncase ha\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < x ^ z\n---\ncase hb\nx y z : \u211d\nhx : 0 < x\nhxy : x < y\nhz : z < 0\nthis : 0 < y\n\u22a2 0 < y ^ z"}, {"line": "all_goals positivity", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_rpow_left_iff (hx : 1 < x) : x ^ y < x ^ z \u2194 y < z := by\n  rw [lt_iff_not_le]\n  rw [rpow_le_rpow_left_iff hx]\n  rw [lt_iff_not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 1 < x\n\u22a2 x ^ y < x ^ z \u2194 y < z"}, {"line": "rw [lt_iff_not_le]", "tactic_state": "x y z : \u211d\nhx : 1 < x\n\u22a2 \u00acx ^ z \u2264 x ^ y \u2194 y < z"}, {"line": "rw [rpow_le_rpow_left_iff hx]", "tactic_state": "x y z : \u211d\nhx : 1 < x\n\u22a2 \u00acz \u2264 y \u2194 y < z"}, {"line": "rw [lt_iff_not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) :\n    x ^ y \u2264 x ^ z \u2194 z \u2264 y := by\n  rw [\u2190 log_le_log_iff (rpow_pos_of_pos hx0 y) (rpow_pos_of_pos hx0 z)]\n  rw [log_rpow hx0]\n  rw [log_rpow hx0]\n  rw [mul_le_mul_right_of_neg (log_neg hx0 hx1)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 x ^ y \u2264 x ^ z \u2194 z \u2264 y"}, {"line": "rw [\u2190 log_le_log_iff (rpow_pos_of_pos hx0 y) (rpow_pos_of_pos hx0 z)]", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 log (x ^ y) \u2264 log (x ^ z) \u2194 z \u2264 y"}, {"line": "rw [log_rpow hx0]", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 y * log x \u2264 log (x ^ z) \u2194 z \u2264 y"}, {"line": "rw [log_rpow hx0]", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 y * log x \u2264 z * log x \u2194 z \u2264 y"}, {"line": "rw [mul_le_mul_right_of_neg (log_neg hx0 hx1)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_rpow_left_iff_of_base_lt_one (hx0 : 0 < x) (hx1 : x < 1) :\n    x ^ y < x ^ z \u2194 z < y := by\n  rw [lt_iff_not_le]\n  rw [rpow_le_rpow_left_iff_of_base_lt_one hx0 hx1]\n  rw [lt_iff_not_le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 x ^ y < x ^ z \u2194 z < y"}, {"line": "rw [lt_iff_not_le]", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 \u00acx ^ z \u2264 x ^ y \u2194 z < y"}, {"line": "rw [rpow_le_rpow_left_iff_of_base_lt_one hx0 hx1]", "tactic_state": "x y z : \u211d\nhx0 : 0 < x\nhx1 : x < 1\n\u22a2 \u00acy \u2264 z \u2194 z < y"}, {"line": "rw [lt_iff_not_le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_one {x z : \u211d} (hx1 : 0 \u2264 x) (hx2 : x < 1) (hz : 0 < z) : x ^ z < 1 := by\n  rw [\u2190 one_rpow z]\n  exact rpow_lt_rpow hx1 hx2 hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx1 : 0 \u2264 x\nhx2 : x < 1\nhz : 0 < z\n\u22a2 x ^ z < 1"}, {"line": "rw [\u2190 one_rpow z]", "tactic_state": "x z : \u211d\nhx1 : 0 \u2264 x\nhx2 : x < 1\nhz : 0 < z\n\u22a2 x ^ z < 1 ^ z"}, {"line": "exact rpow_lt_rpow hx1 hx2 hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_one {x z : \u211d} (hx1 : 0 \u2264 x) (hx2 : x \u2264 1) (hz : 0 \u2264 z) : x ^ z \u2264 1 := by\n  rw [\u2190 one_rpow z]\n  exact rpow_le_rpow hx1 hx2 hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx1 : 0 \u2264 x\nhx2 : x \u2264 1\nhz : 0 \u2264 z\n\u22a2 x ^ z \u2264 1"}, {"line": "rw [\u2190 one_rpow z]", "tactic_state": "x z : \u211d\nhx1 : 0 \u2264 x\nhx2 : x \u2264 1\nhz : 0 \u2264 z\n\u22a2 x ^ z \u2264 1 ^ z"}, {"line": "exact rpow_le_rpow hx1 hx2 hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_one_of_one_lt_of_neg {x z : \u211d} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 := by\n  convert rpow_lt_rpow_of_exponent_lt hx hz\n  exact (rpow_zero x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx : 1 < x\nhz : z < 0\n\u22a2 x ^ z < 1"}, {"line": "convert rpow_lt_rpow_of_exponent_lt hx hz", "tactic_state": "case h.e'_4\nx z : \u211d\nhx : 1 < x\nhz : z < 0\n\u22a2 1 = x ^ 0"}, {"line": "exact (rpow_zero x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_one_of_one_le_of_nonpos {x z : \u211d} (hx : 1 \u2264 x) (hz : z \u2264 0) : x ^ z \u2264 1 := by\n  convert rpow_le_rpow_of_exponent_le hx hz\n  exact (rpow_zero x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx : 1 \u2264 x\nhz : z \u2264 0\n\u22a2 x ^ z \u2264 1"}, {"line": "convert rpow_le_rpow_of_exponent_le hx hz", "tactic_state": "case h.e'_4\nx z : \u211d\nhx : 1 \u2264 x\nhz : z \u2264 0\n\u22a2 1 = x ^ 0"}, {"line": "exact (rpow_zero x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rpow {x z : \u211d} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z := by\n  rw [\u2190 one_rpow z]\n  exact rpow_lt_rpow zero_le_one hx hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx : 1 < x\nhz : 0 < z\n\u22a2 1 < x ^ z"}, {"line": "rw [\u2190 one_rpow z]", "tactic_state": "x z : \u211d\nhx : 1 < x\nhz : 0 < z\n\u22a2 1 ^ z < x ^ z"}, {"line": "exact rpow_lt_rpow zero_le_one hx hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_rpow {x z : \u211d} (hx : 1 \u2264 x) (hz : 0 \u2264 z) : 1 \u2264 x ^ z := by\n  rw [\u2190 one_rpow z]\n  exact rpow_le_rpow zero_le_one hx hz\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx : 1 \u2264 x\nhz : 0 \u2264 z\n\u22a2 1 \u2264 x ^ z"}, {"line": "rw [\u2190 one_rpow z]", "tactic_state": "x z : \u211d\nhx : 1 \u2264 x\nhz : 0 \u2264 z\n\u22a2 1 ^ z \u2264 x ^ z"}, {"line": "exact rpow_le_rpow zero_le_one hx hz", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rpow_of_pos_of_lt_one_of_neg (hx1 : 0 < x) (hx2 : x < 1) (hz : z < 0) :\n    1 < x ^ z := by\n  convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz\n  exact (rpow_zero x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx1 : 0 < x\nhx2 : x < 1\nhz : z < 0\n\u22a2 1 < x ^ z"}, {"line": "convert rpow_lt_rpow_of_exponent_gt hx1 hx2 hz", "tactic_state": "case h.e'_3\nx z : \u211d\nhx1 : 0 < x\nhx2 : x < 1\nhz : z < 0\n\u22a2 1 = x ^ 0"}, {"line": "exact (rpow_zero x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_le_rpow_of_pos_of_le_one_of_nonpos (hx1 : 0 < x) (hx2 : x \u2264 1) (hz : z \u2264 0) :\n    1 \u2264 x ^ z := by\n  convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz\n  exact (rpow_zero x).symm\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x z : \u211d\nhx1 : 0 < x\nhx2 : x \u2264 1\nhz : z \u2264 0\n\u22a2 1 \u2264 x ^ z"}, {"line": "convert rpow_le_rpow_of_exponent_ge hx1 hx2 hz", "tactic_state": "case h.e'_3\nx z : \u211d\nhx1 : 0 < x\nhx2 : x \u2264 1\nhz : z \u2264 0\n\u22a2 1 = x ^ 0"}, {"line": "exact (rpow_zero x).symm", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_one_iff_of_pos (hx : 0 < x) : x ^ y < 1 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y := by\n  rw [rpow_def_of_pos hx]\n  rw [exp_lt_one_iff]\n  rw [mul_neg_iff]\n  rw [log_pos_iff hx.le]\n  rw [log_neg_iff hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 x ^ y < 1 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rw [rpow_def_of_pos hx]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 exp (log x * y) < 1 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rw [exp_lt_one_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 log x * y < 0 \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rw [mul_neg_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 0 < log x \u2227 y < 0 \u2228 log x < 0 \u2227 0 < y \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rw [log_pos_iff hx.le]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 1 < x \u2227 y < 0 \u2228 log x < 0 \u2227 0 < y \u2194 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rw [log_neg_iff hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_one_iff (hx : 0 \u2264 x) :\n    x ^ y < 1 \u2194 x = 0 \u2227 y \u2260 0 \u2228 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  \u00b7 rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, zero_lt_one]\n  \u00b7 simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 x ^ y < 1 \u2194 x = 0 \u2227 y \u2260 0 \u2228 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "rcases hx.eq_or_lt with (rfl | hx)", "tactic_state": "case inl\ny : \u211d\nhx : 0 \u2264 0\n\u22a2 0 ^ y < 1 \u2194 0 = 0 \u2227 y \u2260 0 \u2228 1 < 0 \u2227 y < 0 \u2228 0 < 1 \u2227 0 < y\n---\ncase inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 x ^ y < 1 \u2194 x = 0 \u2227 y \u2260 0 \u2228 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "\u00b7 rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, zero_lt_one]", "tactic_state": "case inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 x ^ y < 1 \u2194 x = 0 \u2227 y \u2260 0 \u2228 1 < x \u2227 y < 0 \u2228 x < 1 \u2227 0 < y"}, {"line": "\u00b7 simp [rpow_lt_one_iff_of_pos hx, hx.ne.symm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_one_iff' {x y : \u211d} (hx : 0 \u2264 x) (hy : 0 < y) :\n    x ^ y < 1 \u2194 x < 1 := by\n  rw [\u2190 Real.rpow_lt_rpow_iff hx zero_le_one hy]\n  rw [Real.one_rpow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 < y\n\u22a2 x ^ y < 1 \u2194 x < 1"}, {"line": "rw [\u2190 Real.rpow_lt_rpow_iff hx zero_le_one hy]", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\nhy : 0 < y\n\u22a2 x ^ y < 1 \u2194 x ^ y < 1 ^ y"}, {"line": "rw [Real.one_rpow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rpow_iff_of_pos (hx : 0 < x) : 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0 := by\n  rw [rpow_def_of_pos hx]\n  rw [one_lt_exp_iff]\n  rw [mul_pos_iff]\n  rw [log_pos_iff hx.le]\n  rw [log_neg_iff hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0"}, {"line": "rw [rpow_def_of_pos hx]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 1 < exp (log x * y) \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0"}, {"line": "rw [one_lt_exp_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 0 < log x * y \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0"}, {"line": "rw [mul_pos_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 0 < log x \u2227 0 < y \u2228 log x < 0 \u2227 y < 0 \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0"}, {"line": "rw [log_pos_iff hx.le]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 1 < x \u2227 0 < y \u2228 log x < 0 \u2227 y < 0 \u2194 1 < x \u2227 0 < y \u2228 x < 1 \u2227 y < 0"}, {"line": "rw [log_neg_iff hx]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem one_lt_rpow_iff (hx : 0 \u2264 x) : 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 0 < x \u2227 x < 1 \u2227 y < 0 := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  \u00b7 rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, (zero_lt_one' \u211d).not_lt]\n  \u00b7 simp [one_lt_rpow_iff_of_pos hx, hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 \u2264 x\n\u22a2 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 0 < x \u2227 x < 1 \u2227 y < 0"}, {"line": "rcases hx.eq_or_lt with (rfl | hx)", "tactic_state": "case inl\ny : \u211d\nhx : 0 \u2264 0\n\u22a2 1 < 0 ^ y \u2194 1 < 0 \u2227 0 < y \u2228 0 < 0 \u2227 0 < 1 \u2227 y < 0\n---\ncase inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 0 < x \u2227 x < 1 \u2227 y < 0"}, {"line": "\u00b7 rcases _root_.em (y = 0) with (rfl | hy) <;> simp [*, lt_irrefl, (zero_lt_one' \u211d).not_lt]", "tactic_state": "case inr\nx y : \u211d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 1 < x ^ y \u2194 1 < x \u2227 0 < y \u2228 0 < x \u2227 x < 1 \u2227 y < 0"}, {"line": "\u00b7 simp [one_lt_rpow_iff_of_pos hx, hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_max {x y p : \u211d} (hx : 0 \u2264 x) (hy : 0 \u2264 y) (hp : 0 \u2264 p) :\n    (max x y) ^ p = max (x ^ p) (y ^ p) := by\n  rcases le_total x y with hxy | hxy\n  \u00b7 rw [max_eq_right hxy, max_eq_right (rpow_le_rpow hx hxy hp)]\n  \u00b7 rw [max_eq_left hxy, max_eq_left (rpow_le_rpow hy hxy hp)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y p : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhp : 0 \u2264 p\n\u22a2 max x y ^ p = max (x ^ p) (y ^ p)"}, {"line": "rcases le_total x y with hxy | hxy", "tactic_state": "case inl\nx y p : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhp : 0 \u2264 p\nhxy : x \u2264 y\n\u22a2 max x y ^ p = max (x ^ p) (y ^ p)\n---\ncase inr\nx y p : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhp : 0 \u2264 p\nhxy : y \u2264 x\n\u22a2 max x y ^ p = max (x ^ p) (y ^ p)"}, {"line": "\u00b7 rw [max_eq_right hxy, max_eq_right (rpow_le_rpow hx hxy hp)]", "tactic_state": "case inr\nx y p : \u211d\nhx : 0 \u2264 x\nhy : 0 \u2264 y\nhp : 0 \u2264 p\nhxy : y \u2264 x\n\u22a2 max x y ^ p = max (x ^ p) (y ^ p)"}, {"line": "\u00b7 rw [max_eq_left hxy, max_eq_left (rpow_le_rpow hy hxy hp)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_le_rpow_of_le_one (h\u2081 : 0 \u2264 x) (h\u2082 : x \u2264 1) (h\u2083 : y \u2264 1) : x \u2264 x ^ y := by\n  simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h\u2081 h\u2082 h\u2083 fun _ \u21a6 (absurd \u00b7 one_ne_zero)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 0 \u2264 x\nh\u2082 : x \u2264 1\nh\u2083 : y \u2264 1\n\u22a2 x \u2264 x ^ y"}, {"line": "simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h\u2081 h\u2082 h\u2083 fun _ \u21a6 (absurd \u00b7 one_ne_zero)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_le_rpow_of_one_le (h\u2081 : 1 \u2264 x) (h\u2082 : 1 \u2264 y) : x \u2264 x ^ y := by\n  simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 1 \u2264 x\nh\u2082 : 1 \u2264 y\n\u22a2 x \u2264 x ^ y"}, {"line": "simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_self_of_le_one (h\u2081 : 0 \u2264 x) (h\u2082 : x \u2264 1) (h\u2083 : 1 \u2264 y) : x ^ y \u2264 x := by\n  simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h\u2081 h\u2082 h\u2083 fun _ \u21a6 (absurd \u00b7 (one_pos.trans_le h\u2083).ne')\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 0 \u2264 x\nh\u2082 : x \u2264 1\nh\u2083 : 1 \u2264 y\n\u22a2 x ^ y \u2264 x"}, {"line": "simpa only [rpow_one]\n    using rpow_le_rpow_of_exponent_ge_of_imp h\u2081 h\u2082 h\u2083 fun _ \u21a6 (absurd \u00b7 (one_pos.trans_le h\u2083).ne')", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_self_of_one_le (h\u2081 : 1 \u2264 x) (h\u2082 : y \u2264 1) : x ^ y \u2264 x := by\n  simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 1 \u2264 x\nh\u2082 : y \u2264 1\n\u22a2 x ^ y \u2264 x"}, {"line": "simpa only [rpow_one] using rpow_le_rpow_of_exponent_le h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_lt_rpow_of_lt_one (h\u2081 : 0 < x) (h\u2082 : x < 1) (h\u2083 : y < 1) : x < x ^ y := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h\u2081 h\u2082 h\u2083\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 0 < x\nh\u2082 : x < 1\nh\u2083 : y < 1\n\u22a2 x < x ^ y"}, {"line": "simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h\u2081 h\u2082 h\u2083", "tactic_state": "No Goals!"}]}
{"declaration": "theorem self_lt_rpow_of_one_lt (h\u2081 : 1 < x) (h\u2082 : 1 < y) : x < x ^ y := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 1 < x\nh\u2082 : 1 < y\n\u22a2 x < x ^ y"}, {"line": "simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_self_of_lt_one (h\u2081 : 0 < x) (h\u2082 : x < 1) (h\u2083 : 1 < y) : x ^ y < x := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h\u2081 h\u2082 h\u2083\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 0 < x\nh\u2082 : x < 1\nh\u2083 : 1 < y\n\u22a2 x ^ y < x"}, {"line": "simpa only [rpow_one] using rpow_lt_rpow_of_exponent_gt h\u2081 h\u2082 h\u2083", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_lt_self_of_one_lt (h\u2081 : 1 < x) (h\u2082 : y < 1) : x ^ y < x := by\n  simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h\u2081 h\u2082\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nh\u2081 : 1 < x\nh\u2082 : y < 1\n\u22a2 x ^ y < x"}, {"line": "simpa only [rpow_one] using rpow_lt_rpow_of_exponent_lt h\u2081 h\u2082", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_left_injOn {x : \u211d} (hx : x \u2260 0) : InjOn (fun y : \u211d => y ^ x) { y : \u211d | 0 \u2264 y } := by\n  rintro y hy z hz (hyz : y ^ x = z ^ x)\n  rw [\u2190 rpow_one y]\n  rw [\u2190 rpow_one z]\n  rw [\u2190 mul_inv_cancel\u2080 hx]\n  rw [rpow_mul hy]\n  rw [rpow_mul hz]\n  rw [hyz]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhx : x \u2260 0\n\u22a2 InjOn (fun y => y ^ x) {y | 0 \u2264 y}"}, {"line": "rintro y hy z hz (hyz : y ^ x = z ^ x)", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 y = z"}, {"line": "rw [\u2190 rpow_one y]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 y ^ 1 = z"}, {"line": "rw [\u2190 rpow_one z]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 y ^ 1 = z ^ 1"}, {"line": "rw [\u2190 mul_inv_cancel\u2080 hx]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 y ^ (x * x\u207b\u00b9) = z ^ (x * x\u207b\u00b9)"}, {"line": "rw [rpow_mul hy]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 (y ^ x) ^ x\u207b\u00b9 = z ^ (x * x\u207b\u00b9)"}, {"line": "rw [rpow_mul hz]", "tactic_state": "x : \u211d\nhx : x \u2260 0\ny : \u211d\nhy : y \u2208 {y | 0 \u2264 y}\nz : \u211d\nhz : z \u2208 {y | 0 \u2264 y}\nhyz : y ^ x = z ^ x\n\u22a2 (y ^ x) ^ x\u207b\u00b9 = (z ^ x) ^ x\u207b\u00b9"}, {"line": "rw [hyz]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_rpow_iff_log_le (hx : 0 < x) (hy : 0 < y) : x \u2264 y ^ z \u2194 log x \u2264 z * log y := by\n  rw [\u2190 log_le_log_iff hx (rpow_pos_of_pos hy z)]\n  rw [log_rpow hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 x \u2264 y ^ z \u2194 log x \u2264 z * log y"}, {"line": "rw [\u2190 log_le_log_iff hx (rpow_pos_of_pos hy z)]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 log x \u2264 log (y ^ z) \u2194 log x \u2264 z * log y"}, {"line": "rw [log_rpow hy]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_rpow_of_log_le (hy : 0 < y) (h : log x \u2264 z * log y) : x \u2264 y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  \u00b7 exact hx.trans (rpow_pos_of_pos hy _).le\n  \u00b7 exact (le_rpow_iff_log_le hx hy).2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\n\u22a2 x \u2264 y ^ z"}, {"line": "obtain hx | hx := le_or_lt x 0", "tactic_state": "case inl\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : x \u2264 0\n\u22a2 x \u2264 y ^ z\n---\ncase inr\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : 0 < x\n\u22a2 x \u2264 y ^ z"}, {"line": "\u00b7 exact hx.trans (rpow_pos_of_pos hy _).le", "tactic_state": "case inr\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : 0 < x\n\u22a2 x \u2264 y ^ z"}, {"line": "\u00b7 exact (le_rpow_iff_log_le hx hy).2 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem lt_rpow_iff_log_lt (hx : 0 < x) (hy : 0 < y) : x < y ^ z \u2194 log x < z * log y := by\n  rw [\u2190 log_lt_log_iff hx (rpow_pos_of_pos hy z)]\n  rw [log_rpow hy]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 x < y ^ z \u2194 log x < z * log y"}, {"line": "rw [\u2190 log_lt_log_iff hx (rpow_pos_of_pos hy z)]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 log x < log (y ^ z) \u2194 log x < z * log y"}, {"line": "rw [log_rpow hy]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_rpow_of_log_lt (hy : 0 < y) (h : log x < z * log y) : x < y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  \u00b7 exact hx.trans_lt (rpow_pos_of_pos hy _)\n  \u00b7 exact (lt_rpow_iff_log_lt hx hy).2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhy : 0 < y\nh : log x < z * log y\n\u22a2 x < y ^ z"}, {"line": "obtain hx | hx := le_or_lt x 0", "tactic_state": "case inl\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : x \u2264 0\n\u22a2 x < y ^ z\n---\ncase inr\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : 0 < x\n\u22a2 x < y ^ z"}, {"line": "\u00b7 exact hx.trans_lt (rpow_pos_of_pos hy _)", "tactic_state": "case inr\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : 0 < x\n\u22a2 x < y ^ z"}, {"line": "\u00b7 exact (lt_rpow_iff_log_lt hx hy).2 h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_le_iff_le_log (hx : 0 < x) (hy : 0 < y) : x ^ n \u2264 y \u2194 n * log x \u2264 log y := by\n  rw [\u2190 rpow_le_iff_le_log hx hy]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n \u2264 y \u2194 \u2191n * log x \u2264 log y"}, {"line": "rw [\u2190 rpow_le_iff_le_log hx hy]", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n \u2264 y \u2194 x ^ \u2191n \u2264 y"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_le_iff_le_log {n : \u2124} (hx : 0 < x) (hy : 0 < y) : x ^ n \u2264 y \u2194 n * log x \u2264 log y := by\n  rw [\u2190 rpow_le_iff_le_log hx hy]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2124\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n \u2264 y \u2194 \u2191n * log x \u2264 log y"}, {"line": "rw [\u2190 rpow_le_iff_le_log hx hy]", "tactic_state": "x y : \u211d\nn : \u2124\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n \u2264 y \u2194 x ^ \u2191n \u2264 y"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_le_of_le_log (hy : 0 < y) (h : log x \u2264 z * log y) : x \u2264 y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  \u00b7 exact hx.trans (rpow_pos_of_pos hy _).le\n  \u00b7 exact (le_rpow_iff_log_le hx hy).2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\n\u22a2 x \u2264 y ^ z"}, {"line": "obtain hx | hx := le_or_lt x 0", "tactic_state": "case inl\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : x \u2264 0\n\u22a2 x \u2264 y ^ z\n---\ncase inr\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : 0 < x\n\u22a2 x \u2264 y ^ z"}, {"line": "\u00b7 exact hx.trans (rpow_pos_of_pos hy _).le", "tactic_state": "case inr\nx y z : \u211d\nhy : 0 < y\nh : log x \u2264 z * log y\nhx : 0 < x\n\u22a2 x \u2264 y ^ z"}, {"line": "\u00b7 exact (le_rpow_iff_log_le hx hy).2 h", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_lt_iff_lt_log (hx : 0 < x) (hy : 0 < y) : x ^ z < y \u2194 z * log x < log y := by\n  rw [\u2190 log_lt_log_iff (rpow_pos_of_pos hx _) hy]\n  rw [log_rpow hx]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ z < y \u2194 z * log x < log y"}, {"line": "rw [\u2190 log_lt_log_iff (rpow_pos_of_pos hx _) hy]", "tactic_state": "x y z : \u211d\nhx : 0 < x\nhy : 0 < y\n\u22a2 log (x ^ z) < log y \u2194 z * log x < log y"}, {"line": "rw [log_rpow hx]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma pow_lt_iff_lt_log (hx : 0 < x) (hy : 0 < y) : x ^ n < y \u2194 n * log x < log y := by\n  rw [\u2190 rpow_lt_iff_lt_log hx hy]\n  rw [rpow_natCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n < y \u2194 \u2191n * log x < log y"}, {"line": "rw [\u2190 rpow_lt_iff_lt_log hx hy]", "tactic_state": "x y : \u211d\nn : \u2115\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n < y \u2194 x ^ \u2191n < y"}, {"line": "rw [rpow_natCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma zpow_lt_iff_lt_log {n : \u2124} (hx : 0 < x) (hy : 0 < y) : x ^ n < y \u2194 n * log x < log y := by\n  rw [\u2190 rpow_lt_iff_lt_log hx hy]\n  rw [rpow_intCast]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nn : \u2124\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n < y \u2194 \u2191n * log x < log y"}, {"line": "rw [\u2190 rpow_lt_iff_lt_log hx hy]", "tactic_state": "x y : \u211d\nn : \u2124\nhx : 0 < x\nhy : 0 < y\n\u22a2 x ^ n < y \u2194 x ^ \u2191n < y"}, {"line": "rw [rpow_intCast]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_lt_of_lt_log (hy : 0 < y) (h : log x < z * log y) : x < y ^ z := by\n  obtain hx | hx := le_or_lt x 0\n  \u00b7 exact hx.trans_lt (rpow_pos_of_pos hy _)\n  \u00b7 exact (lt_rpow_iff_log_lt hx hy).2 h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhy : 0 < y\nh : log x < z * log y\n\u22a2 x < y ^ z"}, {"line": "obtain hx | hx := le_or_lt x 0", "tactic_state": "case inl\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : x \u2264 0\n\u22a2 x < y ^ z\n---\ncase inr\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : 0 < x\n\u22a2 x < y ^ z"}, {"line": "\u00b7 exact hx.trans_lt (rpow_pos_of_pos hy _)", "tactic_state": "case inr\nx y z : \u211d\nhy : 0 < y\nh : log x < z * log y\nhx : 0 < x\n\u22a2 x < y ^ z"}, {"line": "\u00b7 exact (lt_rpow_iff_log_lt hx hy).2 h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_le_one_iff_of_pos (hx : 0 < x) : x ^ y \u2264 1 \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y := by\n  rw [rpow_def_of_pos hx]\n  rw [exp_le_one_iff]\n  rw [mul_nonpos_iff]\n  rw [log_nonneg_iff hx]\n  rw [log_nonpos_iff hx.le]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 x ^ y \u2264 1 \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y"}, {"line": "rw [rpow_def_of_pos hx]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 exp (log x * y) \u2264 1 \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y"}, {"line": "rw [exp_le_one_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 log x * y \u2264 0 \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y"}, {"line": "rw [mul_nonpos_iff]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 0 \u2264 log x \u2227 y \u2264 0 \u2228 log x \u2264 0 \u2227 0 \u2264 y \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y"}, {"line": "rw [log_nonneg_iff hx]", "tactic_state": "x y : \u211d\nhx : 0 < x\n\u22a2 1 \u2264 x \u2227 y \u2264 0 \u2228 log x \u2264 0 \u2227 0 \u2264 y \u2194 1 \u2264 x \u2227 y \u2264 0 \u2228 x \u2264 1 \u2227 0 \u2264 y"}, {"line": "rw [log_nonpos_iff hx.le]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_log_mul_self_rpow_lt (x t : \u211d) (h1 : 0 < x) (h2 : x \u2264 1) (ht : 0 < t) :\n    |log x * x ^ t| < 1 / t := by\n  rw [lt_div_iff\u2080 ht]\n  have := abs_log_mul_self_lt (x ^ t) (rpow_pos_of_pos h1 t) (rpow_le_one h1.le h2 ht.le)\n  rwa [log_rpow h1, mul_assoc, abs_mul, abs_of_pos ht, mul_comm] at this\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x t : \u211d\nh1 : 0 < x\nh2 : x \u2264 1\nht : 0 < t\n\u22a2 |log x * x ^ t| < 1 / t"}, {"line": "rw [lt_div_iff\u2080 ht]", "tactic_state": "x t : \u211d\nh1 : 0 < x\nh2 : x \u2264 1\nht : 0 < t\n\u22a2 |log x * x ^ t| * t < 1"}, {"line": "have := abs_log_mul_self_lt (x ^ t) (rpow_pos_of_pos h1 t) (rpow_le_one h1.le h2 ht.le)", "tactic_state": "x t : \u211d\nh1 : 0 < x\nh2 : x \u2264 1\nht : 0 < t\nthis : |log (x ^ t) * x ^ t| < 1\n\u22a2 |log x * x ^ t| * t < 1"}, {"line": "rwa [log_rpow h1, mul_assoc, abs_mul, abs_of_pos ht, mul_comm] at this", "tactic_state": "No Goals!"}]}
{"declaration": "lemma log_le_rpow_div {x \u03b5 : \u211d} (hx : 0 \u2264 x) (h\u03b5 : 0 < \u03b5) : log x \u2264 x ^ \u03b5 / \u03b5 := by\n  rcases hx.eq_or_lt with rfl | h\n  \u00b7 rw [log_zero, zero_rpow h\u03b5.ne', zero_div]\n  rw [le_div_iff\u2080' h\u03b5]\n  exact (log_rpow h \u03b5).symm.trans_le <| (log_le_sub_one_of_pos <| rpow_pos_of_pos h \u03b5).trans\n    (sub_one_lt _).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03b5 : \u211d\nhx : 0 \u2264 x\nh\u03b5 : 0 < \u03b5\n\u22a2 log x \u2264 x ^ \u03b5 / \u03b5"}, {"line": "rcases hx.eq_or_lt with rfl | h", "tactic_state": "case inl\n\u03b5 : \u211d\nh\u03b5 : 0 < \u03b5\nhx : 0 \u2264 0\n\u22a2 log 0 \u2264 0 ^ \u03b5 / \u03b5\n---\ncase inr\nx \u03b5 : \u211d\nhx : 0 \u2264 x\nh\u03b5 : 0 < \u03b5\nh : 0 < x\n\u22a2 log x \u2264 x ^ \u03b5 / \u03b5"}, {"line": "\u00b7 rw [log_zero, zero_rpow h\u03b5.ne', zero_div]", "tactic_state": "case inr\nx \u03b5 : \u211d\nhx : 0 \u2264 x\nh\u03b5 : 0 < \u03b5\nh : 0 < x\n\u22a2 log x \u2264 x ^ \u03b5 / \u03b5"}, {"line": "rw [le_div_iff\u2080' h\u03b5]", "tactic_state": "case inr\nx \u03b5 : \u211d\nhx : 0 \u2264 x\nh\u03b5 : 0 < \u03b5\nh : 0 < x\n\u22a2 \u03b5 * log x \u2264 x ^ \u03b5"}, {"line": "exact (log_rpow h \u03b5).symm.trans_le <| (log_le_sub_one_of_pos <| rpow_pos_of_pos h \u03b5).trans\n    (sub_one_lt _).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictMono_rpow_of_base_gt_one {b : \u211d} (hb : 1 < b) :\n    StrictMono (b ^ \u00b7 : \u211d \u2192 \u211d) := by\n  simp_rw [Real.rpow_def_of_pos (zero_lt_one.trans hb)]\n  exact exp_strictMono.comp <| StrictMono.const_mul strictMono_id <| Real.log_pos hb\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 StrictMono fun x => b ^ x"}, {"line": "simp_rw [Real.rpow_def_of_pos (zero_lt_one.trans hb)]", "tactic_state": "b : \u211d\nhb : 1 < b\n\u22a2 StrictMono fun x => exp (log b * x)"}, {"line": "exact exp_strictMono.comp <| StrictMono.const_mul strictMono_id <| Real.log_pos hb", "tactic_state": "No Goals!"}]}
{"declaration": "lemma monotone_rpow_of_base_ge_one {b : \u211d} (hb : 1 \u2264 b) :\n    Monotone (b ^ \u00b7 : \u211d \u2192 \u211d) := by\n  rcases lt_or_eq_of_le hb with hb | rfl\n  case inl => exact (strictMono_rpow_of_base_gt_one hb).monotone\n  case inr => intro _ _ _; simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb : 1 \u2264 b\n\u22a2 Monotone fun x => b ^ x"}, {"line": "rcases lt_or_eq_of_le hb with hb | rfl", "tactic_state": "case inl\nb : \u211d\nhb\u271d : 1 \u2264 b\nhb : 1 < b\n\u22a2 Monotone fun x => b ^ x\n---\ncase inr\nhb : 1 \u2264 1\n\u22a2 Monotone fun x => 1 ^ x"}, {"line": "case inl => exact (strictMono_rpow_of_base_gt_one hb).monotone", "tactic_state": "case inr\nhb : 1 \u2264 1\n\u22a2 Monotone fun x => 1 ^ x"}, {"line": "case inr => intro _ _ _; simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma strictAnti_rpow_of_base_lt_one {b : \u211d} (hb\u2080 : 0 < b) (hb\u2081 : b < 1) :\n    StrictAnti (b ^ \u00b7 : \u211d \u2192 \u211d) := by\n  simp_rw [Real.rpow_def_of_pos hb\u2080]\n  exact exp_strictMono.comp_strictAnti <| StrictMono.const_mul_of_neg strictMono_id\n      <| Real.log_neg hb\u2080 hb\u2081\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b < 1\n\u22a2 StrictAnti fun x => b ^ x"}, {"line": "simp_rw [Real.rpow_def_of_pos hb\u2080]", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b < 1\n\u22a2 StrictAnti fun x => exp (log b * x)"}, {"line": "exact exp_strictMono.comp_strictAnti <| StrictMono.const_mul_of_neg strictMono_id\n      <| Real.log_neg hb\u2080 hb\u2081", "tactic_state": "No Goals!"}]}
{"declaration": "lemma antitone_rpow_of_base_le_one {b : \u211d} (hb\u2080 : 0 < b) (hb\u2081 : b \u2264 1) :\n    Antitone (b ^ \u00b7 : \u211d \u2192 \u211d) := by\n  rcases lt_or_eq_of_le hb\u2081 with hb\u2081 | rfl\n  case inl => exact (strictAnti_rpow_of_base_lt_one hb\u2080 hb\u2081).antitone\n  case inr => intro _ _ _; simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "b : \u211d\nhb\u2080 : 0 < b\nhb\u2081 : b \u2264 1\n\u22a2 Antitone fun x => b ^ x"}, {"line": "rcases lt_or_eq_of_le hb\u2081 with hb\u2081 | rfl", "tactic_state": "case inl\nb : \u211d\nhb\u2080 : 0 < b\nhb\u2081\u271d : b \u2264 1\nhb\u2081 : b < 1\n\u22a2 Antitone fun x => b ^ x\n---\ncase inr\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone fun x => 1 ^ x"}, {"line": "case inl => exact (strictAnti_rpow_of_base_lt_one hb\u2080 hb\u2081).antitone", "tactic_state": "case inr\nhb\u2080 : 0 < 1\nhb\u2081 : 1 \u2264 1\n\u22a2 Antitone fun x => 1 ^ x"}, {"line": "case inr => intro _ _ _; simp", "tactic_state": "No Goals!"}]}
{"declaration": "lemma rpow_right_inj (hx\u2080 : 0 < x) (hx\u2081 : x \u2260 1) : x ^ y = x ^ z \u2194 y = z := by\n  refine \u27e8fun H \u21a6 ?_, fun H \u21a6 by rw [H]\u27e9\n  rcases hx\u2081.lt_or_lt with h | h\n  \u00b7 exact (strictAnti_rpow_of_base_lt_one hx\u2080 h).injective H\n  \u00b7 exact (strictMono_rpow_of_base_gt_one h).injective H\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y z : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\n\u22a2 x ^ y = x ^ z \u2194 y = z"}, {"line": "refine \u27e8fun H \u21a6 ?_, fun H \u21a6 by rw [H]\u27e9", "tactic_state": "x y z : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\nH : x ^ y = x ^ z\n\u22a2 y = z"}, {"line": "rcases hx\u2081.lt_or_lt with h | h", "tactic_state": "case inl\nx y z : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\nH : x ^ y = x ^ z\nh : x < 1\n\u22a2 y = z\n---\ncase inr\nx y z : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\nH : x ^ y = x ^ z\nh : 1 < x\n\u22a2 y = z"}, {"line": "\u00b7 exact (strictAnti_rpow_of_base_lt_one hx\u2080 h).injective H", "tactic_state": "case inr\nx y z : \u211d\nhx\u2080 : 0 < x\nhx\u2081 : x \u2260 1\nH : x ^ y = x ^ z\nh : 1 < x\n\u22a2 y = z"}, {"line": "\u00b7 exact (strictMono_rpow_of_base_gt_one h).injective H", "tactic_state": "No Goals!"}]}
{"declaration": "theorem rpow_div_two_eq_sqrt {x : \u211d} (r : \u211d) (hx : 0 \u2264 x) : x ^ (r / 2) = \u221ax ^ r := by\n  rw [sqrt_eq_rpow]\n  rw [\u2190 rpow_mul hx]\n  congr\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Pow/Real.lean", "context": {"open": ["Real ComplexConjugate Finset Set", "Real", "Filter in", "Lean Meta Qq"], "variables": ["{x y z : \u211d}", "{w x y z : \u211d}", "{x y z : \u211d} {n : \u2115}", "{z x y : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x r : \u211d\nhx : 0 \u2264 x\n\u22a2 x ^ (r / 2) = \u221ax ^ r"}, {"line": "rw [sqrt_eq_rpow]", "tactic_state": "x r : \u211d\nhx : 0 \u2264 x\n\u22a2 x ^ (r / 2) = (x ^ (1 / 2)) ^ r"}, {"line": "rw [\u2190 rpow_mul hx]", "tactic_state": "x r : \u211d\nhx : 0 \u2264 x\n\u22a2 x ^ (r / 2) = x ^ (1 / 2 * r)"}, {"line": "congr", "tactic_state": "case e_a\nx r : \u211d\nhx : 0 \u2264 x\n\u22a2 r / 2 = 1 / 2 * r"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem hasStrictDerivAt_arctan (x : \u211d) : HasStrictDerivAt arctan (1 / (1 + x ^ 2)) x := by\n  have A : cos (arctan x) \u2260 0 := (cos_arctan_pos x).ne'\n  simpa [cos_sq_arctan] using\n    tanPartialHomeomorph.hasStrictDerivAt_symm trivial (by simpa) (hasStrictDerivAt_tan A)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/ArctanDeriv.lean", "context": {"open": ["Set Filter", "scoped Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "arctan : \u211d \u2192 \u211d\nx : \u211d\n\u22a2 HasStrictDerivAt arctan (1 / (1 + x ^ 2)) x"}, {"line": "have A : cos (arctan x) \u2260 0 := (cos_arctan_pos x).ne'", "tactic_state": "arctan : \u211d \u2192 \u211d\nx : \u211d\nA : sorry \u2260 0\n\u22a2 HasStrictDerivAt arctan (1 / (1 + x ^ 2)) x"}, {"line": "simpa [cos_sq_arctan] using\n    tanPartialHomeomorph.hasStrictDerivAt_symm trivial (by simpa) (hasStrictDerivAt_tan A)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem C_two_mul_complex_cos (n : \u2124) : (C \u2102 n).eval (2 * cos \u03b8) = 2 * cos (n * \u03b8) := by\n  simp [C_eq_two_mul_T_comp_half_mul_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "context": {"open": ["Polynomial", "Complex"], "variables": ["{R A : Type*} [CommRing R] [CommRing A] [Algebra R A]", "(\u03b8 : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u2102\nn : \u2124\n\u22a2 sorry = 2 * cos (\u2191n * \u03b8)"}, {"line": "simp [C_eq_two_mul_T_comp_half_mul_X]", "tactic_state": "\u03b8 : \u2102\nn : \u2124\n\u22a2 sorry () = 2 * cos (\u2191n * \u03b8)"}]}
{"declaration": "theorem S_two_mul_complex_cos (n : \u2124) : (S \u2102 n).eval (2 * cos \u03b8) * sin \u03b8 = sin ((n + 1) * \u03b8) := by\n  simp [S_eq_U_comp_half_mul_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "context": {"open": ["Polynomial", "Complex"], "variables": ["{R A : Type*} [CommRing R] [CommRing A] [Algebra R A]", "(\u03b8 : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u2102\nx\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry * sin \u03b8 = sin ((\u2191n + 1) * \u03b8)"}, {"line": "simp [S_eq_U_comp_half_mul_X]", "tactic_state": "\u03b8 : \u2102\nx\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry () * sin \u03b8 = sin ((\u2191n + 1) * \u03b8)"}]}
{"declaration": "theorem C_two_mul_complex_cosh (n : \u2124) : (C \u2102 n).eval (2 * cosh \u03b8) = 2 * cosh (n * \u03b8) := by\n  simp [C_eq_two_mul_T_comp_half_mul_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "context": {"open": ["Polynomial", "Complex"], "variables": ["{R A : Type*} [CommRing R] [CommRing A] [Algebra R A]", "(\u03b8 : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u2102\nn : \u2124\n\u22a2 sorry = 2 * cosh (\u2191n * \u03b8)"}, {"line": "simp [C_eq_two_mul_T_comp_half_mul_X]", "tactic_state": "\u03b8 : \u2102\nn : \u2124\n\u22a2 sorry () = 2 * cosh (\u2191n * \u03b8)"}]}
{"declaration": "theorem S_two_mul_complex_cosh (n : \u2124) : (S \u2102 n).eval (2 * cosh \u03b8) * sinh \u03b8 =\n    sinh ((n + 1) * \u03b8) := by\n  simp [S_eq_U_comp_half_mul_X]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Chebyshev.lean", "context": {"open": ["Polynomial", "Complex"], "variables": ["{R A : Type*} [CommRing R] [CommRing A] [Algebra R A]", "(\u03b8 : \u2102)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u2102\nx\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry * sinh \u03b8 = sinh ((\u2191n + 1) * \u03b8)"}, {"line": "simp [S_eq_U_comp_half_mul_X]", "tactic_state": "\u03b8 : \u2102\nx\u271d : Sort u_3\nS : x\u271d\nn : \u2124\n\u22a2 sorry () * sinh \u03b8 = sinh ((\u2191n + 1) * \u03b8)"}]}
{"declaration": "theorem cos_eq_iff_quadratic {z w : \u2102} :\n    cos z = w \u2194 exp (z * I) ^ 2 - 2 * w * exp (z * I) + 1 = 0 := by\n  rw [\u2190 sub_eq_zero]\n  field_simp [cos, exp_neg, exp_ne_zero]\n  refine Eq.congr ?_ rfl\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean", "context": {"open": ["Set Filter", "scoped Real", "scoped Topology"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nz w : \u2102\n\u22a2 sorry = w \u2194 sorry ^ 2 - 2 * w * sorry + 1 = 0"}, {"line": "rw [\u2190 sub_eq_zero]", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nz w : \u2102\n\u22a2 sorry - w = 0 \u2194 sorry ^ 2 - 2 * w * sorry + 1 = 0"}, {"line": "field_simp [cos, exp_neg, exp_ne_zero]", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nz w : \u2102\n\u22a2 sorry () - w = 0 \u2194 sorry () ^ 2 - 2 * w * sorry () + 1 = 0"}, {"line": "refine Eq.congr ?_ rfl", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nz w : \u2102\n\u22a2 sorry () - w = sorry () ^ 2 - 2 * w * sorry () + 1"}, {"line": "ring", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\nexp : x\u271d\nz w : \u2102\n\u22a2 sorry () - w = 1 - sorry () * w * 2 + sorry () ^ 2"}]}
{"declaration": "theorem tan_eq_zero_iff' {\u03b8 : \u211d} (h\u03b8 : cos \u03b8 \u2260 0) : tan \u03b8 = 0 \u2194 \u2203 k : \u2124, k * \u03c0 = \u03b8 := by\n  revert h\u03b8\n  exact_mod_cast @Complex.tan_eq_zero_iff' \u03b8\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Complex.lean", "context": {"open": ["Set Filter", "scoped Real", "scoped Topology", "scoped Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\ntan : x\u271d\n\u03b8 : \u211d\nh\u03b8 : sorry \u2260 0\n\u22a2 sorry = 0 \u2194 \u2203 k, \u2191k * Real.pi = \u03b8"}, {"line": "revert h\u03b8", "tactic_state": "x\u271d\u00b9 : Sort u_1\ncos : x\u271d\u00b9\nx\u271d : Sort u_2\ntan : x\u271d\n\u03b8 : \u211d\n\u22a2 sorry \u2260 0 \u2192 (sorry = 0 \u2194 \u2203 k, \u2191k * Real.pi = \u03b8)"}, {"line": "exact_mod_cast @Complex.tan_eq_zero_iff' \u03b8", "tactic_state": "No Goals!"}]}
{"declaration": "lemma Complex.cot_eq_exp_ratio (z : \u2102) :\n    cot z = (Complex.exp (2 * I * z) + 1) / (I * (1 - Complex.exp (2 * I * z))) := by\n  rw [Complex.cot]\n  rw [Complex.sin]\n  rw [Complex.cos]\n  field_simp\n  have h1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1) := by\n    rw [mul_add]\n    rw [\u2190 Complex.exp_add]\n    simp only [mul_one]\n    simp only [add_left_inj]\n    ring_nf\n  have h2 : (exp (-(z * I)) - exp (z * I)) * I = exp (-(z * I)) * (I * (1 - exp (2 * I * z))) := by\n    ring_nf\n    rw [mul_assoc]\n    rw [\u2190 Complex.exp_add]\n    ring_nf\n  rw [h1]\n  rw [h2]\n  rw [mul_div_mul_left _ _ (Complex.exp_ne_zero _)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Cotangent.lean", "context": {"open": ["Real Complex", "scoped UpperHalfPlane"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 z.cot = (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [Complex.cot]", "tactic_state": "z : \u2102\n\u22a2 cos z / sin z = (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [Complex.sin]", "tactic_state": "z : \u2102\n\u22a2 cos z / ((exp (-z * I) - exp (z * I)) * I / 2) = (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [Complex.cos]", "tactic_state": "z : \u2102\n\u22a2 (exp (z * I) + exp (-z * I)) / 2 / ((exp (-z * I) - exp (z * I)) * I / 2) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "field_simp", "tactic_state": "z : \u2102\n\u22a2 (exp (z * I) + exp (-(z * I))) / ((exp (-(z * I)) - exp (z * I)) * I) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "have h1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1) := by\n    rw [mul_add]\n    rw [\u2190 Complex.exp_add]\n    simp only [mul_one]\n    simp only [add_left_inj]\n    ring_nf", "tactic_state": "z : \u2102\nh1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1)\n\u22a2 (exp (z * I) + exp (-(z * I))) / ((exp (-(z * I)) - exp (z * I)) * I) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "have h2 : (exp (-(z * I)) - exp (z * I)) * I = exp (-(z * I)) * (I * (1 - exp (2 * I * z))) := by\n    ring_nf\n    rw [mul_assoc]\n    rw [\u2190 Complex.exp_add]\n    ring_nf", "tactic_state": "z : \u2102\nh1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1)\nh2 : (exp (-(z * I)) - exp (z * I)) * I = exp (-(z * I)) * (I * (1 - exp (2 * I * z)))\n\u22a2 (exp (z * I) + exp (-(z * I))) / ((exp (-(z * I)) - exp (z * I)) * I) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [h1]", "tactic_state": "z : \u2102\nh1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1)\nh2 : (exp (-(z * I)) - exp (z * I)) * I = exp (-(z * I)) * (I * (1 - exp (2 * I * z)))\n\u22a2 exp (-(z * I)) * (exp (2 * I * z) + 1) / ((exp (-(z * I)) - exp (z * I)) * I) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [h2]", "tactic_state": "z : \u2102\nh1 : exp (z * I) + exp (-(z * I)) = exp (-(z * I)) * (exp (2 * I * z) + 1)\nh2 : (exp (-(z * I)) - exp (z * I)) * I = exp (-(z * I)) * (I * (1 - exp (2 * I * z)))\n\u22a2 exp (-(z * I)) * (exp (2 * I * z) + 1) / (exp (-(z * I)) * (I * (1 - exp (2 * I * z)))) =\n    (exp (2 * I * z) + 1) / (I * (1 - exp (2 * I * z)))"}, {"line": "rw [mul_div_mul_left _ _ (Complex.exp_ne_zero _)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.hasSum_cos' (z : \u2102) :\n    HasSum (fun n : \u2115 => (z * Complex.I) ^ (2 * n) / \u2191(2 * n)!) (Complex.cos z) := by\n  rw [Complex.cos]\n  rw [Complex.exp_eq_exp_\u2102]\n  have := ((expSeries_div_hasSum_exp \u2102 (z * Complex.I)).add\n    (expSeries_div_hasSum_exp \u2102 (-z * Complex.I))).div_const 2\n  replace := (Nat.divModEquiv 2).symm.hasSum_iff.mpr this\n  dsimp [Function.comp_def] at this\n  simp_rw [\u2190 mul_comm 2 _] at this\n  refine this.prod_fiberwise fun k => ?_\n  dsimp only\n  convert hasSum_fintype (_ : Fin 2 \u2192 \u2102) using 1\n  rw [Fin.sum_univ_two]\n  simp_rw [Fin.val_zero, Fin.val_one, add_zero, pow_succ, pow_mul, mul_pow, neg_sq, \u2190 two_mul,\n    neg_mul, mul_neg, neg_div, add_neg_cancel, zero_div, add_zero,\n    mul_div_cancel_left\u2080 _ (two_ne_zero : (2 : \u2102) \u2260 0)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial) (cos z)"}, {"line": "rw [Complex.cos]", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial) ((exp (z * I) + exp (-z * I)) / 2)"}, {"line": "rw [Complex.exp_eq_exp_\u2102]", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)"}, {"line": "have := ((expSeries_div_hasSum_exp \u2102 (z * Complex.I)).add\n    (expSeries_div_hasSum_exp \u2102 (-z * Complex.I))).div_const 2", "tactic_state": "z : \u2102\nthis :\n  HasSum (fun i => ((z * I) ^ i / \u2191i.factorial + (-z * I) ^ i / \u2191i.factorial) / 2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)"}, {"line": "replace := (Nat.divModEquiv 2).symm.hasSum_iff.mpr this", "tactic_state": "z : \u2102\nthis :\n  HasSum ((fun i => ((z * I) ^ i / \u2191i.factorial + (-z * I) ^ i / \u2191i.factorial) / 2) \u2218 \u21d1(Nat.divModEquiv 2).symm)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)"}, {"line": "dsimp [Function.comp_def] at this", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (x.1 * 2 + \u2191x.2) / \u2191(x.1 * 2 + \u2191x.2).factorial +\n          (-z * I) ^ (x.1 * 2 + \u2191x.2) / \u2191(x.1 * 2 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)"}, {"line": "simp_rw [\u2190 mul_comm 2 _] at this", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial +\n          (-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)"}, {"line": "refine this.prod_fiberwise fun k => ?_", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial +\n          (-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\nk : \u2115\n\u22a2 HasSum\n    (fun c =>\n      ((z * I) ^ (2 * (k, c).1 + \u2191(k, c).2) / \u2191(2 * (k, c).1 + \u2191(k, c).2).factorial +\n          (-z * I) ^ (2 * (k, c).1 + \u2191(k, c).2) / \u2191(2 * (k, c).1 + \u2191(k, c).2).factorial) /\n        2)\n    ((z * I) ^ (2 * k) / \u2191(2 * k).factorial)"}, {"line": "dsimp only", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial +\n          (-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\nk : \u2115\n\u22a2 HasSum\n    (fun c =>\n      ((z * I) ^ (2 * k + \u2191c) / \u2191(2 * k + \u2191c).factorial + (-z * I) ^ (2 * k + \u2191c) / \u2191(2 * k + \u2191c).factorial) / 2)\n    ((z * I) ^ (2 * k) / \u2191(2 * k).factorial)"}, {"line": "convert hasSum_fintype (_ : Fin 2 \u2192 \u2102) using 1", "tactic_state": "case h.e'_6\nz : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial +\n          (-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\nk : \u2115\n\u22a2 (z * I) ^ (2 * k) / \u2191(2 * k).factorial =\n    \u2211 b, ((z * I) ^ (2 * k + \u2191b) / \u2191(2 * k + \u2191b).factorial + (-z * I) ^ (2 * k + \u2191b) / \u2191(2 * k + \u2191b).factorial) / 2"}, {"line": "rw [Fin.sum_univ_two]", "tactic_state": "case h.e'_6\nz : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial +\n          (-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) /\n        2)\n    ((NormedSpace.exp \u2102 (z * I) + NormedSpace.exp \u2102 (-z * I)) / 2)\nk : \u2115\n\u22a2 (z * I) ^ (2 * k) / \u2191(2 * k).factorial =\n    ((z * I) ^ (2 * k + \u21910) / \u2191(2 * k + \u21910).factorial + (-z * I) ^ (2 * k + \u21910) / \u2191(2 * k + \u21910).factorial) / 2 +\n      ((z * I) ^ (2 * k + \u21911) / \u2191(2 * k + \u21911).factorial + (-z * I) ^ (2 * k + \u21911) / \u2191(2 * k + \u21911).factorial) / 2"}, {"line": "simp_rw [Fin.val_zero, Fin.val_one, add_zero, pow_succ, pow_mul, mul_pow, neg_sq, \u2190 two_mul,\n    neg_mul, mul_neg, neg_div, add_neg_cancel, zero_div, add_zero,\n    mul_div_cancel_left\u2080 _ (two_ne_zero : (2 : \u2102) \u2260 0)]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.hasSum_sin' (z : \u2102) :\n    HasSum (fun n : \u2115 => (z * Complex.I) ^ (2 * n + 1) / \u2191(2 * n + 1)! / Complex.I)\n      (Complex.sin z) := by\n  rw [Complex.sin]\n  rw [Complex.exp_eq_exp_\u2102]\n  have := (((expSeries_div_hasSum_exp \u2102 (-z * Complex.I)).sub\n    (expSeries_div_hasSum_exp \u2102 (z * Complex.I))).mul_right Complex.I).div_const 2\n  replace := (Nat.divModEquiv 2).symm.hasSum_iff.mpr this\n  dsimp [Function.comp_def] at this\n  simp_rw [\u2190 mul_comm 2 _] at this\n  refine this.prod_fiberwise fun k => ?_\n  dsimp only\n  convert hasSum_fintype (_ : Fin 2 \u2192 \u2102) using 1\n  rw [Fin.sum_univ_two]\n  simp_rw [Fin.val_zero, Fin.val_one, add_zero, pow_succ, pow_mul, mul_pow, neg_sq, sub_self,\n    zero_mul, zero_div, zero_add, neg_mul, mul_neg, neg_div, \u2190 neg_add', \u2190 two_mul,\n    neg_mul, neg_div, mul_assoc, mul_div_cancel_left\u2080 _ (two_ne_zero : (2 : \u2102) \u2260 0), Complex.div_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I) (sin z)"}, {"line": "rw [Complex.sin]", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I) ((exp (-z * I) - exp (z * I)) * I / 2)"}, {"line": "rw [Complex.exp_eq_exp_\u2102]", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)"}, {"line": "have := (((expSeries_div_hasSum_exp \u2102 (-z * Complex.I)).sub\n    (expSeries_div_hasSum_exp \u2102 (z * Complex.I))).mul_right Complex.I).div_const 2", "tactic_state": "z : \u2102\nthis :\n  HasSum (fun i => ((-z * I) ^ i / \u2191i.factorial - (z * I) ^ i / \u2191i.factorial) * I / 2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)"}, {"line": "replace := (Nat.divModEquiv 2).symm.hasSum_iff.mpr this", "tactic_state": "z : \u2102\nthis :\n  HasSum ((fun i => ((-z * I) ^ i / \u2191i.factorial - (z * I) ^ i / \u2191i.factorial) * I / 2) \u2218 \u21d1(Nat.divModEquiv 2).symm)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)"}, {"line": "dsimp [Function.comp_def] at this", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (x.1 * 2 + \u2191x.2) / \u2191(x.1 * 2 + \u2191x.2).factorial -\n            (z * I) ^ (x.1 * 2 + \u2191x.2) / \u2191(x.1 * 2 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)"}, {"line": "simp_rw [\u2190 mul_comm 2 _] at this", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial -\n            (z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\n\u22a2 HasSum (fun n => (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)"}, {"line": "refine this.prod_fiberwise fun k => ?_", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial -\n            (z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\nk : \u2115\n\u22a2 HasSum\n    (fun c =>\n      ((-z * I) ^ (2 * (k, c).1 + \u2191(k, c).2) / \u2191(2 * (k, c).1 + \u2191(k, c).2).factorial -\n            (z * I) ^ (2 * (k, c).1 + \u2191(k, c).2) / \u2191(2 * (k, c).1 + \u2191(k, c).2).factorial) *\n          I /\n        2)\n    ((z * I) ^ (2 * k + 1) / \u2191(2 * k + 1).factorial / I)"}, {"line": "dsimp only", "tactic_state": "z : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial -\n            (z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\nk : \u2115\n\u22a2 HasSum\n    (fun c =>\n      ((-z * I) ^ (2 * k + \u2191c) / \u2191(2 * k + \u2191c).factorial - (z * I) ^ (2 * k + \u2191c) / \u2191(2 * k + \u2191c).factorial) * I / 2)\n    ((z * I) ^ (2 * k + 1) / \u2191(2 * k + 1).factorial / I)"}, {"line": "convert hasSum_fintype (_ : Fin 2 \u2192 \u2102) using 1", "tactic_state": "case h.e'_6\nz : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial -\n            (z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\nk : \u2115\n\u22a2 (z * I) ^ (2 * k + 1) / \u2191(2 * k + 1).factorial / I =\n    \u2211 b, ((-z * I) ^ (2 * k + \u2191b) / \u2191(2 * k + \u2191b).factorial - (z * I) ^ (2 * k + \u2191b) / \u2191(2 * k + \u2191b).factorial) * I / 2"}, {"line": "rw [Fin.sum_univ_two]", "tactic_state": "case h.e'_6\nz : \u2102\nthis :\n  HasSum\n    (fun x =>\n      ((-z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial -\n            (z * I) ^ (2 * x.1 + \u2191x.2) / \u2191(2 * x.1 + \u2191x.2).factorial) *\n          I /\n        2)\n    ((NormedSpace.exp \u2102 (-z * I) - NormedSpace.exp \u2102 (z * I)) * I / 2)\nk : \u2115\n\u22a2 (z * I) ^ (2 * k + 1) / \u2191(2 * k + 1).factorial / I =\n    ((-z * I) ^ (2 * k + \u21910) / \u2191(2 * k + \u21910).factorial - (z * I) ^ (2 * k + \u21910) / \u2191(2 * k + \u21910).factorial) * I / 2 +\n      ((-z * I) ^ (2 * k + \u21911) / \u2191(2 * k + \u21911).factorial - (z * I) ^ (2 * k + \u21911) / \u2191(2 * k + \u21911).factorial) * I / 2"}, {"line": "simp_rw [Fin.val_zero, Fin.val_one, add_zero, pow_succ, pow_mul, mul_pow, neg_sq, sub_self,\n    zero_mul, zero_div, zero_add, neg_mul, mul_neg, neg_div, \u2190 neg_add', \u2190 two_mul,\n    neg_mul, neg_div, mul_assoc, mul_div_cancel_left\u2080 _ (two_ne_zero : (2 : \u2102) \u2260 0), Complex.div_I]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.hasSum_cos (z : \u2102) :\n    HasSum (fun n : \u2115 => (-1) ^ n * z ^ (2 * n) / \u2191(2 * n)!) (Complex.cos z) := by\n  convert Complex.hasSum_cos' z using 1\n  simp_rw [mul_pow, pow_mul, Complex.I_sq, mul_comm]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (-1) ^ n * z ^ (2 * n) / \u2191(2 * n).factorial) (cos z)"}, {"line": "convert Complex.hasSum_cos' z using 1", "tactic_state": "case h.e'_5\nz : \u2102\n\u22a2 (fun n => (-1) ^ n * z ^ (2 * n) / \u2191(2 * n).factorial) = fun n => (z * I) ^ (2 * n) / \u2191(2 * n).factorial"}, {"line": "simp_rw [mul_pow, pow_mul, Complex.I_sq, mul_comm]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem Complex.hasSum_sin (z : \u2102) :\n    HasSum (fun n : \u2115 => (-1) ^ n * z ^ (2 * n + 1) / \u2191(2 * n + 1)!) (Complex.sin z) := by\n  convert Complex.hasSum_sin' z using 1\n  simp_rw [mul_pow, pow_succ, pow_mul, Complex.I_sq, \u2190 mul_assoc, mul_div_assoc, div_right_comm,\n    div_self Complex.I_ne_zero, mul_comm _ ((-1 : \u2102) ^ _), mul_one_div, mul_div_assoc, mul_assoc]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 HasSum (fun n => (-1) ^ n * z ^ (2 * n + 1) / \u2191(2 * n + 1).factorial) (sin z)"}, {"line": "convert Complex.hasSum_sin' z using 1", "tactic_state": "case h.e'_5\nz : \u2102\n\u22a2 (fun n => (-1) ^ n * z ^ (2 * n + 1) / \u2191(2 * n + 1).factorial) = fun n =>\n    (z * I) ^ (2 * n + 1) / \u2191(2 * n + 1).factorial / I"}, {"line": "simp_rw [mul_pow, pow_succ, pow_mul, Complex.I_sq, \u2190 mul_assoc, mul_div_assoc, div_right_comm,\n    div_self Complex.I_ne_zero, mul_comm _ ((-1 : \u2102) ^ _), mul_one_div, mul_div_assoc, mul_assoc]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasSum_cosh (z : \u2102) : HasSum (fun n \u21a6 z ^ (2 * n) / \u2191(2 * n)!) (cosh z) := by\n  simpa [mul_assoc, cos_mul_I] using hasSum_cos' (z * I)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ncosh : x\u271d\nz : \u2102\n\u22a2 HasSum (fun n => z ^ (2 * n) / \u2191(2 * n).factorial) sorry"}, {"line": "simpa [mul_assoc, cos_mul_I] using hasSum_cos' (z * I)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma hasSum_sinh (z : \u2102) : HasSum (fun n \u21a6 z ^ (2 * n + 1) / \u2191(2 * n + 1)!) (sinh z) := by\n  simpa [mul_assoc, sin_mul_I, neg_pow z, pow_add, pow_mul, neg_mul, neg_div]\n    using (hasSum_sin' (z * I)).mul_right (-I)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Series.lean", "context": {"open": ["NormedSpace", "scoped Nat"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\nsinh : x\u271d\nz : \u2102\n\u22a2 HasSum (fun n => z ^ (2 * n + 1) / \u2191(2 * n + 1).factorial) sorry"}, {"line": "simpa [mul_assoc, sin_mul_I, neg_pow z, pow_add, pow_mul, neg_mul, neg_div]\n    using (hasSum_sin' (z * I)).mul_right (-I)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem natCast_mul_eq_nsmul (x : \u211d) (n : \u2115) : \u2191((n : \u211d) * x) = n \u2022 (\u2191x : Angle) := by\n  simpa only [nsmul_eq_mul] using coeHom.map_nsmul x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 \u2191(\u2191n * x) = n \u2022 \u2191x"}, {"line": "simpa only [nsmul_eq_mul] using coeHom.map_nsmul x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem intCast_mul_eq_zsmul (x : \u211d) (n : \u2124) : \u2191((n : \u211d) * x : \u211d) = n \u2022 (\u2191x : Angle) := by\n  simpa only [zsmul_eq_mul] using coeHom.map_zsmul x n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2124\n\u22a2 \u2191(\u2191n * x) = n \u2022 \u2191x"}, {"line": "simpa only [zsmul_eq_mul] using coeHom.map_zsmul x n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_nsmul_coe_pi : (2 : \u2115) \u2022 (\u03c0 : Angle) = 0 := by simp [\u2190 natCast_mul_eq_nsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 \u2022 \u2191Real.pi = 0"}, {"line": "simp [\u2190 natCast_mul_eq_nsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_zsmul_coe_pi : (2 : \u2124) \u2022 (\u03c0 : Angle) = 0 := by simp [\u2190 intCast_mul_eq_zsmul]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 2 \u2022 \u2191Real.pi = 0"}, {"line": "simp [\u2190 intCast_mul_eq_zsmul]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem two_nsmul_eq_zero_iff {\u03b8 : Angle} : (2 : \u2115) \u2022 \u03b8 = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u03c0 := by\n  convert two_nsmul_eq_iff <;> simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 2 \u2022 \u03b8 = 0 \u2194 \u03b8 = 0 \u2228 \u03b8 = \u2191Real.pi"}, {"line": "convert two_nsmul_eq_iff <;> simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_eq_real_cos_iff_eq_or_eq_neg {\u03b8 : Angle} {\u03c8 : \u211d} :\n    cos \u03b8 = Real.cos \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 = -\u03c8 := by\n  induction \u03b8 using Real.Angle.induction_on\n  exact cos_eq_iff_coe_eq_or_eq_neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u03c8 : \u211d\n\u22a2 cos sorry = cos \u03c8 \u2194 \u03b8 = \u2191\u03c8 \u2228 \u03b8 = -\u2191\u03c8"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\n\u03c8 x\u271d : \u211d\n\u22a2 cos sorry = cos \u03c8 \u2194 \u2191x\u271d = \u2191\u03c8 \u2228 \u2191x\u271d = -\u2191\u03c8"}, {"line": "exact cos_eq_iff_coe_eq_or_eq_neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_eq_iff_eq_or_eq_neg {\u03b8 \u03c8 : Angle} : cos \u03b8 = cos \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 = -\u03c8 := by\n  induction \u03c8 using Real.Angle.induction_on\n  exact cos_eq_real_cos_iff_eq_or_eq_neg\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\n\u22a2 cos sorry = cos sorry \u2194 \u03b8 = \u03c8 \u2228 \u03b8 = -\u03c8"}, {"line": "induction \u03c8 using Real.Angle.induction_on", "tactic_state": "case h\n\u03b8 : Angle\nx\u271d : \u211d\n\u22a2 cos sorry = cos sorry \u2194 \u03b8 = \u2191x\u271d \u2228 \u03b8 = -\u2191x\u271d"}, {"line": "exact cos_eq_real_cos_iff_eq_or_eq_neg", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_eq_real_sin_iff_eq_or_add_eq_pi {\u03b8 : Angle} {\u03c8 : \u211d} :\n    sin \u03b8 = Real.sin \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 + \u03c8 = \u03c0 := by\n  induction \u03b8 using Real.Angle.induction_on\n  exact sin_eq_iff_coe_eq_or_add_eq_pi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u03c8 : \u211d\n\u22a2 sin sorry = sin \u03c8 \u2194 \u03b8 = \u2191\u03c8 \u2228 \u03b8 + \u2191\u03c8 = \u2191Real.pi"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\n\u03c8 x\u271d : \u211d\n\u22a2 sin sorry = sin \u03c8 \u2194 \u2191x\u271d = \u2191\u03c8 \u2228 \u2191x\u271d + \u2191\u03c8 = \u2191Real.pi"}, {"line": "exact sin_eq_iff_coe_eq_or_add_eq_pi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_eq_iff_eq_or_add_eq_pi {\u03b8 \u03c8 : Angle} : sin \u03b8 = sin \u03c8 \u2194 \u03b8 = \u03c8 \u2228 \u03b8 + \u03c8 = \u03c0 := by\n  induction \u03c8 using Real.Angle.induction_on\n  exact sin_eq_real_sin_iff_eq_or_add_eq_pi\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\n\u22a2 sin sorry = sin sorry \u2194 \u03b8 = \u03c8 \u2228 \u03b8 + \u03c8 = \u2191Real.pi"}, {"line": "induction \u03c8 using Real.Angle.induction_on", "tactic_state": "case h\n\u03b8 : Angle\nx\u271d : \u211d\n\u22a2 sin sorry = sin sorry \u2194 \u03b8 = \u2191x\u271d \u2228 \u03b8 + \u2191x\u271d = \u2191Real.pi"}, {"line": "exact sin_eq_real_sin_iff_eq_or_add_eq_pi", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sq_add_sin_sq (\u03b8 : Real.Angle) : cos \u03b8 ^ 2 + sin \u03b8 ^ 2 = 1 := by\n  induction \u03b8 using Real.Angle.induction_on\n  exact Real.cos_sq_add_sin_sq _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 cos sorry ^ 2 + sin sorry ^ 2 = 1"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 cos sorry ^ 2 + sin sorry ^ 2 = 1"}, {"line": "exact Real.cos_sq_add_sin_sq _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_sin_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) :\n    |sin \u03b8| = |sin \u03c8| := by\n  simp_rw [two_zsmul, \u2190 two_nsmul] at h\n  exact abs_sin_eq_of_two_nsmul_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 |sin sorry| = |sin sorry|"}, {"line": "simp_rw [two_zsmul, \u2190 two_nsmul] at h", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 |sin sorry| = |sin sorry|"}, {"line": "exact abs_sin_eq_of_two_nsmul_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_cos_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) :\n    |cos \u03b8| = |cos \u03c8| := by\n  simp_rw [two_zsmul, \u2190 two_nsmul] at h\n  exact abs_cos_eq_of_two_nsmul_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 |cos sorry| = |cos sorry|"}, {"line": "simp_rw [two_zsmul, \u2190 two_nsmul] at h", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 |cos sorry| = |cos sorry|"}, {"line": "exact abs_cos_eq_of_two_nsmul_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem coe_toReal (\u03b8 : Angle) : (\u03b8.toReal : Angle) = \u03b8 := by\n  induction \u03b8 using Real.Angle.induction_on\n  exact coe_toIocMod _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 \u2191\u03b8.toReal = \u03b8"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 \u2191(\u2191x\u271d).toReal = \u2191x\u271d"}, {"line": "exact coe_toIocMod _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem neg_pi_lt_toReal (\u03b8 : Angle) : -\u03c0 < \u03b8.toReal := by\n  induction \u03b8 using Real.Angle.induction_on\n  exact left_lt_toIocMod _ _ _\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 -Real.pi < \u03b8.toReal"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 -Real.pi < (\u2191x\u271d).toReal"}, {"line": "exact left_lt_toIocMod _ _ _", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_le_pi (\u03b8 : Angle) : \u03b8.toReal \u2264 \u03c0 := by\n  induction \u03b8 using Real.Angle.induction_on\n  convert toIocMod_le_right two_pi_pos _ _\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 \u03b8.toReal \u2264 Real.pi"}, {"line": "induction \u03b8 using Real.Angle.induction_on", "tactic_state": "case h\nx\u271d : \u211d\n\u22a2 (\u2191x\u271d).toReal \u2264 Real.pi"}, {"line": "convert toIocMod_le_right two_pi_pos _ _", "tactic_state": "case h.e'_4\nx\u271d : \u211d\n\u22a2 Real.pi = -Real.pi + 2 * Real.pi"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_coe_eq_self_sub_two_pi_iff {\u03b8 : \u211d} :\n    (\u03b8 : Angle).toReal = \u03b8 - 2 * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc \u03c0 (3 * \u03c0) := by\n  convert @toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff \u03b8 1 <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u211d\n\u22a2 (\u2191\u03b8).toReal = \u03b8 - 2 * Real.pi \u2194 \u03b8 \u2208 Set.Ioc Real.pi (3 * Real.pi)"}, {"line": "convert @toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff \u03b8 1 <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem toReal_coe_eq_self_add_two_pi_iff {\u03b8 : \u211d} :\n    (\u03b8 : Angle).toReal = \u03b8 + 2 * \u03c0 \u2194 \u03b8 \u2208 Set.Ioc (-3 * \u03c0) (-\u03c0) := by\n  convert @toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff \u03b8 (-1) using 2 <;> norm_num\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : \u211d\n\u22a2 (\u2191\u03b8).toReal = \u03b8 + 2 * Real.pi \u2194 \u03b8 \u2208 Set.Ioc (-3 * Real.pi) (-Real.pi)"}, {"line": "convert @toReal_coe_eq_self_sub_two_mul_int_mul_pi_iff \u03b8 (-1) using 2 <;> norm_num", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_cos_eq_abs_sin_of_two_zsmul_add_two_zsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2124) \u2022 \u03b8 + (2 : \u2124) \u2022 \u03c8 = \u03c0) : |cos \u03b8| = |sin \u03c8| := by\n  simp_rw [two_zsmul, \u2190 two_nsmul] at h\n  exact abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 + 2 \u2022 \u03c8 = \u2191Real.pi\n\u22a2 |cos sorry| = |sin sorry|"}, {"line": "simp_rw [two_zsmul, \u2190 two_nsmul] at h", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 + 2 \u2022 \u03c8 = \u2191Real.pi\n\u22a2 |cos sorry| = |sin sorry|"}, {"line": "exact abs_cos_eq_abs_sin_of_two_nsmul_add_two_nsmul_eq_pi h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) : tan \u03b8 = tan \u03c8 := by\n  simp_rw [two_zsmul, \u2190 two_nsmul] at h\n  exact tan_eq_of_two_nsmul_eq h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 tan sorry = tan sorry"}, {"line": "simp_rw [two_zsmul, \u2190 two_nsmul] at h", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 = 2 \u2022 \u03c8\n\u22a2 tan sorry = tan sorry"}, {"line": "exact tan_eq_of_two_nsmul_eq h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_eq_inv_of_two_zsmul_add_two_zsmul_eq_pi {\u03b8 \u03c8 : Angle}\n    (h : (2 : \u2124) \u2022 \u03b8 + (2 : \u2124) \u2022 \u03c8 = \u03c0) : tan \u03c8 = (tan \u03b8)\u207b\u00b9 := by\n  simp_rw [two_zsmul, \u2190 two_nsmul] at h\n  exact tan_eq_inv_of_two_nsmul_add_two_nsmul_eq_pi h\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 + 2 \u2022 \u03c8 = \u2191Real.pi\n\u22a2 tan sorry = (tan sorry)\u207b\u00b9"}, {"line": "simp_rw [two_zsmul, \u2190 two_nsmul] at h", "tactic_state": "\u03b8 \u03c8 : Angle\nh : 2 \u2022 \u03b8 + 2 \u2022 \u03c8 = \u2191Real.pi\n\u22a2 tan sorry = (tan sorry)\u207b\u00b9"}, {"line": "exact tan_eq_inv_of_two_nsmul_add_two_nsmul_eq_pi h", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_pi_sub (\u03b8 : Angle) : ((\u03c0 : Angle) - \u03b8).sign = \u03b8.sign := by\n  simp [sign_antiperiodic.sub_eq']\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\n\u22a2 (\u2191Real.pi - \u03b8).sign = \u03b8.sign"}, {"line": "simp [sign_antiperiodic.sub_eq']", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sign_toReal {\u03b8 : Angle} (h : \u03b8 \u2260 \u03c0) : SignType.sign \u03b8.toReal = \u03b8.sign := by\n  rcases lt_trichotomy \u03b8.toReal 0 with (ht | ht | ht)\n  \u00b7 simp [ht, toReal_neg_iff_sign_neg.1 ht]\n  \u00b7 simp [sign, ht, \u2190 sin_toReal]\n  \u00b7 rw [sign, \u2190 sin_toReal, sign_pos ht,\n      sign_pos\n        (sin_pos_of_pos_of_lt_pi ht ((toReal_le_pi \u03b8).lt_of_ne (toReal_eq_pi_iff.not.2 h)))]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign"}, {"line": "rcases lt_trichotomy \u03b8.toReal 0 with (ht | ht | ht)", "tactic_state": "case inl\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : \u03b8.toReal < 0\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign\n---\ncase inr.inl\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : \u03b8.toReal = 0\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign\n---\ncase inr.inr\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : 0 < \u03b8.toReal\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign"}, {"line": "\u00b7 simp [ht, toReal_neg_iff_sign_neg.1 ht]", "tactic_state": "case inr.inl\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : \u03b8.toReal = 0\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign\n---\ncase inr.inr\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : 0 < \u03b8.toReal\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign"}, {"line": "\u00b7 simp [sign, ht, \u2190 sin_toReal]", "tactic_state": "case inr.inr\n\u03b8 : Angle\nh : \u03b8 \u2260 \u2191Real.pi\nht : 0 < \u03b8.toReal\n\u22a2 SignType.sign \u03b8.toReal = \u03b8.sign"}, {"line": "\u00b7 rw [sign, \u2190 sin_toReal, sign_pos ht,\n      sign_pos\n        (sin_pos_of_pos_of_lt_pi ht ((toReal_le_pi \u03b8).lt_of_ne (toReal_eq_pi_iff.not.2 h)))]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem eq_iff_abs_toReal_eq_of_sign_eq {\u03b8 \u03c8 : Angle} (h : \u03b8.sign = \u03c8.sign) :\n    \u03b8 = \u03c8 \u2194 |\u03b8.toReal| = |\u03c8.toReal| := by simpa [h] using @eq_iff_sign_eq_and_abs_toReal_eq \u03b8 \u03c8\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Angle.lean", "context": {"open": ["Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03b8 \u03c8 : Angle\nh : \u03b8.sign = \u03c8.sign\n\u22a2 \u03b8 = \u03c8 \u2194 |\u03b8.toReal| = |\u03c8.toReal|"}, {"line": "simpa [h] using @eq_iff_sign_eq_and_abs_toReal_eq \u03b8 \u03c8", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_two_mul {x : \u211d} : tan (2 * x) = 2 * tan x / (1 - tan x ^ 2) := by\n  have := @Complex.tan_two_mul x\n  norm_cast at *\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "context": {"open": ["Set Filter", "scoped Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\n\u22a2 sorry = 2 * sorry / (1 - sorry ^ 2)"}, {"line": "have := @Complex.tan_two_mul x", "tactic_state": "x\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\nthis : Complex.tan (2 * \u2191x) = 2 * Complex.tan \u2191x / (1 - Complex.tan \u2191x ^ 2)\n\u22a2 sorry = 2 * sorry / (1 - sorry ^ 2)"}, {"line": "norm_cast at *", "tactic_state": "x\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\nthis : Real.tan (2 * x) = 2 * Real.tan x / (1 - Real.tan x ^ 2)\n\u22a2 sorry = 2 * sorry / (1 - sorry ^ 2)"}]}
{"declaration": "theorem arctan_zero : arctan 0 = 0 := by simp [arctan_eq_arcsin]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "context": {"open": ["Set Filter", "scoped Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narctan : x\u271d\n\u22a2 sorry = 0"}, {"line": "simp [arctan_eq_arcsin]", "tactic_state": "x\u271d : Sort u_1\narctan : x\u271d\n\u22a2 sorry () = 0"}]}
{"declaration": "theorem arctan_neg (x : \u211d) : arctan (-x) = -arctan x := by simp [arctan_eq_arcsin, neg_div]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Arctan.lean", "context": {"open": ["Set Filter", "scoped Topology Real"], "variables": []}, "tactic_states": [{"line": "(initial)", "tactic_state": "x\u271d : Sort u_1\narctan : x\u271d\nx : \u211d\n\u22a2 sorry = -sorry"}, {"line": "simp [arctan_eq_arcsin, neg_div]", "tactic_state": "x\u271d : Sort u_1\narctan : x\u271d\nx : \u211d\n\u22a2 sorry () = -sorry ()"}]}
{"declaration": "theorem sin_two_pi : sin (2 * \u03c0) = 0 := by simp [two_mul, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin (2 * Real.pi) = 0"}, {"line": "simp [two_mul, sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_two_pi : cos (2 * \u03c0) = 1 := by simp [two_mul, cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cos (2 * Real.pi) = 1"}, {"line": "simp [two_mul, cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_antiperiodic : Function.Antiperiodic sin \u03c0 := by simp [sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.Antiperiodic sin Real.pi"}, {"line": "simp [sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_int_mul_pi_sub (x : \u211d) (n : \u2124) : sin (n * \u03c0 - x) = -((-1) ^ n * sin x) := by\n  simpa only [sin_neg,mul_neg,Int.cast_negOnePow] using sin_antiperiodic.int_mul_sub_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2124\n\u22a2 sin (\u2191n * Real.pi - x) = -((-1) ^ n * sin x)"}, {"line": "simpa only [sin_neg,mul_neg,Int.cast_negOnePow] using sin_antiperiodic.int_mul_sub_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_nat_mul_pi_sub (x : \u211d) (n : \u2115) : sin (n * \u03c0 - x) = -((-1) ^ n * sin x) := by\n  simpa only [sin_neg,mul_neg] using sin_antiperiodic.nat_mul_sub_eq n\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nn : \u2115\n\u22a2 sin (\u2191n * Real.pi - x) = -((-1) ^ n * sin x)"}, {"line": "simpa only [sin_neg,mul_neg] using sin_antiperiodic.nat_mul_sub_eq n", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_antiperiodic : Function.Antiperiodic cos \u03c0 := by simp [cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.Antiperiodic cos Real.pi"}, {"line": "simp [cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem abs_cos_int_mul_pi (k : \u2124) : |cos (k * \u03c0)| = 1 := by\n  simp [abs_cos_eq_sqrt_one_sub_sin_sq]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "k : \u2124\n\u22a2 |cos (\u2191k * Real.pi)| = 1"}, {"line": "simp [abs_cos_eq_sqrt_one_sub_sin_sq]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_nat_mul_two_pi_add_pi (n : \u2115) : cos (n * (2 * \u03c0) + \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.nat_mul n).add_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 cos (\u2191n * (2 * Real.pi) + Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.nat_mul n).add_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_int_mul_two_pi_add_pi (n : \u2124) : cos (n * (2 * \u03c0) + \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 cos (\u2191n * (2 * Real.pi) + Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_nat_mul_two_pi_sub_pi (n : \u2115) : cos (n * (2 * \u03c0) - \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 cos (\u2191n * (2 * Real.pi) - Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_int_mul_two_pi_sub_pi (n : \u2124) : cos (n * (2 * \u03c0) - \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 cos (\u2191n * (2 * Real.pi) - Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_add_pi_div_two (x : \u211d) : sin (x + \u03c0 / 2) = cos x := by simp [sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin (x + Real.pi / 2) = cos x"}, {"line": "simp [sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_sub_pi_div_two (x : \u211d) : sin (x - \u03c0 / 2) = -cos x := by simp [sub_eq_add_neg, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin (x - Real.pi / 2) = -cos x"}, {"line": "simp [sub_eq_add_neg, sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_pi_div_two_sub (x : \u211d) : sin (\u03c0 / 2 - x) = cos x := by simp [sub_eq_add_neg, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin (Real.pi / 2 - x) = cos x"}, {"line": "simp [sub_eq_add_neg, sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_add_pi_div_two (x : \u211d) : cos (x + \u03c0 / 2) = -sin x := by simp [cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (x + Real.pi / 2) = -sin x"}, {"line": "simp [cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_sub_pi_div_two (x : \u211d) : cos (x - \u03c0 / 2) = sin x := by simp [sub_eq_add_neg, cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (x - Real.pi / 2) = sin x"}, {"line": "simp [sub_eq_add_neg, cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_pi_div_two_sub (x : \u211d) : cos (\u03c0 / 2 - x) = sin x := by\n  rw [\u2190 cos_neg]\n  rw [neg_sub]\n  rw [cos_sub_pi_div_two]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 cos (Real.pi / 2 - x) = sin x"}, {"line": "rw [\u2190 cos_neg]", "tactic_state": "x : \u211d\n\u22a2 cos (-(Real.pi / 2 - x)) = sin x"}, {"line": "rw [neg_sub]", "tactic_state": "x : \u211d\n\u22a2 cos (x - Real.pi / 2) = sin x"}, {"line": "rw [cos_sub_pi_div_two]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_eq_sqrt_one_sub_cos_sq {x : \u211d} (hl : 0 \u2264 x) (hu : x \u2264 \u03c0) :\n    sin x = \u221a(1 - cos x ^ 2) := by\n  rw [\u2190 abs_sin_eq_sqrt_one_sub_cos_sq]\n  rw [abs_of_nonneg (sin_nonneg_of_nonneg_of_le_pi hl hu)]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhl : 0 \u2264 x\nhu : x \u2264 Real.pi\n\u22a2 sin x = \u221a(1 - cos x ^ 2)"}, {"line": "rw [\u2190 abs_sin_eq_sqrt_one_sub_cos_sq]", "tactic_state": "x : \u211d\nhl : 0 \u2264 x\nhu : x \u2264 Real.pi\n\u22a2 sin x = |sin x|"}, {"line": "rw [abs_of_nonneg (sin_nonneg_of_nonneg_of_le_pi hl hu)]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma cos_half {x : \u211d} (hl : -\u03c0 \u2264 x) (hr : x \u2264 \u03c0) : cos (x / 2) = sqrt ((1 + cos x) / 2) := by\n  have : 0 \u2264 cos (x / 2) := cos_nonneg_of_mem_Icc <| by constructor <;> linarith\n  rw [\u2190 sqrt_sq this]\n  rw [cos_sq]\n  rw [add_div]\n  rw [two_mul]\n  rw [add_halves]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\n\u22a2 cos (x / 2) = \u221a((1 + cos x) / 2)"}, {"line": "have : 0 \u2264 cos (x / 2) := cos_nonneg_of_mem_Icc <| by constructor <;> linarith", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\nthis : 0 \u2264 cos (x / 2)\n\u22a2 cos (x / 2) = \u221a((1 + cos x) / 2)"}, {"line": "rw [\u2190 sqrt_sq this]", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\nthis : 0 \u2264 cos (x / 2)\n\u22a2 \u221a(cos (x / 2) ^ 2) = \u221a((1 + cos x) / 2)"}, {"line": "rw [cos_sq]", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\nthis : 0 \u2264 cos (x / 2)\n\u22a2 \u221a(1 / 2 + cos (2 * (x / 2)) / 2) = \u221a((1 + cos x) / 2)"}, {"line": "rw [add_div]", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\nthis : 0 \u2264 cos (x / 2)\n\u22a2 \u221a(1 / 2 + cos (2 * (x / 2)) / 2) = \u221a(1 / 2 + cos x / 2)"}, {"line": "rw [two_mul]", "tactic_state": "x : \u211d\nhl : -Real.pi \u2264 x\nhr : x \u2264 Real.pi\nthis : 0 \u2264 cos (x / 2)\n\u22a2 \u221a(1 / 2 + cos (x / 2 + x / 2) / 2) = \u221a(1 / 2 + cos x / 2)"}, {"line": "rw [add_halves]", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_half_eq_sqrt {x : \u211d} (hl : 0 \u2264 x) (hr : x \u2264 2 * \u03c0) :\n    sin (x / 2) = sqrt ((1 - cos x) / 2) := by\n  rw [\u2190 abs_sin_half]\n  rw [abs_of_nonneg]\n  apply sin_nonneg_of_nonneg_of_le_pi <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhl : 0 \u2264 x\nhr : x \u2264 2 * Real.pi\n\u22a2 sin (x / 2) = \u221a((1 - cos x) / 2)"}, {"line": "rw [\u2190 abs_sin_half]", "tactic_state": "x : \u211d\nhl : 0 \u2264 x\nhr : x \u2264 2 * Real.pi\n\u22a2 sin (x / 2) = |sin (x / 2)|"}, {"line": "rw [abs_of_nonneg]", "tactic_state": "x : \u211d\nhl : 0 \u2264 x\nhr : x \u2264 2 * Real.pi\n\u22a2 0 \u2264 sin (x / 2)"}, {"line": "apply sin_nonneg_of_nonneg_of_le_pi <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_half_eq_neg_sqrt {x : \u211d} (hl : -(2 * \u03c0) \u2264 x) (hr : x \u2264 0) :\n    sin (x / 2) = -sqrt ((1 - cos x) / 2) := by\n  rw [\u2190 abs_sin_half]\n  rw [abs_of_nonpos]\n  rw [neg_neg]\n  apply sin_nonpos_of_nonnpos_of_neg_pi_le <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nhl : -(2 * Real.pi) \u2264 x\nhr : x \u2264 0\n\u22a2 sin (x / 2) = -\u221a((1 - cos x) / 2)"}, {"line": "rw [\u2190 abs_sin_half]", "tactic_state": "x : \u211d\nhl : -(2 * Real.pi) \u2264 x\nhr : x \u2264 0\n\u22a2 sin (x / 2) = -|sin (x / 2)|"}, {"line": "rw [abs_of_nonpos]", "tactic_state": "x : \u211d\nhl : -(2 * Real.pi) \u2264 x\nhr : x \u2264 0\n\u22a2 sin (x / 2) = - -sin (x / 2)\n---\nx : \u211d\nhl : -(2 * Real.pi) \u2264 x\nhr : x \u2264 0\n\u22a2 sin (x / 2) \u2264 0"}, {"line": "rw [neg_neg]", "tactic_state": "x : \u211d\nhl : -(2 * Real.pi) \u2264 x\nhr : x \u2264 0\n\u22a2 sin (x / 2) \u2264 0"}, {"line": "apply sin_nonpos_of_nonnpos_of_neg_pi_le <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_ne_zero_iff {x : \u211d} : sin x \u2260 0 \u2194 \u2200 n : \u2124, (n : \u211d) * \u03c0 \u2260 x := by\n  rw [\u2190 not_exists]\n  rw [not_iff_not]\n  rw [sin_eq_zero_iff]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin x \u2260 0 \u2194 \u2200 (n : \u2124), \u2191n * Real.pi \u2260 x"}, {"line": "rw [\u2190 not_exists]", "tactic_state": "x : \u211d\n\u22a2 sin x \u2260 0 \u2194 \u00ac\u2203 x_1, \u2191x_1 * Real.pi = x"}, {"line": "rw [not_iff_not]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 \u2203 x_1, \u2191x_1 * Real.pi = x"}, {"line": "rw [sin_eq_zero_iff]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_eq_zero_iff_cos_eq {x : \u211d} : sin x = 0 \u2194 cos x = 1 \u2228 cos x = -1 := by\n  rw [\u2190 mul_self_eq_one_iff]\n  rw [\u2190 sin_sq_add_cos_sq x]\n  rw [sq]\n  rw [sq]\n  rw [\u2190 sub_eq_iff_eq_add]\n  rw [sub_self]\n  exact \u27e8fun h => by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero \u2218 Eq.symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x = 1 \u2228 cos x = -1"}, {"line": "rw [\u2190 mul_self_eq_one_iff]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x * cos x = 1"}, {"line": "rw [\u2190 sin_sq_add_cos_sq x]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x * cos x = sin x ^ 2 + cos x ^ 2"}, {"line": "rw [sq]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x * cos x = sin x * sin x + cos x ^ 2"}, {"line": "rw [sq]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x * cos x = sin x * sin x + cos x * cos x"}, {"line": "rw [\u2190 sub_eq_iff_eq_add]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 cos x * cos x - cos x * cos x = sin x * sin x"}, {"line": "rw [sub_self]", "tactic_state": "x : \u211d\n\u22a2 sin x = 0 \u2194 0 = sin x * sin x"}, {"line": "exact \u27e8fun h => by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero \u2218 Eq.symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_lt_cos_of_nonneg_of_le_pi {x y : \u211d} (hx\u2081 : 0 \u2264 x) (hy\u2082 : y \u2264 \u03c0) (hxy : x < y) :\n    cos y < cos x := by\n  rw [\u2190 sin_pi_div_two_sub]\n  rw [\u2190 sin_pi_div_two_sub]\n  apply sin_lt_sin_of_lt_of_le_pi_div_two <;> linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x y : \u211d\nhx\u2081 : 0 \u2264 x\nhy\u2082 : y \u2264 Real.pi\nhxy : x < y\n\u22a2 cos y < cos x"}, {"line": "rw [\u2190 sin_pi_div_two_sub]", "tactic_state": "x y : \u211d\nhx\u2081 : 0 \u2264 x\nhy\u2082 : y \u2264 Real.pi\nhxy : x < y\n\u22a2 sin (Real.pi / 2 - y) < cos x"}, {"line": "rw [\u2190 sin_pi_div_two_sub]", "tactic_state": "x y : \u211d\nhx\u2081 : 0 \u2264 x\nhy\u2082 : y \u2264 Real.pi\nhxy : x < y\n\u22a2 sin (Real.pi / 2 - y) < sin (Real.pi / 2 - x)"}, {"line": "apply sin_lt_sin_of_lt_of_le_pi_div_two <;> linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_sin : SurjOn sin (Icc (-(\u03c0 / 2)) (\u03c0 / 2)) (Icc (-1) 1) := by\n  simpa only [sin_neg,sin_pi_div_two] using\n    intermediate_value_Icc (neg_le_self pi_div_two_pos.le) continuous_sin.continuousOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 SurjOn sin (Icc (-(Real.pi / 2)) (Real.pi / 2)) (Icc (-1) 1)"}, {"line": "simpa only [sin_neg,sin_pi_div_two] using\n    intermediate_value_Icc (neg_le_self pi_div_two_pos.le) continuous_sin.continuousOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem surjOn_cos : SurjOn cos (Icc 0 \u03c0) (Icc (-1) 1) := by\n  simpa only [cos_zero,cos_pi] using intermediate_value_Icc' pi_pos.le continuous_cos.continuousOn\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 SurjOn cos (Icc 0 Real.pi) (Icc (-1) 1)"}, {"line": "simpa only [cos_zero,cos_pi] using intermediate_value_Icc' pi_pos.le continuous_cos.continuousOn", "tactic_state": "No Goals!"}]}
{"declaration": "theorem range_sin_infinite : (range Real.sin).Infinite := by\n  rw [Real.range_sin]\n  exact Icc_infinite (by norm_num)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 (range sin).Infinite"}, {"line": "rw [Real.range_sin]", "tactic_state": "\u22a2 (Icc (-1) 1).Infinite"}, {"line": "exact Icc_infinite (by norm_num)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrtTwoAddSeries_zero : sqrtTwoAddSeries x 0 = x := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 x.sqrtTwoAddSeries 0 = x"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrtTwoAddSeries_one : sqrtTwoAddSeries 0 1 = \u221a2 := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sqrtTwoAddSeries 0 1 = \u221a2"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sqrtTwoAddSeries_two : sqrtTwoAddSeries 0 2 = \u221a(2 + \u221a2) := by simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sqrtTwoAddSeries 0 2 = \u221a(2 + \u221a2)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_sq_pi_over_two_pow (n : \u2115) :\n    sin (\u03c0 / 2 ^ (n + 1)) ^ 2 = 1 - (sqrtTwoAddSeries 0 n / 2) ^ 2 := by\n  rw [sin_sq]\n  rw [cos_pi_over_two_pow]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 sin (Real.pi / 2 ^ (n + 1)) ^ 2 = 1 - (sqrtTwoAddSeries 0 n / 2) ^ 2"}, {"line": "rw [sin_sq]", "tactic_state": "n : \u2115\n\u22a2 1 - cos (Real.pi / 2 ^ (n + 1)) ^ 2 = 1 - (sqrtTwoAddSeries 0 n / 2) ^ 2"}, {"line": "rw [cos_pi_over_two_pow]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_pi_div_six : sin (\u03c0 / 6) = 1 / 2 := by\n  rw [\u2190 cos_pi_div_two_sub]\n  rw [\u2190 cos_pi_div_three]\n  congr\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin (Real.pi / 6) = 1 / 2"}, {"line": "rw [\u2190 cos_pi_div_two_sub]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 6) = 1 / 2"}, {"line": "rw [\u2190 cos_pi_div_three]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 6) = cos (Real.pi / 3)"}, {"line": "congr", "tactic_state": "case e_x\n\u22a2 Real.pi / 2 - Real.pi / 6 = Real.pi / 3"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sq_sin_pi_div_three : sin (\u03c0 / 3) ^ 2 = 3 / 4 := by\n  rw [\u2190 cos_pi_div_two_sub]\n  rw [\u2190 sq_cos_pi_div_six]\n  congr\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin (Real.pi / 3) ^ 2 = 3 / 4"}, {"line": "rw [\u2190 cos_pi_div_two_sub]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 3) ^ 2 = 3 / 4"}, {"line": "rw [\u2190 sq_cos_pi_div_six]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 3) ^ 2 = cos (Real.pi / 6) ^ 2"}, {"line": "congr", "tactic_state": "case e_a.e_x\n\u22a2 Real.pi / 2 - Real.pi / 3 = Real.pi / 6"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_pi_div_three : sin (\u03c0 / 3) = \u221a3 / 2 := by\n  rw [\u2190 cos_pi_div_two_sub]\n  rw [\u2190 cos_pi_div_six]\n  congr\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin (Real.pi / 3) = \u221a3 / 2"}, {"line": "rw [\u2190 cos_pi_div_two_sub]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 3) = \u221a3 / 2"}, {"line": "rw [\u2190 cos_pi_div_six]", "tactic_state": "\u22a2 cos (Real.pi / 2 - Real.pi / 3) = cos (Real.pi / 6)"}, {"line": "congr", "tactic_state": "case e_x\n\u22a2 Real.pi / 2 - Real.pi / 3 = Real.pi / 6"}, {"line": "ring", "tactic_state": "No Goals!"}]}
{"declaration": "theorem quadratic_root_cos_pi_div_five :\n    letI c := cos (\u03c0 / 5)\n    4 * c ^ 2 - 2 * c - 1 = 0 := by\n  set \u03b8 := \u03c0 / 5 with h\u03b8\n  set c := cos \u03b8\n  set s := sin \u03b8\n  suffices 2 * c = 4 * c ^ 2 - 1 by simp [this]\n  have hs : s \u2260 0 := by\n    rw [ne_eq]\n    rw [sin_eq_zero_iff]\n    rw [h\u03b8]\n    push_neg\n    intro n hn\n    replace hn : n * 5 = 1 := by field_simp [mul_comm _ \u03c0, mul_assoc] at hn; norm_cast at hn\n    omega\n  suffices s * (2 * c) = s * (4 * c ^ 2 - 1) from mul_left_cancel\u2080 hs this\n  calc s * (2 * c) = 2 * s * c := by rw [\u2190 mul_assoc, mul_comm 2]\n                 _ = sin (2 * \u03b8) := by rw [sin_two_mul]\n                 _ = sin (\u03c0 - 2 * \u03b8) := by rw [sin_pi_sub]\n                 _ = sin (2 * \u03b8 + \u03b8) := by congr; field_simp [h\u03b8]; linarith\n                 _ = sin (2 * \u03b8) * c + cos (2 * \u03b8) * s := sin_add (2 * \u03b8) \u03b8\n                 _ = 2 * s * c * c + cos (2 * \u03b8) * s := by rw [sin_two_mul]\n                 _ = 2 * s * c * c + (2 * c ^ 2 - 1) * s := by rw [cos_two_mul]\n                 _ = s * (2 * c * c) + s * (2 * c ^ 2 - 1) := by linarith\n                 _ = s * (4 * c ^ 2 - 1) := by linarith\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 4 * cos (Real.pi / 5) ^ 2 - 2 * cos (Real.pi / 5) - 1 = 0"}, {"line": "set \u03b8 := \u03c0 / 5 with h\u03b8", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\n\u22a2 4 * cos (Real.pi / 5) ^ 2 - 2 * cos (Real.pi / 5) - 1 = 0"}, {"line": "set c := cos \u03b8", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\nc : \u211d := cos \u2191\u03b8\n\u22a2 4 * cos (Real.pi / 5) ^ 2 - 2 * cos (Real.pi / 5) - 1 = 0"}, {"line": "set s := sin \u03b8", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\nc : \u211d := cos \u2191\u03b8\ns : \u211d := sin \u2191\u03b8\n\u22a2 4 * cos (Real.pi / 5) ^ 2 - 2 * cos (Real.pi / 5) - 1 = 0"}, {"line": "suffices 2 * c = 4 * c ^ 2 - 1 by simp [this]", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\nc : \u211d := cos \u2191\u03b8\ns : \u211d := sin \u2191\u03b8\n\u22a2 2 * c = 4 * c ^ 2 - 1"}, {"line": "have hs : s \u2260 0 := sorry", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\nc : \u211d := cos \u2191\u03b8\ns : \u211d := sin \u2191\u03b8\nhs : s \u2260 0\n\u22a2 2 * c = 4 * c ^ 2 - 1"}, {"line": "suffices s * (2 * c) = s * (4 * c ^ 2 - 1) from mul_left_cancel\u2080 hs this", "tactic_state": "\u03b8 : \u2115 := sorry / 5\nh\u03b8 : \u03b8 = sorry / 5\nc : \u211d := cos \u2191\u03b8\ns : \u211d := sin \u2191\u03b8\nhs : s \u2260 0\n\u22a2 s * (2 * c) = s * (4 * c ^ 2 - 1)"}, {"line": "calc s * (2 * c) = 2 * s * c := by rw [\u2190 mul_assoc, mul_comm 2]\n                 _ = sin (2 * \u03b8) := by rw [sin_two_mul]\n                 _ = sin (\u03c0 - 2 * \u03b8) := by rw [sin_pi_sub]\n                 _ = sin (2 * \u03b8 + \u03b8) := by congr; field_simp [h\u03b8]; linarith\n                 _ = sin (2 * \u03b8) * c + cos (2 * \u03b8) * s := sin_add (2 * \u03b8) \u03b8\n                 _ = 2 * s * c * c + cos (2 * \u03b8) * s := by rw [sin_two_mul]\n                 _ = 2 * s * c * c + (2 * c ^ 2 - 1) * s := by rw [cos_two_mul]\n                 _ = s * (2 * c * c) + s * (2 * c ^ 2 - 1) := by linarith\n                 _ = s * (4 * c ^ 2 - 1) := by linarith", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_pi_div_five : cos (\u03c0 / 5) = (1 + \u221a5) / 4 := by\n  set c := cos (\u03c0 / 5)\n  have : 4 * (c * c) + (-2) * c + (-1) = 0 := by\n    rw [\u2190 sq]\n    rw [neg_mul]\n    rw [\u2190 sub_eq_add_neg]\n    rw [\u2190 sub_eq_add_neg]\n    exact quadratic_root_cos_pi_div_five\n  have hd : discrim 4 (-2) (-1) = (2 * \u221a5) * (2 * \u221a5) := by norm_num [discrim, mul_mul_mul_comm]\n  rcases (quadratic_eq_zero_iff (by norm_num) hd c).mp this with h | h\n  \u00b7 field_simp [h]; linarith\n  \u00b7 absurd (show 0 \u2264 c from cos_nonneg_of_mem_Icc <| by constructor <;> linarith [pi_pos.le])\n    rw [not_le]\n    rw [h]\n    exact div_neg_of_neg_of_pos (by norm_num [lt_sqrt]) (by positivity)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "set c := cos (\u03c0 / 5)", "tactic_state": "c : \u211d := cos (sorry / 5)\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "have : 4 * (c * c) + (-2) * c + (-1) = 0 := by\n    rw [\u2190 sq]\n    rw [neg_mul]\n    rw [\u2190 sub_eq_add_neg]\n    rw [\u2190 sub_eq_add_neg]\n    exact quadratic_root_cos_pi_div_five", "tactic_state": "c : \u211d := cos (sorry / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "have hd : discrim 4 (-2) (-1) = (2 * \u221a5) * (2 * \u221a5) := by norm_num [discrim, mul_mul_mul_comm]", "tactic_state": "c : \u211d := cos (sorry / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "rcases (quadratic_eq_zero_iff (by norm_num) hd c).mp this with h | h", "tactic_state": "case inl\nc : \u211d := cos (sorry / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\nh : c = (- -2 + 2 * \u221a5) / (2 * 4)\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4\n---\ncase inr\nc : \u211d := cos (sorry / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\nh : c = (- -2 - 2 * \u221a5) / (2 * 4)\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "\u00b7 field_simp [h]; linarith", "tactic_state": "case inr\nc : \u211d := cos (sorry / 5)\nthis : 4 * (c * c) + -2 * c + -1 = 0\nhd : discrim 4 (-2) (-1) = 2 * \u221a5 * (2 * \u221a5)\nh : c = (- -2 - 2 * \u221a5) / (2 * 4)\n\u22a2 cos (Real.pi / 5) = (1 + \u221a5) / 4"}, {"line": "\u00b7 absurd (show 0 \u2264 c from cos_nonneg_of_mem_Icc <| by constructor <;> linarith [pi_pos.le])\n    rw [not_le]\n    rw [h]\n    exact div_neg_of_neg_of_pos (by norm_num [lt_sqrt]) (by positivity)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_pi_div_four : tan (\u03c0 / 4) = 1 := by\n  rw [tan_eq_sin_div_cos]\n  rw [cos_pi_div_four]\n  rw [sin_pi_div_four]\n  have h : \u221a2 / 2 > 0 := by positivity\n  exact div_self (ne_of_gt h)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan (Real.pi / 4) = 1"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "\u22a2 sin (Real.pi / 4) / cos (Real.pi / 4) = 1"}, {"line": "rw [cos_pi_div_four]", "tactic_state": "\u22a2 sin (Real.pi / 4) / (\u221a2 / 2) = 1"}, {"line": "rw [sin_pi_div_four]", "tactic_state": "\u22a2 \u221a2 / 2 / (\u221a2 / 2) = 1"}, {"line": "have h : \u221a2 / 2 > 0 := sorry", "tactic_state": "h : \u221a2 / 2 > 0\n\u22a2 \u221a2 / 2 / (\u221a2 / 2) = 1"}, {"line": "exact div_self (ne_of_gt h)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_pi_div_two : tan (\u03c0 / 2) = 0 := by simp [tan_eq_sin_div_cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan (Real.pi / 2) = 0"}, {"line": "simp [tan_eq_sin_div_cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_pi_div_six : tan (\u03c0 / 6) = 1 / sqrt 3 := by\n  rw [tan_eq_sin_div_cos]\n  rw [sin_pi_div_six]\n  rw [cos_pi_div_six]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan (Real.pi / 6) = \u21911 / sorry"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "\u22a2 sin (Real.pi / 6) / cos (Real.pi / 6) = \u21911 / sorry"}, {"line": "rw [sin_pi_div_six]", "tactic_state": "\u22a2 1 / 2 / cos (Real.pi / 6) = \u21911 / sorry"}, {"line": "rw [cos_pi_div_six]", "tactic_state": "\u22a2 1 / 2 / (\u221a3 / 2) = \u21911 / sorry"}, {"line": "ring", "tactic_state": "\u22a2 (\u221a3)\u207b\u00b9 = sorry\u207b\u00b9"}]}
{"declaration": "theorem tan_pi_div_three : tan (\u03c0 / 3) = sqrt 3 := by\n  rw [tan_eq_sin_div_cos]\n  rw [sin_pi_div_three]\n  rw [cos_pi_div_three]\n  ring\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan (Real.pi / 3) = sorry"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "\u22a2 sin (Real.pi / 3) / cos (Real.pi / 3) = sorry"}, {"line": "rw [sin_pi_div_three]", "tactic_state": "\u22a2 \u221a3 / 2 / cos (Real.pi / 3) = sorry"}, {"line": "rw [cos_pi_div_three]", "tactic_state": "\u22a2 \u221a3 / 2 / (1 / 2) = sorry"}, {"line": "ring", "tactic_state": "\u22a2 \u221a3 = sorry"}]}
{"declaration": "theorem tan_pos_of_pos_of_lt_pi_div_two {x : \u211d} (h0x : 0 < x) (hxp : x < \u03c0 / 2) : 0 < tan x := by\n  rw [tan_eq_sin_div_cos]\n  exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo \u27e8by linarith, hxp\u27e9)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nh0x : 0 < x\nhxp : x < Real.pi / 2\n\u22a2 0 < tan x"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\nh0x : 0 < x\nhxp : x < Real.pi / 2\n\u22a2 0 < sin x / cos x"}, {"line": "exact div_pos (sin_pos_of_pos_of_lt_pi h0x (by linarith)) (cos_pos_of_mem_Ioo \u27e8by linarith, hxp\u27e9)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem strictMonoOn_tan : StrictMonoOn tan (Ioo (-(\u03c0 / 2)) (\u03c0 / 2)) := by\n  rintro x hx y hy hlt\n  rw [tan_eq_sin_div_cos]\n  rw [tan_eq_sin_div_cos]\n  rw [div_lt_div_iff\u2080 (cos_pos_of_mem_Ioo hx) (cos_pos_of_mem_Ioo hy)]\n  rw [mul_comm]\n  rw [\u2190 sub_pos]\n  rw [\u2190 sin_sub]\n  exact sin_pos_of_pos_of_lt_pi (sub_pos.2 hlt) <| by linarith [hx.1, hy.2]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 StrictMonoOn tan (Ioo (-(Real.pi / 2)) (Real.pi / 2))"}, {"line": "rintro x hx y hy hlt", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 tan x < tan y"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 sin x / cos x < tan y"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 sin x / cos x < sin y / cos y"}, {"line": "rw [div_lt_div_iff\u2080 (cos_pos_of_mem_Ioo hx) (cos_pos_of_mem_Ioo hy)]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 sin x * cos y < sin y * cos x"}, {"line": "rw [mul_comm]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 cos y * sin x < sin y * cos x"}, {"line": "rw [\u2190 sub_pos]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 0 < sin y * cos x - cos y * sin x"}, {"line": "rw [\u2190 sin_sub]", "tactic_state": "x : \u211d\nhx : x \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\ny : \u211d\nhy : y \u2208 Ioo (-(Real.pi / 2)) (Real.pi / 2)\nhlt : x < y\n\u22a2 0 < sin (y - x)"}, {"line": "exact sin_pos_of_pos_of_lt_pi (sub_pos.2 hlt) <| by linarith [hx.1, hy.2]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_periodic : Function.Periodic tan \u03c0 := by\n  simpa only [Function.Periodic,tan_eq_sin_div_cos] using sin_antiperiodic.div cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.Periodic tan Real.pi"}, {"line": "simpa only [Function.Periodic,tan_eq_sin_div_cos] using sin_antiperiodic.div cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_pi : tan \u03c0 = 0 := by rw [tan_periodic.eq, tan_zero]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 tan Real.pi = 0"}, {"line": "rw [tan_periodic.eq, tan_zero]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tan_pi_div_two_sub (x : \u211d) : tan (\u03c0 / 2 - x) = (tan x)\u207b\u00b9 := by\n  rw [tan_eq_sin_div_cos]\n  rw [tan_eq_sin_div_cos]\n  rw [inv_div]\n  rw [sin_pi_div_two_sub]\n  rw [cos_pi_div_two_sub]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\n\u22a2 tan (Real.pi / 2 - x) = (tan x)\u207b\u00b9"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\n\u22a2 sin (Real.pi / 2 - x) / cos (Real.pi / 2 - x) = (tan x)\u207b\u00b9"}, {"line": "rw [tan_eq_sin_div_cos]", "tactic_state": "x : \u211d\n\u22a2 sin (Real.pi / 2 - x) / cos (Real.pi / 2 - x) = (sin x / cos x)\u207b\u00b9"}, {"line": "rw [inv_div]", "tactic_state": "x : \u211d\n\u22a2 sin (Real.pi / 2 - x) / cos (Real.pi / 2 - x) = cos x / sin x"}, {"line": "rw [sin_pi_div_two_sub]", "tactic_state": "x : \u211d\n\u22a2 cos x / cos (Real.pi / 2 - x) = cos x / sin x"}, {"line": "rw [cos_pi_div_two_sub]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_sin_pi_div_two : Tendsto sin (\ud835\udcdd[<] (\u03c0 / 2)) (\ud835\udcdd 1) := by\n  convert continuous_sin.continuousWithinAt.tendsto\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto sin (nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2))) (nhds 1)"}, {"line": "convert continuous_sin.continuousWithinAt.tendsto", "tactic_state": "case h.e'_5.h.e'_3\n\u22a2 1 = sin (Real.pi / 2)"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_cos_pi_div_two : Tendsto cos (\ud835\udcdd[<] (\u03c0 / 2)) (\ud835\udcdd[>] 0) := by\n  apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within\n  \u00b7 convert continuous_cos.continuousWithinAt.tendsto\n    simp\n  \u00b7 filter_upwards [Ioo_mem_nhdsLT (neg_lt_self pi_div_two_pos)] with x hx\n    exact cos_pos_of_mem_Ioo hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto cos (nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2))) (nhdsWithin 0 (Ioi 0))"}, {"line": "apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within", "tactic_state": "case h1\n\u22a2 Tendsto cos (nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2))) (nhds 0)\n---\ncase h2\n\u22a2 \u2200\u1da0 (x : \u211d) in nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2)), cos x \u2208 Ioi 0"}, {"line": "\u00b7 convert continuous_cos.continuousWithinAt.tendsto\n    simp", "tactic_state": "case h2\n\u22a2 \u2200\u1da0 (x : \u211d) in nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2)), cos x \u2208 Ioi 0"}, {"line": "\u00b7 filter_upwards [Ioo_mem_nhdsLT (neg_lt_self pi_div_two_pos)] with x hx\n    exact cos_pos_of_mem_Ioo hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_tan_pi_div_two : Tendsto tan (\ud835\udcdd[<] (\u03c0 / 2)) atTop := by\n  convert tendsto_cos_pi_div_two.inv_tendsto_nhdsGT_zero.atTop_mul_pos zero_lt_one\n    tendsto_sin_pi_div_two using 1\n  simp only [Pi.inv_apply]\n  simp only [\u2190 div_eq_inv_mul]\n  simp only [\u2190 tan_eq_sin_div_cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto tan (nhdsWithin (Real.pi / 2) (Iio (Real.pi / 2))) atTop"}, {"line": "convert tendsto_cos_pi_div_two.inv_tendsto_nhdsGT_zero.atTop_mul_pos zero_lt_one\n    tendsto_sin_pi_div_two using 1", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => cos\u207b\u00b9 x * sin x"}, {"line": "simp only [Pi.inv_apply]", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => (cos x)\u207b\u00b9 * sin x"}, {"line": "simp only [\u2190 div_eq_inv_mul]", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => sin x / cos x"}, {"line": "simp only [\u2190 tan_eq_sin_div_cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_sin_neg_pi_div_two : Tendsto sin (\ud835\udcdd[>] (-(\u03c0 / 2))) (\ud835\udcdd (-1)) := by\n  convert continuous_sin.continuousWithinAt.tendsto using 2\n  simp\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto sin (nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2)))) (nhds (-1))"}, {"line": "convert continuous_sin.continuousWithinAt.tendsto using 2", "tactic_state": "case h.e'_5.h.e'_3\n\u22a2 -1 = sin (-(Real.pi / 2))"}, {"line": "simp", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_cos_neg_pi_div_two : Tendsto cos (\ud835\udcdd[>] (-(\u03c0 / 2))) (\ud835\udcdd[>] 0) := by\n  apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within\n  \u00b7 convert continuous_cos.continuousWithinAt.tendsto\n    simp\n  \u00b7 filter_upwards [Ioo_mem_nhdsGT (neg_lt_self pi_div_two_pos)] with x hx\n    exact cos_pos_of_mem_Ioo hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto cos (nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2)))) (nhdsWithin 0 (Ioi 0))"}, {"line": "apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within", "tactic_state": "case h1\n\u22a2 Tendsto cos (nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2)))) (nhds 0)\n---\ncase h2\n\u22a2 \u2200\u1da0 (x : \u211d) in nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2))), cos x \u2208 Ioi 0"}, {"line": "\u00b7 convert continuous_cos.continuousWithinAt.tendsto\n    simp", "tactic_state": "case h2\n\u22a2 \u2200\u1da0 (x : \u211d) in nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2))), cos x \u2208 Ioi 0"}, {"line": "\u00b7 filter_upwards [Ioo_mem_nhdsGT (neg_lt_self pi_div_two_pos)] with x hx\n    exact cos_pos_of_mem_Ioo hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem tendsto_tan_neg_pi_div_two : Tendsto tan (\ud835\udcdd[>] (-(\u03c0 / 2))) atBot := by\n  convert tendsto_cos_neg_pi_div_two.inv_tendsto_nhdsGT_zero.atTop_mul_neg (by norm_num)\n      tendsto_sin_neg_pi_div_two using 1\n  simp only [Pi.inv_apply]\n  simp only [\u2190 div_eq_inv_mul]\n  simp only [\u2190 tan_eq_sin_div_cos]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Tendsto tan (nhdsWithin (-(Real.pi / 2)) (Ioi (-(Real.pi / 2)))) atBot"}, {"line": "convert tendsto_cos_neg_pi_div_two.inv_tendsto_nhdsGT_zero.atTop_mul_neg (by norm_num)\n      tendsto_sin_neg_pi_div_two using 1", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => cos\u207b\u00b9 x * sin x"}, {"line": "simp only [Pi.inv_apply]", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => (cos x)\u207b\u00b9 * sin x"}, {"line": "simp only [\u2190 div_eq_inv_mul]", "tactic_state": "case h.e'_3\n\u22a2 tan = fun x => sin x / cos x"}, {"line": "simp only [\u2190 tan_eq_sin_div_cos]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_eq_zero_iff_cos_eq {z : \u2102} : sin z = 0 \u2194 cos z = 1 \u2228 cos z = -1 := by\n  rw [\u2190 mul_self_eq_one_iff]\n  rw [\u2190 sin_sq_add_cos_sq]\n  rw [sq]\n  rw [sq]\n  rw [\u2190 sub_eq_iff_eq_add]\n  rw [sub_self]\n  exact \u27e8fun h => by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero \u2218 Eq.symm\u27e9\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry = 1 \u2228 cos sorry = -1"}, {"line": "rw [\u2190 mul_self_eq_one_iff]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry * cos sorry = 1"}, {"line": "rw [\u2190 sin_sq_add_cos_sq]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry * cos sorry = sin ?m.1407 ^ 2 + cos ?m.1407 ^ 2\n---\nz : \u2102\n\u22a2 \u211d"}, {"line": "rw [sq]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry * cos sorry = sin ?m.1407 * sin ?m.1407 + cos ?m.1407 ^ 2\n---\nz : \u2102\n\u22a2 \u211d"}, {"line": "rw [sq]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry * cos sorry = sin ?m.1407 * sin ?m.1407 + cos ?m.1407 * cos ?m.1407\n---\nz : \u2102\n\u22a2 \u211d"}, {"line": "rw [\u2190 sub_eq_iff_eq_add]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 cos sorry * cos sorry - cos ?m.1407 * cos ?m.1407 = sin ?m.1407 * sin ?m.1407\n---\nz : \u2102\n\u22a2 \u211d\n---\nz : \u2102\n\u22a2 \u211d"}, {"line": "rw [sub_self]", "tactic_state": "z : \u2102\n\u22a2 sin sorry = 0 \u2194 0 = sin sorry * sin sorry"}, {"line": "exact \u27e8fun h => by rw [h, mul_zero], eq_zero_of_mul_self_eq_zero \u2218 Eq.symm\u27e9", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_two_pi : sin (2 * \u03c0) = 0 := by simp [two_mul, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 sin (2 * Real.pi) = 0"}, {"line": "simp [two_mul, sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_two_pi : cos (2 * \u03c0) = 1 := by simp [two_mul, cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 cos (2 * Real.pi) = 1"}, {"line": "simp [two_mul, cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_antiperiodic : Function.Antiperiodic sin \u03c0 := by simp [sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.Antiperiodic sin Real.pi"}, {"line": "simp [sin_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_antiperiodic : Function.Antiperiodic cos \u03c0 := by simp [cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u22a2 Function.Antiperiodic cos Real.pi"}, {"line": "simp [cos_add]", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_int_mul_two_pi_add_pi (n : \u2124) : cos (n * (2 * \u03c0) + \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 cos (\u2191n * (2 * Real.pi) + Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.int_mul n).add_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_nat_mul_two_pi_sub_pi (n : \u2115) : cos (n * (2 * \u03c0) - \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2115\n\u22a2 cos (\u2191n * (2 * Real.pi) - Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.nat_mul n).sub_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_int_mul_two_pi_sub_pi (n : \u2124) : cos (n * (2 * \u03c0) - \u03c0) = -1 := by\n  simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "n : \u2124\n\u22a2 cos (\u2191n * (2 * Real.pi) - Real.pi) = -1"}, {"line": "simpa only [cos_zero] using (cos_periodic.int_mul n).sub_antiperiod_eq cos_antiperiodic", "tactic_state": "No Goals!"}]}
{"declaration": "theorem sin_add_pi_div_two (x : \u2102) : sin (x + \u03c0 / 2) = cos x := by simp [sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin sorry = cos sorry"}, {"line": "simp [sin_add]", "tactic_state": "x : \u2102\n\u22a2 sin (sorry ()) = cos (sorry ())"}]}
{"declaration": "theorem sin_sub_pi_div_two (x : \u2102) : sin (x - \u03c0 / 2) = -cos x := by simp [sub_eq_add_neg, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin sorry = -cos sorry"}, {"line": "simp [sub_eq_add_neg, sin_add]", "tactic_state": "x : \u2102\n\u22a2 sin (sorry ()) = -cos (sorry ())"}]}
{"declaration": "theorem sin_pi_div_two_sub (x : \u2102) : sin (\u03c0 / 2 - x) = cos x := by simp [sub_eq_add_neg, sin_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 sin sorry = cos sorry"}, {"line": "simp [sub_eq_add_neg, sin_add]", "tactic_state": "x : \u2102\n\u22a2 sin (sorry ()) = cos (sorry ())"}]}
{"declaration": "theorem cos_add_pi_div_two (x : \u2102) : cos (x + \u03c0 / 2) = -sin x := by simp [cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos sorry = -sin sorry"}, {"line": "simp [cos_add]", "tactic_state": "x : \u2102\n\u22a2 cos (sorry ()) = -sin (sorry ())"}]}
{"declaration": "theorem cos_sub_pi_div_two (x : \u2102) : cos (x - \u03c0 / 2) = sin x := by simp [sub_eq_add_neg, cos_add]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u2102\n\u22a2 cos sorry = sin sorry"}, {"line": "simp [sub_eq_add_neg, cos_add]", "tactic_state": "x : \u2102\n\u22a2 cos (sorry ()) = sin (sorry ())"}]}
{"declaration": "theorem exp_antiperiodic : Function.Antiperiodic exp (\u03c0 * I) := by simp [exp_add, exp_mul_I]\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u211d\n\u22a2 Function.Antiperiodic exp (Real.pi * I)"}, {"line": "simp [exp_add, exp_mul_I]", "tactic_state": "I : \u211d\n\u22a2 \u2200 (x : \u211d), exp x * exp (Real.pi * I) = -exp x"}]}
{"declaration": "theorem exp_mul_I_antiperiodic : Function.Antiperiodic (fun x => exp (x * I)) \u03c0 := by\n  simpa only [mul_inv_cancel_right\u2080 I_ne_zero] using exp_antiperiodic.mul_const I_ne_zero\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Basic.lean", "context": {"open": ["Topology Filter Set", "Lean.Meta Qq", "Real", "Real NNReal", "Polynomial in", "Real"], "variables": ["{x y z : \u211d}", "(x : \u211d)"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "I : \u211d\n\u22a2 Function.Antiperiodic (fun x => exp (x * I)) Real.pi"}, {"line": "simpa only [mul_inv_cancel_right\u2080 I_ne_zero] using exp_antiperiodic.mul_const I_ne_zero", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_le (hx : 0 \u2264 x) : sin x \u2264 x := by\n  obtain rfl | hx := hx.eq_or_lt\n  \u00b7 simp\n  \u00b7 exact (sin_lt hx).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : 0 \u2264 x\n\u22a2 sorry \u2264 x"}, {"line": "obtain rfl | hx := hx.eq_or_lt", "tactic_state": "case inl\nx\u271d : Sort u_1\nsin : x\u271d\nhx : 0 \u2264 0\n\u22a2 sorry \u2264 0\n---\ncase inr\nx : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 simp", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx\u271d : 0 \u2264 x\nhx : 0 < x\n\u22a2 sorry \u2264 x"}, {"line": "\u00b7 exact (sin_lt hx).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma lt_sin (hx : x < 0) : x < sin x := by simpa using sin_lt <| neg_pos.2 hx", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x < 0\n\u22a2 x < sorry"}, {"line": "simpa using sin_lt <| neg_pos.2 hx", "tactic_state": "No Goals!"}]}
{"declaration": "lemma le_sin (hx : x \u2264 0) : x \u2264 sin x := by simpa using sin_le <| neg_nonneg.2 hx\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2264 0\n\u22a2 x \u2264 sorry"}, {"line": "simpa using sin_le <| neg_nonneg.2 hx", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_lt_sin {x : \u211d} (hx : 0 < x) (hx' : x < \u03c0 / 2) : 2 / \u03c0 * x < sin x := by\n  rw [\u2190 inv_div]\n  simpa [-inv_div, mul_inv_cancel_left\u2080 pi_div_two_pos.ne'] using @lt_sin_mul ((\u03c0 / 2)\u207b\u00b9 * x)\n    (mul_pos (inv_pos.2 pi_div_two_pos) hx) (by rwa [\u2190 div_eq_inv_mul, div_lt_one pi_div_two_pos])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nx : \u211d\nhx : 0 < x\nhx' : x < \u03c0 / 2\n\u22a2 2 / \u03c0 * x < sorry"}, {"line": "rw [\u2190 inv_div]", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nx : \u211d\nhx : 0 < x\nhx' : x < \u03c0 / 2\n\u22a2 (\u03c0 / 2)\u207b\u00b9 * x < sorry"}, {"line": "simpa [-inv_div, mul_inv_cancel_left\u2080 pi_div_two_pos.ne'] using @lt_sin_mul ((\u03c0 / 2)\u207b\u00b9 * x)\n    (mul_pos (inv_pos.2 pi_div_two_pos) hx) (by rwa [\u2190 div_eq_inv_mul, div_lt_one pi_div_two_pos])", "tactic_state": "No Goals!"}]}
{"declaration": "theorem mul_le_sin {x : \u211d} (hx : 0 \u2264 x) (hx' : x \u2264 \u03c0 / 2) : 2 / \u03c0 * x \u2264 sin x := by\n  rw [\u2190 inv_div]\n  simpa [-inv_div, mul_inv_cancel_left\u2080 pi_div_two_pos.ne'] using @le_sin_mul ((\u03c0 / 2)\u207b\u00b9 * x)\n    (mul_nonneg (inv_nonneg.2 pi_div_two_pos.le) hx)\n    (by rwa [\u2190 div_eq_inv_mul, div_le_one pi_div_two_pos])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nx : \u211d\nhx : 0 \u2264 x\nhx' : x \u2264 \u03c0 / 2\n\u22a2 2 / \u03c0 * x \u2264 sorry"}, {"line": "rw [\u2190 inv_div]", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nx : \u211d\nhx : 0 \u2264 x\nhx' : x \u2264 \u03c0 / 2\n\u22a2 (\u03c0 / 2)\u207b\u00b9 * x \u2264 sorry"}, {"line": "simpa [-inv_div, mul_inv_cancel_left\u2080 pi_div_two_pos.ne'] using @le_sin_mul ((\u03c0 / 2)\u207b\u00b9 * x)\n    (mul_nonneg (inv_nonneg.2 pi_div_two_pos.le) hx)\n    (by rwa [\u2190 div_eq_inv_mul, div_le_one pi_div_two_pos])", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_le_mul (hx : -(\u03c0 / 2) \u2264 x) (hx\u2080 : x \u2264 0) : sin x \u2264 2 / \u03c0 * x := by\n  simpa using mul_le_sin (neg_nonneg.2 hx\u2080) (neg_le.2 hx)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : -(\u03c0 / 2) \u2264 x\nhx\u2080 : x \u2264 0\n\u22a2 sorry \u2264 2 / \u03c0 * x"}, {"line": "simpa using mul_le_sin (neg_nonneg.2 hx\u2080) (neg_le.2 hx)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma mul_abs_le_abs_sin (hx : |x| \u2264 \u03c0 / 2) : 2 / \u03c0 * |x| \u2264 |sin x| := by\n  wlog hx\u2080 : 0 \u2264 x\n  case inr => simpa using this (by rwa [abs_neg]) <| neg_nonneg.2 <| le_of_not_le hx\u2080\n  rw [abs_of_nonneg hx\u2080] at hx \u22a2\n  exact (mul_le_sin hx\u2080 hx).trans (le_abs_self _)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : |x| \u2264 \u03c0 / 2\n\u22a2 2 / \u03c0 * |x| \u2264 |sorry|"}, {"line": "wlog hx\u2080 : 0 \u2264 x", "tactic_state": "case inr\nx \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : |x| \u2264 \u03c0 / 2\nthis : \u2200 {x \u03c0 : \u211d} {x_1 : Sort u_1} {sin : x_1}, |x| \u2264 \u03c0 / 2 \u2192 0 \u2264 x \u2192 2 / \u03c0 * |x| \u2264 |sorry|\nhx\u2080 : \u00ac0 \u2264 x\n\u22a2 2 / \u03c0 * |x| \u2264 |sorry|\n---\nx\u271d\u00b9 x \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : |x| \u2264 \u03c0 / 2\nhx\u2080 : 0 \u2264 x\n\u22a2 2 / \u03c0 * |x| \u2264 |sorry|"}, {"line": "case inr => simpa using this (by rwa [abs_neg]) <| neg_nonneg.2 <| le_of_not_le hx\u2080", "tactic_state": "x\u271d\u00b9 x \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : |x| \u2264 \u03c0 / 2\nhx\u2080 : 0 \u2264 x\n\u22a2 2 / \u03c0 * |x| \u2264 |sorry|"}, {"line": "rw [abs_of_nonneg hx\u2080] at hx \u22a2", "tactic_state": "x\u271d\u00b9 x \u03c0 : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2264 \u03c0 / 2\nhx\u2080 : 0 \u2264 x\n\u22a2 2 / \u03c0 * x \u2264 |sorry|"}, {"line": "exact (mul_le_sin hx\u2080 hx).trans (le_abs_self _)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_sq_lt_sq (hx : x \u2260 0) : sin x ^ 2 < x ^ 2 := by\n  wlog hx\u2080 : 0 < x\n  case inr =>\n    simpa using this (neg_ne_zero.2 hx) <| neg_pos_of_neg <| hx.lt_of_le <| le_of_not_lt hx\u2080\n  rcases le_or_lt x 1 with hx\u03c0 | hx\u03c0\n  case inl =>\n    exact pow_lt_pow_left\u2080 (sin_lt hx\u2080)\n      (sin_nonneg_of_nonneg_of_le_pi hx\u2080.le (by linarith [two_le_pi])) (by simp)\n  case inr =>\n    exact (sin_sq_le_one _).trans_lt (by rwa [one_lt_sq_iff\u2080 hx\u2080.le])\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\n\u22a2 sorry ^ 2 < x ^ 2"}, {"line": "wlog hx\u2080 : 0 < x", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nthis : \u2200 {x : \u211d} {x_1 : Sort u_1} {sin : x_1}, x \u2260 0 \u2192 0 < x \u2192 sorry ^ 2 < x ^ 2\nhx\u2080 : \u00ac0 < x\n\u22a2 sorry ^ 2 < x ^ 2\n---\nx\u271d\u00b9 x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nhx\u2080 : 0 < x\n\u22a2 sorry ^ 2 < x ^ 2"}, {"line": "case inr =>\n    simpa using this (neg_ne_zero.2 hx) <| neg_pos_of_neg <| hx.lt_of_le <| le_of_not_lt hx\u2080", "tactic_state": "x\u271d\u00b9 x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nhx\u2080 : 0 < x\n\u22a2 sorry ^ 2 < x ^ 2"}, {"line": "rcases le_or_lt x 1 with hx\u03c0 | hx\u03c0", "tactic_state": "case inl\nx\u271d\u00b9 x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nhx\u2080 : 0 < x\nhx\u03c0 : x \u2264 1\n\u22a2 sorry ^ 2 < x ^ 2\n---\ncase inr\nx\u271d\u00b9 x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nhx\u2080 : 0 < x\nhx\u03c0 : 1 < x\n\u22a2 sorry ^ 2 < x ^ 2"}, {"line": "case inl =>\n    exact pow_lt_pow_left\u2080 (sin_lt hx\u2080)\n      (sin_nonneg_of_nonneg_of_le_pi hx\u2080.le (by linarith [two_le_pi])) (by simp)", "tactic_state": "case inr\nx\u271d\u00b9 x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\nhx\u2080 : 0 < x\nhx\u03c0 : 1 < x\n\u22a2 sorry ^ 2 < x ^ 2"}, {"line": "case inr =>\n    exact (sin_sq_le_one _).trans_lt (by rwa [one_lt_sq_iff\u2080 hx\u2080.le])", "tactic_state": "No Goals!"}]}
{"declaration": "lemma sin_sq_le_sq : sin x ^ 2 \u2264 x ^ 2 := by\n  rcases eq_or_ne x 0 with rfl | hx\n  case inl => simp\n  case inr => exact (sin_sq_lt_sq hx).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\n\u22a2 sorry ^ 2 \u2264 x ^ 2"}, {"line": "rcases eq_or_ne x 0 with rfl | hx", "tactic_state": "case inl\nx\u271d : Sort u_1\nsin : x\u271d\n\u22a2 sorry ^ 2 \u2264 0 ^ 2\n---\ncase inr\nx : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\n\u22a2 sorry ^ 2 \u2264 x ^ 2"}, {"line": "case inl => simp", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\nsin : x\u271d\nhx : x \u2260 0\n\u22a2 sorry ^ 2 \u2264 x ^ 2"}, {"line": "case inr => exact (sin_sq_lt_sq hx).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_sub_sq_div_two_le_cos : 1 - x ^ 2 / 2 \u2264 cos x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  case inl => simp\n  case inr => exact (one_sub_sq_div_two_lt_cos hx).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\n\u22a2 1 - x ^ 2 / 2 \u2264 sorry"}, {"line": "rcases eq_or_ne x 0 with rfl | hx", "tactic_state": "case inl\nx\u271d : Sort u_1\ncos : x\u271d\n\u22a2 1 - 0 ^ 2 / 2 \u2264 sorry\n---\ncase inr\nx : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nhx : x \u2260 0\n\u22a2 1 - x ^ 2 / 2 \u2264 sorry"}, {"line": "case inl => simp", "tactic_state": "case inr\nx : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nhx : x \u2260 0\n\u22a2 1 - x ^ 2 / 2 \u2264 sorry"}, {"line": "case inr => exact (one_sub_sq_div_two_lt_cos hx).le", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_sub_mul_le_cos (hx\u2080 : 0 \u2264 x) (hx : x \u2264 \u03c0 / 2) : 1 - 2 / \u03c0 * x \u2264 cos x := by\n  simpa [sin_pi_div_two_sub, mul_sub, div_mul_div_comm, mul_comm \u03c0, pi_pos.ne']\n    using mul_le_sin (x := \u03c0 / 2 - x) (by simpa) (by simpa)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nhx\u2080 : 0 \u2264 x\nhx : x \u2264 \u03c0 / 2\n\u22a2 1 - 2 / \u03c0 * x \u2264 sorry"}, {"line": "simpa [sin_pi_div_two_sub, mul_sub, div_mul_div_comm, mul_comm \u03c0, pi_pos.ne']\n    using mul_le_sin (x := \u03c0 / 2 - x) (by simpa) (by simpa)", "tactic_state": "No Goals!"}]}
{"declaration": "lemma one_add_mul_le_cos (hx\u2080 : -(\u03c0 / 2) \u2264 x) (hx : x \u2264 0) : 1 + 2 / \u03c0 * x \u2264 cos x := by\n  simpa using one_sub_mul_le_cos (x := -x) (by linarith) (by linarith)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "x \u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nhx\u2080 : -(\u03c0 / 2) \u2264 x\nhx : x \u2264 0\n\u22a2 1 + 2 / \u03c0 * x \u2264 sorry"}, {"line": "simpa using one_sub_mul_le_cos (x := -x) (by linarith) (by linarith)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem le_tan {x : \u211d} (h1 : 0 \u2264 x) (h2 : x < \u03c0 / 2) : x \u2264 tan x := by\n  rcases eq_or_lt_of_le h1 with (rfl | h1')\n  \u00b7 rw [tan_zero]\n  \u00b7 exact le_of_lt (lt_tan h1' h2)\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\nh1 : 0 \u2264 x\nh2 : x < \u03c0 / 2\n\u22a2 x \u2264 sorry"}, {"line": "rcases eq_or_lt_of_le h1 with (rfl | h1')", "tactic_state": "case inl\n\u03c0 : \u211d\nx\u271d : Sort u_1\ntan : x\u271d\nh1 : 0 \u2264 0\nh2 : 0 < \u03c0 / 2\n\u22a2 0 \u2264 sorry\n---\ncase inr\n\u03c0 : \u211d\nx\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\nh1 : 0 \u2264 x\nh2 : x < \u03c0 / 2\nh1' : 0 < x\n\u22a2 x \u2264 sorry"}, {"line": "\u00b7 rw [tan_zero]", "tactic_state": "case inr\n\u03c0 : \u211d\nx\u271d : Sort u_1\ntan : x\u271d\nx : \u211d\nh1 : 0 \u2264 x\nh2 : x < \u03c0 / 2\nh1' : 0 < x\n\u22a2 x \u2264 sorry"}, {"line": "\u00b7 exact le_of_lt (lt_tan h1' h2)", "tactic_state": "No Goals!"}]}
{"declaration": "theorem cos_le_one_div_sqrt_sq_add_one {x : \u211d} (hx1 : -(3 * \u03c0 / 2) \u2264 x) (hx2 : x \u2264 3 * \u03c0 / 2) :\n    cos x \u2264 (1 : \u211d) / \u221a(x ^ 2 + 1) := by\n  rcases eq_or_ne x 0 with (rfl | hx3)\n  \u00b7 simp\n  \u00b7 exact (cos_lt_one_div_sqrt_sq_add_one hx1 hx2 hx3).le\n", "file": "/root/DuelModelResearch/mathlib4/Mathlib/Analysis/SpecialFunctions/Trigonometric/Bounds.lean", "context": {"open": ["Set"], "variables": ["{x : \u211d}"]}, "tactic_states": [{"line": "(initial)", "tactic_state": "\u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nx : \u211d\nhx1 : -(3 * \u03c0 / 2) \u2264 x\nhx2 : x \u2264 3 * \u03c0 / 2\n\u22a2 sorry \u2264 1 / \u221a(x ^ 2 + 1)"}, {"line": "rcases eq_or_ne x 0 with (rfl | hx3)", "tactic_state": "case inl\n\u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nhx1 : -(3 * \u03c0 / 2) \u2264 0\nhx2 : 0 \u2264 3 * \u03c0 / 2\n\u22a2 sorry \u2264 1 / \u221a(0 ^ 2 + 1)\n---\ncase inr\n\u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nx : \u211d\nhx1 : -(3 * \u03c0 / 2) \u2264 x\nhx2 : x \u2264 3 * \u03c0 / 2\nhx3 : x \u2260 0\n\u22a2 sorry \u2264 1 / \u221a(x ^ 2 + 1)"}, {"line": "\u00b7 simp", "tactic_state": "case inr\n\u03c0 : \u211d\nx\u271d : Sort u_1\ncos : x\u271d\nx : \u211d\nhx1 : -(3 * \u03c0 / 2) \u2264 x\nhx2 : x \u2264 3 * \u03c0 / 2\nhx3 : x \u2260 0\n\u22a2 sorry \u2264 1 / \u221a(x ^ 2 + 1)"}, {"line": "\u00b7 exact (cos_lt_one_div_sqrt_sq_add_one hx1 hx2 hx3).le", "tactic_state": "No Goals!"}]}
